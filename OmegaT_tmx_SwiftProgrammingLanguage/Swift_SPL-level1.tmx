<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="3.6.0_1_r8695:8697" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>(A generic version of these functions is defined below.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これらの関数の総称体版は、下で定義されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A literal value is a value that appears directly in your source code, such as 42 and 3.14159 in the examples below.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（リテラル値「文字通りの値」は、直接あなたのソース・コードで見かける値です、例えば下の例での42と3.14159）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(For more information about capturing values in a closure, see Capturing Values.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（クロージャにおいて値を捕獲することに関する詳細は、値を捕獲するを見てください。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In the swapTwoValues(_:_:) example above, T was replaced with Int the first time the function was called, and was replaced with String the second time it was called.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（上のswapTwoValues(_:_:)の例では、Tは関数が呼ばれた最初の時にIntと取り替えられて、それが呼ばれた２番目の時にStringと取り替えられました）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It can’t contain anything else, such as a Bool value or a String value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> （それは、他の何か、例えばBool値またはString値などを含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It is assumed that all media items, including all movies and songs, will have a name.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（全ての映画と歌を含む、全てのメディア項目が名前を持つと仮定されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Neither stylistic tweak is strictly necessary, but they lead to neater code.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（文体の微調整は絶対に必要な訳ではありません、しかしそれはすっきりしたコードにつながります。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Nested tuples are allowed.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（入れ子にされたタプルは、認められます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that these type methods can access the highestUnlockedLevel type property without your needing to write it as LevelTracker.highestUnlockedLevel.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これらの型メソッドは、あなたがそれをLevelTracker.highestUnlockedLevelと書かなくても、highestUnlockedLevel型プロパティにアクセスできる点に注意してください）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Swift reports an error at compile-time if a protocol requirement is not fulfilled.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（プロトコル要件が満たされないならば、スウィフトは実行時にエラーを報告します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The name property is an optional String property, and so it automatically receives a default value of nil, even though this value is not written in the code.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（nameプロパティはオプショナルのStringプロパティです、なのでそれは自動的に省略時の値のnilを受け取ります、たとえこの値がそのコードに書かれないとしてもです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The dice property is declared as a constant property because it does not need to change after initialization, and the protocol only requires that it is gettable.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（diceプロパティは定数プロパティとして宣言されます、なぜなら、それが初期化の後に変化する必要がなく、そして、プロトコルはそれが取得可能なことを必要とするだけであるからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The Boolean return value of advance(to:) is ignored, because the level is known to have been unlocked by the call to LevelTracker.unlock(_:) on the previous line.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（advance(to:)のブールの戻り値は無視されます、なぜなら、このレベルは前の行でLevelTracker.unlock(_:)呼び出しによってすでに錠を開けられていると分かるからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The examples below are based on 8-bit signed integers for simplicity, but the same principles apply for signed integers of any size.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（下の例は、単純さのために8ビット符号つき整数に基づきます、しかし同じ原理はあらゆるサイズの符号つき整数に当てはまります）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The examples of modifying an inherited property’s default value in a subclass initializer have been moved to the Initialization chapter.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（サブクラスのイニシャライザの継承されたプロパティの省略時の値を修正する例は章初期化に移動されました。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The expression number % 10 gives a value of 6 for 16, 8 for 58, and 0 for 510.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（式数number % 10は、16のために6、58のために8、510のために0の値を与えます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The parameters to functions and closures are always constants.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（関数およびクロージャに対するパラメータは常に定数です。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The same is not true for structures and enumerations, because they are always copied when they are assigned to a constant or variable, or passed to a function.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（同じことは構造体と列挙にあてはまりません、なぜなら、それらが値型であって、それらが定数または変数に代入されるか関数に渡される時に、常にコピーされるからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This raw Int value is not used for the Jack, Queen, King, and Ace cards.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（この生のInt値は、ジャック、クイーン、キング、そしてエース・カードには使われません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unlike Objective-C categories, Swift extensions do not have names.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Objective-Cカテゴリーとは異なり、スウィフト拡張には、名前がありません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// "Apple International" is not the real airport for APL, so delete it</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「アップル・インターナショナル」は、APLのための本当の空港ではないので、それを削除します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// "Imagination is more important than knowledge" - Einstein</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「想像は知識より重要です」 - アインシュタイン）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// "Maple Syrup" is now the first item in the list</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「メープルシロップ」が、現在はリストの最初の項目です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// "Voulez-vous un café?" using LATIN SMALL LETTER E WITH ACUTE</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「Voulez-vous un café?」は揚音付きラテン小文字eを使用している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// "Voulez-vous un café?" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「Voulez-vous un café?」はラテン小文字eと揚音アクセント結合を使用している）&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// "required" from SomeProtocol conformance; "override" from SomeSuperClass</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（SomeProtocol準拠からの「required」；SomeSuperClasからの「override」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 1 times 5 is 5</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（１かける５は、５です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 2 times 5 is 10</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（２かける５は、10です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 3 times 5 is 15</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（３かける５は、15です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 4 times 5 is 20</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（４かける５は、20です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 5 times 5 is 25</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（５かける５は、25です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A 12-sided dice</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ひとつの12面のさいころ遊び）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A game of Snakes and Ladders with 25 squares</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（25ますのヘビとはしごのゲーム）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A game of Snakes and Ladders with 25 squares:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（25ますのヘビとはしごのゲーム：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A hamster named Simon</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（サイモンという名前のハムスター）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// APL has now been removed from the dictionary</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（APLは、現在この辞書から削除されました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// About to set totalSteps to 200</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（totalStepsを200に設定している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// About to set totalSteps to 360</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（totalStepsを360に設定している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// About to set totalSteps to 896</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（totalStepsを896に設定している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Added 160 steps</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（160の歩数が加えられた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Added 200 steps</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（200の歩数が加えられた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Added 536 steps</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（536の歩数が加えられた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// All items match, so return true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（全ての項目が合致、なのでtrueを返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Apply f to create an array of Number instances with integer values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（fを適用して整数値を持つNumberインスタンスからなる配列を作成する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Area is 12.5663708</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（面積は、12.5663708です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Area is 243610.0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（面積は、243610.0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// AutomaticCar: traveling at 35.0 miles per hour in gear 4</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（AutomaticCar: 時速35.0マイル、４速ギアで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Baking Powder</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（膨らし粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Bananas</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（バナナ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Bicycle: 2 wheel(s)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（自転車: ２輪）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Bicycle: traveling at 15.0 miles per hour</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（自転車：時速15マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Bind x and y to the elements of point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（xとyをpointの要素へ束縛します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// BlackjackCard properties and methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（BlackjackCardのプロパティとメソッド）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Car: traveling at 25.0 miles per hour in gear 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Car: ３速ギアで時速25.0マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Check each pair of items to see if they are equivalent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（各項目の対をそれらが等しいかどうか見るため調べる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Check that both containers contain the same number of items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（両方のコンテナが同じ数の項目を含むことを確認する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Counting to zero:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ゼロまで数えます：」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Do something three times.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（３回何かをします。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Fall back to earlier iOS and macOS APIs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（以前のiOSとmacOS APIに後退する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// First release</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（最初のリリース）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Flour</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（小麦粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Hello, Alex!</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（よろしく、アレックス！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Hello, Anna!</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（よろしく、アンナ！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Hello, Brian!</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（よろしく、ブライアン！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Hello, Jack!</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（よろしく、ジャック！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Hello, Michael</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（こんにちは、マイケル）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Here's how you call this function with a trailing closure instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（あなたが代わりに後付クロージャでどのようにこの関数を呼ぶのかがここにあります：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Here's how you call this function without using a trailing closure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（あなたが後付クロージャを使うことなくどのようにこの関数を呼ぶのかがここにあります：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// If you omit the second argument when calling this function, then</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（あなたが２番目の引数をこの関数を呼び出すときに省略したならば、その時）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// In the function body, firstParameterName and secondParameterName</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（関数本文において、firstParameterNameとsecondParameterNameは、）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// In the function body, parameterName refers to the argument value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（関数本文において、parameterNameは）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Int8 cannot store a number larger than its maximum value,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Int8はその最大の値より大きい数を保存することができません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Item 1: Six eggs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（項目１：６つの卵）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Item 2: Milk</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（項目２：牛乳）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Item 3: Flour</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（項目３：小麦粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Item 4: Baking Powder</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（項目４：膨らし粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Item 5: Bananas</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（項目５：バナナ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Make a local copy and manually copy it back.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ローカルコピーを作って手動でそれを元へコピーする）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Match only non-nil values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（nilでない値にのみマッチする）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Match using an enumeration case pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（列挙ケース節パターンを使っているマッチ。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Match using an optional pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（オプショナルパターンを使っているマッチ。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Milk</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（牛乳）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Movie: Casablanca, dir. Michael Curtiz</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（映画：『カサブランカ』（監）マイケル・カーティス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Movie: Citizen Kane, dir. Orson Welles</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（映画：『市民ケーン』（監）オーソン・ウェルズ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Now t is (20, 20, 30)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（tは、現在 (20, 20, 30)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Operate on localX asynchronously, then wait before returning.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（非同期にlocalXを処理を施す、それから返すまえに待機する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Overload the ~= operator to match a string with an integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（~=演算子をオーバーロードして文字列を整数と照合するようにする。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Person 1 is called Anna</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（人物は１、アンナと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Person 2 is called Alex</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（人物２は、アレックスと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Person 3 is called Brian</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（人物３は、ブライアンと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Person 4 is called Jack</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（人物４は、ジャックと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints ""123" has an integer value of 123"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「"123" has an integer value of 123」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "(1, -1) is on the line x == -y"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「(1, -1)は、x == -yの線上にある」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "(1, 1) is inside the box"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「(1, 1）は、この四角の中にあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "(1, 2) is near the origin."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「（1, 2）は原点に近いです。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "10"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「10」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "27"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「27」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "3 to the power of 10 is 59049"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「３の10乗は、59049です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "6 mansion scenes; 2 cell scenes"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「６つの邸宅場面；２つの僧房場面」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "6"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「6」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "7"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「７」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "some default text"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「some default text」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "&lt;p&gt;hello, world&lt;/p&gt;"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「&lt;p&gt;よろしく、世界&lt;/p&gt;」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "A 12-sided dice"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ひとつの12面さいころ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "A game of Snakes and Ladders with 25 squares"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「25ますのヘビとはしごのゲーム」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "A hamster named Simon"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「サイモンという名前のハムスター」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "A marathon is 42195.0 meters long"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「マラソンは、42195.0メートルの長さです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "A new player has joined the game with 100 coins"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「新しいプレーヤーが、100のコインを持ってゲームに参加しました」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "ACCESS DENIED"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「アクセス拒否」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "All items match."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「全ての項目が一致する」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "An animal was initialized with a species of Giraffe"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「一匹の動物がキリンの種族で初期化された」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "An implicitly unwrapped optional string."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「暗黙的にアンラップされるオプショナルの文字列。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "And another one: 0.729023776863283"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「さらにもう一つ：0.729023776863283」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "And here's a random Boolean: true"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「そしてここに任意のブール: trueがあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Another value."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「別の値。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Apartment 4A is being deinitialized"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「アパート4Aは、デイニシャライズされた」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Bonjour!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「Bonjour!」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Canada's capital city is called Ottawa"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「カナダの首都はオタワです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Card #1234567890123456 is being deinitialized"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「カード#1234567890123456は、デイニシャライズされた」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Choo Choo"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「シュッシュッ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Collected 2 closures."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「２つのクロージャが集められた。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Do you like cheese?"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「あなたはチーズが好きですか？」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Eww, turnips are horrible."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「うー、カブ怖い。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Happy birthday, Malcolm, you're 21!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「誕生日おめでとうマルコム、あなたは21です！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Hello Jane!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「こんにちはジェーン！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Hello John!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「こんにちはジョン！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Hello again, Anna!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「またあったね、アンナ！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Hello again, Tim!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「またあったね、ティム！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Hello, Anna!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「こんにちは、アンナ！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Hello, Brian!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「こんにちは、ブライアン！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Here's a random number: 0.37464991998171"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ここに任意の数: 0.37464991998171があります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "How about beets?"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「赤かぶはどう？」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "I have 3 favorite music genres."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「私には大好きな音楽ジャンルが３つあります。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "I have particular music preferences."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「私には特定の音楽の好みがあります。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "I hope the weather is nice in Cupertino."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「クパチーノの天気がいいことを望むよ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "I hope the weather is nice near you."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「あなたの近くの天気がいいといいね」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Insufficient funds. Please insert an additional 2 coins."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「金額が不足しています。さらに２コイン入れてください。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "It was not possible to print the number of rooms."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「部屋の数を出力することは、可能ではありませんでした。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "It was not possible to set the address."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「住所を設定することは、可能ではありませんでした。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "It's not that cold. Wear a t-shirt."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「そんなに寒くありません。Tシャツを着てください。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "It's really warm. Don't forget to wear sunscreen."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「非常に暖かいです。日焼け止めを塗るのを忘れないでください。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "It's too funky in here."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「そりゃここじゃfunkyすぎる。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "It's very cold. Consider wearing a scarf."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「非常に寒いです。スカーフを巻くことを考えてください。 」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Item: sock, quantity: 2"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「項目：靴下、数量：２」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "John Appleseed is being deinitialized"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「John Appleseedは、デイニシャライズされた」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "John Appleseed is being initialized"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「John Appleseedは、初期化された」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "John's building identifier begins with "The"."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ジョンの建物名は「月」で始まります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "John's building identifier is The Larches."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ジョンの建物名は月桂樹です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "John's residence has 1 room(s)."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ジョンの邸宅には１部屋ある」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "John's street name is Laurel Street."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ジョンの街路名は月桂樹通りです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Media library contains 2 movies and 3 songs"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「情報媒体書庫は、２つの映画と３つの歌を含みます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Mostly harmless"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「おおむね無害」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Nothing to see here"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ここで見るものは何も無し」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Now serving Alex!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（今アレックスに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Now serving Barry!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（今バリーに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Now serving Daniella!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（今ダニエラに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Now serving Ewa!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（今エヴァに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "On an axis, 9 from the origin"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ある軸上で、原点から９」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "One inch is 0.0254 meters"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「１インチは、0.0254メートルです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "PlayerOne has left the game"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「PlayerOneは、ゲームを離れました」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "PlayerOne won 2000 coins &amp; now has 2100 coins"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「PlayerOneは2000のコインを獲得＆現在2100のコインを持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "QR code: ABCDEFGHIJKLMNOP."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「QRコード：ABCDEFGHIJKLMNOP。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Result: 5"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「結果：５」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Result: 6"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「結果：６」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Result: 8"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「結果：８」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Rock? I'm over it."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「Rock？ もう済んだことさ（曲名？）。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Some value."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ある値。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "SomeSubClass"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「 SomeSubClass 」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The airports dictionary contains 2 items."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「airports辞書は２項目を含む。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The airports dictionary is not empty."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「airports辞書は空ではない。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The anonymous creature could not be initialized"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「不明な生き物は初期化されることができませんでした」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The bank now has 10000 coins"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「胴元には現在10000コインがあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The bank now only has 7900 coins left"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「胴元には現在7900個のコインだけが残っています」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The current value of friendlyWelcome is Bonjour!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「The current value of friendlyWelcome is Bonjour!」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The default temperature is 32.0° Fahrenheit"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「省略時の温度は華氏32.0°です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The dynamic and static type of someInstance are different"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「someInstanceの動的な型と静的な型は、異なります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The first number is 10."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「最初の数は、10です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The first room name is Living Room."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「最初の部屋名は、居間です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The frameRate property of tenEighty is now 30.0"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「tenEightyのframeRateプロパティは、現在は30.0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The index of llama is 2"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ラマのインデックスは、２です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The integer value of 三 is 3."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「三の整数値は３です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The name of the airport is Dublin Airport."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「空港名は「ダブリン空港です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The number 5 is a prime number, and also an integer."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「数５は素数で、そのうえ整数です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The number of edits is 3"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「編集数は、３です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The old value for DUB was Dublin."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「DUBの古い値は「ダブリンでした。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The point is at (1, 2)."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「pointは（1, 2）です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The point is at (3, 2)."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「pointは（3, 2）です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The point is now at (3.0, 4.0)"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ポイントは現在は(3.0, 4.0)です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The remembered direction is still .west"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「記憶されている方位は、依然として.westです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The removed airport's name is Dublin Airport."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「削除された空港の名前はダブリンです。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The second number is 42."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（２番目の数は、42です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The shopping list contains 2 items."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「買い物リストは２つの項目を含みます。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The shopping list is not empty."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「買い物リストは空ではありません。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The status code is 200"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「状態コードは200です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The status code is 404"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「状態コードは404です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The status message is Not Found"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「状態メッセージが見つかりません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The status message is OK"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「状態メッセージはOKです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The top item on the stack is tres."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「このスタックの一番上の項目はtresです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The width of someResolution is 0"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「someResolutionの幅は0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The width of someVideoMode is 0"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「someVideoModeの幅は0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The width of someVideoMode is now 1280"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「someVideoModeの幅は、現在は1280です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "There are 5 scenes in Act 1"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「５つの場面が一幕にあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "There are dozens of moons orbiting Saturn."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「土星の軌道を回るたくさんの月がある。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "There are now 9900 coins left in the bank"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「現在9900個のコインが胴元に残されます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "There isn't a planet at position 11"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「位置11に惑星は存在しない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "These two characters are not equivalent."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「これら２つの文字列は等しくない。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "These two strings are considered equal"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「これら２つの文字列は等しいと考えられる」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "These two vectors are equivalent."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「これらの２つのベクトルは等しいです。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "This is a defined temperature unit, so initialization succeeded."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「これは定義済み温度単位です、なので初期化は成功しました。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "This is not a defined temperature unit, so initialization failed."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「これは定義済み温度単位ではありません、なので初期化は失敗しました。」を出力します」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "This point is to the right of the line where x == 1.0"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「この点は線x == 1.0の右にある」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Three feet is 0.914399970739201 meters"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「３フィートは、0.914399970739201メートルです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Unable to initialize one unnamed product"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「１個の名前のない製品を初期化できません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Unable to initialize zero shirts"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「０個のシャツを初期化できません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Unable to retrieve the address."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「住所を取り出すことができない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Unable to retrieve the first room name."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「最初の部屋名を取り戻すことができない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Unable to retrieve the number of rooms."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「部屋の数を取り出すことができない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Watch out for penguins"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ペンギンに気をつけろ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Welcome!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「歓迎します！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「[マーレイという名のハムスター, モーガンという名のハムスター, モーリスという名のハムスター]」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "cinema is now 2048 pixels wide"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「cinemaは、現在2048のピクセルの幅です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "convertedNumber contains some integer value."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「convertedNumberは、何らかの整数値を持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "convertedNumber has an integer value of 123."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「convertedNumberは、整数値123を持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "data.txt"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「data.txt」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "e is a vowel"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「eは、母音です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "false"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「false」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "hd is still 1920 pixels wide"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「hdは、依然として1920のピクセルの幅です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "hello, world"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「よろしく、世界」を出力ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "hello, world", because name is indeed equal to "world".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「hello, world」を出力します、nameが確かに「world」と等しいので。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "highest unlocked level is now 2"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「最も高い鍵の開いたレベルは現在２です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "letters is of type Set&lt;Character&gt; with 0 items."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「lettersは型Set&lt;Character&gt;で０項目を持ちます。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "level 6 has not yet been unlocked"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「レベル６はまだ開錠されていません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "min is -6 and max is 109"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「最小は-6で、最大は109です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "on the x-axis with an x value of 2"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「２のxの値でx-軸の上」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "p is being deinitialized"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「pは、デイニシャライズされている」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "six times three is 18"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「６かける３は18です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "someInt is now 107, and anotherInt is now 3"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「someIntは今は107、anotherIntは今は３です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "someInts is of type [Int] with 0 items."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「someIntsは型[Int]で0項目を持ちます。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "square.origin is now at (10.0, 10.0)"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「square.originは、現在(10.0, 10.0)です」を出力します））</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "tenEighty and alsoTenEighty refer to the same VideoMode instance."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「tenEightyとalsoTenEightyは、同じVideoModeインスタンスに言及します。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "the number of characters in cafe is 4"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「cafeの文字数は4です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "the number of characters in café is 4"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「caféの文字数は4です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "the volume of fourByFiveByTwo is 40.0"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「fourByFiveByTwoのボリュームは、40.0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "theAceOfSpades: suit is ♠, value is 1 or 11"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「theAceOfSpades: 組み札は♠、値は１または11です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "true"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「true」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "unusualMenagerie has 40 characters"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「unusualMenagerieは、40の文字を持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Random dice roll is 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（無作為にさいころを転がして、３です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Random dice roll is 4</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（無作為にさいころを転がして、４です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Random dice roll is 5</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（無作為にさいころを転がして、５です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Reimplement the Swift standard library's optional type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（スウィフト標準ライブラリのオプショナル型の再実装）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Return the appropriate value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（適切な値を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Rolled a 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（３を出した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Rolled a 4</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（４を出した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Rolled a 5</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（５を出した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Six eggs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（卵６つ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Something that doesn't have an area</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（面積を持たない何か）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Song: Blue Suede Shoes, by Elvis Presley</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（歌：『青い裏革靴』、エルヴィス・プレスリー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Song: Never Gonna Give You Up, by Rick Astley</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（歌：『諦めないで』、リック・アストリー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Song: The One And Only, by Chesney Hawkes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（歌：『唯一無二の』、チェズニー・ホークス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Started a new game of Snakes and Ladders</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ヘビとはしごの新しいゲームを始める）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Subsequent release renames MyProtocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（続くリリースでMyProtocolに改名する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Tandem: traveling at 22.0 miles per hour</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（２人乗り：時速22.0マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The compile-time type of someInstance is SomeBaseClass,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someInstanceのコンパイル時での型は、SomeBaseClassです、）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The following dictionaries have the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（以下の宣言は同じ型を持ちます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The game is using a 6-sided dice</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ゲームは、６面のさいころを使っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The game lasted for 4 turns</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ゲームは、４回続きました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This code isn't valid.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（このコードは有効ではありません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This is a comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>//（これはコメントです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This is a compile-time error: languageName cannot be changed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これはコンパイル時エラーです：anguageNameは変わることができません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This is not valid, because x = y does not return a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは有効ではありません、x = yが値を返さないので。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This will report a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは、コンパイル時エラーを報告します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Type annotation is required because String has multiple initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（型注釈は必須です、なぜならStringは複数のイニシャライザを持つからです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// UInt8 cannot store negative numbers, and so this will report an error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（UInt8は負の数を保存することができません、それでこれはエラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（iOS 10 APIをiOSで、macOS 10.12 APIをmacOSで使う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Vehicle: 0 wheel(s)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（乗り物: ０輪）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Vehicle: traveling at 0.0 miles per hour</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Vehicle: 時速0.0マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Weak capture of "self.parent" as "parent"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「parent」としての弱いキャプチャ「self.parent」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Work with the file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ファイル処理。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a is "test", b is 12, c is 3, and 9.45 is ignored</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（aは「test」です、bは12です、cは３です、そして9.45は無視されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a is now equal to 10</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（aは今は10と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a is now equal to 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（aは現在、３と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a movie called Ghostbusters, dir. Ivan Reitman</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（『ゴーストバスターズ』と呼ばれる映画、監督アイヴァン・ライトマン）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a positive double value of 3.14159</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（正の浮動小数点の値の3.14159）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a string value of "hello"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（文字列値の「よろしく」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// afterDoubling also has values of (2.0, 8.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（afterDoublingも(2.0, 8.0)の値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// alsoPositive is a Vector2D instance with values of (3.0, 4.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（alsoPositiveは、値(-3.0, -4.0)をもつVector2Dインスタンです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// an (x, y) point at 3.0, 5.0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（3.0、5.0の(x, y)座標点）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// an error was thrown</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（エラーがスローされた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// an integer value of 42</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（整数値の42）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// and so this will also report an error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（それでこれも同様にエラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// and the runtime type of someInstance is SomeSubClass</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（そしてsomeInstanceの実行時での型は、SomeSubClassです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// anonymousCreature is of type Animal?, not Animal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（anonymousCreatureは、型Animal?です、Animalではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（anotherMathFunctionは、型(Int, Int) -&gt; Intであると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// anotherPi is also inferred to be of type Double</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（anotherPiもまたDouble型であると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（anotherThreeDoublesは、型[Double]で、[2.5, 2.5, 2.5]に等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ants have 6 legs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（蟻は、６本の足を持っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（centerRectの原点は(0.0, 0.0)、そのサイズは(0.0, 0.0)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// boilingPointOfWater.temperatureInCelsius is 100.0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（boilingPointOfWater.temperatureInCelsiusは、100.0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// cap the new audio level to the threshold level</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（新しい音声レベルを限界レベルに制限する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// cats have 4 legs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（猫は、４本の足を持っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（centerRectの原点は(2.5, 2.5)、そのサイズは(3.0, 3.0)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// class definition goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（クラス定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// class-only protocol definition goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（クラス専用プロトコル定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// close(file) is called here, at the end of the scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（close(file)がここで呼ばれます、このスコープの終わりで。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// closure body goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（クロージャ本文が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// closure's body goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（クロージャの本文がここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// combinedVector is a Vector2D instance with values of (5.0, 5.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（combinedVectorは(5.0, 5.0)の値をもつVector2Dインスタンスです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// conformance to the Container protocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Containerプロトコルに準拠）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// convertedNumber is inferred to be of type "Int?", or "optional Int"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（convertedNumberは、型「Int?」または「オプショナルのInt」であると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a default value for someProperty inside this closure</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（このクロージャの内側でsomePropertyのための省略時の値をつくる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（customersInLine（並んでいる顧客）は、["Alex", "Ewa", "Barry", "Daniella"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// customersInLine is ["Barry", "Daniella"]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（customersInLine（並んでいる顧客）は、["Barry", "Daniella"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// customersInLine is ["Ewa", "Barry", "Daniella"]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（customersInLine（並んでいる顧客）は、["Ewa", "Barry", "Daniella"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// diceRoll will move us beyond the final square, so roll again</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（diceRollは私たちを最後の正方形を越えて動かします、それで再度転がします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// diceRoll will move us to the final square, so the game is over</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（diceRollは私たちを最後の正方形に動かします、なのでゲームは終わりです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// discard 'self' and return 'nil'</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「self」を廃棄して「nil」を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// do nothing - an arbitrary vehicle doesn't necessarily make a noise</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（何もしない - ある任意の乗り物が必ず音を出すわけではない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// do something with the instance of 'SomeStruct'</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「SomeStruct」のインスタンスで何か行う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// doubleIndex is an optional Int with no value, because 9.3 is not in the array</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（9.3がこの配列の中にははないので、doubleIndexは値のないオプショナルのIntです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// eAcute is é, combinedEAcute is é</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（eAcuteはéです、combinedEAcuteはéです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// earthsOrder is 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（earthsOrderは、３です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// enumeration definition goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（列挙定義がここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// f is a function of type (Int) -&gt; Number</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（fは型(Int) -&gt; Numberの関数です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// favoriteGenres has been initialized with three initial items</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（favoriteGenresは３つの初期項目で初期化されています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// favoriteGenres now contains 4 items</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（favoriteGenresは現在４項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// firstItem is equal to "Eggs"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（firstItemは、「Eggs」と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// firstItem is now equal to "Six eggs"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（firstItemは、現在「６つの卵」と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// for that parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（そのパラメータのための引数値に言及することができます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// freezingPointOfWater.temperatureInCelsius is 0.0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（freezingPointOfWater.temperatureInCelsiusは、0.0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// friendlyWelcome is now "Bonjour!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（friendlyWelcomeは、現在「Bonjour!」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// fromTheTop is equal to "cuatro", and the stack now contains 3 strings</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（fromTheTopは「cuatro」と等しいです、そしてスタックは現在は３つの文字列を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// function body goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（関数本文が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// function implementation goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（関数実装が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// http404Error is of type (Int, String), and equals (404, "Not Found")</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（http404Errorは、型が(Int, String)です、そして(404, "Not Found")と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// if we're still on the board, move up or down for a snake or a ladder</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（私達がまだ盤上ならば、ヘビまたははしごに対して上／下に移動する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// implementation of protocol requirements goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（プロトコル要件の実装が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// initialization of 'SomeStruct' failed and the initializer returned 'nil'</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「SomeStruct」の初期化は失敗したのでイニシャライザは「nil」を返した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// initializer implementation goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（イニシャライザ実装がここに来ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// instruction now equals "look over there"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（instructionは、現在「あそこを見て」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// integerPi equals 3, and is inferred to be of type Int</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（integerPiは、３に等しく、型Intであると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// it has a dynamic type of SomeSubClass at runtime</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（実行時ではそれは動的型のSomeSubClassを持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// its value is ["OneSix", "FiveEight", "FiveOneZero"]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（その値は["OneSix", "FiveEight", "FiveOneZero"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// john.fullName is "John Appleseed"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（john.fullNameは、「John Appleseed」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// letters is now an empty set, but is still of type Set&lt;Character&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（lettersは現在空の集合です、しかし依然として型Set&lt;Character&gt;です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// letters now contains 1 value of type Character</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（lettersは型Characterの値を１つ持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// lightSwitch is now equal to .on</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（lightSwitchは、現在.onと等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// maxAmplitudeFound is now 0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（maxAmplitudeFoundは、現在0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// meaningOfLife is inferred to be of type Int</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（meaningOfLifeはInt型であると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// message is "3 times 2.5 is 7.5"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（messageは、「３かける2.５は7.５」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// move by the rolled amount</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（振られた量だけ移動）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// move up or down for a snake or ladder</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ヘビまたははしごのための上下移動）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// moveNearerToZero now refers to the nested stepForward() function</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（moveNearerToZeroは、現在は入れ子にされたstepForward()関数に言及します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// moveNearerToZero now refers to the stepBackward() function</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（moveNearerToZeroは、現在はstepBackward()関数に言及します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// mysteryMeat's name is "[Unnamed]"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（nameMeatの名前は「[Unnamed]」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// namedMeat's name is "Bacon"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（nameMeatの名前は「ベーコン」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// namesOfIntegers is an empty [Int: String] dictionary</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（namesOfIntegersは、空の[Int: String]の辞書です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// namesOfIntegers is once again an empty dictionary of type [Int: String]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（namesOfIntegersは、またもとのように型[Int: String]の空の辞書です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// namesOfIntegers now contains 1 key-value pair</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（namesOfIntegersは、現在は１つの「キーと値」の対を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ncc1701.fullName is "USS Enterprise"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ncc1701.fullNameは、USSエンタープライズです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// negative is a Vector2D instance with values of (-3.0, -4.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（negativeは、値(-3.0, -4.0)をもつVector2Dインスタンです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// nested Rank enumeration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（入れ子にされたRank列挙）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// nested Suit enumeration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（入れ子にされたSuit列挙）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// new functionality to add to SomeType goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（SomeTypeに加える新しい機能性が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// no error was thrown</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（エラーはスローされなかった）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（centerRectの原点は (2.0, 2.0)、そのサイズは(5.0, 5.0)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// original IntStack implementation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（元々のIntStack実施）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// original Stack&lt;Element&gt; implementation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（元々のStack&lt;Element&gt;実装）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// original now has values of (4.0, 6.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（originalは、現在(4.0, 6.0)の値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ovenLight is now equal to .high</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ovenLightは現在.hightと等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ovenLight is now equal to .off</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ovenLightは現在.lowと等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// perform a suitable setting action here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ふさわしい設定動作をここで行う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// perform some initialization here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ここで何らかの初期化を行う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// perform the deinitialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（デイニシャライズを実行する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// pi equals 3.14159, and is inferred to be of type Double</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（piは、3.14159に等しく、型Doubleであると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// pi is inferred to be of type Double</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（パイはDouble型であると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（plusMinusVectorはVector2Dインスタンスで(4.0, -2.0)の値をもちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// possiblePlanet is of type Planet? and equals Planet.uranus</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（possiblePlanetは、型Planet?で、Planet.uranusに等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// potentialOverflow equals 32767, which is the maximum value an Int16 can hold</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（potentialOverflowは32767と等しく、それはInt16が持つことができる最大限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// precomposed is 한, decomposed is 한</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（合成済は「한」, 分解したものは「한」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// print(protocolValue.anotherProperty)  // Uncomment to see the error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>// print(protocolValue.anotherProperty)  // コメントを外すとエラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// prints "hello, world" and returns a value of 12</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「よろしく、世界」を出力して値12を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// prints "hello, world" but does not return a value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「よろしく、世界」を出力しますが値を返しません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// produces an optional instance of 'SomeStruct'</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「SomeStruct」のオプショナルインスタンスを生成します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// protocol definition</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（プロトコル定義）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// protocol definition goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（プロトコル定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// refer to the argument values for the first and second parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（最初と２番目のパラメーターに対する引き数の値を参照します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// return an appropriate subscript value here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（適切な添え字値をここで返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns 0, as if you had requested:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（まるであなたが次のように要請したかのように、0を返します：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns 10.0, which is the arithmetic mean of these three numbers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（10.0を返します、それはこれら３つの数の算術平均です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（2を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns 3.0, which is the arithmetic mean of these five numbers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（3.0を返します、それはこれら５つの数の算術平均です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns 5</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（5を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns 7</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（7を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns 9</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（9を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a value of 10</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（値10を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a value of 20</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（値20を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a value of 30</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（値30を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a value of 40</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（値40を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a value of 50</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（値50を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a value of 7</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（値7を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（reversedNamesは["Ewa", "Daniella", "Chris", "Barry", "Alex"]に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// roll the dice</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（さいころを振る）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// rowHeight is equal to 90</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（rowHeightは、90と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// serverResponseCode contains an actual Int value of 404</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（serverResponseCodeは、実際にあるInt値404を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// serverResponseCode now contains no value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（serverResponseCodeは、現在は値を含みません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shoppingList has been initialized with two initial items</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（shoppingListが、２つの最初の項目で初期化された）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shoppingList now contains 3 items, and someone is making pancakes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（shoppingListは現在３つの項目を含みます、そして誰かはパンケーキを作っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shoppingList now contains 4 items</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（shoppingListは、現在４つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shoppingList now contains 5 items, and no apples</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（shoppingListは現在は５つの項目を含みます、そして「リンゴ」は含みません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shoppingList now contains 6 items</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（shoppingListは、現在６つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shoppingList now contains 6 items, and no Maple Syrup</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（shoppingListは、現在６つの項目、メープルシロップ以外を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shoppingList now contains 7 items</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（shoppingListは、現在７つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// signedOverflow equals -128, which is the minimum value an Int8 can hold</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（signedOverflowは-128と等しく、それはInt8が持つことができる最小限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// signedOverflow is now equal to 127</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（signedOverflowは、現在127と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（sixDoublesは、[Double]と推論され、 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]に等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someCreature is of type Animal?, not Animal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someCreatureは、型Animal?です、Animalではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someDictionary is now ["b": [10, 20], "a": [100, 2, 3]]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someDictionaryは、現在["b": [10, 20], "a": [100, 2, 3]]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someDictionary is now ["b": [10, 20], "a": [42, 2, 3]]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someDictionaryは、現在["b": [10, 20], "a": [42, 2, 3]]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someDictionary is still ["b": [10, 20], "a": [1, 2, 3]]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someDictionaryは、依然として["b": [10, 20], "a": [1, 2, 3]]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someFunction takes a closure as its only argument</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someFunctionは、そのただ一つの引数としてクロージャをとります）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someFunction takes an integer and a closure as its arguments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someFunctionは、その引数として整数とクロージャをとります）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someFunctionWithSideEffects is evaluated and returns 42</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someFunctionWithSideEffectsは、評価されて42を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someFunctionWithSideEffects is not evaluated</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someFunctionWithSideEffectsは、評価されません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someInstance has a static type of SomeBaseClass at compile time, and</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someInstanceは、コンパイル時ではSomeBaseClassの静的型を持ちます、そして）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someInt is now 107, and anotherInt is now 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someIntは今は107、anotherIntは今は３です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someInt is now 9</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someIntは、現在９です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someInts is now an empty array, but is still of type [Int]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someIntsは、現在は空の配列です、しかし依然として型[Int]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someInts now contains 1 value of type Int</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someIntsは、現在は型Intの値ひとつを含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someString is now "world", and anotherString is now "hello"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someStringは今は「world」、anotherStringは今は「hello」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someValue must be of the same type as SomeType</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someValueは、SomeTypeと同じ型でなければなりません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// spiders have 8 legs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（蜘蛛は、８本の足を持っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// store this as the new overall maximum input level</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これを新しい全体で最大の入力レベルとして保存する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// stringIndex is an optional Int containing a value of 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（stringIndexは、オプショナルのIntで値２を含んでいます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// strings is inferred to be of type [String]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（stringsは型[String]と推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// structure definition goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（構造体定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// subclass definition goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（サブクラス定義がここに来ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// subclass implementation of the required initializer goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（必須イニシャライザのサブクラス実装がここに来ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// subclass initialization goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（サブクラスの初期化が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// sunsetDirection is "west"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（sunsetDirectionは、「west」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// surveyAnswer is automatically set to nil</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（surveyAnswerは、自動的にnilに設定されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the "Dave" array is now [91, 82, 84] and the "Bev" array is now [80, 94, 81]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「Dave」配列は現在[91, 82, 84]です、そして「Bev」配列は現在[80, 94, 81]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the DataImporter class would provide data importing functionality here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（DataImporterクラスは、データをインポートする機能性をここで提供します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the DataImporter instance for the importer property has not yet been created</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（importerプロパティのためのDataImporterインスタンスは、まだ作成されていません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the DataImporter instance for the importer property has now been created</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（importerプロパティのためのDataImporterインスタンスが、今つくられました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the DataManager class would provide data management functionality here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（DataManagerクラスは、データ管理の機能性をここで提供します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the airports dictionary now contains 3 items</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（airports辞書は、現在３つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the apples constant is now equal to the removed "Apples" string</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（apples定数は、現在は削除された文字列「リンゴ」と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the counter's value is now 0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（counterの値は、いま0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the counter's value is now 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（counterの値は、いま１です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the counter's value is now 6</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（counterの値は、いま６です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the first item in the list is now equal to "Six eggs" rather than "Eggs"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（リストの中の最初の項目は、現在「６つの卵」と等しいです、「卵」ではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the initial counter value is 0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（counterの最初の値は、0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the item that was at index 0 has just been removed</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（インデックス0であった項目が、ちょうど今取り除かれました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the last item in the array has just been removed</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（配列での最後の項目が、ちょうど今取り除かれました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the mapleSyrup constant is now equal to the removed "Maple Syrup" string</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（定数mapleSyrupは、現在は削除された「メープルシロップ」文字列と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the range now represents integer values 6, 7, and 8</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（範囲は、現在は整数値６、７、そして８を表します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the range represents integer values 0, 1, and 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（範囲は、整数値０、１、そして２を表します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the stack now contains 4 strings</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（スタックは、現在４つの文字列を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the type of "library" is inferred to be [MediaItem]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「library」の型は、[MediaItem]であると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the value for "LHR" has been changed to "London Heathrow"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「LHR」に対する値は、「ロンドン・ヒースロー」に変えられました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the value of parameterWithDefault is 12 inside the function body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（parameterWithDefaultの値はこの関数本文の内部で12です。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// these two strings are both empty, and are equivalent to each other</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これらの２つの文字列は両方とも空で、お互いに等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this causes an error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは、エラーを引き起こします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this causes the assertion to trigger, because age is not &gt;= 0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは表明の起動を引き起こします、age &gt;= 0でないので）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this equals 17</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは17に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this example will compile successfully</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（この例は、うまくコンパイルします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this example will not compile, and will report an error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（この例はコンパイルせず、エラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this function may or may not throw an error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（この関数はエラーをスローするかもしれないししないかもしれない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this initializer creates a document with a nil name value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（このイニシャライザはnilのname値を使って書類を作成します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this initializer creates a document with a nonempty name value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（このイニシャライザは空でないname値を使って書類を作成します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this is a valid move, so find out its effect</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは有効な動きです、それでその効果を調べます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this range represents integer values 0, 1, 2, and 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（この範囲構造体、整数値０、１、２、そして３を表します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this reports a compile-time error - a constant string cannot be modified</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これはコンパイル時エラー - 定数文字列は修正できません、を報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this reports a compile-time error - argument labels are required</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これはコンパイル時エラーを報告します - 引数ラベルが必要とされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this triggers a runtime error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは、実行時エラーの引き金となります）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this triggers an assert, because [2, 2] is outside of the matrix bounds</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これはある表明の引き金となります、なぜなら [2, 2]はマトリックス境界の外であるからです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this will report an error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは、エラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this will report an error, even though firstValue is a variable property</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これはエラーを報告します、たとえfirstValueが変数プロパティであるとしてもです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（threeDoublesは、型[Double]で、 [0.0, 0.0, 0.0]に等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// toBeDoubled now has values of (2.0, 8.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（toBeDoubledは、現在(2.0, 8.0)の値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// trailing closure's body goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（後付クロージャの本文がここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// type method implementation goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（型メソッドの実施が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// unsignedOverflow equals 0, which is the minimum value a UInt8 can hold</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（unsignedOverflowは0と等しく、それはUInt8が持つことができる最小限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// unsignedOverflow equals 255, which is the maximum value a UInt8 can hold</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（unsignedOverflowは255に等しく、それはUInt８が持つことができる最大限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// unsignedOverflow is now equal to 0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（unsignedOverflowは、現在0と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// unsignedOverflow is now equal to 255</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（unsignedOverflowは、現在255と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// userDefinedColorName is nil, so colorNameToUse is set to the default of "red"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（userDefinedColorNameはnilです、なのでcolorNameToUseは省略時の「赤」に設定されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// userDefinedColorName is not nil, so colorNameToUse is set to "green"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これはnilではありません、それでcolorNameToUseは「緑」に設定されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// variableString is now "Horse and carriage"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（variableStringは、現在「馬と馬車」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// welcome now equals "hello there!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（welcomeは、現在「やあ！、こんにちは」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// welcome now equals "hello there"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（welcomeは、現在「やあ、こんにちは」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// welcome now equals "hello!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（welcomeは、現在「こんにちは！」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// welcome now equals "hello"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（welcomeは、現在「こんにちは」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// x is 10, and 20 is ignored</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（xは10です、そして20は無視されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// x is equal to 1, and y is equal to 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（xは１と等しい、そしてyは２と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// zero as a Double</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（浮動小数点のゼロ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// zero as an Int</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（整数のゼロ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(3 % 4) is 3, so this is equivalent to:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(3 % 4)は3なので、これは以下に等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(3 * 5) is 15, so this is equivalent to:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(3 * 5)は15なので、これは以下に等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0xFp-2 means 15 x 2-2, or 3.75.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>0xFp-2は、15 × 2-2、または3.75を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0xFp2 means 15 x 22, or 60.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>0xFp2は、15 × 22、または60.0を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.25e-2 means 1.25 x 10-2, or 0.0125.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>1.25e-2は、1.25 × 10-2、または0.0125を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.25e2 means 1.25 x 102, or 125.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>1.25e2は、1.25 × 102、または125.0を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>123456789[0] returns 9</seg>
      </tuv>
      <tuv lang="JA">
        <seg>123456789[0]は9を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>123456789[1] returns 8</seg>
      </tuv>
      <tuv lang="JA">
        <seg>123456789[1]は8を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 times 5 equals 5</seg>
      </tuv>
      <tuv lang="JA">
        <seg>1掛ける5は5に等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2 plus 3 equals 5</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2足す3は5に等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5 remainder 4 equals 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>5割る4の余りは1に等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;= followed by a version number</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&gt;=にバージョン番号が続きます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@autoclosure is now an attribute of the parameter declaration, not its type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@autoclosureは今ではパラメーター宣言の属性です、それの型ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any can represent an instance of any type at all, including function types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Anyは、関数型を含めて、ともかくどんな型のインスタンスでも表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AnyObject can represent an instance of any class type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AnyObjectは、どんなクラス型のインスタンスでも表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bank keeps track of the current number of coins it holds with its coinsInBank property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Bankは、それがそのcoinsInBankプロパティで保持するコインの現在の数の情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C1 must conform to the Container protocol (written as C1: Container).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C1は、Containerプロトコルに準拠しなければなりません（C1: Containerのように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C2 must also conform to the Container protocol (written as C2: Container).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C2もまた、Containerプロトコルに準拠しなければなりません（C2: Containerのように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Color provides an initializer with three appropriately named parameters of type Double for its red, green, and blue components.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Colorは、３つの適切に命名された型Doubleのパラメータを、それの赤、緑、および青の構成要素のために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dice also has an initializer, to set up its initial state.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Diceはまた、その最初の状態を設定するために、イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dice provides one instance method, roll, which returns an integer value between 1 and the number of sides on the dice.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Diceは１つのインスタンスメソッド、rollを提供します、それは、１とさいころ上の面の数との間の整数値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DiceGameDelegate provides three methods for tracking the progress of a game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>DiceGameDelegateは、３つのメソッドをゲームの進捗を追うために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DiceGameTracker implements all three methods required by DiceGameDelegate.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>DiceGameTrackerは、DiceGameDelegateによって要求される３つのメソッド全てを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Double has a precision of at least 15 decimal digits, whereas the precision of Float can be as little as 6 decimal digits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Doubleは少なくとも10進数で15桁の精度を持ちます、一方でFloatの精度は10進数で６桁ほどです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Double represents a 64-bit floating-point number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Doubleは、64ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Element defines a placeholder name for “some type Element” to be provided later on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Elementは、プレースホルダ名を、後で提供されることになる「ある何らかの型Element」に対して定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Float represents a 32-bit floating-point number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Floatは、32ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LevelTracker also defines two type functions to work with the highestUnlockedLevel property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>LevelTrackerはまた、２つの型関数を定義してhighestUnlockedLevelプロパティを取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matrix provides an initializer that takes two parameters called rows and columns, and creates an array that is large enough to store rows * columns values of type Double.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Matrixはひとつのイニシャライザを提供します、それはrowsとcolumnsと呼ばれる２つのパラメータをとり、型Doubleで個数rows * columnsの値を格納するのに十分大きい配列をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Point encapsulates the x- and y-coordinate of a point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Pointは、ある地点のxおよひy座標をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rank also defines a computed property, values, which returns an instance of the Values structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Rankはまた、ある計算プロパティ、valuesを定義します、それは、Values構造体のインスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>RecipeIngredient also defines a convenience initializer, init(name: String), which is used to create a RecipeIngredient instance by name alone.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>RecipeIngredientはまた、便宜イニシャライザ、init(name: String)を定義します、それは、名前だけでRecipeIngredientインスタンスを作成するのに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rect defines a rectangle by an origin point and a size.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Rectは、原点と大きさによって長方形を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Residence instances have a single Int property called numberOfRooms, with a default value of 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Residenceインスタンスは、numberOfRoomsと呼ばれる省略時の値1を持つIntプロパティただひとつを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ShoppingListItem does not define an initializer to provide an initial value for purchased, because items in a shopping list (as modeled here) always start out unpurchased.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ShoppingListItemはpurchasedに初期値を用意するイニシャライザを定義しません、なぜなら、購入品目リストの項目が（ここでモデル化されるように）常に未購入で始められるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Size encapsulates a width and a height.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Sizeは、widthとheightをカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SomeType(ofInitialValue) is the default way to call the initializer of a Swift type and pass in an initial value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SomeType(ofInitialValue)は、あるスウィフト型のイニシャライザを呼んで、初期値を渡すために通常使う方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String values can be added together (or concatenated) with the addition operator (+) to create a new String value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>String値は、新しいString値をつくるために加算演算子（+）を使って１つに足し合わされる（または連結される）ことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String values can be constructed by passing an array of Character values as an argument to its initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>String値は、Character値の配列をそれのイニシャライザへの引数として渡すことによって組み立てられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tandem inherits all of the properties and methods from Bicycle, which in turn inherits all of the properties and methods from Vehicle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Tandemは、すべてのプロパティとメソッドをBicycleから継承します、そして今度はそれがすべてのプロパティとメソッドをVehicleから継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UInt8 integers have eight bits and can store any value between 0 and 255.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>UInt8整数は、８ビットを持ち、0と255の間でのどんな値でも保存することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a == a (Reflexivity)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>a == a（反射性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a == b &amp;&amp; b == c implies a == c (Transitivity)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>a == b &amp;&amp; b == cがa == cを意味する（推移性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a == b implies b == a (Symmetry)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>a == bがb == aを意味する（対称性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a = (b x some multiplier) + remainder</seg>
      </tuv>
      <tuv lang="JA">
        <seg>a = (b × いくらかの乗数) + 余り</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>anotherContainer is a container of type C2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>anotherContainerは、型C2のコンテナです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>board[0] always equals 0 and has no effect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>board[0]は、常に0に等しくて、効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>didSet is called immediately after the new value is stored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>didSetは、新しい値が保存された直後に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>first, of type Int</seg>
      </tuv>
      <tuv lang="JA">
        <seg>first、型Intのもの</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>increment() increments the counter by 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>increment()は、1だけカウンターを増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>increment(by: Int) increments the counter by a specified integer amount.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>increment(by: Int)は、指定された量の整数でカウンターを増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>item is Movie returns true if the current MediaItem is a Movie instance and false if it is not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>item is Movieは、現在のMediaItemがMovieインスタンスであるならばtrueを、そうでないならばfalseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>john.residence now contains an actual Residence instance, rather than nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>john.residenceは、今では実際のResidenceインスタンスを含みます、nilではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nil and the Booleans true and false are now Literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>nilとブールのtrueおよびfalseは現在リテラルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>nil cannot be used with nonoptional constants and variables.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>nilは、オプショナルでない定数や変数では使用されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>number.kind is already known to be of type Int.Kind.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>number.kindは、既に型Int.Kindであると知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>repeat-while evaluates its condition at the end of each pass through the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>repeat-whileは、その条件を、ループを通り抜けるそれぞれの終わりで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>reset() resets the counter to zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>reset()は、カウンターをゼロに再設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>second, of type Int?, or “optional Int”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>second、型Int?、つまり「オプショナルのInt」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>someContainer and anotherContainer contain the same type of items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>someContainerとanotherContainerは、同じ型の項目を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>someContainer is a container of type C1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>someContainerは、型C1のコンテナです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while evaluates its condition at the start of each pass through the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>whileは、その条件を、ループを通り抜けるそれぞれの始まりで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>willSet is called just before the value is stored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>willSetは、値が保存される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>currentValue has an initial value of 3, which means that currentValue &gt; 0 returns true, causing chooseStepFunction(backward:) to return the stepBackward(_:) function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>currentValueは3の初期値を持ちます、そしてそれは、currentValue &gt; 0がtrueを返して、chooseStepFunction(backward:)がstepBackward(_:)関数を返すことを引き起こすのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Character values are described in Strings and Characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Character値は文字列と文字で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Color also provides a second initializer with a single white parameter, which is used to provide the same value for all three color components.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Colorはまた、ただ１つのwhiteパラメータを持つ第２のイニシャライザを提供します、それは３つの色構成要素すべてに同じ値を提供するのに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dice instances have an integer property called sides, which represents how many sides they have, and a property called generator, which provides a random number generator from which to create dice roll values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Diceインスタンスは、それがどれくらいの面を持つのかを表すsidesと呼ばれる整数プロパティ、そしてそこからさいころを振った値を作成する乱数生成器を提供するgeneratorと呼ばれるプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stack provides two methods, push and pop, to push and pop values on and off the stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Stackは２つのメソッド、pushとpopを提供します、それでスタック上に値を押し込んだり飛び出させたりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>CartItem introduces a stored constant property called quantity and ensures that this property always has a value of at least 1:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CartItemはquantityと呼ばれる保存定数プロパティを導入します、そしてこのプロパティが常に少なくとも1の値を持つことを確実にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ShoppingListItem also adds a computed description property, which provides a textual description of a ShoppingListItem instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ShoppingListItemはまた、計算されるdescriptionプロパティを加えます、それは、ShoppingListItemインスタンスのテキストでの解説を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if and while statements are described in more detail in Control Flow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ifおよびwhile文は更に詳細に「制御の流れ」で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dictionary needs its keys to be hashable so that it can check whether it already contains a value for a particular key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Dictionaryは、それが特定のキーのためにすでに値を含むかどうか確認できるように、そのキーにハッシュ化できることを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Person instances have an optional residence property of type Residence?.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Personインスタンスは、型Residence?のオプショナルresidenceプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HTMLElement also defines an optional text property, which you can set to a string that represents the text to be rendered within that HTML element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>HTMLElementはまた、オプショナルのtextプロパティを定義します、それは、あなたはそれをテキストがそのHTML要素の範囲内で提出されると述べる文字列に設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>tenEighty and alsoTenEighty themselves do not “store” the VideoMode instance—instead, they both refer to a VideoMode instance behind the scenes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>tenEightyおよびalsoTenEightyそれら自身はVideoModeインスタンスを格納しません ― そうではなく、それらは両方とも舞台裏であるVideoModeインスタンスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access control restricts access to parts of your code from code in other source files and modules.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス制御は、他のソースファイルとモジュールの中のコードからのアクセスをあなたのコードの一部分に制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attributes provide more information about a declaration or type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>属性は、宣言または型に関するより多くの情報を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary expressions combine an infix binary operator with the expression that it takes as its left-hand and right-hand arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>二項式は、接中辞二進数演算子を、それがその左手側と右手側の引数としてとる式と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary operators operate on two targets (such as 2 + 3) and are infix because they appear in between their two targets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>二項演算子は、２つの目標に作用します（例えば2 + 3のように）、そしてそれがそれら２つの目標の間に現れるので接中辞です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise operators enable you to manipulate the individual raw data bits within a data structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位演算子は、あなたにあるデータ構造内の個々の生のデータ・ビットを操作することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and structures are general-purpose, flexible constructs that become the building blocks of your program’s code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスおよび構造体は、あなたのプログラムのコードの建築ブロックになる、万能で、柔軟な構造物です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closure expressions are a way to write inline closures in a brief, focused syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式は、簡潔な、焦点のあった構文で、処理の流れに組み込まれた（行内の、インラインの）クロージャを書く方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closures are self-contained blocks of functionality that can be passed around and used in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは、機能性の完全独立のブロック、かたまりです、それは、あなたのコードにおいてあちこちに渡され使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compound assignment operators combine assignment (=) with another operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合代入演算子は、代入（=）を別の操作と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control transfer statements change the order in which your code is executed, by transferring control from one piece of code to another.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御移動文は、制御をコードのひとつの部分から別のものまで移すことによって、あなたのコードが実行される順番を変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Convenience initializers are secondary, supporting initializers for a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは副次的なもので、あるクラスのためのイニシャライザを支援します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaration modifiers are keywords or context-sensitive keywords that modify the behavior or meaning of a declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言修飾子は、キーワードまたは文脈依存キーワードです、それは宣言のふるまいや意味することを修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delegation is a design pattern that enables a class or structure to hand off (or delegate) some of its responsibilities to an instance of another type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>委任は、クラスまたは構造体にそれのもつ責務の一部を別の型のインスタンスへと手渡す（または委任する）ことを可能にするデザイン・パターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated initializers are the primary initializers for a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、あるクラスのための主要なイニシャライザです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error handling is the process of responding to and recovering from error conditions in your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラー処理は、あなたのプログラムにおいてエラー状態へ応答してそこから復旧する過程です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions add new functionality to an existing class, structure, enumeration, or protocol type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しい機能性を既存のクラス、構造体、列挙、またはプロトコル型に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>File-private access restricts the use of an entity to its own defining source file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ファイル外非公開アクセス（ファイル私用）は、ある実在の使用をそれ自身の定義ソースファイルに制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point literals represent floating-point values of unspecified precision.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点リテラルは、不特定精度の浮動小数点値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point numbers are numbers with a fractional component, such as 3.14159, 0.1, and -273.15.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点数は小数部を持つ数です、例えば3.14159、0.1、そして-273.15など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are self-contained chunks of code that perform a specific task.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、特定の作業を実行する完全独立の大きな塊のコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic code enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体コードは、あなたに柔軟な、再使用できる関数と型を書くことを可能にします、それは、あなたが定義する要件を満たした場合に限り、あらゆる型を扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic functions can work with any type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体関数は、どんな型でも扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identifiers begin with an uppercase or lowercase letter A through Z, an underscore (_), a noncombining alphanumeric Unicode character in the Basic Multilingual Plane, or a character outside the Basic Multilingual Plane that isn’t in a Private Use Area.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子は、大文字または小文字のAからZ、アンダースコア（_）、基本多言語面の非合成英数字のUnicode文字、または基本他言語面の外側ての使用領域の中でない文字で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initialization is the process of preparing an instance of a class, structure, or enumeration for use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化は、クラス、構造体、または列挙のインスタンスを使用するために前準備する処理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializers are called to create a new instance of a particular type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザは、特定の型の新しいインスタンスをつくるために呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instance methods are functions that belong to instances of a particular class, structure, or enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスメソッドは、特定のクラス、構造体、または列挙のインスタンスに属している機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer literals represent integer values of unspecified precision.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数リテラルは、無限精度の整数値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integers are whole numbers with no fractional component, such as 42 and -23.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数は、小数部分のない数すべてです、例えば42や-23など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internal access enables entities to be used within any source file from their defining module, but not in any source file outside of that module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>内部アクセス（内部用）は、実在たちが、それらの定義モジュールからのあらゆるソースファイル内で使われることを可能にします、しかし、そのモジュールの外側のいかなるソースファイルの中も除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical operators modify or combine the Boolean logic values true and false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理演算子は、ブールの論理値trueおよびfalseを修正または結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods are functions that are associated with a particular type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドは、特定の型と結び付けられる関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open access and public access enable entities to be used within any source file from their defining module, and also in a source file from another module that imports the defining module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>開放アクセスと公開アクセス（公開用）は、実在たちが、それらの定義モジュールからのあらゆるソースファイル内で、そのうえに、定義モジュールをインポートする別のモジュールからのソースファイルの中で、使われることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional chaining is a process for querying and calling properties, methods, and subscripts on an optional that might currently be nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖は、現時点でnilであるかもしれないオプショナル上での、プロパティ、メソッド、および添え字への問い合わせや呼び出しのための処理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Postfix expressions are formed by applying a postfix operator or other postfix syntax to an expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞式は、接尾辞演算子または他の接尾辞構文を式に適用することによって作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix expressions combine an optional prefix operator with an expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞式では、ある任意の接頭辞演算子をひとつの式と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primary expressions are the most basic kind of expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本式は、最も基本的な種類の式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Private access restricts the use of an entity to the enclosing declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非公開アクセス（私用）は、ある実在の使用をそれを囲んでいる宣言に制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties associate values with a particular class, structure, or enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティは、いくつかの値を特定のクラス、構造体、または列挙と結びつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String interpolation is a way to construct a new String value from a mix of constants, variables, literals, and expressions by including their values inside a string literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列補間は、定数、変数、リテラル、および式の混合から、それらの値をひとつのリテラル文字列に含めることで、新しいString値を造る方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subclassing is the act of basing a new class on an existing class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスをつくることは、既存のクラスをもとに新しいクラスを構築する行為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ternary operators operate on three targets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>三項演算子は、３つの目標に作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples group multiple values into a single compound value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルは、複数の値を一つの複合値にまとめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type aliases define an alternative name for an existing type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアスは、既存の型の代替の名前を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type casting is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャストは、あるインスタンスの型を調べるための、またはそのインスタンスを、それ自身のクラス階層中のどこか他の別のスーパークラスやサブクラスとして扱うための方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary operators operate on a single target (such as -a).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項演算子は、一つだけの目標に作用します（例えば-aなど）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode is an international standard for encoding, representing, and processing text in different writing systems.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニコードは、異なる表記体系のテキストを符号化、表現、そして処理するための国際的な基準です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Advanced Operators covers Swift’s advanced operators, and describes how to define your own custom operators and implement the standard operators for your own custom types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>先進の演算子では、スウィフトの先進の演算子を取り扱い、加えてあなた独自のあつらえの演算子を定義する方法、そしてあなた独自のあつらえの型のために標準の演算子を実装する方法を解説します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array Type Shorthand Syntax is now written as [SomeType] rather than SomeType[].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列型の短縮形構文は、現在は[SomeType]のように書かれます、SomeType[]ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assertions can now use string interpolation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明は今では文字列補間を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionals no longer implicitly evaluate to true when they have a value and false when they do not, to avoid confusion when working with optional Bool values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルはもはや暗黙的に、それが値を持つときtrueに、そしてそれがそうしないときfalseに評価されません、それによってオプショナルBoolを扱うときの混乱を防ぐためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Boolean literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ブールのリテラル）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Floating-point literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（リテラル浮動小数点）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Integer literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（リテラル整数）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// String literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（リテラル文字列）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Valid, uses default value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（有効、省略時の値を使う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// no need for an exclamation mark</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（感嘆符の必要はありません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// requires an exclamation mark</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（感嘆符が要求されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// COMBINING ACUTE ACCENT, U+0301</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（アキュート・アクセント、U+0301を追加する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（エラー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Invalid, alwaysThrows() isn't a throwing parameter</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（無効、alwaysThrows()はスローパラメータではありません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Invalid, missing argument label</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（無効、引数ラベルが欠けている）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Invalid, the case has an empty body</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（無効、このケース節は空の本文を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// No actual side effects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（実際の副作用なし）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// equals "hello, world"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「こんにちは、世界よ」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// equals -1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（-１に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// equals 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（１に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// equals 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（２に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// equals 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（３に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// equals 4.0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（4.0に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// equals 6</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（６に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// false because 2 is not less than or equal to 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（２が１以下でないので偽）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// implicitly file-private class member</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（暗黙的にファイル外非公開のクラス・メンバー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// implicitly internal class</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（暗黙的に内部のクラス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// implicitly internal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（暗黙的に内部です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// implicitly private class member</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（暗黙のうちに非公開のクラス・メンバー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// true because 1 is equal to 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（１が1と同等なので真）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// true because 1 is greater than or equal to 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（１が１以上なので真）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// true because 1 is less than 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（１が２より小さいので真）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// true because 2 is greater than 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（２が１より大きいので真）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// true because 2 is not equal to 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（２が１と同等でないので真）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A decimal integer greater than zero</seg>
      </tuv>
      <tuv lang="JA">
        <seg>０より大きい10進法整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any Unicode scalar value except "­, \­, U+000A, or U+000D</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何らかのユニコードスカラー値、しかし", \、U+000A、またはU+000Dを除く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any identifier, keyword, literal, or operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>任意の識別子、キーワード、リテラル、または演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any punctuation except (­, )­, [­, ]­, {­, or }­</seg>
      </tuv>
      <tuv lang="JA">
        <seg>任意の句読点、(、)、[、]、{、または}を除く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Between one and eight hexadecimal digits</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１から８桁の16進数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Digit 0 or 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アラビア数字の0または1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Digit 0 through 7</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アラビア数字の0から7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Digit 0 through 9, a through f, or A through F</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アラビア数字の0から9、aからf、またはAからF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Digit 0 through 9</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アラビア数字の0から9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upper- or lowercase letter A through Z</seg>
      </tuv>
      <tuv lang="JA">
        <seg>大文字または小文字のAからZ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 17 in binary notation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（２進法での17）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 17 in hexadecimal notation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（16進法での17）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 17 in octal notation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（８進法での17）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// OK: names are inferred</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（OK: 名前は推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// T is inferred to be Double</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（TはDoubleであると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// T is inferred to be Int</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Tは、Intであると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The type of e is inferred to be Double.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（eの型は、Doubleであると推測されます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Valid, uses the value provided</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（有効、提供された値を使う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Warning</seg>
      </tuv>
      <tuv lang="JA">
        <seg>// 警告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// alsoMinusSix equals -6</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（alsoMinusSixは、-6に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// empty string literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（空の文字列リテラル）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// explicitly file-private class member</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（明示的にファイル外非公開のクラス・メンバー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// explicitly file-private class</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（明示的にファイル外非公開のクラス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// explicitly private class member</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（明示的に非公開のクラス・メンバー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// explicitly private class</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（明示的に非公開のクラス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// explicitly public class</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（明示的に公開のクラス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// implicitly internal class member</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（暗黙的に内部のクラス・メンバー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// implicitly internal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（暗黙的に内部です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// initializer syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（イニシャライザ構文）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// minusThree equals -3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（minusThreeは、-3に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// plusThree equals 3, or "minus minus three"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（plusThreeは、3に、または「マイナス マイナス three」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Ambiguous</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（あいまい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Error: try applies only to the first function call</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（エラー：tryは、最初の関数呼び出しだけに適用されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// explicitly public class member</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（明示的に公開のクラス・メンバー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// maxValue is equal to 255, and is of type UInt8</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（maxValuesは255に等しく、そしてUInt8型です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// minValue is equal to 0, and is of type UInt8</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（minValuesは0に等しく、そしてUInt8型です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// strong capture</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（強いキャプチャ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// true because 1 is less than 2; "zebra" and "apple" are not compared</seg>
      </tuv>
      <tuv lang="JA">
        <seg>// １は２より少ないので真；「zebra」と「apple」は比較されません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// true because 3 is equal to 3, and "apple" is less than "bird"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（３は３と等しく、「apple」は「bird」より少ないので真）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// true because 4 is equal to 4, and "dog" is equal to "dog"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（４は４と等しく、「dog」は「dog」と等しいので真）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// try applies to both function calls</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（tryは、両方の関数呼び出しに適用されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Error: names don't match</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（エラー: 名前が一致しない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Invalid, in-out arguments alias each other</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（無効、これらのin-out引数はお互い同士に別名をつけます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// No warning</seg>
      </tuv>
      <tuv lang="JA">
        <seg>// 警告なし</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// OK: names match</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（OK: 名前が一致）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// both x and y are labeled</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（xとyの両方ともラベルをつけられます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Still ambiguous</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（依然あいまい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Unambiguous</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（あいまいさ無し）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someTuple is of type (top: Int, bottom: Int)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someTupleは型 (top: Int, bottom: Int) です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// unowned capture</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（非所有者キャプチャ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// weak capture</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（弱いキャプチャ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A break statement ends program execution of a loop, an if statement, or a switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>break文は、ループ、if文、またはswitch文のプログラム実行を終えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A continue statement ends program execution of the current iteration of a loop statement but does not stop execution of the loop statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>continue文は、ループ文の現在の繰り返しのプログラム実行を終了しますが、ループ文の実行は止めません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A defer statement defers execution until the current scope is exited.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>defer文は、現在のスコープが終了されるまで実行を延期します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A defer statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>defer文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A defer statement is used for executing code just before transferring program control outside of the scope that the defer statement appears in.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>defer文は、defer文が現れるスコープの外側にプログラムの制御を移す直前でのコード実行のために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A do statement creates a new containing scope, which allows errors to be propagated to one or more catch clauses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>do文はひとつの新しく取り囲んでいるスコープを作成します、それはエラーに１つ以上のcatch節に伝えられることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A do statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>do文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A do statement in Swift is similar to curly braces ({}) in C used to delimit a code block, and does not incur a performance cost at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのdo文は、Cにおいてひとつのコードのブロックの境界を定めるために使われる波括弧（{}）に似ていて、実行時に性能上の損失を被りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A fallthrough statement can appear anywhere inside a switch statement, not just as the last statement of a case block, but it can’t be used in the final case block.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>fallthrough文は、switch文のどこにでも現れることができます、あるケース節ブロックの最後の文としてだけではなく、しかしそれは最後のケース節ブロックにおいては使われることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A fallthrough statement consists of the fallthrough keyword and occurs only in a case block of a switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>fallthrough文は、fallthroughキーワードから成って、switch文のケース節ブロックだけに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A for-in statement allows a block of code to be executed once for each item in a collection (or any type) that conforms to the Sequence protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>for-in文は、コードの１ブロックをSequenceプロトコルに準拠するあるコレクション（または何らかの型）の中のそれぞれの項目に対して一度だけ実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A for-in statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>for-in文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A guard statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>guard文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A guard statement is used to transfer program control out of a scope if one or more conditions aren’t met.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>guard文は、１つ以上の条件が満たされないならば、プログラムの制御をあるスコープの外に転移させるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A guard statement, like an if statement, executes statements depending on the Boolean value of an expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>guard文は、if文と同じく、ある式のブール値に基づいて他の文を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A repeat-while statement allows a block of code to be executed one or more times, as long as a condition remains true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>repeat-while文は、ある条件が真のままである限り、ひとかたまりのコードを一回以上実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A repeat-while statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>repeat-while文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A repeat-while statement is executed as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>repeat-while文は、次のように実行されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A return statement can consist of only the return keyword, or it can consist of the return keyword followed by an expression, as shown below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>return文はキーワードreturnだけから成ることができます、あるいはそれは、以下に示すように、キーワードreturnとそれに続く式から成ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A return statement occurs in the body of a function or method definition and causes program execution to return to the calling function or method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>return文は、関数またはメソッド定義の本文に現れて、プログラム実行を関数またはメソッド呼んでいるところに戻るようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A switch case can bind the value or values it matches to temporary constants or variables, for use in the body of the case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switchケース節は、それがマッチする値または複数の値を、そのケース節の本文で使うために一時的な定数または変数に束縛することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A switch case can optionally contain a where clause after each pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switchケース節は、各パターンの後に随意にwhere節を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A switch case can use a where clause to check for additional conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switchケース節は、where節を、追加の条件で調べるために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A switch case that contains only a comment is reported as a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つのコメントだけを含むswitchケース節は、コンパイル時エラーとして報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A switch statement allows certain blocks of code to be executed depending on the value of a control expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文は、コードの特定のブロックをある制御式の値に従って実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A switch statement can also include a default case, introduced by the default keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文はまた、キーワードdefaultによって導入される、省略時のケース節を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A switch statement considers a value and compares it against several possible matching patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文は、ある値について考察して、それをいくつかの候補のマッチングパターンと比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A switch statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A throw statement causes a program to end execution of the current scope and begin error propagation to its enclosing scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>throw文は、プログラムに現在のスコープの実行を終了させます、そしてそれを囲んでいるスコープにエラーの伝達を始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A throw statement consists of the throw keyword followed by an expression, as shown below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>throw文は、以下のように、throwキーワードとそれに続くひとつの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A throw statement occurs in the body of a throwing function or method, or in the body of a closure expression whose type is marked with the throws keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>throw文はスロー関数やメソッドの本文中に、またはthrowsキーワードで印される型のクロージャ式の中に現れます、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A try expression can’t appear on the right hand side of a binary operator, unless the binary operator is the assignment operator or the try expression is enclosed in parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>try式が二項演算子の右手側に現れることは、その二項演算子が代入演算子であるかtry式が丸括弧の中に入れられるかしない限りできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A while loop is appropriate in this case, because the length of the game is not clear at the start of the while loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>whileループはこの場合に適切なものです、なぜならゲームの長さはwhileループの開始時点ではっきりしないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A while loop performs a set of statements until a condition becomes false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>whileループは、ひとまとめにした文を、ある条件がfalseになるまで実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A while loop starts by evaluating a single condition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>whileループは、一つだけ条件を評価することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A while statement allows a block of code to be executed repeatedly, as long as a condition remains true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>while文は、条件が真のままである限り、コードの１ブロックを繰り返して実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A while statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>while文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A while statement is executed as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>while文は、次のように実行されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A willSet observer is called just before the value of the variable or property is set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>willSetオブザーバーは、変数またはプロパティの値が設定される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A continue statement can consist of only the continue keyword, or it can consist of the continue keyword followed by the name of a statement label, as shown below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>continue文は、以下に示すように、キーワードcontinueだけから成ることができます、また、それはキーワードcontinueとそれに続く文ラベルから成ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A switch statement provides an alternative to the if statement for responding to multiple potential states.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文は、複数の起こりうる状況に応答するためにif文に代わるものを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A switch statement can include only one default case, which must appear at the end of the switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文は１つの省略時のケース節だけを含むことができます、それは、switch文の終わりに現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A break statement can consist of only the break keyword, or it can consist of the break keyword followed by the name of a statement label, as shown below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>break文はキーワードbreakだけから成ることができます、あるいは、それは、以下に示すように、キーワードbreakとそれに続く文ラベルの名前から成ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A fallthrough statement causes program execution to continue from one case in a switch statement to the next case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>fallthrough文によって、プログラム実行がswitch文の１つのケース節から次のケース節に続くようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A CreditCard instance never outlives the Customer that it refers to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CreditCardインスタンスは、それが参照するCustomerより決して長生きしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A binary number, with a 0b prefix</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２進数は、接頭辞0bつきで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class declaration introduces a named class type into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言は、名前をつけられたクラス型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure expression creates a closure, also known as a lambda or an anonymous function in other programming languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式はクロージャ、他のプログラミング言語ではまたlambdaまたは匿名関数として知られるものをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A code block is used by a variety of declarations and control structures to group statements together.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コード・ブロックは、いくつかの文をまとめるために、いろいろな宣言や制御構造で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A compound type is a type without a name, defined in the Swift language itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合の型は名前のない型です、そしてスウィフト言語自身によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constant declaration introduces a constant named value into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言は、名前をつけられた一定不変の値をあなたのプログラムにもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A decimal number, with no prefix</seg>
      </tuv>
      <tuv lang="JA">
        <seg>10進数は、接頭辞なしで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A declaration introduces a new name or construct into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言は、新しい名前または構造物をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A deinitializer declaration declares a deinitializer for a class type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザ宣言は、クラス型のためにデイニシャライザを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A deinitializer is called immediately before a class instance is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、クラスインスタンスが割り当て解除される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dictionary literal is an unordered collection of key-value pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書リテラルは、「キーと値」の対の順序付けされないコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dictionary stores associations between keys of the same type and values of the same type in a collection with no defined ordering.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書は、同じ型のキーと同じ型の値との間の関連性をあるコレクションの中に順序を定義しないでしまっておきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dynamic type expression consists of an expression within special syntax that resembles a Function Call Expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動的型式は、関数呼び出し式に類似した特別な構文内のある式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer is a type of initializer that produces an optional instance or an implicitly unwrapped optional instance of the type the initializer is declared on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザは、イニシャライザの一種で、そのイニシャライザが宣言されている型の、オプショナルのインスタンスまたは暗黙的にアンラップされるオプショナルのインスタンスを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A forced-try expression consists of the try! operator followed by an expression that can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強制try式は、try!演算子と後につづくエラーをスローできる１つの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A forced-value expression unwraps an optional value that you are certain is not nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強制された値式は、あなたがnilでないことを確信しているオプショナルの値をアンラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function call expression consists of a function name followed by a comma-separated list of the function’s arguments in parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数呼び出し式は、関数名の後にその関数の引数のコンマ区切りのリストを丸括弧の中に続けることから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function declaration introduces a function or method into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数宣言は、あなたのプログラムに関数またはメソッドをもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic argument clause specifies the type arguments of a generic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体引数節は、総称体型の型引数を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic parameter clause specifies the type parameters of a generic type or function, along with any associated constraints and requirements on those parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体パラメータ節は、総称体の型や関数の型パラメータを、それらのパラメータに関するあらゆる付随する制約と要件と一緒に指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A hexadecimal number, with a 0x prefix</seg>
      </tuv>
      <tuv lang="JA">
        <seg>16進数は、接頭辞0xつきで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key-value pair is a combination of a key and a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「キーと値」の対は、ひとつのキーとひとつの値の組合せです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A lazy stored property is a property whose initial value is not calculated until the first time it is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延保存プロパティは、初めてそれが使われるまで、初期値が計算されないプロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A literal expression consists of either an ordinary literal (such as a string or a number), an array or dictionary literal, a playground literal, or one of the following special literals:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラル式は、普通のリテラル（例えば、ある文字列または数）、配列または辞書リテラル、プレイグラウンドリテラル、または以下の特別なリテラルのうちの１つから成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A literal is the source code representation of a value of a type, such as a number or string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラルは、ある型のある値をソースコードに表わしたものです、例えばある数や文字列など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A module is a single unit of code distribution—a framework or application that is built and shipped as a single unit and that can be imported by another module with Swift’s import keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>モジュールは、コード分類の１つの単位 ― フレームワークまたはアプリケーションです、それは、単一の構成単位として構築され出荷されて、スウィフトのimportキーワードを使って別のモジュールによってインポートされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A named type is a type that can be given a particular name when it is defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前付きの型は、それが定義されるとき、特定の名前を与えられることができる型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parenthesized expression consists of an expression surrounded by parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧に入れられた式は、丸括弧で囲まれたある式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A pattern represents the structure of a single value or a composite value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるパターンは、ある単一の値または複合の値の構造を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A playground literal is used by Xcode to create an interactive representation of a color, file, or image within the program editor.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレイグラウンドリテラルは、Xcodeによって使われて、プログラムエディタ内でいろ、ファイル、または画像の双方向の表現を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A postfix operator is a unary operator that is written immediately after its operand, such as the postfix forced-unwrap operator (!) in the expression a!.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞演算子は単項演算子です、それはその演算数の直後に書かれます、例えば式a!での論理否定演算子（!）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A precedence group declaration introduces a new grouping for infix operator precedence into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位グループは、接中辞演算子優先順位に対する新しいグループをあなたのプログラムへ導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A prefix operator is a unary operator that is written immediately before its operand, such as the prefix logical NOT operator (!) in the expression !a.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞演算子は単項演算子です、それはその演算数の直前に書かれます、例えば式!aでの論理否定演算子（!）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A protocol declaration introduces a named protocol type into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言は、名前をつけられたプロトコル型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコル（規約）は、メソッド、プロパティ、そして他の要件からなるひとつの青写真を定義します、それは、ある特定の作業またはある機能性断片にふさわしくするものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recursive enumeration is an enumeration that has another instance of the enumeration as the associated value for one or more of the enumeration cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再帰列挙は、１つ以上の列挙ケース節のための関連値としてその列挙の別のインスタンスを持つ列挙です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A set stores distinct values of the same type in a collection with no defined ordering.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合は、同じ型の異なった値をひとつのコレクションの中に決まった順序なしで格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A source file is a single Swift source code file within a module (in effect, a single file within an app or framework).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ソースファイルは、あるモジュール内の単一のスウィフトソースコード・ファイルです（実質的には、アプリまたはフレームワーク内の単一のファイル）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string is a series of characters, such as "hello, world" or "albatross".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの文字列は、一連なりの文字です、例えば"hello, world"または"albatross"など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A structure declaration introduces a named structure type into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体宣言は、名前をつけられた構造体型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subscript expression provides subscript access using the getter and setter of the corresponding subscript declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字式は、対応する添え字宣言のゲッターとセッターを使用して、添え字アクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subscript declaration allows you to add subscripting support for objects of a particular type and are typically used to provide a convenient syntax for accessing the elements in a collection, list, or sequence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言は、特定の型のオブジェクトに対する添え字サポートを付け加えることをあなたに可能にして、コレクション、リスト、またはシーケンスの中の要素にアクセスするための便利な構文を提供するために概して使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A superclass expression lets a class interact with its superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラス式は、あるクラスをそのスーパークラスと相互に作用させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A try expression consists of the try operator followed by an expression that can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>try式は、try演算子と後につづくエラーをスローできる１つの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tuple expression consists of a comma-separated list of expressions surrounded by parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル式は、丸括弧に囲まれているコンマ区切りの式のリストから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tuple pattern is a comma-separated list of zero or more patterns, enclosed in parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルパターンは、丸括弧で囲まれた、０個以上のパターンのコンマ区切りのリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type alias declaration introduces a named alias of an existing type into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアス宣言は、あなたのプログラムに既存の型の名前をつけられたエイリアスを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type annotation explicitly specifies the type of a variable or expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型注釈は、明確に変数または式の型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value type is a type whose value is copied when it is assigned to a variable or constant, or when it is passed to a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型は、それが変数または定数に代入される時に、あるいは、それが関数に渡されるときに、値がコピーされる型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value-binding pattern binds matched values to variable or constant names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値束縛パターンは、マッチした値を変数または定数の名前に縛り付けてひとつに束ねます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variable declaration introduces a variable named value into your program and is declared using the var keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数宣言は、名前をつけられた変えられる値をあなたのプログラムにもたらします、そしてキーワードvarを使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variadic parameter accepts zero or more values of a specified type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長パラメータは、指定された型の０個以上の値を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A weak reference is a reference that does not keep a strong hold on the instance it refers to, and so does not stop ARC from disposing of the referenced instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照は、それが言及するインスタンスに対する強い支配力を保たない参照です、なのでARCは参照をつけられたインスタンスを処分するのを止めません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A wildcard expression is used to explicitly ignore a value during an assignment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ワイルドカード式は、代入の間に明示的に値を無視するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A wildcard pattern matches and ignores any value and consists of an underscore (_).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ワイルドカード・パターンは、どんな値にでもマッチして無視します、そしてアンダースコア（_）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type argument is the name of an actual concrete type that replaces a corresponding type parameter in the generic parameter clause of a generic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型引数は実際の具体的な型の名前です、それは、ある総称体型のもつ総称体パラメータ節の中の対応する型パラメータを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type parameter is simply the name of a placeholder type (for instance, T, U, V, Key, Value, and so on).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型パラメータは、単にプレースホルダ型の名前です（たとえばT、U、V、Key、Valueなど）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A where clause is introduced by the where keyword followed by an expression, and is used to provide an additional condition before a pattern in a case is considered matched to the control expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>where節は、キーワードwhereのあとにひとつの式を続けることによって導入されます、そしてケース節の中のあるパターンがその制御式にマッチしたと考えられるより前に更なる条件を与えるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Swift Tour</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトツアー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Swift constant or variable that refers to an instance of some reference type is similar to a pointer in C, but is not a direct pointer to an address in memory, and does not require you to write an asterisk (*) to indicate that you are creating a reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある参照型のインスタンスに言及するスウィフト定数または変数はCの中のポインターに似ています、しかしメモリ中のアドレスへの直接のポインターでなくて、あなたに参照をつくっていることを示すために星印（*）を書くことを要求しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Swift property does not have a corresponding instance variable, and the backing store for a property is not accessed directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのプロパティには対応するインスタンス変数がありません、そしてプロパティのための支援外部記憶は直接にアクセスされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Unicode scalar is a unique 21-bit number for a character or modifier, such as U+0061 for LATIN SMALL LETTER A ("a"), or U+1F425 for FRONT-FACING BABY CHICK ("🐥").</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるユニコード・スカラーは、ある文字または修飾子のための固有な21ビットの数字です、例えばLATIN SMALL LETTER A（"a"）に対するU+0061、またはFRONT-FACING BABY CHICK（"🐥"）に対するU+1F425など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Unicode scalar is any Unicode code point in the range U+0000 to U+D7FF inclusive or U+E000 to U+10FFFF inclusive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるユニコード・スカラーは、U+0000からU+D7FFを含めてまで、またはU+E000からU+10FFFFを含めてまでの範囲のユニコード・コードポイントのどれかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A capture list defines the rules to use when capturing one or more reference types within the closure’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>捕獲リストは、クロージャの本文内で一つ以上の参照型を捕獲するとき使用する規則を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A capture list is written as a comma separated list of expressions surrounded by square brackets, before the list of parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャプチャリストは、角括弧に囲まれているコンマ区切りの式のリストとして、パラメータのリストの前に書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class can inherit methods, properties, and other characteristics from another class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは、メソッド、プロパティ、および他の特徴を別のクラスから継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class can override properties, methods, subscripts, and initializers of its superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは、それのスーパークラスのプロパティ、メソッド、添え字、そしてイニシャライザをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class or structure can provide as many subscript implementations as it needs, and the appropriate subscript to be used will be inferred based on the types of the value or values that are contained within the subscript brackets at the point that the subscript is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスや構造体はそれが必要とする多くの添え字実装を提供することが可能です、そして使用されるのに適切な添え字が、添え字が使われる時点でその添え字角括弧内に含まれる値または複数の値の型に基づいて、推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class type can inherit from only one parent class, its superclass, but can adopt any number of protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス型は、ただ１つの親クラス、それのスーパークラスから継承することだけが許されます、しかし随意の数のプロトコルに準拠することはできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure can capture constants and variables from the surrounding context in which it is defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは、それが定義される周囲の前後関係から、定数と変数を捕獲（キャプチャ）できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure can omit the types of its parameters, its return type, or both.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは、そのパラメータの型、その戻り型、または両方を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure is said to escape a function when the closure is passed as an argument to the function, but is called after the function returns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャが引数として関数に渡される、しかしその関数が戻った後に呼び出されるとき、クロージャは関数を脱出すると言われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure may omit names for its parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは、そのパラメータの名前を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure or nested function that captures an in-out parameter must be nonescaping.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータをキャプチャするクロージャまたは入れ子にされた関数は、非脱出でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure passed as the last argument to a function can appear immediately after the parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後の引数として関数に渡されるクロージャは、丸括弧の直後に現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure that consists of only a single expression is understood to return the value of that expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一つの式だけから成るクロージャは、その式の値を返すと理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A collection of 21-bit Unicode scalar values, equivalent to the string’s UTF-32 encoding form (accessed with the string’s unicodeScalars property)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>21ビットのUnicodeスカラー値の集まり、その文字列のUTF-32符号化方式と等しい（文字列のunicodeScalarsプロパティでアクセスされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A collection of UTF-16 code units (accessed with the string’s utf16 property)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>UTF-16符号単位の集まり（文字列のutf16プロパティでアクセスされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A collection of UTF-8 code units (accessed with the string’s utf8 property)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>UTF-８符号単位の集まり（文字列のutf8プロパティでアクセスされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A comma is allowed after the last element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつのコンマが最後の要素のあとに許容されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A compound type may contain named types and other compound types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの複合の型は、名前付きの型や他の複合の型を含むかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A computed property with a getter but no setter is known as a read-only computed property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲッターを持つ、しかしセッターはない計算プロパティは、読み出し専用の計算プロパティとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A conditional compilation block allows code to be conditionally compiled depending on the value of one or more compilation conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件コンパイルブロックは、１つ以上のコンパイル条件の値に依存してコードが条件付きでコンパイルされるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A conforming type can provide additional functionality, as long as it satisfies these three requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに準拠している型は、それがこれらの３つの要件を満たす限り、追加の機能性を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A conforming type can satisfy a failable protocol initializer requirement by implementing any kind of initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある準拠している型は、失敗できるプロトコルイニシャライザ要件を満たすことが、どんな種類のイニシャライザを実装することによっても可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A conforming type can satisfy a nonfailable protocol initializer requirement by implementing a nonfailable initializer or an init! failable initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある準拠している型は、失敗できないプロトコルイニシャライザ要件を満たすことが、失敗できないイニシャライザまたはinit!失敗できるイニシャライザを実装することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A consistent use of Int for integer values aids code interoperability, avoids the need to convert between different number types, and matches integer type inference, as described in Type Safety and Type Inference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数値のためのIntの一貫した使用は、コードの相互運用性を支援して、異なる数の型の間で変換する必要を避けて、「型安全と型推論」で記述されるように、整数型推論に合致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constant declaration defines an immutable binding between the constant name and the value of the initializer expression; after the value of a constant is set, it cannot be changed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言は、定数名とイニシャライザ式の値の間の不変の束縛を定義します；定数の値が設定されたあと、それは変わることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constant or variable must have the same type as the value you want to assign to it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数または変数は、あなたがそれに代入したい値と同じ型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constant or variable of a certain class type may actually refer to an instance of a subclass behind the scenes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定のクラス型の定数または変数は、舞台裏で実際にはあるサブクラスのインスタンスを参照するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constant, variable, or property cannot be more public than its type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数、変数、またはプロパティは、その型よりもより公開であることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A convenience initializer must call another initializer from the same class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは、別のイニシャライザを同じクラスから呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A convenience initializer must delegate to another initializer before assigning a value to any property (including properties defined by the same class).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは、値を何らかのプロパティ（同じクラスによって定義されるプロパティを含む）に代入する前に、別のイニシャライザに委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A convenience initializer must ultimately call a designated initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは、最終的に指定イニシャライザを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A custom infix operator that is not explicitly placed into a precedence group is given a default precedence group with a precedence immediately higher than the precedence of the ternary conditional operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある優先順位グループの中に明示的に置かれないあつらえの接中辞演算子は、三項条件演算子の優先順位のすぐ上の優先順位を持つ省略時の優先順位グループを与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A default initializer has the same access level as the type it initializes, unless that type is defined as public.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のイニシャライザは、それが初期化する型と同じアクセス水準を持ちます、その型がpublicとして宣言される場合を除いて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A default parameter called newValue is provided to your setter if you do not provide one yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが独自のものを提供しないならば、newValueと呼ばれる省略時のパラメータがあなたのセッターに提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A deinitializer can be declared only in the body of a class declaration—but not in an extension of a class—and each class can have at most one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、クラス宣言の本文においてのみ ― しかしクラスの拡張においてではなく ― 宣言されることができます、そして各クラスが多くとも１つしか持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A deinitializer is called automatically when there are no longer any references to a class object, just before the class object is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、あるクラスオブジェクトに対するいかなる参照ももはやない時、そのクラスオブジェクトが割り当て解除される直前に、自動的に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A designated initializer for that class confirms that all stored properties introduced by that class have a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのクラスのための指定イニシャライザは、そのクラスによって導入される全ての保存プロパティが値を持つことを確かめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、そのクラスによって導入される全てのプロパティを完全に初期化して、適切なスーパークラスのイニシャライザを呼んで初期化プロセスを続けていきスーパークラス連鎖を上っていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A designated initializer must call a designated initializer from its immediate superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、その直接のスーパークラスから指定イニシャライザを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、継承されたプロパティに代入する前にスーパークラスのイニシャライザへ委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A designated initializer must ensure that all of the properties introduced by its class are initialized before it delegates up to a superclass initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、それがスーパークラスのイニシャライザへと委任する前に、そのクラスによって導入されるプロパティの全てが初期化されることを確実にしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A designated initializer of a class initializes all of the class’s properties directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスの指定イニシャライザは、直接そのクラスのプロパティの全てを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A designated or convenience initializer is called on a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定または便宜イニシャライザが、あるクラスで呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dictionary Key type must conform to the Hashable protocol, like a set’s value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある辞書のKey型は、集合の持つ値型のように、Hashableプロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dictionary literal is a shorthand way to write one or more key-value pairs as a Dictionary collection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書リテラルは、Dictionaryコレクションとして一つ以上の「キーと値」の対を書く簡便な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A different function with the same matching type can be assigned to the same variable, in the same way as for non-function types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じ適合する型を持つ異なる関数は、同じ変数に代入されることが可能です、それは関数でない型に対するのと同じ方法でできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable designated initializer can be overridden in a subclass by any kind of designated initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できる指定イニシャライザは、サブクラスにおいて任意の種類の指定イニシャライザでオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer can also delegate to a nonfailable initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザは、また、失敗できないイニシャライザへと委任することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer can delegate to any kind of initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザは、あらゆる種類のイニシャライザへ委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer can return nil at any point in the implementation of the initializer’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザは、そのイニシャライザの本文の中の任意の地点でnilを返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer creates an optional value of the type it initializes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザは、そのイニシャライザの型のオプショナルの値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer is used to find an appropriate enumeration case for a Character value representing a temperature symbol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザは、ある温度記号で表されているCharacter値に対して適切な列挙ケース節を見つけるために使用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer of a class, structure, or enumeration can delegate across to another failable initializer from the same class, structure, or enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス、構造体、または列挙のための失敗できるイニシャライザは、同じクラス、構造体、または列挙からの別の失敗できるイニシャライザに横つながりに委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer requirement can be satisfied by a failable or nonfailable initializer on a conforming type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザ要件は、準拠している型上の失敗できるもしくは失敗できないイニシャライザによって満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A fourth value is “pushed” on to the top of the stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第４の値がスタックのてっぺんに「押し込まれ」ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function call expression can include a trailing closure in the form of a closure expression immediately after the closing parenthesis.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数呼び出し式は、終わりの括弧の直後にクロージャ式の形で後付クロージャを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function can have at most one variadic parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は最大で１つの可変長パラメータしか持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function can take another function as one of its arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数は、その引数の１つとして別の関数をとることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function cannot have a higher access level than its parameter types and return type, because the function could be used in situations where its constituent types are not available to the surrounding code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、そのパラメータ型および戻り型より高いアクセス水準を持つことができません、なぜなら、その関数は、それの組成の型が周囲のコードに利用できない状況において使われることができるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function declared in the context of class, structure, enumeration, or protocol is referred to as a method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス、構造体、列挙、またはプロトコルの文脈において宣言される関数は、メソッドとして言及されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function definition can appear inside another function declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数定義は、別の関数宣言の内部に現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function indicates that it can throw an error by including the throws keyword in its declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数は、それがエラーをスローできることをthrowsキーワードをそれの宣言に含めることによって示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function marked with throws is called a throwing function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>throwsで印された関数は、スロー関数と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function may have at most one variadic parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、最大で１つの可変長パラメータしか持つことが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function or method can be declared with the rethrows keyword to indicate that it throws an error only if one of its function parameters throws an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数またはメソッドは、rethrowsキーワードとともに宣言されて、それの関数パラメータの１つがエラーをスローする場合にのみそれがエラーをスローすることを指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function that tries to retrieve a web page might return the (Int, String) tuple type to describe the success or failure of the page retrieval.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ウェブ・ページを探してくるある関数は、ページ検索の成功または失敗を記述するために(Int, String)のタプル型を返すかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function type can have a variadic parameter in its parameter type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型は、そのパラメータ型において可変長パラメータを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function type represents the type of a function, method, or closure and consists of a parameter and return type separated by an arrow (-&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型は、ある関数、メソッド、またはクロージャの型を表して、矢印（-&gt;）で区切られるパラメータと戻り型から成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function with C function calling conventions can be used as a function with Objective-C block calling conventions, and a function with Objective-C block calling conventions can be used as a function with Swift function calling conventions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C関数呼出規約を持つ関数は、Objective-Cブロック呼出規約を持つ関数として使用されることができます、そしてOblective-Cブロック呼出規約を持つ関数は、スウィフト関数呼出規約を持つ関数として使用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function with a defined return type cannot allow control to fall out of the bottom of the function without returning a value, and attempting to do so will result in a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある定義された戻り型を持つ関数は、値を返すことなく関数の底を抜け落ちるように制御されることができません、そしてそうしようとすることはコンパイル時エラーに終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function’s arguments must always be provided in the same order as the function’s parameter list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の引数は、常にその関数のパラメータ一覧と同じ順序で提供されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic where clause consists of the where keyword, followed by a comma-separated list of one or more requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体where節は、whereキーワード、それに続けてコンマ区切りのリストのひとつ以上の要件（requirements）から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic where clause enables you to require that an associated type must conform to a certain protocol, or that certain type parameters and associated types must be the same.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体where節は、ある関連型が特定のプロトコルに準拠しなければならないこと、または特定の型パラメータおよび関連型が同じでなければならないことをあなたが要求できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic where clause starts with the where keyword, followed by constraints for associated types or equality relationships between types and associated types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体where節は、whereキーワードで始まり、関連型に対する制約がいくつか、または型と関連型の間の同等関係性がいくつか続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic argument clause is enclosed in angle brackets (&lt;&gt;) and has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体引数節は、山形括弧（&lt;&gt;）に囲まれて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic parameter clause is enclosed in angle brackets (&lt;&gt;) and has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体パラメータ節は、山形括弧（&lt;&gt;）において囲まれて、以下の書式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic parameter consists of a type parameter followed by an optional constraint.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体パラメータは、型パラメータとそれに続く任意の制約から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A hash value is an Int value that is the same for all objects that compare equally, such that if a == b, it follows that a.hashValue == b.hashValue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるハッシュ値はあるひとつのInt値です、それは同等とみなされるすべてのオブジェクトに対して同じものです、たとえばa == bのように、それはa.hashValue == b.hashValueで導き出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key-path expression lets you access the string used to refer to a property in Objective-C for use in key-value coding and key-value observing APIs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパス式は、あなたにキー値コーディングとキー値監視APIにおいて使うためにObjective-Cでのプロパティを参照するのに使われる文字列にアクセスをさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A labeled statement is indicated by placing a label on the same line as the statement’s introducer keyword, followed by a colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラベルをつけられた文は、あるラベルをその文の導入子キーワードとして、コロンをその後に続けて同じ行に置くことによって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A line control statement has the following forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行制御文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A line control statement is used to specify a line number and filename that can be different from the line number and filename of the source code being compiled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行制御文は、行番号とファイル名を指定するために使われます、それはコンパイルされているソースコードの行番号とファイル名とは異なっていることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A literal doesn’t have a type on its own.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラルはそれ独自の型を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A metatype type refers to the type of any type, including class types, structure types, enumeration types, and protocol types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるメタタイプ型は、いろいろなクラス型、構造体型、列挙型、そしていろいろなプロトコル型の内で、ある何らかの型のその型に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A method marked with the nonobjc attribute cannot override a method marked with the objc attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>nonobjc属性で印されるメソッドはobjc属性で印されるメソッドをオーバーライドできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A name before the parameter name gives the parameter an explicit argument label, which can be different from the parameter name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ名の前の名前は、そのパラメータに明示的な引数ラベルを与えます、それはパラメーター名と異なるものにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nested function can capture any of its outer function’s arguments and can also capture any constants and variables defined within the outer function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた関数は、その外側の関数の持つ引数の何でも捕獲することができ、また外側の関数の範囲内で定義されるどんな定数や変数でも捕獲することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new Player instance is created, with a request for 100 coins if they are available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいPlayerインスタンスが、それが可能ならば100のコインを要請して作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nonfailable designated initializer can be overridden in a subclass by a nonfailable designated initializer only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できない指定イニシャライザは、サブクラスにおいて失敗できない指定イニシャライザでのみオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nonfailable initializer can delegate to an init? failable initializer by force-unwrapping the result of the superclass’s initializer—for example, by writing super.init()!.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できないイニシャライザは、init?失敗できるイニシャライザに委任することが、スーパークラスのイニシャライザの結果を強制アンラップすることによって可能です ― 例えば、super.init()!と書くことによって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nonfailable initializer can delegate to another nonfailable initializer or to an init! failable initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できないイニシャライザは、別の失敗できないイニシャライザへ、または失敗できるイニシャライザinit!へ委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nonfailable initializer requirement can be satisfied by a nonfailable initializer or an implicitly unwrapped failable initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できないイニシャライザ要件は、失敗できないイニシャライザまたは暗黙的にアンラップされる失敗できるイニシャライザによって満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nonreturning function or method can be called to conclude the else clause of a guard statement, as discussed in Guard Statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非復帰関数およびメソッドは、guard文のelse節で終わるために呼び出されることができます、guard文で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A number that will not fit into a constant or variable of a sized integer type is reported as an error when your code is compiled:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードがコンパイルされるとき、ある大きさを設定された整数型の定数または変数に収まらない数はエラーとして報告されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A pair of parentheses still wrap the entire argument for the method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一対の丸括弧は、依然としてこのメソッドに対する引数をすべて包みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parameter has a name, which is used within the function body, as well as an argument label, which is used when calling the function or method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータは名前を持ちます、それは関数本文内部で使われます、それだけでなく引数ラベルも、それは関数やメソッドが呼ばれる時に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parameter of the function type () -&gt; T (where T is any type) can apply the autoclosure attribute to implicitly create a closure at its call sites.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型() -&gt; T（ここでTはどんな型でも）のあるパラメータは、autoclosure属性を適用することによって、あるクロージャを暗黙的にそれの呼び出し領域で作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parameter with a base type name followed immediately by three dots (...) is understood as a variadic parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本の型の名前に直ちに３つの点（...）が続くパラメータは、可変長パラメータとして理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parameter with an equals sign (=) and an expression after its type is understood to have a default value of the given expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その型の後に等号（=）と式をもつパラメータは、与えられた式からなる省略時の値を持つと理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A point in a 3D coordinate system, perhaps encapsulating x, y and z properties, each of type Double.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>3D座標系でのポイント、おそらくはx、y、そしてzプロパティ（各々Double型）をカプセル化する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A postfix self expression consists of an expression or the name of a type, immediately followed by .self.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞self式は、ある式または型の名前と、それに直ちに続く.selfから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A precedence group declaration has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位グループ定義は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A precedence group specifies an operator’s precedence relative to other infix operators, as well as the operator’s associativity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位グループは、他の接中辞演算子と相対的にある演算子の優先順位を、それだけでなく演算子の結合性も指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A property declaration in a class is written the same way as a constant or variable declaration, except that it is in the context of a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスの中のプロパティ宣言は、定数または変数の宣言と同じ方法で書かれます、ただしそれはクラスの前後関係の中にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A property that normally returns an Int will return an Int? when accessed through optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>通常はIntを返すプロパティは、オプショナル連鎖を通してアクセスされるときInt?を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A protocol can inherit one or more other protocols and can add further requirements on top of the requirements it inherits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、一つ以上の他のプロトコルを継承することができて、それが継承する要件の上に、更なる要件を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A protocol can be used as the type to be stored in a collection such as an array or a dictionary, as mentioned in Protocols as Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型としてのプロトコルで言及されるように、プロトコルは型として使われることで、コレクション、例えば配列や辞書などに保管されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A protocol can require any conforming type to provide an instance property or type property with a particular name and type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルは、あらゆる準拠型に、特定の名前と型をもつインスタンスプロパティまたは型プロパティを提供するように要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A protocol composition type allows you to specify a value whose type conforms to the requirements of multiple protocols without having to explicitly define a new, named protocol that inherits from each protocol you want the type to conform to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成型は、あなたに、その型が複数プロトコルの要件に準拠するある値を、あなたがその型に準拠して欲しい各プロトコルから継承する名前をつけられたある新しいプロトコルを明示的に定義する必要なく指定させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A protocol composition type describes a type that conforms to each protocol in a list of specified protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成型は、指定されたプロトコルのリストの各プロトコルに準拠する型を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A public type defaults to having internal members, not public members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開の型は特に何もしない状態では内部のメンバーを持ちます、公開のメンバーではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A public variable cannot be defined as having an internal, file-private, or private type, because the type might not be available everywhere that the public variable is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開の変数は、内部、ファイル外非公開、または非公開の型のものを持つように定義されることができません、なぜなら、その型は公開の変数が使われるあらゆる所で利用可能ではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A read-only computed property always returns a value, and can be accessed through dot syntax, but cannot be set to a different value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>読み出し専用の計算プロパティは常にある値を返します、そしてドット構文を通してアクセスされることができますが、異なる値に設定されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recursive function is a straightforward way to work with data that has a recursive structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再帰関数は、率直な方法で再帰構造を持つデータを扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reference to the returned function is stored in a constant called moveNearerToZero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>返された関数への参照は、moveNearerToZeroと呼ばれる定数に保存されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A required initializer must have the same access level as the class it belongs to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>必須イニシャライザは、それが属しているクラスと同じアクセス水準を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rethrowing function or method can contain a throw statement only inside a catch clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再度スローする関数やメソッドは、throw文をcatch節の内部にのみ含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A selector expression lets you access the selector used to refer to a method or to a property’s getter or setter in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セレクタ式は、あなたに、Objective-Cにおけるあるメソッドをまたはあるプロパティの持つゲッターやセッターを参照するために使われるセレクタにアクセスをさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A semicolon (;) can optionally appear after any statement and is used to separate multiple statements if they appear on the same line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セミコロン（;）はあらゆる文の後に任意に現れることができて、複数の文をそれらが同じ行に現れる場合に別々に分けるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A set type cannot be inferred from an array literal alone, so the type Set must be explicitly declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合の型は配列リテラルのみでは推論されることができません、それで型Setが明示的に宣言されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sign bit of 0 means positive, and a sign bit of 1 means negative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>0の符号ビットは正を意味します、そして、1の符号ビットは負であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A similar principle is used to check for Song instances, and to print an appropriate description (including artist name) whenever a Song is found in the library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>類似した原則が使用されて、Songインスタンスか確認して、そしてSongがlibraryで見つけられるときはいつでも、適切な説明（artist名を含む）を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simple conditional compilation block has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単純な条件コンパイルブロックは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simple way to remember this is:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを覚えている単純な方法は、以下の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A single expression inside parentheses is a parenthesized expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>丸括弧で囲まれたただ１つだけの式は、括弧で囲まれた式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A single parenthesized type is the same as that type without parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>丸括弧で囲まれたただ１つだけの型は、丸括弧なしのその型と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A speed of 35.0 produces a gear of 4:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>速度35.0はギア4を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stack is a useful collection model whenever you need a strict “last in, first out” approach to managing a collection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックは、厳格に「最後に入れたものが、最初に取り出される」取り組みをコレクションを管理するために必要とするときはいつでも、役に立つコレクション・モデルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stack is an ordered set of values, similar to an array, but with a more restricted set of operations than Swift’s Array type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックは、順序付けられたいくつかの値の集合であり、配列に似ています、しかしスウィフトのArray型より制限された操作具合を持つものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stack, however, allows new items to be appended only to the end of the collection (known as pushing a new value on to the stack).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックは、しかし、新しい項目をコレクション終わりにのみ追加されることが許されます（新しい値をスタックにプッシュするとして知られます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A status code of 404 Not Found is returned if you request a webpage that doesn’t exist.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>状態コード404 Not Foundは、あなたが存在しないウェブ・ページを要請するならば返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stored variable or property declared with observers has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブザーバーとともに宣言される保存変数やプロパティは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string literal is a fixed sequence of textual characters surrounded by a pair of double quotes ("").</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラルは、固定された順序での原文ままの文字たちで、二重引用符（""）に囲まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string literal is a sequence of characters surrounded by double quotes, with the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラル文字列は、以下の形式で、二重引用符に囲まれている一連の文字です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強い参照循環はまた、あなたがあるクロージャをクラスインスタンスのプロパティに代入して、そのクロージャの本文がそのインスタンスを捕獲するならば、起こることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A strong reference cycle is created between the two.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強い参照循環は、２つ作られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subclass can implement a superclass designated initializer as a subclass convenience initializer as part of satisfying rule 2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスは、規則２を満たすことの一部として、スーパークラスの指定イニシャライザをサブクラスの便宜イニシャライザとして実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subclass can provide its own custom implementation of an instance method, type method, instance property, type property, or subscript that it would otherwise inherit from a superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスは、それ独自のあつらえの実装のインスタンスメソッド、型メソッド、インスタンスプロパティ、型プロパティ、または添え字を提供することができます、それらはそれがそうしなければスーパークラスから継承するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subclass cannot have a higher access level than its superclass—for example, you cannot write a public subclass of an internal superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスには、そのスーパークラスより高いアクセス水準があることができません ― 例えば、あなたは内部のスーパークラスに属する公開のサブクラスを書くことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subclass inherits its superclass’s deinitializer, which is implicitly called just before the subclass object is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスはそのスーパークラスのデイニシャライザを継承します、それは、サブクラスオブジェクトが割り当て解除される直前に、暗黙のうちに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subclass’s implementation of that initializer must also be marked with the required declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのイニシャライザのサブクラスでの実装は、また、required宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A throwing function propagates errors that are thrown inside of it to the scope from which it’s called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スロー関数は、それの内部でスローされるエラーを、そこからそれが呼び出されるスコープへと伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A throwing method can’t override a nonthrowing method, and a throwing method can’t satisfy a protocol requirement for a nonthrowing method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローメソッドは、非スローメソッドをオーバーライドすることができません、そしてスローメソッドは、非スローメソッド用のプロトコル要件を満たすことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A throwing method can’t override a rethrowing method, and a throwing method can’t satisfy a protocol requirement for a rethrowing method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローメソッドは、再スローメソッドをオーバーライドできません、そしてスローメソッドは再スローメソッド用のプロトコル要件を満たすことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A token consists of an identifier, keyword, punctuation, literal, or operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるトークンは１つの識別子、キーワード、句読点、リテラル、または演算子からなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A trailing closure is written after the function call’s parentheses, even though it is still an argument to the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後付クロージャは、関数呼び出しの丸括弧の後に書かれます、それでもそれはまだその関数に対する引数であるけれども。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tuple expression can contain zero expressions, or it can contain two or more expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル式はゼロ個の式を含むことができます、またはそれは２つまたはそれ以上の式を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tuple type is a comma-separated list of types, enclosed in parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル型は、丸括弧で囲まれた、コンマ区切りのいくらかの型のリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tuple type’s access level is deduced automatically when the tuple type is used, and cannot be specified explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるタプル型のアクセス水準は、そのタプル型が使われるときに自動的に演繹されます、したがって明示的に指定されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type alias can have an access level less than or equal to the access level of the type it aliases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアスは、それがエイリアスする型のアクセス水準と同等またはそれより下のアクセス水準を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type alias declaration can use generic parameters to give a name to an existing generic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアス宣言は、総称体パラメータを使ってある名前を既存の総称体型に与えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type can conform to a protocol with a lower access level than the type itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型は、その型自体よりも低いアクセス水準を持つプロトコルに準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type identifier refers to either a named type or a type alias of a named or compound type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型識別子は、名前付きの型か、名前付きまたは複合の型の型エイリアスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type inheritance clause begins with a colon (:), followed by either a class requirement, a list of type identifiers, or both.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型継承節はコロン（:）で始まり、ひとつのクラス要件、型識別子のリストをひとつ、このどちらか、または両方が続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type inheritance clause in an enumeration definition can be either a list of protocols, or in the case of an enumeration that assigns raw values to its cases, a single, named type that specifies the type of those raw values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙定義における型継承節は、プロトコルのリスト、または生の値をそれのケース節に割り当てる列挙のケース節においては、それらの生の値を指定する単一の名前付き型、このどちらかであることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type inheritance clause is also used to specify a class requirement on a protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型継承節はまた、あるプロトコル上のclass要件を指定するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type inheritance clause is used to specify which class a named type inherits from and which protocols a named type conforms to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型継承節は、ある名前付きの型が継承するのはどのクラスからか、およびある名前付きの型が準拠するのはどのプロトコルに対してかを指定するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type method can call another type method with the other method’s name, without needing to prefix it with the type name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型メソッドは、別の型メソッドを他のメソッドの名前を使って呼ぶことができます、その型名をそれの前に置く必要なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type must be hashable in order to be stored in a set—that is, the type must provide a way to compute a hash value for itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型は、集合のキー型として使われるためにハッシュ化される必要があります ― すなわち、その型はそれ自身でハッシュ値を計算するためのある方法を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type safe language encourages you to be clear about the types of values your code can work with.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型安全な言語は、あなたのコードが扱うことができる値の型について、あなたが確信を持つように促します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value is passed to a function, but an invalid value means that the function cannot fulfill its task.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある値が関数に渡される、しかし、無効な値は関数がその作業を成し遂げることができないことを意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value of true in the array represents a black square and a value of false represents a white square.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この配列の中のtrueの値は黒の正方形を表します、そしてfalseの値は白い正方形を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variadic parameter is treated as an array that contains elements of the base type name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長パラメータは、基本の型の名前の要素たちが入っている配列とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A way to refer to ranges within a series, perhaps encapsulating a start property and a length property, both of type Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある連続の中に納まるいくつかの範囲を参照する一つの方法、おそらくはstartプロパティとlengthプロパティ（両方とも型Int）をカプセル化する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ARC automatically frees up the memory used by class instances when those instances are no longer needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ARCはクラスインスタンスによって使われるメモリを、それらのインスタンスがもはや必要でないとき、自動的に自由にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ARC does not deallocate the Person instance until the third and final strong reference is broken, at which point it is clear that you are no longer using the Person instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ARCは、Personインスタンスの割り当て解除を３番目の最後に残ったの強い参照が壊れるまで行いません。その時点では、あなたがもはやPersonインスタンスを使っていないことは明白です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ARC in Action</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ARCの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ARC will not deallocate an instance as long as at least one active reference to that instance still exists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ARCは、そのインスタンスへの少なくとも１つの活発な参照がまだ存在する限り、インスタンスの割り当て解除をしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>About Swift</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトについて</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>About the Language Reference</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言語リファレンスについて</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Abstract concepts like Hashable characterize types in terms of their conceptual characteristics, rather than their explicit type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Hashableのような抽象的な概念たちは、それらの概念上の特徴の観点から型を特徴づけます、そのはっきりとした型そのものではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Control</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス制御</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Control Levels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス制御水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Control Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス制御構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Levels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Levels for Frameworks</seg>
      </tuv>
      <tuv lang="JA">
        <seg>フレームワークのためのアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Levels for Single-Target Apps</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単一ターゲットアプリのためのアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Levels for Unit Test Targets</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニットテストターゲットのためのアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access control is discussed in detail in Access Control.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス制御は、アクセス制御で詳細に議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access levels in Swift follow an overall guiding principle: No entity can be defined in terms of another entity that has a lower (more restrictive) access level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの中のアクセス水準は、以下の全体的な原理指針に従います：実在は、より低い（制限のより多い）アクセス水準をもつ別の実在の観点から定義されることができない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access properties of a class instance with dot (.) syntax, as described in Accessing Properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスインスタンスのプロパティにドット（.）構文でアクセスしてください、プロパティにアクセスするで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access to that member is never inlined or devirtualized by the compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのメンパーに対するアクセスは、決してコンパイラによってインラインまたはデバーチャライズされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Enumeration Cases</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Properties Through Optional Chaining</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を通してプロパティにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Subscripts Through Optional Chaining</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を通して添え字にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Subscripts of Optional Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル型の添え字にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Superclass Methods, Properties, and Subscripts</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスメソッド、プロパティ、そして添え字へのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing and Modifying a Dictionary</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書へのアクセスと変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing and Modifying a Set</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合へのアクセスと変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing and Modifying a String</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列へのアクセスと修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing and Modifying an Array</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列へのアクセスと変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add a color() method to Suit that returns “black” for spades and clubs, and returns “red” for hearts and diamonds.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>color()メソッドをSuitに加えてください、それはスペードとクラブのために「黒」を、そしてハートとダイヤのために「赤」を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add a constant property with let, and add another method that takes an argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数プロパティをletを使って１つ加えてください、そして１つの引数をとる別のメソッドを加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add a method to Card that creates a full deck of cards, with one card of each combination of rank and suit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cardにひとつのメソッドを加えてください、それはランク（順位）とスート（記号）の各組合せのカード１枚をもつ、カードの完全なデック（一組）をつくるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add a parameter to include today’s lunch special in the greeting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今日のスペシャル・ランチをこの挨拶に含めるために、パラメータをひとつ加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add a third case to ServerResponse and to the switch.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第３の場合をServerResponseに、そしてスイッチに加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add an else clause that sets a different greeting if optionalName is nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>optionalNameがnilならば異なる挨拶を設定するelse節を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add another variable to keep track of which kind of number was the largest, as well as what that largest number was.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最も大きい数が何であったかだけでなく、どの種類の数が最も大きいものであったかについて情報を把握するために、もう一つの変数を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add code to throw an error inside the do block.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コードを加えてエラーをdoブロック内部でスローしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add computed instance properties and computed type properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算インスタンスプロパティと計算型プロパティを加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a description of Failable Initializer Requirements for protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティのための失敗できるイニシャライザ要件の説明を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a full guide to Failable Initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>完全なガイドを失敗できるイニシャライザに加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new chapter about Access Control.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい章をアクセス制御について加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new guide section about String Indices.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列インデックスについての新しいガイド節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new reference section about Failable Initializers, which can trigger initialization failure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいリファレンス節を失敗できるイニシャライザについて加えました、それは初期化失敗を起こすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about Accessing Subscripts of Optional Type through optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を通してオプショナル型の添え字にアクセスすることについての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about Class-Only Protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス専用プロトコルについての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about Dictionary Type Shorthand Syntax, which is written as [KeyType: ValueType].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書型の略記構文についての新しい節を加えました、それは[KeyType: ValueType]のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about Hash Values for Set Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Set型のためのハッシュ値についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about Initializer Parameters Without Argument Labels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルなしのイニシャライザ・パラメーターについての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about Initializer Requirements in protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルにイニシャライザ要件についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about Optional Tuple Return Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルタプルの戻り型についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about Required Initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>必須イニシャライザについての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note about the order in which Prefix and Postfix Operators are applied when both a prefix and a postfix operator are applied to the same operand.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞および接尾辞演算子の両方が同じ演算数に適用される時に、接頭辞および接尾辞演算子が適用される順番についての注記を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note that the start value a for the Range Operators a...b and a..&lt;b must not be greater than the end value b.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>範囲演算子a...bとa..&lt;bのための開始値aが終了値bより大きくてはならないことの注意を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the Access Levels section with information about the scope of private access.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節アクセス水準にprivateアクセスのスコープについての情報の注意書きを加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the Debugging with Assertions section about when user-defined assertions are disabled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明を使ってデバッグする節に、ユーザ定義の表明が使用不能にされた時についての注を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the Handling Errors section about the performance of executing a throw statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーを処理する節にthrow文の実行性能について注意を追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the Metatype Type section about constructing class instances from metatype values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メタタイプ値からクラスインスタンスを構成することについての注をメタタイプ型節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the Property Observers section about property observers being called when you pass a property as an in-out parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある注意をプロパティオブザーバー節に加えました、あなたがあるプロパティをin-outパラメータとして渡すとき呼び出されているプロパティオブザーバーについて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the Rethrowing Functions and Methods section that rethrowing functions can’t directly throw errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある注意を再スローを行う関数とメソッド節に加えた、それは再スロー関数が直接にエラーをスローできないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the Type Casting for Any and AnyObject section about using an optional value when a value of type Any is expected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの注をAnyおよびAnyObjectに対する型キャストの節へ型Anyの値が期待される時にオプショナル値を使うことについて加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the Weak References section about the differences in weak references between garbage collected systems and ARC.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節弱い参照にガベージコレクトシステムとARCとの間の弱い参照における違いについての情報の注意書きを加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the Weak References section about weak references being unsuitable for caching.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャッシュするのにふさわしくない弱い参照についての注を弱い参照節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a section about error handling to the A Swift Tour chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラー処理についての節をスウィフトツアー章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added an example of Extending a Generic Type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体型を拡張するの例を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added an example of using multiple optional bindings with a where clause to the Optional Binding section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のオプショナル束縛をwhere節とともに使う例をオプショナルの束縛節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added an example that uses the ?? operator to the A Swift Tour chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>??演算子を使う例をスウィフトツアー節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about API availability checking to the Checking API Availability section of the Control Flow chapter and the Availability Condition section of the Statements chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>API有効性確認についての情報を章制御の流れの節API有効性の確認および章文の節有効性条件に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about access control for unit testing to the Access Levels for Unit Test Targets section of the Access Control chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニットテストのためのアクセス制御についての情報を章アクセス制御の節ユニットテストターゲットのためのアクセス水準に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about accessing the selector of an Objective-C property’s getter or setter to the Selector Expression section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cプロパティのゲッターやセッターのセレクタにアクセスすることについての情報をセレクタ式の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about build configuration and line control statements to the Compiler Control Statements section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビルド設定および行制御文についての情報をコンパイラ制御文節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about comparing tuples to the Comparison Operators section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルの比較についての情報を比較演算子節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about error handling to the Error Handling chapter, the Do Statement section, the Throw Statement section, the Defer Statement section, and the Try Operator section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラー処理についての情報を章エラー処理、節do文、節throw文、節defer文、そして節try演算子に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about explicitly referencing an initializer to the Initializer Expression section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的にあるイニシャライザを参照することについての情報をイニシャライザ式節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about how to conditionally compile code depending on the version of Swift being used to the Conditional Compilation Block section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>使われているスウィフトのバージョンに基づいて条件付きでコードをコンパイルする方法についての情報を条件コンパイルプロック節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about how to distinguish between methods or initializers whose names differ only by the names of their arguments to the Explicit Member Expression section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの名前がそれらの引数の名前でだけ異なるところのメソッド間またはイニシャライザ間で区別をする方法についての情報を明示的メンバー式節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about how type inference works with Literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型推論がリテラルで働く方法についての情報を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about operator precedence groups to the Precedence for Custom Infix Operators section of the Advanced Operators chapter, and to the Precedence Group Declaration section of the Declarations chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子優先順位グループについての情報を先進の演算子の章のあつらえの演算子に対する優先順位の節に、そして宣言の章の優先順位グループ定義の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about playground literals to the Literal Expression section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレイグラウンドリテラルについての情報をリテラル式の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about protocol extensions to the Protocol Extensions section of the Protocols chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル拡張についての情報を章プロトコルの節プロトコル拡張に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about recursive enumerations to the Recursive Enumerations section of the Enumerations chapter and the Enumerations with Cases of Any Type section of the Declarations chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再帰列挙についての情報を列挙章の再帰列挙節および宣言章の随意の型のケース節をもつ列挙節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about switch cases that have multiple patterns to the Switch section of the Control Flow chapter and the Switch Statement section of the Statements chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のパターンを持つスイッチケース節についての情報を、章制御の流れの節スイッチと章文の節スイッチ文に加えた</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the #selector syntax for Objective-C selectors to the Selector Expression section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cセレクタのための#selector構文についての情報をセレクタ式節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the @GKInspectable attribute to the Declaration Attributes section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@GKInspectable属性についての情報を宣言属性節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the @autoclosure attribute—including its @autoclosure(escaping) form—to the Autoclosures section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@autoclosure属性についての情報を ― それの@autoclosure(escaping)形式を含めて ― 自動クロージャ節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the availability attribute to the Declaration Attributes section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>availability属性についての情報を宣言属性節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the dynamic declaration modifier in Declaration Modifiers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言修飾子においてdynamic宣言修飾子についての情報を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the open and fileprivate access-level modifiers to the Access Control chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>openおよびfileprivateアクセス水準修飾子についての情報をアクセス制御の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the unowned, unowned(safe), and unowned(unsafe) declaration modifiers in the Declaration Modifiers section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>unowned、unowned(safe)、そしてunowned(unsafe)宣言修飾子についての情報を宣言修飾子の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the behavior of enumeration cases with String raw values to the Implicitly Assigned Raw Values section of the Enumerations chapter and the Enumerations with Cases of a Raw-Value Type section of the Declarations chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Stringの生の値を持つ列挙ケース節の挙動についての情報を列挙章の暗黙的に割り当てられる生の値節および宣言章の「生の値」型のケース節を持つ列挙節に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the behavior of in-out parameters to the In-Out Parameters section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータの挙動についての情報をin-outパラメータ節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the new guard statement to the Early Exit section of the Control Flow chapter and the Guard Statement section of the Statements chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいguard文についての情報を章制御の流れの節早期退出および章文の節guard文に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the new try? keyword to the Converting Errors to Optional Values section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいtry?キーワードについての情報をエラーをオプショナルの値に変換する節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the new Swift standard library print(_:separator:terminator) function to the Printing Constants and Variables section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいスウィフト標準ライブラリprint(_:separator:terminator)関数についての情報を定数と変数を出力する節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the new optional pattern to the Optional Pattern section of the Patterns chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいオプショナルパターンについての情報を章パターンの節オプショナルパターンに追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about throwing an error inside the catch block of a rethrowing function to the Rethrowing Functions and Methods section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再スロー関数のcatchプロック内部でエラーをスローすることについての情報を、節再スローを行う関数とメソッドに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about using enumeration cases as functions to the Enumerations with Cases of Any Type section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節を関数として使うことについての情報を随意の型のケース節をもつ列挙節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about using keywords as external parameter names to the Keywords and Punctuation section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーワードを外部パラメータ名として使うことについての情報をキーワードと句読点節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information to the Capture Lists section about how values specified in closure capture lists are captured.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのようにクロージャキャプチャリストにおいて指定された値がキャプチャされるかについて情報をキャプチャリスト節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information to the Metatype Type section about comparing metatype values and using them to construct instances with initializer expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メタタイプ型節に、メタタイプ値の比較と、それらをインスタンスを作り上げるためにイニシャライザ式とともに使う事についての情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information to the Overriding a Failable Initializer section about how a nonfailable initializer can delegate up to a failable initializer by force-unwrapping the result of the superclass’s initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザのオーバーライド節に失敗できないイニシャライザが失敗できるイニシャライザにまで委任することを、スーパークラスのイニシャライザの結果を強制アンラップすることでできる方法についての情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information to the String Literals section about how concatenating string literals using the + operator happens at compile time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラル節に、どのように+演算子を使った文字列リテラルの連結がコンパイル時に起こるかについての情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information to the Type Alias Declaration section about generic type aliases and using type aliases inside of protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>情報を型エイリアス宣言の節に加えた、プロトコルの内部での総称体型エイリアスと型エイリアス利用について。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added more information about curried functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>カリー化関数についての更なる情報を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added similar information about the do statement in the Do Statement section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>do文について同様の情報をdo文の節において追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Escaping Closures section with information about the @noescape attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>脱出クロージャの節を@noescape属性についての情報とともに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding Constraints to Protocol Extensions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル拡張に制約を加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding Protocol Conformance with an Extension</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張を使ってプロトコル準拠を加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding protocol conformance in this way is described in Adding Protocol Conformance with an Extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この方法でプロトコル準拠を加えることは拡張を使ってプロトコル準拠を加えるで記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Addition (+)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加算（+）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, although operators can contain an exclamation mark (!), postfix operators cannot begin with either a question mark or an exclamation mark.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに加えて、演算子は感嘆符（!）を含むことができますが、接尾辞演算子は、疑問符または感嘆符のどちらかで始まることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, when an instance is no longer needed, ARC frees up the memory used by that instance so that the memory can be used for other purposes instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その上に、インスタンスがもはや必要でないとき、ARCはそのインスタンスによって使われるメモリを開放します、それでメモリが代わりに他の目的のために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Advanced Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>先進の演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After a type alias is declared, the aliased name can be used instead of the existing type everywhere in your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアスが宣言されたあと、エイリアス（別名）にされた名前は、あなたのプログラムの至る所で既存の型の代わりに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After applying the provided closure to each array element, the map(_:) method returns a new array containing all of the new mapped values, in the same order as their corresponding values in the original array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>提供されたクロージャを各配列要素に適用した後に、map(_:)メソッドは、新しい対応付けられる値の全てを、もとの配列のそれらの対応する値と同じ順序で含んでいる新しい配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After calling increment(forCount:), the optional Int that it returns is unwrapped into a constant called amount, using optional binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>increment(forCount:)呼び出しの後、それが返すオプショナルのIntは、オプショナル束縛を使って、amountと呼ばれる定数へとアンラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After calling super.init(), the original value of numberOfWheels is replaced with a new value of 2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>super.init()の呼び出しの後、numberOfWheelsのもとの値は新しい値の2で置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After capturing these values, incrementer is returned by makeIncrementer as a closure that increments runningTotal by amount each time it is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの値を捕獲した後に、incrementerはmakeIncrementerによって、それが呼ばれるたびにrunningTotalをamountによって増加させるクロージャとして返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After creating the dictionary, this example uses subscript assignment to add a String key of "bird" and an Int value of 2 to the dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書を作成した後に、この例は、辞書にStringキーの"bird"とInt値の2を加えるために添え字代入を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After declaring a new operator, you implement it by declaring a static method that has the same name as the operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある新しい演算子を宣言した後に、あなたはその演算子と同じ名前を持つ静的メソッドを宣言することによってそれを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After defining this extension, you can call the repetitions(task:) method on any integer to perform a task that many number of times:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この拡張を定義した後、あなたはrepetitions(task:)メソッドをあらゆる整数上で呼び出して、ある作業をそれだけ多くの回数実行できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After defining this extension, you can use any Array as a Container.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この拡張を定義した後に、あなたはどんなArrayでもContainerとして使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After doing so, the initializer delegates up to the init(name: String) initializer of the Food class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうした後に、イニシャライザは上ってFoodクラスのinit(name: String)イニシャライザに委任します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After executing the code inside the switch case that matched, the program exits from the switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>合致したスイッチのケース節（case）の内部のコードを実行した後に、プログラムはスイッチ文から出ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After making this check, the function iterates over all of the items in someContainer with a for-in loop and the half-open range operator (..&lt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この確認の後、関数はsomeContainerの項目の全てに渡ってfor-inループと半開範囲演算子（..&lt;）を使って繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After popping a value, the stack once again holds three values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値をポップした後では、スタックは再び３つの値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After rolling the dice, the player moves forward by diceRoll squares.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さいころを転がした後、プレーヤーは正方形をdiceRoll分だけ前進します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the switch statement has finished executing, the number’s description is printed using the print(_:separator:terminator:) function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文が実行を終えたあと、その数の解説はprint(_:separator:terminator:)関数を使用して出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the array is created, the name of the ShoppingListItem at the start of the array is changed from "[Unnamed]" to "Orange juice" and it is marked as having been purchased.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列がつくられたあと、配列の始めのShoppingListItemの名前は、"[Unnamed]"から"Orange juice"へ変えられます、そしてそれは購入済みとして印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the code checks for snakes and ladders, the dice is rolled and the player is moved forward by diceRoll squares.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コードがヘビとはしごについて調べた後、さいころが振られてプレーヤーはdiceRollだけの正方形を前進させられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the code within a matched case has finished executing, the program exits from the switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マッチされたケース節内のコードが実行を終えたあと、プログラムはswitch文から出ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the first character, combining Unicode characters are also allowed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の文字の後は、合成ユニコード文字もまた許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the first character, digits and combining Unicode characters are also allowed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の文字の後は、桁および合成Unicode文字もまた、許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the statement is executed, the value of index is updated to contain the second value in the range (2), and the print(_:separator:terminator:) function is called again.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文が実行されたあと、indexの値は範囲の２番目の値（2）を含むように更新されます、そしてprint(_:separator:terminator:)関数が再び呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the switch statement completes its execution, the example uses optional binding to determine whether a value was found.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スイッチ文がその実行を完了したあと、例は値が見つけられたかどうか決定するためにオプショナル束縛を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the temporary constants are declared, they can be used within the case’s code block.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一時的な定数が宣言された後、それらはケース節のもつコードのかたまり内で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After this happens, there are no more strong references to the CreditCard instance, and it too is deallocated:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが起こったあと、CreditCardインスタンスへの強い参照はもうありません、そして、それも割り当て解除されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, the first three codeUnit values (68, 111, 103) represent the characters D, o, and g, whose UTF-16 code units have the same values as in the string’s UTF-8 representation (because these Unicode scalars represent ASCII characters).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再び、最初の３つのcodeUnit値（68、111、103）は文字D、o、そしてgを表します、これらのUTF-16符号単位はこの文字列のUTF-８叙述の場合と同じ値を持ちます（なぜなら、これらのユニコード・スカラーがASCII文字を表わすからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All addition and subtraction for signed integers is performed in bitwise fashion, with the sign bit included as part of the numbers being added or subtracted, as described in Bitwise Left and Right Shift Operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号つき整数に対する全ての加算と減算は、ビット単位の左および右シフト演算子で記述されるように、加算または減算される数の一部として含めらる符号ビットとともに、ビット単位流儀で実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All entities in your code (with a few specific exceptions, as described later in this chapter) have a default access level of internal if you do not specify an explicit access level yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードの中の全ての実在は（この章の後刻に記述されるように、２、３の特定の例外を除いて）、あなたが明示的に独自にアクセス水準を指定しないならば、省略時のアクセス水準である内部を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All game logic is moved into the protocol’s play method, which uses the protocol’s required dice property to provide its dice roll values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全てのゲーム論理は、プロトコルのplayメソッドに引っ越します、それは、プロトコルの要求するdiceプロパティを使ってそれのさいころ振りの値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All information about the property—including its name, type, and memory management characteristics—is defined in a single location as part of the type’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティに関する全ての情報は ― その名前、型、そしてメモリ管理などの特徴を含めて ― その型の定義の一部として一つの場所で定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All is not lost, however.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、道がないわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of Swift’s basic types (such as String, Int, Double, and Bool) are hashable by default, and can be used as set value types or dictionary key types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの基本の型の全て（String、Int、Double、そしてBoolなど）は、特に何もしなくてもハッシュ化されます、そして集合の値型または辞書のキー型として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of Swift’s basic types (such as String, Int, Double, and Bool) are hashable by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの基本の型（例えばString、Int、Double、そしてBool）の全ては、初期状態でハッシュ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of Swift’s standard types automatically support the Equatable protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの標準の型の全ては、自動的にEquatableプロトコルをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of a class’s stored properties—including any properties the class inherits from its superclass—must be assigned an initial value during initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスの全ての保存プロパティは ― そのクラスがそれのスーパークラスから継承するあらゆるプロパティを含めて ― 初期化の間に初期値を代入される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the functions you have encountered so far in this chapter have been examples of global functions, which are defined at a global scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの章においてこれまで遭遇した関数の全てはグローバルな関数の例でした、そしてそれは、グローバルなスコープで定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the game’s levels (apart from level one) are locked when the game is first played.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲームが最初にプレイされるとき、ゲームのレベルの全ては鍵をかけられます（レベル１は別として）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the other bits in firstBits and otherBits match and are set to 0 in the output value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>firstBitsとotherBitsでの他の全てのビットは一致していて、出力値において0に設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the patterns of a compound case have to include the same set of value bindings, and each binding has to get a value of the same type from all of the patterns in the compound case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある複合ケース節のパターンのすべては、同じひとそろいの値束縛を含まなければなりません、そしてそれぞれの束縛は同じ型の値をその複合ケース節のパターンのすべてから得なければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these floating-point literals have a decimal value of 12.1875:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の浮動小数点リテラルの全ては、10進の値で12.1875を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these integer literals have a decimal value of 17:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の整数リテラルの全ては、10進の値で17を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these overflow operators begin with an ampersand (&amp;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのオーバフロー演算子の全ては、アンパサンド（&amp;）から始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of this information is rolled up into the function’s definition, which is prefixed with the func keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この情報の全ては、funcキーワードを前に置かれる、関数の定義にまとめ上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of this means that you can create the Country and City instances in a single statement, without creating a strong reference cycle, and the capitalCity property can be accessed directly, without needing to use an exclamation mark to unwrap its optional value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これの全ては、あなたがCountryとCityインスタンスを１つの文において、強い参照循環をつくることなく作成できることを意味します、そして、capitalCityプロパティはそのオプショナルの値をアンラップするために感嘆符を使う必要なしに直接にアクセスされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All options you can use with string interpolation are described in String Interpolation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが文字列補間で使うことができるオプション全ては、「文字列補間」で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All parameters must have unique names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべてのパラメーターは、特有な名前を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All structures and enumerations are value types in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての構造体と列挙は、スウィフトでは値型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All structures have an automatically-generated memberwise initializer, which you can use to initialize the member properties of new structure instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての構造体は自動的に生成されるメンバー関連イニシャライザを持ちます、それはあなたが新しい構造体インスタンスのメンバープロパティを初期化するために使うことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All this makes Swift a sound future investment for developers and for Apple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全くこれはスウィフトを開発者のために、そしてアップルのために堅実な将来の投資にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All three of these initializers can be used to create new RecipeIngredient instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのイニシャライザの３つ全てが、新しいRecipeIngredientインスタンスを作るために使用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All tuple types contain two or more types, except for Void which is a type alias for the empty tuple type, ().</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべてのタプル型は２つまたはそれ以上の型を含みます、しかし空のタプル型、()に対する型エイリアスであるVoidを除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also clarified the Assignment and Copy Behavior for Strings, Arrays, and Dictionaries.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また文字列、配列、および辞書のための代入およびコピーの挙動がわかりやすくされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternative grammar productions are separated by vertical bars (|).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代替の文法導出は、垂直バー（|）で区別されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, access a String value in one of three other Unicode-compliant representations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは代わりに、３つの他のUnicode対応の表現の１つでString値にアクセスしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, access the individual element values in a tuple using index numbers starting at zero:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは、ゼロから始まっているインデックス番号を使ってタプルの個々の要素の値にアクセスしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, all items in a set can be removed with its removeAll() method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいはまた、集合の全ての項目はremoveAll()メソッドを使って取り除かれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, append an array of one or more compatible items with the addition assignment operator (+=):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいはまた、互換性を持つ１つ以上の項目からなる配列を、追加代入演算子（+=）を使って加えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, enumeration cases can specify associated values of any type to be stored along with each different case value, much as unions or variants do in other languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに、列挙ケース節は、ほとんど他の言語における共用体型やバリアント型がするように、それぞれ異なるケース節の値と一緒に格納されるために、あらゆる型の関連値を指定することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, if the context already provides type information, such as a function argument or an already typed variable or constant, you can create an empty array with an empty array literal, which is written as [] (an empty pair of square brackets):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに、前後関係がすでに型の情報を、例えば関数の引数またはすでに型指定された変数や定数などを提供するならば、あなたは空の配列を空の配列リテラル、[]（１対の空の角括弧）のように書かれるものでつくることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, if the context already provides type information, such as a function argument or an already typed variable or constant, you can create an empty set with an empty array literal:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいはまた、関数の引数や既に型付けされた変数や定数のように、文脈がすでに型情報を提供するならば、あなたは空の集合を空の配列リテラルで作成することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, remove a key-value pair from a dictionary with the removeValue(forKey:) method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは代わりに、removeValue(forKey:)メソッドで辞書から「キーと値」の対を削除してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, specify a default property value as part of the property’s declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりの方法として、省略時のプロパティ値をそのプロパティの宣言の一部として指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, use the underscore character (_), also known as the wildcard pattern, to match any possible value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいはまた、起こりうるどんな値にもマッチするにはアンダースコア文字（_）、またワイルドカードパターンとして知られるもの、を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can create a stand-alone Character constant or variable from a single-character string literal by providing a Character type annotation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは、あなたは１文字だけの文字列リテラルから単独のCharacter定数または変数を作成することが、Character型注釈を提供することによって可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can define a failable initializer that creates an implicitly unwrapped optional instance of the appropriate type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>またはその代わりに、あなたは適切な型の暗黙的にアンラップされるオプショナルのインスタンスを作成する失敗できるイニシャライザを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can mark an extension with an explicit access-level modifier (for example, private extension) to set a new default access level for all members defined within the extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに、あなたは拡張に明確なアクセス水準修飾子（例えばprivate extension）で印して、新しい省略時のアクセス水準をその拡張内で定義される全てのメンバーに設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can override a superclass failable initializer with a subclass nonfailable initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>または代わりに、あなたはスーパークラスの失敗できるイニシャライザをサブクラスの失敗できないイニシャライザでオーバーライドできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although break is not required in Swift, you can use a break statement to match and ignore a particular case or to break out of a matched case before that case has completed its execution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>breakはスウィフトでは必要とされないけれども、あなたはbreak文を特定のケース節を適合してから無視するために、または適合したケース節をそのケース節がそれの実行を完了してしまう前に抜け出すために使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although both functions have names that begin with greet, the greet(person:alreadyGreeted:) function takes two arguments but the greet(person:) function takes only one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の関数がgreetで始まる名前を持つとはいえ、greet(person:alreadyGreeted:)関数は２つの引数を取りますがgreet(person:)関数はただ１つだけ取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although conforming types don’t have to provide their own implementation of either, requirements with default implementations can be called without optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらにおいても準拠する型がそれ自身の実装を提供しなくても良いけれども、省略時の実装を持つ要件はオプショナル連鎖なしに呼ばれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although it is common to define individual types in separate source files, a single source file can contain definitions for multiple types, functions, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>通常は個々の型を別々のソースファイルに定義しますが、単一のソースファイルは、複数の型、関数、その他の定義を含むことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although it is not specified as part of the protocol, it is assumed that this value will be a number from 0.0 up to (but not including) 1.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはプロトコルの一部として指定されないけれども、この値は0.0から1.0まで（しかし含めてではない）のある数を仮定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although it’s possible for multiple parameters to have the same argument label, unique argument labels help make your code more readable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のパラメータが同じ引数ラベルを持つことは可能であるとは言え、特有な引数ラベルはあなたのコードをより読みやすくする助けとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although properties and methods declared in the superclass are inherited by the current class, designated initializers declared in the superclass are only inherited when the subclass meets the conditions described in Automatic Initializer Inheritance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスの中で宣言されるプロパティやメソッドは現在のクラスによって継承されるけれども、スーパークラスの中で宣言される指定イニシャライザはただサブクラスが自動的なイニシャライザ継承で記述される条件と出会う場合に継承されるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although technically allowed, this wouldn’t make for a very good data source.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>技術的には可能であるけれども、これはあまり良いデータ・ソースにつながりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the method name and the property name are expressions, they’re never evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>method name（メソッド名）とproperty name（プロパティ名）は式であるけれども、それらは決して評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the property name is an expression, it is never evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>property name（プロパティ名）は式であるけれども、それは決して評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the actual execution order of pattern-matching operations, and in particular the evaluation order of patterns in cases, is unspecified, pattern matching in a switch statement behaves as if the evaluation is performed in source order—that is, the order in which they appear in source code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>けれどもパターンマッチ操作の実際の実行順序、とりわけケース節の中のパターンの評価順序は指定されません、switch文のパターンマッチングはまるでその評価がソース順 ― すなわち、それらがソース・コードにおいて現れる順番、で実行されるかのようにふるまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the generic where clause provides syntactic sugar for expressing simple constraints on type parameters (for instance, &lt;T: Comparable&gt; is equivalent to &lt;T&gt; where T: Comparable and so on), you can use it to provide more complex constraints on type parameters and their associated types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体where節は、型パラメータ上で単純な制約を表すために構文糖衣を提供しますが（例えば、&lt;T: Comparable&gt;は&lt;T&gt; where T: Comparableに等しいなどなど）、あなたはそれを使ってより複雑な制約を型パラメータとそれの関連型に提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the indexes used to access the elements can be of any type, each parameter must include a type annotation to specify the type of each index.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>要素にアクセスするために使用されるインデックスは、どんな型でも可能であるけれども、各パラメータは型注釈を含んで、各インデックスの型を指定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the rest of its functionality is not shown, the purpose of this DataManager class is to manage and provide access to this array of String data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その機能性の残りの部分は示されないけれども、このDataManagerクラスの目的はこのStringデータの配列を管理して、アクセス提供することになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the two forms are functionally equivalent, the shorthand form is preferred whenever possible.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの書式は機能的に等しいですが、可能であればいつでも略記書式が好ましいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of a dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの書式は機能的に同一であるけれども、短縮形がむしろ好まれ、このガイドを通して辞書の型に言及するときに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of an array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの書式は機能的に同一であるけれども、短縮形がむしろ好まれ、このガイドを通して配列の型に言及するとき使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the unary plus operator doesn’t actually do anything, you can use it to provide symmetry in your code for positive numbers when also using the unary minus operator for negative numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項プラス演算子は実際に何もしないけれども、あなたは、負の数に単項マイナス演算子を使うときに、正の数に対してもまたあなたのコードで釣り合いを取るためにそれを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although these types, functions, and operators are not part of the Swift language itself, they are used extensively in the discussions and code examples in this part of the book.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型、関数、そして演算子は、スウィフト言語自身の一部ではないけれども、それらは本のこの部分の議論とコード例で広く使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although they are implemented as computed properties, the names of these properties can be appended to a floating-point literal value with dot syntax, as a way to use that literal value to perform distance conversions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは計算プロパティとして実装されるけれども、これらのプロパティの名前はある浮動小数点リテラル値に、そのリテラル値を距離変換を実行するために使う方法として、ドット構文で追加されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although you can define custom operators that contain a question mark (?), they can’t consist of a single question mark character only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは疑問符（?）を含むあつらえの演算子を定義できるけれども、それは単一の疑問符文字だけから構成されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although you can query the current value of the numberOfEdits property from within another source file, you cannot modify the property from another source file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは別のソースファイル内からnumberOfEditsプロパティの現在の値についてたずねることができるけれども、あなたは別のソースファイルからこのプロパティを修正できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although you write return nil to trigger an initialization failure, you do not use the return keyword to indicate initialization success.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはreturn nilを書くことで初期化失敗を引き起こすけれども、あなたはreturnキーワードを初期化成功を指し示すためには使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always give type parameters upper camel case names (such as T and MyTypeParameter) to indicate that they are a placeholder for a type, not a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが、値ではなく、型のためのプレースホルダであることを示すために、型パラメータに常にアッパーキャメルケース名（例えばTやMyTypeParameterなど）を与えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always make sure that an optional contains a non-nil value before using ! to force-unwrap its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>必ずあるオプショナルがnilではない値を含むことを、それの値を強制アンラップする!を使う前に確かめてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always prefix type property requirements with the static keyword when you define them in a protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあるプロトコルにおいてそれを定義するとき、常に、型プロパティ要件の前にstaticキーワードを置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always use a break statement to ignore a switch case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switchケース節を無視するために、常にbreak文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always use a normal optional type if you need to check for a nil value during the lifetime of a variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある変数の生涯のある時期にnil値について確認する必要があるならば、必ず普通のオプショナル型を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Int8 constant or variable can store numbers between -128 and 127, whereas a UInt8 constant or variable can store numbers between 0 and 255.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Int8定数または変数は、-128と127の間の数を保存することができる一方、UInt8定数または変数は、0と255の間の数を保存することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An if statement is used for executing code based on the evaluation of one or more conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文は、一つ以上の条件の評価に基づいてコードを実行するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An if statement chained together in this way has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このやり方で一緒につながれるif文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array literal is an ordered collection of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列リテラルは、順序付けられた値のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array stores values of the same type in an ordered list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列は、同じ型の値を順番をつけられたリストに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An associated type gives a placeholder name to a type that is used as part of the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型は、プロトコルの一部として使われる型にプレースホルダ名を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An autoclosure is a closure that is automatically created to wrap an expression that’s being passed as an argument to a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動クロージャは、自動的に作成されて、引数として関数に渡されている式を包み込むクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An availability condition is used as a condition of an if, while, and guard statement to query the availability of APIs at runtime, based on specified platforms arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効性条件は、if、while、そしてguard文の条件として使われて、APIの有効性を実行時に、指定されたプラットホーム引数に基づいて問いただします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An enumeration case pattern matches a case of an existing enumeration type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節パターンは、既存の列挙型のケース節にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An enumeration declaration introduces a named enumeration type into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙宣言は、名前をつけられた列挙型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An enumeration defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙は、一群の関連した値のための共通の型を定義して、それらの値を型安全な方法であなたのコード内で扱えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An explicit member expression allows access to the members of a named type, a tuple, or a module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的メンバー式は、名前付きの型、タプル、またはモジュールのメンバーに対するアクセスを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An expression pattern represents the value of an expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式パターンは、ある式の値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An extension declaration allows you to extend the behavior of existing class, structure, and enumeration types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言は、既存のクラス、構造体、および列挙型の挙動を拡張することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An identifier pattern matches any value and binds the matched value to a variable or constant name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子パターンは、どんな値にでもマッチして、マッチされた値を変数や定数の名前に縛りつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An implicit member expression is an abbreviated way to access a member of a type, such as an enumeration case or a type method, in a context where type inference can determine the implied type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙のメンバー式は、型推論が暗黙の型を決定することができる前後関係において、例えば列挙のケース節や型メソッドなど、ある型のメンバーにアクセスするための簡略された方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An import declaration lets you access symbols that are declared outside the current file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポート宣言は、あなたに現在のファイルの外側で宣言されるシンボルにアクセスさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An infix operator is a binary operator that is written between its two operands, such as the familiar addition operator (+) in the expression 1 + 2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接中辞演算子は、それの２つ演算数の間で書かれる二項演算子です、例えばよく知られた式1 + 2での加算演算子（+）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An initializer declaration introduces an initializer for a class, structure, or enumeration into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ宣言は、あなたのプログラムにクラス、構造体、または列挙のためのイニシャライザを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An initializer expression provides access to a type’s initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、スーパークラスのイニシャライザに委任するために、イニシャライザ式を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An n-times-table is based on a fixed mathematical rule.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>九九のnの段は、決められた数学的な規則に基づきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An octal number, with a 0o prefix</seg>
      </tuv>
      <tuv lang="JA">
        <seg>８進数は、接頭辞0oつきで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator declaration introduces a new infix, prefix, or postfix operator into your program and is declared using the operator keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子宣言は、新しい接中辞、接頭辞、または接尾辞演算子をあなたのプログラムに導入します、そしてキーワードoperatorを使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An operator is a special symbol or phrase that you use to check, change, or combine values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子は、あなたがいろいろな値を調べたり、変えたり、結合したりするために使う、特別な記号または語句です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional pattern matches values wrapped in a some(Wrapped) case of an Optional&lt;Wrapped&gt; enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルパターンは、Optional&lt;Wrapped&gt;列挙のSome(Wrapped)ケース節でラップされる値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional-chaining expression provides a simplified syntax for using optional values in postfix expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式は、オプショナルの値を使うために単純化された構文を接尾辞式において提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional-try expression consists of the try? operator followed by an expression that can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルtry式は、try?演算子と後につづくエラーをスローできる１つの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Optional-Chaining Expression must appear within a postfix expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつのオプショナル連鎖式が、ひとつの接尾辞式の内部に現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An HTTP status code is a special value returned by a web server whenever you request a web page.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>HTTP状態コードは、あなたがウェブ・ページを要請するときはいつでもウェブ・サーバーによって返されるある特別な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An arbitrary Unicode scalar, written as \u{n}, where n is a 1–8 digit hexadecimal number with a value equal to a valid Unicode code point</seg>
      </tuv>
      <tuv lang="JA">
        <seg>任意のユニコード・スカラー、\u{n}のように書かれます、ここでnは有効なユニコードコードポイントと等しい値を持つ１-８桁の16進数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array allows new items to be inserted and removed at any location in the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列は、新しい項目を差し込まれたり取り外除かれることがその配列のどんな場所においても許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array literal is written as a list of values, separated by commas, surrounded by a pair of square brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列リテラルは、一対の角括弧に囲まれて、コンマで区切られる値のリストとして書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An arrow (→) is used to mark grammar productions and can be read as “can consist of.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>矢印（→）を使って文法導出を示します、「その文法はこうしたものから成り立つことができる」と読まれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An assertion also lets you provide a suitable debug message as to the nature of the assert.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明はまた、その表明することの種類によってあなたに適切なデバッグ・メッセージを提供させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An assertion is a runtime check that a Boolean condition definitely evaluates to true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明は、ある実行時確認です、それは、あるブール条件が間違いなくtrueになるか見ることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An assertion is triggered if you try to access a subscript that is outside of the matrix bounds:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがマトリックス境界の外にある添え字にアクセスしようとするならば、表明が引き起こされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An associated type provides an alias for a type that is used as part of a protocol’s declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型は、エイリアスをプロトコルの宣言の一部として使われる型のために用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An autoclosure lets you delay evaluation, because the code inside isn’t run until you call the closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動クロージャは、あなたに評価を延期させます、内部のコードはあなたがそのクロージャを呼び出すまで実行されないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An availability condition has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効性条件は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An eight-bit number has seven value bits, so this means 2 to the power of 7, or 128.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>８ビットの数は７つの値ビットを持ちますので、これは2の7乗、つまり128を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An element name consists of an identifier followed immediately by a colon (:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>要素名は、識別子に直ちにコロン（：）が続くものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An empty dictionary literal is written as a colon inside a pair of brackets ([:]) to distinguish it from an empty array literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の辞書リテラルは、一対の角括弧の中のコロン（[:]）として書かれることで、空の配列リテラルからそれを区別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An enclosing function can also return one of its nested functions to allow the nested function to be used in another scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>囲んでいる関数は、また、入れ子にされた関数が別のスコープにおいて使われるのを許可するために、その入れ子にされた関数のうちの１つを返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An enumeration case that’s marked with the indirect modifier must have an associated value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>indirect修飾子で印される列挙ケース節は、関連値を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An enumeration that is marked with the indirect modifier can contain a mixture of cases that have associated values and cases those that don’t.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>indirect修飾子で印される列挙は、関連値を持つケース節とそうでないケース節の入り交じったものを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An explicit spelling of unowned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>unownedの明確なつづり方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある拡張書記素クラスタは１つ以上のユニコード・スカラーの連なりです、それは（組み合わされて）人間の読み取り可能な１つの文字を作り出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An extension can extend an existing type to make it adopt one or more protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、既存の型を拡張して、それが一つ以上のプロトコルを採用するようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An implicitly unwrapped optional is a normal optional behind the scenes, but can also be used like a nonoptional value, without the need to unwrap the optional value each time it is accessed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナルは、舞台裏では普通のオプショナルです、しかしまたオプショナルでない値のように扱うこともできます、それがアクセスされるたびにオプショナルの値をアンラップする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An in-out parameter has a value that is passed in to the function, is modified by the function, and is passed back out of the function to replace the original value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータはある値を持ち、それは関数の中に渡されて、その関数によって修正されて、それから逆にその関数の外に渡されて本来の値に取って代わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An initializer cannot call any instance methods, read the values of any instance properties, or refer to self as a value until after the first phase of initialization is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザは、初期化の最初の段階が完了するまで、どんなインスタンスメソッドも呼ぶこと、どんなインスタンスプロパティの値も読むこと、またはselfをひとつの値として参照することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An instance method can be called only on a specific instance of the type it belongs to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスメソッドは、それが属している型のある特定のインスタンスでだけ呼ばれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An instance method has implicit access to all other instance methods and properties of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるインスタンスメソッドは、無条件にその型の他のインスタンスメソッドとプロパティの全てへのアクセスを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An instance of a class is traditionally known as an object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスのインスタンスは、伝統的にオブジェクトとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An integer subscript index is passed to a custom subscript implementation, but the subscript index value could be too low or too high.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数添え字インデックスがカスタムメイドの添え字実装を渡される、しかしその添え字インデックス値は低すぎるか高すぎる可能性がある。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An integer type can be initialized with a Double or Float value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数型は、DoubleまたはFloat値で初期化されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional Int is written as Int?, not Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルのIntは、Int?のように書かれます、Intではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional protocol requirement can be called with optional chaining, to account for the possibility that the requirement was not implemented by a type that conforms to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルのプロトコル要件は、オプショナル連鎖を使って呼び出されることができます、それによってプロトコルに準拠する型によって要件が満たされなかったという可能性に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional represents two possibilities: Either there is a value, and you can unwrap the optional to access that value, or there isn’t a value at all.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるオプショナルは２つの可能性を表します：ある値が存在する、するとあなたはそのオプショナルをアンラップすることでその値を利用できます、または値がそもそも存在しないかのいずれか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional tuple type such as (Int, Int)? is different from a tuple that contains optional types such as (Int?, Int?).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(Int, Int)?のようなオプショナルタプル型は、(Int?, Int?)のようなオプショナル型を含むタプルとは異なる方式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional value either contains a value or contains nil to indicate that a value is missing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの値は、ある値を含むか、値が見つからないことを示すnilを含むかのどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional value is currently nil, but a non-nil value is essential for subsequent code to execute successfully.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの値は現在nilである、しかし、非nilが以降のコードがうまく実行されるのに不可欠である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional variable is used here, because players can leave the game at any point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの変数がここで使われます、なぜなら、プレーヤーはどの時点でもゲームから離れることができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An overridden method named someMethod() can call the superclass version of someMethod() by calling super.someMethod() within the overriding method implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>someMethod()という名前のオーバーライドされたメソッドは、オーバーライドしているメソッド実装内でsuper.someMethod()を呼ぶことによって、スーパークラス版のsomeMethod()を呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An overridden property called someProperty can access the superclass version of someProperty as super.someProperty within the overriding getter or setter implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>somePropertyと呼ばれるオーバーライドされたプロパティは、オーバーライドしているゲッターまたはセッター実装内で、super.somePropertyのようにしてスーパークラス版のsomePropertyにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An overridden subscript for someIndex can access the superclass version of the same subscript as super[someIndex] from within the overriding subscript implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>someIndexのためのオーバーライドされた添え字は、オーバーライドしている添え字実装内からsuper[someIndex]のようにしてスーパークラス版の同じ添え字にアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An override can make an inherited class member more accessible than its superclass version.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバーライドは、継承されたクラス・メンバーを、そのスーパークラス版よりもアクセス度を高くすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An underscore (_) before a parameter name suppresses the argument label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメーター名の前のアンダースコア（_）は、引数ラベルを抑制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An underscore (_) parameter is explicitly ignored and can’t be accessed within the body of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつのアンダースコア（_）のパラメータは、明確に無視されます、そして関数の本体内でアクセスされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unowned reference is expected to always have a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非所有者参照は、常にある値を持っていることを期待されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unowned reference is the appropriate capture method to use to resolve the strong reference cycle in the HTMLElement example from earlier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非所有者参照は、以前のHTMLElement例での強い参照循環を解消するのために使うのに適切な捕獲の手法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And SomeProtocol.self returns SomeProtocol itself, not an instance of a type that conforms to SomeProtocol at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして、SomeProtocol.selfは、SomeProtocol自身を返します、実行時にSomeProtocolに準拠するある型のインスタンスではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And because the value of ExampleEnum.c is explicitly set to 5, the value of ExampleEnum.d is automatically incremented from 5 and is therefore 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そしてExampleEnum.cの値が明示的に5に設定されるので、ExampleEnum.dの値は5から自動的に増加して、したがって6です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And just like functions and methods, you use the throws or rethrows keyword after an initializer’s parameters to indicate the appropriate behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして関数やメソッドのように、あなたはthrowsまたはrethrowsキーワードをイニシャライザのパラメータの後に使って、ふさわしい挙動を指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And just like functions, you can get a reference to an enumeration case and apply it later in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらにまさに関数のように、あなたはある列挙ケース節の参照を得ることができ、それを後であなたのコードに応用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>などなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And, because weak references need to allow their value to be changed to nil at runtime, they are always declared as variables, rather than constants, of an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そしてまた、弱い参照はそれらの値を実行時にnilに変更されるのを許される必要があることから、それらは常にオプショナル型の変数として宣言されます、定数ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another choice for enumeration cases is to have values associated with the case—these values are determined when you make the instance, and they can be different for each instance of an enumeration case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節の別の選択はそのケース節と結びつけられる値を持つことになります — それらの値はあなたがインスタンスを作る時に決定されます、そしてそれらはある列挙ケース節のインスタンスそれぞれで異なることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to handle errors is to use try? to convert the result to an optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーを取り扱う別の方法は、try?を使って結果をオプショナルに変換することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to handle optional values is to provide a default value using the ?? operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの値を取り扱うもう１つのの方法は、省略時の値を??演算子を使って提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any Dice instance can now be treated as TextRepresentable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どんなDiceインスタンスでも、今やTextRepresentableとして扱われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any additional setup work that uses methods, getters, or setters can also be done at this point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッド、ゲッター、またはセッターを使うどんな追加の準備作業も、また、この時点で行われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any attempt to override a final method, property, or subscript in a subclass is reported as a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるサブクラスの中の最終的なメソッド、プロパティ、または添え字をオーバーライドするどんな試みも、コンパイル時エラーとして報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any attempt to set a property through optional chaining returns a value of type Void?, which enables you to compare against nil to see if the property was set successfully:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を通してプロパティを設定しようとするあらゆる試みは、型Void?の値を返します、それは、あなたにnilと比較することでそのプロパティがうまく設定されたかどうか調べることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any attempt to subclass a final class is reported as a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最終版クラスにサブクラスを作る試みは何であれ、コンパイル時エラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any bits that are moved beyond the bounds of the integer’s storage are discarded.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数の格納量の境界を越えて動かされるあらゆるビットは、捨てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any class that does not inherit from another class is known as a base class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>別のクラスから継承しない何らかのクラスは、基盤クラスとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any constants or variables assigned a value from an optional binding declaration in a guard statement condition can be used for the rest of the guard statement’s enclosing scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>guard文条件の中のオプショナル束縛宣言由来のあらゆる定数または変数は、guard文の囲むスコープの他の部分で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any errors thrown inside a nonthrowing function must be handled inside the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローしない関数の内部でスローされるどんなエラーも、その関数の内部で取り扱われなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any gaps in an array are closed when an item is removed, and so the value at index 0 is once again equal to "Six eggs":</seg>
      </tuv>
      <tuv lang="JA">
        <seg>項目が取り外されるとき、配列でのどんな隙間でも閉じられます、なのでインデックス0での値はふたたび"Six eggs"と等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any initializer in the diagram above can be used to create a fully-initialized instance of the class they belong to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の図の中のどんなイニシャライザでも、それらが属しているクラスの充分に初期化されたインスタンスをつくるために使用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any internal implementation details of your framework can still use the default access level of internal, or can be marked as private or file private if you want to hide them from other parts of the framework’s internal code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのフレームワークのあらゆる内部的実装詳細は、依然として省略時のアクセス水準である内部を使用します、もしくはあなたがそれらをそのフレームワークの内部コードの他の部分から隠したいならば非公開またはファイル限定として印されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any properties stored by the structure are themselves value types, which would also be expected to be copied rather than referenced.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体で保存されるどんなプロパティでもそれら自身値型であり、それはまた参照をつけられるのではなくコピーされることを期待される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any protocol that inherits from a protocol that’s marked with the class requirement can likewise be adopted only by class types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>class要件で印されるプロトコルから継承するどんなプロトコルも、同じようにクラス型でのみ採用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type aliases you define are treated as distinct types for the purposes of access control.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが定義するどんな型エイリアスでも、アクセス制御の目的のためにはっきりした型とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type argument substituted for a type parameter must meet all the constraints and requirements placed on the type parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型パラメータと置き換えられるどんな型引数でも、型パラメータに設置された制約と要件の全てに応じなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type can be explicitly declared to be (or implicitly converted to) an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる型は、オプショナル型であるとして明示的に宣言される（または暗黙的に変換される）ことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type members added in an extension have the same default access level as type members declared in the original type being extended.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張において加えられるどんな型メンバーでも、拡張されているところの本来の型で宣言される型メンバーと同じ省略時のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type that conforms to the Container protocol must be able to specify the type of values it stores.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Containerプロトコルに準拠するあらゆる型は、それが格納する値の型を指定することができなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type that is Equatable can be used safely with the findIndex(of:in:) function, because it is guaranteed to support the equal to operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Equatableであるどんな型でもfindIndex(of:in:)関数で問題なく使われることができます、なぜなら、それが同等演算子をサポートすると保証されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type that satisfies the requirements of a protocol is said to conform to that protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルの要件を満たす何らかの型は、そのプロトコルに準拠すると言われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any variables or constants that were assigned values using an optional binding as part of the condition are available for the rest of the code block that the guard statement appears in.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル束縛を使ってこの条件の一部として値を代入された、あらゆる変数や定数は、guard文が現れるコードブロックの残りの部分で利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anything that adopts PrettyTextRepresentable must satisfy all of the requirements enforced by TextRepresentable, plus the additional requirements enforced by PrettyTextRepresentable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>PrettyTextRepresentableを採用するどんなものでも、TextRepresentableによって強制される要件の全て、それに加えてPrettyTextRepresentableによって強制される追加の要件を満たさなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anything that is PrettyTextRepresentable must also be TextRepresentable, and so the implementation of prettyTextualDescription starts by accessing the textualDescription property from the TextRepresentable protocol to begin an output string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>PrettyTextRepresentableであるものは何でも、またTextRepresentableでなければなりません、なのでprettyTextualDescriptionの実装は出力文字列を開始するためにTextRepresentableプロトコルからのtextualDescriptionプロパティにアクセスすることによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apple laid the foundation for Swift by advancing our existing compiler, debugger, and framework infrastructure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アップルは、私達の既存のコンパイラ、デバッガ、そしてフレームワーク基盤構造を向上させることにスウィフトの土台を置きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to import declarations for modules compiled with testing enabled to access any entities marked with the internal access-level modifier as if they were declared with the public access-level modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をテストすることを可能にされた状態でコンパイルされたモジュールに対するimport宣言に適用することで、internalアクセス水準修飾子で印されるあらゆる実在に、まるでそれらがpublicアクセス水準修飾子を使って宣言されたかのようにアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a class to indicate that it is the application delegate.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をあるクラスに適用して、それがアプリケーション委任であることを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a function or method declaration to suppress the compiler warning when the function or method that returns a value is called without using its result.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を関数またはメソッド宣言に適用して、値を返す関数やメソッドがそれの結果を使うことなく呼び出された時にコンパイラが警告を発するのを抑制してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a method, property, subscript, or initializer declaration to suppress an implicit objc attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をメソッド、プロパティ、添え字、およびイニシャライザ宣言に適用することで、暗黙的にobjc属性となるのを抑制してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a parameter’s type in a method or function declaration to indicate that the parameter’s value can be stored for later execution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をメソッドや関数宣言の中のパラメータの型に適用して、そのパラメータの値がその後の実行のために保管されることができるのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a parameter’s type in a method or function declaration, for a parameter of a function type that takes no arguments and that returns a value of the type of the expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を、メソッドまたは関数宣言においてあるパラメータの型に対して、引数を持たずそして式の型の値を返す関数型のあるパラメータのために、適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a stored variable property of a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をクラスの保存変数プロパティに適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to an instance method or stored variable property of a class that inherits from NSManagedObject to indicate that Core Data dynamically provides its implementation at runtime, based on the associated entity description.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をNSManagedObjectから継承するクラスのインスタンスメソッドまたは保存変数プロパティに適用することで、関連する実体記述に基づいて、Coreデータが動的にそれの実装に実行時に提供されることを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to any declaration that can be represented in Objective-C—for example, non-nested classes, protocols, nongeneric enumerations (constrained to integer raw-value types), properties and methods (including getters and setters) of classes and protocols, initializers, deinitializers, and subscripts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をObjective-Cにおいて表わされることができるあらゆる宣言に適用してください ― 例えば、入れ子にされないクラス、プロトコル、総称体でない列挙（整数の生の値型に制限される）、クラスやプロトコルのプロパティやメソッド（ゲッターやセッターを含む）、イニシャライザ、デイニシャライザ、そして添え字など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to any declaration to indicate the declaration’s lifecycle relative to certain platforms and operating system versions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をあらゆる宣言に適用して、その宣言のライフサイクルが特定のプラットホームとオペレーティングシステムバージョンと関係することを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to expose a custom GameplayKit component property to the SpriteKit editor UI.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を適用することであつらえのGameplayKitコンポーネントプロパティをSpriteKitエディタUIに露出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to the type of a function to indicate its calling conventions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を関数の型に適用して、それの呼出規約を示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a class or to a property, method, or subscript member of a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子をクラスに、またはプロパティ、メソッド、またはクラスの添え字メンバーに適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed and subclassed by code in the same module as the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子を宣言に適用して、その宣言がアクセスされることおよびサブクラスを作られることが、宣言と同じモジュールの中のコードによって可能なのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed only by code in the same module as the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子を宣言に適用して、その宣言が、宣言と同じモジュールの中のコードによってのみアクセスされることができるのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed only by code in the same source file as the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子を宣言に適用して、その宣言が、宣言と同じソースファイルの中のコードによってのみアクセスされることができるのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed only by code within the declaration’s immediate enclosing scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子を宣言に適用して、その宣言がアクセスされることは、宣言が直に囲んでいるスコープ内のコードによってのみ可能なのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a designated or convenience initializer of a class to indicate that every subclass must implement that initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子をクラスの必須または便宜イニシャライザに適用して、全てのサブクラスがそのイニシャライザを実装しなければならないことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a protocol’s property, method, or subscript members to indicate that a conforming type isn’t required to implement those members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子をプロトコルのプロパティ、メソッド、または添え字メンバーに適用して、ある準拠型がそれらのメンバーを実装する必要がないことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a stored variable or stored variable property to indicate that the variable or property has a weak reference to the object stored as its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子を保存変数または保存変数プロパティに適用して、その変数またはプロパティがそれの値として格納されるオブジェクトに対して弱い参照を持つことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a stored variable property of a class or structure to indicate that the property’s initial value is calculated and stored at most once, when the property is first accessed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子をクラスまたは構造体の保存変数プロパティに適用して、そのプロパティの初期値が最大でも一度だけ、そのプロパティが最初にアクセスされるときに、計算または格納されることを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a stored variable, constant, or stored property to indicate that the variable or property has an unowned reference to the object stored as its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子を保存変数、定数、または保存プロパティに適用して、その変数またはプロパティがそれの値として格納されるオブジェクトに対して非所有参照を持つことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to any member of a class that can be represented by Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子をObjective-Cによって表わされることのできるクラスのあらゆるメンバーに適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying this attribute also implies the objc attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を適用することはさらにまたobjc属性も意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Argument labels must always be used in an initializer if they are defined, and omitting them is a compile-time error:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルは、それらが定義されるならば常にイニシャライザで使われなければなりません、そして、それらを省略することはコンパイル時エラーになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Argument names in functions and methods are not part of the corresponding function type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数やメソッドの引数名は、対応する関数型の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arithmetic Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>算術演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arithmetic operators (+, -, *, /, % and so forth) detect and disallow value overflow, to avoid unexpected results when working with numbers that become larger or smaller than the allowed value range of the type that stores them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>算術演算子（+、-、*、/、%その他）は、値があふれること（オーバフロー）を検知して承認しません、数を扱うときにそれらを保存する型の許容される値の範囲より大きいか小さくなる予想外の結果を防ぐためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array Type Shorthand Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列型の短縮形構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays are ordered collections of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列は、順番をつけられた値のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays in Swift are always zero-indexed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの配列は、常に０からのインデックスをつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays, sets, and dictionaries in Swift are always clear about the types of values and keys that they can store.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの配列、集合、そして辞書は、それらが保存できる値とキーの型について常に明確です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array’s existing append(_:) method and subscript enable Swift to infer the appropriate type to use for ItemType, just as for the generic Stack type above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の既存のappend(_:)メソッドと添え字は、スウィフトに、ちょうど上の総称体Stack型と同じように、ItemTypeに使うのに適当な型を推論するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a general guideline, consider creating a structure when one or more of these conditions apply:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般的な指針として、これらの状況のうちの１つ以上があてはまるとき、構造体を作成することを考えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a parameter type or return type in a function, method, or initializer</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数、メソッド、またはイニシャライザにおいてパラメータ型または戻り型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, ARC never sets an unowned reference’s value to nil, which means that unowned references are defined using nonoptional types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、ARCは決して非所有参照の持つ値をnilに設定しません、それは非所有参照が非オプショナル型を使って定義されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, a failable initializer can return nil to indicate that initialization failed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、失敗できるイニシャライザは、そのイニシャライザが失敗したのを指し示すためにnilを返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, if multiple cases contain patterns that evaluate to the same value, and thus can match the value of the control expression, the program executes only the code within the first matching case in source order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、複数のケース節が同じ値に評価される、そしてそれゆえ制御式の値にマッチすることができるパターンを含むならば、プログラムはソース順において最初のマッチしているケース節内のコードだけを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, in many cases you do not need to specify an explicit access level in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、多くの場合には、あなたはあなたのコードにおいて明示的にアクセス水準を指定する必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, it automatically receives a default initializer, as described in Default Initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、省略時のイニシャライザで記述されるように、それは自動的に省略時のイニシャライザを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, only class types can adopt and conform to a protocol that contains optional member requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、クラス型だけがオプショナルメンバー要件を含むプロトコルを採用および準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, the endIndex property isn’t a valid argument to a string’s subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、endIndexプロパティは、文字列の添え字として有効な引数ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, the statements are compiled and executed only if the compilation condition evaluates to true at compile time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、statements（文）がコンパイル及び実行されるのはcompilation conditionがコンパイル時にtrueに評価される場合に限ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, the number of characters in a string cannot be calculated without iterating through the string to determine its extended grapheme cluster boundaries.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、ある文字列の中の文字の数は、それの拡張書記素クラスタ境界を解決するためにその文字列の最初から終わりまで繰り返していくことなしに計算されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, the value of the customerProvider argument must be allowed to escape the function’s scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、customerProvider引数の値は関数のスコープを脱出することを許されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, there is no need to use whitespace to disambiguate between the closing &gt; characters in constructs like Dictionary&lt;String, Array&lt;Int&gt;&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、曖昧さをなくすために空白を使う必要は、Dictionary&lt;String, Array&lt;Int&gt;&gt;のような構造物における閉じ&gt;文字たちの間にはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, they are both evaluated before the addition is considered.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、それらは両方とも、加算が考慮される前に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, they have a rawValue property and a failable initializer with the signature init?(rawValue: RawValue).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、それはrawValueプロパティとシグネチャinit?(rawValue: RawValue)を持つ失敗できるイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, you can use a nonthrowing function in the same places as a throwing one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、あなたは非スロー関数をスロー関数と同じ場所で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, you do not write the override modifier when providing a matching implementation of a superclass convenience initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、あなたはスーパークラスの便宜イニシャライザに一致する実装を提供している時にoverride修飾子を書きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, you don’t implement the getter or setter directly in the protocol in which it is declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、それが宣言されるプロトコルにおいて、あなたは直接ゲッターまたはセッターを実装しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, you must include at least one statement following the colon (:) of each case label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、あなたはそれぞれのケース節ラベルのコロン（:）に続いている文を少なくとも１つは含めなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, you never need to write an inline closure in its fullest form when the closure is used as a function or method argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、あなたは、行内クロージャをその最も完全な形式で書くことは、そのクロージャが関数やメソッドの引数として使われる時にまったく必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a shortcut to accessing its rooms array, this version of Residence provides a read-write subscript that provides access to the room at the requested index in the rooms array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのrooms配列にアクセスすることへの近道として、Residenceのこの版は読み出し専用の添え字を提供します、それは、rooms配列の中の要求されたインデックスでの部屋へのアクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an alternative to associated values, enumeration cases can come prepopulated with default values (called raw values), which are all of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連値に代わるものとして、列挙ケース節は全て同じ型の（生の値と呼ばれる）初期値があらかじめ入れられた状態であることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an alternative to querying their value properties, each UnicodeScalar value can also be used to construct a new String value, such as with string interpolation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらのvalueプロパティについて尋ねることに代わるものとして、各UnicodeScalar値は、また、新しいString値を造るために使われることもできます、例えば文字列補間を使って：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an alternative to subscripting, use a dictionary’s updateValue(_:forKey:) method to set or update the value for a particular key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字指定に代わるものとして、辞書のupdateValue(_:forKey:)メソッドを、特定のキーに対する値を設定したり更新したりするために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, Swift’s Array type has a map(_:) method which takes a closure expression as its single argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、スウィフトのArray型はmap(_:)メソッドを持ちます、そしてそれは、そのただ一つの引数としてクロージャ式をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, consider the task of reading and processing data from a file on disk.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの例として、ディスク上のファイルからデータを読み込んで処理する作業を考えてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, many functions that start an asynchronous operation take a closure argument as a completion handler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、非同期の演算を開始する多くの関数は、クロージャ引数を完了ハンドラとして取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, the +++ operator in a +++b is treated as a prefix unary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、a +++bにおける+++演算子は、接頭辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, the +++ operator in a+++ b is treated as a postfix unary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、a+++ bにおける+++演算子は、接尾辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, the +++ operator in a+++b and a +++ b is treated as a binary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、a+++bとa +++ bにおける+++演算子は、二項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, the +++ operator in a+++.b is treated as a postfix unary operator (a+++ .b rather than a +++ .b).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、a+++.bにおける+++演算子は、接尾辞単項演算子とみなされます（a +++ .bではなくa+++ .b）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, the grammar of a getter-setter block is defined as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、ゲッターセッター・ブロックの文法は、次のように定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by a closure, and if the value is not mutated after the closure is created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの最適化として、その値がクロージャによって変化させられないならば、そしてその値がクロージャが作成された後に変化されられないならば、スウィフトはそれよりむしろ値のコピーをキャプチャして保管するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an optimization, when the argument is a value stored at a physical address in memory, the same memory location is used both inside and outside the function body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの最適化として、引数がメモリにおいて物理的番地に保存される値である時、同じメモリ位置は関数本体の内側と外側の両方で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As can be seen above, the getter correctly returns a center point of (5, 5).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で見られるように、ゲッターは正しく中心点(5, 5)を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As demonstrated in Optional Chaining as an Alternative to Forced Unwrapping, you can use optional chaining to access a property on an optional value, and to check if that property access is successful.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強制アンラップに代わるものとしてのオプショナル連鎖で例示されるように、あなたはオプショナル連鎖を使って、あるオプショナル上でプロパティにアクセスして、そのプロパティへのアクセスが成功したか調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described above, optionals indicate that a constant or variable is allowed to have “no value”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>先に述べたように、オプショナルは、ある定数や変数が「値がない」状態でも許されることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described above, the ultimate return type of this method call after optional chaining is also String?:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>先に述べたように、オプショナル連鎖の後ろのこのメソッド呼び出しの最終的な戻り型は、また、String?です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described in Control Flow, a switch statement must be exhaustive when considering an enumeration’s cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御の流れで記述されるように、switch文は列挙のケース節を考慮するとき、徹底的でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described in Default Initializers, Swift automatically provides a default initializer without any arguments for any structure or base class that provides default values for all of its properties and does not provide at least one initializer itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のイニシャライザで記述されるように、スウィフトは、全く引数を持たない省略時のイニシャライザを、あらゆる構造体または基盤クラスで、それのプロパティの全てに省略時の値を提供して、とにかく１つのイニシャライザもそれ自身では提供しないもののために、自動的に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described in Failable Initializers, a special form of the return statement (return nil) can be used in a failable initializer to indicate initialization failure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザで記述されるように、return文の特別な形式（return nil）は、失敗できるイニシャライザの中で使用されて初期化失敗を指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described in Dictionaries, the type of a dictionary’s keys must be hashable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書で記述されるように、辞書のキーの型は、ハッシュ化できなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed in Initializer Declaration, classes can have designated and convenience initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ宣言で議論されるように、クラスは、指定および便宜イニシャライザを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed in Protocol Declaration, you can include the class keyword as the first item in the type inheritance clause to mark a protocol declaration with a class requirement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言での議論のように、あなたは、class要件を持つプロトコル宣言を印付けするためにclassキーワードを型継承節における最初の項目として含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As expected, the counter’s count property increases by three each time increment() is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>予想されるように、counterのcountプロパティは、increment()が呼ばれるたびに３つずつ増加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in the previous example, the final case matches all possible remaining values, and so a default case is not needed to make the switch statement exhaustive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前の例の場合のように、最後のケース節は全てのあり得る残りの値に適合します、そしてdefaultケース節はこのswitch文を徹底的なものにするのに必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in this example, careful choice of Boolean constant and variable names can help to keep code readable and concise, while avoiding double negatives or confusing logic statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例の場合のように、ブールの定数と変数の名前の慎重な選択はコードを読みやすく簡潔にしておくのを助けることができます、その一方で、二重の否定や、混乱させる論理文を避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As its name suggests, the toggle() method is intended to toggle or invert the state of any conforming type, typically by modifying a property of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その名前が暗示するように、toggle()メソッドはあらゆる準拠型の状態を切り換えるか逆にすることを意図します、概してその型のプロパティの修正によって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned above, different characters can require different amounts of memory to store, so in order to determine which Character is at a particular position, you must iterate over each Unicode scalar from the start or end of that String.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で述べたように、異なる文字は格納するのに異なるメモリ量を必要とすることがあり得ます、それでCharacterがある特定の位置にあることを確定するために、あなたはそのStringの始まりまたは終わりからユニコードスカラーそれぞれにわたってずっと繰り返さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned above, subclasses do not inherit their superclass initializers by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で述べたように、サブクラスは何もしなければそれらのスーパークラスのイニシャライザを継承しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned above, the Rank enumeration defines a further nested structure of its own, called Values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で言及されるように、Rank列挙は独自の更なる入れ子にされた構造体を定義します、それはValuesと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned above, the memory for an object is only considered fully initialized once the initial state of all of its stored properties is known.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で言及したように、いったんその保存プロパティの全ての最初の状態が知られる場合にのみ、あるオブジェクトに対するメモリが充分に初期化されたとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned in Generic Parameter Clause, you don’t use a generic argument clause to specify the type arguments of a generic function or initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体パラメータ節で言及されるように、あなたは、総称体の関数やイニシャライザの型引数を指定するために総称体引数節を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As soon as all properties of the superclass have an initial value, its memory is considered fully initialized, and Phase 1 is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスの全てのプロパティが初期値を持つとすぐに、そのメモリが充分に初期化されてすると考慮されます、そして第１段階は完了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As soon as the default case is matched, the break statement ends the switch statement’s execution, and code execution continues from the if let statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>defaultケース節が適合したならすぐに、break文がswitch文の実行を終えます、そしてコード実行はif let文から続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As such, index does not have to be declared before it is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このように、indexは、それが使われる前に宣言される必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As such, the performance characteristics of a throw statement are comparable to those of a return statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>throw文のいろいろな性能特徴は、それ自体としては、return文のそれと同程度です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the above example shows, patterns in a case can also bind constants using the let keyword (they can also bind variables using the var keyword).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で示されるように、あるケース節中のいくつかのパターンはまた、letキーワードを使って定数に束縛できます（それらはまたvarキーワードを使って変数に束縛もできます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the type of a constant, variable, or property</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数、変数、またはプロパティの型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the type of items in an array, dictionary, or other container</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列、辞書、または他のコンテナ中の項目の型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As their names suggest, the value of a stored variable or a stored variable property is stored in memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの名前が示すように、保存変数または保存変数プロパティの値はメモリに保存されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with Int and Double above, you don’t need to declare constants or variables as Bool if you set them to true or false as soon as you create them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のIntとDoubleと同様に、あなたがそれらを作成するやいなやtrueまたはfalseに設定するならば、あなたは定数または変数をBoolとして宣言する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with all unsafe operations, you take on the responsiblity for checking that code for safety.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての安全でない操作と同様に、あなたは安全性のためにそのコードを検査する責任があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with an array, you find out the number of items in a Dictionary by checking its read-only count property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列と同様に、あなたはあるDictionaryの中の項目の数を、それの読み出し専用のcountプロパティを調べることによって突き止めます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with an overridden property, method or subscript, the presence of the override modifier prompts Swift to check that the superclass has a matching designated initializer to be overridden, and validates that the parameters for your overriding initializer have been specified as intended.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバーライドされるプロパティ、メソッドや添え字を書く時と同様に、override修飾子の存在はスウィフトにスーパークラスが一致している、オーバーライドされる指定イニシャライザを持つのを確認すること、そしてあなたがオーバーライドするイニシャライザのパラメータが意図されるように指定されてしまっているのを検証することを促します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with any other type, you can leave it to Swift to infer the function type when you assign a function to a constant or variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる他の型と同様に、あなたが関数を定数または変数に代入するとき、あなたはスウィフトに関数型を推論するように任せることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with arrays, you can create an empty Dictionary of a certain type by using initializer syntax:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列と同様に、あなたは、特定の型の空のDictionaryを作成することが、イニシャライザ構文を使うことで行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with arrays, you don’t have to write the type of the dictionary if you’re initializing it with a dictionary literal whose keys and values have consistent types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列と同様に、キーと値が首尾一貫した型をもつ辞書リテラルでそれを初期化しているならば、あなたは辞書の型を書く必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with computed properties, subscript declarations support reading and writing the value of the accessed elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算プロパティと同様に、添え字宣言はアクセスされた要素の値を読み書きすることをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with computed properties, you can choose not to specify the setter’s (newValue) parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算プロパティと同様に、あなたはセッターの(newValue)パラメータを指定しないほうを選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with constant declarations, if the variable name is a tuple pattern, the name of each item in the tuple is bound to the corresponding value in the initializer expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言と同様に、変数名がタプルパターンであるならば、タプルの中の各項目の名前はイニシャライザ式の対応する値に縛りつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with function and method parameters, initialization parameters can have both a parameter name for use within the initializer’s body and an argument label for use when calling the initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数とメソッドのパラメータと同様に、初期化パラメータは、イニシャライザの本文内で使用するためのパラメータ名とイニシャライザを呼ぶ時に使用するための引数ラベルの両方を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with function and method parameters, the types of an initializer’s parameters cannot be more private than the initializer’s own access level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数やメソッドパラメータと同様に、イニシャライザのパラメーターの型は、そのイニシャライザ自身のアクセス水準よりも非公開にすることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with methods, properties, and subscripts, you need to mark overridden designated initializers with the override declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッド、プロパティ、そして添え字と同様に、あなたはオーバーライドした指定イニシャライザをoverride宣言修飾子で印する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with optionals, if you don’t provide an initial value when you declare an implicitly unwrapped optional variable or property, its value automatically defaults to nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルと同様に、あなたが暗黙的にアンラップされるオプショナルの変数やプロパティに初期値を提供しないならば、その値は自動的に省略時のnilになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with other examples of type safety in Swift, this approach avoids accidental errors and ensures that the intention of a particular section of code is always clear.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおける型安全に関する他の例と同様に、このやり方は、偶然のエラーを避けること、そしてコードの特定の節の意図を常にはっきりさせることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with other protocol member declarations, these property declarations declare only the getter and setter requirements for types that conform to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のプロトコルメンバー宣言と同様に、これらのプロパティ宣言はそのプロトコルに準拠する型のためのゲッターとセッター要件だけを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with prefix operators, postfix operator declarations don’t specify a precedence level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞演算子と同様に、接尾辞演算子宣言は、優先順位レベルを指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with read-only computed properties, you can drop the get keyword for read-only subscripts:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>読み出し専用の計算プロパティと同様に、あなたは読み出し専用の添え字ではgetキーワードを省くことが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with strong reference cycles between two class instances, you declare each captured reference to be a weak or unowned reference rather than a strong reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つのクラスインスタンスの間の強い参照循環と同様に、あなたは各捕らえられた参照が強い参照というよりは弱いまたは非所有者参照であると宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with the closed range operator, the value of a must not be greater than b.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>完結範囲演算子と同じように、aの値はbより大きくてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with the default initializer above, if you want a public structure type to be initializable with a memberwise initializer when used in another module, you must provide a public memberwise initializer yourself as part of the type’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記の省略時のイニシャライザと同様に、あなたがある公開の構造体型を別のモジュール内で使うときにメンバー関連イニシャライザを使って初期化できるようにしたいならば、あなたは公開のメンバー関連イニシャライザをあなた自身でその型定義の一部として提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with type property requirements, you always prefix type method requirements with the static keyword when they are defined in a protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティ要件と同様に、あなたは常に型メソッド要件の前に、それらがプロトコルにおいて定義されるとき、staticキーワードを置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you consider the data constructs and functionality that you need for a project, decide whether each data construct should be defined as a class or as a structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがプロジェクトのために必要とするデータ構造と機能性を考慮するので、各データ構造物がクラスとしてまたは構造体として定義されなければならないか決めてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assertions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assertions are disabled when your code is compiled with optimizations, such as when building with an app target’s default Release configuration in Xcode.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明は、あなたのコードが最適化を使ってコンパイルされる時に使用不能にされます、例えばXcodeにおいてアプリターゲットの省略時の「Release」構成を使ってビルドしている時など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assertions cause your app to terminate and are not a substitute for designing your code in such a way that invalid conditions are unlikely to arise.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明は、あなたのアプリの終了を引き起こします、そして無効な状況が起こりそうにないようなあなたのコードを設計することの代わりではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning Constant Properties During Initialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化の間に定数プロパティを割り当てる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning to self Within a Mutating Method</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変メソッド内部でselfに代入する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代入演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment and Copy Behavior for Strings, Arrays, and Dictionaries</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列、配列、そして辞書のための代入とコピー挙動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment is performed from each part of the value to the corresponding part of the expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代入は、値の各部分から式の対応する部分へと実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associated Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associated Types in Action</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型の動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associated Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associated types are similar to type parameters in generic parameter clauses, but they’re associated with Self in the protocol in which they’re declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型は、総称体パラメータ節の中の型パラメータに似ています、しかしそれらは、それらが宣言されるプロトコルにおいてSelfと結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associated types are specified with the associatedtype keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型は、associatedtypeキーワードで指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associated values are set when you create a new constant or variable based on one of the enumeration’s cases, and can be different each time you do so.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連値は、あなたが列挙のケース節のうちの１つに基づいて新しい定数または変数を作るときに設定されます、そしてあなたがそうするたびに違ったものにすることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming that you provide default values for any new properties you introduce in a subclass, the following two rules apply:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが省略時の値をあなたがサブクラスで導入するあらゆる新しいプロパティに用意すると仮定して、以下の２つの規則が適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At compile time, the key-path expression is replaced by a string literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイル時において、キーパス式は文字列リテラルで置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At parse time, an expression made up of binary operators is represented as a flat list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構文解析の時、二項演算子から成り立つ式は、平坦なリストとして表わされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At runtime, if the cast succeeds, the value of expression is wrapped in an optional and returned; otherwise, the value returned is nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行時に、キャストが成功したならば、式の値がひとつのオプショナルの中にラップされて返されます；そうでなければ返される値はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the end of the for-in loop, the values of movieCount and songCount contain a count of how many MediaItem instances were found of each type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>for-inループの終わりに、movieCountとsongCountの値は、各型のMediaItemインスタンスがどれくらい見つけられたかの総数を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the start of the game, the player is on “square zero”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲームの開始時点で、プレーヤーは−「正方形ゼロ」の上にいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, the original Barcode.upc and its integer values are replaced by the new Barcode.qrCode and its string value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この点で、最初のBarcode.upcおよびその整数値は、新しいBarcode.qrCodeおよびその文字列値と取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempting to access an index outside of a string’s range or a Character at an index outside of a string’s range will trigger a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある文字列の範囲外のインデックスにまたはある文字列の範囲外のインデックスでCharacterにアクセスを試みることは、実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempting to do so is reported as an error when your code is compiled:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうしようとすることは、あなたのコードがコンパイルされる時にエラーとして報告されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempting to do so would be reported as a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうしようとすることは、コンパイル時エラーとして報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attributes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Autoclosures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automatic Initializer Inheritance</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動的なイニシャライザ継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automatic Reference Counting</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動参照カウント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Availability Condition</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効性条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoid combining multiple instances of the ternary conditional operator into one compound statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>三項条件演算子を使用したもの複数を１つの複合文に結合することを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoiding default fallthrough means that Swift switch statements are much more concise and predictable than their counterparts in C, and thus they avoid executing multiple switch cases by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何もしなくても抜け落ちることを避けることは、スウィフトのswitch文がCでのそれに対応する物よりずっと簡潔で予測できること、そしてそれゆえに、それは誤って複数のswitchケース節を実行することを回避することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backslash (\\)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バックスラッシュ（\\）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Based on the values of enteredDoorCode, passedRetinaScan, and hasDoorKey, the first two subexpressions are false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>enteredDoorCode、passedRetinaScan、そしてhasDoorKeyの値に基づいて、最初の２つの下位の式はfalseです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本の演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be careful to ensure that operator interactions still behave in the way you intend when porting existing code to Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存のコードをスウィフトに移植するとき、依然としてあなたが意図するやり方で演算子相互作用が振る舞うことを確実にするように注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be extended to expand their functionality beyond a default implementation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの機能性を元の実装を越えて広げるために、拡張されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be warned, though—this function does not compile, for reasons explained after the example:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注意するように、とは言うものの ― この関数はコンパイルしません、この例の後に説明される理由のために：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because 1 is less than 2, (1, "zebra") is considered less than (2, "apple"), regardless of any other values in the tuples.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>1は2より少ないことから、(1, "zebra")は(2, "apple")より少ないとみなされます、タプルの中のあらゆる他の値に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Array conforms to Collection and the array’s elements conform to the TextRepresentable protocol, the array can use the textualDescription property to get a textual representation of its contents:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ArrayがCollectionに準拠して配列要素がTextRepresentableプロトコルに準拠することから、この配列はtextualDescriptionプロパティを使ってそれの内容のテキスト表現を取得することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because BlackjackCard is a structure with no custom initializers, it has an implicit memberwise initializer, as described in Memberwise Initializers for Structure Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>BlackjackCardがあつらえのイニシャライザのない構造体であるので、構造型のためのメンバー関連イニシャライザで記述されるように、それは暗黙のメンバー関連イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Int and Double, for example, both conform to the Comparable protocol, this function accepts arguments of either type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、IntとDoubleは両方ともComparableプロトコルに準拠するので、この関数はどちらの型の引数でも受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because capitalCity has a default nil value, a new Country instance is considered fully initialized as soon as the Country instance sets its name property within its initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>capitalCityが省略時のnil値を持つので、新しいCountryインスタンスは、Countryインスタンスがそのイニシャライザ内でそのnameプロパティを設定するとすぐに、完全に初期化されると見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because john.residence is nil, this optional chaining call fails in the same way as before.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>john.residenceがnilであるため、このオプショナル連鎖呼び出しは前と同じやり方で失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because playerOne is an optional, it is qualified with an exclamation mark (!) when its coinsInPurse property is accessed to print its default number of coins, and whenever its winCoins(_:) method is called:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>playerOneがオプショナルであることから、それは感嘆符（!）で修飾されます、それのもつcoinsInPurseプロパティがその省略時のコイン数を出力するためにアクセスされる時に、そしてそれのwinCoins(_:)メソッドが呼ばれる時にいつでも：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because rangeOfFourItems is declared as a constant (with the let keyword), it is not possible to change its firstValue property, even though firstValue is a variable property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>rangeOfFourItemsが定数（letキーワードを使って）として宣言されるので、たとえfirstValueが変数プロパティであるとしても、そのfirstValueプロパティを変えることは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because makeASandwich() can throw an error, the function call is wrapped in a try expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>makeASandwich()はエラーをスロー可能なので、この関数呼び出しはtry式で包まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Resolution is a structure, a copy of the existing instance is made, and this new copy is assigned to cinema.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Resolutionが構造体であるので、既存のインスタンスのコピーが作成されます、そして、この新しいコピーはcinemaに代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because item is a MediaItem instance, it’s possible that it might be a Movie; equally, it’s also possible that it might be a Song, or even just a base MediaItem.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>itemがMediaItemインスタンスであるので、それがMovieであるかもしれない可能性があります；等しく、それがSongかもしれない可能性もまたあります、または単に基盤MediaItemであることさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because AutomaticallyNamedDocument copes with the empty string case in a different way than its superclass, its initializer does not need to fail, and so it provides a nonfailable version of the initializer instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AutomaticallyNamedDocumentが空の文字列の場合をそれのスーパークラスと異なるやり方でうまく処理するので、それのイニシャライザは失敗する必要はありません、それでそれはそうせずに、失敗できない改作のイニシャライザを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because IntStack conforms to all of the requirements of the Container protocol, Swift can infer the appropriate ItemType to use, simply by looking at the type of the append(_:) method’s item parameter and the return type of the subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IntStackがContainerプロトコルの要件の全てに準拠するので、スウィフトは、単にappend(_:)メソッドのitemパラメータの型、そして、添え字の戻り型を見ることによって、使用するのに適切なItemTypeを推論することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Person conforms to both protocols, this is a valid call, and the wishHappyBirthday(to:) function is able to print its birthday greeting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Personが両方のプロトコルに準拠するので、これは有効な呼び出しです、そしてwishHappyBirthday(to:)関数はその誕生日のお祝いを出力することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because anotherPoint is always a tuple of two values, this case matches all possible remaining values, and a default case is not needed to make the switch statement exhaustive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>anotherPointが常に２つの値のタプルであることから、このケース節は全てのあり得る残りの値にマッチします、そしてdefaultケース節はこのswitch文を余すところのないものにするのに必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because game is known to conform to the DiceGame protocol, it is guaranteed to have a dice property, and so the gameDidStart(_:) method is able to access and print the dice’s sides property, regardless of what kind of game is being played.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>gameがDiceGameプロトコルに従うと知られているので、それはdiceプロパティを持つと保証されます、なので、gameDidStart(_:)メソッドは、どんな種類のゲームがプレイされているかに関係なく、diceのsidesプロパティにアクセスして出力することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because john.residence is currently nil, the subscript call fails:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>john.residenceが現在nilなので、添え字呼び出しは失敗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because userDefinedColorName is of an optional type, you can use the nil-coalescing operator to consider its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>userDefinedColorNameがオプショナル型であるため、あなたはその値を考慮するためにnil合体演算子を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because T is a placeholder, Swift does not look for an actual type called T.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Tがプレースホルダであるので、スウィフトはTと呼ばれる実際の型を捜しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because generator is known to adopt RandomNumberGenerator, it is guaranteed to have a random() method to call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>generatorがRandomNumberGeneratorを採用すると知られているので、それはrandom()メソッドを呼ぶことを保証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because userDefinedColorName is nil, the expression userDefinedColorName ?? defaultColorName returns the value of defaultColorName, or "red".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>userDefinedColorNameはnilなので、式userDefinedColorName ?? defaultColorNameは、defaultColorNameの値、すなわち"red"を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Swift is type safe, it performs type checks when compiling your code and flags any mismatched types as errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトが型安全であるので、それは、あなたのコードをコンパイルするとき型チェックを実行して、あらゆる組合せを誤った型をエラーとして合図します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Swift’s switch statement is exhaustive and does not allow empty cases, it is sometimes necessary to deliberately match and ignore a case in order to make your intentions explicit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのswitch文は網羅的で空のケース節を許さないので、あなたの意図を明確にするために故意にあるケース節を適合してから無視することが時々必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a throw statement immediately transfers program control, an item will be vended only if all of these requirements are met.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>throw文が直ちにプログラム制御を移すので、これらの必要なものすべてが満たされる場合にのみ項目は販売されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a credit card will always have a customer, you define its customer property as an unowned reference, to avoid a strong reference cycle:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クレジットカードが常にひとりの顧客を持つので、強い参照循環を避けるために、あなたはそのcustomerプロパティを非所有者参照として定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a selector is created at compile time, not at runtime, the compiler can check that a method or property exists and that they’re exposed to the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるセレクタが作成されるのはコンパイル時であり、実行時でないので、コンパイラはそのメソッドまたはプロパティが存在すること、そしてそれらがObjective-Cランタイムに露出されていることを確かめることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a weak reference does not keep a strong hold on the instance it refers to, it is possible for that instance to be deallocated while the weak reference is still referring to it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照がそれが言及するインスタンスに対する強い支配力を保たないので、弱い参照がまだそれに言及する間にそのインスタンスが割り当て解除されることは可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because addition isn’t part of the essential behavior for a vector, the type method is defined in an extension of Vector2D rather than in the main structure declaration of Vector2D.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加算はベクトルの欠くことのできない挙動の部分ではないので、この型メソッドはVector2Dの拡張において定義されます、Vector2Dの主構造定義においてではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because all keys in the literal are of the same type as each other, and likewise all values are of the same type as each other, Swift can infer that [String: String] is the correct type to use for the airports dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このリテラルの全てのキーが互いに同じ型である、そして全ての型が互いに他と同じ型であるので、スウィフトは、[String: String]がairports辞書に使うために適切な型であると推測することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because all of the types can be inferred, the return arrow (-&gt;) and the parentheses around the names of the parameters can also be omitted:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型の全てが推論されることができるので、戻り矢印（-&gt;）と、パラメータの名前のまわりの丸括弧もまた省略することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because all properties of the ShoppingListItem class have default values, and because it is a base class with no superclass, ShoppingListItem automatically gains a default initializer implementation that creates a new instance with all of its properties set to their default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ShoppingListItemクラスの全てのプロパティ省略時の値を持つことから、そしてそれがスーパークラスを持たない基盤クラスであることから、ShoppingListItemは自動的に省略時のイニシャライザ実装を獲得します、それは、それのプロパティの全てをそれらの省略時の値に設定して、新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because all values in the array literal are of the same type, Swift can infer that Set&lt;String&gt; is the correct type to use for the favoriteGenres variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列リテラルの中の全ての値が同じ型であることから、スウィフトはSet&lt;String&gt;が正しい型であると推論することができ、favoriteGenres変数に使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because all values in the array literal are of the same type, Swift can infer that [String] is the correct type to use for the shoppingList variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この配列リテラルの値の全てが同じ型であるので、スウィフトは[String]がshoppingList変数のために利用されるのに正しい型であると推測することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because an addition operator was defined earlier, you don’t need to reimplement the addition process here.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加算演算子は以前に定義されたので、あなたはここでは加算プロセスを再実装する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because an instance is not deallocated until after its deinitializer is called, a deinitializer can access all properties of the instance it is called on and can modify its behavior based on those properties (such as looking up the name of a file that needs to be closed).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスはそれのデイニシャライザが呼ばれる後までは割り当て解除されないので、デイニシャライザはそれが呼ばれるところのインスタンスの全てのプロパティにアクセスすることができて、それらのプロパティに基づいてその挙動を修正することができます（たとえば閉じられる必要があるファイルの名前を調べることなど）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because both sides of the addition are now of type UInt16, the addition is allowed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加算の両側が今では型UInt16であるので、加算は許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because classes are reference types, tenEighty and alsoTenEighty actually both refer to the same VideoMode instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスが参照型であるので、tenEightyとalsoTenEightyは両方とも実際に同じVideoModeインスタンスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because classes are reference types, it is possible for multiple constants and variables to refer to the same single instance of a class behind the scenes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスが参照型であるので、複数の定数と変数があるクラスの同じ一つのインスタンスに言及することが舞台裏で可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because declarations marked with the dynamic modifier are dispatched using the Objective-C runtime, they’re implicitly marked with the objc attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>dynamic修飾子で印される宣言はObjective-Cランタイムを使ってディスパッチされるので、それらは暗黙的にobjc属性で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because downcasting can fail, the type cast operator comes in two different forms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ダウンキャストは失敗することがありえるので、型キャスト演算子は２つの異なる書式になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because each numeric type can store a different range of values, you must opt in to numeric type conversion on a case-by-case basis.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの数の型は、値の異なる幅を保存できるので、あなたは数の型変換を一件一件を原則に決めていかなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because implicit unwrapping changes the meaning of the declaration that contains that type, optional types that are nested inside a tuple type or a generic type—such as the element types of a dictionary or array—can’t be marked as implicitly unwrapped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされることがその型を含む宣言の意味することを変えることから、タプル型や総称体型の内部に入れ子にされたオプショナル型—例えば辞書や配列に属する要素型など—は、暗黙的にアンラップされるように印されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because implicitly unwrapped optionals have the same Optional&lt;Wrapped&gt; type as optional values, you can use implicitly unwrapped optionals in all the same places in your code that you can use optionals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナルがオプショナル値と同じOptional&lt;Wrapped&gt;型を持つことから、あなたは、あなたのコードにおいてあなたがオプショナルを使うことができるのと同じ場所すべてで暗黙的にアンラップされるオプショナルを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it does not need to return a value, the function’s definition does not include the return arrow (-&gt;) or a return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが値を返す必要がないので、この関数の定義は戻り矢印（-&gt;）または戻り型を含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is a generic type, Stack can be used to create a stack of any valid type in Swift, in a similar manner to Array and Dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが総称体型であるので、Stackは、ArrayとDictionaryに類似したやり方で、スウィフトにおけるあらゆる有効な型のスタックを作るために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is a type, you can use a protocol in many places where other types are allowed, including:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが型であるので、以下を含む、他の型が許される多くの場所において、あなたはプロトコルを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is an alias, the call to AudioSample.min actually calls UInt16.min, which provides an initial value of 0 for the maxAmplitudeFound variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがエイリアスであるので、AudioSample.minへの呼び出しは実際にはUInt16.minを呼び、それは0の初期値をmaxAmplitudeFound変数のために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is an integer, it is rounded down during the division, so 16 becomes 1, 58 becomes 5, and 510 becomes 51.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが整数であるので、除算のときに端数を切り捨てられます、それで16が1に、58が5に、そして510は51になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is in essence an “additive” operator, it has been given the same precedence group as additive infix operators such as + and -.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは本質的には「加法的な」演算子であるので、それは+や-といった加法的な接中辞演算子と同じ優先順位グループを与えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is marked with the lazy modifier, the DataImporter instance for the importer property is only created when the importer property is first accessed, such as when its fileName property is queried:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがlazy修飾子という特徴をもつので、importerプロパティのためのDataImporterインスタンスは、importerプロパティが最初にアクセスされるsgにだけ作成されます、例えばそのfileNameプロパティがたずねられるときなど：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is of an optional type, the delegate property is automatically set to an initial value of nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがオプショナル型であるので、delegateプロパティは自動的に初期値のnilに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is possible to request a key for which no value exists, a dictionary’s subscript returns an optional value of the dictionary’s value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに対する値が存在しないキーへの要請が可能であるので、ある辞書の添え字は、その辞書の値型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it provides a default value for all of the properties it introduces and does not define any initializers itself, ShoppingListItem automatically inherits all of the designated and convenience initializers from its superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが、省略時の値をそれが導入するプロパティの全てに与えて、そしてまったくイニシャライザを定義しないので、ShoppingListItemはそのスーパークラスから自動的に指定および便宜イニシャライザの全てを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it’s not necessarily a mistake for code that calls the advance(to:) method to ignore the return value, this function is marked with the @discardableResult attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>advance(to:)メソッドを呼び出して戻り値を無視することが必ずしもコードの誤りでないことから、この関数は@discardableResult属性で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it’s not practical to list every possible Character value in the example above, a default case handles any characters that are not matched.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべてのあり得るCharacter値を並べることは上の例では実際的ではないので、defaultケース節が適合しないあらゆる文字を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of the special way that positive and negative numbers are stored, shifting either of them to the right moves them closer to zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正および負の数が保存される特別な方法のため、それらのどちらでも右へシフトすることは、それらをゼロの近くに動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of the unowned customer reference, when you break the strong reference held by the john variable, there are no more strong references to the Customer instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非所有者customer参照であることから、あなたがjohn変数によって保持される強い参照を壊すとき、Customerインスタンスへの強い参照はもうそれ以上ありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this behavior, the switch cases case let (x, y): and case (let x, let y): match the same values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動のため、switchケース節case let (x、y):とcase (let x、let y):は、同じ値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this uncertainty, the as? form of the type cast operator returns an optional value when attempting to downcast to a subclass type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この不確実性のために、サブクラス型へのダウンキャストを試みるとき、型キャスト演算子のas?形式はオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this, Swift provides an automatic argument label for every parameter in an initializer if you don’t provide one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これのため、スウィフトは、あなたがそれを独自に提供しないならば、自動的な引数ラベルをイニシャライザのあらゆるパラメータに用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this, all of the Int.Kind case values can be written in shorthand form inside the switch statement, such as .negative rather than Int.Kind.negative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのことから、Int.Kindのケース節の値の全ては、switch文内で略記形式で書かれることができます、たとえばInt.Kind.negativeではなく.negativeのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this, characters in Swift do not each take up the same amount of memory within a string’s representation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これのため、スウィフトの中の文字は、ひとつの文字列表現の範囲内でもそれぞれ同じ量のメモリを取りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this, it is not possible to guarantee that this code will work for every possible type T, and an appropriate error is reported when you try to compile the code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このため、このコードがすべての可能な型Tのために機能することを保証することは可能ではありません、それであなたがこのコードをコンパイルしようとする場合は該当するエラーが報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this, the call to john.residence?.address?.street fails.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このことから、john.residence?.address?.streetへの呼び出しは、失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this, the more general term instance is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これのため、より一般的な語インスタンスが使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this, the raw value initializer always returns an optional enumeration case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのため、生の値のイニシャライザは常にオプショナルの列挙ケース節を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of type inference, Swift requires far fewer type declarations than languages such as C or Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型推論のため、スウィフトはCまたはObjective-Cのような言語よりはるかに少ない型宣言しか必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because one value is true, the overall expression also evaluates to true, and access is allowed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つの値がtrueなので、式全体もまたtrueです、そしてアクセスは許可されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because optional patterns are syntactic sugar for Optional enumeration case patterns, the following are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルパターンはOptional列挙ケース節パターンに対する構文糖であるので、以下のものは等価です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because patterns represent the structure of a value rather than any one particular value, you can match them with a variety of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターンがどれかひとつの特定の値ではなく値の構造を表すので、あなたはそれをいろいろな値と照合（マッチング）できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because protocols are types, begin their names with a capital letter (such as FullyNamed and RandomNumberGenerator) to match the names of other types in Swift (such as Int, String, and Double).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルが型であるので、それらの名前を大文字で開始してください（例えばFullyNamedとRandomNumberGeneratorのように）、それによってスウィフトでの他の型の名前（例えばInt、String、およびDouble）と釣り合いがとれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because superclass A and subclass B are defined in the same source file, it is valid for the B implementation of someMethod() to call super.someMethod().</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスAとサブクラスBが同じソースファイルにおいて定義されるので、B実装のsomeMethod()がsuper.someMethod()を呼ぶことは有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the Hashable protocol conforms to Equatable, conforming types must also provide an implementation of the equals operator (==).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>HashableプロトコルがEquatableに準拠することから、準拠する型はまた同等演算子（==）のあるひとつの実装を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the Rect structure provides default values for all of its properties, it receives a default initializer and a memberwise initializer automatically, as described in Default Initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Rect構造体がそのプロパティの全てに省略時の値を与えるので、省略時のイニシャライザで記述されるように、それは自動的に省略時のイニシャライザとメンバー関連イニシャライザを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the delegate property is an optional DiceGameDelegate, the play() method uses optional chaining each time it calls a method on the delegate.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>delegateプロパティがオプショナルのDiceGameDelegateであるので、play()メソッドは、それが委任先でメソッドを呼ぶたびにオプショナル連鎖を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the vend(itemNamed:) method propagates any errors it throws, any code that calls this method must either handle the errors—using a do-catch statement, try?, or try!—or continue to propagate them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このvend(itemNamed:)メソッドはそれがスローするどんなエラーも伝達するので、このメソッドを呼び出す何らかのコードは、それらのエラーを取り扱うか ― do-catch文、try?、またはtry!を使って ― またはそれらの伝達を続けるか、どちらかをしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the vend(itemNamed:) method can throw an error, it’s called with the try keyword in front of it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>vend(itemNamed:)メソッドはエラーをスローできることから、それはそれの前のtryキーワードとともに呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the switch must have a case for every possible character, not just every alphabetic character, this switch statement uses a default case to match all characters other than a and z.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switchは、単にすべてのアルファベット文字ではなく、すべての可能な文字に対してひとつのケース節を持たなければならないことから、このswitch文はaとzのほかのすべての文字にマッチするためにdefaultケース節を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the return type can be a tuple type, function types support functions and methods that return multiple values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>return typeはタプル型であることが可能なので、関数型は複数の値を返す関数およびメソッドをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the arithmetic addition operator is a binary operator, this operator method takes two input parameters of type Vector2D and returns a single output value, also of type Vector2D.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>算術加算演算子は二項演算子なので、この演算子メソッドはVector2D型の２つの入力パラメーターを取り、同じくVector2D型のただ１つの出力値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the attempt to access numberOfRooms has the potential to fail, the optional chaining attempt returns a value of type Int?, or “optional Int”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>numberOfRoomsにアクセスする試みは失敗する可能性があるので、オプショナル連鎖は型Int?の値、すなわち「オプショナルのInt」、を返すことを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the body of the closure is so short, it can even be written on a single line:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャの本文がたいへん短いので、それは一つの行に書かれさえすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the call to increment(forCount:) can fail for either of these two reasons, the call returns an optional Int value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>increment(forCount:)への呼び出しがこれらの２つの理由のどちらによっても失敗する可能性があるので、呼び出しはオプショナルのInt値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the cases of a switch statement do not fall through to the next case in Swift, it avoids common C errors caused by missing break statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文のケース節はスウィフトでは次のケース節に抜け落ちることはないことから、それはbreak文の書き落としに起因する広く知られたCエラーを回避します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the closure’s body contains a single expression (s1 &gt; s2) that returns a Bool value, there is no ambiguity, and the return keyword can be omitted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャの本文がBool値を返すただ一つの式（s1 &gt; s2）を含むので、曖昧さはありません、それでreturnキーワードは省略されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the data is nested, the enumeration used to store the data also needs to support nesting—this means the enumeration needs to be recursive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>データが入れ子にされるため、データを格納するために使われる列挙もまた、入れ子をサポートする必要があります—これは列挙が再帰することを必要とするのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the function returns a String value, greet(person:) can be wrapped in a call to the print(_:separator:terminator:) function to print that string and see its return value, as shown above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数はString値を返すので、上で見られるように、greet(person:)はprint(_:separator:terminator:)関数への呼び出しの中に包まれて、その文字列を出力してその戻り値を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the function’s return type is private, you must mark the function’s overall access level with the private modifier for the function declaration to be valid:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の戻り型が非公開であるので、あなたはこの関数宣言が有効になるために関数の全体的なアクセス水準にprivate修飾子で印しなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the initializer might fail, it returns an optional Int, rather than an Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザが失敗するかもしれないので、それはIntではなくて、オプショナルのIntを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the key path is created at compile time, not at runtime, the compiler can check that the property exists and that the property is exposed to the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパスは実行時ではなく、コンパイル時に作成されるため、コンパイラはプロパティが存在することおよびプロパティがObjective-Cランタイムへと露出されることを確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the new Person instance has been assigned to the reference1 variable, there is now a strong reference from reference1 to the new Person instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいPersonインスタンスがreference1変数に代入されたので、強い参照が現在reference1から新しいPersonインスタンスまで存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the sorting closure is passed as an argument to a method, Swift can infer the types of its parameters and the type of the value it returns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ソート（分類）するクロージャが引数としてメソッドに渡されるので、スウィフトは、それのパラメータの型とそれが返す値の型を推論することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the temperature has increased to 40 degrees Fahrenheit, it is no longer cold enough to advise wearing a scarf and so the else branch is triggered instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>温度が華氏40度まで増加したので、スカーフを着けることを助言するに足りるほどもはや寒くありません、それで代わりにelse分岐が作動させられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the temperature is neither too cold nor too warm to trigger the if or else if conditions, no message is printed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この気温はifまたはelse if条件の引き金になるにはあまり寒くもなくあまり暖かくもないので、メッセージは出力されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the tuple’s member values are named as part of the function’s return type, they can be accessed with dot syntax to retrieve the minimum and maximum found values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルの構成要素値は、この関数の戻り型の部分で命名されるので、それらは最小および最大の見つけられた値を取り出すためにドット構文でアクセスされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the type alias and the existing type can be used interchangeably, the type alias can’t introduce additional generic constraints.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアスと既存の型は交換可能に使われることができるので、型エイリアスは追加的な総称体制約を導入することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the value of approximateCount falls between 12 and 100, naturalCount is assigned the value "dozens of", and execution is transferred out of the switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>approximateCountの値が12と100の間で失敗することから、naturalCountは、値"dozens of"を代入されます、そして実行はswitch文の外に移されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the value of the condition is evaluated after the statements are executed, the statements in a repeat-while statement are executed at least once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文が実行された後で条件の値が評価されるので、repeat-while文の中の文は少なくとも一回は実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the value of the condition is evaluated before the statements are executed, the statements in a while statement can be executed zero or more times.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文が実行される前に、条件の値が評価されるので、while文の中の文は０回またはそれ以上実行される可能性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there are no more strong references to the Apartment instance, it too is deallocated:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Apartmentインスタンスへの強い参照はもうこれ以上ないので、それも割り当て解除されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there are no more strong references to the Customer instance, it is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Customerインスタンスへの強い参照はもうないので、それは割り当て解除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there are no more strong references to the Person instance, it is deallocated and the tenant property is set to nil:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Personインスタンスへの強い参照はもうこれ以上ないことから、それは割り当て解除されます、そしてtenant特性はnilに設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there are no other specific cases, integerToDescribe is matched by the default case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のいかなる特定のケース節もないことから、integerToDescribeはdefaultケース節に適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there is at least one strong reference, ARC makes sure that this Person is kept in memory and is not deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>少なくとも１つの強い参照があるので、ARCはこのPersonがメモリに保たれて割り当て解除されないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because these variables are of an optional type (Person?, not Person), they are automatically initialized with a value of nil, and do not currently reference a Person instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの変数がオプショナル型（Personではなく、Person?）であることから、それらは自動的にnilの値で初期化されて、今はPersonインスタンスに参照をつけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because they are named types, you can extend their behavior to suit the needs of your program, using an extension declaration, discussed in Extensions and Extension Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが名前付きの型であるので、あなたはそれらの挙動を、拡張と拡張宣言で議論される拡張宣言を使って、あなたのプログラムの必要に応じて拡張することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because they are separate instances, setting the width of cinema to 2048 doesn’t affect the width stored in hd.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが別々のインスタンスであるので、cinemaの幅を2048に設定することはhdに保存される幅に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this convenience initializer overrides a designated initializer from its superclass, it must be marked with the override modifier (as described in Initializer Inheritance and Overriding).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この便宜イニシャライザがそれのスーパークラスからの指定イニシャライザをオーバーライドするので、それはoverride修飾子で印されなければなりません（イニシャライザの継承およびオーバーライドで記述されるように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this particular array has specified a value type of String, it is allowed to store String values only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この特定の配列がStringの値型を指定したので、それが貯蔵を許可されるのはString値のみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this particular set has specified a value type of String, it is only allowed to store String values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この問題の集合が明確に指定されたStringの値型を持つことから、それはString値を格納することだけが許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this version of Residence stores an array of Room instances, its numberOfRooms property is implemented as a computed property, not a stored property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Residenceのこの改作がRoomインスタンスの配列を格納するので、そのnumberOfRoomsプロパティは計算プロパティとして実装されます、保存プロパティではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before updating currentLevel, this method checks whether the requested new level is already unlocked.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>currentLevelを更新する前に、このメソッドは要請された新しいレベルがすでに錠を開けられるかどうか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behind the scenes, UInt16 has an initializer that accepts a UInt8 value, and so this initializer is used to make a new UInt16 from an existing UInt8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>舞台裏で、UInt16はUInt8値を受け入れるイニシャライザを持ちます、それでこのイニシャライザが新しいUInt16を既存のUInt8から作るために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behind the scenes, Swift’s compiler optimizes string usage so that actual copying takes place only when absolutely necessary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>舞台裏で、スウィフトのコンパイラは、実際にコピーすることは絶対に必要なときだけ起こるように、文字列使用を最適化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behind the scenes, Swift’s native String type is built from Unicode scalar values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>舞台裏で、スウィフト生得のString型はユニコード・スカラー値によって組み立てられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary Expressions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>二項式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary literals begin with 0b, octal literals begin with 0o, and hexadecimal literals begin with 0x.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２進のリテラルは0bから始まります、８進のリテラルは0oから始まります、そして16進のリテラルは0xから始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary literals contain 0 and 1, octal literals contain 0 through 7, and hexadecimal literals contain 0 through 9 as well as A through F in upper- or lowercase.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２進のリテラルは0と1を含みます、８進のリテラルは0から7までを含みます、そして、16進のリテラルは0から9までに加えて大文字または小文字でのAからFまでを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise AND Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理積演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise Left and Right Shift Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の左および右シフト演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise NOT Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理否定演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise OR Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理和演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise XOR Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の排他的論理和演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise left and right shifts have the effect of multiplying or dividing an integer by a factor of two.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の左または右シフトは、２の因数によって、ある整数を掛けるまたは割る効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise operators can also be useful when you work with raw data from external sources, such as encoding and decoding data for communication over a custom protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位演算子はまた、あなたが外部のソースからの生のデータを扱うとき、役に立つことがありえます、例えば、あつらえのプロトコルを越えて通信するためのデータの符号化や復号など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Blue numbers are shifted, gray numbers are discarded, and orange zeros are inserted:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>青色の数はシフトされます、灰色の数は捨てられます、そしてオレンジ色のゼロが差し込まれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Boolean values are particularly useful when you work with conditional statements such as the if statement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがif文のような条件つきの文で作業するとき、ブールの値は特に役に立ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Boolean values are referred to as logical, because they can only ever be true or false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブールの値は、論理として参照されます、なぜならそれらは真か偽であることだけができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Booleans</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both C1 and C2 are type parameters for two container types to be determined when the function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C1とC2の両方は、２つのコンテナ型のための型パラメータで、関数が呼ばれるときに決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both can:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方とも以下のことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both classes correctly conform to the HasArea protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方のクラスは、正しくHasAreaプロトコルに従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both constants can now be used independently:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の定数は、今や独立して使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both designated initializers must call the single designated initializer from the superclass, to satisfy rule 1 from above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記の規則１を満たすために、両方の指定イニシャライザは、スーパークラスからその一つだけある指定イニシャライザを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both functions have a type of (Int) -&gt; Int:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の関数は、(Int) -&gt; Intの型を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both initializers can be used to create a new Color instance, by providing named values for each initializer parameter:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方のイニシャライザとも、新しいColorインスタンスを作成するために、各イニシャライザ・パラメータに名前を付けられた値を提供することで、使用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both initializers convert their single argument into the corresponding Celsius value and store this value in a property called temperatureInCelsius.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方のイニシャライザは、それらのただ１つの引数を相当する摂氏の値に変えて、その値をtemperatureInCelsiusと呼ばれるプロパティに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both integers and floats can be padded with extra zeros and can contain underscores to help with readability.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数と浮動小数点は、余分のゼロを詰められることができ、読みやすくするためにアンダースコアを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both of these classes also define a deinitializer, which prints the fact that an instance of that class is being deinitialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのクラスの両方ともデイニシャライザを定義します、それは、そのクラスのインスタンスがデイニシャライズされているという事実を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both of these extended grapheme clusters are valid ways to represent the character é, and so they are considered to be canonically equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの拡張書記素クラスタの両方とも、文字éを表わす有効な方法です、そういうわけでそれらは正準等価とみなされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both of these protocols are adopted by a structure called Person.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのプロトコルの両方とも、Personと呼ばれる構造体で採用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both of these representations qualify as a single Character value in Swift:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの表し方の双方とも、スウィフトでは単一のCharacter値としての基準を満たします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both of these variables have an initial value of nil, by virtue of being optional:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルである利点によって、これらの変数の両方とも、nilの初期値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both patterns include a binding for distance and distance is an integer in both patterns—which means that the code in the body of the case can always access a value for distance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方のパターンは、distanceに対する束縛を含みます、そしてdistanceは両方のパターンにおいて整数です—それはcaseの本文のコードは常にdistanceに対する値にアクセスできることを編みします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both place their entire definition within a pair of braces:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方とも、それらの全ての定義を一対の波括弧の範囲内に置きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both properties are inferred to be of type Double by assigning a default value of 0.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方のプロパティは、省略時の値の0.0を代入することによってDouble型であると推測されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both the IBAction and IBOutlet attributes imply the objc attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IBActionとIBOutlet属性の両方とも、objc属性の意味を当然含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both the protocol and the optional requirement must be marked with the @objc attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルとオプショナル要件の両方は、@objc属性で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Braces around the body are required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本文のまわりの波括弧は必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Branch Statements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>分岐文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Branch statements allow the program to execute certain parts of code depending on the value of one or more conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>分岐文は、プログラムが一つ以上の条件の値に従いコードの特定の部分を実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Break Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブレーク文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Break in a Loop Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文の中断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Break in a Switch Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文の中断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bridging lets you use an expression of a Swift standard library type such as String as its corresponding Foundation type such as NSString without needing to create a new instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブリッジは、あなたにStringのようなスウィフト標準ライブラリ型の式を、NSStringのようなそれの対応しているFoundation型として使用させます、新しいインスタンスを作成する必要なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Building from this common ground, Swift introduces many new features and unifies the procedural and object-oriented portions of the language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このよく知られた立地から組み立てられて、スウィフトは、多くの新しい特徴を導入して、言語の手続き的な部分とオブジェクト指向的な部分を統一します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But if you provide a setter clause, you must also provide a getter clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしあなたがセッター節を提供するならば、あなた同様にゲッター節を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By contrast, C requires you to insert an explicit break statement at the end of every switch case to prevent fallthrough.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、Cはあなたに抜け落ちること（フォールスルー）を防ぐために明示的にbreak文をあらゆるswitchケース節の終わりに書き入れることを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By creating an extension on the protocol, all conforming types automatically gain this method implementation without any additional modification.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張をプロトコル上に作成することによって、すべての準拠している型が自動的にこのメソッド実装をなんら追加の修正なしに手に入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Swift assigns the raw values starting at zero and incrementing by one each time, but you can change this behavior by explicitly specifying values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態で、スウィフトはゼロで開始して毎回１つ増加させながら生の値を割り当てます、しかしあなたは明示的にそれらの値を指定することでこの挙動を変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, a closure expression captures constants and variables from its surrounding scope with strong references to those values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、クロージャ式は、それの囲んでいるスコープから定数や変数をそれらの値への強い参照を使ってキャプチャします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, any new Bicycle instance you create will not have a basket.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしなければ、あなたが作成するあらゆる新しいBicycleインスタンスは、入れ物かごを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, floating-point literals are expressed in decimal (with no prefix), but they can also be expressed in hexadecimal (with a 0x prefix).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態で、浮動小数点リテラルは10進において（接頭辞なしで）表されます、しかしそれらはまた、16進法において（0x接頭辞で）表されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, functions use their parameter names as labels for their arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしなくとも、関数はそれらのパラメータ名をそれらの引数のラベルとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, initializers declared in a superclass are not inherited by subclasses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、スーパークラスで宣言されるイニシャライザは、サブクラスによって継承されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, integer literals are expressed in decimal; you can specify an alternate base using a prefix.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、整数リテラルは10進法で表されます；あなたは、接頭辞を使用して代替の基数を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, most declarations are implicitly marked with the internal access-level modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時では、大部分の宣言は暗黙的にinternalアクセス水準修飾子で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, only entities marked as open or public are accessible to other modules.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしない状態では、開放または公開と印される実在だけが他のモジュールに利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, parameter names are also used as argument labels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしなければ、パラメータ名はまた引数ラベルとしても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, parameters use their parameter name as their argument label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしなければ、パラメータはそれらのパラメータ名をそれらの引数ラベルとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the asHTML property is assigned a closure that returns a string representation of an HTML tag.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしなければ、asHTMLプロパティは、あるHTMLタグの文字列表現を返すクロージャを代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the ~= operator compares two values of the same type using the == operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態で、~=演算子は、同じ型の２つの値を==演算子を使用して比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the function terminates the line it prints by adding a line break.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、この関数はそれが出力する行を改行を加えて終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the parameters used in subscripting don’t have argument labels, unlike functions, methods, and initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態で、添字において使用されるパラメータは引数ラベルを持ちません、関数、メソッド、およびイニシャライザとは違って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the properties of a value type cannot be modified from within its instance methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、ある値型に属するプロパティは、それのインスタンスメソッド内から修正されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, types that conform to a protocol must implement all properties, methods, and subscripts declared in the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、あるプロトコルに準拠する型は、そのプロトコルにおいて宣言される全てのプロパティ、メソッド、そして添え字を実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, variables, constants, and other named declarations that are declared at the top-level of a source file are accessible to code in every source file that is part of the same module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、あるソースファイルのトップレベルで宣言される変数、定数、そして他の名前をつけられる宣言は、同じモジュールの一部であるすべてのソースファイルの中のコードにアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By making if x = y invalid, Swift helps you to avoid these kinds of errors in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if x = yを無効にすることによって、スウィフトはあなたがこれらの種類のエラーをあなたのコードにおいて避けるのを手伝います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By returning a tuple with two distinct values, each of a different type, the function provides more useful information about its outcome than if it could only return a single value of a single type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの別の値をそれぞれ異なる型で持つひとつのタプルを返すことによって、その関数は、それが一つの型の一つの値を返すことができるだけよりも、その結果に関するより役に立つ情報を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By wrapping the function call in a do statement, any errors that are thrown will be propagated to the provided catch clauses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関数呼び出しをdo文の中に包み込むことによって、スローされるどんなエラーも添付のcatch節に伝えられるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call a function by following its name with a list of arguments in parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、その名前の後に丸括弧に入れた引数の目録（リスト）を続けることで呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call one of the initializers declared within the class, as described in Initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのクラス内で宣言されるイニシャライザのうちの１つを呼び出す、イニシャライザで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call one of the initializers declared within the structure, as described in Initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その構造体の内部で宣言されるイニシャライザの内の１つを呼び出す、イニシャライザで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling Methods Through Optional Chaining</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を通してメソッドを呼ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling the function multiple times shows this behavior in action:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数を複数回呼ぶことは、活動中にこの挙動を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling the original incrementer (incrementByTen) again continues to increment its own runningTotal variable, and does not affect the variable captured by incrementBySeven:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のインクリメンタ（incrementByTen）を再び呼ぶことは、それ独自のrunningTotal変数を増加させることを継続します、そしてincrementBySevenによってキャプチャされる変数に影響しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling the superclass’s initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスのイニシャライザを呼ぶ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling this initializer returns a Rect instance whose origin and size properties are both initialized with the default values of Point(x: 0.0, y: 0.0) and Size(width: 0.0, height: 0.0) from their property definitions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザを呼ぶことはRectインスタンスを返します、それは、originとsizeプロパティが両方ともそれらのプロパティ定義からの省略時の値のPoint(x: 0.0、y: 0.0)とSize(width: 0.0、height: 0.0)で初期化されるものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls to a throwing function or method must be wrapped in a try or try! expression (that is, in the scope of a try or try! operator).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スロー関数またはメソッドに対する呼び出しは、tryまたはtry!式の中に（即ち、tryまたはtry!演算子のスコープの中に）包まれなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Capture Lists</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャプチャリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Capturing Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値を捕獲する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Capturing by reference ensures that runningTotal and amount do not disappear when the call to makeIncrementer ends, and also ensures that runningTotal is available the next time the incrementer function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>参照を捕獲することは、makeIncrementerへの呼び出しが終わる時にrunningTotalとamountが消えてなくならないことを確かにします、そしてまたincrementer関数が呼ばれる次の時にrunningTotalが利用可能であることを確実にもします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Carriage Return (\r)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャリッジリターン「復帰文字」（\r）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cases can match many different patterns, including interval matches, tuples, and casts to a specific type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらのケース節は、区間マッチ、タプル、そして特定の型への型キャストを含む、多くの異なるパターンにマッチすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Casting does not actually modify the instance or change its values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャストは、実際にインスタンスを修正したり、その値を変えたりしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chaining on Methods with Optional Return Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの戻り値をもつメソッド上で連鎖する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Change optionalName to nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>optionalNameをnilに変えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Change the printer name to "Never Has Toner", so that the send(job:toPrinter:) function throws an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プリンタ名を"Never Has Toner"に変更してください、そうするとsend(job:toPrinter:)関数はエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changing the value of currentDirection thereafter does not affect the copy of the original value that was stored in rememberedDirection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それ以降にcurrentDirectionの値を変えることは、本来の値のコピーに、rememberedDirectionに保存されたものに影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changing the value of properties defined by the superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスによって定義されるプロパティの値を変える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking API Availability</seg>
      </tuv>
      <tuv lang="JA">
        <seg>API有効性の確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型を調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking for Protocol Conformance</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル準拠の確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking for an empty string value (such as "" rather than "Giraffe") is not the same as checking for nil to indicate the absence of an optional String value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の文字列値（例えば"Giraffe"といったものでなく""）について調べることは、オプショナルのString値の不在を指し示すnilについて調べることと同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking for and casting to a protocol follows exactly the same syntax as checking for and casting to a type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルについて調べたりそれにキャストすることは、ある型について調べたりキャストするのと正確に同じ構文に従います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking the frameRate property of tenEighty shows that it correctly reports the new frame rate of 30.0 from the underlying VideoMode instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>tenEightyのframeRateプロパティを調べてみると、それが根底にあるVideoModeインスタンス由来の新しいフレームレートの30.0を正しく報告することがわかります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking the width property of cinema shows that it has indeed changed to be 2048:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>cinemaのwidthプロパティをチェックすると、2048になるように変えられたことを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chess is played on an 8 x 8 board, with alternating black and white squares.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チェスは、黒と白の正方形を互い違いに持つ、８×８マスの盤上で行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choosing Between Classes and Structures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスと構造体のどちらかを選ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clarified the full list of characters that can be used when defining Custom Operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの演算子を定義するとき使われることが出来る文字の完全なリストをわかりやすくしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class B is a subclass of A, with a reduced access level of “internal”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスBはAのサブクラスです、そして減少させられたアクセス水準の「内部」を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class Implementations of Protocol Initializer Requirements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ要件プロトコルのクラス実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class Inheritance and Initialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス継承と初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class and Structure Instances</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスと構造体のインスタンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class and structure initialization is described in more detail in Initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスと構造体の初期化は、更に詳細に初期化で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class declarations are declared using the class keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言は、キーワードclassを使用して宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class declarations can’t contain protocol declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言は、プロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class definitions can have at most one deinitializer per class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス定義は、クラスごとに多くとも１つのデイニシャライザしか持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class initialization in Swift is a two-phase process.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでのクラス初期化は、２段階処理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class members with public access, or any more restrictive access level, can be overridden by subclasses only within the module where they’re defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開アクセス、または何らかのより制限のあるアクセス水準を持つクラスメンバーは、それらが定義されるところのモジュール内部でのみ、サブクラスによってオーバライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class types can inherit from a single superclass and conform to any number of protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス型は、１つのスーパークラスから継承することができ、任意の数のプロトコルに準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class-Only Protocols</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス専用プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes Are Reference Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは、参照型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and Structures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスと構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and structures must set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスと構造体は、それらの保存プロパティの全てを、そのクラスや構造体のインスタンスがつくられる時には適切な初期値に設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and structures can also provide implementations of the standard unary operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスと構造体は、また、標準の単項演算子の実施も提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and structures can provide their own implementations of existing operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスと構造体は、既存の演算子のそれら独自の実装を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and structures have a similar definition syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスと構造体は、類似した定義構文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and structures in Swift have many things in common.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでのクラスと構造体は、多くのものを共通して持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes are reference types; instances of a class are referred to, rather than copied, when assigned to variables or constants, or when passed as arguments to a function call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは、参照型です；クラスのインスタンスは、変数または定数に代入されるとき、または関数呼び出しに対する引数として渡されるときに、コピーされるのではなく、参照されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes can also add property observers to inherited properties in order to be notified when the value of a property changes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスはまた、プロパティの値が変化するとき通知されるように継承されたプロパティにプロパティオブザーバー（監視者）を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes do not have a default memberwise initializer, and so the Food class provides a designated initializer that takes a single argument called name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのクラスには省略時のメンバー関連イニシャライザがありません、なので、Foodクラスはnameと呼ばれる１つの引数をとる指定イニシャライザを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes have additional capabilities that structures do not:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは、構造体がそうしない追加の能力を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes in Swift can call and access methods, properties, and subscripts belonging to their superclass and can provide their own overriding versions of those methods, properties, and subscripts to refine or modify their behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのクラスは、それらのスーパークラスに属しているメソッド、プロパティ、そして添え字の呼び出しやアクセスが行えて、それらのメソッド、プロパティ、そして添え字の独自の優先的に使われる改変板を提供することでそれらの挙動の洗練や修正を行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes marked with the objc attribute must inherit from a class defined in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>objc属性で印されたクラスは、Objective-Cにおいて定義されたクラスから継承しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes may also use the class keyword to allow subclasses to override the superclass’s implementation of that method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスはまたclassキーワードを使って、サブクラスにスーパークラスのもつそのメソッドの実装のオーバーライドを許可することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes may mark type computed properties with the class declaration modifier instead to allow subclasses to override the superclass’s implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは型計算プロパティを代わりにclass宣言修飾子で印をつけて、サブクラスがスーパークラスの実装をオーバーライドすることを許可することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes tend to have very few designated initializers, and it is quite common for a class to have only one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスはほとんど指定イニシャライザを持たない傾向があります、そして、あるクラスが１つだけしか持たないことは全く普通です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes that implement this method declare the method with the class modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのメソッドを実装するクラスは、このメソッドをclass修飾子を使って宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes with public access, or any more restrictive access level, can be subclassed only within the module where they’re defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開アクセス、または何らかのより制限のあるアクセス水準を持つクラスは、それらが定義されるところのモジュール内部でのみ、サブクラスを作成されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes you define without specifying a superclass automatically become base classes for you to build upon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスを指定することなくあなたが定義するクラスは、自動的に基盤クラスになり、あなたが基礎とするために使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes, enumerations, and structs can all adopt protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス、列挙、そして構造体は、全てそのようなプロトコルを採用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes, however, can inherit from other classes, as described in Inheritance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスはしかし、継承で記述されるように、他のクラスから継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのクラス、構造体、および列挙は、すべてインスタンスメソッドを定義することができます、それは、ある定められた型のあるインスタンスで働くために特定の作業や機能性をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes, structures, and enumerations can also define type methods, which are associated with the type itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス、構造体、および列挙は、また、型メソッドを定義することができます、それは型それ自身に結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes, structures, and enumerations can define subscripts, which are shortcuts for accessing the member elements of a collection, list, or sequence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス、構造体、および列挙は、添え字を定義することができます、それは、コレクション、リスト、またはシーケンスのメンバー要素にアクセスするための近道です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closed Range Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>完結範囲演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closure Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closure Expression Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closure Expressions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closure expression syntax has the following general form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式構文は、以下の一般的な形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式は、それの周囲の前後関係から値を捕獲することができる軽快な構文で書かれる無名のクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closure expressions provide several syntax optimizations for writing closures in a shortened form without loss of clarity or intent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式は、いくつかの構文最適化を、ある省略形式で明快さや意図の損失なしでクロージャを書くために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closures Are Reference Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは参照型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closures can capture and store references to any constants and variables from the context in which they are defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは、それが定義されている前後関係からのあらゆる定数や変数への参照を捕獲して、保存することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおけるクロージャは、CとObjective-Cでのブロックに、そして他のプログラミング言語でのラムダ（lambda）に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closures take one of three forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは、３つの書式のうちの１つをとります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code Blocks</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コード・ブロック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code written at global scope is used as the entry point for the program, so you don’t need a main() function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グローバルなスコープで書かれるコードは、プログラムのエントリポイントとして使われるので、あなたはmain()関数を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collection Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コレクション型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collections of Protocol Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル型のコレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Combining Logical Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理演算子を結合する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments are ignored by the Swift compiler when your code is compiled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードがコンパイルされるとき、コメントはスウィフトのコンパイラによって無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments are not statements and do not cause a switch case to be ignored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コメントは、文でなくて、switchケース節を無視されるようにはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments are treated as whitespace by the compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コメントは、コンパイラによって空白とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments can contain additional formatting and markup, as described in Markup Formatting Reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コメントは、さらに追加の書式とマークアップを含む事が、マークアップ書式リファレンスで記述されるように可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments in Swift are very similar to comments in C. Single-line comments begin with two forward-slashes (//):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのコメントは、Cのコメントに非常に似ています。一行コメントは２つのスラッシュで始まります（//）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compare the return value from the printNumberOfRooms call against nil to see if the method call was successful:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>printNumberOfRooms呼び出しからの戻り値をnilと比較して、そのメソッドがうまく呼び出されたか見てください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparing Classes and Structures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスと構造体を比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparing Strings</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列を比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparison Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>比較演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparison operators are often used in conditional statements, such as the if statement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>比較演算子は、条件文においてしばしば使われます、例えばif文など：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparisons like i == 1 are discussed in Basic Operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>i == 1のような比較は「基本の演算子」で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compiler Control Statements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラ制御文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compiler control statements allow the program to change aspects of the compiler’s behavior and include a conditional compilation block and a line control statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラ制御文は、プログラムにコンパイラの挙動のいろいろな面を変更できるようにします、そして条件コンパイルブロックと行制御文を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compiler control statements allow the program to change aspects of the compiler’s behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラ制御文は、プログラムに、コンパイラの挙動の様々な面を変更できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compound Assignment Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合代入演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compound Cases</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合ケース節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compound cases can also include value bindings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合ケース節はまた、値束縛を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computed Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computed Variables and Computed Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算変数と計算プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computed properties are provided by classes, structures, and enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算プロパティは、クラス、構造体、および列挙で提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computed type properties are always declared as variable properties, in the same way as computed instance properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算型プロパティは、計算インスタンスプロパティと同じ方法で、常に変数プロパティとして宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computed variables calculate their value, rather than storing it, and they are written in the same way as computed properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算変数は値を計算します、それの貯蔵ではなくて、そして計算プロパティと同じ方法で書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concatenating Strings and Characters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列と文字の連結</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional Compilation Block</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件コンパイルブロック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional Statements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件つきの文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional compilation blocks that contain multiple branches have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数の分岐を含む条件コンパイルブロックは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional statements such as the if statement are covered in more detail in Control Flow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文のような条件つきの文は、更に詳細に「制御の流れ」で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conform to protocols to provide standard functionality of a certain kind</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定の種類の標準の機能性を提供するために、プロトコルに準拠します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the Hamster structure from before, which conforms to the TextRepresentable protocol, and an array of Hamster values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前のHamster構造体を考えてください、それはTextRepresentableプロトコルに準拠します、そしてHamster値の配列です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider this example, which uses the Resolution structure from the previous example:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例を考慮してください、それは、前の例からResolution構造体を使用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant and variable names can contain almost any character, including Unicode characters:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数の名前は、ユニコード文字を含めて、ほとんどどんな文字でも含むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant and variable names cannot contain whitespace characters, mathematical symbols, arrows, private-use (or invalid) Unicode code points, or line- and box-drawing characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数の名前は、空白文字、数学記号、矢印、私的使用（または無効な）Unicodeコード点、または書式印刷文字および罫線素片を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant declarations are declared using the let keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言は、letキーワードを使用して宣言され、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant declarations are not computed properties and therefore do not have getters or setters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言は、計算プロパティではなく、したがって、ゲッターまたはセッターを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant properties must always have a value before initialization completes, and therefore cannot be declared as lazy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数プロパティは常に値を、初期化が完了する前に持たなければなりません、それゆえに遅延であると宣言されることが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants and Variables</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants and variables are still explicitly typed, but much of the work of specifying their type is done for you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数は依然として明確に型を決められます、しかしそれらの型を指定する行為のほとんどは、あなたのために行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants and variables associate a name (such as maximumNumberOfLoginAttempts or welcomeMessage) with a value of a particular type (such as the number 10 or the string "Hello").</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数は、ひとつの名前（例えばmaximumNumberOfLoginAttemptsまたはwelcomeMessageなど）を特定の型のひとつの値（例えば数10または文字列"Hello"など）と結びつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants and variables created with optional binding in an if statement are available only within the body of the if statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文の中でオプショナル束縛を使って作成された定数と変数は、そのif文の本文の内部でのみ利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants and variables must be declared before they are used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数は、それらが使われる前に宣言されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants and variables of type Any can now contain function instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型Anyの定数と変数は、今では関数インスタンスを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants and variables of type Barcode can store either a .upc or a .qrCode (together with their associated values), but they can only store one of them at any given time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型Barcodeの定数と変数は、.upcまたは.qrCodeのどちらでも（それらの関連値と共に）格納することができます、しかしそれらはどんな時でもそれらの１つを保存することだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants can now be declared without being initialized in local function scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数は今では初期化されることなくローカル関数のスコープ内で宣言されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants, Variables, Properties, and Subscripts</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数、変数、プロパティ，そして添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Continue Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>継続文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control Flow</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御の流れ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control Transfer Statements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御移動文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control flow in a loop statement can be changed by a break statement and a continue statement and is discussed in Break Statement and Continue Statement below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文の中の制御の流れは、break文そしてcontinue文によって変えられることができます、そして下記のブレーク文と継続文で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control flow in an if statement or a switch statement can be changed by a break statement and is discussed in Break Statement below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文またはswitch文の中の制御の流れは、break文によって変えられることができます、それは下記のブレーク文で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control flow statements are used to control the flow of execution in a program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御の流れ文は、プログラムにおいて実行の流れを制御するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control transfer statements are discussed in Control Transfer Statements below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御移動文は、下の制御移動文で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control transfer statements can change the order in which code in your program is executed by unconditionally transferring program control from one piece of code to another.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御移動文は、あなたのプログラムの中のコードが実行される順番を、プログラム制御を１つのコード片から他のものまで無条件に移すことによって変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Convenience initializers are written in the same style, but with the convenience modifier placed before the init keyword, separated by a space:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは同じ形式で書かれます、しかしconvenience修飾子がinitキーワードの前に空白で区切って置かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Convenience initializers can delegate the initialization process to another convenience initializer or to one of the class’s designated initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは、初期化プロセスを別の便宜イニシャライザに、またはそのクラスの指定イニシャライザのうちの１つに委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Convenience initializers can’t call a superclass’s initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは、スーパークラスのイニシャライザを呼ぶことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Convenience initializers must always delegate across.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは、常に横に委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, LATIN CAPITAL LETTER A (U+0041, or "A"), as used in English, is not equivalent to CYRILLIC CAPITAL LETTER A (U+0410, or "А"), as used in Russian.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>反対に、英語で使われるような、LATIN CAPITAL LETTER A（U+0041、または"A"）は、ロシアで使われるような、CYRILLIC CAPITAL LETTER A（U+0410、または"А"）と等しくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, always give properties and methods lowerCamelCase names (such as frameRate and incrementCount) to differentiate them from type names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>逆に、それらを型名と区別するために、常に、プロパティとメソッドにlowerCamelCase ローワーキャメルケース名（例えばframeRateやincrementCount）を与えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, define a capture as a weak reference when the captured reference may become nil at some point in the future.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>逆に、捕らえられた参照が将来どこかの時点でnilになるかもしれないときは、捕獲を弱い参照として定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, if you write a subclass initializer that matches a superclass convenience initializer, that superclass convenience initializer can never be called directly by your subclass, as per the rules described above in Initializer Delegation for Class Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>逆に言えば、上記のクラス型のためのイニシャライザ委任で記述される規則どおりに、あなたがスーパークラスの便宜イニシャライザに一致するサブクラスのイニシャライザを書くならば、そのスーパークラスの便宜イニシャライザは直接にあなたのサブクラスによって呼び出されることが決してできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, set b is a subset of set a, because all elements in b are also contained by a.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>逆に言えば、集合bは集合aの下位集合です、bの要素すべてはaによってまた含まれるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversions between integer and floating-point numeric types must be made explicit:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数と浮動小数点数型の間の変換は、明示的に行われる必要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Converting Errors to Optional Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーをオプショナルの値に変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Corrected the discussion of the @NSApplicationMain attribute in the Declaration Attributes section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@NSApplicationMain属性の解説を宣言属性の節において訂正した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Counting Characters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字を数える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create a constant with an explicit type of Float and a value of 4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明確にFloatの型で値4の定数をつくってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create an instance of a class by putting parentheses after the class name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス名の後に丸括弧を置くことによって、クラスのインスタンスをつくってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create arrays and dictionaries using brackets ([]), and access their elements by writing the index or key in brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>角括弧（[]）を使って配列および辞書（連想配列）を作ってください、そしてインデックスまたはキーを角括弧の中に記述することによってそれらの要素にアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create convenience initializers whenever a shortcut to a common initialization pattern will save time or make initialization of the class clearer in intent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>共通の初期化の繰り返しに対する近道が時間を節約したり、そのクラスの初期化を意図においてより明白にするときはいつでも、便宜イニシャライザをつくってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating a Dictionary with a Dictionary Literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書を辞書リテラルで作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating a Set with an Array Literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合を配列リテラルで作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating an Array by Adding Two Arrays Together</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの配列を一緒にすることで１つの配列を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating an Array with a Default Value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列を１つの初期値で作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating an Array with an Array Literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列を配列リテラルで作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating an Empty Array</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の配列の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating an Empty Dictionary</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の辞書を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating and Initializing an Empty Set</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の集合の作成と初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom classes and structures do not receive a default implementation of the equivalence operators, known as the “equal to” operator (==) and “not equal to” operator (!=).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえのクラスと構造体は、「同等」演算子（==）そして「不等」演算子（!=）として知られる、同等演算子たちの省略時の実装を受け取りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom infix operators each belong to a precedence group.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの接中辞演算子それぞれは、ある優先順位グループに属しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom initializers can be assigned an access level less than or equal to the type that they initialize.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえのイニシャライザは、それらが初期化する型と同じか低いアクセス水準を割り当てられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom operators can begin with one of the ASCII characters /, =, -, +, !, *, %, &lt;, &gt;, &amp;, |, ^, ?, or ~, or one of the Unicode characters defined in the grammar below (which include characters from the Mathematical Operators, Miscellaneous Symbols, and Dingbats Unicode blocks, among others).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの演算子は、ASCII文字/、=、-、+、!、*、%、&lt;、&gt;、&amp;、|、^、?、および~のうちの１つ、または以下の文法において定義されるユニコード文字のうちの１つで始まります（それはMathematical Operators、Miscellaneous Symbols、そしてDingbatsユニコードブロックなどからの文字を含みます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom operators can now contain the ? character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの演算子は、今では?文字を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom types state that they adopt a particular protocol by placing the protocol’s name after the type’s name, separated by a colon, as part of their definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの型は、それが特定のプロトコルを採用することを、型の名前の後に、コロンで区切って、それらの定義の一部としてプロトコルの名前を置くことによって示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Customizing Initialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化をカスタマイズする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data types that are normally considered basic or primitive in other languages—such as types that represent numbers, characters, and strings—are actually named types, defined and implemented in the Swift standard library using structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の言語で通常は基本的またはプリミティブであるとみなされるデータ型 ― 例えば数、文字、そして文字列を表す型 ― これらは実際に名前付きの型で、構造体を使用してスウィフト標準ライブラリにおいて定義および実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DataImporter is a class to import data from an external file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（DataImporterは、データを外部ファイルからインポートするクラスです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Date</seg>
      </tuv>
      <tuv lang="JA">
        <seg>日付</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Debugging with Assertions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明を使ってデバッグする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decimal floating-point literals consist of a sequence of decimal digits followed by either a decimal fraction, a decimal exponent, or both.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>10進の浮動小数点リテラルは、一連の10進の桁に、小数部か10進の指数のどちらか、または両方が続くものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decimal floats can also have an optional exponent, indicated by an uppercase or lowercase e; hexadecimal floats must have an exponent, indicated by an uppercase or lowercase p.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>10進浮動小数点はまた、任意に指数を持つことができ、大文字か小文字のeで示されます；16進浮動小数点は、指数を持つ必要があり、大文字か小文字のpで示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decimal literals contain the digits 0 through 9.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>10進のリテラルは、0から9までの桁を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaration Attributes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaration Attributes Used by Interface Builder</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インターフェースビルダーで使用される宣言属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaration Modifiers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言修飾子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declarations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declarations marked with the open access-level modifier can also be accessed and subclassed by code in a module that imports the module that contains that declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>openアクセス水準修飾子で印される宣言はまた、アクセスされることおよびサブクラスを作られることが、その宣言を含むモジュールをインポートするモジュール内のコードによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declarations marked with the public access-level modifier can also be accessed (but not subclassed) by code in a module that imports the module that contains that declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>publicアクセス水準修飾子で印される宣言はまた、アクセスされる（しかしサブクラスは作られない）ことが、その宣言を含むモジュールをインポートするモジュール内のコードによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declare extensions with the extension keyword:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>extensionキーワードによって拡張を宣言してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring Constants and Variables</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数の宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring Protocol Adoption with an Extension</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張を使ってプロトコル採用を宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default Access Levels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default Initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default Memberwise Initializers for Structure Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体体型のための省略時のメンバー関連イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default Parameter Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のパラメータ値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default Property Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のプロパティ値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default values, however, cannot be specified for method parameters within a protocol’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の値は、しかしながら、プロトコル定義の内部のメソッドパラメーターに対して指定されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defer Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>defer文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deferred actions are executed in reverse order of how they are specified—that is, the code in the first defer statement executes after code in the second, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>延期された動作は、それらが指定されるのと逆の順序で実行されます—すなわち、最初のdefer文の中のコードは２番目の中のコードの後に実行される、等々。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが捕らえるクロージャとインスタンスが常にお互いに言及して、常に同時に割り当て解除されるときは、クロージャにおいて捕獲を非所有者参照として定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define and use new nested types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい入れ子にされた型を定義して、使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define initializers to set up their initial state</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの初期状態を設定するために、イニシャライザを定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define instance methods and type methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスメソッドと型メソッドを定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define methods to provide functionality</seg>
      </tuv>
      <tuv lang="JA">
        <seg>機能性を提供するために、メソッドを定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define properties to store values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値を格納するために、プロパティを定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define subscripts</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字を定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define subscripts to provide access to their values using subscript syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字構文を使用してそれらの値の利用することを提供するために、添え字を定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define the access level for an entity by placing one of the open, public, internal, fileprivate, or private modifiers before the entity’s introducer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある実在にアクセス水準を定義するには、open、public、internal、fileprivate、またはprivate修飾子のうちの１つをその実在の導入子の前に置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Model Classes for Optional Chaining</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖のモデル・クラスを定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a Base Class</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基盤クラスを定義すること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a Capture List</seg>
      </tuv>
      <tuv lang="JA">
        <seg>捕獲リストの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a Class Hierarchy for Type Casting</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャストのためにクラス階層を定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining and Calling Functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の定義と呼び出し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Definition Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定義構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitializer Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitializers are called automatically, just before instance deallocation takes place.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、インスタンスの割り当て解除が起こる直前に、自動的に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitializers are not called directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、直接に呼ばれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitializers are only available on class types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、クラス型で利用可能なだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitializers enable an instance of a class to free up any resources it has assigned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、クラスのインスタンスにそれが代入したどんなリソースでも解放するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitializers in Action</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitializers take no parameters and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、パラメータを取らない以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delaying evaluation is useful for code that has side effects or is computationally expensive, because it lets you control when that code is evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>評価を遅らせることは、副作用を持つまたは計算的に高くつくコードに対して有用です、なぜならそれがあなたに何時そのコードが評価されるかを制御させるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delegation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>委任</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delegation can be used to respond to a particular action, or to retrieve data from an external source without needing to know the underlying type of that source.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>委任は、特定の動作に応答したり、外部ソースからそのソースの根底の型を知る必要なしにデータを取り出したりするのに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated Initializers and Convenience Initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザと便宜イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated and Convenience Initializers in Action</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定および便宜イニシャライザの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated initializers and deinitializers must always be provided by the original class implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザとデイニシャライザは、常に最初のクラス実施によって提供されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated initializers are “funnel” points through which initialization takes place, and through which the initialization process continues up the superclass chain.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、「漏斗」地点です、そこを通して初期化が行われ、そこを通して初期化処理がスーパークラス連鎖を上って続いていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated initializers can be declared in the context of a class declaration only and therefore can’t be added to a class using an extension declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、クラス宣言の文脈においてのみ宣言されることができて、したがって拡張宣言を使ってあるクラスに加えられることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated initializers for classes are written in the same way as simple initializers for value types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスのための指定イニシャライザは、値型のための単純なイニシャライザと同様に書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated initializers must always delegate up.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、常に上に委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Despite this simplicity of syntax, Swift’s String type is a fast, modern string implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構文のこの単純さにもかかわらず、スウィフトのString型は、速く、現代的な文字列の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dictionaries</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dictionaries are an unordered collection, so their keys and values are iterated over in an arbitrary order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書は、順序付けられないコレクションです、なのでそのキーと値は気まぐれな順番で繰り返されていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dictionaries are unordered collections of key-value associations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書は、「キーと値」を結びつけたものの順番をつけられないコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dictionary Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dictionary Type Shorthand Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書型の略記構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disabling Error Propagation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラー伝達を抑制する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの異なった状況を区別することは、プログラムにいくらかのエラーを解消すること、そしてなんらかのそれが解消できないエラーを利用者に伝えることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Division (/)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>除算（/）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>do文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not access the value that was passed as an in-out argument, even if the original argument is available in the current scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-out引数として渡された値にアクセスしないでください、たとえオリジナルの引数が現在のスコープで利用可能であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not depend on the implementation of the call-by-reference optimization to try to keep the changes from being overwritten.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの変更を上書きされることから守ろうとして、参照呼び出しの最適化の実装に依存しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not use an implicitly unwrapped optional when there is a possibility of a variable becoming nil at a later point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある変数がその後のある時点でnilになる可能性がある時には、暗黙的にアンラップされるオプショナルを使用しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do this by placing an exclamation mark after the init keyword (init!) instead of a question mark.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを、疑問符ではなく、感嘆符をinitキーワードの後に置くこと（init!）によって行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do this by writing the final modifier before the method, property, or subscript’s introducer keyword (such as final var, final func, final class func, and final subscript).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッド、プロパティ、または添え字の導入子キーワードの前にfinal修飾子を書くことによって、これをしてください（例えば、final var、final func、final class func、そしてfinal subscriptなど）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Document Revision History</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文書改訂履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing so clarifies that you intend to provide an override and have not provided a matching definition by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうすることは、あなたがオーバーライドを提供するつもりであって、誤って同じ定義を提供したのでないことを明らかにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing so is consistent with the label’s use alongside the break statement and helps make the game’s logic clearer to read and understand.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうすることは、break文と並べるとラベルの使用で調和して、ゲームの論理を読み取って理解するのをより明快にする助けとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing so makes it easier for you to reason about your code and enables the Swift compiler to optimize the performance of the collections you create.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうすることは、あなたがあなたのコードについて推論するのをより容易にして、スウィフトのコンパイラにあなたが作成するコレクションの運用性能を最適なものにすることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don’t worry if you are not familiar with the concept of capturing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがキャプチャの概念に馴染みがなくても、心配いりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don’t worry if you don’t understand something—everything introduced in this tour is explained in detail in the rest of this book.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>わからないことがあっても心配することはありません ― このツアーにおいて紹介されるすべてのことは、この本の残りで詳細に説明されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Double Quote (\")</seg>
      </tuv>
      <tuv lang="JA">
        <seg>二重引用符（\"）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Downcasting</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ダウンキャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Downcasting to Movie fails when applied to the Song instances in the library array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Movieにダウンキャストすることは、library配列のSongインスタンスに適用されるとき失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Download Playground</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「遊び場」をダウンロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic Type Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動的型式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each Player instance is initialized with a starting allowance of a specified number of coins from the bank during initialization, although a Player instance may receive fewer than that number if not enough coins are available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各Playerインスタンスは、初期化の間に、胴元からの指定された数のコインの開始手当で初期化されます、とは言え、十分なコインが利用可能でなければPlayerインスタンスはその数より少ないものを受け取るかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each String value has an associated index type, String.Index, which corresponds to the position of each Character in the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのString値は、結び付けられたインデックス型、String.Indexを持ちます、それは、各Characterのその文字列中での位置に対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each UnicodeScalar has a value property that returns the scalar’s 21-bit value, represented within a UInt32 value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各UnicodeScalarはひとつのvalueプロパティを持ちます、それはそのスカラーの21ビットの値を返します、そしてそれはUInt32値の範囲内で表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each Starship class instance stores a mandatory name and an optional prefix.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各Starshipクラスインスタンスは、義務的なnameそしてオプショナルのprefixを格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each case compares that value to a number or interval.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各caseは、その値をある数または区間と比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each access-level modifier above optionally accepts a single argument, which consists of the set keyword enclosed in parentheses (for instance, private(set)).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記のそれぞれのアクセス水準修飾子は、任意に１つだけの引数を受け入れます、それは丸括弧に囲まれたキーワードsetからなります（例えば、private(set)）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each approach is described in a section below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各取り組みは、以下の節で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each barcode has a “number system” digit, followed by five “manufacturer code” digits and five “product code” digits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各バーコードは、一つの「ナンバーシステム」桁、それに続く５桁の「製造者コード」そして５桁の「商品コード」を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each build target (such as an app bundle or framework) in Xcode is treated as a separate module in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Xcodeでの各ビルドターゲット（例えばアプリ・バンドルまたはフレームワーク）は、スウィフトにおいて別々のモジュールとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each case can also specify that it stores values of a given type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各ケース節は、また、それが特定の型の値を保存することを示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each case must have a unique name and be assigned a unique raw value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのケース節は、固有な名前を持ち固有な生の値を割り当てられなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each channel has an integer audio level between 0 and 10 inclusive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各チャンネルは、0から10を含むまでの整数オーディオ・レベルがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each element of the tuple can be tested against a different value or interval of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルの各要素は、ある異なる値または値の区間に対して試験されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each enumeration definition defines a brand new type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの列挙定義は、まっさらの新しい型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each example below shows a different representation of the following string, which is made up of the characters D, o, g, ‼ (DOUBLE EXCLAMATION MARK, or Unicode scalar U+203C), and the 🐶 character (DOG FACE, or Unicode scalar U+1F436):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の各例は、次の文字列の異なる具象化を示します、それは文字D、o、g、‼（DOUBLE EXCLAMATION MARK、またはユニコード・スカラーU+203C）、そして🐶文字（DOG FACEまたはユニコード・スカラーU+1F436）から成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each expression can have an optional identifier before it, separated by a colon (:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各式はそれの前に、コロン（:）で区切られる任意の識別子を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each form encodes the string in small chunks known as code units.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各方式は、文字列を、符号単位として知られている小さいかたまりで符号化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each function parameter has both an argument label and a parameter name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数パラメーターそれぞれは、引数ラベルとパラメーター名の両方を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each instance of Person has a single stored property called fullName, which is of type String.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Personの各インスタンスは、fullNameと呼ばれる１つの保存プロパティを持ちます、それは、型Stringです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each item in a capture list is a pairing of the weak or unowned keyword with a reference to a class instance (such as self) or a variable initialized with some value (such as delegate = self.delegate!).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>捕獲リストの各項目は、weakまたはunownedキーワードと、クラスインスタンスへの参照（例えばself）またはなんらかの値で初期化された変数（例えばdelegate = self.delegate!）を対にしたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each item in a protocol composition list must be either the name of protocol or a type alias of a protocol composition type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成リストの中の各項目は、プロトコルの名前かあるプロトコル合成型の型エイリアスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each item in the dictionary is returned as a (key, value) tuple when the dictionary is iterated, and you can decompose the (key, value) tuple’s members as explicitly named constants for use within the body of the for-in loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書の中の各項目は、辞書が繰り返されるとき、(key, value)タプルとして返されます、そしてあなたは(key, value)タプルの構成要素をfor-inループの本文内で使用するわかりやすい名前の定数として分解することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each item in the dictionary is returned as a (key, value) tuple, and you can decompose the tuple’s members into temporary constants or variables as part of the iteration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書の中の各項目は、(key, value)タプルとして返されます、そしてあなたはタプルの構成要素を一時的な定数または変数に分解することが、この繰り返しの一部として行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each item that you insert into the string literal is wrapped in a pair of parentheses, prefixed by a backslash:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがリテラル文字列に差し込む各項目は、一対の丸括弧に包まれて、バックスラッシュを前に置かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each kind of expression is described in detail in the sections below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各種類の式は、以下の節において詳細に記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each of the comparison operators returns a Bool value to indicate whether or not the statement is true:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの比較演算子は、Bool値を返して、その文が真かどうかを指し示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each pair of characters in a hexadecimal number uses 8 bits, so a move 16 places to the right will convert 0xCC0000 into 0x0000CC.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>16進数の中の文字の各ペアは８ビットを使うので、右への16桁の移動は0xCC0000を0x0000CCへと変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each player has a certain number of coins stored in their purse at any time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各々のプレーヤーは、特定の数のコインをいつでもかれらの財布に保管しておきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each position in the matrix is given an initial value of 0.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行列の中の各位置は、0.0の初期値を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each raw value must be unique within its enumeration declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値それぞれは、その列挙宣言の範囲内で固有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each statement in the body of a conditional compilation block is parsed even if it’s not compiled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件コンパイルブロックの本文中の各文は、たとえそれがコンパイルされなくとも、構文解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each time swapTwoValues(_:_:) is called, the type to use for T is inferred from the types of values passed to the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>swapTwoValues(_:_:)が呼ばれるたびに、Tのために使われる型は関数に渡される値の型から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each time through the while loop, diceRoll is incremented by one and is then checked to see whether it has become too large.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>毎回whileループの間、diceRollは１増やされて、それからそれが大きくなりすぎていないか調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each turn, you roll a six-sided dice and move by that number of squares, following the horizontal path indicated by the dotted arrow above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>順番になるたび、あなたは六面のさいころを転がします、そしてその数だけ正方形を移動します、上の点線の矢印で示される水平移動の経路をたどっていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each type argument must satisfy all the constraints of the generic parameter it replaces, including any additional requirements specified in a generic where clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各型引数は、それが置き換える総称体パラメータの全ての制約を、総称体where節で指定される任意の追加の要件を含めて、満たさなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each type method is explicitly scoped to the type it supports.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各型メソッドは、当然ながらそれが支える型にスコープを指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each unassigned case of type Int is implicitly assigned a raw value that is automatically incremented from the raw value of the previous case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型Intの未割り当てのケース節それぞれは、暗黙のうちに生の値を割り当てられます、それは、前のケース節の生の値から自動的に増やされたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each value is associated with a unique key, which acts as an identifier for that value within the dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各値は固有のキーと結び付けられます、そして、それはその辞書の内部でその値のために識別子の働きをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Early Exit</seg>
      </tuv>
      <tuv lang="JA">
        <seg>早期退出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Effectively, the addition and the assignment are combined into one operator that performs both tasks at the same time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実質的に、加算と代入は１つの演算子に結合され、同時に両方の作業を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Effectively, they are just two different names for the same single instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>事実上、それらは同じ一つのインスタンスに対する単なる２つの異なる名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Empty array literals are written using an empty pair of square brackets and can be used to create an empty array of a specified type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の配列リテラルは、空の角括弧の対を使って書かれて、指定された型の空の配列をつくるために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration Case Pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration case patterns appear in switch statement case labels and in the case conditions of if, while, guard, and for-in statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節パターンは、switch文のケース節ラベル（ケース節表記）において、そしてif、while、guard、およびfor-in文のケース節条件において現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration case values without associated values (as described in Enumerations) are also hashable by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連値なしでの列挙ケース節の値（列挙で記述されます）もまた、そのままでハッシュ化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration cases that store associated values can be used as functions that create instances of the enumeration with the specified associated values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連値を格納する列挙ケース節は、関数として使われることができ、それは指定された関連値を持つその列挙のインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration declarations can’t contain deinitializer or protocol declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙宣言は、デイニシャライザまたはプロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration declarations have two basic forms and are declared using the enum keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙宣言は、２つの基本の形式を持ち、キーワードenumを使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration types can adopt any number of protocols, but can’t inherit from classes, structures, or other enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙型は、任意の数のプロトコルに準拠することができます、しかしクラス、構造体、または他の列挙から継承することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations and Structures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙と構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations are often created to support a specific class or structure’s functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙は、特定のクラスまたは構造体の機能性を支えるためにたびたびつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations can also define initializers to provide an initial case value; can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙は、さらに、最初のケース節値を提供するためにイニシャライザを定義することができます；それらの本来の実装を越えてそれらの機能性を広げるために拡張されることができます；そして、標準の機能性を提供するためにプロトコルに準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations can have a recursive structure, that is, they can have cases with associated values that are instances of the enumeration type itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙は、再帰構造を持つことができます、すなわち、それは、その列挙型それ自身のインスタンスである関連値を伴うケース節を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations declared in this form are sometimes called discriminated unions in other programming languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この形式で宣言される列挙は、時として他のプログラミング言語では判別共用体と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations in Swift are first-class types in their own right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの列挙は、れっきとした第一級の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations in Swift are much more flexible, and do not have to provide a value for each case of the enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの列挙は、ずっと柔軟で、列挙のケース節の各々に値を与える必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations similar to these are known as discriminated unions, tagged unions, or variants in other programming languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これに似ている列挙は、他のプログラミング言語で判別共用体、タグ付き共用体、またはバリアントとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations that have cases of a raw-value type implicitly conform to the RawRepresentable protocol, defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「生の値」型のケース節を持つ列挙は、スウィフト標準ライブラリで定義されるRawRepresentableプロトコルに暗黙的に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations with Cases of Any Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>随意の型のケース節をもつ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations with Cases of a Raw-Value Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「生の値」型のケース節を持つ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations with Indirection</seg>
      </tuv>
      <tuv lang="JA">
        <seg>間接参照を持つ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations with raw values automatically receive a failable initializer, init?(rawValue:), that takes a parameter called rawValue of the appropriate raw-value type and selects a matching enumeration case if one is found, or triggers an initialization failure if no matching value exists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値を持つ列挙は、自動的にひとつの失敗できるイニシャライザ、init?(rawValue:)を受け取ります、それは、適切な「生の値」型のrawValueと呼ばれるパラメータを取って、適合する列挙ケース節をそれが見つかったならば選択します、または適合する値が存在しないならば初期化失敗を引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations with raw values now have a rawValue property rather than a toRaw() method and a failable initializer with a rawValue parameter rather than a fromRaw() method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値を持つ列挙は、今ではtoRaw()メソッドではなくrawValueプロパティを、そしてfromRaw()メソッドではなくrawValueパラメーターを使う失敗できるイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equal to (a == b)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同等である（a == b）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalence Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同等演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error Handling</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーの処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error handling in Swift interoperates with error handling patterns that use the NSError class in Cocoa and Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでのエラー処理は、CocoaとObjective-CでのNSErrorクラスを使うエラー処理パターンと相互運用性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error handling in Swift resembles exception handling in other languages, with the use of the try, catch and throw keywords.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおけるエラー処理は、try、catch、そしてthrowキーワードの使用とともに、他の言語での例外処理に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Escaping Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>脱出クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluating an expression returns a value, causes a side effect, or both.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある式を評価することは、ひとつの値を返す、ある副作用を引き起こす、あるいはその両方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even on 32-bit platforms, Int can store any value between -2,147,483,648 and 2,147,483,647, and is large enough for many integer ranges.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>32ビットのプラットホーム上でさえ、Intは-2,147,483,648と2,147,483,647の間のどんな値でも保存することができ、多くの整数範囲のために十分に大きいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though Rank and Suit are nested within BlackjackCard, their type can be inferred from context, and so the initialization of this instance is able to refer to the enumeration cases by their case names (.ace and .spades) alone.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえRankとSuitがBlackjackCard内部に入れ子にされるとしても、それらの型は前後関係から推論されることができます、なのでこのインスタンスの初期化は、列挙ケース節を参照することがもっぱらそれらのケース節名（.aceと.spades）のみによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though RecipeIngredient provides the init(name: String) initializer as a convenience initializer, RecipeIngredient has nonetheless provided an implementation of all of its superclass’s designated initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえRecipeIngredientが便宜イニシャライザとしてinit(name: String)イニシャライザを提供するとしても、RecipeIngredientはそれでもやはりそれのスーパークラスの指定イニシャライザの全ての実装を提供しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though hd and cinema now have the same width and height, they are two completely different instances behind the scenes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえhdとcinemaが現在同じ幅と高さを持つとしても、それらは舞台裏では２つの完全に異なるインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the text property is now a constant, it can still be set within the class’s initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえtextプロパティが今や定数であるとしても、それはクラスのイニシャライザの内部ではまだ設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the closure refers to self multiple times, it only captures one strong reference to the HTMLElement instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえクロージャが複数回selfに言及するとしても、それはそのHTMLElementインスタンスへの１つの強い参照を捕獲するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the first element of the customersInLine array is removed by the code inside the closure, the array element isn’t removed until the closure is actually called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえcustomersInLine配列の最初の要素がクロージャ内部のコードによって取り除かれるとしても、その配列要素はクロージャが実際に呼び出されるまで実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the stack and the array are of a different type, they both conform to the Container protocol, and both contain the same type of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえスタックと配列が異なる型であるとしても、それらは両方ともContainerプロトコルに準拠して、両方とも同じ型の値を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the variable protocolValue has a runtime type of SimpleClass, the compiler treats it as the given type of ExampleProtocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ変数protocolValueが実行時の型としてSimpleClassを持つとしても、コンパイラはそれを与えられた型ExampleProtocolとみなします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though there are two optional chaining operations, one after another, the result is still wrapped in a single optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ２つのオプショナル連鎖演算があったとしても、後から後から、その結果は依然としてただ１つのオプショナルの中にラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though you do not write an explicit getter and setter for a stored property, Swift still synthesizes an implicit getter and setter for you to provide access to the stored property’s backing storage.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえあなたが保存プロパティのために明確なゲッターとセッターを書かないとしても、スウィフトは保存プロパティのもつ支援外部記憶へのアクセスを提供するためにあなたのためにまだ暗黙のゲッターとセッターを総合的に扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every Person instance has a name property of type String and an optional apartment property that is initially nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆるPersonインスタンスは、型Stringのnameプロパティと初期時にはnilであるオプショナルのapartmentプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every switch statement consists of multiple possible cases, each of which begins with the case keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆるswitch文は複数の起こりうるケース節から成ります。そして、それぞれはcaseキーワードから始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every switch statement must be exhaustive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆるswitch文は、徹底的でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every class must have at least one designated initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆるクラスは、少なくとも１つの指定イニシャライザを持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every conditional compilation block begins with the #if compilation directive and ends with the #endif compilation directive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての条件コンパイルブロックは、#ifコンパイル指令で始まって、#endifコンパイル指令で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every function has a function name, which describes the task that the function performs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる関数は関数名を持ち、それはその関数が実行する作業を形容します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every function has a specific function type, made up of the parameter types and the return type of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる関数は特定の関数型を持ちます、それは、その関数のパラメータ型と戻り型から成り立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every function in Swift has a type, consisting of the function’s parameter types and return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのあらゆる関数は、その関数のパラメータ型と戻り型から成る、ある型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every instance of Swift’s Character type represents a single extended grapheme cluster.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのCharacter型の全てのインスタンスは、単一の拡張書記素クラスタ（房、群）を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every instance of a type has an implicit property called self, which is exactly equivalent to the instance itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型のすべてのインスタンスは、暗黙的にselfと呼ばれるプロパティを持ちます、それは、正確にそのインスタンスそれ自身に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every item in the shopping list starts out as “unpurchased”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>購入品目リストでのあらゆる項目は、「未購入」として始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every property needs a value assigned—either in its declaration (as with numberOfSides) or in the initializer (as with name).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆるプロパティは、代入される値を必要とします ― その宣言において（numberOfSidesでのように）またはイニシャライザにおいて（nameでのように）のどちらでも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every string is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる文字列は、符号化に依存しないUnicode文字から構成されます、そして多彩なUnicode表現においてそのような文字にアクセスするための支援を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every time a player finishes a level, that level is unlocked for all players on the device.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレーヤーがあるレベルを終了するごとに、そのレベルはその装置上の全てのプレーヤーのために鍵を外されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every time you create a new instance of a class, ARC allocates a chunk of memory to store information about that instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがクラスの新しいインスタンスをつくるたびに、ARCはメモリのある量を割り当てて、そのインスタンスに関する情報を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every time you create a new instance of that type, it has its own set of property values, separate from any other instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがその型の新しいインスタンスをつくるたびに、それは、他のあらゆるインスタンスから独立した、独自のひと組のプロパティ値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples of Closure Expressions now use the global sorted(_:_:) function rather than the global sort(_:_:) function, to reflect the new array value semantics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式の例は、現在はグローバルなsorted(_:_:)関数を、グローバルなsort(_:_:)関数のかわりに使用します、それによって新しい配列値意味論を反映します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples of good candidates for structures include:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体の良い候補者の例には、次のようなものがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except when count is 0 (meaning the array is empty), the largest valid index in an array will always be count - 1, because arrays are indexed from zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>countが0である（その配列が空であるのを意味する）場合を除き、配列はゼロからインデックスを付けられるので、配列での最も大きく有効なインデックスは常にcount - 1になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Executing the last defer statement in a given scope first means that statements inside that last defer statement can refer to resources that will be cleaned up by other defer statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある特定のスコープ中の最後のdefer文の実行が最初であることは、その最後のdefer文内の文は別のdefer文によってクリーンアップされることになるリソースを参照できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Execution Does Not Fall Through Cases Implicitly</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行は暗黙のうちにケース節を抜け落ちません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Execution doesn’t continue to the next case, so there is no need to explicitly break out of the switch at the end of each case’s code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行は次の条件部分に続かないので、各条件部分のコードの終わりで明示的にスイッチから抜け出す必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Existing bits are moved to the left or right by the requested number of places.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存のビットは、左または右へ要請された桁数だけ動かされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Existing instances of a type automatically adopt and conform to a protocol when that conformance is added to the instance’s type in an extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型の既存のインスタンスたちは、そのインスタンスの型に拡張の中で準拠が加えられるとき、そのプロトコルを自動的に採用して準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Experiment</seg>
      </tuv>
      <tuv lang="JA">
        <seg>試してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicit Member Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的メンバー式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicit Parentheses</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明確な括弧</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expression Pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expression patterns appear only in switch statement case labels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式パターンは、switch文のケース節ラベルにおいてのみ現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended Grapheme Clusters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張書記素クラスタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended grapheme clusters are a flexible way to represent many complex script characters as a single Character value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張書記素クラスタは、多くの複雑な書き方の文字を単一のCharacter値として表わす適応性に富む方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended grapheme clusters are canonically equivalent if they have the same linguistic meaning and appearance, even if they are composed from different Unicode scalars behind the scenes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張書記素クラスタが正準等価であるのは、それらが同じ言語的な意味と外観を持つ場合です、たとえそれらが舞台裏で異なるユニコードスカラーから組み立てられるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended grapheme clusters can be composed of one or more Unicode scalars.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張書記素クラスタは、１つ以上のユニコード・スカラーから構成される可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended grapheme clusters enable scalars for enclosing marks (such as COMBINING ENCLOSING CIRCLE, or U+20DD) to enclose other Unicode scalars as part of a single Character value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張書記素クラスタは、囲み記号としてのスカラー（COMBINING ENCLOSING CIRCLE、またはU+20DD）を可能にして、単一のCharacter値の一部として他のユニコード・スカラーを囲み入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extending a Generic Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体型を拡張する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extending an Existing Type to Specify an Associated Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存の型を拡張して関連型を指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extending existing types to provide initializers that accept new types (including your own type definitions) is covered in Extensions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい型（あなた独自の型定義を含む）を受け入れるイニシャライザを提供するように既存の型を拡張することは、「拡張」で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension declarations are declared using the extension keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言は、キーワードextensionから始まり、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension declarations can add protocol conformance to an existing class, structure, and enumeration type in the adopted protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言は、プロトコル準拠を既存のクラス、構造体、そして列挙型に加えることがadopted protocols 採用プロトコルにおいて可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension declarations can contain initializer declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言は、イニシャライザ宣言を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension declarations can’t add class inheritance to an existing class, and therefore you can specify only a list of protocols after the type name and colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言は、クラス継承を既存のクラスに加えることができません、従ってあなたは単にプロトコルのリストだけをtype name 型名とコロンの後に指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension declarations can’t contain deinitializer or protocol declarations, stored properties, property observers, or other extension declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言は、デイニシャライザまたはプロトコル宣言、保存プロパティ、プロパティオブザーバー、または他の拡張宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions are similar to categories in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、Objective-Cでのカテゴリーに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add computed instance properties and computed type properties to existing types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、既存の型に計算インスタンスプロパティと計算型プロパティを加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new computed properties, but they cannot add stored properties, or add property observers to existing properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は新しい計算プロパティを加えることができます、しかし、それは保存プロパティを加えることができません、またプロパティオブザーバーを既存のプロパティに加えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new convenience initializers to a class, but they cannot add new designated initializers or deinitializers to a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しい便利なイニシャライザをクラスに加えることができます、しかし、それは新しい指定イニシャライザまたはデイニシャライザをクラスに加えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new functionality to a type, but they cannot override existing functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しい機能性をある型に加えることができます、しかしそれは既存の機能性をオーバーライドすることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new initializers to existing types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しいイニシャライザを既存の型に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new instance methods and type methods to existing types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しいインスタンスメソッドと型メソッドを既存の型に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new nested types to existing classes, structures, and enumerations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しい入れ子にされた型を既存のクラス、構造体、および列挙に加えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new properties, methods, and subscripts to an existing type, and are therefore able to add any requirements that a protocol may demand.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しいプロパティ、メソッド、そして添え字を既存の型に加えることができます、したがって、あるプロトコルが要求するであろうどんな要件でも加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new subscripts to an existing type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しい添え字を既存の型に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions in Swift can:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの拡張は、以下が可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failable Initializer Requirements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザ要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failable Initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failable Initializers for Enumerations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙のための失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failable Initializers for Enumerations with Raw Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値を使う列挙のための失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fallthrough</seg>
      </tuv>
      <tuv lang="JA">
        <seg>抜け落ちる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fallthrough Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>フォールスルー文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, Residence defines an optional property called address, with a type of Address?.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最終的に、Residenceはaddressと呼ばれるオプショナルのプロパティを、Address?の型で定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, any convenience initializers in the chain have the option to customize the instance and to work with self.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後に、連鎖の中のあらゆる便宜イニシャライザは、インスタンスを好みに合わせて作り変えるために、selfを扱うために選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, it is set to a frame rate of 25.0 frames per second.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後に、それは１秒につき25.0フレームのフレームレートに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, once the subclass’s designated initializer is finished, the convenience initializer that was originally called can perform additional customization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後に、一旦サブクラスの指定イニシャライザが作業をし終えるならば、最初に呼ばれた便宜イニシャライザは追加の特注処理を実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the default case matches any other character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最終的に、defaultケース節が他の文字のすべてにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the blue component is obtained by performing a bitwise AND between the numbers 0xCC6699 and 0x0000FF, which gives an output value of 0x000099.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後に、青の構成要素は数0xCC6699と0x0000FFとの間のビット単位の論理積を実行することによって得られます、それは、0x000099の出力値を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the overall minimum and maximum values are returned as a tuple of two Int values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後に、全体で最も小さいそして最も大きい値が２つのInt値のタプルとして返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Find out whether a String value is empty by checking its Boolean isEmpty property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるString値が空かどうかを、それのブールのisEmptyプロパティを調べることで確認してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it is possible that dataSource may be nil, and so dataSource has a question mark after its name to indicate that increment(forCount:) should be called only if dataSource isn’t nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第１に、dataSourceがnilかもしれない可能性があります、なので、dataSourceはその名前の後に疑問符を持ち、dataSourceがnilでない場合にのみincrement(forCount:)が呼ばれるべきであるのを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, two classes called Person and Residence are defined:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初に、PersonとResidence（個人と邸宅）と呼ばれる２つのクラスが定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, you can add -1 to -4, simply by performing a standard binary addition of all eight bits (including the sign bit), and discarding anything that doesn’t fit in the eight bits once you’re done:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第１に、あなたは-1を-4に加えることが、単純に８つのビット全て（符号ビットを含む）の通常のバイナリの加算を実行して、あなたがそうしたならばその８ビットに収まらない何でも捨てることによって行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-Point Literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-Point Numbers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point literals can be decimal (with no prefix), or hexadecimal (with a 0x prefix).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点リテラルは、10進（接頭辞なし）、または16進（接頭辞0xつき）であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point literals can begin with leading zeros (0), but are likewise ignored and don’t affect the base or value of the literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点リテラルは、いくつかのゼロ（0）を先頭に始まることができます、しかし同様に無視されて、リテラルの基数または値に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point to integer conversion must also be made explicit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点を整数に変換することは、また、明示的に行われる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point types can represent a much wider range of values than integer types, and can store numbers that are much larger or smaller than can be stored in an Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点型は、整数型よりずっと広い値の幅を表すことができ、そしてIntに保存できるよりずっと大きいまたは小さい数を保存することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point values are always truncated when used to initialize a new integer value in this way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この方法で新しい整数値を初期化するとき、浮動小数点値は常に切り詰められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a complete list of Swift operator precedences and associativity rules, see Expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの演算子優先順位と結合性規則の完全な一覧のために、式を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a complete list of operators and precedence groups provided by the Swift standard library, see Swift Standard Library Operators Reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリによって提供される演算子と優先順位グループの完全なリストとして、Swift標準ライブラリ演算子リファレンスを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a complete list of the compound assignment operators provided by the Swift standard library, see Swift Standard Library Operators Reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリで提供される複合代入演算子の完全な一覧は、スウィフト標準ライブラリ演算子リファレンスを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a complete list of the operator precedence groups and associativity settings, for the operators provided by the Swift standard library, see Swift Standard Library Operators Reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子優先順位グループと結合性設定の完全なリストとして、Swift標準ライブラリによって定義される演算子については、Swift標準ライブラリ演算子リファレンスを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a description of the Snakes and Ladders gameplay, see Break section of the Control Flow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ヘビとはしごのゲームプレイの解説として、制御の流れの中断するの節を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a detailed discussion of the Swift standard library Array type, see Arrays.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリArray型の詳細な議論のために、配列を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a detailed discussion of the Swift standard library Dictionary type, see Dictionaries.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリDictionary型の詳細な議論として、辞書を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a detailed discussion of the behavior of in-out parameters and associated compiler optimizations, see In-Out Parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータの挙動と関連するコンパイラ最適化の詳細な議論として、in-outパラメータを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a detailed discussion of the behavior of in-out parameters, see In-Out Parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータの振る舞いの詳細な議論のために、in-outパラメータを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a dictionary that stores String values, for example, the method returns a value of type String?, or “optional String”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、String値を保存する辞書に対しては、このメソッドは型String?、すなわち「オプショナルのString」の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a discussion and several examples of classes that include various kinds of declarations, see Classes and Structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>議論および、いろいろな種類の宣言を含むクラスのいくつかの例のために、クラスと構造体を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a discussion and several examples of extensions that include various kinds of declarations, see Extensions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>議論といろいろな種類の宣言を含む拡張のいくつかの例のために、拡張を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a discussion and several examples of structures that include various kinds of declarations, see Classes and Structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>議論および、いろいろな種類の宣言を含む構造体のいくつかの例のために、クラスと構造体を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a discussion of nested functions, see Nested Functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた関数の議論のために、入れ子にされた関数を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a list of characters that can be used to define custom operators, see Operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの演算子を定義するために使用されることができる文字のリストとして、演算子を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a paragraph element, the closure would return "&lt;p&gt;some text&lt;/p&gt;" or "&lt;p /&gt;", depending on whether the text property equals "some text" or nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>段落要素のために、このクロージャは、textプロパティが"some text"またはnilに等しいかどうかに従って、"&lt;p&gt;some text&lt;/p&gt;"または"&lt;p /&gt;"を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a property marked with the NSManaged attribute, Core Data also provides the storage at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NSManaged属性で印されるプロパティに対して、Coreデータはまたストレージを実行時に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a type that is defined as public, the default initializer is considered internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>publicとして定義される型のために、その省略時のイニシャライザは内部と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an alternative way to write this example without defining the init() and init(origin:size:) initializers yourself, see Extensions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>init()とinit(origin:size:)イニシャライザをあなた自身で定義することなくこの例を書く代わりの方法のために、拡張を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example and more information about the unowned modifier, see Unowned References.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>unowned修飾子についての例とさらなる情報として、非所有参照を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example and more information about the weak modifier, see Weak References.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>weak修飾子についての例と更なる情報のために、弱い参照を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of an autoclosure function type parameter, see Autoclosures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動クロージャ関数型パラメータの例として、自動クロージャを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of an enumeration definition that uses a type inheritance clause to specify the type of its raw values, see Raw Values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その生の値の型を指定するために型継承節を使う列挙定義の例のために、生の値を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use a fallthrough statement in a switch statement, see Control Transfer Statements in Control Flow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>fallthrough文をswitch文において使う方法の例のために、制御移動文を章制御の流れで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use a throw statement, see Propagating Errors Using Throwing Functions in Error Handling.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>throw文を使う方法の例のために、スロー関数を使ってエラーを伝えるをエラー処理の章で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use a deinitializer in a class declaration, see Deinitialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言においてデイニシャライザを使う方法の例のために、デイニシャライズを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use protocol inheritance, see Protocol Inheritance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル継承を使う方法の例のために、プロトコル継承を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use the autoclosure attribute, see Autoclosures and Function Type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>autoclosure属性を使用する方法の例として、自動クロージャと関数型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use the final attribute, see Preventing Overrides.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>final属性を使う方法の例として、オーバーライドを防ぐを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use the lazy modifier, see Lazy Stored Properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>lazy修飾子を使う方法の例として、遅延保存プロパティを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use the escaping attribute, see Escaping Closures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>escaping属性を使う方法の例として、脱出クロージャを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example that demonstrates both of these features, see Functions with Multiple Return Values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの特徴の両方を示す例のために、複数の戻り値をもつ関数を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example that uses a switch statement to match enumeration cases containing associated values, see Associated Values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連値を含んでいる列挙ケース節にマッチするためにswitch文を使う例のために、関連値を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example that uses a switch statement to match values with is and as patterns, see Type Casting for Any and AnyObject.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文を使用して、さまざまに値をisやasパターンとマッチする例のために、AnyおよびAnyObjectに対する型キャストを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example that uses a variadic parameter, see Variadic Parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長パラメータを使う例のために、可変長パラメータを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example that uses a variadic parameter, see Variadic Parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長パラメータを使う例のために、可変長パラメータを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example that uses the ternary conditional operator, see Ternary Conditional Operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>三項条件演算子を使用する例のために、三項条件演算子を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an extended discussion and several examples of class inheritance, see Inheritance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス継承の広範囲にわたる議論といくつかの例のために、継承を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an overview of generics in Swift, see Generics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでの総称体の概要のために、総称体を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For both signed and unsigned integers, overflow in the positive direction wraps around from the maximum valid integer value back to the minimum, and overflow in the negative direction wraps around from the minimum value to the maximum.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号つきおよび符号なし整数の両方に対して、正の方向でのオーバフローは最大限の有効な整数値から逆に最小限へとぐるっと送り込まれ、負の方向でのオーバフローは最小限の値から最大限へとぐるっと送り込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For brevity, multiple values are covered in a single switch case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>簡潔にするため、複数の値が１つのswitchケース節で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For characters in strings, “greater than” means “appears later in the alphabet than”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列の中の文字のために、「より大きい」は「アルファベットにおいてより後に現れる」ことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For class instances, a constant property can be modified during initialization only by the class that introduces it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスインスタンスのために、定数プロパティは、それを導入するクラスによってのみ初期化の間に修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For class instances, the initializer that’s called must be marked with the required keyword or the entire class marked with the final keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスインスタンスに対しては、呼び出されるイニシャライザがrequiredキーワードで印されるか、クラス全体がfinalキーワードで印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For computed type properties for class types, you can use the class keyword instead to allow subclasses to override the superclass’s implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス型のための計算型プロパティに対しては、あなたは代わりにclassキーワードを使って、サブクラスにそのスーパークラスの実装のオーバーライドを許可することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For convenience and because the distinction isn’t that important in Swift, the term declaration covers both declarations and definitions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便利さとその区別がスウィフトにおいてそんなに重要でないことから、用語宣言は、宣言と定義を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For decimal numbers with an exponent of exp, the base number is multiplied by 10exp:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>expの指数を持つある10進数に対して、その基数は10expを掛けられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For details, see Break in a Switch Statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細はスイッチ文の中断を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each entry in the capture list, a constant is initialized to the value of the constant or variable that has the same name in the surrounding scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャプチャリストのそれぞれの登録項目に対して、その定数や変数の値へとひとつの定数が初期化されます、それは囲んでいるスコープの中で同じ名前を待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each integer in the array, the function considers the kind computed property for that integer, and prints an appropriate description.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その配列の各整数に対して、この関数はその整数に対するkind計算プロパティを考慮して、適切な説明を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each item in the array, the enumerated() method returns a tuple composed of an integer and the item.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この配列の各項目に対して、enumerated()メソッドは、整数とその項目から成るひとつのタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each item, the function checks whether the item from someContainer is not equal to the corresponding item in anotherContainer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各項目のために、関数はsomeContainerからの項目がanotherContainerでの対応する項目と同等でないかどうか確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example in the code below, a is included in the capture list but b is not, which gives them different behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば以下のコードにおいて、aはキャプチャリストに含まれますがbはそうではありません、そのことはそれらに異なる挙動を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, Int is a type identifier that directly refers to the named type Int, and the type identifier Dictionary&lt;String, Int&gt; directly refers to the named type Dictionary&lt;String, Int&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、Intは、直接に名前付きの型Intに言及する型識別子です、そして型識別子Dictionary&lt;String, Int&gt;は、直接に名前付きの型Dictionary&lt;String, Int&gt;に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, LATIN SMALL LETTER E WITH ACUTE (U+00E9) is canonically equivalent to LATIN SMALL LETTER E (U+0065) followed by COMBINING ACUTE ACCENT (U+0301).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、LATIN SMALL LETTER E WITH ACUTE（U+00E9）は、LATIN SMALL LETTER E（U+0065）にCOMBINING ACUTE ACCENT（U+0301）を続けたものと正準等価です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, .+. is treated as a single operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、.+.は単一の演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;S1: Sequence, S2: Sequence&gt; where S1.Iterator.Element == S2.Iterator.Element expresses the constraints that S1 and S2 conform to the Sequence protocol and that the elements of both sequences must be of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;S1: Sequence, S2: Sequence&gt; where S1.Iterator.Element == S2.Iterator.Elementが表す制約は、S1とS2がSequenceプロトコルに準拠すること、そして両方のシーケンスの要素が同じ型でなければならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, SomeClass.self returns SomeClass itself, not an instance of SomeClass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、SomeClass.selfは、SomeClass自身を返します、SomeClassのインスタンスではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, class is not a valid identifier, but `class` is valid.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、classは有効な識別子ではありません、しかし、`class`は有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, x.self evaluates to x.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、x.selfはxに評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, (Int) is equivalent to Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、(Int)はIntに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, +.+ is treated as the + operator followed by the .+ operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、+.+は、+演算子に.+演算子が続くとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, 0xFp2 represents 15 x 22, which evaluates to 60.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、0xFp2は15 × 22を表します、それは60に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, 1.25e2 represents 1.25 x 102, which evaluates to 125.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、1.25e2は1.25 × 102を表します、それは125.0に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;S: Sequence&gt; where S.Iterator.Element: Equatable specifies that S conforms to the Sequence protocol and that the associated type S.Iterator.Element conforms to the Equatable protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;S: Sequence&gt; where S.Iterator.Element: Equatableが指定するのは、SがSequenceプロトコルに準拠すること、そして関連型S.Iterator.ElementがEquatableプロトコルに準拠することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, Int8 conforms to the ExpressibleByIntegerLiteral protocol, and therefore it can be used in the type annotation for the integer literal 42 in the declaration let x: Int8 = 42.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、Int8はExpressibleByIntegerLiteralプロトコルに準拠します、したがってそれは宣言let x: Int8 = 42の中の整数リテラル42のための型注釈において使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, Hangul syllables from the Korean alphabet can be represented as either a precomposed or decomposed sequence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、コリアン・アルファベットのハングル音節は、最初から組み立てられるか、または分解されて並べたもののどちらでも表わすことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, Swift’s Dictionary type implements a subscript to set and retrieve the values stored in a Dictionary instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、スウィフトのDictionary型は、Dictionaryインスタンスに保存される値を設定したり取り出すために添え字を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, Swift’s Dictionary type places a limitation on the types that can be used as keys for a dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、スウィフトのDictionary型は、辞書のキーとして使われることができる型に制限を置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, Swift’s Array and Dictionary types are both generic collections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、スウィフトのArrayとDictionary型は、両方とも総称体コレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a case named venus in a Swift Planet enumeration is exposed to Objective-C code as a case named PlanetVenus.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、スウィフトのPlanet列挙の中のvenusと名付けられるケース節は、Objective-CコードにPlanetVenusと名付けられるケース節として暴露されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a method of type (Int) -&gt; String becomes ((Int) -&gt; String)?.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、型(Int) -&gt; Stringのメソッドは((Int) -&gt; String)?になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a private type alias can alias a private, file-private, internal, public, or open type, but a public type alias cannot alias an internal, file-private, or private type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、非公開の型エイリアスは、非公開、ファイル外非公開、内部、公開、または開放型のエイリアス（別名）となることができます、しかし公開型エイリアスは、内部、ファイル外非公開、または非公開型をエイリアスできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a variadic parameter with a name of numbers and a type of Double... is made available within the function’s body as a constant array called numbers of type [Double].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、numbersの名前とDouble...の型を持つある可変長パラメータは、関数の本文内で型[Double]のnumbersと呼ばれるある定数配列として利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, all the following string literals have the same value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下の全ての文字列リテラルは、同じ値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, because SomeClass.self evaluates to the SomeClass type itself, you can pass it to a function or method that accepts a type-level argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、SomeClass.selfはSomeClass型それ自体に評価されるので、あなたはそれを型レベルの引数を受け入れる関数またはメソッドへ渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, both Int and String can be compared, which means tuples of the type (Int, String) can be compared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、IntとStringは両方とも比較されることができます、それは型(Int, String)のタプルが比較されることができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider the case of requesting the sunrise and sunset times from a server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、日の出と日没の時間をあるサーバーに要請する場合を考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here is an enumeration that stores simple arithmetic expressions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここに単純な算術式を格納する列挙があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here’s a function that evaluates an arithmetic expression:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここに算術式の数値を求める関数があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here’s how you might represent the error conditions of operating a vending machine inside a game:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここにあなたが表すかもしれないあるゲーム内の自動販売機操作のエラー状況がどのようなものかがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if a public type conforms to an internal protocol, the type’s implementation of each protocol requirement must be at least “internal”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ある公開型が内部プロトコルに準拠するならば、その型の持つ各プロトコル要件の実装は少なくとも「内部」でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you assign a literal value of 42 to a new constant without saying what type it is, Swift infers that you want the constant to be an Int, because you have initialized it with a number that looks like an integer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたがそれがどんな型であるかについて言うことなく、新しい定数にリテラル値42を代入するならば、スウィフトは、あなたがその定数にIntであって欲しいのだと推測します、なぜならあなたがそれを整数のように見える数で初期化したからです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you compose a tuple from two different types, one with internal access and one with private access, the access level for that compound tuple type will be private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたが２つの異なる型、内部アクセスを持つものと非公開アクセスを持つものからタプルを組み立てるならば、その複合のタプル型のためのアクセス水準は非公開になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you create a custom class to open a file and write some data to it, you might need to close the file before the class instance is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたがファイルを開いてそれに何かのデータを書くあつらえのクラスを作成するならば、クラスインスタンスが割り当て解除される前に、あなたはファイルを閉じる必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you define a file-private class, that class can only be used as the type of a property, or as a function parameter or return type, in the source file in which the file-private class is defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたがあるファイル外非公開のクラスを定義するならば、そのクラスは、プロパティの型として、または関数パラメータや戻り型として、そのファイル外非公開クラスが定義されるソースファイルの中で使われることだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you initialize a new string with the four-character word cafe, and then append a COMBINING ACUTE ACCENT (U+0301) to the end of the string, the resulting string will still have a character count of 4, with a fourth character of é, not e:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたがある新しい文字列を４文字の単語cafeで初期化して、それからCOMBINING ACUTE ACCENT（U+0301）をその文字列の終わりに加えたならば、結果の文字列は依然として文字数4で、eではなく、éの４番目の文字を持ちます：&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if your app uses a custom subclass of UIApplication as its principal class, call the UIApplicationMain(_:_:_:) function instead of using this attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたのアプリがそれの主役クラス（プリンシパルクラス）としてUIApplicationのあつらえのサブクラスを使うならば、UIApplicationMainnMain(_:_:_:)関数をこの属性を使用する代わりに呼んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the code below, the closure passed to someFunctionWithEscapingClosure(_:) is an escaping closure, which means it needs to refer to self explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードにおいて、someFunctionWithEscapingClosure(_:)に渡されるクロージャは脱出クロージャです、それは、それがselfを明示的に参照する必要があるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the declaration let x: Int8 = 42, Swift uses the explicit type annotation (: Int8) to infer that the type of the integer literal 42 is Int8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、宣言let x: Int8 = 42において、スウィフトは明示的な型注釈（: Int8）を使って、整数リテラル42の型はInt8であると推論します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the declaration let str = "Hello, world", the default inferred type of the string literal "Hello, world" is String.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、宣言let str = "Hello, world"において、文字列リテラル"Hello, world"の省略時の推論される型はStringです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the following assignment 10 is assigned to x and 20 is ignored:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下の代入において、10はxに代入されて20は無視されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the following code x and y have the same value and behavior:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードにおいてxとyは、同じ値と挙動を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the following constant declaration, someValue is an identifier pattern that matches the value 42 of type Int:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下の定数宣言において、someValueは、型Intの値42にマッチする識別子パターンです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, instances of a user-defined class named MyClass have the type MyClass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、MyClassという名前をつけられるユーザー定義のクラスのインスタンスは、型MyClassを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, instead of writing var x: Int = 0, you can write var x = 0, omitting the type completely—the compiler correctly infers that x names a value of type Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、var x: Int = 0を書く代わりに、あなたは型を完全に省略してvar x = 0と書くことができます ― コンパイラは、xが型Intの値に名をつけると正しく推測します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, operator precedence explains why the following expression equals 17.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、演算子優先順位は、なぜ以下の式が17に等しいのかを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, specifying a protocol composition type ProtocolA &amp; ProtocolB &amp; ProtocolC is effectively the same as defining a new protocol ProtocolD that inherits from ProtocolA, ProtocolB, and ProtocolC, but without having to introduce a new name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、プロトコル合成型ProtocolA &amp; ProtocolB &amp; ProtocolCを指定することは、新しい名前を導入する必要がないことを除き、実質的にProtocolA、ProtocolB、そしてProtocolCから継承する新しいプロトコルProtocolDを定義するのと同じことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, suppose an inventory tracking system needs to track products by two different types of barcode.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ある在庫追跡システムが、２つの異なる型のバーコードによって製品を追跡する必要があると思ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the Int16 integer type can hold any signed integer between -32768 and 32767.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、Int16整数型は、-32768と32767の間のどんな符号つき整数でも持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the PrettyTextRepresentable protocol, which inherits the TextRepresentable protocol can provide a default implementation of its required prettyTextualDescription property to simply return the result of accessing the textualDescription property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、TextRepresentableプロトコルを継承するprettyTextualDescriptionプロパティは、それの必須プロパティprettyTextualDescriptionの省略時の実装を提供して、単にtextualDescriptionプロパティの結果を返すようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the RandomNumberGenerator protocol can be extended to provide a randomBool() method, which uses the result of the required random() method to return a random Bool value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、RandomNumberGeneratorプロトコルは拡張されてrandomBool()メソッドを提供することができます、それは必須メソッドのrandom()を利用してランダムなBool値を返すものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the UntitledDocument subclass below is always named "[Untitled]", and it uses the failable init(name:) initializer from its superclass during initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、下のUntitledDocumentサブクラスは、常に"[Untitled]"と名前をつけられます、そしてそれは失敗できるinit(name:)イニシャライザをそれのスーパークラスから初期化の間に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the asHTML property could be set to a closure that defaults to some text if the text property is nil, in order to prevent the representation from returning an empty HTML tag:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、asHTMLプロパティは、あるクロージャに設定されることができます、それはtextプロパティがnilならば特に何もしなくともいくらかのテキストになり、その表現が空のHTMLタグを返すことを予防する手段となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the &lt; operator has an associativity of none, which means 1 &lt; 2 &lt; 3 is not a valid expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;演算子は、noneの関係性を持ちます、それは1 &lt; 2 &lt; 3が有効な式でないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the assert(condition:message:file:line:) function takes an autoclosure for its condition and message parameters; its condition parameter is evaluated only in debug builds and its message parameter is evaluated only if condition is false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、assert(condition:message:file:line:)関数は自動クロージャをそれのconditionとmessageパラメータとして取ります；それのconditionパラメータはデバッグビルドにおいてのみ評価されます、そしてそれのmessageパラメータはconditionがfalseである場合にのみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the buyFavoriteSnack(person:vendingMachine:) in the example below is also a throwing function, and any errors that the vend(itemNamed:) method throws will propagate up to the point where the buyFavoriteSnack(person:vendingMachine:) function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、下の例のbuyFavoriteSnack(person:vendingMachine:)もまたスロー関数です、そしてvend(itemNamed:)メソッドがスローするあらゆるエラーは、buyFavoriteSnack(person:vendingMachine:)関数が呼び出される地点へとさかのぼり伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the addition (+) and subtraction (-) operators belong to the AdditionPrecedence group, and the multiplication (*) and division (/) operators belong to the MultiplicationPrecedence group.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、加算（+）および減算（-）演算子は、AdditionPrecedenceグルーブに所属し、そして乗算（*）および減算（/）演算子はMultiplicationPrecedenceグルーブに属します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the addition assignment operator (+=) combines addition and assignment into a single operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、加算代入演算子（+=）は、加算と代入を一回の操作に結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the addition operator (+) adds two numbers, as in let i = 1 + 2, and the logical AND operator (&amp;&amp;) combines two Boolean values, as in if enteredDoorCode &amp;&amp; passedRetinaScan.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、加算演算子（+）は、let i = 1 + 2のように、２つの数を加えてひとつにします、そして論理積演算子（&amp;&amp;）は、if enteredDoorCode &amp;&amp; passedRetinaScanのように、２つのブール値を組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the class below ensures that the side length of its triangle is always the same as the side length of its square.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、下のクラスは、その三角形の横の長さが常にその正方形の横の長さと同じものであることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the expression 2 + 3 * 5 is initially understood as a flat list of five items, 2, +, 3, *, and 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、式2 + 3 * 5は、最初に５つの項目、2、+、3、*、そして5の平坦なリストとして理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the expression (5 + 4) * 2 has a number on the right hand side of the multiplication and another expression on the left hand side of the multiplication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、式(5 + 4) * 2は、１つの数を掛け算の右手側にそして別の式を掛け算の左手側に持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のものはどれも等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code handles all three cases of the VendingMachineError enumeration, but all other errors have to be handled by its surrounding scope:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードはVendingMachineError列挙のケース節の３つすべてを取り扱います、しかし他のエラーすべてはそれの取り囲んでいるスコープで処理されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code isn’t valid because the element 0 in the tuple pattern (x, 0) is an expression pattern:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードは有効ではありません、タプルパターン(x, 0)の中の要素0が式パターンであるためです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code iterates through the closed range 1...3, ignoring the current value of the range on each iteration of the loop:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、完結範囲1...3のすべてに繰り返す以下のコードは、ループの各繰り返しにおいて範囲の現在の値を無視しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code throws an error to indicate that five additional coins are needed by the vending machine:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードはあるエラーをスローして、５つの追加のコインが自動販売機に必要とされることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code uses a loadImage(atPath:) function, which loads the image resource at a given path or throws an error if the image can’t be loaded.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードはloadImage(atPath:)関数を使います、それは画像リソースを与えられたパスでロードします、または画像がロードできないならばエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code uses several approaches to fetch data, or returns nil if all of the approaches fail.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードはいくつかの取り組みを使ってデータを取ってきます、またはすべての取り組みが失敗するならばnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following is invalid because the catch clause would handle the error thrown by alwaysThrows().</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のものは無効です、なぜならcatch節がalwaysThrows()によってスローされるエラーを取り扱おうとするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following listing shows chained method calls split over several lines:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコード出力は、連結されたメソッド呼び出しがいくつかの行に分けられるのを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following protocol can be adopted only by class types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のプロトコルはクラス型によってのみ採用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the function type (Int) -&gt; (Int) -&gt; Int is understood as (Int) -&gt; ((Int) -&gt; Int)—that is, a function that takes an Int and returns another function that takes and returns an Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、関数型(Int) -&gt; (Int) -&gt; Intは、(Int) -&gt; ((Int) -&gt; Int)として理解されます ― すなわち、ひとつのIntを取って、ひとつのIntを取りそして返す別の関数を返す関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the initializer for the PurchasedSnack structure in the listing below calls a throwing function as part of the initialization process, and it handles any errors that it encounters by propagating them to its caller.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコード出力のPurchasedSnack構造体のためのイニシャライザは、スロー関数を初期化処理の一部として呼び出します、そしてそれは、それが遭遇するどんなエラーもそれの呼び出し側にそれらを伝達することによって取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the metatype of the class type SomeClass is SomeClass.Type and the metatype of the protocol SomeProtocol is SomeProtocol.Protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、クラス型SomeClassのメタタイプはSomeClass.Typeです、そして、プロトコルSomeProtocolのメタタイプはSomeProtocol.Protocolです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the structure of a tuple (1, 2) is a comma-separated list of two elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、タプル(1, 2)の構造は、コンマで区切られた２つの要素のリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the subtraction operator (-) is left-associative, so the expression 4 - 5 - 6 is grouped as (4 - 5) - 6 and evaluates to -7.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、減算演算子（-）は左結合です、それで式4 - 5 - 6は(4 - 5) - 6のようにグループにされて、-7に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the tuple pattern (x, y): (Int, Int) in the constant declaration let (x, y): (Int, Int) = (1, 2) matches only tuple types in which both elements are of type Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、定数宣言let (x, y): (Int, Int) = (1, 2)におけるタプルパターン(x, y): (Int, Int)は、両方の要素が型Intであるタプル型だけにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the type identifier in the following code references the named type MyType that is declared in the ExampleModule module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードの型識別子は、ExampleModuleモジュールで宣言される名前付きの型MyTypeを参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the values of textA and textB in the example below are identical—no runtime concatenation is performed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、以下の例のtextAとtextBの値は同一です ― 実行時連結は行われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, there are two things named x in the code below, a variable in the outer scope and a constant in the inner scope, but they both refer to the same object because of reference semantics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、xと名前をつけられる２つのものが以下のコードにはあります、外側のスコープの中の変数と内側のスコープの中の定数、しかしそれらは両方とも同じオブジェクトを参照します、なぜなら参照意味論だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this is useful when the name of a declaration is changed between releases of a framework or library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、これは宣言の名前がフレームワークまたはライブラリのリリースの間で変更されたときに役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this protocol, called TextRepresentable, can be implemented by any type that has a way to be represented as text.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、このプロトコル、TextRepresentableと呼ばれるものは、テキストとして表わされる方法を持つどんな型によってでも実装されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to create a new stack of strings, you write Stack&lt;String&gt;():</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、新しく文字列のスタックを作成するために、あなたはStack&lt;String&gt;()を書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when a computed property or a property with observers is passed as an in-out parameter, its getter is called as part of the function call and its setter is called as part of the function return.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、計算プロパティまたはオブザーバを持つプロパティがin-outパラメータとして渡される時、それのゲッターは関数呼び出しの一部として呼び出され、それのセッターは関数の戻りの一部として呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you access elements in an Array instance as someArray[index] and elements in a Dictionary instance as someDictionary[key].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはあるArrayインスタンスの中の要素にsomeArray[index]として、そしてあるDictionaryインスタンスの中の要素にsomeDictionary[key]のようにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can create a three-dimensional array of integers using three sets of square brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたは３つ固めた角括弧を使って整数の三次元配列をつくることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can decompose the elements of a tuple and bind the value of each element to a corresponding identifier pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはタプルの要素を分解して、各要素の値を対応する識別子パターンへと縛り付けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can define a constant or variable to be of a function type and assign an appropriate function to that variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはある関数型となる定数または変数を定義して、適切な関数をその変数に代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can define a public type that can be used in other modules, but whose conformance to an internal protocol can only be used within the internal protocol’s defining module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、あなたは、別のモジュール内で使われることができる公開の型を定義することができます、しかし内部プロトコルに準拠するものは、ただその内部プロトコルの定義するモジュール内で使われることができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can refine the behavior of that existing implementation, or store a modified value in an existing inherited variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはその既存の実施の挙動を洗練させたり、既存の継承された変数に修正された値を保存することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can replace the type parameter Element in Array&lt;Element&gt; with a specialized version of an array, Array&lt;Int&gt;, to form an array whose elements are themselves arrays of integers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはArray&lt;Element&gt;における型パラメータElementを配列の特殊化版、Array&lt;Int&gt;で置き換えて、要素それ自身が整数の配列である配列を作り出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can rewrite the above example to compare the point expression with a string representations of points.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたは上記の例を書き直して、point式をpoint（座標）の文字列表現と比較するようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can use a defer statement to ensure that file descriptors are closed and manually allocated memory is freed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはdefer文を使ってファイル記述子が閉じられて手動割り当てメモリが解放されることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you cannot write let b = a += 2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはlet b = a += 2を書くことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you use declarations to introduce functions and methods, variables and constants, and to define new, named enumeration, structure, class, and protocol types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはいろいろな宣言を使って、関数やメソッド、変数や定数を導入したり、そして新しく名前付きの、列挙、構造体、クラス、そしてプロトコル型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For examples of conforming types that implement the method requirements of a protocol, see Method Requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルのメソッド要件を満たすものである準拠している型の例のために、メソッド要件を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For examples of conforming types that implement the property requirements of a protocol, see Property Requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルのプロパティ要件を実装するものである、準拠している型の例のために、プロパティ要件を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For examples of how to use a break statement, see Break and Labeled Statements in Control Flow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>break文を使う方法の例のために、ブレーク文とラベルをつけられた文を章制御の流れで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For examples of how to use a continue statement, see Continue and Labeled Statements in Control Flow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>continue文を使う方法の例のために、続けるとラベルをつけられた文を章制御の流れで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For examples of how to use these various types of values in switch statements, see Switch in Control Flow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのいろいろな型の値をswitch文で使う方法の例のために、スイッチを制御の流れで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For hexadecimal numbers with an exponent of exp, the base number is multiplied by 2exp:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>expの指数を持つある16進数に対して、その基数は２expを掛けられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about key-value coding and key-value observing, see Key-Value Coding Programming Guide and Key-Value Observing Programming Guide.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キー値コーディングとキー値監視についての情報として、キー値コーディングプログラミングガイド（日本語文書）とキー値監視プログラミングガイド（日本語文書）を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about parameters with default values, see Default Parameter Values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の値を持つパラメータについての情報として、省略時のパラメータ値を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about passing a closure as an argument to a function, see Function Call Expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャを引数として関数に渡すことに関する情報については、関数呼び出し式を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about reference types, see Structures and Enumerations Are Value Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>参照型に関して詳しくは、構造体と列挙は値型ですを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about subscript declarations, see Protocol Subscript Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言に関して詳しくは、プロトコル添え字宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about the behavior of these operators, see Basic Operators and Advanced Operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの演算子の挙動に関して詳しくは、基本の演算子と先進の演算子を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about the operators provided by the Swift standard library, see Swift Standard Library Operators Reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリによって提供される演算子についての情報のために、スウィフト標準ライブラリ演算子リファレンスを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about the operators provided by the Swift standard library, see Swift Standard Library Operators Reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリによって提供される演算子についての情報のために、スウィフト標準ライブラリ演算子リファレンスを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about using special characters in string literals, see Special Characters in String Literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラル内で特殊文字を使用することについての情報として、文字列リテラル内の特別な文字を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about value types, see Structures and Enumerations Are Value Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型に関して詳しくは、構造体と列挙は値型ですを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information on optional chaining, see Optional Chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖に関する情報のために、オプショナル連鎖を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information on using playground literals in Xcode, see Xcode Help &gt; Use playgrounds &gt; Add a literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Xcodeにおけるプレイグラウンドリテラルの使用に関するさらなる情報として、Xcode Help &gt; Use playgrounds &gt; Add a literal を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance methods on value types (that is, structures and enumerations) you place the mutating keyword before a method’s func keyword to indicate that the method is allowed to modify the instance it belongs to and any properties of that instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型（すなわち、構造体と列挙）のインスタンスメソッドのために、あなたはmutatingキーワードをメソッドのfuncキーワードの前に置いて、メソッドがそれが属しているインスタンスおよびそのインスタンスのあらゆるプロパティを修正するのを許可されることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, a control expression matches the case in the example below only if it is a tuple that contains two elements of the same value, such as (1, 1).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ある制御式は、それが同じ値の２つの要素を持つタプル、例えば(1, 1)のようなものである場合にのみ、以下の例におけるケース節にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if you write let dict: Dictionary = ["A": 1], the compiler infers that dict has the type Dictionary&lt;String, Int&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、あなたがlet dict: Dictionary = ["A": 1]を書くならば、コンパイラはdictが型Dictionary&lt;String, Int&gt;を持つと推測します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, in addition to the values of scalar types, such as integers and characters, your code can branch on the values of any type, including floating-point numbers, strings, tuples, instances of custom classes, and optionals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、整数と文字のようなスカラー型の値に加えて、あなたのコードは、浮動小数点数、文字列、タプル、あつらえのクラスのインスタンス、そしてオプショナルを含むあらゆる型の値に関して分岐することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, in the example below, the use of Point in the type annotation refers to the tuple type (Int, Int).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、下記の例で、型注釈においてPointを使うことは、タプル型(Int, Int)に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, in the generic function below, the generic parameter T: Comparable indicates that any type argument substituted for the type parameter T must conform to the Comparable protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、下記の総称体関数において、総称体パラメータT: Comparableは、型パラメータTと置き換えられる任意の型の引数はComparableプロトコルに準拠しなければならないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the pattern (x, y) matches the tuple (1, 2) and any other two-element tuple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、パターン(x, y)はタプル(1, 2)および他のどんな２要素タプルにでもマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the tuple type (Int, (Int, Int)) contains two elements: The first is the named type Int, and the second is another compound type (Int, Int).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、タプル型(Int, (Int, Int))は、２つの要素を含みます：第一は名前付きの型Intです、そして第二は別の複合の型(Int, Int)です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the variadic parameter Int... is treated as [Int].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、可変長パラメータInt...は[Int]とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the variadic parameter Int... is treated as [Int].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、可変長パラメータInt...は[Int]とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, when integers are used for raw values, the implicit value for each case is one more than the previous case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、整数が生の値のために使われるとき、各ケース節に対する暗黙の値は、その前のケース節よりもうひとつ多くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, you can assign values of implicitly unwrapped optionals to variables, constants, and properties of optionals, and vice versa.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、あなたは暗黙的にアンラップされるオプショナルの値を、オプショナルの変数、定数、そしてプロパティに代入することができます、その逆もまたできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, you can constrain the associated types of type parameters to conform to protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、あなたは型パラメータの関連型をいくらかのプロトコルに準拠するように制約することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, you can define an extension to the Collection protocol that applies to any collection whose elements conform to the TextRepresentable protocol from the example above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはある拡張をCollectionプロトコルに対して定義することができます、それはその要素が上の例のTextRepresentableプロトコルに準拠するあらゆるコレクションに適用するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about extensions, see Extensions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張についてのより多くのために、拡張を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about operator method, see Operator Methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子メソッドについてさらに、演算子メソッドを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about the for-in loop, see For-In Loops.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更にfor-inループについて、for-inループを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more details, see Protocol Extensions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、プロトコル拡張を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more discussion and examples of in-out parameters, see In-Out Parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータの議論と例のために、in-outパラメータを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about Dictionary subscripting, see Accessing and Modifying a Dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Dictionaryで添え字を使うことの詳細については、辞書へのアクセスと修正を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about capture lists, see Capture Lists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャプチャリストについての更なる情報として、キャプチャリストを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about compound cases, see Compound Cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合ケース節についてのさらなる情報として、複合ケース節を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about conforming to protocols, see Protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルに準拠することについての更なる情報は、プロトコルを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about constants and for guidance about when to use them, see Constants and Variables and Stored Properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数の詳細について、そしていつそれらを使うべきかの手引きとして、定数と変数および保存プロパティを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about deinitializers, see Deinitialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザの詳細については、デイニシャライザを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about generic where clauses and to see an example of one in a generic function declaration, see Generic Where Clauses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体where節のさらなる情報のために、そして総称体関数定義におけるそれの一例を見るために、総称体where節を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about how to use the optional modifier and for guidance about how to access optional protocol members—for example, when you’re not sure whether a conforming type implements them—see Optional Protocol Requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>optional修飾子を使う方法についての更なる情報のために、そしてオプショナルプロトコルメンバーにアクセスする方法についての手引きとして ― 例えば、あなたがある準拠型がそれらを実装するかどうか確信が持てない時など ― オプショナルのプロトコル要件を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about how to use the optional declaration modifier and for guidance about how to access optional protocol members—for example, when you’re not sure whether a conforming type implements them—see Optional Protocol Requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>optional宣言修飾子を働かせる方法に関する詳細は、そして、オプショナルのプロトコルメンバーにアクセスする方法 ― 例えば、ある準拠している型がそれらを実装するかどうかについてあなたが確信が持てない時など ― についての手引きとしてオプショナルのプロトコル要件を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about implicitly unwrapped optional types, see Implicitly Unwrapped Optionals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナル型の詳細については、暗黙的にアンラップされるオプショナルを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about initializer delegation, see Initializer Delegation for Value Types and Initializer Delegation for Class Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ委任についての更なる情報として、値型のためのイニシャライザ委任とクラス型のためのイニシャライザ委任を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about pattern matching, see Patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターンマッチングについての更なる情報として、パターンを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about precedence groups and to see the syntax for defining your own operators and precedence groups, see Operator Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位グループについてのさらなる情報として、そしてあなた独自の演算子と優先順位グループを定義するための構文を見るには、演算子宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about subscripting and to see examples of subscript declarations, see Subscripts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字に関するより多くの情報のために、そして、添え字宣言の例を見るために、添え字を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about the String type, see Strings and Characters and &lt;!5&gt;String Structure Reference&lt;!6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>String型の詳細については、文字列と文字と&lt;!5&gt;文字列構造リファレンス&lt;!6&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about the fallthrough statement, see Fallthrough Statement below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>fallthrough文の詳細については、下記のフォールスルー文を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about the pattens you can use in a catch clause, see Patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがcatch節において使うパターンについての更なる情報として、パターンを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about this attribute, see Attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性についてのさらなる情報として、属性を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about this class, see Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.0.1).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスについての更なる情報として、エラーの処理をSwiftをCocoaとObjective-Cとともに使う（Swift 3.0.1）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about type casting and to see examples that use the type-casting operators, see Type Casting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャストに関するより多くの情報のために、そして、型キャスト演算子を使用する例をより多く見るために、型キャストを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using Array with Foundation and Cocoa, see Working with Cocoa Data Types in Using Swift with Cocoa and Objective-C (Swift 3.0.1).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>FoundationとCocoaとともにArrayを使うことについてのさらなる情報として、Cocoaデータ型を扱うをSwiftをCocoaとObjective-Cと共に使う（Swift 3.0.1）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using Dictionary with Foundation and Cocoa, see Working with Cocoa Data Types in Using Swift with Cocoa and Objective-C (Swift 3.0.1).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>FoundationとCocoaとともにDictionaryを使うことについてのさらなる情報として、Cocoaデータ型を扱うをSwiftをCocoaとObjective-Cと共に使う（Swift 3.0.1）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using Set with Foundation and Cocoa, see Working with Cocoa Data Types in Using Swift with Cocoa and Objective-C (Swift 3.0.1).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>FoundationとCocoaとともにSetを使うことについてのさらなる情報として、Cocoaデータ型を扱うをSwiftをCocoaとObjective-Cと共に使う（Swift 3.0.1）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using String with Foundation and Cocoa, see Working with Cocoa Data Types in Using Swift with Cocoa and Objective-C (Swift 3.0.1).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>FoundationとCocoaとともにStringを使うことについてのさらなる情報として、Cocoaデータ型を扱うをSwiftをCocoaとObjective-Cと共に使う（Swift 3.0.1）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using multiple optional chaining operations, see Linking Multiple Levels of Chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のオプショナル連鎖演算を使用することについての更なる情報として、連鎖の複数の階層を結ぶを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using selectors in Swift code that interacts with Objective-C APIs, see Keys and Key Paths in Using Swift with Cocoa and Objective-C (Swift 3.0.1).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C APIと相互作用するスウィフトコードにおけるセレクタの使用についてのさらなる情報として、キーとキーパスをSwiftをCocoaとObjective-Cと共に使う（Swift 3.0.1）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using selectors in Swift code that interacts with Objective-C APIs, see Objective-C Selectors in Using Swift with Cocoa and Objective-C (Swift 3.0.1).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C APIと相互作用するスウィフトコードにおいてセレクタを使うことについての更なる情報として、Objective-CセレクタをSwiftをCocoaとObjective-Cと共に使う (Swift 3.0.1)において見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and examples of capture lists, see Resolving Strong Reference Cycles for Closures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャプチャリストのより多くの情報と例のために、クロージャのための強い参照循環の解消を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and examples of closure expressions, see Closure Expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式のより多くの情報と例のために、クロージャ式を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and examples, see Associated Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報と例のために、関連型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see an example of how to use property observers, see Property Observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そして、プロパティオブザーバーを使う方法の例を見るために、プロパティオブザーバーを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see an example, see In-Out Parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そして、例を見るために、In-Outパラメータを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see examples of cases with associated value types, see Associated Values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そして関連値型をもつケース節の例を見るために、関連値を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see examples of cases with raw-value types, see Raw Values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そして「生の値」型をもつケース節の例を見るために、生の値を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see examples of computed properties, see Computed Properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そして、計算プロパティの例を見るために、計算プロパティを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see examples of failable initializers, see Failable Initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらなる情報と、失敗できるイニシャライザの例を見るために、失敗できるイニシャライザを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see examples of how to use try, try?, and try!, see Error Handling.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そしてtry、try?、そしてtry!文を使う方法の例を見るために、エラーを処理するを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see examples of how to use statement labels, see Labeled Statements in Control Flow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そして、文ラベルを使用する方法の例を見るために、ラベルをつけられた文を制御の流れで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see examples that show how to use optional types, see Optionals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そしてオプショナル型を使う方法を示す例を見るために、オプショナルを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on bridging, see Working with Cocoa Data Types in Using Swift with Cocoa and Objective-C (Swift 3.0.1).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブリッジに関する更なる情報として、ココアデータ型を扱うをSwiftをCocoaとObjective-Cと共に使う（Swift 3.0.1）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on functions with the Never return type, see Functions that Never Return.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Never戻り型を持つ関数でのさらなる情報は、決して戻らない関数を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on property observers, see Property Observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバーの詳細については、プロパティオブザーバーを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on required initializers, see Required Initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>必須イニシャライザに関する更なる情報として、必須イニシャライザを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information see Type Variable Properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、型変数プロパティを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Assigning Constant Properties During Initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、初期化の間に定数プロパティを割り当てるを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Classes and Structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、クラスと構造体を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Constant Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、定数宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Extensions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、拡張を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Failable Initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらなる情報として、失敗できるイニシャライザを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Inheritance, Type Casting, Deinitialization, and Automatic Reference Counting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、継承、型キャスト、デイニシャライズ、そして自動参照カウントを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Properties, Methods, Subscripts, Initialization, Extensions, and Protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、プロパティ、メソッド、添え字、初期化、拡張、そしてプロトコルを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Automatic Initializer Inheritance below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報は、以下の自動的なイニシャライザ継承を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Functions with Multiple Return Values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、「複数の戻り値をもつ関数」を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Optional Binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、オプショナルの束縛を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Sets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、集合を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Strong Reference Cycles for Closures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、クロージャのための強い参照循環を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Checking for Protocol Conformance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、プロトコル準拠の確認を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Declaration Attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、宣言属性を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Precedence Group Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらなる情報は、優先順位グループ定義を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Classes and Structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、クラスと構造体を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Type-Casting Operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、型キャスト演算子を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Raw Values and Enumerations with Cases of a Raw-Value Type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、生の値と「生の値」型のケース節を持つ列挙を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more on for-in loops, see Control Flow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>for-inループの詳細については、制御の流れを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more on arrays and dictionaries, see Collection Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列と辞書の詳細について、コレクション型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more on arrays, see Arrays.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の詳細については、配列を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more on generic types and collections, see Generics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体型とコレクションの詳細は「総称体」を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more on reference and value semantics, see Structures and Enumerations Are Value Types and Classes Are Reference Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>参照および値意味論についての詳細として、構造体と列挙は値型ですとクラスは、参照型ですを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more on the if statement, see Control Flow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文の詳細については、制御の流れを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more on the final modifier, see Preventing Overrides.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>final修飾子に関する更なる情報として、オーバーライドを防ぐを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more on these capabilities, see Properties, Methods, Initialization, Extensions, and Protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの能力の詳細について、プロパティ、メソッド、初期化、拡張、そしてプロトコルを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For readability, a compound case can also be written over multiple lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可読性のために、複合ケース節はまた複数行にわたって描かれることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For simple numeric values, the unary minus operator converts positive numbers into their negative equivalent and vice versa.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単純な数の値のために、この単項マイナス演算子は正の数をその負の等価物に変えます、逆の場合も同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the numberOfLegs dictionary above, the key-value subscript takes and returns a value of type Int?, or “optional int”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のnumberOfLegs辞書のために、その「キーと値」添え字は型Int?、つまり「オプショナルのint」の値を受け取りそして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the best experience, open this chapter as a playground in Xcode.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最もよい体験方法として、Xcodeでplayground（遊び場）としてこの章を開いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the example above, this enables the names of Suit, Rank, and Values to be kept deliberately short, because their names are naturally qualified by the context in which they are defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、これは、Suit、Rank、そしてValuesの名前が故意に短いままにしておかれるようにします、なぜなら、それらが定義される文脈によってそれらの名前が自然に修飾されて限定されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the numeric cards, it uses the rank’s raw Int value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数字カードのために、それは等級の生のInt値を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the other three properties, new VideoMode instances will be initialized with an interlaced setting of false (meaning “noninterlaced video”), a playback frame rate of 0.0, and an optional String value called name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の３つのプロパティのために、新しいVideoModeインスタンスは、falseに設定されるinterlaced（「ノンインタレース・ビデオ」を意味します）、0.0の再生フレームレート、nameというオプショナルのString値で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the purposes of these rules, the characters (, [, and { before an operator, the characters ), ], and } after an operator, and the characters ,, ;, and : are also considered whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの規則を理由に、演算子の前の文字(、[、および{、演算子の後の文字)、]、および}、そして文字,、;、および:は、また、空白と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the purposes of this example, +++ is treated as a new “prefix doubling” operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例の目的のために、+++は新しい「接頭辞倍加」演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For these types, Objective-C methods typically return a special value (such as NSNotFound) to indicate the absence of a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型のために、Objective-Cメソッドは、値の欠如を示すために概して特別な値（例えばNSNotFound）を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this calculation, the individual counter values each time through the loop are unnecessary—the code simply executes the loop the correct number of times.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この計算では、ループするごとに個別のカウンタ値は必要ではありません ― このコードは単に正しい回数ループを実行するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, Swift strings cannot be indexed by integer values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この理由のために、スウィフトの文字列は整数値でインデックス付けされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For value types, you use self.init to refer to other initializers from the same value type when writing your own custom initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型のために、あなたはself.initを使って、あなた独自のあつらえのイニシャライザを書くとき同じ値型の他のイニシャライザに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For-In Loops</seg>
      </tuv>
      <tuv lang="JA">
        <seg>for-inループ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For-In Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>For-In文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forced-Value Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強制された値式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Foundation also extends String to expose methods defined by NSString.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Foundationはまた、Stringを拡張してNSStringによって定義されるメソッドに触れさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Argument Labels and Parameter Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の引数ラベルとパラメータ名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Call Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数呼び出し式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Parameters and Return Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数のパラメータと戻り値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Types as Parameter Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ型としての関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Types as Return Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>戻り型としての関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function call expressions have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数呼び出し式は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function declarations are declared using the func keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数宣言は、キーワードfuncを使って宣言されます、そして以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function parameters and return values are extremely flexible in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数パラメータと戻り値は、スウィフトではとても柔軟です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function parameters are a comma separated list where each parameter has one of several forms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数パラメータはコンマ区切りのリストです、そこにおいて各パラメータはいくつかの書式のうちの１つを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function parameters are constants by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数パラメータは、特に何もしなければ定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function parameters can have both a name (for use within the function’s body) and an argument label (for use when calling the function), as described in Function Argument Labels and Parameter Names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数パラメータは、名前（関数の本文内で使うため）と引数ラベル（関数を呼び出すとき使うため）の両方を持つことができます、関数の引数ラベルとパラメータ名で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function type parameters with the escaping type attribute require explicit use of self. for properties or methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>escaping型属性を持つ関数型パラメーターは、明示的なself.の使用をプロパティやメソッドに対して必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function types that can throw an error must be marked with the throws keyword, and function types that can rethrow an error must be marked with the rethrows keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーを投げ掛けること（スロー）ができる関数型は、throwsキーワードで印されなければなりません、そしてエラーを再度投げ掛けること（再スロー）ができる関数型は、rethrowsキーワードで印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions With Multiple Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のパラメーターを持つ関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions Without Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータのない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions Without Return Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>戻り値のない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions and Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数とクロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions and methods that can throw an error must be marked with the throws keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーをスローできる関数とメソッドは、throwsキーワードで印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions and methods with the Never return type are called nonreturning.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Never戻り型を持つ関数およびメソッドは、非復帰と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are a first-class type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、第一級（ファーストクラス）の種類のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are actually a special case of closures: blocks of code that can be called later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、実際のところクロージャ：後刻に呼び出されることができるコードのひとまとまり、の特別な場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are not required to define a return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、戻り型を定義することを要求されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are not required to define input parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、入力パラメータを定義することを要求されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can also be written within other functions to encapsulate useful functionality within a nested function scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、また、他の関数の内部で記述されることで、役に立つ機能性を入れ子にされた関数スコープ内でカプセル化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can also take a variable number of arguments, collecting them into an array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数はまた、引数を可変の数だけとることができます、それらは配列へと集めることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can be nested.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、入れ子にされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can have multiple input parameters, which are written within the function’s parentheses, separated by commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は複数の入力パラメータを持つことが出来ます、それは関数の丸括弧内に書かれ、コンマで区切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can return multiple values using a tuple type as the return type of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、関数の戻り型としてタプル型を使って、複数の値を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions that Never Return</seg>
      </tuv>
      <tuv lang="JA">
        <seg>決して返らない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions with Multiple Return Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数の戻り値を持つ関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions without a defined return type return a special value of type Void.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>戻り型定義のない関数は、型Voidの特別な値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fundamental Set Operations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合演算の基本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, a new CreditCard instance can only be created by passing a number value and a customer instance to a custom CreditCard initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに、新しいCreditCardインスタンスは、number値とcustomerインスタンスをあつらえのCreditCardイニシャライザに渡すことによってのみ作成されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic Argument Clause</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体引数節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic Functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic Parameter Clause</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体パラメータ節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic Parameters and Arguments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体パラメータと引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic Where Clauses</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体where節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic classes can inherit from other generic and nongeneric classes, but a nongeneric class can inherit only from other nongeneric classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体クラスは、他の総称体および非総称体クラスから継承することができます、しかし非総称体クラスはただ他の非総称体クラスからのみ継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic code enables you to write such a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体コードは、あなたにこのような関数を書くことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generics</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generics are one of the most powerful features of Swift, and much of the Swift standard library is built with generic code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体は、スウィフトの最も強力な特徴のうちの１つです、そして、多くのスウィフト標準ライブラリは総称体コードで組み立てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gettable and settable properties are indicated by writing { get set } after their type declaration, and gettable properties are indicated by writing { get }.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>取得可能かつまた設定可能なプロパティは、それらの型宣言の後に{ get set }を書くことによって示されます、そして取得可能なプロパティは{ get }を書くことによって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getters and Setters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲッターとセッター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getters and setters for constants, variables, properties, and subscripts automatically receive the same access level as the constant, variable, property, or subscript they belong to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数、変数、プロパティ、そして添え字のためのゲッターとセッターは、自動的に、それらが属している定数、変数、プロパティまたは添え字と同じアクセス水準を受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Give enumeration types singular rather than plural names, so that they read as self-evident:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙型に複数形よりむしろ単数形の名前を与えてください、わかりきったことという印象を受けるので：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Give types UpperCamelCase names (such as SomeClass and SomeStructure here) to match the capitalization of standard Swift types (such as String, Int, and Bool).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>標準のスウィフト型（例えばString、Int、そしてBool）の大文字の使用法に合うように、型にUpperCamelCase アッパーキャメルケース名（例えばSomeClassやSomeStructure）を与えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global and Local Variables</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グローバルおよびローカル変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global and nested functions, as introduced in Functions, are actually special cases of closures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数で紹介される、グローバルおよび入れ子にされた関数は、実際にはクロージャの特別な場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global constants and variables are always computed lazily, in a similar manner to Lazy Stored Properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グローバルな定数と変数は、遅延保存プロパティと似たやり方で、常に遅延計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global functions are closures that have a name and do not capture any values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グローバルな関数は、名前を持ち、まったく値をキャプチャしない（捕獲しない）クロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global variables are variables that are defined outside of any function, method, closure, or type context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グローバルな変数は、あらゆる関数、メソッド、クロージャ、または型の文脈の外で定義される変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a binary expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>二項式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a branch statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>分岐文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a break statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブレーク文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a class declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a closure expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a code block</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コードブロックの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a compiler control statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラ制御文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a conditional compilation block</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件コンパイルプロックの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a conditional operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a constant declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a continue statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>継続文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a control transfer statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御移動文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a declaration modifier</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言修飾子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a defer statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>defer文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a deinitializer declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a dictionary type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a do statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>do文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a dynamic type expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動的型式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a fallthrough statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>フォールスルー文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a floating-point literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a for-in statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>for-in文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a forced-value expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強制された値の式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a function call expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数呼び出し式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a function declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a function type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a generic argument clause</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体引数節の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a generic parameter clause</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体パラメータ節の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a getter-setter block</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲッターセッター・ブロックの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a guard statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>guard文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a implicit member expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的メンバー式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a key-path expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパス式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a labeled statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラベルをつけられた文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a line control statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行制御文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a literal expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラル式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a loop statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a metatype type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メタタイプ型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a parenthesized expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>丸括弧に入れられた式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a postfix expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a precedence group declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位グループ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a prefix expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a primary expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a protocol associated type declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル関連型宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a protocol composition type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル構成型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a protocol declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a protocol initializer declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル・イニシャライザ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a protocol method declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルメソッド宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a protocol property declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルプロパティ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a protocol subscript declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル添え字宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a repeat-while statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>repeat-while文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a return statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>return文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a selector expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セレクタ式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a self expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>self式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a string literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a structure declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a subscript declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a subscript expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a superclass expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラス式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a switch statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a throw statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スロー文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a top-level declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トップレベル宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a try expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>try式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a tuple pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル・パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a tuple type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a type alias declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアス宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a type annotation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型注釈の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a type casting pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャスト・パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a type identifier</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型識別子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a type inheritance clause</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型継承節の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a type-casting operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャスト演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a value-binding pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値束縛パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a variable declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a while statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>while文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a wildcard expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ワイルドカード式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a wildcard pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ワイルドカード・パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an array type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an assignment operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代入演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an attribute</seg>
      </tuv>
      <tuv lang="JA">
        <seg>属性の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an availability condition</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効性条件の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an enumeration case pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an enumeration declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an explicit member expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的メンバー式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an expression pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an extension declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an identifier</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an identifier pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an if statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an implicitly unwrapped optional type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナル型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an import declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポート宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an initializer declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an initializer expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an integer literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an operator declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an optional pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルパターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an optional type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an optional-chaining expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Greater than (a &gt; b)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より大きい（a &gt; b）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Greater than or equal to (a &gt;= b)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より大きいか等しい、以上（a &gt;= b）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Greet n times</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（n回あいさつします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grouping parentheses don’t change an expression’s type—for example, the type of (1) is simply Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グループ化括弧はある式のもつ型を変えません — 例えば、(1)の型は単にIntです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Guard Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>guard文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Guiding Principle of Access Levels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス水準の原理指針</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Had this check not been performed, board[square] might try to access a value outside the bounds of the board array, which would trigger an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この確認が実行されなかったなら、board[square]はboard配列の範囲外で値にアクセスしようとしたかもしれません、それはエラーの引き金となったでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Half-Open Range Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>半開範囲演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Half-open ranges are particularly useful when you work with zero-based lists such as arrays, where it is useful to count up to (but not including) the length of the list:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>半開範囲は、あなたが配列のようなゼロに基づくリストを扱うとき特に便利です、そこにおいて、そのリストの長さまで（しかしそれは含まずに）数え上げるのに役に立ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling Errors</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーを処理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling Errors Using Do-Catch</seg>
      </tuv>
      <tuv lang="JA">
        <seg>do-catchを使ってエラーを処理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash Values for Set Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Set型のためのハッシュ値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Having created a new Vehicle instance, you can access its description property to print a human-readable description of the vehicle’s current speed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいVehicleインスタンスを作成したら、あなたはそれのdescriptionプロパティにアクセスして、その乗り物の現在速度の説明を人の読めるように出力することが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are two classes, Circle and Country, both of which conform to the HasArea protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その両方ともHasAreaプロトコルに従う２つのクラス、CircleとCountryが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is the general form of a do-catch statement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにdo-catch文の一般的な形式があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the function returns an integer, so x and y are optional integers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに整数を返す関数があります、それでxとyはオプショナル整数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, $0 and $1 refer to the closure’s first and second String arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、$0と$1は、クロージャの１番目と２番目のString引数に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, AudioSample is defined as an alias for UInt16.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、AudioSampleはUInt16に対するエイリアス（別名）として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, self disambiguates between a method parameter called x and an instance property that is also called x:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、selfは、xと呼ばれるメソッドパラメータと同様にまたxと呼ばれるインスタンスプロパティの間の曖昧さをなくします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, a new array called breakfastList is created from an array literal containing three new ShoppingListItem instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、breakfastListと呼ばれる新しい配列は、３つの新しいShoppingListItemインスタンスを含んでいる配列リテラルからつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, an additional if statement was added to respond to particularly warm temperatures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、追加のif文は、特に暖かい気温に反応するために加えられました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the shoppingList array is initialized with two String values ("Eggs" and "Milk"), written within an array literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここで、shoppingList配列は、配列リテラル内に書かれる２つのString値（"Eggs"と"Milk"）で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the favoriteGenres set is initialized with three String values ("Rock", "Classical", and "Hip hop"), written within an array literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、favoriteGenres集合は、配列リテラル内に書かれる、３つのString値（"Rock"、"Classical"、そして"Hip hop"）で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the deinitializer simply returns all of the player’s coins to the bank:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、デイニシャライザは単に胴元にプレーヤーのコインの全てを返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the dictionary’s keys are decomposed into a constant called animalName, and the dictionary’s values are decomposed into a constant called legCount.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、辞書のキーはanimalNameと呼ばれる定数に分解されます、そして辞書の値はlegCountと呼ばれる定数に分解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the function type of the sorted(by:) method’s argument makes it clear that a Bool value must be returned by the closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、sorted(by:)メソッドの引数である関数型は、Bool値がクロージャによって返されなければならないことを明白にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the player has won 2,000 coins.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、プレーヤーは2,000個のコインを獲得しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the possibility that increment(forCount:) might not be implemented is also handled by optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、increment(forCount:)が実装されないかもしれないという可能性もまたオプショナル連鎖によって取り扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the raw values for an enumeration called ASCIIControlCharacter are defined to be of type Character, and are set to some of the more common ASCII control characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、ASCIIControlCharacterと呼ばれる列挙に対する生の値は、型Characterであると定義されて、たいへんありふれたASCII制御文字のいくつかに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the superclass has a single designated initializer and two convenience initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、スーパークラスは一つの指定イニシャライザと２つの便宜イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the value of the constant three is used to create a new value of type Double, so that both sides of the addition are of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、定数threeの値が、Double型の新しい値をつくるために使われます、それでこの加算の両側は同じ型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, they are used to print the categorization of the point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、それらはポイントの分類を出力するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a class called Animal, which does not conform to the HasArea protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>HasAreaプロトコルに従わないAnimalと呼ばれるクラスが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a function called chooseStepFunction(backward:), whose return type is (Int) -&gt; Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにchooseStepFunction(backward:)と呼ばれる関数があります、それの戻り型は(Int) -&gt; Intです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a function with no input parameters, which always returns the same String message whenever it is called:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに入力パラメータのない関数があります、そしてそれは、それが呼ばれるときはいつでも、常に同じStringメッセージを返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a generic version of the swapTwoInts(_:_:) function from above, called swapTwoValues(_:_:):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、上記のswapTwoInts(_:_:)関数の総称体版があります、それはswapTwoValues(_:_:)と呼ばれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a generic version of the same code:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じコードの総称体版は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a more complex class, which also adopts and conforms to the FullyNamed protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、FullyNamedプロトコルを採用して準拠するさらに複雑なクラスが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a more complex data source called TowardsZeroSource, which makes a Counter instance count up or down towards zero from its current count value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>TowardsZeroSourceと呼ばれるより複雑なデータ・ソースがここにあります、それは、Counterインスタンスをその現在のcount値から上下にゼロの方へ数えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a non-generic function called findIndex(ofString:in:), which is given a String value to find and an array of String values within which to find it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにfindIndex(ofString:in:)と呼ばれる非総称体関数があります、それは、見つけるString値と、そこにおいてそれを捜すString値からなる配列を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a simple CounterDataSource implementation where the data source returns a constant value of 3 every time it is queried.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある単純なCounterDataSource実装がここにあります、そこにおいて、データ・ソースは3の定数値をそれが問い合わされるたびに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a skeleton outline of how a closure can be used to provide a default property value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、あるクロージャが省略時のプロパティ値を提供するために使われることができる方法の骨組み概要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a standard, non-generic function called swapTwoInts(_:_:), which swaps two Int values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、通常の、非総称体のswapTwoInts(_:_:)と呼ばれる関数があります、それは、２つのInt値を交換します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a variation of the greet(person:) function that takes a person’s name and hometown and returns a greeting:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにgreet(person:)関数の変形があります、それはある個人の名前と出身地をとって挨拶を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a version of the greet(person:) function, which prints its own String value rather than returning it:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにgreet(person:)関数の改作があります、それはString値を自身で出力します、それを返すのではなく：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a version of the Snakes and Ladders game originally introduced in Control Flow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御の流れで元々は紹介されるヘビとはしごゲームのひとつの改作が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a version of the non-generic IntStack type from earlier, adapted to conform to the Container protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以前の非総称体のIntStack型の改作、Containerプロトコルに準拠するために適応させたものが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an alternative version of the Rect structure, which takes advantage of this shorthand notation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この短縮形表記法を利用するRect構造体の代替版が、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example for the four main points of a compass:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、コンパスの主な４方位のための例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of makeIncrementer in action:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動作しているmakeIncrementerの例がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of willSet and didSet in action.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>willSetとdidSetの作動する例が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a deinitializer in action.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザの動作の例は、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a function called makeIncrementer, which contains a nested function called incrementer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、makeIncrementerと呼ばれる関数の例があります、それはincrementerと呼ばれる入れ子にされた関数を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a function called swapTwoInts(_:_:), which has two in-out integer parameters called a and b:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにswapTwoInts(_:_:)と呼ばれる関数の例があります、それは、aとbと呼ばれる２つのin-out整数パラメータを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a protocol called Container, which declares an associated type called ItemType:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Containerと呼ばれるプロトコルの例がここにあります、それはItemTypeと呼ばれる関連型を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a protocol that inherits the TextRepresentable protocol from above:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のTextRepresentableプロトコルを継承するプロトコルの例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a protocol used as a type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型として使われるプロトコルの例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a protocol with a single instance property requirement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ただ一つのインスタンスプロパティ要件を持つプロトコルの例が、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a read-only subscript implementation, which defines a TimesTable structure to represent an n-times-table of integers:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに読み出し専用の添え字の実施の例があります、それは、整数の九九のn段を表すTimesTable構造体を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a simple structure that adopts and conforms to the FullyNamed protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>FullyNamedプロトコルを採用して準拠する単純な構造体の例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a structure definition and a class definition:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体定義とクラス定義の例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of how Automatic Reference Counting works.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動参照カウントがどのように働くかの例は、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of how a strong reference cycle can be created by accident.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強い参照循環がどのように偶然に作られることができるかの例は、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of how constants and variables can be used to track the number of login attempts a user has made:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに定数と変数が、どのようにあるユーザーが行ったログインの試みの数を追跡するために使われることができるかの例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of how error handling can be used to respond to different error conditions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにどのようにエラー処理が異なるエラー状態に応答するために使われることができるかの例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of how optionals can be used to cope with the absence of a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、値の欠如に対処するためにどのようにオプショナルが使われることができるかの１つの例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of this syntax for a while loop, although the principle is the same for all loops and switch statements:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、この構文のwhileループに対する例があります、とはいえその原則は全てのループとswitch文のための同じです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of using Any to work with a mix of different types, including function types and non-class types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型と非クラス型を含む、異なった型の混合を扱うためにAnyを使う例は、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of what happens when an unsigned integer is allowed to overflow in the positive direction, using the overflow addition operator (&amp;+):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、オーバフロー加算演算子（&amp;+）を使用して、正の向きにおいて符号なし整数がオーバフローを許されるとき何が起こるかの例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example that combines two protocols called Named and Aged into a single protocol composition requirement on a function parameter:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、関数パラメータ上でNamedとAgedと呼ばれる２つのプロトコルを１つのプロトコル合成要件に結合する例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example that defines a simple Counter class, which can be used to count the number of times an action occurs:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単純なCounterクラスを定義する例がここにあります、それは、ある動作が起こる回数を数えるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example that stores raw ASCII values alongside named enumeration cases:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定した列挙ケース節の傍らに生のASCII値を格納する例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example to print the results of the math functions from above:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに上記の数学関数の結果を出力する例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example using the overflow subtraction operator (&amp;-):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにオーバフロー減算演算子（&amp;-）を使った例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example, using the VideoMode class defined above:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で定義されるVideoModeクラスを使用している例がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example, which calculates the height for a table row.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにひとつの例があります、それはあるテーブルの列の高さを計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにひとつの例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an expanded version of the Celsius example from earlier, with an additional initializer to create a new Celsius instance from a Double value that is already in the Celsius scale:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに前のCelsius例の拡張版があります、それは追加のイニシャライザを使って、既に摂氏尺度であるDouble値から新しいCelsiusインスタンスを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an implementation of a class that adopts and conforms to the RandomNumberGenerator protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>RandomNumberGeneratorプロトコルを採用して準拠するクラスの実施が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s another example, for a function with no parameters or return value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もう一つの例がここにあります、パラメータおよび戻り値のないある関数です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how DiceGameTracker looks in action:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動作中のDiceGameTrackerがどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how stackOfStrings looks after pushing these four values on to the stack:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの４つの値をそのスタックにプッシュした後でstackOfStringsがどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how bit shifting looks in Swift code:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビットシフトがスウィフトコードにおいてどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how phase 1 looks for an initialization call for a hypothetical subclass and superclass:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第１段階がある仮定のサブクラスとスーパークラスのための初期化呼び出しを捜す方法がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how phase 2 looks for the same initialization call:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第２段階が同じ初期化呼び出しを捜す方法は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the Dice class can be used to create a six-sided dice with a LinearCongruentialGenerator instance as its random number generator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Diceクラスが、６面のさいころをつくるためにその乱数生成器としてLinearCongruentialGeneratorインスタンスをつかってどのように使われることができるかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the allItemsMatch(_:_:) function looks in action:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動作中のallItemsMatch(_:_:)関数がどのように見えるかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the bits inside an Int8 look for the number -4:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Int8内のビットが数-4に対してどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the bits inside an Int8 look for the number 4:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Int8内のビットが数4に対してどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the cycle looks:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>循環がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the first lines compare:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の行がどのくらい似ているかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the method looks:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのようにそのメソッドが見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the references look now that you’ve linked the two instances together:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが２つのインスタンスを結びつけた今、参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the references look with the capture list in place:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>捕獲リストで適切にされた参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the references look, now that you’ve linked the two instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが２つのインスタンスを結んだ今、これらの参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the remainder operator works.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに剰余演算子が機能する方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the stack looks after popping its top value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックがその一番上の値をポップした後にどう見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the strong references look after creating and assigning these two instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの２つのインスタンスの作成と代入の後に強い参照がどのように見えるかが、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the strong references look after you link the two instances together:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが２つのインスタンスを結びつけた後に強い参照がどのように見えるかが、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the strong references look after you set the john and unit4A variables to nil:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがjohnとunit4A変数をnilに設定したあと、強い参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how to write a non-generic version of a stack, in this case for a stack of Int values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックの非総称体版を書く方法がここにあります、これはInt値のスタックの場合です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how two-phase initialization plays out, based on the four safety checks above:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２段階初期化が、上の４つの安全点検に基づいて最後までやり終える方法がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how you call a type method on a class called SomeClass:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが型メソッドをSomeClassと呼ばれるクラスの上で呼び出す方法がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how you can use the map(_:) method with a trailing closure to convert an array of Int values into an array of String values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、あなたがInt値の配列をString値の配列に変えるために後付クロージャとともにmap(_:)メソッドをどのように使用できるかがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how you might expect a generic version of findIndex(ofString:in:), called findIndex(of:in:), to be written.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが予想するfindIndex(ofString:in:)の総称体版、findIndex(of:in:)と呼ばれるものが書かれる方法はここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how you use the HTMLElement class to create and print a new instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが新しいインスタンスを作成して出力するためにHTMLElementクラスを使用する方法は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how you write the HTMLElement class to avoid the cycle:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがHTMLElementクラスを循環を避けるように書く方法は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s the Snakes and Ladders example again, written as a repeat-while loop rather than a while loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに再び「ヘビとはしご」の例があります、それはrepeat-whileループとして書かれます、whileループではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s the general form of a repeat-while loop:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>repeat-whileループの一般的な形式は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s the general form of a while loop:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>whileループの一般的な形式は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s the initial array to be sorted:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>分類される最初の配列は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hexadecimal floating-point literals consist of a 0x prefix, followed by an optional hexadecimal fraction, followed by a hexadecimal exponent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>16進の浮動小数点リテラルは、0x接頭辞、続けて任意の16進の小数部、それに続く16進の指数から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Higher-precedence operators are evaluated before lower-precedence ones.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より高い優先順位の演算子は、より低い優先順位のもの前に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Horizontal Tab (\t)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>水平タブ（\t）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How ARC Works</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ARCは、どのように働きますか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How Deinitialization Works</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライズはどのように働くか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to Read the Grammar</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文法を読む方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Swift classes and structures are much closer in functionality than in other languages, and much of this chapter describes functionality that can apply to instances of either a class or a structure type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、スウィフトのクラスと構造体は他の言語においてよりも機能性において非常に近いものです、したがってこの章の多くはクラスまたは構造体型の両方のインスタンスに適用されることができる機能性を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Swift only performs an actual copy behind the scenes when it is absolutely necessary to do so.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、スウィフトは実際のコピーを、そうすることが絶対に不可欠な時に舞台裏で行うだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a method marked with the objc attribute can override a method marked with the nonobjc attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、objc属性で印されるメソッドはnonobjc属性で印されるメソッドをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a unit test target can access any internal entity, if you mark the import declaration for a product module with the @testable attribute and compile that product module with testing enabled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、あなたが製品モジュールのためのインポート宣言を@testable属性で印して、その製品モジュールをテスト可能な状態にコンパイルするならば、ユニットテストターゲットはあらゆる内部実在にアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, at the point that they are stored in the objectWithArea constant, they are only known to be of type HasArea, and so only their area property can be accessed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、それらが定数のobjectWithAreaに格納される時点で、それらは型HasAreaであるということを知られているだけです、なので、それらのareaプロパティだけがアクセスされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, avoid using keywords as names unless you have absolutely no choice.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたに選択が全くない場合を除き、キーワードをなんらかの名前として使用することを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, because asHTML is a closure property rather than an instance method, you can replace the default value of the asHTML property with a custom closure, if you want to change the HTML rendering for a particular HTML element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、asHTMLはインスタンスメソッドではなくクロージャプロパティであるので、あなたが特定のHTML要素に対してHTML解釈を変更したいならば、あなたはあつらえのクロージャでasHTMLプロパティの省略時の値を置き替えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, because it’s called with a string constant, you can see that the initializer won’t fail, so no runtime error can occur in this case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、それは文字列定数で呼び出されるので、あなたはこのイニシャライザが失敗することはないと分かります、それで実行時エラーはこの場合には起こりえません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, because of Swift’s type inference, you don’t have to write the type of the set if you’re initializing it with an array literal containing values of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、スウィフトのもつ型推論のために、あなたが同じ型の値を含んでいる配列リテラルを使ってそれを初期化しているならば、あなたは集合の型を書く必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, because the closure refers to self within its body (as a way to reference self.name and self.text), the closure captures self, which means that it holds a strong reference back to the HTMLElement instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、クロージャがその本文内でselfに言及する（self.nameとself.textを参照する方法として）ので、クロージャはselfを捕獲します、それは、今度は逆にそれがHTMLElementインスタンスへの強い参照を保持することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, before you learn how to break a strong reference cycle with a closure capture list, it is useful to understand how such a cycle can be caused.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたがクロージャ捕獲リストで強い参照循環を壊す方法を学ぶ前に、そのような循環がどのように引き起こされることがありえるか理解することは役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, before you learn how to resolve a strong reference cycle, it is useful to understand how such a cycle is caused.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしあなたが強い参照循環を解消する方法を学ぶ前に、そのような循環がどのように引き起こされるか理解することは役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, for the inline closure expression, the parameters and return type are written inside the curly braces, not outside of them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、行内クロージャ式のために、パラメータと戻り型は、波括弧の内側に書かれます、その外側ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, functions and methods with no return type have an implicit return type of Void, as described in Functions Without Return Values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、戻り値のない関数で記述されるように、戻り型のない関数やメソッドは、Voidの暗黙の戻り型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if ARC were to deallocate an instance that was still in use, it would no longer be possible to access that instance’s properties, or call that instance’s methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、ARCがまだ使用中だったインスタンスの割り当て解除をすることになったならば、そのインスタンスのプロパティにアクセスすることや、そのインスタンスのメソッドを呼ぶことは、もはや可能でないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if multiple matches are possible, the first matching case is always used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、複数の適合が出来るならば、最初の適合するケース節が常に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if you apply both a prefix and a postfix operator to the same operand, the postfix operator is applied first.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたが接頭辞演算子と接尾辞演算子の両方を同じ演算数を適用したならば、接尾辞演算子が最初に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if you iterate over the contents of this array, the items you receive back are typed as MediaItem, and not as Movie or Song.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたがこの配列の内容上に繰り返すならば、あなたがそこから取り出す項目は、MediaItem型としてであって、MovieまたはSongではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if you need to modify the properties of your structure or enumeration within a particular method, you can opt in to mutating behavior for that method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたがある特定のメソッド内であなたの構造体または列挙のプロパティを修正する必要があるならば、あなたはそのメソッドのために可変挙動を選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in a few cases ARC requires more information about the relationships between parts of your code in order to manage memory for you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、２、３の場合には、ARCは、あなたのためにメモリを管理するために、あなたのコードの部分間の関係に関するより多くの情報を要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, initializers do not have an identifying function name before their parentheses in the way that functions and methods do.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、イニシャライザは、関数とメソッドがするように識別する関数名をその括弧の前に持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, instances of enumeration types have value semantics, which means they have a fixed layout in memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、列挙型のインスタンスは値意味論を持ちます、それは、それらがメモリにおいてある固定された配置を持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is more convenient (and clearer in intent) for the init(center:size:) initializer to take advantage of an existing initializer that already provides exactly that functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、すでに正確にその機能性を提供する既存のイニシャライザを利用するほうが、init(center:size:)イニシャライザにとってより便利です（そして意図においてより明白です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is not appropriate for an animal to have an empty string as the value of its species property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、ある動物にとってそれのspecies（種族）プロパティの値として空の文字列を持つことはふさわしくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is possible to write code in which an instance of a class never gets to a point where it has zero strong references.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あるクラスのあるインスタンスが、強い参照を１つも持たない状態になることが決してないコードを書くことは、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is sometimes useful to be able to store associated values of other types alongside these case values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、他の型の関連値をこれらのケース節値の傍らに保存することができることは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is sometimes useful to enforce certain type constraints on the types that can be used with generic functions and generic types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、総称体関数と総称体型で使われることができる型に、特定の型制約を強制することは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is sometimes useful to write shorter versions of function-like constructs without a full declaration and name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、まるまる完全な宣言や名前なしに、関数のような構造物のより短いものをいろいろと書くことは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, its behavior in Swift for negative numbers means that it is, strictly speaking, a remainder rather than a modulo operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、スウィフトでの負数に対するそれの挙動は、それが、厳密に言って、剰余（remainder）であり、モジュロ（modulo）演算でないのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, loops and conditional statements can both use the break statement to end their execution prematurely.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、ループと条件文は、両方ともしかるべき時よりも早くそれらの実行を終えるためにbreak文を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, multiple levels of optional chaining do not add more levels of optionality to the returned value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、オプショナル連鎖の複数の階層は、返された値にさらにオプショナルの階層を加えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, not every string can be converted into an integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、すべての文字列が、整数に変えられることができるというわけでありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, only nongeneric global functions, and local functions or closures that don’t capture any local variables, can be used as a function with C function calling conventions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、非総称体グローバル関数だけは、つまり全くローカル変数をキャプチャしないローカル関数またはクロージャは、C関数呼出規約を持つ関数として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, properties can also be associated with the type itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、プロパティはまた、型それ自体に結び付けられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, rather than two class instances, this time it’s a class instance and a closure that are keeping each other alive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし２つのクラスインスタンスではなく、今度は、それはお互いを生かし続けているクラスインスタンスとクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, remainder and multiplication have the same precedence as each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、剰余と乗算は、互いに同じ優先順位を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, semicolons are required if you want to write multiple separate statements on a single line:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それにもかかわらず、セミコロンは必要とされます、もしあなたが一つの行に複数の別々の文を書きたい場合には：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, structure instances are always passed by value, and class instances are always passed by reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、構造体インスタンスは常に値によって渡されます、そして、クラスインスタンスは常に参照によって渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, superclass initializers are automatically inherited if certain conditions are met.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、スーパークラスのイニシャライザは、決まった条件が満たされるならば、自動的に継承されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, that argument is now an inline closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、この引数は今では１つの行内クロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, that property declaration can’t be implemented as a constant property or a read-only computed property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、そのプロパティ宣言は、定数プロパティまたは読み出し専用の計算プロパティとして実装されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the width property of the original hd instance still has the old value of 1920:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、最初のhdインスタンスのwidthプロパティは、まだ1920の古い値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the &amp;&amp; and || operators still operate on only two values, so this is actually three smaller expressions chained together.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、&amp;&amp;と||演算子は依然として２つの値だけに作用します、なのでこれは実際のところ１つに繋がれた３つのより小さい式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the access level for the numberOfEdits property is marked with a private(set) modifier to indicate that the property’s getter still has the default access level of internal, but the property is settable only from within code that’s part of the TrackedString structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、numberOfEditsプロパティのためのアクセス水準は、private(set)修飾子を使って印を付けられて、そのプロパティの持つゲッターが依然として省略時のアクセス水準の内部を持つ、しかしプロパティはTrackedString構造体の部分であるコード内からのみ設定可能であることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the actual answer is 17, not 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、実際の答えは17です、5ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the alternative example below is valid:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、これに代わる以下の例は有効です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the emergency override password is known, so the overall compound expression still evaluates to true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、非常用解除パスワードは知られているので、複合式全体はなおtrueと評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the error must be handled by some surrounding scope—either by an enclosing do-catch clause that handles the error or by being inside a throwing function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、エラーは取り囲んでいるスコープの何れかによって処理される必要があります ― そのエラーを処理する 囲んでいるdo-catch節によって、またはスロー関数内部によって、このどちらかで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the first line of swapTwoValues(_:_:) is slightly different from swapTwoInts(_:_:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、swapTwoValues(_:_:)の最初の行は、わずかにswapTwoInts(_:_:)と異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the function does not perform any safety checks on the array it is passed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、この関数は、それが渡される配列に関してどんな安全確認も実行しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the initializer for Country cannot pass self to the City initializer until a new Country instance is fully initialized, as described in Two-Phase Initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、２段階初期化で記述されるように、Countryのためのイニシャライザは、selfをCityイニシャライザに渡すことが、新しいCountryインスタンスが完全に初期化されるまでできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the method is still able to use type casting to query the type of the underlying instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、このメソッドは依然として基盤インスタンスの型についてたずねるために型キャストを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the same letter can also be represented as a pair of scalars—a standard letter e (LATIN SMALL LETTER E, or U+0065), followed by the COMBINING ACUTE ACCENT scalar (U+0301).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、同じ文字はまた、一対のスカラー ― 通常の文字e（LATIN SMALL LETTER E、またはU+0065）、それに続けてCOMBINING ACUTE ACCENTスカラー（U+0301）として表わされることも出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the value of john.residence.address is currently nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、john.residence.addressの値は、現在はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there is a third scenario, in which both properties should always have a value, and neither property should ever be nil once initialization is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、第３の筋書きがあります、そこにおいて両方のプロパティは常に値を持たなければなりません、そして一旦初期化が終了しているならば、どちらのプロパティも決してnilであってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there is an exception if the compilation condition includes a swift() platform condition: The statements are parsed only if the compiler’s version of Swift matches what is specified in the platform condition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、例外があります、それはコンパイル条件がswift()プラットホーム条件を含む場合です：文はスウィフトのコンパイラのバージョンがプラットホーム条件において指定されるものと合致する場合にのみ構文解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there is no harm in using the gameLoop label with the continue statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、gameLoopラベルをcontinue文で使用することに害はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, they can contain other string literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、それは、他の文字列リテラルを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this code always triggers a runtime error when residence is nil, as illustrated above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、residenceがnilのとき、上で説明するように、このコードは常に実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this doesn’t mean that you have to specify the type of every constant and variable that you declare.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、これはあなたがすべてのあなたが宣言する定数と変数の型を指定しなければならないことを意味しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this is a rather long-winded way to write what is essentially a single-expression function (a &gt; b).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、これは本質的に単一式の関数（a &gt; b）であるものを書くには、相当に長たらしい方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this means that they are not exactly the same as in C-based languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、これはCに基づく言語とそれらが厳密には同じでないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, type properties are queried and set on the type, not on an instance of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、型プロパティは、その型のインスタンスにではなく、その型に問い合わせられ設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, when the tuples’ first elements are the same, their second elements are compared—this is what happens on the second and third line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、タプルのもつ最初の要素が同じ場合、２番目の要素は比較されます — これが２番目と３番目の行で起こることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, when there isn’t a meaningful relationship between them, it’s traditional to name them using single letters such as T, U, and V, such as T in the swapTwoValues(_:_:) function above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、意味がある関係がそれらの間に無かった時、例えばswapTwoValues(_:_:)におけるTのように、T、U、そしてVなどの一文字を使ってそれらに名前をつけるのが伝統的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, when you are working with your own resources, you might need to perform some additional cleanup yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたがあなた独自のリソース（計算資源）を扱うとき、あなたは追加のいくらかの掃除をあなた自身でする必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, when you specifically want an overflow condition to truncate the number of available bits, you can opt in to this behavior rather than triggering an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたがに利用できるビットの数を切り詰めるために特にオーバフロー条件を望むとき、あなたはエラーを引き起こすのではなくこの挙動を選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, with ARC, values are deallocated as soon as their last strong reference is removed, making weak references unsuitable for such a purpose.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、ARCでは、値はその最後の強い参照が削除されるやいなや割り当て解除されて、弱い参照をそのような目的のためにふさわしくないものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you call type methods on the type, not on an instance of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたは型のメソッドを型の上で呼び出します、その型のインスタンスの上ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can also define computed variables and define observers for stored variables, in either a global or local scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたはまた、計算変数を定義すること、そして保存変数のためにオブザーバーを定義することが、グローバルなまたはローカルなスコープのどちらにおいても可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can provide explicit argument labels using the same syntax that functions, methods, and initializers use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、あなたは明示的に引数ラベルを提供することが、関数、メソッド、およびイニシャライザが使うのと同じ構文を使うことで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can still change tenEighty.frameRate and alsoTenEighty.frameRate because the values of the tenEighty and alsoTenEighty constants themselves do not actually change.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたはそれでもなおtenEighty.frameRateとalsoTenEighty.frameRateを変更することができます、なぜならtenEightyおよびalsoTenEighty定数それら自身の値は実のところ変わらないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can’t construct an instance of a protocol, because protocols do not actually provide the implementations for the requirements they specify.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたはプロトコルからインスタンスを造ることができません、なぜならプロトコルは実際にはそれらが指定する要件に対する実装を用意しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you don’t always have to write the type explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたは必ずしも明確に型を書く必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identical to (===)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同一である（===）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identifier Pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identifiers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identifiers patterns within a value-binding pattern bind new named variables or constants to their matching values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある値束縛パターン内の複数の識別子パターンは、複数の新しい名前をつけられた変数または定数を、それらがマッチしている値に縛りつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identity Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同一性演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If someThrowingFunction() throws an error, the value of x and y is nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>someThrowingFunction()がエラーをスローするならば、xとyの値はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If true, execution continues to step 2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>trueならば、実行はステップ２に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If true, execution returns to step 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>trueならば、実行はステップ１に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If false, the program is finished executing the repeat-while statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>falseならば、プログラムはrepeat-while文の実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If false, the program is finished executing the while statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>falseならば、プログラムはwhile文の実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a and b were not of the same type, it would not be possible to swap their values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>aとbが同じ型でないならば、それらの値を交換することは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If square were equal to 26, the code would try to check the value of board[26], which is larger than the size of the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>squareが26と等しかったならば、コードはboard[26]の値の確認を試みるだろうし、それはこの配列の寸法よりも大きいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If question is true, it evaluates answer1 and returns its value; otherwise, it evaluates answer2 and returns its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>questionが真実ならば、それはanswer1を評価して、その値を返します；そうでなければ、それはanswer2を評価して、その値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If count is already zero, the method returns 0 to indicate that no further counting should take place.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>countがすでにゼロであるならば、メソッドは0を返して、これ以上数えることは必要ないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If Statements and Forced Unwrapping</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文と強制アンラップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a catch clause doesn’t have a pattern, the clause matches any error and binds the error to a local constant named error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>catch節がパターンを持たないならば、その節はあらゆるエラーにマッチします、そしてそのエラーをerrorと名前を付けられるローカル定数に束縛します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a catch clause does not specify a pattern, the catch clause matches and binds any error to a local constant named error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるcatch節がパターンを指定しないならば、そのcatch節はマッチしてあらゆるエラーをerrorと名前をつけられるローカル定数に束縛します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a where clause is present, the statements within the relevant case are executed only if the value of the control expression matches one of the patterns of the case and the expression of the where clause evaluates to true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>where節が存在するならば、関連するケース節の範囲内のいくらかの文は、制御式の値がケース節のパターンの１つとマッチして、そしてwhere節がtrueに評価される場合にだけ、実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a String is empty, startIndex and endIndex are equal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるStringが空ならば、startIndexとendIndexは同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a class has a superclass, list the superclass name before any protocols it adopts, followed by a comma:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスがスーパークラスを持つならば、それが採用するあらゆるプロトコルの前に、コンマに続けてスーパークラス名を列記してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a closure does not specify a parameter list or return type because they can be inferred from context, place the capture list at the very start of the closure, followed by the in keyword:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャがパラメータ・リストまたは戻り型を、それらが前後関係から推論されることができるために指定しないならば、捕獲リストをクロージャのまさしくその始まりに、inキーワードに続けて置いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a closure expression is provided as the function or method’s only argument and you provide that expression as a trailing closure, you do not need to write a pair of parentheses () after the function or method’s name when you call the function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクロージャ式がただ関数やメソッドの引数としてだけ提供され、そしてあなたが後付クロージャとしてその式を提供するならば、あなたがその関数を呼ぶときに、一対の丸括弧()を関数やメソッドの名前の後に書く必要はありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a computed property’s setter does not define a name for the new value to be set, a default name of newValue is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算プロパティのセッターが設定される新しい値の名前を定義しないならば、省略時の名前のnewValueが使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a conforming type provides its own implementation of a required method or property, that implementation will be used instead of the one provided by the extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>準拠している型がある必須のメソッドやプロパティのそれ自身の実装を提供する場合は、その実装が拡張によって提供されるものの代わりに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a conforming type satisfies the requirements for multiple constrained extensions that provide implementations for the same method or property, Swift will use the implementation corresponding to the most specialized constraints.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある準拠型が同じメソッドやプロパティに対する実装を提供する複数の制約付き拡張の要件を満たすならば、スウィフトは最も特殊化した制約と一致している実装を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a constant or variable in your code needs to work with the absence of a value under certain conditions, always declare it as an optional value of the appropriate type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードの中の定数または変数が特定の条件下で値の欠如を取り扱う必要があるならば、常に、それを適切な型のオプショナルの値として宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a constant, variable, property, or subscript makes use of a private type, the constant, variable, property, or subscript must also be marked as private:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数、変数、プロパティ、または添え字が非公開の型を利用するならば、定数、変数、プロパティ、または添え字はまた、privateと印しされなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a default value is defined, you can omit that parameter when calling the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の値が定義されるならば、あなたは関数を呼ぶときそのパラメータを省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a function type includes more than a single arrow (-&gt;), the function types are grouped from right to left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数型がただ１つだけの矢印（-&gt;）ではなくもっと多く含むならば、その関数型は右から左にグループにされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a match is found, one of the switch statement’s cases sets an optional Int? variable called possibleIntegerValue to an appropriate integer value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの適合が見つけられるならば、switch文のケース節の一つは、possibleIntegerValueと呼ばれるあるオプショナルのInt?変数を適切な整数値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a match is found, the program executes the statements listed within the scope of that case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マッチが見つけられるならば、プログラムはそのケース節のスコープ内で列記される文を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a nonfailable initializer delegates to an init! failable initializer that fails and returns nil, then a runtime error is raised (as if you used the ! operator to unwrap an optional that has a nil value).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できないイニシャライザが、ある失敗してnilを返す失敗できるイニシャライザinit!へと委任するならば、その時は実行時エラーが（まるであなたがnilの値を持つオプショナルをアンラップするために!演算子を使ったかのように）引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a parameter has an argument label, the argument must be labeled when you call the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある引数が引数ラベルを持つならば、その引数は、あなたがその関数を呼ぶ時にラベルを付けられる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a particular dice roll would take you beyond square 25, you must roll again until you roll the exact number needed to land on square 25.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある特定のさいころを振る回が、正方形25を越えてあなたを連れて行くならば、あなたは正方形25に到着するのに必要な正確な数を出すまで、再びさいころを振らなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a period appears at the beginning of a line, it is understood as part of an explicit member expression, not as an implicit member expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ピリオドがある行の初めに現れたならば、それはある明示的なメンバー式の一部として理解されます、ひとつの明示的なメンバー式としてではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a postfix expression that contains an optional-chaining expression is nested inside other postfix expressions, only the outermost expression returns an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式を含む接尾辞式が、他の接尾辞式の内部に入れ子にされるならば、最も外部の式だけがオプショナル型を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a property always takes the same initial value, provide a default value rather than setting a value within an initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロパティが常に同じ初期値をとるならば、イニシャライザ内で値を設定することよりむしろ省略時の値を提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a property declaration includes both the get and set keywords, a conforming type can implement it with a stored variable property or a computed property that is both readable and writeable (that is, one that implements both a getter and a setter).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロパティ宣言がgetとsetキーワードを両方とも含むならば、準拠している型はそれを、保存変数プロパティや計算プロパティを使って実装することができます、それは読み出し可能と書き込み可能の両方であるものです（すなわち、ゲッターとセッターのどちらも実装できるもの）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a property declaration includes only the get keyword, it can be implemented as any kind of property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティ宣言がgetキーワードだけを含むならば、それはどんな種類のプロパティとしてでも実装されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a property marked with the lazy modifier is accessed by multiple threads simultaneously and the property has not yet been initialized, there is no guarantee that the property will be initialized only once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>lazy修飾子で印されるプロパティが複数のスレッドによって同時にアクセスされ、そのプロパティがその時まだ初期化されないならば、そのプロパティがただ一度だけ初期化されるとは保障されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a protocol is marked with the objc attribute, the class requirement is implicitly applied to that protocol; there’s no need to mark the protocol with the class requirement explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルがobjc属性で印されるならば、class要件が暗黙的にそのプロトコルに適用されます；そのプロトコルをclass要件を使って明示的に印する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a protocol requires a property to be gettable and settable, that property requirement cannot be fulfilled by a constant stored property or a read-only computed property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルがプロパティに取得可能かつまた設定可能であることを要求するならば、そのプロパティ要件は、定数保存プロパティまたは読み出し専用の計算プロパティによって満たされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a stored property’s default value requires some customization or setup, you can use a closure or global function to provide a customized default value for that property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある保存プロパティの省略時の値が、いくらかの特別な注文または準備を必要とするならば、あなたは特注の省略時の値をそのプロパティのために用意するために、クロージャまたはグローバル関数を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a stored value in your code is not going to change, always declare it as a constant with the let keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードにおいて保存された値を変化させる予定がないならば、常にletキーワードを使ってそれを定数として宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a subclass overrides a designated initializer from a superclass, and also implements a matching initializer requirement from a protocol, mark the initializer implementation with both the required and override modifiers:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるサブクラスが、スーパークラスからの指定イニシャライザをオーバーライドして、またプロトコルからのイニシャライザ要件にも合致するものを実装するならば、そのイニシャライザ実装をrequiredとoverrideの両方の修飾子を使って印してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a subscript returns a value of optional type—such as the key subscript of Swift’s Dictionary type—place a question mark after the subscript’s closing bracket to chain on its optional return value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある添え字がオプショナル型の値を返すならば ― 例えばスウィフトのDictionary型のキー添え字 ― 疑問符をその添え字の閉じ括弧の後ろに置いて、そのオプショナルの戻り値の上に連鎖を繋げてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a type already conforms to all of the requirements of a protocol, but has not yet stated that it adopts that protocol, you can make it adopt the protocol with an empty extension:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型があるプロトコルの要件の全てにすでに準拠するが、それがそのプロトコルを採用するとまだ示していなかったならば、あなたは空の拡張を使ってそれがそのプロトコルを採用するようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a type is public, but a protocol it conforms to is internal, the type’s conformance to that protocol is also internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型が公開である、しかしそれが準拠するプロトコルは内部であるならば、そのプロトコルに対する型の準拠もまた内部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a value (known as a “raw” value) is provided for each enumeration case, the value can be a string, a character, or a value of any integer or floating-point type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値（「生」の値として知られるもの）が列挙のケース節の各々のために提供されている場合には、その値は文字列、文字、またはあらゆる整数または浮動小数点型の値であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If all of the associated values for an enumeration case are extracted as constants, or if all are extracted as variables, you can place a single var or let annotation before the case name, for brevity:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節の関連値の全てが定数として抽出されるならば、または全てが変数として抽出されるならば、あなたは簡潔にvarまたはlet注釈一つだけをケース節名の前に置くことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If all the elements are equal, then the tuples themselves are equal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての要素が等しいならば、その時それらのタプル自体が等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an available attribute only specifies an introduced argument in addition to a platform name argument, the following shorthand syntax can be used instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>available属性がただintroduced引数だけをプラットフォーム名引数の他に指定するならば、以下の略記構文が代わりに使用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an audio signal comes in with a higher value than 10, it will be capped to this threshold value (as described below).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある音声信号が10より高い値でやってくるならば、それはこの限界値に制限されます（下記のように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an empty string is found, an initialization failure is triggered.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし空の文字列が見つけられたならば、初期化失敗が引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an enumeration has raw values, those values are determined as part of the declaration, which means every instance of a particular enumeration case always has the same raw value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある列挙が生の値を持つならば、それらの値は宣言の一部として決定されます、それはある特定の列挙ケース節のすべてのインスタンスが常に同じ生の値を持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error actually is thrown, you’ll get a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーが実際はスローされたならば、あなたは実行時エラーを受け取るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error is thrown and it matches the SandwichError.outOfCleanDishes case, then the washDishes() function will be called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーがスローされてそれがSandwichError.outOfCleanDishesケース節にマッチするならば、そのときwashDishes()関数が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error is thrown and it matches the SandwichError.missingIngredients case, then the buyGroceries(_:) function is called with the associated [String] value captured by the catch pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーがスローされてそれがSandwichError.missingIngredientsケース節にマッチするならば、そのときbuyGroceries(_:)関数がそのcatchパターンによってキャプチャされた[String]関連値とともに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error is thrown by the code in the do clause, it is matched against the catch clauses to determine which one of them can handle the error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるエラーがdo節の中にあるコードによってスローされるならば、それはcatch節と照合されて、それらの１つがそのエラーを処理できると決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error is thrown while evaluating the try? expression, the value of the expression is nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>try?式を評価している間にエラーがスローされたならば、式の値はnilになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error is thrown, execution immediately transfers to the catch clauses, which decide whether to allow propagation to continue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーがスローされるならば、実行は直ちにcatch節に移ります、それは伝達を継続させるかどうか結論を下します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an implicitly unwrapped optional is nil and you try to access its wrapped value, you’ll trigger a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナルがnilであり、あなたがそれのラップされた値にアクセスしようとするならば、あなたは実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an instance of an optional type contains a value, you can access that value using the postfix operator !, as shown below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル型のインスタンスが値を含むならば、あなたが接尾辞演算子!を使用してその値にアクセスすることができます、以下に示すように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an operator doesn’t begin with a dot, it can’t contain a dot elsewhere.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある演算子がドットで始まらないならば、それはどこか他にドットを含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an operator has no whitespace on the left but is followed immediately by a dot (.), it is treated as a postfix unary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある演算子が左側では空白を持たないが直ちに続けて１つのドット（.）を持つならば、それは接尾辞単項演算子と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an operator has whitespace around both sides or around neither side, it is treated as a binary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある演算子が、空白をそのまわりの両側に持つか、そのまわりのどちら側にも持たないならば、それは二項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an operator has whitespace on the left side only, it is treated as a prefix unary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある演算子が左側だけで空白を持つならば、それは接頭辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an operator has whitespace on the right side only, it is treated as a postfix unary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある演算子が右側だけで空白を持つならば、それは接尾辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an optional has a value, it is considered to be “not equal to” nil:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるオプショナルが値を持つならば、それはnilと「同等でない」と判断されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any of the patterns match, then the case is considered to match.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらのパターンのどれかが合致するならば、そのときそのケース節は合致するとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any of the values in the optional bindings are nil or any Boolean condition evaluates to false, the whole if statement’s condition is considered to be false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何れかのオプショナル束縛の中の値がnilであるか何かのブール条件の評価がfalseになるならば、if文の条件の全体がfalseであるとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If casting to the specified type is guaranteed to fail or is guaranteed to succeed, a compile-time error is raised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定された型へのキャストが失敗すると保証されるまたは成功すると保証される場合には、コンパイル時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If either value is false, the overall expression will also be false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらかの値がfalseならば、全体的な式もまたfalseになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it doesn’t, the new value the convenience initializer assigns will be overwritten by its own class’s designated initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがそうしないならば、便宜イニシャライザが代入する新しい値は、それ自身のクラスの指定イニシャライザによって上書きされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it doesn’t, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがそうしないならば、指定イニシャライザが代入する新しい値は、スーパークラスによってそれ自身の初期化の一部として上書きされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is not possible to retrieve a value from the increment(forCount:) method—either because dataSource is nil, or because the data source does not implement increment(forCount:)—then the increment() method tries to retrieve a value from the data source’s fixedIncrement property instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値をincrement(forCount:)メソッドから取り出すことが可能でないならば ― dataSourceがnilであるから、またはデータ・ソースがincrement(forCount:)を実装しないからのどちらでも ― その時increment()メソッドはその代わりに値をデータ・ソースのfixedIncrementプロパティから取り出そうとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is, a message is printed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしそうならば、メッセージが出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it’s not appropriate to provide a case for every possible value, you can define a default case to cover any values that are not addressed explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべてのあり得る値に対してひとつのケース節を用意することが妥当でないならば、あなたはdefault（省略時）ケース節を定義することで、明確に言及されないどんな値にも対応できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If multiple defer statements appear in the same scope, the order they appear is the reverse of the order they are executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のdefer文が同じスコープに現れるならば、それらが現れる順番が、それらが実行される順番の逆です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no error is thrown, the eatASandwich() function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーがスローされないならば、eatASandwich()関数が呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no error is thrown, the remaining statements in the do statement are executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーかスローされないならば、doの中の残っている文が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no initializers are declared, and all properties of the class declaration were given initial values, call the class’s default initializer, as described in Default Initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザが宣言されない、そして全てのクラス宣言のプロパティが初期値を与えられるならば、クラスの省略時のイニシャライザを呼び出す、省略時のイニシャライザで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no initializers are declared, and all properties of the structure declaration were given initial values, call the structure’s default initializer, as described in Default Initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザが宣言されない、そしてその構造体宣言の全てのプロパティが初期値を与えられたならば、構造体の省略時のイニシャライザを呼び出す、省略時のイニシャライザで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no initializers are declared, call the structure’s memberwise initializer, as described in Memberwise Initializers for Structure Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザが宣言されないならば、その構造体のメンバー関連イニシャライザ呼び出す、構造型のためのメンバー関連イニシャライザで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If none of the catch clauses handle the error, the error propagates to the surrounding scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのcatch節もエラーを処理しないならば、エラーは取り囲んでいるスコープへと伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If part of your code expects a String, type safety prevents you from passing it an Int by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードの一部がStringを期待するならば、型安全はあなたが間違ってそれにIntを渡すことを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If part of your code expects a String, you can’t pass it an Int by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードの一部がStringを予期するならば、あなたは誤ってそれにIntを渡すことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If such a determination can be made, the error is considered handled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのような決定が為されるならば、エラーは処理されたと判断されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If that condition is not met, the code inside the else branch is executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その条件が満たされないならば、else分岐の内部のコードが実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the ! or ? predefined operator has no whitespace on the left, it is treated as a postfix operator, regardless of whether it has whitespace on the right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらかじめ定義された演算子!または?が左側に空白を持たないならば、それは接尾辞演算子と見なされます、それが右側に空白を持つかどうかに関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Int value does not have enough digits for the requested index, the subscript implementation returns 0, as if the number had been padded with zeros to the left:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Int値には要十分な桁が請されたインデックスに対してないならば、この添え字実装は、まるで数が左にゼロを詰められたように0を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the break statement above did not use the gameLoop label, it would break out of the switch statement, not the while statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のbreak文がgameLoopラベルを使用しないならば、それは、while文ではなく、switch文から抜け出すでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the guard statement’s condition is met, code execution continues after the guard statement’s closing brace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>guard文の条件が満たされるならば、コード実行はguard文の閉じ中括弧の後に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the array argument contains an empty array, the minMax(array:) function, as defined above, will trigger a runtime error when attempting to access array[0].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>array引数が空の配列を含んでいるならば、上で定義されるminMax(array:)関数は、array[0]にアクセスしようとする時に実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the case for .west is omitted, this code does not compile, because it does not consider the complete list of CompassPoint cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>.westのためのcaseが省略されるならば、このコードはコンパイルしません、なぜなら、それがCompassPointのケース節の完全なリストを考慮しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the quantity is invalid, the entire initialization process fails immediately and no further initialization code is executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>quantityが無効ならば、初期化処理全体が直ちに失敗して、以降の初期化コードは実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the delegate property is nil, these delegate calls fail gracefully and without error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>delegateプロパティがnilならば、これらの委任先呼び出しはエラーなしで美しく失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the delegate property is non-nil, the delegate methods are called, and are passed the SnakesAndLadders instance as a parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>delegateプロパティがnilでないならば、委任先のさまざまなメソッドが呼ばれます、そしてパラメータとしてSnakesAndLaddersインスタンスを渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the condition evaluates to true, the conditional operator evaluates the first expression and returns its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件がtrueに評価されるならば、条件演算子は最初の式を評価して、その値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the constant name of a constant declaration is a tuple pattern, the name of each item in the tuple is bound to the corresponding value in the initializer expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言の定数名がタプルパターンであるならば、タプルの中の各項目の名前は、イニシャライザ式の中の対応する値に縛りつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the expression does not throw an error, the value of the optional-try expression is an optional containing the value of the expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このexpression（式）がエラーをスローしないならば、オプショナルtry式の値はひとつのオプショナルになり、そのexpression（式）の値を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the expression throws an error, a runtime error is produced.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このexpression（式）がエラーをスローするならば、実行時エラーが生み出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the expression is a tuple, the value must be a tuple with the same number of elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式がタプルであるならば、値は同じ数の要素をもつタプルでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the captured reference will never become nil, it should always be captured as an unowned reference, rather than a weak reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>捕獲された参照が決してnilにならないならば、それは常に、非所有者参照として捕らえられなければなりません、弱い参照ではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the case contains multiple patterns that match the control expression, all of the patterns must contain the same constant or variable bindings, and each bound variable or constant must have the same type in all of the case’s patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御式にマッチする複数のパターンをケース節が含むならば、そのパターンのすべてが同じ定数または変数束縛を含まなければなりません、そして束縛された変数または定数の各々は、そのケース節の持つパターンのすべてで同じ型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the cast fails, a runtime error is raised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャストが失敗したならば、実行時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the class does not inherit from another class, the list can begin with a protocol instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスが別のクラスから継承しないならば、このリストは代わりにプロトコルで始まることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the class inherits any properties from its superclass, one of the superclass’s designated initializers must be called before any of these properties can be set or modified in the current class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスが何らかのプロパティをそのスーパークラスから受け継ぐならば、これらのプロパティのどれかが現在のクラスにおいて設定または修正されることができる前に、スーパークラスの指定イニシャライザのうちの１つが呼ばれなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the closure is never called, the expression inside the closure is never evaluated, which means the array element is never removed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクロージャが決して呼び出されないならば、クロージャ内部の式は決して評価されません、それは配列要素が決して取り除かれないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the condition evaluates to true, code execution continues as usual; if the condition evaluates to false, code execution ends, and your app is terminated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その条件がtrueに評価されるならば、コードの実行は通常通り続きます；条件がfalseに評価されるならば、コードの実行は終わります、そしてあなたのアプリは終了されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the condition is true, a set of statements is repeated until the condition becomes false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その条件がtrueならば、条件がfalseになるまで、ひとかたまりの文が繰り返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the context already provides type information, you can create an empty dictionary with an empty dictionary literal, which is written as [:] (a colon inside a pair of square brackets):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前後関係がすでに型の情報を提供するならば、あなたは[:]（一対の角括弧の内側のひとつのコロン）として書かれる空の辞書リテラルを使って、空の辞書を作成することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the conversion is successful, the actualNumber constant becomes available for use within the first branch of the if statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変換が成功しているならば、定数actualNumberは、if文の最初の分岐の内部での利用に役立てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the dice roll will move the player beyond the final square, the move is invalid and the player needs to roll again.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さいころの目が最後の正方形を越えてプレーヤーを動かすならば、その移動は無効です、そしてプレーヤーは再びさいころを振る必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the dice roll will move the player onto the final square, the game is over.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さいころの目が最後の正方形の上へプレーヤーを動かすならば、ゲームは終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the dictionary contains a value for the requested key, the subscript returns an optional value containing the existing value for that key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その辞書が要請されたキーに対する値を含むならば、添え字はそのキーに対する既存の値を含んでいるオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the downcasting succeeds, the properties of movie are then used to print a description for that Movie instance, including the name of its director.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ダウンキャストが成功するならば、movieのプロパティがそれから使用されて、そのMovieインスタンスの、それのdirector（監督）の名前を含む説明を出力することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the enumeration case you’re trying to match has any associated values, the corresponding enumeration case pattern must specify a tuple pattern that contains one element for each associated value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがマッチしようとしている列挙ケース節が関連値を持つならば、対応する列挙ケース節パターンは、各関連値に対して１つの要素を含んでいるタプルパターンを指定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the first case doesn’t have a value set, its value is 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のケース節が値を設定されないならば、それの値は0です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the first string (s1) is greater than the second string (s2), the backward(_:_:) function will return true, indicating that s1 should appear before s2 in the sorted array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の文字列（s1）が第二の文字列（s2）より大きいならば、backward(_:_:)関数は、ソートされた配列においてs1がs2の前に現れなければならないことを示す、trueを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the function definition includes names for its parameters, the function call must include names before its argument values separated by a colon (:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数定義がそれのパラメータたちの名前を含むならば、関数呼び出しはそれらの引数値の前にその名前をコロン（:）で区切って含まなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the function has a return type of Void, the return type can be omitted as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数がVoidの戻り型を持つならば、次のように戻り型は省略されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the function specifies a return type, you write the throws keyword before the return arrow (-&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関数が戻り型を指定するならば、あなたはthrowsキーワードを戻り矢印（-&gt;）の前に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the function throws an error, the specific error is discarded and the result is nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数がエラーをスローするならば、その具体的なエラーは廃棄されます、そしてその結果はnilになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the initial value doesn’t provide enough information (or if there is no initial value), specify the type by writing it after the variable, separated by a colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の値が十分な情報を提供しないならば（または最初の値がないならば）、変数の後にコロンで区切ってそれを書くことによって型を指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the left side of a Logical OR expression is true, the right side is not evaluated, because it cannot change the outcome of the overall expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理和式の左側がtrueならば、右側は評価されません、なぜならそれが式全体の結論を変えることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the loop finishes without finding a mismatch, the two containers match, and the function returns true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループが一致しない組合せを見つけることなく終わるならば、２つのコンテナは合致します、そして関数はtrueを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the match succeeds, the type of the matched value is cast to the pattern specified in the right-hand side of the as pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マッチが成功するならば、マッチされた値の型は、asパターンの右手側で指定されるパターンにキャストされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the new value of currentLevel (after any capping) is higher than any value previously received by any AudioChannel instance, the property observer stores the new currentLevel value in the maxInputLevelForAllChannels type property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>currentLevelの新しい値が（制限を受けた後に）あらゆるAudioChannelインスタンスで以前に受けた値より高いならば、プロパティオブザーバーは、新しいcurrentLevel値を型プロパティmaxInputLevelForAllChannelsに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the new value of currentLevel is greater than the allowed thresholdLevel, the property observer caps currentLevel to thresholdLevel.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>currentLevelの新しい値が許可されたthresholdLevelより大きいならば、このプロパティオブザーバーはcurrentLevelをthresholdLevelに制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the omitted types can’t be inferred, a compile-time error is raised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略された型が推論されることができないならば、コンパイル時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the optional Int does contain a value—that is, if the delegate and method both exist, and the method returned a value—the unwrapped amount is added onto the stored count property, and incrementation is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルのIntが値を含むならば ― すなわち、委任先とメソッドが両方とも存在する、そしてメソッドが値を返すならば ― アンラップされたamountが保存countプロパティへと加えられます、そして増加作業は完了です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the optional contains a value, the property, method, or subscript call succeeds; if the optional is nil, the property, method, or subscript call returns nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのオプショナルが値を含むならば、プロパティ、メソッド、または添え字の呼び出しは成功します；そのオプショナルがnilであるならば、プロパティ、メソッド、または添え字の呼び出しはnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the optional value is nil, the conditional is false and the code in braces is skipped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの値がnilならば、この条件文はfalseになります、そして波括弧の中のコードはスキップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the optional value is missing, the default value is used instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル値が見つからないならば、省略時の値が代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the parameter is omitted when calling the function, the default value is used instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメーターが関数呼び出し時に省略されるならば、省略時の値が代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the player has moved on or beyond square number 25, the loop’s condition evaluates to false and the game ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレーヤーが25番目の正方形の上にまたは越えて移動したならば、ループの条件はfalseに評価してゲームは終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the protocol only requires a property to be gettable, the requirement can be satisfied by any kind of property, and it is valid for the property to be also settable if this is useful for your own code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルがプロパティに取得可能なことを要求するだけならば、その要件はどんなプロパティにでもよって満たされることができます、そして、それが同時にまた設定可能であることは、もしそれがあなた自身のコードに役立つ場合には、そのプロパティにとって有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the raw-value type is specified as Int and you don’t assign a value to the cases explicitly, they are implicitly assigned the values 0, 1, 2, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし生の値型がIntとして指定され、あなたが明示的に値をそれぞれのケース節に割り当てないならば、それらは暗黙のうちに値0、1、2、等々を割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the raw-value type is specified as String and you don’t assign values to the cases explicitly, each unassigned case is implicitly assigned a string with the same text as the name of that case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「生の値」型がStringとして指定されてあなたが明示的に値をそのケース節に割り当てないならば、未割り当てのケース節のそれぞれは暗黙的にそのケース節の名前である同じテキストをもつ文字列を割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the right side of the assignment is a tuple with multiple values, its elements can be decomposed into multiple constants or variables at once:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代入の右側が、複数の値をもつタプルであるならば、その要素は同時に複数の定数または変数に分解されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the specified key isn’t contained in the dictionary, the subscript returns nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定されたキーがその辞書に含まれないならば、添え字はnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the square’s value is greater than 0, it is the base of a ladder, and is represented by ▲.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正方形の値が0より大きいならば、それははしごの基部であって、▲によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the square’s value is less than 0, it is the head of a snake, and is represented by ▼.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正方形の値が0より小さいならば、それはヘビの頭であって、▼によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the stack is empty, topItem returns nil; if the stack is not empty, topItem returns the final item in the items array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックが空ならば、topItemはnilを返します；スタックが空でないならば、topItemはitems配列の最後の項目を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the subclass overrides all of the superclass’s designated initializers, it inherits the superclass’s convenience initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスがスーパークラスの指定イニシャライザのすべてをオーバーライドするならば、それはスーパークラスの便宜イニシャライザたちを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the subscript declaration includes both the get and set keywords, a conforming type must implement both a getter and a setter clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言がgetとsetキーワードを両方とも含むならば、準拠している型はゲッターとセッター節を両方とも実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the subscript declaration includes only the get keyword, a conforming type must implement at least a getter clause and optionally can implement a setter clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言がgetキーワードだけを含むならば、準拠している型は、少なくともゲッター節を実装しなければなりません、そして随意にセッター節を実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the total number of steps has increased, a message is printed to indicate how many new steps have been taken.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総歩数が増加したならば、どれくらいの新たな歩数がとられたかについて示すためにメッセージが出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the trailing closure is the function’s only argument, the parentheses can be omitted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後付クロージャが関数のただ一つの引数であるならば、括弧は省略されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the tuple type to be returned from a function has the potential to have “no value” for the entire tuple, you can use an optional tuple return type to reflect the fact that the entire tuple can be nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数から返されるタプル型がタプル全体として「値がない」見込みがあるならば、あなたはタプル全体がnilであることが出来るのを反映するためにオプショナルタプルの戻り型を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the two items are not equal, then the two containers do not match, and the function returns false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの項目が等しくないならば、２つのコンテナは合致しません、そして関数はfalseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type already implements all of the requirements, you can leave the body of the extension declaration empty.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その型が要件の全てをすでに実装するならば、あなたは拡張宣言の本文を空のままにしておいてかまいません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type of the expression’s value is a class, you can mark the expression in a capture list with weak or unowned to capture a weak or unowned reference to the expression’s value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この式の値の型がクラスならば、あなたはその式をキャプチャリストの中でweakまたはunownedを使って印を付けて、式の値に対する弱いまたは非所有の参照をキャプチャすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type you are trying to retrieve is already optional, it will not become more optional because of the chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが取り出そうとしている型がすでにオプショナルならば、それは連鎖であることからさらにオプショナルにはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type you are trying to retrieve is not optional, it will become optional because of the optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが取り出そうとしている型がオプショナルでないならば、それはオプショナル連鎖であることからオプショナルになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value before the ? is nil, everything after the ? is ignored and the value of the whole expression is nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>?の前の値がnilならば、?の後のすべてのものは、無視されて、その全体の式の値はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value is nil, no operation is performed and therefore no runtime error is produced.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その値がnilならば、演算は実行されません、したがって、実行時エラーは生じません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of a is non-nil, the value of b is not evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>aの値がnilでないならば、bの値は評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of age is negative, as in the code above, then age &gt;= 0 evaluates to false, and the assertion is triggered, terminating the application.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードの場合のように、ageの値が負数であるならば、そのときage &gt;= 0はfalseに評価されます、そして表明が起動して、アプリケーションを終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of integerToDescribe is one of the prime numbers in the list, the function appends text to the end of description, to note that the number is prime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>integerToDescribeの値がリストにある素数の一つであるならば、数が素数であることを書き留めるために、関数はdescriptionの終わりにテキストを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of a is equal to b, then the resulting range will be empty.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>aの値がbと等しいならば、そのとき結果として生じる範囲は空になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of the expression is not nil, the optional value is unwrapped and returned with the corresponding nonoptional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式の値がnilでないならば、オプショナルの値は包装を取られて、対応する非オプショナル型で返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of the expression does not match the value of the return type declared in the function or method declaration, the expression’s value is converted to the return type before it is returned to the calling function or method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式の値が関数またはメソッド宣言において宣言される戻り型の値にマッチしないならば、それが関数またはメソッドを呼んでいるところに返される前に、式の値は戻り型に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of the optional-chaining expression is nil, all of the other operations in the postfix expression are ignored and the entire postfix expression evaluates to nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式の値がnilならば、接尾辞式での他の演算の全ては無視されます、そして接尾辞式の全体はnilに評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of the optional-chaining expression is nil, the expression on the right hand side of the assignment operator is not evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式の値がnilならば、代入演算子の右手側の式は評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of the optional-chaining expression is not nil, the value of the optional-chaining expression is unwrapped and used to evaluate the rest of the postfix expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式の値がnilでないならば、オプショナル連鎖式の値はアンラップされて、接尾辞式の残りを評価するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value returned is not nil, it is assigned to the item pattern, the program executes the statements, and then continues execution at the beginning of the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>返される値がnilでないならば、それはitem（項目）パターンに割り当てられて、プログラムはstatements（文）を実行して、それからループの初めに戻って実行を続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are expressions of multiple types, T is their closest common supertype.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数の型の式があるならば、Tはそれらの最も近い共通のスーパー型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are expressions of multiple types, Key and Value are the closest common supertype for their respective values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数の型の式があるならば、KeyとValueはそれらめいめいの値に対して最も近い共通のスーパー型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are not enough coins, Bank returns a smaller number than the number that was requested (and returns zero if no coins are left in the bank).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>十分なコインがないならば、Bankは要請された数より少ない数を返します（そしてコインが胴元に残っていないならばゼロを返します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there isn’t suitable type information available, Swift infers that the literal’s type is one of the default literal types defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>適した型情報が得られなかったならば、スウィフトはそのリテラルの型はスウィフト標準ライブラリで定義される省略時のリテラル型の１つと推論します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If they contain a different number of items, there is no way that they can match, and the function returns false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが異なる数の項目を含むならば、それらが合致することができる術はありません、そして関数はfalseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is not the case, Int is preferred, even when the values to be stored are known to be non-negative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合でないならば、保存される値が負数でないということがわかっているときでさえ、Intがむしろ好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is successful, set a new temporary constant called movie to the value stored in the returned optional Movie.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが成功するならば、movieと呼ばれる新しい一時的な定数を、返されたオプショナルのMovieに格納される値に設定してください。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If type information can be inferred, you can write an empty array as [] and an empty dictionary as [:]—for example, when you set a new value for a variable or pass an argument to a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型情報が推論されることが出来るならば、あなたは空の配列を[]のように、そして空の辞書を[:]のように書くことができます ― 例えば、あなたが新しい値を変数に設定したり、関数に引数を渡す時に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we’ve entered the correct door code and passed the retina scan, or if we have a valid door key, or if we know the emergency override password, then allow access.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>私達が正しいドア・コードを入力して網膜走査をパスしたならば、または私達が有効なドア・キーを持つならば、または私達が非常用解除パスワードを知っているならば、その時アクセスを許可してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you access the variable or property after the object has been deallocated, its value is nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが変数またはプロパティにそのオブジェクトがデアロケートされてしまった後にアクセスするならば、それの値はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you apply the objc attribute to an enumeration, each enumeration case is exposed to Objective-C code as the concatenation of the enumeration name and the case name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがobjc属性をある列挙に適応したならば、個々の列挙ケース節はObjective-Cコードに列挙名とそのケース節名を連結したものとして暴露されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you apply the objc attribute to a class or protocol, it’s implicitly applied to the Objective-C compatible members of that class or protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがobjc属性をあるクラスまたはプロトコルに適用するならば、それは暗黙のうちにそのクラスやプロトコルのObjective-C互換メンバーに適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are familiar with C, you will know that C enumerations assign related names to a set of integer values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがCに精通しているならば、あなたはCの列挙がひとまとめの整数値それぞれに対して関連した名前を割り当てるということを知っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are working with particularly long string values, be aware that the characters property must iterate over the Unicode scalars in the entire string in order to determine the characters for that string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが特に長い文字列値を扱う場合は、charactersプロパティは、その文字列の文字を決定する目的で文字列全体のユニコード・スカラーのすべてに繰り返しを行わなければならないことを知っていてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assign a closure to a property of a class instance, and the closure captures that instance by referring to the instance or its members, you will create a strong reference cycle between the closure and the instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、あるクロージャをあるクラスインスタンスのプロパティに代入して、そしてクロージャがそのインスタンスを、インスタンスまたはそのメンバ（属するもの）に言及することによって捕獲するならば、あなたはクロージャとインスタンスの間で強い参照循環をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assign a non-nil value to userDefinedColorName and perform the nil-coalescing operator check again, the value wrapped inside userDefinedColorName is used instead of the default:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがnilでない値をuserDefinedColorNameに代入して、nil合体演算子による確認をふたたび実行するならば、userDefinedColorName内にラップされた値は省略時のものの代わりに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assign a value to a property within its own didSet observer, the new value that you assign replaces the one that was just set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが独自のdidSetオブザーバーの内部で値をプロパティに代入するならば、あなたが代入する新しい値はついさっき設定されたものを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assign an array, a set, or a dictionary to a constant, that collection is immutable, and its size and contents cannot be changed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある配列、集合、または辞書をある定数に代入したならば、そのコレクションは不変になります、そしてそれの大きさと内容は変更されることが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assign an instance of a reference type to a constant, you can still change that instance’s variable properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが参照型のインスタンスを定数に代入するならば、あなたは依然としてそのインスタンスの変数プロパティを変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assign the same Person instance to two more variables, two more strong references to that instance are established:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが同じPersonインスタンスをさらに２つの変数に代入するならば、そのインスタンスへのさらに２つの強い参照が確立されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you break that strong reference, there are no more strong references to the Apartment instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがその強い参照を壊すならば、Apartmentインスタンスへの強い参照はもうこれ以上ありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you break two of these strong references (including the original reference) by assigning nil to two of the variables, a single strong reference remains, and the Person instance is not deallocated:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが変数のうちの２つにnilを代入することによってこれらの強い参照のうちの（最初の参照を含む）２つを壊すならば、１つの強い参照が残ります、そしてPersonインスタンスは割り当て解除されません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you call this method on an optional value with optional chaining, the method’s return type will be Void?, not Void, because return values are always of an optional type when called through optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこのメソッドをあるオプショナルの値の上でオプショナル連鎖を使って呼ぶならば、メソッドの戻り値はVoid?になります、Voidではなく、なぜならば、オプショナル連鎖を通して呼び出されるとき戻り値は常にオプショナルだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you combine integer and floating-point literals in an expression, a type of Double will be inferred from the context:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある式の中で整数と浮動小数点リテラルを結合するならば、その前後関係からDoubleの型が推論されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create a CartItem instance with a nonempty name and a quantity of 1 or more, initialization succeeds:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがCartItemインスタンスを空でない名前と1以上の数量で作成するならば、初期化は成功します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create a TrackedString instance and modify its string value a few times, you can see the numberOfEdits property value update to match the number of modifications:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがTrackedStringインスタンスをつくって、２、３回その文字列値を修正するならば、あなたはnumberOfEditsプロパティが修正の数に合うように更新されるのを見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create a new Person instance, its residence property is default initialized to nil, by virtue of being optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが新しいPersonインスタンスをつくるならば、そのresidenceプロパティは、オプショナルである長所によって、省略時でnilに初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create a new String value, that String value is copied when it is passed to a function or method, or when it is assigned to a constant or variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが新しいString値をつくるならば、そのString値は、それが関数またはメソッドに渡される時に、またはそれが定数または変数に代入される時に、コピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create a new instance of Train and call its makeNoise() method, you can see that the Train subclass version of the method is called:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがTrainの新しいインスタンスを作成してそれのmakeNoise()メソットを呼び出すならば、あなたはサブクラス板のTrainメソッドが呼び出されるのを見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create a second incrementer, it will have its own stored reference to a new, separate runningTotal variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが第２のインクリメンタをつくるならば、それは、独自に保存された、ある新しい、別個のrunningTotal変数への参照を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create a second player, whom you try to move to a level that is not yet unlocked by any player in the game, the attempt to set the player’s current level fails:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが二番目のプレーヤーを作成して、あなたがその人をそのゲームにおいてどのプレーヤーによってもまだ錠を開けられていないレベルへ動かそうとするならば、プレーヤーの現在のレベルを決めるその試みは失敗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create an array, a set, or a dictionary, and assign it to a variable, the collection that is created will be mutable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある配列、集合、または辞書を作成して、それをある変数に代入したならば、作成されたコレクションは可変となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create an instance of Bicycle, you can call its inherited description computed property to see how its numberOfWheels property has been updated:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがBicycleのインスタンスを作成するならば、あなたはそれの継承されたdescription計算プロパティを呼び出して、どのようにそれのnumberOfWheelsプロパティが更新されたか見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create an instance of Tandem, you can work with any of its new and inherited properties, and query the read-only description property it inherits from Vehicle:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがTandemのインスタンスを作成するならば、あなたはそれの新規および継承するプロパティを扱うことができて、それがVehicleから継承する読み込み専用のdescriptionプロパティについて問い合わせることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create an instance of a structure and assign that instance to a constant, you cannot modify the instance’s properties, even if they were declared as variable properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが構造体のインスタンスをつくって、そのインスタンスを定数に代入するならば、あなたはそのインスタンスのもつプロパティを、たとえそれらが変数プロパティとして宣言されたとしても、修正することはできません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create an instance of the Car class and set its gear and currentSpeed properties, you can see that its description property returns the tailored description defined within the Car class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがCarクラスのインスタンスを作成して、それのgearとcurrentSpeedプロパティを設定するならば、あなたはそれのdescriptionプロパティがCarクラス内で定義される特注の説明を返すのを見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create and assign an actual Residence instance to john.residence, with one or more Room instances in its rooms array, you can use the Residence subscript to access the actual items in the rooms array through optional chaining:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが実際のResidenceインスタンスをつくってjohn.residenceに代入して、そのrooms配列の中に一つ以上のRoomインスタンスをもつならば、あなたはResidence添え字を使って、オプショナル連鎖を通してrooms配列の実際の項目にアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create your own class or structure to represent a complex data model, for example, then the meaning of “equal to” for that class or structure is not something that Swift can guess for you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが例えば独自のクラスまたは構造体を作成してある複合データモデルを表すならば、そのときそのクラスまたは構造体のための「同等」の意味することはスウィフトがあなたのために推測することができる何かではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define a new protocol that inherits from an existing protocol, the new protocol can have at most the same access level as the protocol it inherits from.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが既存のプロトコルから継承する新しいプロトコルを定義するならば、新しいプロトコルは最大ではそれが継承するプロトコルと同じアクセス水準を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define a protocol instance method requirement that is intended to mutate instances of any type that adopts the protocol, mark the method with the mutating keyword as part of the protocol’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがそのプロトコルを採用するあらゆる型のインスタンスを変化させることを意図したインスタンスメソッド要件プロトコルを定義するならば、プロトコルの定義の一部としてそのメソッドにmutatingキーワードで印をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define a public protocol, the protocol’s requirements require a public access level for those requirements when they are implemented.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある公開プロトコルを定義するならば、そのプロトコルは、それらの要件のために対してそれらが実装されるときに公開アクセス水準を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define a type’s access level as internal or public (or use the default access level of internal without specifying an access level explicitly), the default access level of the type’s members will be internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある型のアクセス水準を内部または公開として定義する（または明示的にアクセス水準を指定することなく省略時のアクセス水準である内部を使用する）ならば、その型のメンバーの省略時のアクセス水準は内部になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define a type’s access level as private or file private, the default access level of its members will also be private or file private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある型のアクセス水準を非公開またはファイル外非公開として定義するならば、そのメンバーの省略時のアクセス水準も、非公開またはファイル外非公開になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define an enumeration with a raw-value type, the enumeration automatically receives an initializer that takes a value of the raw value’s type (as a parameter called rawValue) and returns either an enumeration case or nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが列挙を「生の値」型を使って定義したならば、その列挙は生の値の方の値を（rawValueと呼ばれるパラメーターとして）とって、一つの列挙ケース節かnilのどちらかを返すイニシャライザを自動的に受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define an extension to add new functionality to an existing type, the new functionality will be available on all existing instances of that type, even if they were created before the extension was defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが新しい機能性を既存の型に加えるために拡張を定義するならば、新しい機能性はその型の全ての既存の例で利用可能になります、たとえそれらが拡張が定義される前につくられたとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define an optional variable without providing a default value, the variable is automatically set to nil for you:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが既定値を提供することなくオプショナルの変数を定義するならば、その変数はあなたのために自動的にnilに設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you didn’t mark the parameter of this function with @escaping, you would get a compiler error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの関数のパラメータを@escapingで印しないならば、あなたはコンパイラエラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not provide a setter name, the default parameter name to the setter is newValue, as described in Shorthand Setter Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがセッター名を提供しないならば、短縮形セッター宣言で記述されるように、セッターへの省略時のパラメータ名はnewValueです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not provide a setter name, the default parameter name to the setter is value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがセッター名を提供しないならば、セッターへの省略時ののパラメータ名はvalueです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not provide setter names, the default parameter name to the willSet observer is newValue and the default parameter name to the didSet observer is oldValue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがセッター名を提供しないならば、willSetオブザーバーへの初期状態でのパラメータ名はnewValueです、そして、didSetオブザーバーへの初期状態でのパラメータ名はoldValueです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not use this attribute, supply a main.swift file with code at the top level that calls the NSApplicationMain(_:_:) function as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの属性を使わないならば、以下のようにNSApplicationMain(_:_:)関数を呼ぶトップレベルコードを持つmain.swiftファイルを提供してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not use this attribute, supply a main.swift file with code at the top level that calls the UIApplicationMain(_:_:_:) function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの属性を使わないならば、UIApplicationMain(_:_:_:)関数を呼ぶトップレベルでのコードを持つmain.swiftファイルを提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not want to use an argument label for an initializer parameter, write an underscore (_) instead of an explicit argument label for that parameter to override the default behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがイニシャライザ・パラメータのために引数ラベルを使うことを望まないならば、そのパラメータに対して明示的な引数ラベルを書くのではなくひとつのアンダーバー（_）を書いて、省略時の挙動をオーバーライドしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t explicitly write self, Swift assumes that you are referring to a property or method of the current instance whenever you use a known property or method name within a method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが明示的にselfを書かないならば、スウィフトは、あなたがメソッド内で既知のプロパティまたはメソッド名を使用するときはいつでも、あなたが現在のインスタンスに属するプロパティまたはメソッドに言及していると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t need each value from a sequence, you can ignore the values by using an underscore in place of a variable name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある連続物からの各値を必要としないならば、あなたは変数の名前の代わりにアンダースコアを使うことによってその値を無視することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t need to compute the property but still need to provide code that is run before and after setting a new value, use willSet and didSet.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、プロパティを計算する必要がないにもかかわらず新しい値の設定の前や後で実行されるコードを提供する必要があるならば、willSetやdidSetを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t provide an initial value when you declare an optional variable or property, its value automatically defaults to nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの変数またはプロパティを宣言する時にあなたが最初の値を提供しないならば、その値は自動的に省略時のnilになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t specify the type of value you need, Swift uses type inference to work out the appropriate type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが必要とする値の型をあなたが指定しないならば、スウィフトは適切な型を導きだすために型推論を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t want an argument label for a parameter, write an underscore (_) instead of an explicit argument label for that parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあるパラメーターに引数ラベルを使うことを望まないならば、そのパラメーターに対して明示的な引数ラベルの代わりにひとつのアンダースコア（_）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t want to modify the inherited property’s value within the overriding getter, you can simply pass through the inherited value by returning super.someProperty from the getter, where someProperty is the name of the property you are overriding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがオーバーライドのゲッター内で継承されたプロパティの値を修正したくないならば、あなたは、そのゲッターからsuper.somePropertyを返すことによって、単に継承された値を通り抜けさせることができます、ここでsomePropertyはあなたがオーバーライドしているプロパティの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t write the parameter name and parentheses within your implementation, the parameter is made available with a default parameter name of newValue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがパラメータ名と丸括弧をあなたの実装内で書かないならば、パラメータは省略時のパラメータ名のnewValueを使って利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you extend a file-private type, any new type members you add have a default access level of file private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあるファイル外非公開型を拡張するならば、あなたが加えるどんな新しい型メンバーでも省略時のアクセス水準であるファイル外非公開を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you extend a private type, any new type members you add have a default access level of private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある非公開型を拡張するならば、あなたが加えるどんな新しい型メンバーでも省略時のアクセス水準である非公開を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you extend a public or internal type, any new type members you add have a default access level of internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある公開または内部型を拡張するならば、あなたが加えるどんな新しい型メンバーでも省略時のアクセス水準である内部を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you group together aspects of your app’s code as a stand-alone framework—perhaps to encapsulate and reuse that code across multiple applications—then everything you define within that framework will be part of a separate module when it is imported and used within an app, or when it is used within another framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、あなたのアプリのコードのさまざまな面をスタンドアローンのフレームワークとして ― おそらくそのコードをカプセル化して複数のアプリケーションに渡って再利用するために ― １つにまとめるならば、あなたがそのフレームワーク内で定義するすべてのものは、それがアプリ内にインポートされて使われるとき、またはそれがもう一つのフレームワーク内で使われるとき、別々のモジュール部分になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have experience with C, C++, or Objective-C, you may know that these languages use pointers to refer to addresses in memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがC、C++、またはObjective-Cで経験を持つならば、あなたはこれらの言語がメモリのアドレスに言及するためにポインターを使用するということを知っているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have experience with Objective-C, you may know that it provides two ways to store values and references as part of a class instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがObjective-Cでの経験を持つならば、あなたはそれがクラスインスタンスの一部として値や参照を保存するために２つの方法を提供するということを知っているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have written code in C or Objective-C, this syntax looks familiar to you—in Swift, this line of code is a complete program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがCまたはObjective-Cでコードを書いたことがあるならば、この構文はあなたにとって馴染みがあるものでしょう ― スウィフトにおいて、コードのこの行は、ひとつの完全なプログラムです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you implement a willSet observer, it’s passed the new property value as a constant parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがwillSetオブザーバーを実装するならば、それは新しいプロパティ値を定数パラメータとして渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you implement the Togglable protocol for a structure or enumeration, that structure or enumeration can conform to the protocol by providing an implementation of the toggle() method that is also marked as mutating.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがTogglableプロトコルをある構造体または列挙のために実装するならば、その構造体または列挙は、同様にmutatingとして印されるtoggle()メソッドの実施を提供することによって、このプロトコルに準拠できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you mark a protocol instance method requirement as mutating, you do not need to write the mutating keyword when writing an implementation of that method for a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがインスタンスメソッド要件プロトコルにmutatingとして印するならば、あるクラスのためにそのメソッドの実装を書くとき、あなたはmutatingキーワードを書く必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you mark an initializer with the required declaration modifier, you don’t also mark the initializer with the override modifier when you override the required initializer in a subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがイニシャライザをrequired宣言修飾子で印するならば、あなたはさらにそのイニシャライザをoverride宣言修飾子で印することは、あなたがサブクラスの必須イニシャライザをオーバーライドする場合には、しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you name the elements in a tuple, you can use the element names to access the values of those elements:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがタプルの要素に名をつけるならば、あなたはそれらの要素の値にアクセスするために要素名を使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need C-style fallthrough behavior, you can opt in to this behavior on a case-by-case basis with the fallthrough keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがC形式のフォールスルー挙動を必要とするならば、あなたはfallthroughキーワードを使ってそれぞれ個別にこの挙動を選択できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need the behavior of the swapTwoValues(_:_:) function in your own code, you can use Swift’s existing swap(_:_:) function rather than providing your own implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあなた自身のコードにおいてswapTwoValues(_:_:)関数の挙動を必要とするならば、あなたはあなた自身の実施を提供するのではなくスウィフトの既存のswap(_:_:)関数を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need the integer index of each item as well as its value, use the enumerated() method to iterate over the array instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがその値のみならず各項目の整数インデックスを必要とするならば、代わりにenumerated()メソッドを配列じゅうを繰り返し処理するのに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to capture an in-out parameter without mutating it or to observe changes made by other code, use a capture list to explicitly capture the parameter immutably.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがin-outパラメータをキャプチャする必要がそれを変化させることなしにまたは他のコードによってなされる変更を監視するためにあるならば、キャプチャリストを使うことで明示的にそのパラメータを不変にキャプチャしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to capture and mutate an in-out parameter, use an explicit local copy, such as in multithreaded code that ensures all mutation has finished before the function returns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがin-outパラメータをキャプチャして変化させる必要があるならば、明示的なローカルコピーを使ってください、例えばすべての変化がその関数が返るまえに完了してしまっていることを保証するマルチスレッド化されたコードにおいてなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to convert a value to a different type, explicitly make an instance of the desired type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある値を異なる型に変換する必要があるならば、明示的に望む型のインスタンスにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to give a constant or variable the same name as a reserved Swift keyword, surround the keyword with backticks (`) when using it as a name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが予約済みのスウィフトのキーワードと同じ名前を定数または変数に与える必要があるならば、名前としてそれを使うときバッククォート（`）でそのキーワードを囲んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to pass a closure expression to a function as the function’s final argument and the closure expression is long, it can be useful to write it as a trailing closure instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが関数の最後の引数としてクロージャ式を関数に渡す必要がある、そして、クロージャ式が長いならば、代わりに後付クロージャとしてそれを書くことは役に立つことがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to use a dictionary’s keys or values with an API that takes an Array instance, initialize a new array with the keys or values property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、ある辞書のキーまたは値を、Arrayインスタンスを引数にとるAPIで使う必要があるならば、keysまたはvaluesプロパティによってひとつの新しい配列を初期化してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you omit the parameter names and both types, omit the in keyword before the statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがパラメータ名と両方の型を省略するならば、文の前のinキーワードを省略します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you omit the precedence group for an operator, Swift uses the default precedence group, DefaultPrecedence, which specifies a precedence just higher than TernaryPrecedence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが優先順位グループを省略するならば、スウィフトは省略時の優先順位グループ、DefaultPrecedenceを使います、それはTernaryPrecedenceのすぐ上の優先順位を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you omit the version number, omit the colon (:) as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこのバージョン番号を省略したならば、コロン（:）も同様に省いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you omit these parentheses, you are trying to assign the closure itself to the property, and not the return value of the closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの丸括弧を省略するならば、あなたはプロパティにクロージャそれ自体を代入することを試みています、つまりそのクロージャの戻り値でなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you only need some of the tuple’s values, ignore parts of the tuple with an underscore (_) when you decompose the tuple:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがタプルの値の一部を必要とするだけならば、あなたがタプルを分解するとき、アンダースコア（_）で、タプルの一部を無視してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you pass a property that has observers to a function as an in-out parameter, the willSet and didSet observers are always called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがオブザーバーを持つプロパティをある関数へin-outパラメータとして渡すならば、willSetとdidSetオブザーバーは常に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you pass an empty string value to the failable initializer’s species parameter, the initializer triggers an initialization failure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが失敗できるイニシャライザのspeciesパラメータに空の文字列値を渡すならば、イニシャライザは初期化失敗を引き起こします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you provide a new initializer with an extension, you are still responsible for making sure that each instance is fully initialized once the initializer completes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが新しいイニシャライザを拡張によって提供する場合、あなたは依然として、一旦イニシャライザが完了するならば各インスタンスが完全に初期化されることを確かにする責任があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you provide a setter as part of a property override, you must also provide a getter for that override.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがプロパティオーバーライドの一部としてセッターを提供するならば、あなたはまたそのオーバーライドのためにゲッターも提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you provide a setter name, it is used as the name of the parameter to the setter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがセッター名を提供するならば、それがセッターにパラメータの名前として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you provide an initial value for a constant or variable at the point that it is defined, Swift can almost always infer the type to be used for that constant or variable, as described in Type Safety and Type Inference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが最初の値を定数または変数に、それが定義される時点で提供するならば、「型安全と型推論」で記述されるように、スウィフトはたいていその定数または変数のために使われる型を推測することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you provide setter names, they are used as the parameter names to the willSet and didSet observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがセッター名を提供するならば、それらがwillSetとdidSetオブザーバーへのパラメータ名として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you read strictly from left to right, you might expect the expression to be calculated as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが厳密に左から右に読んだならば、あなたはこの式を以下のように計算されることを期待するでしょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you really do need to use an optional value as an Any value, you can use the as operator to explicitly cast the optional to Any, as shown below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが本当にオプショナル値をAny値として使う必要があるならば、あなたはas演算子を使って明示的にオプショナルをAnyへキャストすることが、以下で示すように行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you set an actual Address instance as the value for john.residence.address, and set an actual value for the address’s street property, you can access the value of the street property through multilevel optional chaining:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが実際のAddressインスタンスをjohn.residence.addressのための値として設定して、そしてアドレスのもつstreetプロパティのために実際の値を設定するならば、あなたは複数階層のオプショナル連鎖を通してstreetプロパティの値にアクセスすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you set the currentLevel of the left channel to 7, you can see that the maxInputLevelForAllChannels type property is updated to equal 7:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが左のチャンネルのcurrentLevelを7に設定するならば、あなたは型プロパティmaxInputLevelForAllChannelsが7に等しくなるよう更新されるのを見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you set the paragraph variable to nil and break its strong reference to the HTMLElement instance, neither the HTMLElement instance nor its closure are deallocated, because of the strong reference cycle:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがparagraph変数をnilに設定して、HTMLElementへのそれの強い参照を壊すならば、HTMLElementインスタンスもそれのクロージャも割り当て解除されません、強い参照循環のためです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you set the strong reference from the paragraph variable to nil, the HTMLElement instance is deallocated, as can be seen from the printing of its deinitializer message in the example below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが強い参照であるparagraph変数をnilに設定するならば、そのHTMLElementインスタンスは、下の例におけるそれのデイニシャライザのメッセージの出力から分かるように、割り当て解除されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you specify a type by name, you can access the type’s initializer without using an initializer expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある型を名前で指定するならば、あなたはその型のイニシャライザにイニシャライザ式を使うことなくアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you subtract 1 from 00000000 using the overflow subtraction operator (&amp;-), the number will overflow and wrap around to 11111111, or 255 in decimal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがオーバフロー減算演算子（&amp;-）を使用して00000000から1を減ずるならば、その数はあふれ出てぐるっと送り込まれて11111111、10進での255になります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you throw an error in a function, the function returns immediately and the code that called the function handles the error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが関数においてエラーをスローするならば、その関数は直ちに返ります、そして関数を呼んだコードがエラーを取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to access numberOfRooms with the same optional chaining as before, it will now return an Int? that contains the default numberOfRooms value of 1:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが前と同じオプショナル連鎖でnumberOfRoomsにアクセスしようとするならば、それは今では省略時のnumberOfRooms値の1を含むInt?を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to access an unsafe unowned reference after the instance that it refers to is deallocated, your program will try to access the memory location where the instance used to be, which is an unsafe operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが安全でない非所有参照に、それが参照するインスタンスがデアロケートされてしまった後にアクセスすることを試みるならば、あなたのプログラムはそのインスタンスが存在するのに使われたところの位置でメモリにアクセスしようと試みるでしょう、それはメモリ安全ではない操作です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to access or modify a value for an index that is outside of an array’s existing bounds, you will trigger a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが配列のもつ存在する境界の外にあるインデックスに対する値にアクセスまたは変更しようとするならば、あなたは実行時エラーの引き金を引くことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to access the numberOfRooms property of this person’s residence, by placing an exclamation mark after residence to force the unwrapping of its value, you trigger a runtime error, because there is no residence value to unwrap:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの人のresidenceのnumberOfRoomsプロパティに、その値を強制アンラップするためresidenceの後に感嘆符を置くことによって、アクセスしようとするならば、あなたは実行時エラーを引き起こします、なぜなら、アンラップするresidence値はないからです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to access the value of an unowned reference after that instance has been deallocated, you’ll get a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある非所有者参照の値に、そのインスタンスがデアロケートされてしまった後にアクセスしようとするならば、あなたは実行時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to access the variable or property after the object has been deallocated, a runtime error is raised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが変数またはプロパティにそのオブジェクトがデアロケートされてしまった後にアクセスすることを試みるならば、実行時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to access the variable or property after the object has been deallocated, you’ll access the memory at the location where the object used to be, which is a memory-unsafe operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが変数またはプロパティに、そのオブジェクトがデアロケートされてしまった後にアクセスすることを試みるならば、あなたはそのオブジェクトが存在するのに使われたところの位置でメモリにアクセスするでしょう、それはメモリ安全ではない操作です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to create a CartItem instance with a quantity value of 0, the CartItem initializer causes initialization to fail:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがCartItemインスタンスを0のquantity値で作成することを試みるならば、CartItemイニシャライザが初期化を失敗する原因となります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to find a planet with a position of 11, the optional Planet value returned by the raw value initializer will be nil:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが11の位置で惑星を見つけようとするならば、生の値のイニシャライザによって返されるオプショナルのPlanet値は、nilになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to insert a number into an integer constant or variable that cannot hold that value, by default Swift reports an error rather than allowing an invalid value to be created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある数をその値を持つことができない整数の定数や変数の中へ入れようとするならば、初期状態では、スウィフトは無効な値がつくられるようにするのではなく、エラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to retrieve an Int value through optional chaining, an Int? is always returned, no matter how many levels of chaining are used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがオプショナル連鎖を通してInt値を取り出そうと試すならば、Int?が常に返されます、どんなに多くの連鎖階層が使われようともです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to set the currentLevel of the right channel to 11, you can see that the right channel’s currentLevel property is capped to the maximum value of 10, and the maxInputLevelForAllChannels type property is updated to equal 10:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが右のチャンネルのcurrentLevelを11に設定しようとするならば、あなたは右のチャンネルのcurrentLevelプロパティが最大値の10に制限されるのを見ることができます、そして型プロパティmaxInputLevelForAllChannelsは10に等しくなるよう更新されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to use an implicitly unwrapped optional that has a value of nil, you’ll get a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがnilの値を持つ暗黙的にアンラップされるオプショナルを使うことを試みるならば、あなたは実行時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use a capture list, you must also use the in keyword, even if you omit the parameter names, parameter types, and return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがキャプチャリストを使うならば、あなたはまたinキーワードも使わなければなりません、たとえあなたがパラメータ名、パラメータ型、そして戻り型を省略するとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use a closure to initialize a property, remember that the rest of the instance has not yet been initialized at the point that the closure is executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがプロパティを初期化するためにクロージャを使うならば、そのクロージャが実行される時点で、残りのインスタンスはまだ初期化されていないのを思い出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use an extension to add an initializer to a value type that provides default values for all of its stored properties and does not define any custom initializers, you can call the default initializer and memberwise initializer for that value type from within your extension’s initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが拡張を、その保存プロパティの全てに省略時の値を与えて全くあつらえのイニシャライザを定義しない値型に、イニシャライザを加えるために使うならば、あなたはその値型のための省略時のイニシャライザとメンバー関連イニシャライザを、あなたの拡張のイニシャライザ内から呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use these shorthand argument names within your closure expression, you can omit the closure’s argument list from its definition, and the number and type of the shorthand argument names will be inferred from the expected function type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこれらの短縮形引数名をあなたのクロージャ式の中で使用するならば、あなたはクロージャの引数リストをその定義から省略することができます、そして、短縮形引数名の数と型は期待される関数型から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want a custom subclass to present one or more of the same initializers as its superclass, you can provide a custom implementation of those initializers within the subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、あるあつらえのサブクラスにそれのスーパークラスと同じイニシャライザがひとつ以上存在することを望むならば、あなたはそれらのイニシャライザのあつらえの実装をそのサブクラスにおいて提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want a function to modify a parameter’s value, and you want those changes to persist after the function call has ended, define that parameter as an in-out parameter instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある関数にパラメータの値を修正して欲しいならば、そしてあなたが関数呼び出しが終わった後それらの変化に存続して欲しいならば、代わりにそのパラメータをin-outパラメータとして定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want a nested type within a public type to be publicly available, you must explicitly declare the nested type as public.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが公開型の内側で入れ子にされた型に公開的に利用できて欲しいならば、あなたは明確に入れ子にされた型を公開として宣言しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want a public type to be initializable with a no-argument initializer when used in another module, you must explicitly provide a public no-argument initializer yourself as part of the type’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある公開型を別のモジュール内で使うときに引数のないイニシャライザを使って初期化できるようにしたいならば、あなたはある公開の引数のないイニシャライザをあなた自身でその型定義の一部として明示的に提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want a type member to be public, you must explicitly mark it as such.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが型のメンバーに公開であって欲しいならば、あなたは明確にそれをそのように印しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want an autoclosure that is allowed to escape, use both the @autoclosure and @escaping attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが脱出を許可される自動クロージャを望むならば、@autoclosureと@escaping属性を両方とも使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to assign an explicit access level to a protocol type, do so at the point that you define the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが明確なアクセス水準をあるプロトコル型に割り当てたいならば、あなたがそのプロトコルを定義する時点でそうしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to observe changes to a property’s value, and you are already providing a custom setter for that property, you can simply observe any value changes from within the custom setter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあるプロパティの値に対する変更を監視したい、そしてあなたが既にあつらえのセッターをそのプロパティのために提供しているならば、あなたは簡単にあつらえのセッター内からどんな値の変化でも監視することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to perform further optional chaining on this method’s return value, place the optional chaining question mark after the method’s parentheses:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこのメソッドの戻り値の上でさらにオプショナル連鎖を実行したいならば、メソッドの丸括弧の後にオプショナル連鎖の疑問符を置いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to remove the final item from an array, use the removeLast() method rather than the remove(at:) method to avoid the need to query the array’s count property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが配列から最後の項目を取り除きたいならば、removeLast()メソッドをremove(at:)メソッドよりむしろ使用して、配列のcountプロパティについてたずねる必要を避けるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to specify an explicit access level for a custom type, do so at the point that you define the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあつらえの型のために明示的にアクセス水準を指定したいならば、あなたが型を定義する時点でそうしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to swap two String values, or two Double values, you have to write more functions, such as the swapTwoStrings(_:_:) and swapTwoDoubles(_:_:) functions shown below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが２つのString値、または２つのDoubleの値を交換したいならば、あなたはより多くの関数を書かなければなりません、例えば以下で示されるswapTwoStrings(_:_:)とswapTwoDoubles(_:_:)関数のように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want your custom value type to be initializable with the default initializer and memberwise initializer, and also with your own custom initializers, write your custom initializers in an extension rather than as part of the value type’s original implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、あなたのあつらえの値型に省略時のイニシャライザとメンバー関連イニシャライザで、その上にあなた自身のあつらえのイニシャライザで初期化可能にされて欲しいならば、あなたのあつらえのイニシャライザを値型の元々の実装の一部としてではなく、ある拡張の中で書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wanted to manipulate the value of actualNumber within the first branch of the if statement, you could write if var actualNumber instead, and the value contained within the optional would be made available as a variable rather than a constant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがactualNumberの値をif文の最初の分岐内で取り扱うことを望むならば、あなたはif var actualNumberを代わりに書くことができたでしょう、そしてオプショナル内部に含まれる値は定数ではなく変数として利用可能にされたでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you write inout in front of a parameter’s type, the parameter can be modified inside the scope of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがinoutをパラメータの型のすぐ前に書くならば、そのパラメータは関数のスコープ内部において修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your code triggers an assertion while running in a debug environment, such as when you build and run an app in Xcode, you can see exactly where the invalid state occurred and query the state of your app at the time that the assertion was triggered.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デバッグ環境で動作している間に、例えばあなたがXcodeでアプリをビルドして実行する時に、あなたのコードがある表明にひっかかるならば、あなたは無効な状態が起こったところを正確に見ることができて、表明がひっかかった時のあなたのアプリの状態についてたずねることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your custom type has a stored property that is logically allowed to have “no value”—perhaps because its value cannot be set during initialization, or because it is allowed to have “no value” at some later point—declare the property with an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたの特注で作った型が論理的に「無い値」を持つことを許される保存プロパティを ― もしかしたらそれの値が初期化の間に設定されることができないかもしれないため、または後の時点でそれが「無い値」を持つことを許されるため ― 持つならば、そのプロパティをオプショナルの型で宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your data structure is likely to persist beyond a temporary scope, model it as a class or structure, rather than as a tuple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのデータ構造が、一時的な範囲を越えて存続しそうならば、タプルとしてよりも、クラスまたは構造体としてそれをモデル化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのサブクラスがまったく指定イニシャライザを定義しないならば、それは自動的にそれのスーパークラスの指定イニシャライザの全てを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your subclass provides an implementation of all of its superclass designated initializers—either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition—then it automatically inherits all of the superclass convenience initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしあなたのサブクラスがそれのスーパークラスの指定イニシャライザの実装の全てを ― 規則１に従ってそれらを継承することによって、またはあつらえの実装をそれの定義の一部として提供することによってのどちらかで ― 提供するならば、その時それは自動的にスーパークラスの便宜イニシャライザの全てを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your turn ends at the bottom of a ladder, you move up that ladder.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたの番がはしごの下で終わるならば、あなたはそのはしごを上ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your turn ends at the head of a snake, you move down that snake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたの番がヘビの頭のところで終わるならば、あなたはそのヘビを下ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you’re implementing a prefix or postfix operator, you must also mark that method declaration with the corresponding prefix or postfix declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが接頭辞または接尾辞演算子を実装しているならば、あなたはまたそのメソッド宣言を対応するprefixまたはpostfix宣言修飾子で印をしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you’re implementing the method in an extension, use the class modifier if you’re extending a class and the static modifier if you’re extending a structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこのメソッドをある拡張の中で実装するならば、あなたがクラスを拡張しているならclass修飾子を、あなたが構造体を拡張しているならstatic修飾子を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implement an area() and a simpleDescription() method on the Circle class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>area()およびsimpleDescription()メソッドをCircleクラス上で実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicit Member Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙のメンバー式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicit Returns from Single-Expression Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単一式のクロージャからの値を暗黙的に返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicit returns from single-expression closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単一式のクロージャからの値を暗黙的に返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicitly Assigned Raw Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的に割り当てられる生の値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicitly Unwrapped Optional Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナルの型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicitly Unwrapped Optionals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicitly unwrapped optionals are useful when an optional’s value is confirmed to exist immediately after the optional is first defined and can definitely be assumed to exist at every point thereafter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナルは、あるオプショナルの値が存在するのをそのオプショナルが最初に定義された直後に確かめられて、それ以降あらゆる所で存在するのを自信を持って仮定出来るようにされる場合に役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポート宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Important</seg>
      </tuv>
      <tuv lang="JA">
        <seg>重要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Improved the discussion of autoclosures in the Autoclosures section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動クロージャの説明を自動クロージャ節において改善した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Blackjack, the Ace cards have a value of either one or eleven.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブラックジャックにおいて、「エース」のカードは、１または11のどちらかの値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In C and Objective-C, you define static constants and variables associated with a type as global static variables.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CとObjective-Cでは、あなたは静的定数およびグローバルな静的変数として型と結びついた変数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, nil is a pointer to a nonexistent object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、nilは、ある存在しないオブジェクトへのポインターです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, classes are the only types that can define methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、クラスはメソッドを定義することができる唯一の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, you can define type-level methods only for Objective-C classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、あなたはObjective-Cクラスのためにだけ型レベルのメソッドを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, nil is not a pointer—it is the absence of a value of a certain type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、nilはポインターではありません ― それは、ある特定の型のある値の不在です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, an enumeration to define product barcodes of either type might look like this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、両方の種類の製品バーコードを定義する列挙は、これのように見えるかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, as in C, the remainder operator (%) and the multiplication operator (*) have a higher precedence than the addition operator (+).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、Cでのように、剰余演算子（%）と乗算演算子（*）は、加算演算子（+）より高い優先順位を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, as in Objective-C, protocol conformance is global—it is not possible for a type to conform to a protocol in two different ways within the same program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、Objective-Cにおいてと同様に、プロトコル準拠はグローバルです ― ひとつの型にとって、同じプログラム内でひとつのプロトコルに２つの異なる方法で準拠することは、可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, errors are represented by values of types that conform to the Error protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、エラーはErrorプロトコルに準拠する型の値によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, every possible value of the control expression’s type must match the value of at least one pattern of a case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、制御式のもつ型のあらゆる可能な値は、少なくともあるケース節の１つのパターンの値にマッチしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, however, type properties are written as part of the type’s definition, within the type’s outer curly braces, and each type property is explicitly scoped to the type it supports.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、しかしながら、型プロパティは、型の定義の一部として、型の外縁の波括弧の内部に書かれます、そして各型プロパティは、明確にそれが支持する型にスコープを定められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, many basic data types such as String, Array, and Dictionary are implemented as structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、多くの基本的なデータ型、String、Array、およびDictionaryなどが、構造体として実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, most declarations are also definitions in the sense that they are implemented or initialized at the same time they are declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、大部分の宣言はまた、それらが宣言されるのと同時にそれらが実装または初期化されるという意味で定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, the simplest form of a closure that can capture values is a nested function, written within the body of another function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、値をキャプチャできるクロージャの最も単純な形式は、別の関数の本文内に書かれる、入れ子にされた関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, there are four kinds of expressions: prefix expressions, binary expressions, primary expressions, and postfix expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトには、４種類の式があります：接頭辞式、二項式、基本式、そして接尾辞式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, there are three kinds of statements: simple statements, compiler control statements, and control flow statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトには、３種類の文があります：単純な文、コンパイラ制御文、そして制御の流れ文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, there are two basic kinds of patterns: those that successfully match any kind of value, and those that may fail to match a specified value at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトには、２つの基本的な種類のパターンがあります：あらゆる種類の値に成功裏にマッチするものたち、そして指定された値にマッチするのを実行時に失敗するものたち。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, there are two kinds of types: named types and compound types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトには、２つの種類の型：名前付きの型と複合の型があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, this can be done in a single line:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、これは一つの行でされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, this would be written as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、これはこのように書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, type information can also flow in the opposite direction—from the root down to the leaves.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、型情報は逆方向にも流れます ― 根から下って葉っぱまで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can choose whether to define a class, structure, or enumeration, and still have the flexibility to define methods on the type you create.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたは、クラス、構造体、または列挙を定義すべきかを選択することができます、そしてまだあなたがつくる型でメソッドを定義する柔軟性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can define type-level methods for all classes, structures, and enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたは全てのクラス、構造体、および列挙のために型レベルのメソッドを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can even extend a protocol to provide implementations of its requirements or add additional functionality that conforming types can take advantage of.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたはプロトコルを拡張してその要件の実装を提供することやそれの準拠型が利用することができる追加の機能性を加えることさえ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can nest loops and conditional statements inside other loops and conditional statements to create complex control flow structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたはループおよび条件文を他のループおよび条件文の中に入れ子にして、複雑な制御の流れの構造を作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you define a class or a structure in a single file, and the external interface to that class or structure is automatically made available for other code to use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたは一つのファイルにおいてクラスまたは構造体を定義します、そして、そのクラスまたは構造体への外部インタフェースは自動的に他のコードが使うことが可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Xcode, for example, the print(_:separator:terminator:) function prints its output in Xcode’s “console” pane.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、Xcodeでは、print(_:separator:terminator:)関数はその出力をXcodeの「コンソール」枠に表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a for statement, the increment expression is still evaluated after the continue statement is executed, because the increment expression is evaluated after the execution of the loop’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>for文において、増加式はcontinue文が実行されたあと依然として評価されます、なぜなら増加式がループの本文の実行の後に評価されるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a class declaration, the static keyword has the same effect as marking the declaration with both the class and final declaration modifiers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言において、キーワードstaticは宣言をclassとfinal宣言修飾子の両方で記しすることと同じ効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a dictionary literal, the key and value in each key-value pair are separated by a colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書リテラルでは、それぞれの「キーと値」の対の中のキーと値は、コロンで区切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a few cases, regular font text is used to describe the right-hand side of a grammar production rule.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２、３の場合には、標準活字のテキストが説明のために文法導出規則の右側で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a mutating method of a value type, you can assign a new instance of that value type to self.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型の可変メソッドでは、あなたはselfにその値型の新しいインスタンスを代入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a type method, self refers to the current type in which it occurs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型メソッドでは、selfはそれが現れているところの現在の型に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to comparing against specific values, Swift provides several ways for each case to specify more complex matching patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある特定の値に対して比較することに加えて、スウィフトは、それぞれのケース節のために、より複雑な適合パターンを指定するためのいくつかの方法を用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to familiar types, Swift introduces advanced types not found in Objective-C, such as tuples.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>よく知られている型に加えて、スウィフトはObjective-Cで見られない先進の型を導入します、例えばタプルのような。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to generic functions, Swift enables you to define your own generic types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体関数に加えて、スウィフトはあなたに独自の総称体型を定義することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to its type property and type methods, LevelTracker tracks an individual player’s progress through the game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その型プロパティと型メソッドに加えて、LevelTrackerは個々のプレーヤーのゲームを通しての進捗を追います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to matching a pattern with a value, you can extract part or all of a composite value and bind each part to a constant or variable name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターンを値とマッチングすることに加えて、あなたはある複合値の部分または全てを抽出して、各部分を定数や変数の名前に結び付ける（束縛する）ことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to offering various levels of access control, Swift reduces the need to specify explicit access control levels by providing default access levels for typical scenarios.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス制御のいろいろな水準を提供することに加えて、スウィフトは省略時のアクセス水準を典型的なシナリオのために用意することによって明示的にアクセス制御水準を指定する必要を減らします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to properties, you can use instance variables as a backing store for the values stored in a property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティに加えて、あなたはインスタンス変数をプロパティに保管される値に対する支援外部記憶として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to simple properties that are stored, properties can have a getter and a setter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存される単純なプロパティに加えて、プロパティはゲッター（取得メソッド）とセッター（設定メソッド）を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to specifying major version numbers like iOS 8, you can specify minor versions numbers like iOS 8.3 and macOS 10.10.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メジャーなバージョン数を、iOS 8のように、指定することに加えて、あなたはマイナーバージョン数を、iOS 8.3そしてmacOS 10.10.3のように、指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to specifying requirements that conforming types must implement, you can extend a protocol to implement some of these requirements or to implement additional functionality that conforming types can take advantage of.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>準拠する型が実装しなければならない要件を指定することに加えて、あなたはあるプロトコルを拡張してそれらの要件のいくつかを実装したり、更なる機能性を実装したりできます、それらは、準拠する型それぞれで利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to stored properties, classes, structures, and enumerations can define computed properties, which do not actually store a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存プロパティに加えて、クラス、構造体、および列挙は計算プロパティを定義することができます、それは、実際に値を保存しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the characteristics it inherits, the Bicycle class defines a new stored property, hasBasket, with a default value of false (inferring a type of Bool for the property).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが継承する特徴に加えて、Bicycleクラスは新しい保存プロパティ、hasBasketを、falseの省略時の値を使って定義します（このプロパティに対してはBoolの型が推論されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the operators described in Basic Operators, Swift provides several advanced operators that perform more complex value manipulation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本の演算子で記述される演算子に加えて、スウィフトはより複雑な値操作を実行するいくつかの先進の演算子を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the standard library operators, you use &amp; immediately before the name of a variable that’s being passed as an in-out argument to a function call expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>標準ライブラリ演算子に加えて、あなたは&amp;を変数の名前の直前で使います、それはin-out引数として関数呼び出し式に渡されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to these two simple properties, the HTMLElement class defines a lazy property called asHTML.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの２つの単純なプロパティに加えて、HTMLElementクラスは、asHTMLと呼ばれる遅延プロパティを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to user-defined named types, the Swift standard library defines many commonly used named types, including those that represent arrays, dictionaries, and optional values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザー定義の名前付きの型に加えて、スウィフト標準ライブラリは、配列、辞書、そしてオプショナル値を表すものたちを含む、多くの一般に使われる名前付きの型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, Swift provides a do statement to introduce scope, and catch and handle errors, and a defer statement for running cleanup actions just before the current scope exits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて、スウィフトは、do文をスコープを導入し、それでエラーを捕えて処理するために、そしてdefer文を現在のスコープを脱出する直前にさまざまな片付け活動を実行するために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the catch clause must handle only errors thrown by one of the rethrowing function’s throwing parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて、そのcatch節はスロー関数の持つスローパラメータの１つによってスローされるエラーのみを取り扱わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, you can define property observers to monitor changes in a property’s value, which you can respond to with custom actions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに加えて、あなたはプロパティオブザーバーを定義して、あるプロパティの値の変化を監視することができて、あなたはあつらえの動作でそれに応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, you can override any class member (method, property, initializer, or subscript) that is visible in a certain access context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに加えて、あなたは特定のアクセス前後関係において見えるあらゆるクラスメンバー（メソッド、プロパティ、イニシャライザ、または添え字）をオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all other cases, define a class, and create instances of that class to be managed and passed by reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての他の場合には、クラスを定義してください、そしてそのクラスのインスタンスをつくって、参照で管理されて渡されるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all other cases, the dice roll is a valid move.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の全ての場合には、さいころの目は有効な移動となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all other cases, you must use an initializer expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての他の場合では、あなたはイニシャライザ式を使う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all three functions, it is important that the types of a and b are defined to be the same as each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>の３つの関数の全てにおいて、重要であることは、aとbの型がお互いと同じものであると定義されることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In an if statement, the conditional must be a Boolean expression—this means that code such as if score { ... } is an error, not an implicit comparison to zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文において、その条件を表すのはブール式でなければなりません ― これはif score { ... }のようなコードがエラーになることを意味します、暗黙的なゼロとの比較はしないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In an initializer, constant properties can now only assign a value once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある初期化において、定数プロパティは今ではただ一度しか値を割り当てることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In an initializer, subscript, or instance method, self refers to the current instance of the type in which it occurs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ、添え字、またはインスタンスメソッドでは、selfはそれが現れているところの型の現在のインスタンスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, it is written as (s1: String, s2: String) -&gt; Bool.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合において、それは(s1: String, s2: String) -&gt; Boolのように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, program control is then transferred to the condition of the enclosing loop statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合において、プログラム制御はそれから囲んでいるループ文の条件へ移されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, program control is then transferred to the first line of code following the enclosing loop or switch statement, if any.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合において、プログラム制御はそれから、もしあれば、それを囲んでいるループまたはswitch文に続くコードの最初の行へ移されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, the constant someArray is declared as an array of strings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合で、定数のsomeArrayは、文字列の配列として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, the constant someDictionary is declared as a dictionary with strings as keys and integers as values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合で、定数someDictionaryは、キーとして文字列そして値として整数を持つ辞書として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, the letter é is represented as a single Swift Character value that represents an extended grapheme cluster.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合で、文字éは、単一のスウィフトのCharacter値として表わされます、それはひとつの拡張書記素クラスタを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, the value of the whole expression is an optional value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合で、その全体の式の値は、オプショナルの値となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, the variable optionalInteger is declared to have the type of an optional integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合には、変数optionalIntegerは、オプショナル整数の型を持つと宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, you must mark the initializer implementation with the required modifier:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合で、あなたはそのイニシャライザ実装をrequired修飾子で印しなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both of the examples above, the type information is passed up from the leaves of the expression tree to its root.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例の両方とも、型情報は、式ツリーの葉っぱから、その根までさかのぼって渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In certain constructs, operators with a leading &lt; or &gt; may be split into two or more tokens.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定の構造物において、先導する&lt;または&gt;をもつ演算子は、２つ以上のトークンに分割されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to optionals, which can use the presence or absence of a value to communicate success or failure of a function, error handling allows you to determine the underlying cause of failure, and, if necessary, propagate the error to another part of your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルと対比して（それは値の有無を使って、ある関数の成否を伝えることができます）、エラー処理はあなたに根本的な失敗の原因を突き止めること、そして、必要ならば、そのエラーをあなたのプログラムの別の部分に伝えることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to the willSet observer, the old value of the variable or property is passed to the didSet observer in case you still need access to it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>willSetオブザーバーと対照的に、変数またはプロパティの古い値が、あなたがまだそれへのアクセスを必要とする場合に備えてdidSetオブザーバーに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast with switch statements in C and Objective-C, switch statements in Swift do not fall through the bottom of each case and into the next one by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CおよびObjective-Cのswitch文とは対照的に、スウィフトのswitch文は、なにもしなくても、各ケース節の底を突き抜けて次のものに行ったりしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast with generic types, you don’t specify a generic argument clause when you use a generic function or initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体型と対照的に、あなたが総称体の関数やイニシャライザを使うとき、あなたは総称体引数節を指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, Bool can’t be compared, which means tuples that contain a Boolean value can’t be compared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、Boolは比較されることができません、それはブール値を含むタプルは比較されることができないのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, the closure passed to someFunctionWithNonescapingClosure(_:) is a nonescaping closure, which means it can refer to self implicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、someFunctionWithNonescapingClosure(_:)に渡されるクロージャは非脱出クロージャです、それは、それがselfを暗黙的に参照できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, the constants and variables created with a guard statement are available in the lines of code that follow the guard statement, as described in Early Exit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、guard文で作成された定数と変数は、そのguard文以降のコード行において利用可能です、早期退出において議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, there is only one variable named b—the b in the outer scope—so changes from inside or outside the closure are visible in both places.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、bと名前を付けられるただ１つだけの変数があります ― 外側のスコープの中のb ― それでクロージャ内部および外部からの変更は、両方の場所で見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, use an unowned reference when the other instance has the same lifetime or a longer lifetime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、非所有参照を他のインスタンスが同じ生涯またはより長い生涯を持つ場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, when creating a selector for a property’s setter, the property name must be a reference to a variable property only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、プロパティのセッターのためのセレクタを作成するとき、property nameは必ず変数プロパティへの参照でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In dot syntax, you write the property name immediately after the instance name, separated by a period (.), without any spaces:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ドット構文において、あなたはプロパティ名をインスタンス名の直後に、終止符（.）で区切り、どんな空白もなしで、書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In each case, a new copy of the existing String value is created, and the new copy is passed or assigned, not the original version.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの場合において、既存のString値の新しいコピーがつくられます、そしてその新しいコピーが渡されるか代入されます、元々のものではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In each case, the type parameter is replaced with an actual type whenever the function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの場合において、型パラメータは、その関数が呼ばれるときはいつでも実際の型と取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In each form, the name of the operator can contain only the operator characters defined in Operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各形式において、演算子の名前は演算子で定義される演算子文字だけを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In each form, the opening and closing braces are required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各形式で、開始と終了の波括弧は必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, if you delegate to another initializer that causes initialization to fail, the entire initialization process fails immediately, and no further initialization code is executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの場合においても、あなたが初期化失敗の原因となる別のイニシャライザに委任するならば、全体の初期化プロセスは直ちに失敗します、そしてそれ以上初期化コードが実行されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, the value of the postfix expression is still of an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いずれにせよ、接尾辞式の値は、依然としてオプショナル型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, these accesses cause the closure to “capture” self, creating a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いずれにせよ、これらのアクセスは、クロージャが強い参照循環をつくってselfを「捕獲する」ことを引き起こします</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, it’s the same problem as above—two strong references are keeping each other alive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本質において、それは上記と同じ問題です ― ２つの強い参照が、お互いを生かし続けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, someFunction() will not compile as written below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際、someFunction()は以下のように書かれるときコンパイルしないでしょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, all of the basic types in Swift—integers, floating-point numbers, Booleans, strings, arrays and dictionaries—are value types, and are implemented as structures behind the scenes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際、スウィフトにおける基本の型の全て ― 整数、浮動小数点数、ブール、文字列、配列および辞書 ― は、値型であり、そして舞台裏では構造体として実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, if the first value is false, the second value won’t even be evaluated, because it can’t possibly make the overall expression equate to true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際には、最初の値がfalseならば、２番目の値は評価されさえしません、なぜならそれがどうやっても式全体をtrueと等しくすることが出来ないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, in cases where there isn’t a meaningful raw value, you don’t have to provide one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際、意味がある生の値がない状況の場合には、あなたはそれを提供する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, the point (0, 0) could match all four of the cases in this example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際、点(0, 0)は、この例ではケース節の４つ全てに適合することができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, you’ve been using generics throughout the Language Guide, even if you didn’t realize it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際、たとえあなたがそれを実感しなかったとしても、あなたはこの言語ガイドを通して総称体を使用していました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its general form, the availability condition takes a list of platform names and versions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それの一般的な形式において、有効性条件はプラットホーム名とバージョンを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its simplest form, a switch statement compares a value against one or more values of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その最も単純な形式では、switch文は、ある値を、同じ型の一つ以上の値に対して比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its simplest form, a stored property is a constant or variable that is stored as part of an instance of a particular class or structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その最も単純な形式で、保存プロパティは、特定のクラスまたは構造体のあるひとつのインスタンスの一部として保存される定数または変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its simplest form, an initializer is like an instance method with no parameters, written using the init keyword:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その最も単純な形式では、イニシャライザはパラメータのないインスタンスメソッドのようです、そしてinitキーワードを使用して書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its simplest form, the if statement has a single if condition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その最も単純な形式において、if文はただ１つだけのif条件を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most cases, this means that memory management “just works” in Swift, and you do not need to think about memory management yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの場合、これは、スウィフトにおいてメモリ管理が「正確に機能する」こと、そしてあなたはあなた自身でメモリ管理について考える必要がないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most cases, tokens are generated from the characters of a Swift source file by considering the longest possible substring from the input text, within the constraints of the grammar that are specified below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの場合、トークンは、スウィフトのソースファイルの文字から、下で指定される文法の制約の範囲内で、その入力テキストからの最も長く取ることのできる下位文字列を考慮することによって生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most cases, type parameters have descriptive names, such as Key and Value in Dictionary&lt;Key, Value&gt; and Element in Array&lt;Element&gt;, which tells the reader about the relationship between the type parameter and the generic type or function it’s used in.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの場合には、型パラメータは描写的な名前を持ちます、たとえばDictionary&lt;Key, Value&gt;におけるKeyとValueおよびArray&lt;Element&gt;におけるElementなど、それは読み手に型パラメータとそれがその中で使われる総称体型や関数との関係について語ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most cases, you don’t need to pick a specific size of integer to use in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの場合、あなたはあなたのコードにおいて使用するのに整数の特定のサイズを選択する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order for this rule to be satisfied, a designated initializer must make sure that all of its own properties are initialized before it hands off up the chain.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この規則が満たされるために、指定イニシャライザは、それがその連鎖を上って手渡す前に、それ自身のプロパティの全てが初期化されることを確認しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to work with them as their native type, you need to check their type, or downcast them to a different type, as described below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらをそれらの生来の型として取り扱うために、下で述べるように、あなたはそれらの型を調べること、またはそれらを異なる型へダウンキャストすることが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, the following two declarations are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言い換えると、以下の２つの宣言は、等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, a protocol can declare that conforming types must implement certain properties, methods, initializers, and subscripts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、プロトコルは、準拠している型が特定のプロパティ、メソッド、イニシャライザ、そして添え字を実装しなければならないと宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the raw-value type must conform to the Equatable protocol and one of the following protocols: ExpressibleByIntegerLiteral for integer literals, ExpressibleByFloatLiteral for floating-point literals, ExpressibleByStringLiteral for string literals that contain any number of characters, and ExpressibleByUnicodeScalarLiteral or ExpressibleByExtendedGraphemeClusterLiteral for string literals that contain only a single character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、生の値型は、Equatableプロトコルおよび次のプロトコルの内の１つに準拠しなければなりません：整数リテラルのためのExpressibleByIntegerLiteral、浮動小数点リテラルのためのExpressibleByFloatLiteral、随意の数の文字を含む文字列リテラルのためのExpressibleByStringLiteral、そしてただ１つの文字だけを含む文字列リテラルのためのExpressibleByUnicodeScalarLiteralまたはExpressibleByExtendedGraphemeClusterLiteral。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, this means that most custom data constructs should be classes, not structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際問題として、これは、ほとんどのあつらえのデータ構造はクラスでなければならないことを意味します、構造体ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, this means that you do not need to write initializer overrides in many common scenarios, and can inherit your superclass initializers with minimal effort whenever it is safe to do so.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際問題として、これは、あなたが多くの通常の状況ではイニシャライザのオーバーライドを書く必要がなく、そしてそれが安全にそうできる時はいつでも最小の努力であなたのスーパークラスのイニシャライザを継承することができることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, you don’t need to write self in your code very often.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際問題として、あなたは頻繁にあなたのコードにselfを書く必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In situations where either type would be appropriate, Double is preferred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの型でも適切である状況では、Doubleが望ましいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, it is simply not possible for your code to continue execution if a particular condition is not satisfied.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの場合には、特定の状態が満たさないならば、あなたのコードには実行を続けることが単純に可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, this requirement is satisfied by inheriting one or more designated initializers from a superclass, as described in Automatic Initializer Inheritance below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>若干の場合には、この必要条件は、下記の自動的なイニシャライザ継承で記述されるように、あるスーパークラスから一つ以上の指定イニシャライザを継承することによって満たされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In systems that use garbage collection, weak pointers are sometimes used to implement a simple caching mechanism because objects with no strong references are deallocated only when memory pressure triggers garbage collection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ガベージコレクションを使うシステムにおいて、時おり弱いポインタが簡単なキャッシュの仕組みを実装するために使われます、なぜなら強い参照を持たないオブジェクトは、メモリの逼迫がガベージコレクションを引き起こす時のみに割り当て解除されるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that context, Self refers to the eventual type that conforms to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その文脈で、Selfはそのプロトコルに準拠する結果として生じる型に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the Apartment example above, it is appropriate for an apartment to be able to have no tenant at some point in its lifetime, and so a weak reference is an appropriate way to break the reference cycle in this case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のApartment例で、あるアパートがその生涯のどこかの時点で賃借人がいないことがあるというのは妥当です、なのでこの場合は弱い参照が参照循環を壊す適切な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the CompassPoint example above, north, south, east and west do not implicitly equal 0, 1, 2 and 3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のCompassPoint例で、north、south、eastそしてwestは、暗黙のうちに0、1、2そして3に等しくはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the swapTwoValues(_:_:) example above, the placeholder type T is an example of a type parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のswapTwoValues(_:_:)例で、プレースホルダ型Tは型パラメータの一例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the welcomeMessage example above, no initial value is provided, and so the type of the welcomeMessage variable is specified with a type annotation rather than being inferred from an initial value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のwelcomeMessageの例では、初期値が提供されません、それでwelcomeMessage変数の型は、最初の値から推論されるのではなく、型注釈で指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the repeat-while loop above, square += board[square] is always executed immediately after the loop’s while condition confirms that square is still on the board.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のrepeat-whileループにおいて、square += board[square]は常に、このループのwhile条件がsquareはまだ盤上かを確認した直後に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the above example, approximateCount is evaluated in a switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、approximateCountはswitch文において評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the above example, the buyFavoriteSnack(person:vendingMachine:) function is called in a try expression, because it can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、buyFavoriteSnack(person:vendingMachine:)関数はtry式の中で呼び出されます、それがエラーをスローできるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the above example, the raw value of ExampleEnum.a is 0 and the value of ExampleEnum.b is 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記の例で、ExampleEnum.aの値は0です、そしてExampleEnum.bの値は1です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the above example, the raw value of GamePlayMode.cooperative is "cooperative", the raw value of GamePlayMode.individual is "individual", and the raw value of GamePlayMode.competitive is "competitive".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記の例で、GamePlayMode.cooperativeの生の値は"cooperative"、GamePlayMode.individualの生の値は"individual"、そしてGamePlayMode.competitiveの生の値は"competitive"です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the body of the function, the copy is modified.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の本体において、そのコピーが修正されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of the sorted(by:) method, the purpose of the closure is clear from the fact that sorting is taking place, and it is safe for a reader to assume that the closure is likely to be working with String values, because it is assisting with the sorting of an array of strings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>sorted(by:)メソッドの場合、クロージャの目的はソートが行われているという事実から明快です、そして、読者がクロージャはString値を扱っているようだと仮定しても差し支えありません、なぜならそれがいくつかの文字列からなる配列のソートを手伝っているからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case where it equals .north, print "Lots of planets have a north".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが.northに等しい場合には、"Lots of planets have a north"を出力する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case where it equals .south, print "Watch out for penguins".”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが.southに等しい場合には、"Watch out for penguins"を出力する。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code above, instead of calling the closure passed to it as its customerProvider argument, the collectCustomerProviders(_:) function appends the closure to the customerProviders array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードにおいて、それのcustomerProvider引数としてそれに渡されるクロージャを呼び出す代わりに、collectCustomerProviders(_:)関数は、そのクロージャをcustomerProviders配列に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code below, john has a residence property value of nil:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記のコードにおいて、johnはnilのresidenceプロパティ値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the context of Vector2D, it makes sense to consider “equal” as meaning “both instances have the same x values and y values”, and so this is the logic used by the operator implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Vector2Dの文脈では、「同等」を「両方のインスタンスが同じx値とy値を持つ」ことを意味すると考えるのが道理にかなっています、なのでそれが演算子実装によって使われる論理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the door access example above, it is useful to add parentheses around the first part of the compound expression to make its intent explicit:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のドア・アクセスの例で、その意図を明確にするために複合式の最初の部分のまわりに丸括弧を加えることは、役に立ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, Ace is explicitly given a raw value of 1, and the rest of the raw values are assigned in order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例では、Aceは暗黙的に1の生の値を与えられます、そして残りの生の値は順に割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, CompassPoint.south has an implicit raw value of "south", and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、CompassPoint.southは暗黙的な生の値の"south"をもちます、等々。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, Planet.mercury has an explicit raw value of 1, Planet.venus has an implicit raw value of 2, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、Planet.mercuryは明示的な生の値の1を持ちます、Planet.venusは暗黙的な生の値の2を持ちます、等々。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, SomeClassOnlyProtocol can only be adopted by class types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、SomeClassOnlyProtocolはクラス型によってのみ採用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, incrementBySeven and incrementByTen are constants, but the closures these constants refer to are still able to increment the runningTotal variables that they have captured.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、incrementBySevenとincrementByTenは定数です、しかしこれらの定数が言及するクロージャはそれでもなお、それらが捕獲したrunningTotal変数を増加させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, index is a constant whose value is automatically set at the start of each iteration of the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、indexは、ループの各繰り返しの開始時点でその値が自動的に設定される定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, let distributes to each identifier pattern in the tuple pattern (x, y).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、letは、タプルパターン(x, y)における各識別子パターンに分配されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, possiblePlanet is of type Planet?, or “optional Planet.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、possiblePlanetは型Planet?、すなわち「オプショナルのPlanet」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, length is initialized when the new range is created and cannot be changed thereafter, because it is a constant property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、lengthは新しい範囲が作成される時に初期化されます、そしてその後は変更されることが出来ません、なぜならそれが変数プロパティだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, an empty string ("") is a valid, nonoptional String.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、空の文字列（""）は有効な、オプショナルでないStringです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, it is guaranteed that number % 10 will always be a valid subscript key for the digitNames dictionary, and so an exclamation mark is used to force-unwrap the String value stored in the subscript’s optional return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例でnumber % 10は常にdigitNames辞書のための有効な添え字キーであることを求められます、なのでその添え字のオプショナルの戻り値に保管したString値を強制アンラップするために感嘆符が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, it is the choice of closure that incrementByTen refers to that is constant, and not the contents of the closure itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例では、それは「クロージャの選択」です、それがincrementByTenが参照するものであり、それは定数であり、そしてクロージャ自身の内容ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the allItemsMatch(_:_:) function correctly reports that all of the items in the two containers match.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、allItemsMatch(_:_:)関数は、２つのコンテナの中の項目の全てが一致すると正しく報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the description property correctly reports that the Ace of Spades has a value of 1 or 11.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、descriptionプロパティは、スペードのエースが1または11の値を持つことを正しく報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the Key type parameter is constrained to conform to the Hashable protocol and therefore String must also conform to the Hashable protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、Key型パラメータは、Hashableプロトコルに準拠することを強制されます、したがってStringもまたHashableプロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the compiler infers that myVariable is an integer because its initial value is an integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、コンパイラはmyVariableが整数であると推測します、その最初の値が整数であるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the first three decimal codeUnit values (68, 111, 103) represent the characters D, o, and g, whose UTF-8 representation is the same as their ASCII representation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、最初の３つの10進のcodeUnit値（68、111、103）は、文字D、o、そしてgを表わします、これらのUTF-８叙述はそれらのASCII叙述と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the operator is used to determine an initial value for a String variable called colorNameToUse.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、この演算子はcolorNameToUseと呼ばれるあるString変数の初期値を確定するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the use of an implicitly unwrapped optional means that all of the two-phase class initializer requirements are satisfied.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、暗黙的にアンラップされるオプショナルの使用は、２段階のクラスイニシャライザの必要とする条件の全てが満たされることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the value of multiplier is inserted into a string literal as \(multiplier).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、multiplierの値は、文字列リテラルに\(multiplier)として差し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, you can see the left-to-right comparison behavior on the first line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、あなたは左から右への比較挙動を最初の行において見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, you place the optional chaining question mark after the parentheses, because the optional value you are chaining on is the buildingIdentifier() method’s return value, and not the buildingIdentifier() method itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、あなたは丸括弧の後にオプショナル連鎖の疑問符を置きます、なぜなら、あなたがその上に連鎖しているオプショナルの値はbuildingIdentifier()メソッドの戻り値であって、buildingIdentifier()メソッドそれ自体ではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, class A is a public class with a file-private method called someMethod().</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例で、クラスAは公開のクラスです、それはsomeMethod()と呼ばれるあるファイル外非公開のメソッドを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the CompassPoint enumeration has an explicit access level of “public”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例において、CompassPoint列挙は明示的な「公開」のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the VendingMachine class has a vend(itemNamed:) method that throws an appropriate VendingMachineError if the requested item is not available, is out of stock, or has a cost that exceeds the current deposited amount:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例において、VendingMachineクラスはvend(itemNamed:)メソッドを持ちます、それは、要求された項目が利用可能でない、在庫切れ、または現在預け入れされた総額を超える価格を持つならば対応するVendingMachineErrorをスローします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the constant twoThousand is of type UInt16, whereas the constant one is of type UInt8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例で、定数twoThousandは型UInt16ですが、定数oneは型UInt8です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the first Bool value (hasDoorKey) is false, but the second value (knowsOverridePassword) is true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例で、最初のBool値（hasDoorKey）はfalseです、しかし、第二の値（knowsOverridePassword）はtrueです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the values of firstBits and otherBits each have a bit set to 1 in a location that the other does not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例で、firstBitsとotherBitsそれぞれの値は、他のものがそうでない場所で、ビットを1に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the values of firstSixBits and lastSixBits both have four middle bits equal to 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例で、firstSixBitsとlastSixBitsの値は、1と等しい４つの中間のビットを両方とも持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the values of someBits and moreBits have different bits set to 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例で、someBitsとmoreBitsの値は、1に設定される異なるビットを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, when c is not nil, its value is unwrapped and used to evaluate .property, the value of which is used to evaluate .performAction().</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例で、cがnilでないとき、その値はアンラップされて.propertyを評価するために使われ、その値が.performAction()を評価するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the examples above, ARC is able to track the number of references to the new Person instance you create and to deallocate that Person instance when it is no longer needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、ARCはあなたがつくる新しいPersonインスタンスへの参照の数を追跡して、それがもはや必要でないとき、そのPersonインスタンスを割り当て解除することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the expression 1 + 2, the + symbol is a binary operator and its two operands are the values 1 and 2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式1 + 2において、記号+は二項演算子です、そしてその２つの演算数は値1と2です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the extension, you must implement all of the adopted protocol’s requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張において、あなたは採用されたプロトコルの要件の全てを実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first case, a type identifier refers to a type alias of a named or compound type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第一の場合には、型識別子は、名前付きまたは複合の型の型エイリアスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first case, the cluster contains a single scalar; in the second case, it is a cluster of two scalars:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の場合では、クラスタは、ただ１つだけのスカラーを含みます；２番目の場合には、それは、２つのスカラーのクラスタ（１つの房、群れ）です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first example, the expression someTuple is specified to have the tuple type (Double, Double).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の例で、式someTupleは、タプル型(Double, Double)を持つと指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first of these two checks, the didSet observer sets currentLevel to a different value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの２つのチェックで最初のものにおいて、didSetオブザーバーは、currentLevelを異なる値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first phase, each stored property is assigned an initial value by the class that introduced it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の段階では、各保存プロパティは、それを導入したクラスによって、初期値を代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following example, for instance, the explicit type annotation (: Float) on the constant eFloat causes the numeric literal 2.71828 to have an inferred type of Float instead of Double.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下の例において、定数eFloatでの明示的な型注釈（: Float）は、数値リテラル2.71828をFloatの推論される型を持つようにします、Doubleではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the last example above, the width property of the resolution property of someVideoMode is set directly, without your needing to set the entire resolution property to a new value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の最後の例で、someVideoModeのresolutionプロパティのwidthプロパティは直接に設定されます、あなたがresolutionプロパティ全体を新しい値に設定する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the line of code that says return greeting, the function finishes its execution and returns the current value of greeting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>return greetingを告げるコード行において、関数はその実行を終えてgreetingの現在の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the previous example, it’s not easy to see that someAddress is never evaluated, because accessing a constant doesn’t have any side effects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前の例において、someAddressが決して評価されないというのはわかりやすいとはいえません、なぜならある定数を代入することは、何ら副作用を持たないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the second case, a type identifier uses dot (.) syntax to refer to named types declared in other modules or nested within other types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二の場合には、型識別子は、他のモジュールで宣言される、または他の型の内部で入れ子にされる名前付きの型を参照するためにドット（.）構文を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the second example, the parameter a to the function someFunction is specified to have the type Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二の例で関数someFunctionのためのパラメータaは、型Intを持つ指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the setter for perimeter, the new value has the implicit name newValue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>perimeterのためのセッターにおいて、新しい値は、隠された名前newValueを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the two examples below, T is inferred to be Int and String respectively:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の２つの例で、TはそれぞれIntとStringであると推測されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these cases, it is useful to remove the need to check and unwrap the optional’s value every time it is accessed, because it can be safely assumed to have a value all of the time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの場合には、オプショナルの値をそれがアクセスされるたびに確認してアンラップする必要を無くすことは役に立ちます、なぜならそれがいつでも値を持つと安全に仮定されることが出来るためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these situations, you can trigger an assertion in your code to end code execution and to provide an opportunity to debug the cause of the absent or invalid value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの状況において、あなたはある表明を、あなたのコードにおいてコード実行を止めるための、そして不在もしくは無効な値の原因をデバッグする機会を提供するための、引き金にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, Element is used as a placeholder in three places:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、Elementはプレースホルダとして３つの場所で使われます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, because the image is shipped with the application, no error will be thrown at runtime, so it is appropriate to disable error propagation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、画像はアプリケーションとともに出荷されるので、エラーが実行時にスローされることはありません、それでふさわしいのはエラー伝達を抑制することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, if the init(name:) initializer of the superclass were ever called with an empty string as the name, the forced unwrapping operation would result in a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、スーパークラスのinit(name:)イニシャライザがもしかその名前として空の文字列で呼び出されたならば、強制アンラップ操作は実行時エラーという結果になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, it is not possible to retrieve a planet with a position of 11, and so the else branch is executed instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、11の位置で惑星を取り出すことは可能ではありません、それでelse分岐が代わりに実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the array literal contains two String values and nothing else.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、配列リテラルは、２つのString値を含んでいて他には何も含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the capture list is [unowned self], which means “capture self as an unowned reference rather than a strong reference”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、捕獲リストは[unowned self]です、それは、「selfを強い参照ではなく非所有者参照として捕獲する」ことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the expression is written as \(Double(multiplier) * 2.5) when it is included inside the string literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、式は、それがリテラル文字列に含められる時、\(Double(multiplier) * 2.5)と書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the loop contains only one statement, which prints an entry from the five-times table for the current value of index.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合では、ループは１つの文だけを含みます、それは、indexの現在の値に対する九九の５の段の項を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this data model, a customer may or may not have a credit card, but a credit card will always be associated with a customer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このデータ・モデルにおいて、顧客はクレジットカードを持っているかもしれないし、持っていないかもしれません、しかし、クレジットカードは常にひとりの顧客と結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this data model, every country must always have a capital city, and every city must always belong to a country.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このデータ・モデルにおいて、あらゆる国に常に主都がなければなりません、そして、あらゆる都市は常に国に属していなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this dictionary, the keys are three-letter International Air Transport Association codes, and the values are airport names:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この辞書では、キーは３文字の国際航空運送協会コードです、そして値は空港名です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, (404, "Not Found") is a tuple that describes an HTTP status code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、(404, "Not Found")がひとつのタプルです、それはHTTP状態コードを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, firstNumber is a named constant for the value 10, and secondNumber is a named constant for the value 42.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、firstNumberは、値10のための名前をつけられた定数です、そして、secondNumberは値42のための名前をつけられた定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, someResolution.width refers to the width property of someResolution, and returns its default initial value of 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、someResolution.widthはsomeResolutionのwidthプロパティに言及して、その省略時の初期値の0を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, actualNumber is simply used to print the result of the conversion.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、actualNumberは単にその変換の結果を出力するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, PrettyTextRepresentable adds a single requirement to provide a gettable property called prettyTextualDescription that returns a String.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、PrettyTextRepresentableは１つの要件を加えて、Stringを返すprettyTextualDescriptionと呼ばれる取得可能なプロパティを提供するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, a Double value of 1.0 is considered to represent “one meter”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、1.0のDouble値は「１メートル」を表すと考慮されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, a new instance of TimesTable is created to represent the three-times-table.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、TimesTableの新しいインスタンスは、九九の３の段を表すためにつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, code execution will continue only if age &gt;= 0 evaluates to true, that is, if the value of age is non-negative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、コードの実行はage &gt;= 0がtrueに評価される場合、すなわち、ageの値が負数でない場合にのみ続行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, each item in the array might be a Movie, or it might be a Song.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、配列の各項目はMovieであるかもしれませんし、それはSongであるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, initialization begins with a call to a convenience initializer on the subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、初期化はサブクラス上での便宜イニシャライザへの呼び出しから始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, it checks whether game is actually an instance of SnakesAndLadders behind the scenes, and prints an appropriate message if so.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、gameが実際に舞台裏でSnakesAndLaddersのインスタンスであるかどうか調べて、もしそうならば適切なメッセージを出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, it simply prints out the value that is about to be set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、それは単に設定されようとしている値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, it would be preferable to write the sorting closure inline, using closure expression syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、クロージャ式構文を使って、ソート・クロージャを行内に書くことがずっと好ましいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the buyFavoriteSnack(person: vendingMachine:) function looks up a given person’s favorite snack and tries to buy it for them by calling the vend(itemNamed:) method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例において、buyFavoriteSnack(person: vendingMachine:)関数は指定された個人のお気に入りのスナックを探してそれを彼らのために仕入れることをvend(itemNamed:)メソッドを呼ぶことによって試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the makeASandwich() function will throw an error if no clean dishes are available or if any ingredients are missing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例において、makeASandwich()関数は、綺麗な皿が利用可能でないならばまたは何の食材も見つからないならばエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the attempt to set the address property of john.residence will fail, because john.residence is currently nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例において、john.residenceのaddressプロパティを設定する試みは失敗します、なぜならjohn.residenceが現在nilだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the attempt to set the address property of john.residence will succeed, because the value of john.residence currently contains a valid Residence instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例において、john.residenceのaddressプロパティを設定しようとする試みは成功します、なぜならjohn.residenceの値は現在は有効なResidenceインスタンスを含むからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the closing &gt; characters are not treated as a single token that may then be misinterpreted as a bit shift &gt;&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例において、閉じ&gt;文字たちは、単一のトークンとして見なされることはなく、それでビットシフト演算子&gt;&gt;と誤解されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the maximum number of allowed login attempts is declared as a constant, because the maximum value never changes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例において、許可されるログインの試みの最大数は、最大の値が決して変わらないので、定数として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the number 5 is correctly identified as a prime number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、数5は正しく素数と確認されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the superclass for RecipeIngredient is Food, which has a single convenience initializer called init().</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、RecipeIngredientのためのスーパークラスはFoodです、それは、init()と呼ばれる一つの便宜イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the value of friendlyWelcome is changed from "Hello!" to "Bonjour!":</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、friendlyWelcomeの値は、"Hello!"から"Bonjour!"に変えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the variable number is initialized with the value of the closure’s number parameter, so that the value can be modified within the closure body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、変数numberはこのクロージャの持つnumberパラメータの値を使って初期化されます、それでその値はクロージャ本体の内部で修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this figure, the left channel has a current level of 9, and the right channel has a current level of 7:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この図には、左のチャンネルに現在9のレベルがあり、右のチャンネルに現在7のレベルがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this form, each case block consists of the case keyword followed by one or more enumeration cases, separated by commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この形式では、それぞれのケース節ブロックはキーワードcaseとそれに続く一つ以上の、コンマで区切られた、列挙ケース節から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this form, each case block consists of the case keyword, followed by one or more enumeration cases, separated by commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この形式では、それぞれのケース節ブロックはキーワードcase、それに続けて、コンマで区切られる一つ以上の列挙ケース節から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this implementation, the input parameters are named left and right to represent the Vector2D instances that will be on the left side and right side of the + operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この実装において、入力パラメータは、leftとrightという名前をつけられ、+演算子の左側と右側にあるVector2Dインスタンスを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this scenario, it is useful to combine an unowned property on one class with an implicitly unwrapped optional property on the other class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この筋書きにおいて、一方のクラス上の非所有者プロパティと他方のクラス上の暗黙的にアンラップされるオプショナルのプロパティを結合することは、役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this situation, the parameter name takes precedence, and it becomes necessary to refer to the property in a more qualified way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この状況には、パラメータ名が優先されます、そして、より対象を限定するやり方でプロパティに言及することが必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this version of the game, the first action in the loop is to check for a ladder or a snake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲームのこの改作において、ループでの最初の活動は、はしごまたはヘビについて調べることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-Out Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>In-Outパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-out parameters are an alternative way for a function to have an effect outside of the scope of its function body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータは、その関数本体のスコープの外で効果を持つようにする関数のための代替の方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-out parameters are discussed in In-Out Parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータは、in-outパラメータで議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-out parameters are discussed in detail in In-Out Parameters, below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータは詳細に、下で、in-outパラメータにおいて議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-out parameters are not the same as returning a value from a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータは、関数からある値が返されることと同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-out parameters are passed as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータは、以下のように渡されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-out parameters cannot have default values, and variadic parameters cannot be marked as inout.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>In-outパラメータは省略時の値を持つことができません、そして可変長パラメータはinoutとして印されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Includes a new section on Extended Grapheme Clusters and more information about Unicode Scalars and Comparing Strings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張書記素クラスタに関する新しい節そしてユニコード・スカラーと文字列を比較するについての更なる情報を含めました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indeed, if you are writing a single-target app, you may not need to specify explicit access control levels at all.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際に、あなたが単一ターゲットのアプリを書いているならば、明確なアクセス制御水準を指定する必要はまったくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indeed, if you delete the typealias ItemType = Int line from the code above, everything still works, because it is clear what type should be used for ItemType.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本当に、あなたが上のコードから行typealias ItemType = Intを削除するならば、すべては依然として働きます、なぜなら、どんな型がItemTypeのために使われなければならないかは明白であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indeed, if you tried to access the instance, your app would most likely crash.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実はそれどころか、あなたがそのインスタンスにアクセスしようとするならば、あなたのアプリはたぶんクラッシュするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inferring Type From Context</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文脈から型を推論する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inferring parameter and return value types from context</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前後関係からパラメータおよび戻り値の型を推論する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Infix Operator Methods no longer require the @infix attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接中辞演算子メソッドはもはや@infix属性を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Infix operators can optionally specify a precedence group.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接中辞演算子は、任意に優先順位グループを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inheritance</seg>
      </tuv>
      <tuv lang="JA">
        <seg>継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inheritance enables one class to inherit the characteristics of another.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>継承は、あるクラスが他のものの特徴を受け継ぐのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inheritance is a fundamental behavior that differentiates classes from other types in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>継承は、スウィフトにおいてクラスを他の型と区別する基本的挙動です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initial values for the properties of the new instance can be passed to the memberwise initializer by name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいインスタンスのプロパティのための初期値は、名前でメンバー関連イニシャライザに渡されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initial values for the properties of the new instance can be passed to the memberwise initializer by name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいインスタンスのプロパティのための最初の値は、名前によってメンバー関連イニシャライザに渡されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initialization Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initialization failure propagates through initializer delegation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化失敗は、イニシャライザ委任を通じて伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initialization parameters have the same capabilities and syntax as function and method parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化パラメータは、関数およびメソッドのパラメータと同じ能力と構文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer Delegation for Class Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス型のためのイニシャライザ委任</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer Delegation for Value Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型のためのイニシャライザ委任</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer Inheritance and Overriding</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザの継承およびオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer Parameters Without Argument Labels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルのないイニシャライザ・パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer Requirements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer declarations are declared using the init keyword and have two basic forms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ宣言は、キーワードinitを使って宣言されて、２つの基本の書式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializers are described in more detail in Initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザは、更に詳細に初期化で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializers are now able to access self and can modify its properties, call its instance methods, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザは、今ではselfにアクセスすることができます、そしてそれのプロパティを修正すること、それのインスタンスをメソッドを呼び出すこと、などが行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializers can call other initializers to perform part of an instance’s initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザは、あるインスタンスの初期化の一部を実行するために他のイニシャライザを呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializers can delegate to other initializers in the enumeration, but the initialization process is complete only after an initializer assigns one of the enumeration cases to self.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザは、その列挙の中の他のイニシャライザに委任することができます、しかしその初期化処理はあるイニシャライザが列挙ケース節のうちの１つをselfに代入した後になって初めて終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializers in structures and enumerations can call other declared initializers to delegate part or all of the initialization process.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体および列挙のイニシャライザは、初期化プロセスの一部または全てを委任するために他の宣言済みイニシャライザを呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializing an Empty String</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の文字列を初期化する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializing from a Raw Value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値から初期化する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inserting -9 and 4 into the equation yields:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>-9と4を等式に入れることは、以下を生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inserting 9 and 4 into this equation yields:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>9と4をこの等式に入れることは、以下を生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inserting and Removing</seg>
      </tuv>
      <tuv lang="JA">
        <seg>差し込みと削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside a closure with no explicit parameter names, the parameters are implicitly named $0, $1, $2, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明確なパラメータ名のないクロージャの内部で、パラメータは暗黙のうちに$0、$1、$2、などと名前をつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside a function, the value of #function is the name of that function, inside a method it is the name of that method, inside a property getter or setter it is the name of that property, inside special members like init or subscript it is the name of that keyword, and at the top level of a file it is the name of the current module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の内側では、#functionの値は、その関数の名前であり、メソッドの内側ではそれはそのメソッドの名前であり、プロパティゲッターやセッターの内側ではそれはそのプロパティの名前であり、initまたはsubscriptのような特別なメンバーの内側ではそれはそのキーワードの名前であり、そしてあるファイルのトップレベルではそれは現在のモジュールの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside a protocol declaration, a type alias can give a shorter and more convenient name to a type that is used frequently.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言の内部で、型エイリアスはより短くより便利な名前を頻繁に使われる型に提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside the do block, you mark code that can throw an error by writing try in front of it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>doブロックの内部で、あなたはエラーをスローできるコードを、それの前にtryを書くことによって印します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside the catch block, the error is automatically given the name error unless you give it a different name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>catchブロック内部で、エラーは、あなたがそれに別の名前を与えるのでない限り、自動的に名前errorを与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside the switch, the enumeration case is referred to by the abbreviated form .hearts because the value of self is already known to be a suit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スイッチの内側では、列挙のケース節は省略された形式.heartsによって参照されます、なぜならselfの値がすでに組み札のひとつ（スペード、クラブ、ハート、ダイヤのどれか）であるということがわかっているからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instance Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instance methods added with an extension can also modify (or mutate) the instance itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張を使って加えられるインスタンスメソッドは、また、インスタンスそれ自体を修正（または変更）することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instance methods have exactly the same syntax as functions, as described in Functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスメソッドは、関数と正確に同じ構文を持ちます、関数で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instance methods, as described above, are methods that are called on an instance of a particular type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスメソッドは、先に述べたように、特定の型のインスタンスの上で呼ばれるメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instance properties are properties that belong to an instance of a particular type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスプロパティは、ある特定の型のあるひとつのインスタンスに属しているプロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instances of FixedLengthRange have a variable stored property called firstValue and a constant stored property called length.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>FixedLengthRangeのインスタンスはfirstValueと呼ばれる変数保存プロパティとlengthと呼ばれる定数保存プロパティをもちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instances of Hamster can now be used wherever TextRepresentable is the required type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>TextRepresentableが必要な型であるどこででも、Hamsterのインスタンスが現在使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instances of class types can also implement a deinitializer, which performs any custom cleanup just before an instance of that class is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス型のインスタンスはまた、デイニシャライザを実装することができます、それは、そのクラスのインスタンスの割り当て解除がされる直前に、何らかのあつらえのクリーンアップ作業を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of generating a random number, it starts with a diceRoll value of 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>無作為な数を生成する代わりに、それは0のdiceRoll値から始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of returning a new point, this method actually modifies the point on which it is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい点を返す代わりに、このメソッドは、それが呼び出された点を実際に修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, Rect defines a custom getter and setter for a computed variable called center, to enable you to work with the rectangle’s center as if it were a real stored property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、Rectは、centerと呼ばれる計算される変数のためにあつらえのゲッターとセッターを定義して、矩形のcenterをそれがまったく保存プロパティであるかのようにあなたが扱うことができるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, a literal is parsed as having infinite precision and Swift’s type inference attempts to infer a type for the literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうではなく、リテラルは無限精度を持つものとして解析されて、スウィフトの型推論はそのリテラルの型を推測することを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it makes more sense to create the DataImporter instance if and when it is first used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、それが最初に必要とされる時になればDataImporterを作成するほうが筋が通ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, make an explicit check against nil with the == or != operators to find out if an optional contains a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、nilに備えて、==または!=演算子を使ってオプショナルが値を持つかどうか確認するために明示的に調べてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the Stack type’s existing type parameter name, Element, is used within the extension to indicate the optional type of the topItem computed property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうしなくても、Stack型の既存の型パラメーター名、Elementは、拡張の内部でtopItem計算プロパティの元々の型を指し示すために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the addition assignment operator method takes advantage of the existing addition operator method, and uses it to set the left value to be the left value plus the right value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに、追加代入演算子メソッドは、既存の加算演算子メソッドを利用して、左の値を右の値を加えた左の値に設定するためにそれを使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the different enumeration cases are fully-fledged values in their own right, with an explicitly-defined type of CompassPoint.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、異なる列挙ケース節は、ある明示的に定義された型であるCompassPointを持つ、他に頼らない完全に自立した値です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the entire switch statement finishes its execution as soon as the first matching switch case is completed, without requiring an explicit break statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、最初のマッチしているswitchケース節の部分が完了されるとすぐに、switch文の全体がその実行を終えます、明確なbreak文を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the entire switch statement completes its execution as soon as the first matching case is completed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、最初の適合するケース節が完了されるとすぐに、スイッチ文の全体がその実行を完了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the loop is executed until a particular condition is satisfied.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、このループは特定の条件が満たされるまで実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the protocol’s own access level is used to provide the default access level for each protocol requirement implementation within the extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、プロトコル自身のアクセス水準が、省略時のアクセス水準を拡張内の各プロトコル要件実施のために提供するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the type parameter list from the original type definition is available within the body of the extension, and the original type parameter names are used to refer to the type parameters from the original definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうしなくても、元々の型定義からの型パラメーターリストは、その拡張の本文内で利用可能です、そして元々の型パラメーター名は、元々の定義からの型パラメーターを参照するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, these references are defined like any other constant or variable in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、これらの参照は、スウィフトにおけるあらゆる他の定数または変数と同じように定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, they are called only when the value is set outside of an initialization context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうではなく、値が初期化の文脈の外で設定されるときにだけ、それらは呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、それらは他のプロパティや値を間接的に取得したり設定したりするためにゲッターと任意のセッターを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, this example calls UInt16(one) to create a new UInt16 initialized with the value of one, and uses this value in place of the original:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、この例はoneの値で初期化される新しいUInt16を作るためにUInt16(one)を呼んで、オリジナルの代わりにこの値を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, use the append(_:) method, or append a single-item array with the += operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、append(_:)メソッドを使ってください、または単一項目の配列を+=演算子を使って加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer Bounds</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数の限界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer Conversion</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer Literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer and Floating-Point Conversion</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数と浮動小数点の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer literals can be written as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数リテラルは、次のように書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer literals can begin with leading zeros (0), but they are likewise ignored and don’t affect the base or value of the literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数リテラルは、いくつかのゼロ（0）を先頭に始まることができます、しかしそれらは同様に無視されて、リテラルの基数または値に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integers are either signed (positive, zero, or negative) or unsigned (positive or zero).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数は、符号つき（正、ゼロ、または負）または符号なし（正またはゼロ）のどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interface Builder attributes are declaration attributes used by Interface Builder to synchronize with Xcode.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかのインターフェースビルダー属性は、Xcodeと同期するためにインターフェースビルダーによって使用される宣言属性です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interval Matching</seg>
      </tuv>
      <tuv lang="JA">
        <seg>区間マッチング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It adds a director property on top of the base MediaItem class, with a corresponding initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、対応するイニシャライザを使って、基盤クラスMediaItemの上にdirectorプロパティを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It adopts the readability of Objective-C’s named parameters and the power of Objective-C’s dynamic object model.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、Objective-Cの名前付きパラメータの読みやすさとObjective-Cの動的なオブジェクト・モデルのパワーを採用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also cannot transfer control into a case block whose pattern contains value binding patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、パターンが値束縛パターンを含むケース節ブロックに制御を移すことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also defines a computed property called description, which uses the values stored in rank and suit to build a description of the name and value of the card.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、descriptionと呼ばれる計算プロパティを定義します、それは、rankとsuitに保管される値を使って、カードの名前と説明の値を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also defines a protocol called Aged, with a single requirement for a gettable Int property called age.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、ageと呼ばれる取得可能なIntプロパティのための要件を１つ持つ、Agedと呼ばれるプロトコルを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also defines an array of integers, ready to be converted into strings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、文字列に変換される準備ができている整数の配列も定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also means you can be confident about the type of values you will retrieve from a collection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、あなたがコレクションから取り出す値の型をあなたが確信できることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also offers two methods—distribute(coins:) and receive(coins:)—to handle the distribution and collection of coins.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、２つのメソッド ― distribute(coins:)とreceive(coins:)— ― を提供して、コインの配布と回収を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also provides a method called complete(level:), which is called whenever a player completes a particular level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまたcomplete(level:)と呼ばれるメソッドを提供します、それは、プレーヤーが特定のレベルを完了するときはいつでも呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also tracks the current level for an individual player.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、個々のプレーヤーのために現在のレベルを追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It appends a colon and a line break, and uses this as the start of its pretty text representation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはコロンと改行を追加します、そしてそれのきれいなテキスト表示のスタートとして、これを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It calculates the last digit of number by using the remainder operator (number % 10), and uses this digit to look up an appropriate string in the digitNames dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、numberの最後の桁を剰余演算子を使用することによって計算して（number % 10）、この桁をdigitNames辞書で適切な文字列を捜すために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It calls the provided function with the values 3 and 5, and prints the result of 8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、提供された関数を値3と5を使って呼び出して、結果の8を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can also be useful to define requirements for associated types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型のために要件を定義することは、また同様に役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can also match a value with a range of values, by checking whether the value is contained within the range, as the following example shows.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、ある値をある範囲の値と照合することが、その値がその範囲に含まれるかどうかを調べることによって可能です、以下の例が示すように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be described as “a tuple of type (Int, String)”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは型(Int, String)のタプルとして記述されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be read as “not a”, as seen in the following example:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、「aでない」のように読まれることができます、下記の例では見られるように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be useful to require a type to conform to multiple protocols at once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型に一度に複数のプロトコルに従うことを要求することは、役に立つことがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can do this with a control transfer statement such as return, break, continue, or throw, or it can call a function or method that doesn’t return, such as fatalError(_:file:line:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはこれを制御移動文return、break、continue、またはthrowなどで行えます、またはそれは復帰しない関数やメソッド、例えばfatalError(_:file:line:)を呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can sometimes be useful to find out if two constants or variables refer to exactly the same instance of a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの定数または変数が正確にあるクラスの同じインスタンスに言及するかどうかについて、知ることは時々役に立つことがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It cannot be called in isolation without an existing instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、単独で既存のインスタンスなしで呼ばれることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It cannot be modified by a subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、サブクラスによって修正されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can’t call any other initializers of the same class, and if the class has a superclass, it must call one of the superclass’s designated initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは同じクラスの他のどのイニシャライザも呼ぶことができません、そしてそのクラスがスーパークラスを持つならば、それはスーパークラスの指定イニシャライザのうちの１つを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It compares the new value of totalSteps against the old value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、totalStepsの新しい値をその古い値と比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of a period (.) between the item and the identifier of its member.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、その項目とそれのメンバーの識別子の間のピリオド（.）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It delegates across to a designated initializer from the same class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、横の同じクラスの指定イニシャライザに向かって委任します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does this by capturing a reference to runningTotal and amount from the surrounding function and using them within its own function body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、それを囲んでいる関数からrunningTotalとamountへの参照を捕獲して、それらをそれ自身の関数本文内で使うことによってこれを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does this by implementing the optional fixedIncrement property requirement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、オプショナルのfixedIncrementプロパティ要件を実装することによってこれをします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doesn’t make sense for volume to be settable, because it would be ambiguous as to which values of width, height, and depth should be used for a particular volume value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>volumeが設定可能であることは意味をなしません、なぜなら特定のvolume値に対してwidth、height、そしてdepthにどの値が使われなければならないかはあいまいだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doesn’t matter that "zebra" isn’t less than "apple", because the comparison is already determined by the tuples’ first elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>"zebra"が"apple"より少ないことは問題ではありません、この比較はすでにタプルの最初の要素によって決定されているからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doesn’t matter what that function’s implementation actually does—it matters only that the function is of the correct type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関数の実装が実際に何をするかは、重要ではありません ― ただ関数が正しい型であるのが重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doesn’t take any arguments, and when it’s called, it returns the value of the expression that’s wrapped inside of it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、全く引数を取りません、そしてそれが呼ばれる時、その内部に包み込まれた式の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doubles the x and y values of a Vector2D instance, by adding the vector to itself with the addition assignment operator defined earlier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはVector2Dインスタンスのxとy値を、そのベクトルをそれ自体へと以前に定義される加算代入演算子を使って加えることによって２倍にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It enables you to represent almost any character from any language in a standardized form, and to read and write those characters to and from an external source such as a text file or web page.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、あなたにほとんどどんな文字でもどんな言語のものでも標準化された方式で表わすこと、そしてそれらの文字を、テキスト・ファイルやウェブ・ページのような外部のソースへ書き込んだり、それらから読み込んだりすることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It evaluates an addition or multiplication by evaluating the expression on the left hand side, evaluating the expression on the right hand side, and then adding them or multiplying them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは加算や乗算を、左手側の式を評価する、右手側の式を評価すること、そしてそれからそれらを加算や乗算することで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It executes a set of statements only if that condition is true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、その条件がtrueの場合にだけ、あるひとまとめにした文を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has already been initialized with the value contained within the optional, and so there is no need to use the ! suffix to access its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、すでにオプショナルの内部に含まれる値で初期化されています、それでその値にアクセスするために!接尾辞を使う必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has one of the following forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、以下の書式のうちの１つを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has the following forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、以下の各形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It illustrates how the designated initializers in this hierarchy act as “funnel” points for class initialization, simplifying the interrelationships among classes in the chain:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、この階層の中の指定イニシャライザが、どのようにクラス初期化のために「漏斗」地点の働きをして、この連鎖におけるクラス間の相互関係を単純化しているかを図示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It introduces an Int property called quantity (in addition to the name property it inherits from Food) and defines two initializers for creating RecipeIngredient instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、quantityと呼ばれるIntプロパティ（加えてそれがFoodから受け継ぐnameプロパティ）を導入して、そしてRecipeIngredientインスタンスをつくるために２つのイニシャライザを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is a compile-time error to write a structure or enumeration definition that tries to adopt SomeClassOnlyProtocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SomeClassOnlyProtocolを採用しようと試みる構造体や列挙定義を書くことは、コンパイル時エラーになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is a shortcut for evaluating one of two expressions based on whether question is true or false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、questionが真実であるか間違っているかに基づいて、２つの式のうちの１つを評価することに対する近道です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is a single-player game, but can store information for multiple players on a single device.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはシングルプレーヤーのゲームです、しかし一つの装置上で複数のプレーヤーのために情報を蓄えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is always better to be specific about the types you expect to work with in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いつでもより望ましいのは、あなたのコードで扱うことをあなたが期待する型について明確にすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is always possible to infer the parameter types and return type when passing a closure to a function or method as an inline closure expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャを関数やメソッドに行内クロージャ式として渡すとき、パラメータ型と戻り型を推論することは常に可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is automatically assigned a default value of nil, meaning “no string yet”, when a new instance of SurveyQuestion is initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、SurveyQuestionの新しいインスタンスは初期化される時に、「まだ無い文字列」を意味する、省略時の値のnilを自動的に代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is even valid for a subclass member to call a superclass member that has lower access permissions than the subclass member, as long as the call to the superclass’s member takes place within an allowed access level context (that is, within the same source file as the superclass for a file-private member call, or within the same module as the superclass for an internal member call):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスのメンバーへの呼び出しがある許されるアクセス水準文脈内で（すなわち、ファイル外非公開メンバー呼び出しのためのスーパークラスと同じソースファイル内で、または内部メンバー呼び出しのためのスーパークラスと同じモジュール内で）起こる限り、サブクラスメンバーより低いアクセス許可を持つスーパークラスメンバーを呼び出すことは、サブクラスメンバーにとってさえ有効です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is explained in detail below in Capturing Values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、下で詳細に値を捕獲する（キャプチャする）の中で説明されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is good practice to create immutable collections in all cases where the collection does not need to change.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのコレクションを変更する必要がないすべての場合において不変のコレクションを作成することは良い習慣です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is implicitly declared simply by its inclusion in the loop declaration, without the need for a let declaration keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはループ宣言にひっくるめることによって、let宣言キーワードの必要なしで、簡易に暗黙のうちに宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to consider each operator’s precedence and associativity when working out the order in which a compound expression will be calculated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合の式が計算される順番を解決するとき、各演算子の優先順位と結合性を考慮することは、重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not appropriate to set threeTimesTable[someIndex] to a new value, and so the subscript for TimesTable is defined as a read-only subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>threeTimesTable[someIndex]を新しい値に設定することは適切ではありません、なのでTimesTableのための添え字は、読み出し専用の添え字として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not of type Dice, or DiceGame, or Hamster, even if the actual instance behind the scenes is of one of those types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは型Dice、またはDiceGame、またはHamsterではありません、たとえ舞台裏の実際のインスタンスがそれらの型のうちの１つであるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible for Swift to guess what would qualify as “equal” for your own custom types, because the meaning of “equal” depends on the roles that those types play in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトには何があなたのあつらえの型にとって「等しい」と認められるべきか推測することは不可能です、なぜなら「等しい」の意味することはそれらの型があなたのコードで演じる役割に依存するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible to overload the default assignment operator (=).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もとからある代入演算子（=）をオーバーロードすることは不可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not strictly necessary to use the gameLoop label when calling continue gameLoop to jump to the next iteration of the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループの次の繰り返しへジャンプするためにcontinue gameLoopを呼ぶとき、gameLoopラベルを使用することは厳密には必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not valid to mark the definition of someFunction() with the public or internal modifiers, or to use the default setting of internal, because public or internal users of the function might not have appropriate access to the private class used in the function’s return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>someFunction()の定義がpublicまたはinternalを使って印されること、または省略時設定の内部を使うことは有効ではありません、なぜなら、この関数の公開や内部のユーザーは適切なアクセスを関数の戻り型の中で使われる非公開クラスに対して持たないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not valid to write a public property with a private type, for example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、非公開の型で公開のプロパティを書くことは、有効ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not valid to write the following code, because the first case is empty:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のケース節が空であるので、以下のコードを書くことは、有効ではありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is now possible to iterate over the items in the array, and print each item’s textual description:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在この配列の項目の上に繰り返して、各項目のもつ説明テキストを出力することが可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is often useful to execute different pieces of code based on certain conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定の状況に基づいて異なるコード小片を実行することは、しばしば役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible for a DataManager instance to manage its data without ever importing data from a file, so there is no need to create a new DataImporter instance when the DataManager itself is created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>DataManagerインスタンスがそれのもつデータを管理することはデータをファイルから一度もインポートしなくとも可能ですので、DataManager自体がつくられるときに、新しいDataImporterインスタンスをつくる必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is rare that you need to write type annotations in practice.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが型注釈を書く必要があることは実際問題として、まれです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is reasonable to expect that the encapsulated values will be copied rather than referenced when you assign or pass around an instance of that structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがその構造体のインスタンスをあちこち代入したり、渡したりするとき、カプセル化された値が参照をつけられるのではなくコピーされるのが当然だと思うことが道筋が立っている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is said to be half-open because it contains its first value, but not its final value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが半開と言われるのは、それがその最初の値を含むけれども、その最後の値は含まないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is set to be interlaced, and is given a name of "1080i".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、インターレースに設定され、"1080i"の名前を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is sometimes necessary for a method to modify (or mutate) the instance it belongs to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドがそれが属しているインスタンスを修正する（または変化させる）ことは、時々必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is sometimes useful to define a class, structure, or enumeration for which initialization can fail.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに対するイニシャライザが失敗できるクラス、構造体、または列挙を定義することは時として便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is sometimes useful to include parentheses when they are not strictly needed, to make the intention of a complex expression easier to read.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複雑な式をより簡単に読めるようにするため、丸括弧をそれらが厳密には必要とされないとき含むことは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the frameRate property of the underlying VideoMode that is changed, not the values of the constant references to that VideoMode.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、根底にあるVideoModeの変更可能なframeRateプロパティです、そのVideoModeに対する参照をもつこれら定数の値ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the first industrial-quality systems programming language that is as expressive and enjoyable as a scripting language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、スクリプティング言語と同じくらい表現が豊かで楽しい、最初の工業品質システムのプログラミング言語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is then incremented by 1 using the overflow addition operator (&amp;+).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、それからオーバフロー加算演算子（&amp;+）を使って1だけ増やされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is therefore appropriate to write this initializer as init(_ celsius: Double) so that it can be called by providing an unnamed Double value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、適切なのはこのイニシャライザをinit(_ celsius: Double)のように書くことであり、それによってそれは名前のないDouble値を提供することで呼び出されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It lets you write the code that’s typically executed without wrapping it in an else block, and it lets you keep the code that handles a violated requirement next to the requirement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはあなたにコードをそれが概ねelseブロックの内にそれを包み込むことなしに実行されるように書かせて、尚且つそれはあなたにコードをそれがある破られた要件から次の要件を取り扱うように保ったままにさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It makes for shorter, clearer initializers and enables you to infer the type of the property from its default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、より短い、より明白なイニシャライザを作り、あなたにその省略時の値からプロパティの型を推論するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may seem an unusual way to represent negative numbers, but it has several advantages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは負数を表す普通でない方法のようかもしれません、しかしそれはいくつかの利点を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It multiplies a starting value of 1 (that is, 3 to the power of 0) by 3, ten times, using a closed range that starts with 1 and ends with 10.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは開始値の1（すなわち、3の0乗）に3を掛けることを、10回、1から始まり10で終わる完結範囲を使って行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It must be possible to access a count of the items in the container through a count property that returns an Int value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンテナの中の項目の総数にアクセスすることがInt値を返すcountプロパティを通して可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It must be possible to add a new item to the container with an append(_:) method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい項目をコンテナに加えることがappend(_:)メソッドで可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It must be possible to retrieve each item in the container with a subscript that takes an Int index value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンテナの中の各項目を取り出すことがIntインデックス値をとる添え字で可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides a gettable dice property and a play() method in order to conform to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、プロトコルに従うために取得可能なdiceプロパティとplay()メソッドを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides seamless access to existing Cocoa frameworks and mix-and-match interoperability with Objective-C code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、既存のココア・フレームワークへのシームレスなアクセスと、Objective-Cコードで色々なものを組み合わせる相互運用性を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It resets a numberOfTurns property to zero when the game starts, increments it each time a new turn begins, and prints out the total number of turns once the game has ended.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、ゲームが始まるときnumberOfTurnsプロパティをゼロに再設定します、新しいターンが開始するときそれぞれそれを増加させます、そしてひとたびゲームが終わってしまったならばターンの総数を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns true if the expression can be cast to the specified type; otherwise, it returns false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、式が指定された型へキャストできるならばtrueを返します；そうでなければfalseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns a new number whose bits are set to 1 only if the bits were equal to 1 in both input numbers:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはある新しい数を返します、それのビットは両方の入力数においてビットが1と等しかった場合にだけ1に設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns an integer value to indicate the actual number of coins that were provided.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、提供されたコインの実際の数を示す整数値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It says “I am done with the current loop iteration” without leaving the loop altogether.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、そのループをすっかり止めてしまわずに「私は、現在のループ繰り返しを終えた」と言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It starts by calculating an appropriate origin point based on a center point and a size value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、center地点とsize値に基づいて適切な原点を計算することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It starts with an initial value of 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、初期値の0から始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It states that it adopts the FullyNamed protocol as part of the first line of its definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、その定義の最初の行の部分でそれがFullyNamedプロトコルを採用すると述べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It supports playgrounds, an innovative feature that allows programmers to experiment with Swift code and see the results immediately, without the overhead of building and running an app.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはplayground（遊び場）をサポートします、それは、プログラマーにスウィフトのコードで実験して直ちに結果を知ることをアプリをビルドして実行するオーバーヘッドなしに出来るようにする、革新的な機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then calls (or delegates) to the init(origin:size:) initializer, which stores the new origin and size values in the appropriate properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、それからinit(origin:size:)イニシャライザに呼び出し（または委任）をします、それは、新しい原点とサイズ値を適切なプロパティに格納します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then calls a designated initializer on its superclass to continue the initialization up the chain.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはそれから、連鎖を上って初期化を続けるために、そのスーパークラス上で指定イニシャライザを呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then continues to repeat the loop until the condition is false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはそれから、条件がfalseになるまでループを繰り返し続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then declares a variable called cinema and sets it to the current value of hd.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、それからcinemaと呼ばれる変数を宣言して、それをhdの現在の値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then executes an appropriate block of code, based on the first pattern that matches successfully.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはそれから、うまく合う最初のパターンに基づいて、適切なコードのブロックを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then iterates through the array of board squares, and appends a geometric shape to represent the contents of each square:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、それからボードの正方形の配列の端から端まで繰り返して、ある幾何学形を各正方形の内容を表わすために追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then uses the fallthrough keyword to “fall into” the default case as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはそれからfallthroughキーワードを使って、defaultケース節にもまた「落ちていく」ようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It uses an instance property called currentLevel to track the level that a player is currently playing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはcurrentLevelと呼ばれるインスタンスプロパティをプレーヤーが現在プレイしているレベルを追跡するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It uses special values for jack, queen, king, and ace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、jack、queen、king、そしてaceのために特別な値を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It uses these methods to keep track of the number of turns a game has taken.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、あるゲームがとったターンの数の情報を得続けるためにこれらのメソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It would be convenient for an inventory tracking system to be able to store UPC barcodes as a tuple of four integers, and QR code barcodes as a string of any length.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>UPCバーコードを４つの整数のタプルとして、そしてQRコード・バーコードを任意の長さの文字列として保存できるのは、在庫追跡システムにとって便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It would be much more useful to define a generic Stack class, that can manage a stack of any type of value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それをもっと役に立つようにするには、総称体Stackクラスを定義することです、それはあらゆる型の値のスタックを管理することができるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It would be much more useful, and considerably more flexible, to write a single function that could swap two values of any type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが、ずっと役に立ち、さらにもっと柔軟であるようにするには、あらゆる型の２つの値を交換できるただ１つの関数を書くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Items in a Dictionary may not necessarily be iterated in the same order in which they were inserted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Dictionaryの中の項目は、必ずしもその中にそれらが書き入れられたのと同じ順序で繰り返されるわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterating Over a Dictionary</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書じゅうを繰り返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterating Over a Set</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合全体を繰り返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterating Over an Array</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列じゅうを繰り返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its conciseness can lead to hard-to-read code if overused.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その簡潔さは、濫用されるならば、読み辛いコードに至る可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its keys are of type Int, and its values are of type String.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのキーはInt型です、そしてその値はString型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its parameters are then implicitly named $ followed by their position: $0, $1, $2, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのパラメータは、それから暗黙のうちに$の後にそれらの位置が続く名前：$0、$1、$2、などをつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its size is based on a constant called finalSquare, which is used to initialize the array and also to check for a win condition later in the example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その大きさはfinalSquareと呼ばれる定数に基づきます、そして、それがこの配列を初期化して、さらにこの例の後半で勝利したかどうか調べるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s a compile-time error to override a method without the override modifier or to use the override modifier on a method that doesn’t override a superclass method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>override宣言修飾子なしでメソッドをオーバーライドするか、スーパークラスメソッドをオーバーライドしないメソッドでoverride宣言修飾子を使用することは、コンパイル時エラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s applied to a class to indicate that the class can’t be subclassed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはクラスに適用されて、そのクラスがサブクラスを作られることができないのを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s applied to a property, method, or subscript of a class to indicate that a class member can’t be overridden in any subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはプロパティ、メソッド、またはクラスの添え字に適用されて、そのクラスメンバーがあらゆるサブクラスにおいてオーバーライドされることができないのを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s common to call functions that take autoclosures, but it’s not common to implement that kind of function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動クロージャを取る関数を呼び出すのは普通です、しかしそのような関数を実装するのは一般的ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s designed to scale from “hello, world” to an entire operating system.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、「hello, world」からひとつのオペレーティングシステム全体までの規模に対して設計されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s either an Int, or it’s nothing at all.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはひとつのInt、またはそれは全く何も無いかのどちらかです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s possible that the dice roll may have moved the player beyond square 25, in which case the game is over.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さいころを振ることが正方形25を越えてプレーヤーを動かす可能性はあり得ます、その場合にはゲームは終了です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just before this happens, its deinitializer is called automatically, and its coins are returned to the bank.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが起こる直前に、そのデイニシャライザは自動的に呼ばれます、そしてそのコインは胴元に返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like functions and methods, initializers can throw or rethrow errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数やメソッドのように、イニシャライザはエラーをスローまたは再スローできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keeping the sign bit the same during this shift means that negative integers remain negative as their value moves closer to zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このシフトの間に符号ビットを同じに保つことは、それの値がゼロの近くに動くとき、負整数が負のままであることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key-Path Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパス式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords and Punctuation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーワードと句読点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords other than inout, var, and let can be used as parameter names in a function declaration or function call without being escaped with backticks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>inout、var、そしてlet以外のキーワードは、パラメータ名として関数定義または関数呼び出しにおいてバッククォートでエスケープされることなく使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords reserved in particular contexts: associativity, convenience, dynamic, didSet, final, get, infix, indirect, lazy, left, mutating, none, nonmutating, optional, override, postfix, precedence, prefix, Protocol, required, right, set, Type, unowned, weak, and willSet.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定の前後関係において予約されるキーワード：associativity, convenience, dynamic, didSet, final, get, infix, indirect, lazy, left, mutating, none, nonmutating, optional, override, postfix, precedence, prefix, Protocol, required, right, set, Type, unowned, weak, そしてwillSet。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords that begin with a number sign (#): #available, #colorLiteral, #column, #else, #elseif, #endif, #file, #fileLiteral, #function, #if, #imageLiteral, #line, #selector, and #sourceLocation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>番号記号（#）で始まるキーワード：#available, #colorLiteral, #column, #else, #elseif, #endif, #file, #fileLiteral, #function, #if, #imageLiteral, #line, #selector, そして#sourceLocation。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords used in declarations: associatedtype, class, deinit, enum, extension, fileprivate, func, import, init, inout, internal, let, open, operator, private, protocol, public, static, struct, subscript, typealias, and var.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言において使用されるキーワード：associatedtype, class, deinit, enum, extension, fileprivate, func, import, init, inout, internal, let, open, operator, private, protocol, public, static, struct, subscript, typealias, そしてvar。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords used in expressions and types: as, Any, catch, false, is, nil, rethrows, super, self, Self, throw, throws, true, and try.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式と型において使用されるキーワード：as, Any, catch, false, is, nil, rethrows, super, self, Self, throw, throws, true, そしてtry。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords used in patterns: _.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターンにおいて使用されるキーワード：_。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords used in statements: break, case, continue, default, defer, do, else, fallthrough, for, guard, if, in, repeat, return, switch, where, and while.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文において使用されるキーワード：break, case, continue, default, defer, do, else, fallthrough, for, guard, if, in, repeat, return, switch, where, そしてwhile。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Labeled Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラベルをつけられた文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Labeled Statements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラベルをつけられた文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Language Guide</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言語ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Language Reference</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言語リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lazy Stored Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延保存プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that should not be performed unless or until it is needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延プロパティはまた、プロパティのための最初の値が、それが必要でないなら、あるいは必要になるまで、実行されるべきではない複雑なまたはコンピュータ処理的に高くつく準備を必要とするときに役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lazy properties are useful when the initial value for a property is dependent on outside factors whose values are not known until after an instance’s initialization is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延プロパティが役に立つのは、プロパティのための最初の値がインスタンスの初期化が終了する後まで値が知られない外部の要因に依存しているときです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Less than (a &lt; b)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より小さい、未満（a &lt; b）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Less than or equal to (a &lt;= b)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より小さいか等しい、以下（a &lt;= b）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexical Structure</seg>
      </tuv>
      <tuv lang="JA">
        <seg>語彙の構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C, Swift has only one ternary operator, the ternary conditional operator (a ? b : c).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cのように、スウィフトはただ１つの三項演算子、三項条件演算子（a ? b : c）だけをもちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C, Swift provides compound assignment operators that combine assignment (=) with another operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cのように、スウィフトは複合代入演算子を提供します、それは、代入（=）を別の演算と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C, Swift uses variables to store and refer to values by an identifying name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cのように、スウィフトはひとつの識別名によっていろいろな値を保管したり引用したりするために、変数を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like a switch statement, the compiler attempts to infer whether catch clauses are exhaustive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文のように、コンパイラはcatch節が徹底的であるか推論を試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like a function declaration, a closure contains statements which it executes, and it captures constants and variables from its enclosing scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数宣言の様に、クロージャはそれらが実行する文を含みます、そして、それはそれの取り囲むスコープから定数と変数をキャプチャします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like a function, an initializer can be used as a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数のように、イニシャライザは値として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like a weak reference, an unowned reference does not keep a strong hold on the instance it refers to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照のように、非所有者参照は、それが言及するインスタンスに対する強い支配力を保ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like a weak reference, the type of the property or value must be a class type; unlike a weak reference, the type is nonoptional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照のように、プロパティや値の型はクラス型でなければなりません；弱い参照と違って、その型は非オプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like all types in Swift, these integer types have capitalized names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおける全ての型のように、これらの整数型は頭文字を使った名前を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like classes and all other named types, enumerations can have methods associated with them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスや全ての他の名前をつけられた型のように、列挙はそれと結びつけられるメソッドを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like other types in Swift, their names (such as CompassPoint and Planet) should start with a capital letter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおける他の型のように、それらの名前（例えばCompassPointおよびPlanet）は、大文字から始めなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like structures but unlike classes, enumerations are value types; instances of an enumeration are copied when assigned to variables or constants, or when passed as arguments to a function call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体のように、しかしクラスとは違い、列挙は値型です；列挙のインスタンスは、変数や定数に代入されるとき、または関数呼び出しに引数として渡されるときにコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like the remove(at:) method, removeLast() returns the removed item:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>removeAtIndex(_:)メソッドのように、remove(at:)は取り除かれた項目を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like the Logical AND operator above, the Logical OR operator uses short-circuit evaluation to consider its expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の論理積演算子のように、論理和演算子はその式を考慮するために短絡評価を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like the body of an if statement, each case is a separate branch of code execution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文の本文のように、各caseは別々の分岐のコード実行です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like the subscript examples above, the updateValue(_:forKey:) method sets a value for a key if none exists, or updates the value if that key already exists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の添え字の例のように、updateValue(_:forKey:)メソッドは、まったく何も存在しないならばあるキーに対して値を設定します、またはキーがすでに存在するならばその値を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, if any of the structure’s stored properties are file private, the initializer is file private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、構造体の持つ保存プロパティのいずれかがファイル外非公開ならば、イニシャライザはファイル外非公開です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, if you don’t specify a type for a floating-point literal, Swift infers that you want to create a Double:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、あなたがある浮動小数点リテラルのために型を指定しないならば、スウィフトはあなたがDoubleをつくりたいと推測します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, method and function declarations are written the same way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらにまた、メソッドおよび関数の宣言も同じやり方で書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, the willSet clause is optional when you provide a didSet clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、あなたがdidSet節を提供するとき、willSet節は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, the failable initializer for Product checks the name value, and the initializer process fails immediately if name is the empty string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、Productのための失敗できるイニシャライザは、name値を確認して、nameが空の文字列ならば初期化処理は直ちに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, type safety prevents you from accidentally passing an optional String to a piece of code that expects a nonoptional String.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに、型安全はあなたがうっかりしてオプショナルStringを非オプショナルStringを期待するコード部分に渡すことを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line Control Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行制御文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line Feed (\n)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラインフィード「字送り文字」（\n）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Linking Multiple Levels of Chaining</seg>
      </tuv>
      <tuv lang="JA">
        <seg>連鎖の複数の階層を結ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literal Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラル式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literal words and punctuation are indicated by boldface constant width text and appear only on the right-hand side of a grammar production rule.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラルの単語と句読点は、太字体の等幅テキストによって示されて、文法導出規則の右側だけに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literally put, an assertion “asserts” that a condition is true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>書かれる通り、ある表明はある条件が真であることを「表明」します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>様々なリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local constants and variables are never computed lazily.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ローカルな定数と変数は、決して遅延して計算されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local variables are variables that are defined within a function, method, or closure context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ローカル変数は、関数、メソッド、またはクロージャの文脈の範囲内で定義される変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical AND (a &amp;&amp; b)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理積（a &amp;&amp; b）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical AND Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理積演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical NOT (!a)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理否定（!a）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical NOT Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理否定演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical OR (a || b)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理和（a || b）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical OR Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理和演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop Statements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop statements allow a block of code to be executed repeatedly, branch statements allow a certain block of code to be executed only when certain conditions are met, and control transfer statements provide a way to alter the order in which code is executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文はコードの１ブロックが繰り返して実行されるようにします、分岐文はコードの特定のブロックを特定の条件が満たされるときにだけ実行されるようにします、そして制御移動文はコードが実行される順番を変える方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop statements allow a block of code to be executed repeatedly, depending on the conditions specified in the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文は、ループにおいて指定される条件に従って、コードの１ブロックを繰り返して実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make an existing type conform to a protocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存の型をプロトコルに準拠させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make another subclass of NamedShape called Circle that takes a radius and a name as arguments to its initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NamedShapeの別のサブクラス、Circleと呼ばれるものを作ってください、それはそのイニシャライザに対する引数として半径と名前をとるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Marking a class as open explicitly indicates that you’ve considered the impact of code from other modules using that class as a superclass, and that you’ve designed your class’s code accordingly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスを明示的に開放とすることが指し示すのは、あなたが、そのクラスをスーパークラスとして使っている、他のモジュール由来のコードの影響を考慮に入れるということです、そしてあなたがあなたのクラスのコードをそれに従って設計するということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Marking a closure with @escaping means you have to refer to self explicitly within the closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクロージャを@escapingで印することは、あなたがそのクロージャ内部でselfを明示的に参照しなければならないのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matched values in a switch case can be bound to temporary constants or variables for use within the case’s body, and complex matching conditions can be expressed with a where clause for each case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるswitchケース節においてマッチされた値は、そのケース節内の本文で使われるために一時的な定数や変数に結び付けられることができます、そして複雑なマッチ条件が各ケース節に対してwhere節を使って表わされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matching Enumeration Values with a Switch Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スイッチ文で列挙値を照合する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Memberwise Initializers for Structure Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体型のためのメンバー関連イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Memory for a new instance of that class is allocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのクラスの新しいインスタンスに対するメモリが割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metatype Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メタタイプ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method Requirements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッド要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods associated with a type rather than an instance of a type must be marked with the static declaration modifier for enumerations and structures or the class declaration modifier for classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型のインスタンスとではなく、ある型と結び付けられるメソッドは、列挙と構造体ではstatic宣言修飾子で、クラスではclass宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods on a subclass that override the superclass’s implementation are marked with override—overriding a method by accident, without override, is detected by the compiler as an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるサブクラスのメソッドで、そのスーパークラスの実装をオーバーライド（再定義）するものは、overrideで印を付けられます ― overrideなしで、偶然にメソッドをオーバーライドすることは、コンパイラによってエラーとして検出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods on an enumeration or a structure that modify self must be marked with the mutating declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙または構造体でのselfを修正するメソッドは、mutating宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods that override a superclass method must be marked with the override declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスのメソッドをオーバーライドするメソッドは、override宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods, properties, or subscripts that you add to a class in an extension can also be marked as final within the extension’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある拡張においてクラスに加えるメソッド、プロパティ、または添え字は、また、拡張の定義内で最終版として印されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modify the anyCommonElements(_:_:) function to make a function that returns an array of the elements that any two sequences have in common.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>共通したなんらかの２つの連続物である要素たちをもつある配列を返す関数になるように、anyCommonElements(_:_:)関数を修正してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifying Value Types from Within Instance Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型をインスタンスメソッド内から修正する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modules and Source Files</seg>
      </tuv>
      <tuv lang="JA">
        <seg>モジュールとソースファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More generally, any unqualified method and property names that you use within the body of a type method will refer to other type-level methods and properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より一般的に言えば、あなたがある型メソッドの本文内で使うどんな非修飾のメソッドやプロパティ名でも、他の型レベルのメソッドやプロパティに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, IntStack specifies that for this implementation of Container, the appropriate ItemType to use is a type of Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに、IntStackは、Containerのこの実施のために、適切なItemTypeとして使用するのはInt型であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the time, a type identifier directly refers to a named type with the same name as the identifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの場合、型識別子は、名前付きの型に、その識別子と同じ名前で直接に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiline comments begin with /* and end with */.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行コメントは/*で始まり*/で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiline comments start with a forward-slash followed by an asterisk (/*) and end with an asterisk followed by a forward-slash (*/):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行コメントは、スラッシュに続く星印（/*）で始まり、星印に続くスラッシュ（*/）で終わります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple cases can appear on a single line, separated by commas:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のケース節は、コンマで区切られて、ただ一つの行に現れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple optional bindings can now appear in a single if statement as a comma-separated list of assignment expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のオプショナル束縛は、今では単一のif文においてコンマ区切りの代入式のリストとして現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple protocols can be listed, and are separated by commas:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のプロトコルが、コンマで区切られて、リストされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数の問い合わせが一緒に鎖で繋げられることができます、そして連鎖の中のどれかの輪がnilならば、その連鎖全体がいさぎよく失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple switch cases that share the same body can be combined by writing several patterns after case, with a comma between each of the patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じ本文を共有する複数のケース節は、caseの後にそれぞれのパターンを、それぞれのパターンの間のコンマとともに書くことによって結合されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiplication (*)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>乗算（*）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mutability of Collections</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コレクションの可変性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mutating Instance Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変インスタンスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mutating Method Requirements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変メソッド要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mutating methods can assign an entirely new instance to the implicit self property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変メソッドは、まったく新しいインスタンスを暗黙のselfプロパティに代入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mutating methods for enumerations can set the implicit self parameter to be a different case from the same enumeration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙のための可変メソッドは、暗黙のselfパラメータを同じ列挙からの異なるケース節に設定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named types include classes, structures, enumerations, and protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前付きの型は、クラス、構造体、列挙、そしてプロトコルを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naming Constants and Variables</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数に名をつける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naming Type Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型パラメータに名をつける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Negative floating-point literals are expressed by prepending a minus sign (-) to a floating-point literal, as in -42.5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>負の浮動小数点数は、浮動小数点リテラルに単項マイナス演算子（-）を前につけることによって表わされます、-42.5のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Negative integers literals are expressed by prepending a minus sign (-) to an integer literal, as in -42.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>負整数リテラルは、負符号（-）をリテラル整数の前に付けることによって表されます、-42のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Negative numbers, however, are stored differently.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>負の数は、しかし異なって保存されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Neither type of formatting affects the underlying value of the literal:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>書式整形のどちらの種類も、もととなるリテラルの値に影響を及ぼしません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested Functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested Types in Action</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた型の動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested functions are closures that have a name and can capture values from their enclosing function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた関数は、名前を持ち、それを囲んでいる関数から値を捕獲することができるクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested functions are hidden from the outside world by default, but can still be called and used by their enclosing function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた関数は、初期状態では外界から隠されます、しかしそれにもかかわらず、それらを囲む関数によって呼び出されて使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested functions have access to variables that were declared in the outer function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた関数は、外側の関数において宣言された変数に、アクセスをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested functions, as introduced in Nested Functions, are a convenient means of naming and defining self-contained blocks of code as part of a larger function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた関数は、入れ子にされた関数の中で紹介されるように、より大きい関数の一部として、いろいろな完全独立のコードの塊を名前をつけて定義する便利な手段です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested multiline comments enable you to comment out large blocks of code quickly and easily, even if the code already contains multiline comments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた複数行コメントによって、たとえコードがすでに複数行コメントを含むとしても、あなたは速く簡単にコードの大きなブロックをコメントアウトすることが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested types defined within a file-private type have an automatic access level of file private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ファイル外非公開型の内側で定義される入れ子にされた型は、自動的なアクセス水準としてファイル外非公開を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested types defined within a private type have an automatic access level of private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非公開型の内側で定義される入れ子にされた型は、自動的なアクセス水準として非公開を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested types defined within a public type or an internal type have an automatic access level of internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開型または内部型の内側で定義される入れ子にされた型は、自動的なアクセス水準として内部を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nesting multiline comments is allowed, but the comment markers must be balanced.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行コメントが入れ子にされることは許されます、しかしコメント目印が釣り合っている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New barcodes can then be created using either type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいバーコードは、それからどちらの型を使ってでも作成されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New document that describes Swift 1.0, Apple’s new programming language for building iOS and OS X apps.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>iOSおよびOS Xアプリ構築のためのAppleの新しいプログラミング言語、スウィフト 1.0を解説する新しい文書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New operators are declared at a global level using the operator keyword, and are marked with the prefix, infix or postfix modifiers:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい演算子はoperatorキーワードを使ってグローバル水準で宣言されます、そしてprefix、infixまたはpostfix修飾子で印されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, tenEighty is assigned to a new constant, called alsoTenEighty, and the frame rate of alsoTenEighty is modified:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次に、tenEightyは、新しい定数、alsoTenEightyと呼ばれるものに代入されます、そしてalsoTenEightyのフレームレートが修正されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, the width property of cinema is amended to be the width of the slightly-wider 2K standard used for digital cinema projection (2048 pixels wide and 1080 pixels high):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次に、cinemaのwidthプロパティは、デジタル映画館投影のために使われるわずかにより広い2Kの標準の幅（2048ピクセル幅の広さで1080ピクセルの高さがある）になるように改められます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nil-Coalescing Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>nil合体演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No Implicit Fallthrough</seg>
      </tuv>
      <tuv lang="JA">
        <seg>知らずに突き抜けない（フォールスルーしない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No further code from the current iteration of the loop is executed, and no further iterations of the loop are started.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループの現在の繰り返しからそれ以上のコードは実行されません、そしてループのそれ以上の繰り返しは始まりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No ladder on the board takes the player straight to square 25, and so it isn’t possible to win the game by moving up a ladder.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>盤上のはしごは、プレーヤーをまっすぐ正方形25に連れて行きません、なので、はしごを上がることでゲームに勝つことは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No other properties or variables are still referring to the Player instance, and so it is deallocated in order to free up its memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のいかなるプロパティまたは変数も、もはやPlayerインスタンスに言及していません、なのでそれは、それのもつメモリを開放するために順次割り当て解除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonassociative operators of the same precedence level can’t appear adjacent to each to other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じ優先順位レベルを持つ非結合演算子は、互いに隣同士に現れることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, any protocol you create will become a fully-fledged type for use in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでもなお、あなたがつくるどんなプロトコルでも、あなたのコードに用いられるひとつの完全に自立した型になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, because it is of type TextRepresentable, and anything that is TextRepresentable is known to have a textualDescription property, it is safe to access thing.textualDescription each time through the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでもなお、それがTextRepresentable型であり、そして、TextRepresentableであるもの全てがtextualDescriptionプロパティを持つと知られているので、それがループの各回でthing.textualDescriptionにアクセスするのは安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, class B provides an override of someMethod() with an access level of “internal”, which is higher than the original implementation of someMethod():</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それにもかかわらず、クラスBは、「内部」のアクセス水準を持つsomeMethod()のオーバーライドを提供します、それは元々のsomeMethod()の実装よりもより高いです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, in situations where invalid conditions are possible, an assertion is an effective way to ensure that such conditions are highlighted and noticed during development, before your app is published.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでもなお、無効な状態が起こりうる状況には、表明は、あなたのアプリが発表される前、開発の間にそのような状況が目立たされ気づかれることを確実にする効果的な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, it is useful for a Cuboid to provide a read-only computed property to enable external users to discover its current calculated volume.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでもなお、Cuboidが外部のユーザーにその現在の計算された体積を見つけられるように読み出し専用の計算プロパティを提供することは、役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>にもかかわらず、スウィフトの多くの部分は、あなたのCとObjective-Cでの開発経験からきっとお馴染みのものでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, the ItemType alias provides a way to refer to the type of the items in a Container, and to define a type for use with the append(_:) method and subscript, to ensure that the expected behavior of any Container is enforced.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでもなお、ItemTypeエイリアスは、Containerの中の項目の型に言及するための、そしてappend(_:)メソッドと添え字で使うための型を定義するための、ひとつの方法を提供します、それによってあらゆるContainerが期待される挙動を強制されることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, they are all classes, and so instances of all three types can be used to initialize an array that stores values of type AnyObject:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでもなお、それらは全てクラスです、なので、３つの型全てのインスタンスは、型AnyObjectの値を格納するある配列を初期化するために使用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, you can still make the types explicit if you wish, and doing so is encouraged if it avoids ambiguity for readers of your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでもなお、あなたが望むならば、依然としてあなたは型を明確にすることができます、そして、それがあなたのコードの読者のために曖昧さを避けるならば、そうすることは推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonreturning functions and methods either cause an irrecoverable error or begin a sequence of work that continues indefinitely.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非復帰関数およびメソッドは、回復不能のエラーを起こすかまたは無期限に続く一連の作業を始めるかのどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nor can they begin with a number, although numbers may be included elsewhere within the name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そしてそれらは数字から始まることもできません、けれども数字が名前内のどこか他で含まれることはできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nor can you change a constant into a variable or a variable into a constant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして、あなたはある定数を変数に、またはある変数を定数に変更することもできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all possible Int values will find a matching planet, however.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、全ての可能なInt値が、適合する惑星を見つけるというわけでありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not equal to (a != b)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同等でない（a != b）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not every type in Swift can be compared with the equal to operator (==).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの中のすべての型が、同等演算子（==）で比較されることができるというわけでありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not identical to (!==)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同一でない（!==）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not only are optionals safer and more expressive than nil pointers in Objective-C, they are at the heart of many of Swift’s most powerful features.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルはObjective-Cでのnilポインターより安全でさらに表現豊かであるだけでなく、それはスウィフトのたくさんある非常に強力な特徴のうち核心的なものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that you cannot provide both an overriding setter and an overriding property observer for the same property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが同じプロパティに対してオーバーライドしたセッターとオーバーライドしたプロパティオブザーバーの両方を提供することができない点にまた、注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note how the generic version of Stack is essentially the same as the non-generic version, but with a type parameter called Element instead of an actual type of Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Stackの総称体版が、本質的にどれほど非総称体版と同じものであるかに注意してください、しかしElementと呼ばれる型パラメータを実際の型Intの代わりに持つことは除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that tenEighty and alsoTenEighty are declared as constants, rather than variables.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>tenEightyとalsoTenEightyが、変数ではなく、定数として宣言される点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that @objc protocols can be adopted only by classes that inherit from Objective-C classes or other @objc classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@objcプロトコルがObjective-Cクラスや他の@objcクラスから継承するクラスによってのみ採用される点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that x and y are an optional of whatever type someThrowingFunction() returns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>xとyは、たとえどんなものでもsomeThrowingFunction()が返す型のオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that two levels of optional chaining are at play here.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここで２つの階層のオプショナル連鎖が働いていることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Swift infers a type of String for the someString constant, because it is initialized with a string literal value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトがString型をsomeString定数に対して推論する点に注意してください、それが文字列リテラル値で初期化されるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Swift’s use of extended grapheme clusters for Character values means that string concatenation and modification may not always affect a string’s character count.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのCharacter値に対する拡張書記素クラスタの使用は、文字列の連結と修正が常に文字列の文字数に影響を与えないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that an exclamation mark (!) is used to unwrap and access the instances stored inside the john and unit4A optional variables, so that the properties of those instances can be set:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>感嘆符（!）が使われることに注意してください、そうすることでオプショナル変数のjohnとunit4Aに保存されるインスタンスがアンラップされてアクセスされるようになります、それでそれらのインスタンスのプロパティが設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if you define a custom initializer for a value type, you will no longer have access to the default initializer (or the memberwise initializer, if it is a structure) for that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある値型のためにあつらえのイニシャライザを定義するならば、あなたがもはやその型の省略時のイニシャライザに（および、それが構造体の場合には、メンバー関連イニシャライザにも）アクセスをしない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if you override a failable superclass initializer with a nonfailable subclass initializer, the only way to delegate up to the superclass initializer is to force-unwrap the result of the failable superclass initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注意することは、あなたが失敗できるスーパークラス・イニシャライザを、失敗できないサブクラス・イニシャライザでオーバーライドする場合、唯一の方法としてスーパークラスのイニシャライザにまで委任するには、失敗できるスーパークラスイニシャライザの結果を強制アンラップすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in the example above, you are trying to retrieve the value of the street property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、あなたがstreetプロパティの値を取り出そうとしている点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that it is not possible to call these initializers without using argument labels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルを使用することなくこれらのイニシャライザを呼び出すことは可能でない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that neither deinitializer was called when you set these two variables to nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこれらの２つの変数をnilに設定したとき、どちらのデイニシャライザも呼ばれなかった点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that no whitespace may appear between the type and the !.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空白が型と!の間に現れないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that no whitespace may appear between the type and the ?.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空白が型と?の間に現れないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that not all 21-bit Unicode scalars are assigned to a character—some scalars are reserved for future assignment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての21ビットのユニコード・スカラーがひとつの文字に割り当てられる訳ではないことに注意してください ― いくつかのスカラーは将来の割り当てのために取っておかれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the delegate property is defined as an optional DiceGameDelegate, because a delegate isn’t required in order to play the game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>delegateプロパティが、オプショナルのDiceGameDelegateとして定義される点に注意してください、delegateがゲームをプレイするために必須でないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the thing constant is of type TextRepresentable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>thing定数が型TextRepresentableであることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the array contains four items, but 0..&lt;count only counts as far as 3 (the index of the last item in the array), because it is a half-open range.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この配列が４つの項目を含む点に注意してください、しかし0..&lt;countは3（この配列の最後の項目のインデックス）まで数えるだけです、なぜならそれが半開範囲であるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the closure’s end curly brace is followed by an empty pair of parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャの閉じ波括弧に、一対の空の丸括弧が続くことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the declaration of parameters and return type for this inline closure is identical to the declaration from the backward(_:_:) function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行内クロージャのためのパラメータと戻り型の宣言が、backward(_:_:)関数の宣言と同一であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the entire function type is wrapped in the optional, not the method’s return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドの戻り値ではなく、その関数型の全体がオプショナルの中のラップされることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the message "John Appleseed is being initialized" is printed at the point that you call the Person class’s initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがPersonクラスのイニシャライザを呼んだ時点で、メッセージ"John Appleseed is being initialized"が出力されるという点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the message in the HTMLElement deinitializer is not printed, which shows that the HTMLElement instance is not deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>HTMLElementデイニシャライザにおけるメッセージが出力されないことに注意してください、それは、HTMLElementインスタンスが割り当て解除されないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the names of someInt and anotherInt are prefixed with an ampersand when they are passed to the swapTwoInts(_:_:) function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>someIntとanotherIntの名前が、それらがswapTwoInts(_:_:)関数に渡される時に、アンパサンドで接頭辞を付けられるという点に注意してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the return type of this function is still Int?, because the function returns an optional index number, not an optional value from the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数の戻り型が以前としてInt?であるという点に注意してください、なぜなら、この関数がオプショナルのインデックス番号（配列からのオプショナルの値でない）を返すからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the tuple’s members do not need to be named at the point that the tuple is returned from the function, because their names are already specified as part of the function’s return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルの構成要素が、タプルがその関数から返される時点で名前をつけられる必要がない点に注意してください、なぜなら、それらの名前が関数の戻り型の一部としてすでに指定されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the type of customerProvider is not String but () -&gt; String—a function with no parameters that returns a string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注意すべきは、customerProviderの型はStringではなく() -&gt; String—ある文字列を返すパラメータのない関数—であることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the type of the someInts variable is inferred to be [Int] from the type of the initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>someInts変数の型が、そのイニシャライザの型から[Int]であると推測される点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the underlying objects are not changed by the casting process.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>根底にあるオブジェクトがキャスト処理によって変更されない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this extension does not define a type parameter list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この拡張は型パラメーターリストを定義しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this function is distinct from the greet(person:) function shown in an earlier section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数が前の節で見せたgreet(person:)関数と別個のものであることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is true even though numberOfRooms is a nonoptional Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえnumberOfRoomsが非オプショナルのIntであるとしても、これが当てはまることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you can assign an explicit access level for both a getter and a setter if required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは明示的なアクセス水準をゲッターとセッターの両方に割り当てることが、必要ならば可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you cannot call a mutating method on a constant of structure type, because its properties cannot be changed, even if they are variable properties, as described in Stored Properties of Constant Structure Instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが定数の構造体型で可変メソッドを呼ぶことができないということに注意してください、なぜなら、定数構造体インスタンスの保存プロパティで記述されるように、そのプロパティは、たとえそれらが変数プロパティであるとしても変わることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that “identical to” (represented by three equals signs, or ===) does not mean the same thing as “equal to” (represented by two equals signs, or ==):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「同一である」（３つの等号、つまり===によって表されるもの）は「同等である」（２つの等号、つまり==によって表されるもの）と同じことを意味しないことに注意してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>覚え書き</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nothing else is required of the instance you assign to this property, except that the instance must adopt the RandomNumberGenerator protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのインスタンスがRandomNumberGeneratorプロトコルを採用しなければならないことをのぞいては、あなたがこのプロパティに代入するインスタンスに必要とされるものは他に何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice how let can be used in a pattern to assign the value that matched the pattern to a constant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのようにletがパターン内で使われて、パターンに合致した値を定数に割り当てることができるかに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice how self is used to distinguish the name property from the name argument to the initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのようにselfがnameプロパティをイニシャライザのためのname引数と区別するために使われるかに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice how the sunrise and sunset times are extracted from the ServerResponse value as part of matching the value against the switch cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのように日の出と日没の時間がServerResponseの値から、その値をスイッチの各条件と比較することの一環として抽出されるかに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that the initializer for the EquilateralTriangle class has three different steps:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>EquilateralTriangleクラスのためのイニシャライザが３つの異なる段階を持つことに注意してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice the two ways that the hearts case of the enumeration is referred to above: When assigning a value to the hearts constant, the enumeration case Suit.hearts is referred to by its full name because the constant doesn’t have an explicit type specified.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記で列挙のheartsケース節が参照される２つの方法に注意してください：定数のheartsに値を代入するとき、列挙のケース節Suit.heartsはそのフルネームによって参照されます、なぜならこの定数には明確に指定される型がないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice the use of the mutating keyword in the declaration of SimpleStructure to mark a method that modifies the structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SimpleStructureの宣言におけるmutatingキーワードに注意してください、それはその構造体を修正するメソッドに印を付けるためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that moveNearerToZero refers to the correct function, it can be used to count to zero:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>moveNearerToZeroが正しい関数に言及する今、それはゼロまで数えるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now you can call the function as if it took a String argument instead of a closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今やあなたはこの関数を、まるでそれがクロージャではなくString引数を取るかのように呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Null Character (\0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>null文字（\0）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numbers can overflow in both the positive and negative direction.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数は正と負の向きの両方においてオーバフローすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric Literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数のリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric Type Conversion</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数の型変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric literals can contain extra formatting to make them easier to read.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数のリテラルは、それらをより簡単に読めるように書式を整える追加のものを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C itself has evolved to support blocks, collection literals, and modules, enabling framework adoption of modern language technologies without disruption.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cそれ自体は、分裂なしで現代的な言語技術のフレームワーク採用を出来るようにして、ブロック、コレクション・リテラル、そしてモジュールをサポートするように発展しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objects and Classes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトとクラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Omitting Argument Labels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルの省略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Omitting the version number indicates that the declaration is currently deprecated, without giving any information about when the deprecation occurred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バージョン番号の省略は、宣言が現れた時についてのどんな情報も与えることなく、その宣言が現在は非推奨であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a 32-bit platform, Int is the same size as Int32.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>32ビットのプラットホーム上で、IntはInt32と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a 32-bit platform, UInt is the same size as UInt32.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>32ビットのプラットホーム上で、UIntはUInt32と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a 64-bit platform, Int is the same size as Int64.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>64ビットのプラットホーム上で、IntはInt64と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a 64-bit platform, UInt is the same size as UInt64.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>64ビットのプラットホーム上で、UIntはUInt64と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On each pass, the for-in loop sets the item constant to the next MediaItem in the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各段階で、このfor-inループはitem定数を次のMediaItemに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On those occasions, you can write try! before the expression to disable error propagation and wrap the call in a runtime assertion that no error will be thrown.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの場合には、あなたはtry!をその式の前に書くことによって、エラー伝達を抑制して、エラーはスローされないという実行時表明の中にその呼び出しを包み込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once directionToHead is declared as a CompassPoint, you can set it to a different CompassPoint value using a shorter dot syntax:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦directionToHeadが、あるCompassPointとして宣言されるならば、あなたはそれをより短いドット構文を使って、異なるCompassPoint値に設定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a constant property is assigned a value, it can’t be further modified.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いったん定数プロパティが値を割り当てられるならば、それはそれ以上変更されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once it completes the sorting process, the sorted(by:) method returns a new array of the same type and size as the old one, with its elements in the correct sorted order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦それがソート処理を完了するならば、sorted(by:)メソッドは、古いものと同じ型と大きさの新しい配列を返します、そしてその要素は正しく分類された順序を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the counter reaches zero, no more counting takes place:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとたびcounterがゼロに達するならば、それ以上数えることは起こりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦あらゆる保存プロパティのための最初の状態が決定されるならば、第２の段階が始まります、そして各クラスは、新しいインスタンスが使用する準備ができているとみなされる前に、さらにその保存プロパティを好みに合わせて作り変える機会を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the superclass’s designated initializer is finished, the subclass’s designated initializer can perform additional customization (although again, it does not have to).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦スーパークラスの指定イニシャライザが作業をし終えるならば、サブクラスの指定イニシャライザは追加の改良を実行することができます（しかし再び、そうしなければならない訳ではない）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the top of the chain is reached, and the final class in the chain has ensured that all of its stored properties have a value, the instance’s memory is considered to be fully initialized, and phase 1 is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いったん連鎖の最上部に届き、そして連鎖の中の最終的なクラスがその保存プロパティの全てが値を持つことを確実にしたならば、インスタンスのメモリは充分に初期化されるとみなされます、そして、第１段階は完了です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you define a type alias, you can use the alias anywhere you might use the original name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦あなたがある型エイリアスを定義するならば、あなたが本来の名前を使うであろうどこにでも、あなたはそのエイリアスを使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you specify a type parameter, you can use it to define the type of a function’s parameters (such as the a and b parameters of the swapTwoValues(_:_:) function), or as the function’s return type, or as a type annotation within the body of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦あなたが型パラメータを指定するならば、あなたはそれを、関数のパラメータの型を定義するために（例えば、 swapTwoValues(_:_:)関数のaとbパラメータのように）、または関数の戻り型として、あるいは関数の本文内の型注釈として使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you’re sure that the optional does contain a value, you can access its underlying value by adding an exclamation mark (!) to the end of the optional’s name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦あなたがそのオプショナルが値を含んでいることを確かめたなら、あなたは感嘆符（!）をオプショナルの名前の終わりに加えることによって、それに内在する値にアクセスすることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you’ve declared a constant or variable of a certain type, you can’t redeclare it again with the same name, or change it to store values of a different type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦あなたが特定の型のある定数または変数を宣言してしまったならば、あなたは同じ名前でもう一度それを宣言し直すこと、またはそれを異なる型の値を保存するように変更することは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One convenience initializer calls another convenience initializer, which in turn calls the single designated initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つの便宜イニシャライザは、別の便宜イニシャライザを呼びます、それは、今度は一つだけある指定イニシャライザを呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One example is the addition assignment operator (+=):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つの例は、加算代入演算子（+=）です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One kilometer is the same as 1,000 meters, so the km computed property multiplies the value by 1_000.00 to convert into a number expressed in meters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１キロメートルは1,000メートルと同じものですので、km計算プロパティは1_000.00を掛けられて、メートルで表される数に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the most important differences between structures and classes is that structures are always copied when they are passed around in your code, but classes are passed by reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体とクラスの間の１つの最も重要な違いは、それらがあなたのコードにおいてあちこち渡されるとき、構造体は常にコピーされるということです、それに対してクラスは参照によって渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of these classes was defined as “internal”, and the other was defined as “private”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらのクラスのうちの１つは「内部」として定義されました、そして別のものは「非公開」として定義されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of these two branches is always executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの２つの分岐のうちの１つは、常に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way is to use do-catch.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つの方法は、do-catchを使うことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way that a closure can escape is by being stored in a variable that is defined outside the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャが脱出出来る１つの方法は、関数の外側で定義される変数に格納されることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way to provide the sorting closure is to write a normal function of the correct type, and to pass it in as an argument to the sorted(by:) method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ソート・クロージャを提供する１つの方法は、通常の関数を正しい型で記述することです、そしてそれを１つの引数としてsorted(by:)メソッドに渡すことになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the compound assignment operators can be overloaded.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合代入演算子だけが、オーバーロードされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only throwing functions can propagate errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スロー関数だけがエラーを伝えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open access applies only to classes and class members, and it differs from public access as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>開放アクセスはクラスとクラスメソッドのみに適用されます、そしてそれは次のように公開アクセスと異なります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open access is the highest (least restrictive) access level and private access is the lowest (most restrictive) access level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>開放アクセスは最も高い（制限の最も少ない）アクセス水準であり、非公開アクセスは最も低い（制限の最も多い）アクセス水準です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open class members can be overridden by subclasses within the module where they’re defined, and within any module that imports the module where they’re defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>開放クラスメンバーは、それらが定義されたところのモジュール内部で、そしてそれらが定義されたところのモジュールをインポートする何らかのモジュール内部で、サブクラスによってオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open classes can be subclassed within the module where they’re defined, and within any module that imports the module where they’re defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>開放クラスは、それらが定義されたところのモジュール内部で、そしてそれらが定義されたところのモジュールをインポートする何らかのモジュール内部で、サブクラスを作成されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator associativity defines how operators of the same precedence are grouped together—either grouped from the left, or grouped from the right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子結合性は、同じ優先順位の演算子がまとめられる方法を定義します ― 左からまとめられるか右からまとめられるかのどちらか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator precedence gives some operators higher priority than others; these operators are applied first.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子優先順位は、ある演算子に他のものよりも高い優先権を与えます；これらの演算子は最初に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator functions for Compound Assignment Operators no longer use the @assignment attribute when defining the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合代入演算子のための演算子関数は、もはや関数を定義する時に@assignment属性を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators are unary, binary, or ternary:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子には、単項、二項、または三項があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators from those precedence groups can’t be used next to each other without grouping parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの優先順位グループ由来の演算子は、グループ化括弧なしで互いにすぐ隣に使われることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that are left-associative group left-to-right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>左結合である演算子は、左から右へとグループにまとめられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that are right-associative group right-to-left, and operators that are specified with an associativity of none don’t associate at all.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>右結合の演算子は右から左にグループにされます、そしてnoneの関係性を指定される演算子は全く結合しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Binding</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルを束縛する（定数・変数と結び付ける）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Chaining</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Chaining as an Alternative to Forced Unwrapping</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強制アンラップに代わるものとしてのオプショナル連鎖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルパターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Property Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルプロパティ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Protocol Requirements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルのプロトコル要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Tuple Return Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルタプルの戻り型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional binding can be used with if and while statements to check for a value inside an optional, and to extract that value into a constant or variable, as part of a single action.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル束縛は、ifやwhile文と一緒に使用して、オプショナルの内部の値を確認すること、そしてその値を定数または変数に抽出することを、一回の動作で可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional chaining in Swift is similar to messaging nil in Objective-C, but in a way that works for any type, and that can be checked for success or failure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおけるオプショナル連鎖は、どんな型のためにでも働きそして成功か失敗を確認されることができるというようなことを除いて、Objective-Cにおけるnilにメッセージを送ることに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional chaining provides an alternative way to access the value of numberOfRooms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖は、numberOfRoomsの値にアクセスする代わりの方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional patterns consist of an identifier pattern followed immediately by a question mark and appear in the same places as enumeration case patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルパターンは、１つの識別子パターンに直接に１つの疑問符が続くものから成ります、そして列挙ケース節パターンと同じ場所に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional requirements are available so that you can write code that interoperates with Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル要件が利用可能なことから、あなたはObjective-Cと相互運用するコードを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional requirements are prefixed by the optional modifier as part of the protocol’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの要件は、そのプロトコル定義においてoptional修飾子を前に置かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional syntactic categories and literals are marked by a trailing subscript, opt.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>任意である統語論のカテゴリーとリテラルは後に続く下つき文字、optによって印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional-Chaining Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional-chaining expressions must appear within a postfix expression, and they cause the postfix expression to be evaluated in a special way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式は、接尾辞式の中に現れなければなりません、そしてそれはその接尾辞式を特別なやり方で評価されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionals are used to represent the absence of a value, but when an operation fails, it’s often useful to understand what caused the failure, so that your code can respond accordingly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルは、ある値の欠如を表すために使われます、しかしある操作が失敗する時、何がその失敗をもたらしたのか理解するのはしばしば役に立ちます、それであなたのコードはそれに適切に応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionals can be checked with an if statement to see if a value exists, and can be conditionally unwrapped with optional binding to access the optional’s value if it does exist.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルは、値が存在しているかどうか見るために、if文を使って調べられることが出来ます、そしてオプショナルの持つ値にそれが存在するならばアクセスするために、オプショナル束縛を使って条件に応じてアンラップされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionals of any type can be set to nil, not just object types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての型のオプショナルが、nilに設定されることができます、単にオブジェクト型だけでなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionals say either “there is a value, and it equals x” or “there isn’t a value at all”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルであるものは、「ひとつの値がある、そしてそれはxに等しい」または「まったく値がない」のどちらかを伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other named types can only inherit from or conform to a list of protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の名前付きの型は、プロトコルのリストから継承し準拠することだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other products are labeled with 2D barcodes in QR code format, which can use any ISO 8859-1 character and can encode a string up to 2,953 characters long:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>別の製品はQRコード形式の二次元バーコードでラベルをつけられます、それはどんなISO 8859-1の文字でも使うことができて、2,953文字までの長さの文字列をコード化することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other units require some conversion to be expressed as a value measured in meters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の単位は、メートルで計られる値として表されるためにいくらかの変換を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, a runtime error is raised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、実行時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, it evaluates the second expression and returns its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、それは第二の式を評価して、その値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, no message is printed, and code execution continues after the if statement’s closing brace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、メッセージは出力されません、そしてコードの実行はif文の閉じ波括弧の後に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the species property’s value is set, and initialization succeeds:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、speciesプロパティの値は設定されて、初期化は成功します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the error can propagate out of the containing scope, which means the error must be handled by an enclosing catch clause or the containing function must be declared with throws.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、エラーはそれを収容しているスコープの外に伝えられることができます、それが意味するのは、エラーは囲んでいるcatch節によって取り扱われなければならない、または収容している関数がthrowsで宣言されなければならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the initializer has an access level of internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、イニシャライザは内部のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the optional value is unwrapped and assigned to the constant after let, which makes the unwrapped value available inside the block of code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、そのオプショナルの値は包装を取られて、letの後の定数に代入されます、そしてそれはコードのブロックの内側で利用できる包装を取られた値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the optional value is unwrapped, and everything after the ? acts on the unwrapped value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、オプショナルの値は包装を取られます、そして?の後のすべてのものは包装を取られた値に作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the program does not perform assignment or execute the statements, and it is finished executing the for-in statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、プログラムは代入を実行しませんし、文を実行しません、そしてそれはfor-in文の実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the result is an optional containing the value that the function returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、結果は関数が返した値を含んでいるオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the square’s value is 0, and it is a “free” square, represented by ○.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一方、正方形の値は0ならば、それは「自由」な正方形であって、○によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the subscript returns nil:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、添え字はnilを返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the value of x and y is the value that the function returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、xとyの値はこの関数が返す値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the value of the optional-try expression is nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、オプショナルtry式の値はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, when set to false or omitted, operators in the precedence group follows the same optional chaining rules as operators that don’t perform assignment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうせずに、falseに設定するか省略する場合は、その優先順位グループの演算子は代入を実行しない演算子と同じオプショナル連鎖規則に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our framework stack, built on the solid base of Foundation and Cocoa, has been modernized and standardized throughout.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ファウンデーションとココアのしっかりした基礎の上に建てられる、私達のフレームワーク・スタックは、隅から隅まで現代化されて、標準化されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our goals for Swift are ambitious.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのための私達のゴールは、野心的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Outside the context in which they appear in the grammar, they can be used as identifiers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そこにおいてそれらが文法の中に現れる文脈外では、それらは識別子として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overflow Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overflow addition (&amp;+)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー加算（&amp;+）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overflow also occurs for signed integers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフローはまた、符号つき整数に対しても起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overflow behavior is trapped and reported as an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー挙動は、エラーとして捕まえられて報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overflow multiplication (&amp;*)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー乗算（&amp;*）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overflow subtraction (&amp;-)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー減算（&amp;-）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overridden properties, methods, subscripts, and designated initializers must be marked with the override declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティ、メソッド、添え字、そして指定イニシャライザのオーバーライドは、override宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding Property Getters and Setters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティゲッターとセッターのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding Property Observers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバーのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding a Failable Initializer</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding by accident can cause unexpected behavior, and any overrides without the override keyword are diagnosed as an error when your code is compiled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>誤って偶然にオーバーライドすることは予想外の挙動を引き起こすことがありえます、なので、あなたのコードがコンパイルされるとき、overrideキーワードのないどんなオーバーライドもエラーとして診断されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overusing autoclosures can make your code hard to understand.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動クロージャの使いすぎは、あなたのコードを理解しにくくする可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameter Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameter Names and Argument Labels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ名と引数ラベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters can be ignored, take a variable number of values, and provide default values using the following forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータは、無視されること、可変の数の値をとること、そして以下の形式を使って省略時の値を提供することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters can provide default values to simplify function calls and can be passed as in-out parameters, which modify a passed variable once the function has completed its execution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータは、関数呼び出しを単純化するために初期値を提供することができます、そしてひとたび関数がその実行を完了し終えれば渡された変数を修正するin-outパラメータとして渡されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters that don’t have default values are usually more important to the function’s meaning—writing them first makes it easier to recognize that the same function is being called, regardless of whether any default parameters are omitted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の値を持たないパラメータは、関数の意味するところにとって通常より重要です—それらを最初に書くことは、何らかの省略時のパラメータが省かれているかどうかに関係なく、同じ関数が呼び出されているのをよりわかり易くします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parentheses around the condition or loop variable are optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件またはループ変数のまわりの丸括弧は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parenthesized Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧に入れられた式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Part of the functionality of the DataManager class is the ability to import data from a file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>DataManagerクラスの機能性の一部は、データをファイルからインポートする能力です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Patterns</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performing Set Operations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合演算の実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Phase 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第１段階</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Phase 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第２段階</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Place parameters that don’t have default values at the beginning of a function’s parameter list, before the parameters that have default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の値を持たないパラメータを関数のもつパラメータリストの始まりに、省略時の値を持つパラメータの前に、置いてください、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Place the capture list before a closure’s parameter list and return type if they are provided:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが提供されるならばクロージャのパラメータ・リストと戻り型の前に、捕獲リストを置いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Platform condition</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プラットホーム条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Playground literals in plain text outside of Xcode are represented using a special literal syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Xcodeの外部のプレーンテキストの中のプレイグラウンドリテラルは、特別なリテラル構文を使って表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Playgrounds allow you to edit the code listings and see the result immediately.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレイグラウンドは、あなたがコードリストを編集してすぐにその結果を見られるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pointers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポインター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Popping a value from the stack removes and returns the top value, "cuatro":</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このスタックから値をボップすることは、一番上の値、"cuatro"を削除して、返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Positive numbers are stored in exactly the same way as for unsigned integers, counting upwards from 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正の数は符号なし整数と正確に同じ方法で保存されて、0から上方へ数えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Postfix Expressions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Postfix Self Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞self式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Postfix expressions, like prefix and binary expressions, let you build up more complex expressions using postfixes such as function calls and member access.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞式は、接頭辞や二項の式に似て、関数呼び出しやメンバー・アクセスのような接尾辞を使うことで、あなたにより複雑な式を組み立てさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Postfix operators are nonassociative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞演算子は非結合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Precedence Group Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位グループ定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Precedence and Associativity</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位と結合性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Precedence for Custom Infix Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの接中辞演算子の優先順位</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Precedence groups related to each other using lower group names and higher group names must fit into a single relational hierarchy, but they don’t have to form a linear hierarchy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下方グループ名と上方グループ名を使って互いに関係のある優先順位グループは、単一の関係階層へはめ込まなければなりません、しかしそれらは線形階層を形作る必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix Expressions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix and Postfix Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞と接尾辞演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix and Suffix Equality</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞と接尾辞等式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix and binary expressions let you apply operators to smaller expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞と二項式は、あなたに演算子をより小さい式に適用させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix operators are nonassociative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞演算子は非結合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix operators declarations don’t specify a precedence level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞演算子宣言は、優先順位レベルを指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix operators take one argument, the expression that follows them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞演算子は、１つの引数（それらの後に続く式）をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preventing Overrides</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバーライドを防ぐ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primary Expressions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primary expressions are conceptually the simplest kind of expression, and they provide a way to access values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本式は、概念的に最も単純な種類の式で、それらはアクセス手段をさまざまな値に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Printing Constants and Variables</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数を出力する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Printing the description of each item in the array shows that their default states have been set as expected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の各項目の説明を出力することは、予想されるようにそれらの省略時の状態が設定されたことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Program execution continues at the point immediately following the function or method call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プログラム実行は、関数またはメソッド呼び出しに直ちに続いている地点に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Program execution continues to the next case even if the patterns of the case label do not match the value of the switch statement’s control expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえケース節ラベルのパターンがswitch文のもつ制御式の値にマッチしないとしても、プログラム実行は次のケース節に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Program execution does not continue or “fall through” to the next case or default case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プログラム実行は続きません、あるいは、次のケース節または省略時のケース節に「抜け落ちる」ことはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Propagating Errors Using Throwing Functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スロー関数を使ってエラーを伝える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Propagation of Initialization Failure</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化失敗の伝播</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties can only be accessed, and methods can only be called, once the class instance is known to be valid at the end of the first phase.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦クラスインスタンスが第１段階の終わりに有効であるということを知られる場合にのみ、プロパティはアクセスされることができ、そしてメソッドは呼ばれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties of a structure instance can be accessed using dot (.) syntax, as described in Accessing Properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスインスタンスのプロパティにドット（.）構文でアクセスされることができます、プロパティにアクセスするで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties of optional type are automatically initialized with a value of nil, indicating that the property is deliberately intended to have “no value yet” during initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの型のプロパティは、nilの値で自動的に初期化されて、そのプロパティは初期化の時には「まだ無い値」を故意に持つつもりであることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties, methods, and initializers of an existing type can’t be overridden in an extension of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存の型のプロパティ、メソッド、そしてイニシャライザは、その型の拡張においてオーバーライドされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property Observers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property Requirements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティ要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバーは、あるプロパティの値が設定されるたびに、たとえ新しい値がそのプロパティの現在の値と同じものであるとしても、呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property observers aren’t called when ARC sets a weak reference to nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバーは、ARCが弱い参照をnilに設定するとき呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property observers can be added to any property, regardless of whether it was originally defined as a stored or computed property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバーは、どんなプロパティにでも加えられることができます、それが保存または計算プロパティとして元々定義されたかどうかは関係ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property observers can be added to stored properties you define yourself, and also to properties that a subclass inherits from its superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバーは、あなたがあなた自身で定義する保存プロパティに、そのうえにサブクラスがそのスーパークラスから継承するプロパティにも加えられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property observers observe and respond to changes in a property’s value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバーは、あるプロパティの値の変化を観察して、応答します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property overriding is described in Overriding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティをオーバーライドすることはオーバーライドで記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property requirements are always declared as variable properties, prefixed with the var keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティ要件は常に変数プロパティとして宣言されます、それでvarキーワードを前に置かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Associated Type Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル関連型宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Composition</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Composition Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Conformance</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Extensions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Inheritance</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Initializer Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルイニシャライザ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Method Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルメソッド宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Property Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルプロパティ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Subscript Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル添え字宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol casts are no longer limited to @objc protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルのキャストは、もはや@objcプロトコルに制限されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol composition types have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成型は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol composition types may be used only in type annotations and in generic parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成型は、型注釈においておよび総称体パラメータにおいてのみ使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol compositions do not define a new, permanent protocol type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成は、新しい、永続的なプロトコル型を定義しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol compositions have the form SomeProtocol &amp; AnotherProtocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成は、形式SomeProtocol &amp; AnotherProtocolを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol declarations are declared at global scope using the protocol keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言は、グローバルなスコープでキーワードprotocolを使って宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol declarations can’t contain class, structure, enumeration, or other protocol declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言は、クラス、構造体、列挙、または他のプロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol initializer declarations have the same form as initializer declarations, except they don’t include the initializer’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルイニシャライザ宣言は、それらがイニシャライザ本文を含めないことを除いて、イニシャライザ宣言と同じ形式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol method declarations have the same form as function declarations, with two exceptions: They don’t include a function body, and you can’t provide any default parameter values as part of the function declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルメソッド宣言は、２つの例外を除いて、関数宣言と同じ形式を持ちます：それらは関数本体を含むことができません、そして、あなたは関数宣言の一部として省略時のパラメータ値をまったく提供することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol property declarations have a special form of a variable declaration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルプロパティ宣言は、変数宣言の特別な形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol requirements with default implementations provided by extensions are distinct from optional protocol requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張によって提供される省略時の実装を持つプロトコル要件は、オプショナルプロトコル要件とは異なったものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol subscript declarations have a special form of a subscript declaration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル添え字宣言は、添え字宣言の特別な形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol types can inherit from any number of other protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル型は、いくらかの他のプロトコルから継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols and Extensions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルと拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols are named types, and thus they can appear in all the same places in your code as other named types, as discussed in Protocols as Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは名前をつけられた型です、したがってそれらはあなたのコードにおいて他の名前をつけられた型と同じ場所の全てにおいて現れることができます、型としてのプロトコルで議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols as Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型としてのプロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols can also declare special kinds of type aliases, called associated types, that can specify relationships among the various declarations of the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルはまた、特別な種類の型エイリアス、そのプロトコルのいろいろな宣言の間での関係を指定することができる関連型と呼ばれるものを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols can be extended to provide method and property implementations to conforming types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは拡張されることが可能です、それによって準拠している型にメソッドとプロパティの実装を提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols can be restricted to a certain context, as can global constants, variables, and functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは特定の前後関係に制限されることができます、グローバルな定数、変数、そして関数も同じようにされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols can define failable initializer requirements for conforming types, as defined in Failable Initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、失敗できるイニシャライザで記述されるように、準拠している型に対して失敗できるイニシャライザ要件を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols can require specific initializers to be implemented by conforming types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、準拠型によって特定のイニシャライザが実装されるように要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols can require specific instance methods and type methods to be implemented by conforming types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、準拠型によって特定のインスタンスメソッドと型メソッドが実装されるように要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols declare associated types using the associatedtype keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、関連型をキーワードassociatedtypeを使って宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols declare that conforming types must implement a method by including a protocol method declaration in the body of the protocol declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルが宣言するのは、準拠している型は、プロトコル宣言の本文中のプロトコルメソッド宣言を含めることによって、あるメソッドを実装する必要があるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols declare that conforming types must implement a property by including a protocol property declaration in the body of the protocol declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、準拠している型がそのプロトコル宣言の本文の中のプロトコルプロパティ宣言を含めることによってプロパティを実装しなければならないことを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols declare that conforming types must implement a subscript by including a protocol subscript declaration in the body of the protocol declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、準拠している型がそのプロトコル宣言の本文の中のプロトコル添え字宣言を含めることによって添え字を実装しなければならないと宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols declare that conforming types must implement an initializer by including a protocol initializer declaration in the body of the protocol declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、準拠している型がそのプロトコル宣言の本文の中のプロトコルイニシャライザ宣言を含めることによってイニシャライザを実装しなければならないと宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols do not actually implement any functionality themselves.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、実際に少しの機能性も実装しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols marked with the objc attribute can’t inherit from protocols that aren’t.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>objc属性で印されるプロトコルは、そうしないプロトコルから継承することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provide new initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいイニシャライザを提供する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Providing Default Implementations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の実装を提供する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Providing a value when you create a constant or variable lets the compiler infer its type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが定数または変数をつくる時に値を提供することは、コンパイラにその型を推論させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Providing error handling when values get too large or too small gives you much more flexibility when coding for boundary value conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値があまりに大きいかあまりに小さくなる時にエラー処理を提供することは、境界値条件のためのコードを書くとき、あなたにずっと多くの柔軟性を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Providing more detail limits which symbols are imported—you can specify a specific submodule or a specific declaration within a module or submodule.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より詳細な記述を提供することは、どのシンボルがインポートされるかを制限します ― あなたは、あるモジュールまたはサブモジュール内で、特定のサブモジュールまたは特定の宣言を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Querying and Setting Type Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティを問い合わせて、設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Range Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>範囲演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than a copy, a reference to the same existing instance is used instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コピーではなく、既存の同じインスタンスに対する参照が代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than moving the player immediately, the loop uses a switch statement to consider the result of the move and to determine whether the move is allowed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>直ちにプレーヤーを動かすのではなく、ループはswitch文を使うことで、移動の結果を考慮して、移動が許可されるかどうか判断します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than placing an exclamation mark after the optional’s name each time you use it, you place an exclamation mark after the optional’s type when you declare it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがそれを使うたびにオプショナルの名前の後に感嘆符を置くよりも、あなたがそれを宣言する時にオプショナルの型の後に感嘆符を書きたいとあなたは思うでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than returning an existing value, the getter actually calculates and returns a new Point to represent the center of the square.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存の値を返すのではなく、このゲッターは正方形の中心を表すために実際に計算して新しいPointを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather, it reports a compile-time error that case "a": does not contain any executable statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうではなく、それはcase "a":が実行可能な文を何も含まないという、コンパイル時エラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather, their role is to ensure that self is fully and correctly initialized by the time that initialization ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>というより、それの役割は、初期化が終わるまでにselfが完全にそして正確に初期化されることを確実にすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather, they define a temporary local protocol that has the combined requirements of all protocols in the composition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうではなく、それはその合成物の中の全てのプロトコルの要件を結合したものを持つ、一時的なローカル・プロトコルを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raw Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raw Values and Associated Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値と関連値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raw values are not the same as associated values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値は、関連値と同じものでない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raw values are set to prepopulated values when you first define the enumeration in your code, like the three ASCII codes above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値は、上の３つのASCIIコードの様に、あなたがあなたのコードにおいて最初に列挙を定義するとき、あらかじめ入れられた値に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raw values can be strings, characters, or any of the integer or floating-point number types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値は、文字列、文字、または何らかの整数や浮動小数点数型であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read-Only Computed Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>読み出し専用の計算プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Readability is always preferred over brevity; use parentheses where they help to make your intentions clear.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>読みやすさは、常に簡潔さよりも好まれます；それらがあなたの意図を明確にする助けとなるところに丸括弧を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recursive Enumerations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再帰列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reference counting allows more than one reference to a class instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>参照カウントは、あるクラスインスタンスに対する１つ以上の参照を許します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reference counting only applies to instances of classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>参照カウントは、クラスのインスタンスに適用されるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Referring to Nested Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた型を参照する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remainder Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>剰余演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remainder and multiplication both associate with the expression to their left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>剰余と乗算は、両方とも式をそれらの左と結びつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remove the day parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>dayパラメータを取り除いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed a duplicate description of the valid set of operator characters from Custom Operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効な演算子の一式の重複する説明をあつらえの演算子から取り除きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed a note to the contrary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これに反する注意書きを取り除きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed discussion of C-style for loops, the ++ prefix and postfix operators, and the -- prefix and postfix operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C形式forループ、++接頭辞および接尾辞演算子、そして--接頭辞および接尾辞演算子の議論を削除した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed discussion of variable function arguments and the special syntax for curried functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数関数引数とカリー化関数のための特別な構文の議論を削除した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed the discussion of explicitly using let in function parameters from the Function Declaration section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的にletを関数パラメータにおいて使用することの解説を節関数宣言から削除した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed the discussion of the Boolean protocol from the Statements chapter, now that the protocol has been removed from the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Booleanプロトコルの解説を文の章から削除した、今ではこのプロトコルはスウィフト標準ライブラリから削除されてしまったので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed the overflow division (&amp;/) and overflow remainder (&amp;%) operators from Overflow Operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー除算（&amp;/）とオーバフロー剰余（&amp;%）演算子をオーバフロー演算子から削除しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Repeat-While</seg>
      </tuv>
      <tuv lang="JA">
        <seg>終わりに評価</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Repeat-While Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>repeat-while文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Representing and Throwing Errors</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーの表現とスロー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Required Initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>必須イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requiring exhaustiveness ensures that enumeration cases are not accidentally omitted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>徹底を必要とすることは、列挙ケース節がうっかり忘れられないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resolving Strong Reference Cycles Between Class Instances</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスインスタンス間の強い参照循環の解消</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resolving Strong Reference Cycles for Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャのための強い参照循環の解消</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rethrowing Functions and Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再スローを行う関数とメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rethrowing functions and methods must have at least one throwing function parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再スロー関数とメソッドは、少なくとも１つのスロー関数パラメーターを持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrieve a value from the array by using subscript syntax, passing the index of the value you want to retrieve within square brackets immediately after the name of the array:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字構文を使うことで、ひとつの値をこの配列から取り出してください、あなたが取り出したい値の添え字（インデックス、指数）を、配列の名前の直後の角括弧内に入れて渡してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>復帰文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return values can be ignored, but a function that says it will return a value must always do so.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>戻り値は無視されることができます、しかし値を返すつもりだと言う関数は、常にそうしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Revision History</seg>
      </tuv>
      <tuv lang="JA">
        <seg>改訂履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rewrite the closure to return zero for all odd numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクロージャを、全ての奇数に対してゼロを返すように書き直してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rewrote the Inheritance chapter to remove its introductory coverage of initializer overrides.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>章継承を書き直して、それの前置きのイニシャライザのオーバーライドを扱った部分を取り除きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rule 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>規則１</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rule 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>規則２</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rule 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>規則３</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Safety check 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>安全点検１</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Safety check 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>安全点検２</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Safety check 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>安全点検３</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Safety check 4</seg>
      </tuv>
      <tuv lang="JA">
        <seg>安全点検４</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalars that have been assigned to a character typically also have a name, such as LATIN SMALL LETTER A and FRONT-FACING BABY CHICK in the examples above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある文字に割り当てられるスカラーは、たいてい名前を持っています、例えば以前の例でのLATIN SMALL LETTER AとFRONT-FACING BABY CHICKなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, even if dataSource does exist, there is no guarantee that it implements increment(forCount:), because it is an optional requirement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第２に、たとえdataSourceが存在するとしても、それがincrement(forCount:)を実装する保証はありません、それがオプショナルの要件であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, the two’s complement representation also lets you shift the bits of negative numbers to the left and right like positive numbers, and still end up doubling them for every shift you make to the left, or halving them for every shift you make to the right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第２に、２の補数表現はまた、あなたに負数のビットを左や右に正の数のようにシフトさせます、そして依然としてあなたが左へとするシフトは全てそれを２倍にすることで、またあなたが右へとするシフトは全てそれを半分にすることで終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Precedence and Associativity for an explanation of how these characteristics affect an infix operator’s interaction with other infix operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位と結合性をどのようにそれらの特徴が接中辞演算子の他の接中辞演算子との相互作用に影響を及ぼすかの解説として見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Special Characters in String Literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、文字列リテラル内の特別な文字を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Overflow Operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー演算子を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also Function Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、関数宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also Initializer Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、イニシャライザ宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also Protocol Associated Type Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、プロトコル関連型宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also Subscript Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、添え字宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also Subscripts and Functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、「添え字」そして「関数」を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also Type Alias Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、型エイリアス宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also Variable Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、変数の宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Selector Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セレクタ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Self Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>self式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Semicolons</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セミコロン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set b and set c are disjoint with one another, because they share no elements in common.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合bと集合cは、他のものと互いに素です（交わりを持たない）、なぜならそれらが共通の要素を共有しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set a is a superset of set b, because a contains all elements in b.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合aは集合bの上位集合です、なぜならaがbのすべての要素を含むからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set Membership and Equality</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合の帰属と等価性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set Type Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Set型構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets are unordered collections of unique values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合は、順番をつけられないそれぞれが異なった値のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Initial Values for Stored Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期値を保存プロパティに設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting a Default Property Value with a Closure or Function</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のプロパティ値をクロージャまたは関数を使って設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the center property calls the setter for center, which modifies the x and y values of the stored origin property, and moves the square to its new position.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>centerプロパティを設定することは、centerのためのセッターを呼び出します、そしてそれは、保存されたoriginプロパティのxとy値を修正して、正方形をその新しい位置へと動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the value of properties that the subclass declares.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスが宣言するプロパティの値を設定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several of the switch statement’s cases bind their matched value to a constant of the specified type to enable its value to be printed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文のケース節のいくつかは、それらが適合した値を指定された型のある定数に結び付け、その値を出力できるようにします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shifting Behavior for Signed Integers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号つき整数のためのシフト挙動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shifting Behavior for Unsigned Integers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号なし整数のためのシフト挙動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shifting an integer’s bits to the left by one position doubles its value, whereas shifting it to the right by one position halves its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数のビットを位置１つだけ左へ移すことはその値を２倍にします、一方それを位置１つだけ右へ移すことはその値を半分にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shorthand Argument Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>短縮形引数名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shorthand Setter Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>短縮形セッター宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shorthand argument names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>短縮形引数名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signed integers use their first bit (known as the sign bit) to indicate whether the integer is positive or negative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号つき整数は、それらの最初のビット（符号ビットとして知られるもの）を使って、その整数が正であるか負であるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to an if statement, you can add multiple conditional branches to test for different compilation conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文と同様に、あなたは複数の条件分岐を加えて、異なるコンパイル条件に対してテストすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, item is Song checks whether the item is a Song instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、item is Songはその項目がSongインスタンスであるか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, 0xFp-2 represents 15 x 2-2, which evaluates to 3.75.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、0xFp-2は15 × 2-2を表します、それは3.75に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, 1.25e-2 represents 1.25 x 10-2, which evaluates to 0.0125.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、1.25e-2は1.25 × 10-2を表します、それは0.0125に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, a method marked with the nonobjc attribute cannot satisfy a protocol requirement for a method marked with the objc attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、nonobjc属性で印されるメソッドは、objc属性で印されるメソッドに対するプロトコル要件を満たすことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, a stack allows items to be removed only from the end of the collection (known as popping a value off the stack).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、スタックは項目をコレクションの終わりからだけ取り除かれることが許されます（値をスタックからポップするとして知られます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, a subclass failable initializer can delegate up to a superclass failable initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、サブクラスの失敗できるイニシャライザは、スーパークラスの失敗できるイニシャライザにさかのぼって委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, a subscript cannot be more public than either its index type or return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、添え字はそのインデックス型や戻り型よりも公開であることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, every Apartment instance has a unit property of type String and has an optional tenant property that is initially nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あらゆるApartmentインスタンスは、型Stringのunitプロパティを持って、初期時にはnilであるオプショナルのtenantプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if you have multiple nested loops, it can be useful to be explicit about which loop the continue statement should affect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あなたが複数の入れ子にされたループを持つならば、continue文が影響を及ぼさなければならないループはどれかについて明確にすることは役に立つでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if you implement a didSet observer, it’s passed a constant parameter containing the old property value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あなたがdidSetオブザーバーを実装するならば、それは古いプロパティ値を含んでいる定数パラメータを渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if you try to create a CartItem instance with an empty name value, the superclass Product initializer causes initialization to fail:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、あなたがCartItemインスタンスを空のname値で作成することを試みるならば、スーパークラスのProductイニシャライザは初期化が失敗する原因となります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if you try to retrieve an Int? value through optional chaining, an Int? is always returned, no matter how many levels of chaining are used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あなたがオプショナル連鎖を通してInt?値を取り出そうと試すならば、Int?が常に返されます、どんなに多くの連鎖階層が使われようともです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あくまでもより複雑な型の文脈内で使用するだけの有用なクラスや構造体を定義することは、便利でありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, its second case matches all lowercase English consonants.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、その第二のケース節は、小文字の英語の子音すべてにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, the SnakesAndLadders game class can be extended to adopt and conform to the TextRepresentable protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、SnakesAndLaddersゲーム・クラスは、拡張されることで、TextRepresentableプロトコルを採用して準拠することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, the green component is obtained by performing a bitwise AND between the numbers 0xCC6699 and 0x00FF00, which gives an output value of 0x006600.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、緑の構成要素は数0xCC6699と0x00FF00との間のビット単位の論理積を実行することによって得られます、それは、0x006600の出力値を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, the second case, case (0, let y), matches any point with an x value of 0 and assigns the point’s y value to the temporary constant y.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、第二のケース節、case (0, let y)は、0のx値をもつどんなポイントにでも適合して、そのポイントのy値を一時的な定数yに代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, the ternary conditional operator (a ? b : c) cannot be overloaded.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように三項条件演算子（a ? b : c)は、オーバーロードされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, there are 3.28084 feet in a meter, and so the ft computed property divides the underlying Double value by 3.28084, to convert it from feet to meters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、１メートルは3.28084フィートあります、なのでft計算プロパティは、もとのDouble値を3.28084で割って、それをフィートからメートルに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, type methods on structures and enumerations can access type properties by using the type property’s name without a type name prefix.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、構造体と列挙の型メソッドは、型名前接頭辞なしで型プロパティの名前を使用することによって型プロパティにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, use the hasSuffix(_:) method to count the number of scenes that take place in or around Capulet’s mansion and Friar Lawrence’s cell:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、hasSuffix(_:)メソッドを、キャビュレットの邸宅と修道士ローレンスの独居房の中または周囲で起こる場面の数を数えるために使用してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, you can create a dictionary to store values of any specified type, and there are no limitations on what that type can be.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あなたはどんな指定された型の値たちでも保管する辞書を作成することができます、そしてその型が何であることができるか制限がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, you can omit part of a type when the full type can be inferred from context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、前後関係から完全に型が推論されることができるとき、あなたはある型の一部を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, you can try to set a new value through a subscript with optional chaining:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あなたはオプショナル連鎖を使う添え字を通して、新しい値の設定を試みることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, you remove an item from the array with the remove(at:) method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あなたはremove(at:)メソッドを使って配列から項目を取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simple Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単純な値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simple statements are the most common and consist of either an expression or a declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単純な文は、もっとも普通のもので、ひとつの式もしくはひとつの宣言から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single Quote (\')</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一重引用符（\'）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single line comments begin with // and continue until a line feed (U+000A) or carriage return (U+000D).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一行コメントは//で始まります、そして行送り（U+000A）または復帰（U+000D）まで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single statement closures implicitly return the value of their only statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつだけの文のクロージャは、暗黙のうちにそのただ一つの文の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single-expression closures can implicitly return the result of their single expression by omitting the return keyword from their declaration, as in this version of the previous example:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単一の式のクロージャは、前の例のこの改作のように、returnキーワードをそれらの宣言から省略することによって、暗黙的にそれのただ一つの式の結果を返すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some declaration attributes accept arguments that specify more information about the attribute and how it applies to a particular declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>若干の宣言属性は、属性に関するより多くの情報とそれが特定の宣言に適用される方法を指定する引数を受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operations aren’t guaranteed to always complete execution or produce a useful output.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの操作は、常に実行を完了することや役に立つ出力を生成することを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some products are labeled with 1D barcodes in UPC format, which uses the numbers 0 to 9.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある製品はUPC形式の一次元バーコードでラベルをつけられます、それは0から9までの数字を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some squares are then set to have more specific values for the snakes and ladders.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの正方形は、それからヘビとはしごのためのより独特な値を持つように設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Something similar happens when an unsigned integer is allowed to overflow in the negative direction.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号なし整数が負の向きにおいてオーバフローを認められるときに同じようなことが起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes it is clear from a program’s structure that an optional will always have a value, after that value is first set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>時々、プログラムの構造から、あるオプショナルが必ず値を持つことが、その値が最初に設定される結果として、はっきりしていることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes you know a throwing function or method won’t, in fact, throw an error at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>時にはあなたはあるスロー関数またはメソッドが、実際のところ、実行時にエラーをスローすることがないのを知っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special Characters in String Literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラル内の特別な文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special Kinds of Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特別な種類のメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special Kinds of Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特別な種類のパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special characters can be included in string literals using the following escape sequences:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特別な文字は、以下のエスケープ・シーケンスを使って文字列リテラルの中に含まれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, if a failable initializer delegates to an initializer that fails and returns nil, then the initializer that delegated also fails and implicitly returns nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>具体的には、失敗できるイニシャライザが、ある失敗してnilを返すイニシャライザへ委任するならば、その時その委任した側のイニシャライザもまた失敗して暗黙的にnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, it declares a name property of type String, and an init name initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、それは型Stringのnameプロパティ、そしてinit nameイニシャライザを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, it expresses whether the number is negative, zero, or positive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>具体的には、それはその数が負、ゼロ、または正かを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, it must ensure that only items of the right type are added to the container, and it must be clear about the type of the items returned by its subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>具体的には、それは正しい型の項目だけがコンテナに加えられることを確実にしなければなりません、そして、それはそれの添え字によって返される項目の型についてはっきりわかっていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, the property observer chooses a gear that is the new currentSpeed value divided by 10, rounded down to the nearest integer, plus 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>具体的には、プロパティオブザーバーは、新しいcurrentSpeed値を10で割って、最も近い整数に丸めて、1を加えたギアを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, the result of an optional chaining call is of the same type as the expected return value, but wrapped in an optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>具体的には、オプショナル連鎖の呼び出しの結果は、期待される戻り値と同じ型ですが、オプショナルの中にラップされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying Argument Labels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルを指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying Cleanup Actions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クリーンアップ動作の指定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Square 3 contains the bottom of a ladder that moves you up to square 11.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正方形３は、正方形11まであなたを動かすはしごの底を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Squares with a ladder base have a positive number to move you up the board, whereas squares with a snake head have a negative number to move you back down the board.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>はしごの接地面がある正方形は、あなたを盤の上方に動かすために正の番号を持ちます、一方でヘビの頭のある正方形は、あなたを逆に盤の下に動かすために負の数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Statements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored Properties and Instance Variables</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存プロパティとインスタンス変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored Properties of Constant Structure Instances</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数構造体インスタンスの保存プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored Variable Observers and Property Observers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存された変数オブザーバーとプロパティオブザーバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored Variables and Stored Variable Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存変数と保存変数プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored and computed properties are usually associated with instances of a particular type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存されるもしくは計算されるプロパティは、通常は特定の型のインスタンスに結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored properties are constants or variables that are bundled up and stored as part of the class or structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存プロパティは、クラスまたは構造体の一部としてまとめられて保存される定数または変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored properties are provided only by classes and structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存プロパティは、クラスと構造体だけで提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored properties can be either variable stored properties (introduced by the var keyword) or constant stored properties (introduced by the let keyword).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存プロパティは、変数保存プロパティ（varキーワードによって導入される）か定数保存プロパティ（letキーワードによって導入される）であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored properties cannot be left in an indeterminate state.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存プロパティは、不確定な状態のままにされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存プロパティは、あるインスタンスの一部として定数と変数の値を保存します、一方で、計算プロパティは、値を（たくわえておくのではなく）計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored type properties are lazily initialized on their first access.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存型プロパティは、それらの最初のアクセスにおいて遅延して初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored type properties can be variables or constants.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存型プロパティは、変数または定数であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored variables, like stored properties, provide storage for a value of a certain type and allow that value to be set and retrieved.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存変数は、保存プロパティの様に、保管場所を特定の型のひとつの値のために用意して、その値の設定と取得を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strictly speaking, initializers do not return a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>厳密にいえば、イニシャライザは値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strictly speaking, this version of the greet(person:) function does still return a value, even though no return value is defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>厳密に言って、たとえ戻り値が定義されないとしても、このバージョンのgreet(person:)関数は、まだ値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strictly speaking, you can write a custom class that conforms to CounterDataSource without implementing either protocol requirement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>厳密に言って、あなたはCounterDataSourceに準拠する特注のクラスを書くことが両方のプロトコル要件を満たすことなく可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String Indices</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列インデックス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String Interpolation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列補間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String Literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String Mutability</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列の可変性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String and Character Equality</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列と文字の同等性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String and character comparisons in Swift are not locale-sensitive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列および文字の比較はスウィフトではロケールに影響されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String and character equality is checked with the “equal to” operator (==) and the “not equal to” operator (!=), as described in Comparison Operators:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列と文字の同等性は、「同等」演算子（==）および「不等」演算子（!=）で調べられます、これは比較演算子で記述されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String literals can include the following special characters:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラルは、以下の特別な文字を含むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String literals cannot contain an unescaped double quote ("), an unescaped backslash (\), a carriage return, or a line feed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラルは、エスケープされない二重引用符（"）、エスケープされないバックスラッシュ（\）、キャリッジリターン、またはラインフィードを含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String literals that are concatenated by the + operator are concatenated at compile time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>+演算子によって連結される文字列リテラルは、コンパイル時に連結されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings Are Value Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列は値型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings and Characters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列と文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings, arrays, and dictionaries in Foundation are always assigned and passed around as a reference to an existing instance, rather than as a copy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Foundationでの文字列、配列、そして辞書は、常にコピーとしてでなく既存のインスタンスへの参照として代入されてあちこちに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strong Reference Cycles Between Class Instances</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスインスタンス間の強い参照循環</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strong Reference Cycles for Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャのための強い参照循環</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure and enumeration methods that modify self or its properties must mark the instance method as mutating, just like mutating methods from an original implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>selfまたはそのプロパティを修正する構造および列挙メソッドは、ちょうど最初の実施からの可変メソッドのように、そのインスタンスメソッドにmutatingとして印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure declarations are declared using the struct keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体宣言は、キーワードstructを使って宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure declarations can’t contain deinitializer or protocol declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造宣言は、デイニシャライザまたはプロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure types automatically receive a memberwise initializer if they do not define any of their own custom initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体型は、それが独自のあつらえのイニシャライザを何ら定義しないならば、自動的にメンバー関連イニシャライザを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure types can adopt any number of protocols, but can’t inherit from classes, enumerations, or other structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体型は、随意の数のプロトコルに準拠することができます、しかしクラス、列挙、または他の構造体から継承することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure, enumeration, and class types can have any number of initializers, but the rules and associated behavior for class initializers are different.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体、列挙、そしてクラス型は、随意の数のイニシャライザを持つことができます、しかし、クラスイニシャライザのための規則および関連する挙動は異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures and Enumerations Are Value Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体と列挙は値型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures and classes both use initializer syntax for new instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体とクラスは両方とも、新しいインスタンスのためにイニシャライザ構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures and enumerations are value types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体と列挙は、値型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures and enumerations are value types, not reference types, and are not stored and passed by reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造と列挙は値型であって、参照型ではありません、そして参照によって格納されたり渡されたりしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures are always copied when they are passed around in your code, and do not use reference counting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体は、それがあなたのコードにおいてあちこち渡されるとき常にコピーされます、したがって参照カウントを使用しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures are value types; instances of a structure are copied when assigned to variables or constants, or when passed as arguments to a function call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体は、値型です；構造体のインスタンスは、変数や定数に代入される時、または関数呼び出しの引数として渡される時にコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures support many of the same behaviors as classes, including methods and initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体は、クラスと同じ挙動の多くを、メソッドとイニシャライザも含めてサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures that implement it must declare the method with the static declaration modifier instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それを実装する構造体は、その代わりにstatic宣言修飾子を使ってメソッドを宣言しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subclasses can modify inherited variable properties during initialization, but can not modify inherited constant properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスは、初期化の間に継承された変数プロパティを修正することできます、しかし継承された定数プロパティを変更することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subclasses can themselves be subclassed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスは、それ自身サブクラスを作られることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subclasses can use a superclass expression in their implementation of members, subscripting, and initializers to make use of the implementation in their superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスは、そのメンバー、添え字、そしてイニシャライザの実装においてスーパークラス式を使うことで、それらのスーバークラス内の実装を活用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subclasses include their superclass name after their class name, separated by a colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスたちはそれらのクラス名の後に、コロンで区切られて、それらのスーパークラス名を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subclassing</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスをつくる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript Options</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字オプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字の構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript Usage</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字の使用法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript declarations are declared using the subscript keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言は、キーワードsubscriptを使って宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript declarations can appear only in the context of a class, structure, enumeration, extension, or protocol declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言は、クラス、構造体、列挙、拡張、またはプロトコル宣言の文脈においてだけ、現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript declarations only declare the minimum getter and setter implementation requirements for types that conform to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言は、プロトコルに準拠する型のための最小限のゲッターとセッター実装要件を宣言するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts are not limited to a single dimension, and you can define subscripts with multiple input parameters to suit your custom type’s needs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は一つの次元に制限されません、なのであなたは複数の入力パラメータをもつ添え字を定義して、あなたのあつらえの型の必要を満たすことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts are typically used as a shortcut for accessing the member elements in a collection, list, or sequence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は、一般的に、コレクション、リスト、またはシーケンスの中のメンバー要素にアクセスするための近道として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts can also return any type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は、また、どんな型でも返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts can take any number of input parameters, and these input parameters can be of any type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は、任意の数の入力パラメータをとることができます、そしてこれらの入力パラメータはどんな型でもかまいません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts can use variadic parameters, but they can’t use in-out parameters or provide default parameter values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は、可変長パラメータを使うことができます、しかしそれはin-outパラメータを使うことや省略時のパラメータ値を提供することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts enable you to query instances of a type by writing one or more values in square brackets after the instance name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は、あなたにそのインスタンス名の後で角括弧の中に一つ以上の値を書くことによって、ある型のインスタンスに問い合わせることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subtracting 1 from this binary number with the overflow operator gives a binary value of 01111111, which toggles the sign bit and gives positive 127, the maximum positive value that an Int8 can hold.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この２進数からオーバフロー演算子を使って1を減ずることは、２進数の01111111を与えます、それは符号ビットを切り替えて正の127、Int8が持つことができる最大限の正の値、を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subtraction (-)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>減算（-）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such properties are known as type properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのようなプロパティは、型プロパティとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suitable scenarios for an assertion check include:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明による検査にふさわしいシナリオは、以下を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary of the Grammar</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文法の概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Superclass Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラス式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Superclass deinitializers are always called, even if a subclass does not provide its own deinitializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスのデイニシャライザは、たとえサブクラスがそれ自身のデイニシャライザを提供しないとしても、常に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Superclass deinitializers are inherited by their subclasses, and the superclass deinitializer is called automatically at the end of a subclass deinitializer implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスのデイニシャライザは、それらのサブクラスたちによって継承されます、そして、スーパークラスのデイニシャライザはサブクラスのデイニシャライザ実施の終わりに自動的に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Superclass initializers are inherited in certain circumstances, but only when it is safe and appropriate to do so.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスのイニシャライザはある特定の状況において継承されます、しかしそれが安全にそして適切にそうできる時だけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift adopts safe programming patterns and adds modern features to make programming easier, more flexible, and more fun.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、いくつかの安全なプログラミング・パターンを採用すること、そして様々な現代的な特徴を加えることで、プログラミングをより簡単でより柔軟でより面白くします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also handles all memory management involved in disposing of variables when they are no longer needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、それがもはや必要とされないとき変数を処分することに関わるすべての記憶管理を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also introduces optional types, which handle the absence of a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまたオプショナルの型を導入します、それは値の欠如を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also makes extensive use of variables whose values cannot be changed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、値が変更されることができない変数を広範囲に利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also provides unsafe unowned references for cases where you need to disable runtime safety checks—for example, for performance reasons.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまたunsafe非所有参照を、あなたが実行時安全確認を無効にする必要がある場合のために提供します — 例えば、性能上の理由のために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also provides a for-in loop that makes it easy to iterate over arrays, dictionaries, ranges, strings, and other sequences.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、for-inループを提供します、それは、配列、辞書、範囲、文字列、およびその他のシーケンス（連続したもの）の全体にわたって繰り返し処理するのを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also provides an unsigned integer type, UInt, which has the same size as the current platform’s native word size:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、符号なし整数型、UIntを提供します、そしてそれは、現在のプラットホーム固有のワードサイズと同じ大きさを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also provides powerful versions of the three primary collection types, Array, Set, and Dictionary, as described in Collection Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、３つの主要なコレクション型、Array、Set、そしてDictionaryの強力なバージョンを提供します、それは「コレクション型」で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also provides two identity operators (=== and !==), which you use to test whether two object references both refer to the same object instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、２つの同一性演算子を提供します（===と!==）、それはあなたが２つのオブジェクト参照が両方とも同じオブジェクト・インスタンスに言及するかどうかについて調べるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also provides two range operators (a..&lt;b and a...b) not found in C, as a shortcut for expressing a range of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、値の幅を表す近道として、Cで見られない２つの範囲演算子（a..&lt;bとa...b）を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift always chooses Double (rather than Float) when inferring the type of floating-point numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点数の型を推論するとき、スウィフトは常にDoubleを選びます（Floatではなく）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift automatically deallocates your instances when they are no longer needed, to free up resources.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは自動的に、それらがもはや必要とされない場合はあなたのインスタンスを割り当て解除して、資源を自由に使えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift automatically propagates errors out of their current scope until they are handled by a catch clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは自動的に、エラーをそれの現在のスコープの外に、それがcatch節によって取り扱われるまで伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure’s arguments by the names $0, $1, $2, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは行内クロージャに自動的に短縮形引数名を提供します、そしてそれは、名前$0、$1、$2、などにでクロージャの引数の値に言及するために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift can therefore infer that Element is the appropriate type to use as the ItemType for this particular container.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、したがってElementが、この特定のコンテナのためのItemTypeとして使うのに適当な型であると推測することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift classes do not inherit from a universal base class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのクラスたちは、ひとつの共通の基盤クラスから継承はしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift combines the best in modern language thinking with wisdom from the wider Apple engineering culture.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、現代の言語の最良の思想を、幅広いアップル工学文化由来の知的資産と結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift defines a Never type, which indicates that a function or method doesn’t return to its caller.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはNever型を定義します、それはある関数またはメソッドがそれの呼び出し側に帰らないことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift defines numerous precedence groups to go along with the operators provided by the standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、標準ライブラリによって提供される演算子と一緒にやっていくために、多数の優先順位グループを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift defines two kinds of initializers for class types to help ensure all stored properties receive an initial value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、クラス型のために２種類のイニシャライザを定義して、全ての保存プロパティが初期値を受け取ることを確実にするのを手伝います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift enumerations are particularly well suited to modeling a group of related error conditions, with associated values allowing for additional information about the nature of an error to be communicated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト列挙は、関連値がエラーの性質についての追加の情報と通信可能にすることを含め、関係のあるエラー状況のグループを作るのにとりわけ適します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift feels familiar to Objective-C developers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、Objective-C開発者にとってなじみ深いものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift gives you a warning if you use an optional value where a value of type Any is expected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、あなたがオプショナル値を型Anyが期待されるところで使うならば警告を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift gives you the freedom to define your own custom infix, prefix, postfix, and assignment operators, with custom precedence and associativity values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、あなたに、特注の優先順位と結合性値で、あなた自身のあつらえの接中辞、接頭辞、接尾辞、そして代入演算子を定義する自由を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift handles all of the memory management of capturing for you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、キャプチャ（その瞬間の保存）の記憶管理の全てを、あなたのために取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift handles the memory management of instances through automatic reference counting (ARC), as described in Automatic Reference Counting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、自動参照カウントで記述されるように、インスタンスのメモリ管理を自動参照カウント（ARC）を通して取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has a basic Boolean type, called Bool.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、ひとつの基本的なブール型を持ちます、それはBoolと呼ばれるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has been years in the making.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、その作成に幾年かを費やしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has built-in support for checking API availability, which ensures that you don’t accidentally use APIs that are unavailable on a given deployment target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、API有効性確認のための組み込みのサポートを持ちます、それはあなたが特定の開発対象で有効でないAPIをうっかり使うことがないのを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has five control transfer statements:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、５つの制御移動文を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has five control transfer statements: a break statement, a continue statement, a fallthrough statement, a return statement, and a throw statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、５つの制御移動文を持ちます：break文、continue文、fallthrough文、return文、そしてthrow文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has three branch statements: an if statement, a guard statement, and a switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、３つの分岐文を持ちます：if文、guard文、そしてswitch文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has three loop statements: a for-in statement, a while statement, and a repeat-while statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、３つのループ文を持ちます：for-in文、while文、そしてrepeat-while文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has two complier control statements: a conditional compilation block and a line control statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、２つのコンパイラ制御文：条件コンパイルブロックと行制御文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift helps to ensure your overrides are correct by checking that the override definition has a matching superclass definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、あなたの無効化が正しいものであることを、その無効化定義がスーパークラス定義に合致するのを確認することによって確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift includes two range operators, which are shortcuts for expressing a range of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは２つの範囲演算子を含みます、それは値の範囲を表すための近道です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift is a type-safe language, which means the language helps you to be clear about the types of values your code can work with.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは型安全な言語です、それが意味するのは、この言語があなたを助けて、あなたのコードが扱うことができる値の型について明確であるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift is a type-safe language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、型安全な言語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift is a fantastic way to write iOS, macOS, watchOS, and tvOS apps, and will continue to evolve with new features and capabilities.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、iOS、macOS、watchOS、そしてtvOSアプリを書く素晴らしい方法であり、新しい特徴と能力で発展し続けるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、iOS、macOS、watchOS、そしてtvOSアプリ開発のための新しいプログラミング言語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift is a new programming language for iOS, macOS, watchOS, and tvOS apps that builds on the best of C and Objective-C, without the constraints of C compatibility.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、iOS、macOS、watchOS、そしてtvOSアプリのための新しいプログラミング言語です、それはCとObjective-Cの最良の部分を、Cとの互換性に縛られることなく活用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift is a type-safe language, and does not allow (for example) a variable of type String and a variable of type Double to swap values with each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは型安全な言語です、それで（例えば）型Stringの変数と型Doubleの変数にお互いに値を交換させることをしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift is friendly to new programmers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、新規プログラマーに好意的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift makes it easy to provide tailored implementations of these operators and to determine exactly what their behavior should be for each type you create.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、それら演算子の注文仕立ての実装を提供することについて、そしてそれらの挙動があなたがつくる各型のために正確にどういったものでなければならないかについて決定することを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift manages all value copying to ensure optimal performance, and you should not avoid assignment to try to preempt this optimization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、全ての値のコピーを管理して最適のパフォーマンスを保証します、そしてあなたは代入を避けてこの最適化を先取りしようとしてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift now has a Nil-Coalescing Operator (a ?? b), which unwraps an optional’s value if it exists, or returns a default value if the optional is nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは今やnil合体演算子（a ?? b）をもちます、それはあるオプショナルの値を、もしそれが存在するならばアンラップします、またはそのオプショナルがnilならばある省略時の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift now has a native Set collection type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは今では持って生まれたSetコレクション型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift now includes the as? and as! failable downcast operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは今では失敗できるダウンキャスト演算子as?とas!を含めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides a default initializer for any structure or class that provides default values for all of its properties and does not provide at least one initializer itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、それのもつプロパティの全てに省略時の値を与えて、ともかく１つのイニシャライザもそれ自身では提供しないあらゆる構造体またはクラスのために、省略時のイニシャライザを用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides a variety of control flow statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、さまざまな制御の流れ文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides an additional integer type, Int, which has the same size as the current platform’s native word size:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは追加の整数型、Intを提供します、そしてそれは、現在のプラットホーム固有のワードサイズと同じ大きさを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides an elegant solution to this problem, known as a closure capture list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはこの問題の洗練された解答、クロージャ捕獲リストとして知られるものを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、回復可能なエラーのスロー、キャッチ、伝達、そして取り扱いに対してファーストクラスのサポートを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides five different access levels for entities within your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、５つの異なるアクセス水準をあなたのコード内の実在に対して用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides five levels of access control: open, public, internal, file private, and private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、５つの水準のアクセス制御を提供します：公開、内部、そして非公開。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides its own versions of all fundamental C and Objective-C types, including Int for integers, Double and Float for floating-point values, Bool for Boolean values, and String for textual data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、全ての基本的なCおよびObjective-C型に関してそれ自身のバージョンを提供します、それには、整数のためのInt、浮動小数点値のためのDoubleとFloat、ブール値のためのBool、そして、文字情報データのためのStringを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides several different ways to access Unicode representations of strings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、文字列のUnicode表現にアクセスするためにいくつかの異なる方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides signed and unsigned integers in 8, 16, 32, and 64 bit forms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、８、16、32、そして64ビット形式で、符号つきおよび符号なし整数を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides the following Interface Builder attributes: IBAction, IBOutlet, IBDesignable, and IBInspectable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、以下のインターフェースビルダー属性を提供します：IBAction、IBOutlet、IBDesignable、そしてIBInspectable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides three arithmetic overflow operators that opt in to the overflow behavior for integer calculations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、整数計算のためにオーバフロー挙動を選択する３つの算術オーバフロー演算子を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides three primary collection types, known as arrays, sets, and dictionaries, for storing collections of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは３つの主要なコレクション型を提供します、それらは配列、集合、そして辞書として知られ、値の集まり（コレクション）をしまっておくためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides three ways to compare textual values: string and character equality, prefix equality, and suffix equality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、テキスト関連の値を比較する３つの方法を提供します：文字列および文字の等式、接頭辞等式、そして接尾辞等式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides two Boolean constant values, true and false:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは２つのブールの定数値、trueとfalseを提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides two kinds of while loops:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは２種類のwhileループを提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides two signed floating-point number types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、２つの符号つき浮動小数点数型を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides two special types for working with nonspecific types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、２つの特別な型を「不特定」の型を扱うために提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides two ways to add conditional branches to your code: the if statement and the switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは条件分岐をあなたのコードに加える２つの方法：if文とswitch文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides two ways to resolve strong reference cycles when you work with properties of class type: weak references and unowned references.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがクラス型のプロパティを扱うとき、スウィフトは強い参照循環を解消する２つの道を提供します：弱い参照と非所有者参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift reports an error at compile time if you try to use an API that isn’t available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、あなたが有効でないAPIを使おうと試みるならば、コンパイル時にエラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift requires you to write self.someProperty or self.someMethod() (rather than just someProperty or someMethod()) whenever you refer to a member of self within a closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはあなたにself.somePropertyまたはself.someMethod()（ただ単にsomePropertyまたはsomeMethod()ではなく）を書くことを、あなたがクロージャ内でselfのメンバーに言及するときはいつでも、要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift strings are represented by the String type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの文字列はString型によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift supports all of the bitwise operators found in C, as described below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、下記のように、Cで見つけられるビット単位演算子の全てをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift supports all standard C comparison operators:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、標準的なC 比較演算子の全てをサポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift supports most standard C operators and improves several capabilities to eliminate common coding errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、ほとんどの標準のC演算子をサポートして、一般的なコード記述エラーを排除するためにいくつかの能力を向上させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift supports the four standard arithmetic operators for all number types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、４つの標準の算術演算子を数の型すべてに対してサポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift supports the three standard logical operators found in C-based languages:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、Cに基づく言語で見られる３つの標準の論理演算子をサポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift unifies these concepts into a single property declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、これらの概念をだだ１つのプロパティ宣言に統一します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、あなたのアプリのメモリ使用を追跡して管理するために、自動参照カウント（ARC）を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift uses capture lists to break these strong reference cycles.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、これらの強い参照循環を壊すために捕獲リストを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift uses string interpolation to include the name of a constant or variable as a placeholder in a longer string, and to prompt Swift to replace it with the current value of that constant or variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、定数または変数の名前をより長い文字列の中にプレースホルダーとして含めるために、そしてそれをその定数または変数の現在の値と取り替えることをスウィフトに促すために、文字列補間を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift uses type inference extensively, allowing you to omit the type or part of the type of many variables and expressions in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは広く型推論を使います、そして、あなたのコードにおいて型、または多くの変数および式の型の一部を省略できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s Array type already provides an append(_:) method, a count property, and a subscript with an Int index to retrieve its elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのArray型は、すでにappend(_:)メソッド、countプロパティ、そしてその要素を取り出すためにIntインデックスを使う添え字を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s Array type also provides an initializer for creating an array of a certain size with all of its values set to the same default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのArray型はまた、その値の全てが提供された同じ初期値に設定される、特定の大きさの配列をつくるためにイニシャライザを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s Array type is bridged to Foundation’s NSArray class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのArray型はFoundationのNSArrayクラスにブリッジ（橋渡し）されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s Array type now has full value semantics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのArray型は現在は完全な値意味論を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s Dictionary type does not have a defined ordering.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのDictionary型は、決まった順序を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s Dictionary type implements its key-value subscripting as a subscript that takes and returns an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのDictionary型は、それの「キーと値」に関する添え字を、オプショナル型を受け取り返す添え字として実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s Dictionary type is bridged to Foundation’s NSDictionary class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのDictionary型は、FoundationのNSDictionaryクラスにブリッジ（橋渡し）します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s Int type has an initializer which tries to convert a String value into an Int value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのInt型はあるイニシャライザを持ちます、それはString値をInt値に変換することを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s Set type does not have a defined ordering.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのSet型は、決まった順番を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s Set type is bridged to Foundation’s NSSet class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのSet型は、FoundationのNSSetクラスにブリッジ（橋渡し）されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s String and Character types provide a fast, Unicode-compliant way to work with text in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのStringおよびCharacter型は、あなたのコードにおいてテキストを処理するために、ある高速な、Unicodeに対応したやり方を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s String type is a value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのString型は、値型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s String type is bridged with Foundation’s NSString class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのString型は、FoundationのNSStringクラスを使って橋渡しをされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s nil is not the same as nil in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのnilは、Objective-Cでのnilと同じものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s switch statement is also considerably more powerful than its counterpart in many C-like languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのswitch文もまた、多くのCに似た言語で相当する物よりずっと強力です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s String and Character types are fully Unicode-compliant, as described in this section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのStringとCharacter型は、この節で記述されるように、完全にUnicodeに対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s String type defines its string-specific implementation of the greater-than operator (&gt;) as a method that has two parameters of type String, and returns a value of type Bool.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのString型は、それの文字列特有の実装の「大なり」演算子（&gt;）をメソッドとして定義します、それは型Stringの２つのパラメータを持ち、型Boolの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s access control model is based on the concept of modules and source files.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのアクセス制御モデルは、モジュールとソースファイルの概念に基づきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s approach prevents a situation in which a simple initializer from a superclass is inherited by a more specialized subclass and is used to create a new instance of the subclass that is not fully or correctly initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの取り組み方は、スーパークラスのもつ単純なイニシャライザがより特殊化されたサブクラスによって継承されて、充分にまたは正しく初期化されない状態の、サブクラスの新しいインスタンスをつくるのに使われる状況を防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s array, set, and dictionary types are implemented as generic collections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの配列、集合、そして辞書型は、総称体のコレクションとして実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s clean slate, backed by the mature and much-loved Cocoa and Cocoa Touch frameworks, is an opportunity to reimagine how software development works.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの（成熟し非常に愛されるココアとココア・タッチ・フレームワークを背景とした）白紙の状態は、ソフトウェア開発作業のやり方を再考する絶好の機会です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s closure expressions have a clean, clear style, with optimizations that encourage brief, clutter-free syntax in common scenarios.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのクロージャ式は、最適化された、きれいな、明白なスタイルを持ちます、それは、通常さまざまに予想される状況において、簡潔な、混乱のない構文を助長します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s compiler performs four helpful safety-checks to make sure that two-phase initialization is completed without error:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのコンパイラは、２段階初期化がエラーなしで完了されることを確認するために４つの役に立つ安全点検を実行します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s copy-by-default String behavior ensures that when a function or method passes you a String value, it is clear that you own that exact String value, regardless of where it came from.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの省略時コピーのString挙動は、関数またはメソッドがあなたにString値を渡すとき、それが来たところに関係なく、あなたがその正確な写しのString値を所有することが明白なのを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s initialization flow is more flexible in that it lets you set custom initial values, and can cope with types for which 0 or nil is not a valid default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがあなたに好みに合わせた初期値を設定させて、0またはnilが有効な省略時の値でない型に対処することができるという点で、スウィフトの初期化の流れはより柔軟です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s native String type no longer has an uppercaseString or lowercaseString property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの生粋のString型はもはやuppercaseStringまたはlowercaseStringプロパティを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s operator precedences and associativity rules are simpler and more predictable than those found in C and Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの演算子優先順位と結合性規則は、CとObjective-Cで見つけられるそれらより単純でより予測できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s optionals let you indicate the absence of a value for any type at all, without the need for special constants.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのオプショナルは、あなたに特別な定数の必要なしにあらゆる全ての型の値の欠如を示させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s standard library provides a method called sorted(by:), which sorts an array of values of a known type, based on the output of a sorting closure that you provide.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの標準ライブラリはsorted(by:)と呼ばれるメソッドを提供します、それは、ある既知の型の値からなる配列の分類を、あなたが提供するあるソート（分類）を行うクロージャの出力に基づき行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s two-phase initialization process is similar to initialization in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの２段階初期化プロセスは、Objective-Cでの初期化に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s type checker is able to deduce that Movie and Song have a common superclass of MediaItem, and so it infers a type of [MediaItem] for the library array:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの型チェッカーはMovieとSongが共通のスーパークラスMediaItemを持つと推論することができます、なのでそれはlibrary配列に対して[MediaItem]型を推論します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s type safety prevents non-Boolean values from being substituted for Bool.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの型安全は、非ブール値がBoolの代用にされるのを妨げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s unified function syntax is flexible enough to express anything from a simple C-style function with no parameter names to a complex Objective-C-style method with names and argument labels for each parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの統合された関数構文は、十分な柔軟性があり、パラメータ名を持たない単純なCスタイルの関数から、各パラメータに対して名前および引数ラベルをもつ複雑なObjective-Cスタイルのメソッドまで、何でも表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switch</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スイッチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switch Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スイッチ文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switch Statements Must Be Exhaustive</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スイッチ文は徹底的でなければなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switch statements in Swift don’t fall through the bottom of each case and into the next one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのスイッチ文は、それぞれのケース節の底を抜け落ちて次のものにいきません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switches support any kind of data and a wide variety of comparison operations—they aren’t limited to integers and tests for equality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スイッチ（条件分岐）は、あらゆる種類のデータおよび多種多様な比較操作をサポートします ― それは、整数および同等性に対する検査に限られていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntactic categories are indicated by italic text and appear on both sides of a grammar production rule.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>統語論のカテゴリーは、イタリックのテキストによって示されて、文法導出規則の両側に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntactically, a variadic parameter consists of a base type name followed immediately by three dots (...), as in Int....</seg>
      </tuv>
      <tuv lang="JA">
        <seg>統語的には、可変長パラメータは、Int...のように、基となる型名に直ちに３つの点（...）が続くものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntactically, every primary expression is also a postfix expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>統語論的に、あらゆる基本式は、また、接尾辞式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntax for Designated and Convenience Initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定および便宜イニシャライザのための構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Terminology</seg>
      </tuv>
      <tuv lang="JA">
        <seg>用語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ternary Conditional Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>三項条件演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tests can also access classes and class members that are marked with the internal or public access-level modifier as if they were declared with the open access-level modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのテストはまた、internalまたはpublicアクセス水準修飾子で印を付けられるクラスおよびクラスメソッドにアクセスできます、まるでそれらがopenアクセス水準修飾子で宣言されたかのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to Swift’s type inference, you don’t actually need to declare a concrete ItemType of Int as part of the definition of IntStack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの型推論のおかげで、あなたは実際にはIntStackの定義の一部として具体的なItemTypeのIntを宣言する必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to Swift’s type inference, you don’t have to write the type of the array if you’re initializing it with an array literal containing values of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの型推論のおかげで、あなたが同じ型の値を含んでいる配列リテラルでそれを初期化しているのならば、あなたは配列の型を書く必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to this groundwork, we can now introduce a new language for the future of Apple software development.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この基礎のおかげで、私達は現在アップル・ソフトウェア開発の将来のために、新しい言語を紹介することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That branch must transfer control to exit the code block in which the guard statement appears.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その分岐は、制御を移して、guard文が現れているコードブロックを脱出する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That function’s caller can then catch the error and respond appropriately.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関数の呼び出し側はそのときそのエラーをキャッチして（捕まえて）適切に応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, an implementation of == must satisfy the following three conditions, for all values a, b, and c:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すなわち、==の実装は、以下の３つの条件をa、b、およびcすべての値に対して満足させなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, every possible value of the type being considered must be matched by one of the switch cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すなわち、考察されている型のすべてのあり得る値が、switchケース節のうちの１つと適合しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, it must provide a way to make itself uniquely representable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すなわち、それはそれ自身を特有に表わすことを可能にする方法を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the type must conform to one of the following Swift standard library protocols: ExpressibleByIntegerLiteral for integer literals, ExpressibleByFloatLiteral for floating-point literals, ExpressibleByStringLiteral for string literals, ExpressibleByBooleanLiteral for Boolean literals, ExpressibleByUnicodeScalarLiteral for string literals that contain only a single Unicode scalar, and ExpressibleByExtendedGraphemeClusterLiteral for string literals that contain only a single extended grapheme cluster.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すなわち、その型は以下のスウィフト標準ライブラリのプロトコルの１つに準拠しなければなりません：整数リテラルに対してExpressibleByIntegerLiteral、浮動小数点リテラルに対してExpressibleByFloatLiteral、文字列リテラルに対してExpressibleByStringLiteral、ブールのリテラルに対してExpressibleByBooleanLiteral、ただ１つのユニコードスカラーだけを含む文字列リテラルに対してExpressibleByUnicodeScalarLiteral、そしてただ１つの拡張書記素クラスタだけを含む文字列リテラルに対してExpressibleByExtendedGraphemeClusterLiteral。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the type of x in var x: Int = 0 is inferred by first checking the type of 0 and then passing this type information up to the root (the variable x).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すなわち、var x: Int = 0の中のxの型は、最初に0の型を調べて、それからこの型情報を根（変数x）までさかのぼって渡すことによって推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, a nonthrowing method can override a throwing method, and a nonthrowing method can satisfy a protocol requirement for a throwing method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、非スローメソッドはスローメソッドをオーバーライドできます、そして非スローメソッドはスローメソッドのプロトコル要件を満たすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, a rethrowing method can override a throwing method, and a rethrowing method can satisfy a protocol requirement for a throwing method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、再スローメソッドはスローメソッドをオーバーライドできます、そして再スローメソッドはスローメソッド用のプロトコル要件を満たすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, because protocols don’t implement their members, most protocol members are declarations only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、プロトコルがそれらのメンバーを実装しないので、大部分のプロトコル・メンバーは宣言だけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, if a constant is initialized with a class object, the object itself can change, but the binding between the constant name and the object it refers to can’t.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうは言っても、定数がクラスオブジェクトで初期化されるならば、そのオブジェクト自体は変わることができます、しかし、定数名とそれが言及するオブジェクトの間の束縛はそうすることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, if a subclass initializes all of its stored properties with default values and doesn’t define any initializers of its own, it inherits all of the superclass’s initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、サブクラスがそれの保存プロパティのすべてを省略時の値で初期化して、それ自身のイニシャライザを全く定義しないならば、それはそのスーパークラスのイニシャライザのすべてを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, if no initializer expression is present, the variable declaration must include an explicit type annotation (: type).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、イニシャライザ式が存在しないならば、変数の宣言は明確な型注釈（: type）を含まなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, if the type you’re extending is defined in another module, an initializer declaration must delegate to an initializer already defined in that module to ensure members of that type are properly initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、 あなたが拡張している型が別のモジュールにおいて定義されるならば、イニシャライザ宣言はそのモジュールですでに定義されるイニシャライザに委任して、その型のメンバーが正しく初期化されることを確実にしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, if you assign a value to a variable or property within its own didSet observer clause, that new value that you assign will replace the one that was just set and passed to the willSet observer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、あなたがdidSetオブザーバー節自身の内部である値を変数またはプロパティに代入するならば、あなたが代入するその新しい値は、ちょうど設定されたばかりのwillSetオブザーバーに渡されたものを置き換えることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, if you provide a setter clause, you must also provide a getter clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、 あなたがセッター節を提供するならば、あなたはまたゲッター節も提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, if you want execution to continue from one case to the next, explicitly include a fallthrough statement, which simply consists of the fallthrough keyword, in the case from which you want execution to continue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでもやはり、あなたが実行に１つのケース節から次のものまで続いて欲しいならば、あなたが実行に続いて欲しいケース節で明示的にfallthrough文を含めてください、それは、単にキーワードfallthroughから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, it can’t contain any cases that are also marked with the indirect modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言うものの、それはindirect修飾子でさらに印されるどんなケース節も含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, the initialization processes must end with a call to a designated initializer that ultimately initializes the class’s properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、 初期化プロセスは、最終的にそのクラスのプロパティを初期化する指定イニシャライザに対する呼び出しで終わらなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, you can mark these protocol member declarations with the optional declaration modifier to specify that their implementation by a conforming type is optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、 あなたはこれらのプロトコルメンバー宣言をoptional宣言修飾子を使って印して、ある準拠型にとってそれらの実装が随意であると指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, you can overload a function based on whether a function parameter can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、あなたは関数を、ある関数パラメーターがエラーをスローできるかどうかに基づいてオーバーロードすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, you can use parentheses to be explicit about the scope of the operator’s application.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言うものの、あなたは丸括弧を使って演算子の適用範囲について明確にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The (404, "Not Found") tuple groups together an Int and a String to give the HTTP status code two separate values: a number and a human-readable description.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この(404, "Not Found")タプルはIntとStringをひとつにまとめて、HTTP状態コードに２つの別々の値：数と人間の読める説明を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The @optional, @lazy, @final, and @required attributes are now the optional, lazy, final, and required Declaration Modifiers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@optional、@lazy、@final、そして@required属性は今やoptional、lazy、final、そしてrequired宣言修飾子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The @prefix and @postfix attributes for Prefix and Postfix Operators have been replaced by prefix and postfix declaration modifiers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞および接尾辞演算子のための@prefixと@postfix属性は、prefixとpostfix宣言修飾子によって置き換えられました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Address class also provides a method called buildingIdentifier(), which has a return type of String?.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Addressクラスはまた、buildingIdentifier()と呼ばれるメソッドを提供します、それは、String?の戻り型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Any type represents values of any type, including optional types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Any型は、オプショナル型を含む、何らかの型の値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The AudioChannel structure also defines a stored instance property called currentLevel, which represents the channel’s current audio level on a scale of 0 to 10.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AudioChannel構造体はまた、currentLevelと呼ばれる保存インスタンスプロパティを定義します、それは、0から10までの目盛りでチャンネルの現在の音声レベルを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The AudioChannel structure defines two stored type properties to support its functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AudioChannel構造体は、その機能性を支えるために２つの保存型プロパティを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The AutomaticallyNamedDocument overrides its superclass’s failable init?(name:) initializer with a nonfailable init(name:) initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AutomaticallyNamedDocumentは、それのスーパークラスの失敗できるinit?(name:)イニシャライザを、失敗できないinit(name:)イニシャライザでオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Bicycle subclass defines a custom designated initializer, init().</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Bicycleサブクラスはあつらえの指定イニシャライザ、init()を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The BlackjackCard structure itself has two properties—rank and suit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>BlackjackCard構造体は、２つのプロパティ ― rankとsuitを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Circle class implements the area property requirement as a computed property, based on a stored radius property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Circleクラスはareaプロパティ要件を、保存radiusプロパティに基づいて計算プロパティとして、満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Circle, Country and Animal classes do not have a shared base class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Circle、CountryとAnimalクラスには、共有の基盤クラスがありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Container protocol defines three required capabilities that any container must provide:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Containerプロトコルは、あらゆるコンテナ（容れ物）が提供しなければならない３つの必須の能力を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Counter class also declares a variable property, count, to keep track of the current counter value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Counterクラスはまた、変数プロパティ、countを宣言して、現在のカウンターの値の情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Counter class defines three instance methods:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Counterクラスは、３つのインスタンスメソッドを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Counter class stores its current value in a variable property called count.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Counterクラスは、その現在の値をcountと呼ばれる変数プロパティに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Counter class, defined below, has an optional dataSource property of type CounterDataSource?:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下で定義される、Counterクラスは、型CounterDataSource?のオプショナルのdataSourceプロパティを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CounterDataSource protocol defines an optional method requirement called increment(forCount:) and an optional property requirement called fixedIncrement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CounterDataSourceプロトコルは、incrementForCount(_:)と呼ばれるオプショナルのメソッド要件とfixedIncrementと呼ばれるオプショナルのプロパティ要件を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Customer and CreditCard example shows a situation where one property that is allowed to be nil and another property that cannot be nil have the potential to cause a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CustomerとCreditCardの例は、nilであることを許されるあるプロパティとnilであることができないもう１つのプロパティが強い参照循環を引き起こす可能性をもつ状況を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Customer instance now has a strong reference to the CreditCard instance, and the CreditCard instance has an unowned reference to the Customer instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Customerインスタンスは現在CreditCardインスタンスへの強い参照を持ちます、そして、CreditCardインスタンスはCustomerインスタンスへの非所有者参照を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DataManager class has a stored property called data, which is initialized with a new, empty array of String values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>DataManagerクラスはdataと呼ばれる保存プロパティを持ちます、それは、String値の、新規の、空の配列で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Dice class from earlier can be extended to adopt and conform to TextRepresentable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以前のDiceクラスは、拡張されることで、TextRepresentableを採用して準拠することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DiceGame protocol is a protocol that can be adopted by any game that involves dice.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>DiceGameプロトコルは、さいころが関わるどんなゲームによってでも採用されることができるプロトコルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Food class also provides a convenience initializer, init(), with no arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Foodクラスはまた、引数のない便宜イニシャライザ、init()を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The FullyNamed protocol requires a conforming type to provide a fully-qualified name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>FullyNamedプロトコルは、完全修飾名を提供するある準拠型を要件とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HTMLElement class defines a name property, which indicates the name of the element, such as "h1" for a heading element, "p" for a paragraph element, or "br" for a line break element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>HTMLElementクラスはnameプロパティを定義します、それは、要素の名前を示します、例えばヘッダ要素の"h1"、段落要素のための"p"、またはあるいは、改行のための"br"要素など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HTMLElement class provides a single initializer, which takes a name argument and (if desired) a text argument to initialize a new element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>HTMLElementクラスは一つのイニシャライザを提供します、それは、name引数と（希望する場合には）text引数をとって新しい要素を初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The IntStack type implements all three of the Container protocol’s requirements, and in each case wraps part of the IntStack type’s existing functionality to satisfy these requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IntStack型は、Containerプロトコルの要件の３つすべてを実装します、そしてそれぞれの場合において、これらの要件を満たすためにIntStack型がもつ既存の機能性の一部をラップしています（内部で利用して外側を包む）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The IntStack type shown above can only be used with Int values, however.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、上で示されるIntStack型は、Int値で使われることができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ItemType for C1 must be the same as the ItemType for C2 (written as C1.ItemType == C2.ItemType).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C1のためのItemTypeは、C2のためのItemTypeと同じものでなければなりません（C1.ItemType == C2.ItemTypeのように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ItemType for C1 must conform to the Equatable protocol (written as C1.ItemType: Equatable).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C1のためのItemTypeは、Equatableプロトコルに準拠しなければなりません（C1.ItemType: Equatableのように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The LevelTracker structure is used with the Player class, shown below, to track and update the progress of an individual player:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>LevelTracker構造体はPlayerクラスとともに使用され、下で示されるように、個々のプレーヤーの進捗を追跡して更新します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The LevelTracker structure keeps track of the highest level that any player has unlocked.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>LevelTracker構造体は、プレーヤーのだれかが鍵を開けた最も高いレベルの情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The LevelTracker structure uses type properties and methods to keep track of which levels of the game have been unlocked.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>LevelTracker構造体は、そのゲームのどのレベルが鍵を開けられているかを追跡し続けるために型プロパティとメソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Matrix subscript’s getter and setter both contain an assertion to check that the subscript’s row and column values are valid.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Matrix添え字のゲッターとセッターは両方とも、添え字のもつrowとcolumn値が有効なことを確認するためにひとつの表明を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The NSCopying attribute behaves in a way similar to the Objective-C copy property attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NSCopying属性は、Objective-Cのcopyプロパティ属性に似たやり方でふるまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The NSString length property is now mapped onto Swift’s native String type as utf16Count, not utf16count.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NSStringのlengthプロパティは現在ではスウィフトの生粋のString型とutf16Countとして対応づけられます、utf16countではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Person and Apartment example shows a situation where two properties, both of which are allowed to be nil, have the potential to cause a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>PersonとApartmentの例は、２つのプロパティ、両方ともnilであることを許されるものが強い参照循環を引き起こす可能性をもつ状況を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Person class has an initializer that sets the instance’s name property and prints a message to indicate that initialization is underway.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Personクラスは、インスタンスのnameプロパティを設定して、初期化が進行中であることを示すためにメッセージを出力するイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Person class is defined in the same way as before:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Personクラスは、前の通りに定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Person instance now has a strong reference to the Apartment instance, and the Apartment instance has a strong reference to the Person instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Personインスタンスは現在Apartmentインスタンスへの強い参照を持ちます、そして、ApartmentインスタンスはPersonインスタンスへの強い参照を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Person instance still has a strong reference to the Apartment instance, but the Apartment instance now has a weak reference to the Person instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Personインスタンスは依然としてApartmentインスタンスへの強い参照を持ちます、しかし、Apartmentインスタンスは現在はPersonインスタンスへの弱い参照を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Player class creates a new instance of LevelTracker to track that player’s progress.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Playerクラスは、そのプレーヤーの進捗を追うためにLevelTrackerの新しいインスタンスをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Player class defines a win(coins:) method, which retrieves a certain number of coins from the bank and adds them to the player’s purse.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Playerクラスはwin(coins:)メソッドを定義します、それは、胴元からコインの特定の数を取り戻して、それらをプレーヤーの財布に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Player class describes a player in the game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Playerクラスは、ゲームにおけるプレーヤーを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Point structure above defines a mutating moveBy(x:y:) method, which moves a Point instance by a certain amount.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のPoint構造体は可変のmoveBy(x:y:)メソッドを定義します、それは、Pointインスタンスを特定の量だけ動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The RandomNumberGenerator protocol does not make any assumptions about how each random number will be generated—it simply requires the generator to provide a standard way to generate a new random number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>RandomNumberGeneratorプロトコルは、それぞれの乱数が生成される方法について、全く仮定しません ― それは単に生成器に新しい乱数を生み出す標準の方法を提供することを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Rank enumeration describes the thirteen possible playing card ranks, together with a raw Int value to represent their face value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Rank列挙は、13のあり得るトランプカードの等級を、それらの額面を表す生のInt値と共に記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The RecipeIngredient class has a single designated initializer, init(name: String, quantity: Int), which can be used to populate all of the properties of a new RecipeIngredient instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>RecipeIngredientクラスは、一つの指定イニシャライザ、init(name: String, quantity: Int)を持ちます、それは、新しいRecipeIngredientインスタンスのプロパティの全てに何か入れるために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Rect structure also provides a computed property called center.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Rect構造体はまた、center（中心）と呼ばれる計算プロパティを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Residence class is more complex than before.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Residenceクラスは、前より複雑です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Resolution structure definition and the VideoMode class definition only describe what a Resolution or VideoMode will look like.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Resolution構造体定義とVideoModeクラス定義は、ResolutionまたはVideoModeがどのようなものかについて記述するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Room class used for the rooms array is a simple class with one property called name, and an initializer to set that property to a suitable room name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>rooms配列のために使用されるRoomクラスは、nameと呼ばれる１つのプロパティ、そしてそのプロパティを適切な部屋名に設定するイニシャライザをもつ単純なクラスです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Size structure automatically receives an init(width:height:) memberwise initializer, which you can use to initialize a new Size instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Size構造体は自動的にメンバー関連イニシャライザinit(width:height:)を受け取ります、それは、あなたが新しいSizeインスタンスを初期化するために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SnakesAndLadders class can be extended to adopt and conform to PrettyTextRepresentable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SnakesAndLaddersクラスは、拡張されることでPrettyTextRepresentableを採用して準拠するようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The StepCounter class declares a totalSteps property of type Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>StepCounterクラスは、型IntのtotalStepsプロパティを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Suit enumeration describes the four common playing card suits, together with a raw Character value to represent their symbol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Suit列挙は、トランプの４つの通常のスート（組み札）を、それらの記号を表す生のCharacter値と共に記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TowardsZeroSource class implements the optional increment(forCount:) method from the CounterDataSource protocol and uses the count argument value to work out which direction to count in.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>TowardsZeroSourceクラスは、CounterDataSourceプロトコルからのオプショナルのincrement(forCount:)メソッドを実装して、どの方向に数えるべきか解決するためにcount引数値を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TrackedString structure and the value property do not provide an explicit access-level modifier, and so they both receive the default access level of internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>TrackedString構造体とvalueプロパティは明確なアクセス水準修飾子を提供しません、なので、それらは両方とも省略時のアクセス水準である内部を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The TrackedString structure defines a stored string property called value, with an initial value of "" (an empty string).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>TrackedString構造体は、valueと呼ばれる保存文字列プロパティを、""（空の文字列）の初期値で定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Vehicle base class also defines a method called makeNoise.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Vehicleクラスはまた、makeNoiseと呼ばれるメソッドを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Vehicle class defines common characteristics for an arbitrary vehicle, but is not much use in itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Vehicleクラスは、任意の乗物のためのありふれた特徴を定義します、しかしそれ自体では余り役に立ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Vehicle class provides a default value for its only stored property, and does not provide any custom initializers itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Vehicleクラスは、それの保存プロパティのためにのみ省略時の値を提供します、そしてそれ自身では何らあつらえのイニシャライザを提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The addTwoInts(_:_:) function has the same type as the mathFunction variable, and so this assignment is allowed by Swift’s type-checker.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>addTwoInts(_:_:)関数はmathFunction変数と同じ型を持ちます、なので、この代入はスウィフトの型チェッカーによって認められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The addition and multiplication cases have associated values that are also arithmetic expressions—these associated values make it possible to nest expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>additionとmultiplicationケース節は、それもまた算術式である関連値を持ちます—これらの関連値がそれを入れ子式可能なものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The airports dictionary is declared as a variable (with the var introducer), and not a constant (with the let introducer), because more airports are added to the dictionary in the examples below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>airports辞書は、変数として（var導入子を使って）宣言されます、定数（let導入子を使って）ではなく、なぜならより多くの空港が下記の例でこの辞書に加えられるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The airports dictionary is declared as having a type of [String: String], which means “a Dictionary whose keys are of type String, and whose values are also of type String”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>airports辞書は、[String: String]の型を持つとして宣言されます、それは「キーが型Stringであり、値もまた型StringであるDictionary」を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The airports dictionary is initialized with a dictionary literal containing two key-value pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>airports辞書は、２つの「キーと値」の対を含んでいるひとつの辞書リテラルで初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The allItemsMatch(_:_:) function starts by checking that both containers contain the same number of items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>allItemsMatch(_:_:)関数は、両方のコンテナが同じ数の項目を含むことを確認することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The arch(arm) platform condition does not return true for ARM 64 devices.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>arch(arm)プラットホーム条件は、ARM 64機器に対してtrueを返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as! operator performs a forced cast of the expression to the specified type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>as!演算子は式の指定された型への強制的なキャストを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as! version of the downcast operator forces the downcast to the protocol type and triggers a runtime error if the downcast does not succeed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>as!版のダウンキャスト演算子は、そのプロトコル型へのダウンキャストを強制して、ダウンキャストが成功しなかったならば実行時エラーの引き金を引きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as operator performs a cast when it is known at compile time that the cast always succeeds, such as upcasting or bridging.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>as演算子は、コンパイル時にそのキャストが常に成功することを知られているキャストを実行します、例えばアップキャストやブリッジなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as pattern matches a value if the type of that value at runtime is the same as the type specified in the right-hand side of the as pattern—or a subclass of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>asパターンは、ある値にマッチします、もしその値の実行時での型がasパターンの右側で指定される型 ― または、それの型のサブクラス ― と同じものであるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as? operator performs a conditional cast of the expression to the specified type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>as?演算子は式の指定された型への条件付きキャストを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as? version of the downcast operator returns an optional value of the protocol’s type, and this value is nil if the instance does not conform to that protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>as?版のダウンキャスト演算子は、そのプロトコルの型のオプショナルの値を返します、そしてインスタンスがそのプロトコルに準拠しないならばその値はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The asHTML property is declared as a lazy property, because it is only needed if and when the element actually needs to be rendered as a string value for some HTML output target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>asHTMLプロパティは遅延プロパティとして宣言されます、なぜなら、要素が何らかのHTML出力対象のために実際に文字列値として解釈される必要がもしもあるときのみそれが必要なだけだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The asHTML property is named and used somewhat like an instance method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>asHTMLプロパティは、いくぶんインスタンスメソッドのように名前をつけられて、使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The available attribute always appears with a list of two or more comma-separated attribute arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>available属性は、常に２つ以上のコンマで区切られた属性引数とともに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The block argument is used to indicate an Objective-C compatible block reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>block引数は、あるObjective-C互換プロック参照を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The boardColors array is initialized with a closure to set up its color values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>boardColors配列は、その色値を設定するために、クロージャで初期化されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The break gameLoop statement transfers control to the first line of code outside of the while loop, which ends the game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>break gameLoop文は、制御をwhileループの外側のコードの最初の行へ移します、そしてゲームを終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The break statement ends execution of an entire control flow statement immediately.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>break文は、ある制御の流れに関する文まるまる全体の実行を直ちに終えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The c argument is used to indicate a C function reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>c引数は、C関数参照を示すために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The capitalCity property can be used and accessed like a nonoptional value once initialization is complete, while still avoiding a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>capitalCityプロパティは、一旦初期化が終了しているならば、非オプショナルの値のように使われて、アクセスされることができます、その一方で、依然として強い参照循環を避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The case above has two patterns: (let distance, 0) matches points on the x-axis and (0, let distance) matches points on the y-axis.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のcaseは、２つのパターンを持ちます：(let distance, 0)はx軸上の点にマッチします、そして(0, let distance)はy軸上の点にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The catch clauses don’t have to handle every possible error that the code in its do clause can throw.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>catch節は、それのdo節の中のコードがスロー可能な、すべての起こりうるエラーを処理する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The center property is then set to a new value of (15, 15), which moves the square up and to the right, to the new position shown by the orange square in the diagram below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>centerプロパティは、それから新しい値(15, 15)に設定されます、それは、正方形を上にそして右に、下記の図においてオレンジの正方形によって示される新しい位置へと動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The continue statement tells a loop to stop what it is doing and start again at the beginning of the next iteration through the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>continue文は、あるループにそれがしていることを止めて、そのループの次の繰り返しの始めのところで再び始めるように言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The continue, break, and fallthrough statements are described below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>continue、break、そしてfallthrough文は、以下で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The convention attribute always appears with one of the attribute arguments below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>convention属性は、常に以下の属性引数とともに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The currentLevel property has a didSet property observer to check the value of currentLevel whenever it is set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>currentLevelプロパティはdidSetプロパティオブザーバーを持ち、currentLevelの値をそれが設定されるときはいつでも調べるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The deprecated argument indicates the first version of the specified platform in which the declaration was deprecated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>deprecated引数は、その宣言が非推奨にされたところの、指定されたプラットホームの最初のバージョンを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The didSet clause is optional when you provide a willSet clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがwillSet節を提供するとき、didSet節は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The didSet observer is called after the value of totalSteps is updated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>didSetオブザーバーは、totalStepsの値が更新された後に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The distribute(coins:) method checks that there are enough coins in the bank before distributing them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>distribute(coins:)メソッドは、十分なコインがそれらを配布する前に胴元にあることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The do statement is used to introduce a new scope and can optionally contain one or more catch clauses, which contain patterns that match against defined error conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>do文は、ある新しいスコープを導入するために使われます、そして随意に１つ以上のcatch節を含むことができ、それは定義されたエラー条件にマッチするパターンを複数含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The else clause of a guard statement is required, and must either call a function with the Never return type or transfer program control outside the guard statement’s enclosing scope using one of the following statements:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>guard文のelse節は必ず必要です、そしてNever戻り型を持つ関数を呼び出すか、プログラム制御をguard文の囲むスコープの外側に以下の文のうちの１つを使って移すか、どちらかをする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>fallthroughキーワードは、それが実行を落としていく先のswitchケース節のためのケース節条件を調べません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The favoriteGenres set is declared as a variable (with the var introducer) and not a constant (with the let introducer) because items are added and removed in the examples below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>favoriteGenres集合は、定数（let導入子を使って）ではなく変数として（var導入子を使って）宣言されます、項目が下の例で加えられたり取り除かれたりするためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The favoriteGenres variable is declared as “a set of String values”, written as Set&lt;String&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>favoriteGenres変数は、Set&lt;String&gt;のように書かれ、「String値の集合」として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The findIndex(of:in:) function now compiles successfully and can be used with any type that is Equatable, such as Double or String:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>findIndex(of:in:)関数は、今やうまくコンパイルして、Equatableであるどんな型とでも使われることができます、例えばDoubleやStringなど：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The findIndex(ofString:in:) function can be used to find a string value in an array of strings:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>findIndex(ofString:in:)関数は、文字列の配列の中をある文字列値がないか捜すために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The for-in loop is described in For-In Loops.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>for-inループはfor-inループで記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The gameDidStart(_:) method also accesses the dice property of the passed game parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>gameDidStart(_:)メソッドはまた、渡されたgameパラメータのdiceプロパティにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generator property is of type RandomNumberGenerator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>generatorプロパティは、型RandomNumberGeneratorです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hasPrefix(_:) and hasSuffix(_:) methods perform a character-by-character canonical equivalence comparison between the extended grapheme clusters in each string, as described in String and Character Equality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>hasPrefix(_:)とhasSuffix(_:)は、各文字列の拡張書記素クラスタ間で文字ごとの正準等価比較を実行します、そのことは文字列と文字の同等性で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The if statement can provide an alternative set of statements, known as an else clause, for situations when the if condition is false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文は、代替のひとそろいの文、else節として知られるものをif条件がfalseの場合の状況のために提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The in keyword can also be omitted, because the closure expression is made up entirely of its body:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>inキーワードもまた、クロージャ式がもっぱらその本文から成り立つので、省略されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The increment() method first tries to retrieve an increment amount by looking for an implementation of the increment(forCount:) method on its data source.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>increment()メソッドは、最初にそれのデータ・ソース上でincrement(forCount:)メソッドの実装を捜すことによって増加量を取り出そうと試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The increment() method in the example above could have been written like this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例におけるincrement()メソッドは、このように記述されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The incrementer() function doesn’t have any parameters, and yet it refers to runningTotal and amount from within its function body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>incrementer()関数には全くパラメータがありません、それなのに、それはその関数本文内からrunningTotalとamountに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The init() initializer for Bicycle starts by calling super.init(), which calls the default initializer for the Bicycle class’s superclass, Vehicle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Bicycleのためのinit()イニシャライザは、super.init()を呼ぶことによって始まります、それは、Bicycleクラスのスーパークラス、Vehicleのための省略時のイニシャライザを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The init(center:size:) initializer could have assigned the new values of origin and size to the appropriate properties itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>init(center:size:)イニシャライザは、それ自体でoriginとsizeの新しい値を適切なプロパティに代入することができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The init(name: String) convenience initializer provided by RecipeIngredient takes the same parameters as the init(name: String) designated initializer from Food.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>RecipeIngredientによって提供される便宜イニシャライザinit(name: String)は、Foodからの指定イニシャライザinit(name: String)と同じパラメータを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The init(name: String) initializer from the Food class is provided as a designated initializer, because it ensures that all stored properties of a new Food instance are fully initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Foodクラスからのinit(name: String)イニシャライザは、指定イニシャライザとして提供されます、なぜならそれが新しいFoodインスタンスの全ての保存プロパティが充分に初期化されることを確実にするためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The introduced argument indicates the first version of the specified platform in which the declaration was introduced.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>introduced引数は、そこにおいてその宣言が導入されたところの、指定されたプラットホームの最初のバージョンを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The is operator checks at runtime whether the expression can be cast to the specified type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>is演算子は実行時に式が指定された型へとキャスト可能かどうかを調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The is operator returns true if an instance conforms to a protocol and returns false if it does not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>is演算子は、あるインスタンスがプロトコルに準拠するならばtrueを返して、それがそうしないならばfalseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The is pattern matches a value if the type of that value at runtime is the same as the type specified in the right-hand side of the is pattern—or a subclass of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>isパターンは、ある値にマッチします、もしその値の実行時での型がisパターンの右側で指定される型 ― またはそれの型のサブクラス ― と同じものであるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The john variable now has a strong reference to the new Person instance, and the unit4A variable has a strong reference to the new Apartment instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>john変数は現在新しいPersonインスタンスへの強い参照を持ちます、そしてunit4A変数は新しいApartmentインスタンスへの強い参照を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The makeIncrementer(forIncrement:) function defines an integer variable called runningTotal, to store the current running total of the incrementer that will be returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>makeIncrementer(forIncrement:)関数は、返されるincrementerの現在の状態での合計を保存するために、runningTotalと呼ばれる整数変数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The makeIncrementer(forIncrement:) function has a single Int parameter with an argument label of forIncrement, and a parameter name of amount.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>makeIncrementer(forIncrement:)関数は、forIncrementの引数ラベル、そしてamountのパラメータ名を持つ、ただ１つのIntパラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The makeIterator() method is called on the collection expression to obtain a value of an iterator type—that is, a type that conforms to the IteratorProtocol protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>makeIterator()メソッドがcollection（コレクション）式の上で呼ばれて、イテレータ型 ― すなわち、IteratorProtocolプロトコルに準拠する型、に属する１つの値を取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The map(_:) method calls the closure expression once for each item in the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>map(_:)メソッドは、配列の中の各項目に対して一度だけクロージャ式を呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The message argument is used to provide a textual message that’s displayed by the compiler when emitting a warning or error about the use of a deprecated or obsoleted declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>message引数は、非推奨または廃止された宣言の使用について警告やエラーを発するときにコンパイラによって表示されるテキストメッセージを提供するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The minMax(array:) function above returns a tuple containing two Int values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のminMax(array:)関数は、２つのInt値を含んでいるタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The minMax(array:) function returns a tuple containing two Int values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>minMax(array:)関数は、２つのInt値を含んでいる１つのタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number property of the CreditCard class is defined with a type of UInt64 rather than Int, to ensure that the number property’s capacity is large enough to store a 16-digit card number on both 32-bit and 64-bit systems.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CreditCardクラスのnumberプロパティは、UInt64の型で定義されます、Intではなく、それによってnumberプロパティの容量が32bitと64bitシステムの両方で16桁のカード番号を格納するのに十分に大きいことを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number variable is then divided by 10.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>number変数は、それから10で割られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The objc attribute optionally accepts a single attribute argument, which consists of an identifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>objc属性は、任意にただ１つだけ属性引数を受け入れます、それはひとつの識別子から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The objc attribute tells the compiler that a declaration is available to use in Objective-C code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>objc属性は、コンパイラにある宣言がObjective-Cコードにおいて使われることが可能であるのを伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The objects array can now be iterated, and each object in the array can be checked to see if it conforms to the HasArea protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>objects配列は、今や繰り返されることができます、そして配列の各オブジェクトはそれがHasAreaプロトコルに従うかどうかを確認されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The objects array is initialized with an array literal containing a Circle instance with a radius of 2 units; a Country instance initialized with the surface area of the United Kingdom in square kilometers; and an Animal instance with four legs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>objects配列は、単位２の半径をもつCircleインスタンスを含んでいる配列リテラル；平方キロメートルでの英国の面積で初期化されるCountryインスタンス；そして、４本脚のAnimalインスタンス；を含んでいる配列リテラルで初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The obsoleted argument indicates the first version of the specified platform in which the declaration was obsoleted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>obsoleted引数は、その宣言が廃止されたところの、指定されたプラットホームの最初のバージョンを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The override keyword also prompts the Swift compiler to check that your overriding class’s superclass (or one of its parents) has a declaration that matches the one you provided for the override.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>overrideキーワードはまた、あなたのオーバーライドしているクラスのスーパークラス（またはその親のうちの１つ）が、そのオーバーライドのためにあなたが提供するものと合致する宣言を持っていることを確認するように、スウィフトのコンパイラを促します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The paragraph variable above is defined as an optional HTMLElement, so that it can be set to nil below to demonstrate the presence of a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記のparagraph変数は、オプショナルのHTMLElementとして定義されます、それでそれは下で強い参照循環の存在を例示するためにnilに設定されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The possibleIntegerValue variable has an implicit initial value of nil by virtue of being an optional type, and so the optional binding will succeed only if possibleIntegerValue was set to an actual value by one of the switch statement’s first four cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>possibleIntegerValue変数は、オプショナル型であることの長所によって暗黙的にnilの初期値を持ちます、そのためpossibleIntegerValueがswitch文の最初の４つのケース節の１つによって実際の値に設定される場合にだけ、このオプショナル束縛は成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The prettyTextualDescription property can now be used to print a pretty text description of any SnakesAndLadders instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このprettyTextualDescriptionプロパティは、現在あらゆるSnakesAndLaddersインスタンスのきれいなテキスト解説を出力するために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The print(_:separator:terminator:) function doesn’t have a label for its first argument, and its other arguments are optional because they have a default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>print(_:separator:terminator:)関数は、それの最初の引数に対してラベルを持ちません、そしてそれの他の引数は任意です、それらが省略時の値を持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The print(_:separator:terminator:) function is a global function that prints one or more values to an appropriate output.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>print(_:separator:terminator:)関数は、ひとつ以上の値を適切な出力先に出力するグローバルな関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The printNumberOfRooms() method on the Residence class prints the current value of numberOfRooms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Residenceクラス上のprintNumberOfRooms()メソッドは、numberOfRoomsの現在の値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The receive(coins:) method simply adds the received number of coins back into the bank’s coin store.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>receive(coins:)メソッドは、単純に受け取ったコインの数を胴元のコインの蓄えに戻すよう加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The renamed argument is used to provide a textual message that indicates the new name for a declaration that’s been renamed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>renamed引数は、改名された宣言の新しい名前を指し示すテキストメッセージを提供するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The repeat-while loop in Swift is analogous to a do-while loop in other languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのrepeat-whileループは、他の言語のdo-whileループと類似したものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The repetitions(task:) method takes a single argument of type () -&gt; Void, which indicates a function that has no parameters and does not return a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>repetitions(task:)メソッドは型() -&gt; Voidの引数をひとつだけとります、それは、パラメータを持たず、値を返さない関数であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The self expression is an explicit reference to the current type or instance of the type in which it occurs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>self式は、それがその中に現れているところの現在の型や型のインスタンスへの明確な参照です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The self expression is used to specify scope when accessing members, providing disambiguation when there is another variable of the same name in scope, such as a function parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>self式は、メンバーにアクセスする時にスコープを指定するために使われて、関数パラメータなど、同じ名前の別の変数がスコープ内にある場合に一義化を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The serve(customer:) function in the listing above takes an explicit closure that returns a customer’s name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で記載されるserve(customer:)関数は、次の顧客の名前を返す、ある明示的なクロージャを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The shoppingList array is declared as a variable (with the var introducer) and not a constant (with the let introducer) because more items are added to the shopping list in the examples below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>shoppingList配列は、変数として（var導入子を使って）宣言されます、定数（let導入子を使って）ではなく、なぜならより多くの項目が下記の例で購入品目リストに加えられるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The shoppingList variable is declared as “an array of string values”, written as [String].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>shoppingList変数は、「String値の配列」として宣言され、[String]のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The someFunctionWithEscapingClosure(_:) function takes a closure as its argument and adds it to an array that’s declared outside the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>someFunctionWithEscapingClosure(_:)関数は、クロージャをそれの引数として取ります、そしてそれを関数の外側で宣言される配列に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sorted(by:) method accepts a closure that takes two arguments of the same type as the array’s contents, and returns a Bool value to say whether the first value should appear before or after the second value once the values are sorted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>sorted(by:)メソッドは、配列の内容物と同じ型の２つの引数をとり、そしてひとたび値が分類されるならば最初の値が第２の値の前か後のどちらに現れなければならないのかを伝えるBool値を返すクロージャを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sorted(by:) method is being called on an array of strings, so its argument must be a function of type (String, String) -&gt; Bool.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このsorted(by:)メソッドは文字列の配列上で呼ばれています、それでそれの引数は型(String, String) -&gt; Boolの関数でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The square variable’s center property is then accessed through dot syntax (square.center), which causes the getter for center to be called, to retrieve the current property value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>square変数のcenterプロパティは、それからドット構文（square.center）を通してアクセスされます、それによってcenterのためのゲッターが呼び出されて、現在のプロパティ値を取り出すことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The swapTwoInts(_:_:) function is useful, but it can only be used with Int values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>swapTwoInts(_:_:)関数は役に立ちます、しかし、それはInt値で使われることができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The swapTwoInts(_:_:) function simply swaps the value of b into a, and the value of a into b.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>swapTwoInts(_:_:)関数は、単にbの値をaの中に、そしてaの値をbの中へと入れ替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The swapTwoInts(_:_:) function swaps the original value of b into a, and the original value of a into b.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>swapTwoInts(_:_:)関数は、bの元々の値をaの中へ、そしてaの元々の値をbの中へと交換します、そして、最初の値のにb。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The swapTwoInts example above does not define a return type or return a value, but it still modifies the values of someInt and anotherInt.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のswapTwoInts例は、戻り型を定義しないし、また値を返しません、しかしそれでもそれはsomeIntとanotherIntの値を修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The swapTwoValues(_:_:) function and the Stack type can work with any type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>swapTwoValues(_:_:)関数とStack型は、どんな型でも扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The swapTwoValues(_:_:) function can now be called in the same way as swapTwoInts, except that it can be passed two values of any type, as long as both of those values are of the same type as each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>swapTwoValues(_:_:)関数は現在swapTwoIntsと同じやり方で呼ばれることができます、しかしそれがあらゆる型の２つの値を渡されることが、それらの値の両方が互いに同じ型である限り可能であるのを除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The swapTwoValues(_:_:) function defined above is inspired by a generic function called swap, which is part of the Swift standard library, and is automatically made available for you to use in your apps.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で定義されるswapTwoValues(_:_:)関数はswapと呼ばれる総称体関数に着想を得たものです、それは、スウィフト標準ライブラリの一部であって、あなたのアプリにおいて自動的にあなたが使うことが可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The swift argument is used to indicate a Swift function reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>swift引数は、スウィフト関数参照を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The switch statement determines whether the point is at the origin (0, 0), on the red x-axis, on the orange y-axis, inside the blue 4-by-4 box centered on the origin, or outside of the box.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このswitch文は、そのポイントがあるのは、原点(0, 0)、赤いx-軸上、オレンジのy-軸上、原点を中心とした青の４×４の四角の内側、または四角の外側かどうかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The switch statement determines whether the point is on the green diagonal line where x == y, on the purple diagonal line where x == -y, or neither.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このswitch文は、そのポイントが、x == yであるところの緑の斜線上、あるいはx == -yであるところの紫の斜線上にあるかどうかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The switch statement determines whether the point is on the red x-axis, on the orange y-axis, or elsewhere (on neither axis).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このswitch文は、この地点が、赤のx-軸上、オレンジのy-軸上、または他のどこか（どちらの軸上でもない）かを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The switch statement’s first case matches all five lowercase vowels in the English language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文の最初のケース節は、英語における５つの小文字の母音字すべてにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The switch statement’s first case matches the first letter of the English alphabet, a, and its second case matches the last letter, z.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文の最初のケース節は、英語アルファペットの最初の文字、aにマッチします、そしてそれの２番目のケース節は最後の文字、zにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The textualDescription property returns the textual description of the entire collection by concatenating the textual representation of each element in the collection into a comma-separated list, enclosed in brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>textualDescriptionプロパティは、コレクション全体の解説テキストを、コレクションの中の各要素のテキスト表現をコンマ区切りのリストへと連結して、角括弧に囲むことによって返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The things array contains two Int values, two Double values, a String value, a tuple of type (Double, Double), the movie “Ghostbusters”, and a closure expression that takes a String value and returns another String value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>things配列は、２つのInt値、２つのDouble値、１つのString値、型(Double, Double)のタプル、映画「ゴーストバスターズ」、そしてString値をとって別のString値を返す一つのクロージャ式を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The throws keyword is part of a function’s type, and nonthrowing functions are subtypes of throwing functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>throwsキーワードは関数の型の一部です、そしてスローを行わない関数はスロー関数の下位型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The toggle() method is marked with the mutating keyword as part of the Togglable protocol definition, to indicate that the method is expected to mutate the state of a conforming instance when it is called:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>toggle()メソッドは、Togglableプロトコル定義の一部としてmutatingキーワードで印されます、それによってそのメソッドが、それが呼ばれるとき準拠インスタンスの状態を変化させることを予期されるようにします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The topItem computed property can now be used with any Stack instance to access and query its top item without removing it:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>topItem計算プロパティは、今やあらゆるStackインスタンスで、それの一番上の項目にそれを取り除くことなくアクセスおよび問い合わせるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The topItem property returns an optional value of type Element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>topItemプロパティは型Elementのオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unavailable argument indicates that the declaration isn’t available on the specified platform.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>unavailable引数は、その宣言が指定されたプラットホーム上で利用可能でないことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The updateValue(_:forKey:) method returns an optional value of the dictionary’s value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>updateValue(_:forKey:)メソッドは、その辞書の値型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The userDefinedColorName variable is defined as an optional String, with a default value of nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>userDefinedColorName変数は、省略時の値のnilを持つ、あるオプショナルのStringとして定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value properties for the first three UnicodeScalar values (68, 111, 103) once again represent the characters D, o, and g.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の３つのUnicodeScalar値（68、111、103）のためのvalueプロパティは、またふたたび文字D、o、そしてgを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value property of the fifth and final UnicodeScalar, 128054, is a decimal equivalent of the hexadecimal value 1F436, which represents the Unicode scalar U+1F436 for the DOG FACE character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>５番目で最後のUnicodeScalarのvalueプロパティ、128054は、16進の値1F436の10進の等価物です、そしてそれは、DOG FACE文字のためのユニコード・スカラーU+1F436を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The welcomeMessage variable can now be set to any string value without error:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>welcomeMessage変数は、現在エラーなしでどんな文字列値にでも設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The while loop’s condition is while square != finalSquare, to reflect that you must land exactly on square 25.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>whileループの条件は、あなたが正確に正方形25に到着しなければならないことを反映する、while square != finalSquareです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The willSet and didSet observers for totalSteps are called whenever the property is assigned a new value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>totalStepsのためのwillSetとdidSetオブザーバーは、プロパティが新しい値を代入されるときはいつでも呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The willSet and didSet observers of superclass properties are called when a property is set in a subclass initializer, after the superclass initializer has been called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスプロパティのwillSetとdidSetオブザーバーは、スーパークラスイニシャライザが呼び出され終わった後、あるプロパティがサプクラスのイニシャライザにおいて設定される時に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The willSet and didSet observers provide a way to observe (and to respond appropriately) when the value of a variable or property is being set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>willSetとdidSetオブザーバーは、変数またはプロパティの値が設定されている時に監視する（そして適切に応答する）方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The wiseWords constant contains two escaped double quote characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数のwiseWordsは、２つのエスケープされた二重引用符文字を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The COMBINING ACUTE ACCENT scalar is graphically applied to the scalar that precedes it, turning an e into an é when it is rendered by a Unicode-aware text-rendering system.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>COMBINING ACUTE ACCENTスカラーは、それの前のスカラーに追加筆記され、eを、それがユニコードに通じたテキスト描画システムによって表わされる時に、éにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name property is automatically given a default value of nil, or “no name value”, because it is of an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>nameプロパティは省略時の値のnil、つまり「name値なし」を自動的に与えられます、なぜならそれがオプショナル型であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The BlackJack structure contains two nested enumeration types called Suit and Rank.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>BlackJack構造体は、SuitとRankと呼ばれる２つの入れ子にされた列挙型を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Celsius structure implements two custom initializers called init(fromFahrenheit:) and init(fromKelvin:), which initialize a new instance of the structure with a value from a different temperature scale:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Celsius構造体は、init(fromFahrenheit:)とinit(fromKelvin:)と呼ばれる２つのあつらえのイニシャライザを実装します、それは、その構造体の新しいインスタンスを異なる温度尺度の値を使って初期化します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Container protocol needs to specify that any value passed to the append(_:) method must have the same type as the container’s element type, and that the value returned by the container’s subscript will be of the same type as the container’s element type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Containerプロトコルは、append(_:)メソッドに渡されるあらゆる値がそのコンテナの要素の型と同じ型を持たなければならないこと、そしてコンテナの添え字によって返される値がコンテナの要素型と同じ型のものになることを指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DiceGameDelegate protocol can be adopted by any type to track the progress of a DiceGame.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>DiceGameDelegateプロトコルは、どんな型によってでも採用されることができて、あるDiceGameの進歩を追いかけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Fahrenheit structure has one stored property, temperature, which is of type Double:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Fahrenheit構造体は、１つの保存プロパティ、temperatureを持ちます、それはDouble型です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Food class introduces a single String property called name and provides two initializers for creating Food instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Foodクラスは、nameと呼ばれる一つのStringプロパティを導入して、２つのイニシャライザをFoodインスタンスをつくるために提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Point example shown above could have been written in the following way instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で示されるPointの例は、その代わりに以下のようにして書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The break statement can be used inside a switch statement or loop statement when you want to terminate the execution of the switch or loop statement earlier than would otherwise be the case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>break文は、これを使わなかった場合よりも早くswitchまたはループ文の実行をあなたが終了したい時に、switch文またはループ文の内側で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class keyword must always appear first in a protocol’s inheritance list, before any inherited protocols:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このclassキーワードは、常にプロトコルの継承リストの最初、あらゆる継承プロトコルの前に現れなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The continue gameLoop statement ends the current while loop iteration and begins the next iteration of the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>continue gameLoop文は、現在のwhileループ繰り返しを終えて、ループの次の繰り返しを開始します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dollarSign, blackHeart, and sparklingHeart constants demonstrate the Unicode scalar format:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>dollarSign、blackHeart、そしてsparklingHeart定数は、Unicodeスカラーの書式を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The grid array for this Matrix instance is effectively a flattened version of the matrix, as read from top left to bottom right:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このMatrixインスタンスのためのgrid配列は、実際にはこのMatrix 行列の、左上から右下へと読まれる、平らにされた改変板です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The let keyword is only used for constant properties, to indicate that their values cannot be changed once they are set as part of instance initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>letキーワードは定数プロパティのためにだけ使われます、そして一旦それがインスタンス初期化の一部として設定されるならば、その値が変わることができないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nonobjc attribute tells the compiler to make the declaration unavailable in Objective-C code, even though it is possible to represent it in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>nonobjc属性は、コンパイラにその宣言がObjective-Cコードにおいて利用不可にされることを伝えます、たとえそれがObjective-Cで表現可能であってもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional modifier can be applied only to members that are marked with the objc attribute, and only to members of protocols that are marked with the objc attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>optional修飾子は、objc属性で印されるメンバにだけ、そしてobjc属性で印されるプロトコルのメンバにだけ適用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The @escaping attribute is described above in Escaping Closures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@escaping属性は、上の脱出クロージャで解説されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The AutomaticCar class represents a car with an automatic gearbox, which automatically selects an appropriate gear to use based on the current speed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AutomaticCarクラスはオートマチック・ギアボックスをもつ車を表します、それは、現在の速度に基づいて自動的に使用するのに適切なギアを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The AutomaticallyNamedDocument subclass overrides both of the designated initializers introduced by Document.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AutomaticallyNamedDocumentサブクラスは、Documentで導入される指定イニシャライザを両方ともオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Bank class manages a made-up currency, which can never have more than 10,000 coins in circulation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Bankクラスは、ある架空の通貨を管理します、そしてそれは、流通する10,000個以上のコインを決して持つことができません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Car class introduces a new stored property called gear, with a default integer value of 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Carクラスは、gearと呼ばれる、1の省略時の値を持つ、新しい保存プロパティを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CartItem class models an item in an online shopping cart.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CartItemクラスは、あるオンライン買物かごの中のひとつの項目をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Counter class also defines a method called increment, which increments the count property every time the method is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Counterクラスはまた、incrementと呼ばれるメソッドを定義します、それは、メソッドが呼ばれるたびにcountプロパティを増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Matrix structure’s subscript takes two integer parameters:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Matrix構造体の添え字は、２つの整数パラメータをとります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Person class also has a deinitializer that prints a message when an instance of the class is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Personクラスはまた、クラスのインスタンスが割り当て解除されるとき、メッセージを出力するデイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Player class also implements a deinitializer, which is called just before a Player instance is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Playerクラスはまた、デイニシャライザを実装します、それはPlayerインスタンスが割り当て解除される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The RecipeIngredient class models an ingredient in a cooking recipe.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>RecipeIngredientクラスは、料理のレシピの材料をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ShoppingListItem class models a recipe ingredient as it appears in a shopping list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ShoppingListItemクラスは、それが購入品目リストに現れるように、レシピの材料をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Values structure defines two properties to represent this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Values構造体は、これを表すために２つのプロパティを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The a in the inner scope is initialized with the value of the a in the outer scope when the closure is created, but their values are not connected in any special way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>内側のスコープの中のaは、クロージャが作成される時に外側のスコープの中のaの値で初期化されます、しかしそれらの値は何ら特別な方法で結びつけられません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The arch(i386) platform condition returns true when code is compiled for the 32–bit iOS simulator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>arch(i386)プラットホーム条件は、コードが32ビットiOSシミュレーターに対してコンパイルされるときtrueを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The chooseStepFunction(backward:) function returns the stepForward(_:) function or the stepBackward(_:) function based on a Boolean parameter called backward:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>chooseStepFunction(backward:)はstepForward(_:)関数あるいはstepBackward(_:)関数を、backwardと呼ばれるブールのパラメータに基づいて返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>fallthroughキーワードは、Cの標準のswitch文の挙動でのように、単に次のケース節（またはdefaultケース節）ブロックの中の文へ、コード実行を直接に移すことを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The game parameter has a type of DiceGame, not SnakesAndLadders, and so gameDidStart(_:) can access and use only methods and properties that are implemented as part of the DiceGame protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>gameパラメータは、型DiceGameを持ちます、SnakesAndLaddersではありません、なので、gameDidStart(_:)はDiceGameプロトコルの一部として実施されるメソッドとプロパティだけにアクセスして使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The increment() method uses optional chaining to try to call increment(forCount:), and passes the current count value as the method’s single argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>increment()メソッドは、オプショナル連鎖を使ってincrement(forCount:)を呼ぶことを試みます、そしてメソッドのもつただ１つの引数として現在のcount値を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The is pattern appears only in switch statement case labels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>isパターンは、switch文のケース節ラベルだけで見かけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The is pattern behaves like the is operator in that they both perform a type cast but discard the returned type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>isパターンは、それらが両方とも型キャストを実行するが返された型を捨てるという点において、is演算子のようにふるまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lowerThan precedence group attribute may only be used to refer to precedence groups declared outside of the current module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>lowerThan優先順位グループ属性は、現在のモジュールの外側で宣言される優先順位グループを参照するのに使われるだけでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mutating keyword is only used by structures and enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>mutatingキーワードは、構造体と列挙によって使われるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The separator and terminator parameter have default values, so you can omit them when you call this function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>separatorとterminatorパラメータは省略時の値を持ちます、それであなたはそれらを省略することが、この関数をあなたが呼び出す時に可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The someContainer argument is of type C1, and the anotherContainer argument is of type C2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>someContainer引数は型C1です、そしてanotherContainer引数は型C2です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The square variable is initialized with an origin point of (0, 0), and a width and height of 10.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>square変数は、(0, 0)の原点、そして10の幅と高さで初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stepForward(_:) function returns a value one more than its input value, and the stepBackward(_:) function returns a value one less than its input value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>stepForward(_:)関数は、その入力された値より１大きい値を返します、そしてstepBackward(_:)関数はその入力された値より１小さい値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The switch statement determines which branch should be selected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文は、どの分岐が選ばれるべきか決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The throws keyword is part of a function’s type, and nonthrowing functions are subtypes of throwing functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>throwsキーワードは関数の型の一部です、そしてスローを行わない関数はスロー関数の下位型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The while loop has a statement label called gameLoop to indicate that it is the main game loop for the Snakes and Ladders game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>whileループは、gameLoopと呼ばれる文ラベルを持ち、それが「ヘビとはしご」ゲームのための主なゲーム・ループであることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Address class type for this property is defined below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロパティのためのAddressクラス型は、下で定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Animal structure also defines a failable initializer with a single parameter called species.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Animal構造体はまた、speciesと呼ばれるただ一つのパラメータを持つ、失敗できるイニシャライザを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Country class implements the area requirement directly as a stored property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Countryクラスは、area要件を保存プロパティとして直接に満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Equatable protocol requires any conforming implementation of == to be an equivalence relation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Equatableプロトコルは、==のどんな準拠実装もひとつの同等性関係であることを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Tandem subclass also adds a new stored property called currentNumberOfPassengers, with a default value of 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Tandemサブクラスはまた、currentNumberOfPassengersと呼ばれる新しい保存プロパティを、0の省略時の値を使って追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as! operator returns a value of the specified type, not an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>as!演算子は指定された型の値を返します、オプショナル型ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as? operator returns an optional of the specified type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>as?演算子は、指定された型のオプショナルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The didSet observer does not provide a custom parameter name for the old value, and the default name of oldValue is used instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>didSetオブザーバーはあつらえのパラメータ名を古い値のために用意しません、そして省略時の名前のoldValueがその代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The didSet observer is called immediately after the new value is set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>didSetオブザーバーは、新しい値が設定された直後に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The endIndex property is the position after the last character in a String.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>endIndexプロパティは、あるStringの最後の文字の後の位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The findIndex(ofString:in:) function returns an optional Int value, which will be the index of the first matching string in the array if it is found, or nil if the string cannot be found:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>findIndex(ofString:in:)関数は、オプショナルのInt値を返します、それは、それが見つけられるならば配列での最初の合致している文字列のインデックスです、または文字列が見つけられることができないならばnilです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The init() initializer provides a default placeholder name for a new food by delegating across to the Food class’s init(name: String) with a name value of [Unnamed]:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>init()イニシャライザは、Foodクラスのinit(name: String)に[Unnamed]のname値を使って横に委任することで、省略時のプレースホルダ名を新しい食物のために用意します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mutating keyword is added to its definition to enable it to modify its properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>mutatingキーワードがその定義に加えられ、それにそのプロパティを修正するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The objectWithArea constant is known to be of type HasArea, and so its area property can be accessed and printed in a type-safe way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数のobjectWithAreaは、型HasAreaであるということを知られています、なので、そのareaプロパティは型安全な方法でアクセスされて出力されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return statement is described in Functions, and the throw statement is described in Propagating Errors Using Throwing Functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>return文は関数において、そしてthrow文はスロー関数を使ってエラーを伝えるにおいて記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The switch statement is better suited to more complex conditions with multiple possible permutations and is useful in situations where pattern matching can help select an appropriate code branch to execute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文は、複数の可能な起こりうる組み合わせを伴うさらに複雑な状況によりよく適します、そして、パターンマッチングが適切なコード分岐を選択して実行する助けとなり得る状況において役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The * argument is required and specifies that on any other platform, the body of the code block guarded by the availability condition executes on the minimum deployment target specified by your target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>*引数は必須であらゆる他のプラットホーム上を指定します、有効性条件によって保護されたコード・ブロックの本文はあなたのターゲットによって指定される最小の開発ターゲット上で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Car class’s version of description then adds some extra text onto the end of this description to provide information about the current gear.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Carクラス版のdescriptionは、それからこの説明の最後に現在のギアーについての情報を提供するために追加のテキストを加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Dictionary type uses an optional subscript type to model the fact that not every key will have a value, and to give a way to delete a value for a key by assigning a nil value for that key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Dictionary型は、すべてのキーに値があるというわけでないという事実をモデル化するために、そしてあるキーに対する値を削除する方法をそのキーに対してnilの値を代入することで提供するために、オプショナルの添え字型を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Food class does not have a superclass, and so the init(name: String) initializer does not need to call super.init() to complete its initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Foodクラスには、スーパークラスがありません、なので、init(name: String)イニシャライザはその初期化を完了するためにsuper.init()を呼ぶ必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The advance(to:) method returns a Boolean value to indicate whether or not it was actually able to set currentLevel.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>advance(to:)メソッドは、それが実際にcurrentLevelを設定することができたかどうか示すためにブールの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The asHTML property is of type () -&gt; String, or “a function that takes no parameters, and returns a String value”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>asHTMLプロパティは型() -&gt; Stringです、あるいは「パラメータをとらなくて、String値を返す関数」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The currentSpeed property’s value is used by a read-only computed String property called description to create a description of the vehicle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>currentSpeedプロパティの値は、descriptionと呼ばれる読み込み専用の計算Stringプロパティによってその乗り物の解説を作成するために使用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fullName property uses the prefix value if it exists, and prepends it to the beginning of name to create a full name for the starship.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>fullNameプロパティは、prefix値を、それが存在するならば使います、そしてそれをnameの始めに付けて、その宇宙船の完全な名前をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The is and as patterns have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>isとasパターンは以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The numberOfWheels property is used by a computed property called description to create a String description of the vehicle’s characteristics:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>numberOfWheelsプロパティはdescriptionと呼ばれる計算プロパティによって使用されて、この乗り物の特徴のあるStringの解説を作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Car class also overrides the description property it inherits from Vehicle, to provide a custom description that includes the current gear:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Carクラスはまた、それがVehicleから継承するdescriptionプロパティをオーバーライドして、現在のギアーを示すあつらえの説明を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The apartment property is optional, because a person may not always have an apartment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>人は必ずしもアパートを持つわけではないので、apartmentプロパティはオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The makeIncrementer function defines a nested function called incrementer, which performs the actual incrementing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>makeIncrementer関数はincrementerと呼ばれる入れ子にされた関数を定義します、それは、実際に増やすことを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The switch case matches the current value of point only if the where clause’s condition evaluates to true for that value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このswitchケース節は、pointの現在の値に、where節の条件がtrueに評価する場合にのみ適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The description property uses optional binding to check whether there is a second value to display, and if so, inserts additional description detail for that second value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>descriptionプロパティは、オプショナル束縛を使って、表示する第２の値があるかどうか調べます、そしてもしそうなら、その第２の値に関する追加の記述詳細を差し込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fixedIncrement property is also an optional requirement, so its value is an optional Int value, even though fixedIncrement is defined as a nonoptional Int property as part of the CounterDataSource protocol definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>fixedIncrementプロパティもまたオプショナルの要件です、なのでその値はオプショナルのInt値です、たとえfixedIncrementがCounterDataSourceプロトコル定義の部分では非オプショナルのIntプロパティであると定義されるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Country initializer can therefore pass self as one of the parameters for the City initializer when the Country initializer is setting its own capitalCity property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Countryイニシャライザはしたがって、selfをCityイニシャライザのパラメータの１つとして渡すことが、Countryイニシャライザが自身のcapitalCityプロパティを設定しているときに可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default case adds some extra text to the end of the description, and the switch statement is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>defaultケース節はこの解説（description）の終わりに追加の若干のテキストを加えます、そしてswitch文は終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Snakes and Ladders game board setup takes place within the class’s init() initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ヘビとはしごゲーム盤設定は、このクラスのinit()イニシャライザ内で行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignment operator (a = b) initializes or updates the value of a with the value of b:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代入演算子（a = b）は、aの値をbの値で初期化または更新します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignment operator sets a new value for a given expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代入演算子は、指定された式に対してある新しい値を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignment of a precedence group specifies the precedence of an operator when used in an operation that includes optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある優先順位グループのassignmentは、オプショナル連鎖を含む演算において使われる場合はある演算子の優先順位を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The associativity of an operator specifies how a sequence of operators with the same precedence level are grouped together in the absence of grouping parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子の結合性は、グループ括弧がない場合に同じ優先順位レベルを持つひと連なりの演算子がどのようにまとめられるかを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise AND operator (&amp;) combines the bits of two numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理積演算子（&amp;）は、２つの数のビットを結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise NOT operator (~) inverts all bits in a number:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理否定演算子（~）は、ある数の中の全てのビットを逆にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise OR operator (|) compares the bits of two numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理和演算子（|）は、２つの数のビットを比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise XOR operator, or “exclusive OR operator” (^), compares the bits of two numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の排他的論理和（XOR）演算子、あるいは「排他的論理和演算子」（^）は、２つの数のビットを比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise left shift operator (&lt;&lt;) and bitwise right shift operator (&gt;&gt;) move all bits in a number to the left or the right by a certain number of places, according to the rules defined below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の左シフト演算子（&lt;&lt;）とビット単位の右シフト演算子（&gt;&gt;）は、下で定義される規則に従ってある数の中の全てのビットを左または右に特定の桁数だけ移動します。（シフト：移す、ずらす）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closed range operator (a...b) defines a range that runs from a to b, and includes the values a and b.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>完結範囲演算子（a...b）は、aからbまで続く範囲を定義します、それはaとbの値を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compilation condition can include the true and false Boolean literals, an identifier used with the -D command line flag, or any of the platform conditions listed in the table below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>compilation conditionは、trueとfalseのブールのリテラル、-Dコマンドラインフラグと共に使われる識別子、もしくは以下の表で列記されるプラットホーム条件を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The condition is evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件が評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The constraint specifies that a type parameter inherits from a specific class or conforms to a protocol or protocol composition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制約は、型パラメータが特定のクラスから継承する、もしくはあるプロトコルまたはプロトコル合成に準拠することを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The control expression of the switch statement is evaluated and then compared with the patterns specified in each case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文の制御式は、評価されて、それからそれぞれのケース節（case）で指定されるパターンと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression can’t be the name of a type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式は、型の名前であることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fixity of an operator specifies the relative position of an operator to its operands.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子の定着性は、その演算子の演算数に対する相対位置を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function name can be any expression whose value is of a function type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数名は、値がその関数型であるどんな式でもかまいません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generic argument list is a comma-separated list of type arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体引数リストは、型引数のコンマで区切られたリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generic parameter list is a comma-separated list of generic parameters, each of which has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体パラメータリストは、コンマで区切られた総称体パラメータのリストです、そしてそのそれぞれは以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The half-open range operator (a..&lt;b) defines a range that runs from a to b, but does not include b.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>半開範囲演算子（a..&lt;b）は、aからbまで続く範囲を定義します、しかしbの値を含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lexical structure of Swift describes what sequence of characters form valid tokens of the language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの語彙の構造は、どんな文字の連なりがこの言語の公式のトークン（個々の語、最少単位の語）を作り上げるかについて述べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The logical AND operator (a &amp;&amp; b) creates logical expressions where both values must be true for the overall expression to also be true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理積演算子（a &amp;&amp; b）は、論理式をつくります、そこにおいて全体的な式もまたtrueになるためには、両方の値がtrueでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The logical NOT operator (!a) inverts a Boolean value so that true becomes false, and false becomes true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理否定演算子（!a）は１つのブール値を逆にします、それでtrueはfalseに、falseはtrueになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The logical OR operator (a || b) is an infix operator made from two adjacent pipe characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理和演算子（a || b）は、２つの隣接したパイプ文字から作られる接中辞演算子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lower group names and higher group names lists specify the new precedence group’s relation to existing precedence groups.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下方グループ名および上方グループ名リストは、新しい優先順位グループのもつ関係を既存の優先順位グループに対して指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The message consists of a string literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>messageは、文字列リテラルから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method name and property name must be a reference to a method or a property that is available in the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>method nameとproperty nameは、あるメソッドおよびプロパティへの参照で、それはObjective-Cランタイムにおいて利用可能なものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method name can contain parentheses for grouping, as well the as operator to disambiguate between methods that share a name but have different type signatures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>method nameは、グループにまとめるための丸括弧、その上に、名前を共有するが異なる型シグネチャを持つメソッド間の違いを明確にするためにas演算子を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new name consists of a string literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい名前は文字列リテラルからなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nil-coalescing operator (a ?? b) unwraps an optional a if it contains a value, or returns a default value b if a is nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>nil合体演算子（a ?? b）は、それが値を持つならばオプショナルのaをアンラップします、またはaがnilならば省略時の値のbを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parameter type is comma-separated list of types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>parameter typeコンマ区切りの型のリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parameters have the same form as the parameters in a function declaration, as described in Function Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータは、関数宣言で記述されるように、関数宣言でのパラメータと同じ形式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parameters in closure expression syntax can be in-out parameters, but they can’t have a default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式構文中のparametersはin-outパラメータであることができます、しかしそれらは省略時の値を持つことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parameters specify one or more indexes used to access elements of the corresponding type in a subscript expression (for example, the i in the expression object[i]).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータは、対応する型の要素にアクセスするために添え字式において使用する一種類以上のインデックスを指定します（例えば、式object[i]におけるiなど）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The property name must be a reference to a property that is available in the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>property nameは、Objective-Cランタイムにおいて利用可能であるプロパティへの参照でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remainder operator (a % b) works out how many multiples of b will fit inside a and returns the value that is left over (known as the remainder).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>剰余演算子（a % b）は、どのくらい多くのbの倍数がaの内部に収まるかを計算して、残された値（余りとして知られるもの）を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The requirements in a generic where clause specify that a type parameter inherits from a class or conforms to a protocol or protocol composition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体where節の中の要件が指定するのは、型パラメータがクラスから継承するかまたはプロトコルやプロトコル合成に準拠するということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The setter name and enclosing parentheses are optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッター名と囲んでいる括弧は、任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The setter name and enclosing parentheses in the willSet and didSet clauses are optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>willSetとdidSet節の中のセッター名と囲んでいる丸括弧は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The setter name and enclosing parentheses is optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッター名、そして囲んでいる丸括弧は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The statements inside a code block include declarations, expressions, and other kinds of statements and are executed in order of their appearance in source code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コード・ブロックの内側の文は、宣言、式、そして他の種類の文を含みます、そしてソース・コードにおいてそれらの現れる順に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ternary conditional operator evaluates to one of two given values based on the value of a condition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>三項条件演算子は、ある条件の値に基づいて、２つの与えられた値のうちの１つへと評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ternary conditional operator is a special operator with three parts, which takes the form question ? answer1 : answer2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>三項条件演算子は３つの部分をもつ特別な演算子です、それは形式question ? answer1 : answer2をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unary plus operator (+) simply returns the value it operates on, without any change:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項プラス演算子（+）は、それが作用する値を、どんな変更もせずに、ただ単純に返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The version number consists of one or more positive integers, separated by periods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バージョン番号は、ビリオドで区切られた、１つ以上の正の整数から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The superclass appears first after the class name and colon, followed by any adopted protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスがまずクラス名とコロンの後に現れ、続いて随意の準拠するプロトコルが続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type annotation is optional when the type can be inferred from the initializer expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型注釈は、その型が初期化式から推論されることができる場合は随意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The existing type can be a named type or a compound type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存の型は、名前付きの型または複合の型でありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The line number changes the value of #line and is any integer literal greater than zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>line number（行番号）は、#lineの値を変更します、そして0より大きい何らかの整数リテラルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol member declarations are discussed in detail below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルメンバー宣言は、詳細に下で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return type specifies the type of the element being accessed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>戻り型は、アクセスされている要素の型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The filename changes the value of #file and is a string literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>filename（ファイル名）は、#fileの値を変更します、そしてひとつの文字列リテラルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Basics</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CSS color value #CC6699 is written as 0xCC6699 in Swift’s hexadecimal number representation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CSS色値#CC6699は、スウィフトの16進数表現では0xCC6699のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Problem That Generics Solve</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体が解決する問題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Sorted Method</seg>
      </tuv>
      <tuv lang="JA">
        <seg>分類メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift language defines the postfix ! as syntactic sugar for the named type Optional&lt;Wrapped&gt;, which is defined in the Swift standard library, with the additional behavior that it’s automatically unwrapped when it’s accessed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト言語は、接尾辞!を構文糖衣としてスウィフト標準ライブラリで定義される名前付きの型Optional&lt;Wrapped&gt;に対して定義します、それはそれがアクセスされるとき自動的にアンラップされるという追加の挙動を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift language defines the postfix ? as syntactic sugar for the named type Optional&lt;Wrapped&gt;, which is defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト言語は、接尾辞?を構文糖衣として名前付きの型Optional&lt;Wrapped&gt;に対して定義します、それは、スウィフト標準ライブラリで定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift language is relatively small, because many common types, functions, and operators that appear virtually everywhere in Swift code are actually defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト言語は比較的小さいです、スウィフトのコードのほとんど至る所で見かける多くの通常の型、関数、そして演算子がスウィフト標準ライブラリで実際には定義されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift language provides the following syntactic sugar for the Swift standard library Array&lt;Element&gt; type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト言語は、スウィフト標準ライブラリのArray&lt;Element&gt;型のために以下の構文糖衣を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift language provides the following syntactic sugar for the Swift standard library Dictionary&lt;Key, Value&gt; type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト言語は、以下の構文糖衣をスウィフト標準ライブラリDictionary&lt;Key, Value&gt;型に提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift logical operators &amp;&amp; and || are left-associative, meaning that compound expressions with multiple logical operators evaluate the leftmost subexpression first.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの論理演算子&amp;&amp;と||は、左結合です、複数の論理演算子を持つ複合式が最も左の下位の式を最初に評価することを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift standard library also defines a Float type, which represents a 32-bit floating-point number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリはまたFloat型も定義します、それは、32ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift standard library also defines types for various sizes of signed and unsigned integers, as described in Integers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数で記述されるように、スウィフト標準ライブラリはまた、さまざまな大きさの符号つきおよび符号なし整数のために、いろいろな型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift standard library defines a number of operators for your use, many of which are discussed in Basic Operators and Advanced Operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリは、いくつかの演算子をあなたが使うために定義します、その多くは基本の演算子と先進の演算子で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift standard library defines a protocol called Equatable, which requires any conforming type to implement the equal to operator (==) and the not equal to operator (!=) to compare any two values of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリは、Equatableと呼ばれるプロトコルを定義します、それは、それに準拠している全ての型に対してその型のあらゆる２つの値を比較するために同等演算子（==）と不等演算子（!=）を実装することを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift standard library includes tuple comparison operators for tuples with fewer than seven elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリは、いくらかのタプル比較演算子を、７要素より少数でのタプルに対して含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The above example implements an “equal to” operator (==) to check if two Vector2D instances have equivalent values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記の例は、ある「同等」演算子（==）を実装して、２つのVector2Dインスタンスが同じ値を持つかどうか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The above example uses a defer statement to ensure that the open(_:) function has a corresponding call to close(_:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、defer文を使って、open(_:)関数がそれと対応するclose(_:)への呼び出しを持つことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The access control level of a type also affects the default access level of that type’s members (its properties, methods, initializers, and subscripts).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型のアクセス制御水準はまた、その型のメンバー（それのプロパティ、メソッド、イニシャライザ、そして添え字）の省略時のアクセス水準に影響を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The access level for a function type is calculated as the most restrictive access level of the function’s parameter types and return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型のためのアクセス水準は、その関数のパラメータ型と戻り型での最も制限の多いアクセス水準と同じに算出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The access level for a generic type or generic function is the minimum of the access level of the generic type or function itself and the access level of any type constraints on its type parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体型または総称体関数のためのアクセス水準は、総称体型または関数自身のアクセス水準およびその型パラメータ上のあらゆる型制約のアクセス水準の最少のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The access level for a tuple type is the most restrictive access level of all types used in that tuple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル型のためのアクセス水準は、そのタプルで使われる全ての型での最も制限的なアクセス水準です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The access level of each requirement within a protocol definition is automatically set to the same access level as the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル定義内の各要件のアクセス水準は、自動的にプロトコルと同じアクセス水準に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual type to use for that associated type is not specified until the protocol is adopted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関連型のために使われる実際の型は、プロトコルが採用されるまでは指定されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual type to use in place of T will be determined each time the swapTwoValues(_:_:) function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Tの代わりに実際に使われる型は、swapTwoValues(_:_:)関数が呼ばれるたびに決定されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The addition operator is also supported for String concatenation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加算演算子は、また、String連結に対してもサポートされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The appropriate choice of weak or unowned depends on the relationships between the different parts of your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱いまたは非所有者の適切な選択は、あなたのコードの異なる部分間の関係に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The appropriate floating-point type to use depends on the nature and range of values you need to work with in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>使うのに適切な浮動小数点型は、あなたのコードにおいて扱わなければならない値の種別と幅に依ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The appropriate form to use depends on the scope at which the variable is declared and the kind of variable you intend to declare.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>使用するのに適切な形式は、その変数が宣言されるスコープとあなたが宣言するつもりである変数の種類に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The argument is automatically converted to a closure, because the customerProvider parameter’s type is marked with the @autoclosure attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数は、自動的にクロージャに変換されます、なぜならcustomerProviderパラメータの型は@autoclosure属性で印されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The argument label is used when calling the function; each argument is written in the function call with its argument label before it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルは、関数を呼び出すときに使われます；各引数は、関数呼び出しにおいてそれの前のそれの引数ラベルとともに書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The argument value passed to this parameter specifies how much runningTotal should be incremented by each time the returned incrementer function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このパラメータに渡された引き数の値は、返されたインクリメンタ関数（漸増器関数）が呼ばれるたびに、どのくらいrunningTotalが増やされなければならないかについて指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The arguments to the initializer are passed like a function call when you create an instance of the class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザに対する引数は、あなたがクラスのインスタンスをつくるときに関数呼び出しのように渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The arithmetic addition operator is a binary operator because it operates on two targets and is said to be infix because it appears in between those two targets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>算術加算演算子は、それが２つの目標に作用するので二項演算子です、そして、それがそれらの２つの目標の間に現れるので接中辞と言われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The array [16, 58, 510] is used to create the new array ["OneSix", "FiveEight", "FiveOneZero"]:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列[16, 58, 510]は、新しい配列["OneSix", "FiveEight", "FiveOneZero"]をつくるために使われます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The array is declared outside the scope of the function, which means the closures in the array can be executed after the function returns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この配列は関数のスコープの外側で宣言されます、それは配列の中のクロージャが関数が戻った後で実行されることができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assertion message can be omitted if desired, as in the following example:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例の場合のように、表明メッセージは、望むならば省略されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignment is part of the optional chaining, which means none of the code on the right hand side of the = operator is evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この代入はオプショナル連鎖の一部です、それが意味するのは、=演算子の右手側のコードで評価されるものは何もないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignment operator (=) does not return a value, to prevent it from being mistakenly used when the equal to operator (==) is intended.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代入演算子（=）は値を返しません、それが同等演算子（==）が意図される時に誤って使われるのを防ぐためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignment operator does not return any value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代入演算子は、少しの値も返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The audio channels described above are represented by instances of the AudioChannel structure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で記述される音声のチャンネルは、AudioChannel構造体のインスタンスによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The availability condition above specifies that on iOS, the body of the if executes only on iOS 10 and later; on macOS, only on macOS 10.12 and later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上での有効性条件は次を指定します、iOS上では、ifの本文はiOS 10以降でのみ実行します；macOS上では、macOS 10.12以降でのみ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The availability condition takes a comma-separated list of platform names and versions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効性条件は、プラットホーム名とバージョンのコンマ区切りのリストを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The backticks are not considered part of the identifier; `x` and x have the same meaning.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バッククォートは、識別子の一部とみなされません；`x`とxは、同じ意味を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The barcode example in Associated Values shows how cases of an enumeration can declare that they store associated values of different types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連値におけるバーコード例は、それらが異なる型の関連値を格納することを、ある列挙のケース節たちがどのように宣言可能かを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The base class in the hierarchy is called Food, which is a simple class to encapsulate the name of a foodstuff.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この階層構造における基盤クラスはFoodと呼ばれています、それは、食品の名前をカプセル化する単純なクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic form imports the entire module; it consists of the import keyword followed by a module name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本の形式は、そのモジュール全体をインポートします；それは、importキーワードとそれに続くモジュール名から成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic syntax for type constraints on a generic function is shown below (although the syntax is the same for generic types):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体関数に関する型制約のための基本の構文は、下で示されます（とはいえ構文は総称体型と同じものです）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior of x as! T is the same as the behavior of (x as? T)!.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>x as! Tの挙動は、(x as? T)!の挙動と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior you see in your code will always be as if a copy took place.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあなたのコードにおいて見るこの挙動は、常にコピーが起こったかのようです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bit-shifting behavior for unsigned integers is as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号なし整数のためのビットシフト挙動は、次の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise AND operator combines them to make the number 00111100, which is equal to an unsigned decimal value of 60:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理積演算子は、それらを結合して、数00111100をつくります、それは、符号なしの10進数の60と等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理否定演算子は、接頭辞演算子で、少しの空白なしで、それが作用する値の直前に現れまます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise NOT operator is then used to create a new constant called invertedBits, which is equal to initialBits, but with all of the bits inverted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理否定演算子は、それからinvertedBitsと呼ばれる新しい定数をつくるために使われます、それは、initialBitsと等しいです、しかし全てのビットは逆にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise OR operator combines them to make the number 11111110, which equals an unsigned decimal of 254:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理和演算子は、それらを結合して、数11111110を作ります、それは、符号なしの10進数の254と等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise XOR operator sets both of these bits to 1 in its output value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の排他的論理和演算子は、これらのビットの両方ともその出力値において1に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The board has 25 squares, and the aim is to land on or beyond square 25.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この盤には25の正方形があります、そして目ざすのは正方形25の上に乗るまたは越える事です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The board is initialized with 26 zero Int values, not 25 (one each at indexes 0 through 25).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この盤は、26個の０のInt値で初期化されます、25ではなく（インデックス0から25までのそれぞれにひとつ）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of a class contains zero or more declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスの本文は、０個以上の宣言を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of a protocol contains zero or more protocol member declarations, which describe the conformance requirements that any type adopting the protocol must fulfill.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルの本文は０以上のプロトコルメンバー宣言を含みます、それは、プロトコルを採用しているすべての型が満たさなければならない準拠要件を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of a structure contains zero or more declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造の本文は、０以上の宣言を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of an enumeration declared using either form contains zero or more values—called enumeration cases—and any number of declarations, including computed properties, instance methods, type methods, initializers, type aliases, and even other enumeration, structure, and class declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの形式を使って宣言される列挙宣言の本文でも、０以上の値 ― 列挙ケース節と呼ばれるもの ― および任意の数の宣言から成っていて、計算プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、型エイリアス、そして他の列挙、構造体、およびクラス宣言さえも含められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of an extension declaration contains zero or more declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言の本文は、０個以上の宣言を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of each case must contain at least one executable statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのケース節の本文は、少なくとも１つの実行可能な文を含んでいることが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of the greet(person:) function starts by defining a new String constant called greeting and setting it to a simple greeting message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>greet(person:)関数の本文は、greetingと呼ばれる新しいString定数を定義してそれを単純な挨拶メッセージに設定することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of the minMax(array:) function starts by setting two working variables called currentMin and currentMax to the value of the first integer in the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>minMax(array:)の本文は、currentMinとcurrentMaxと呼ばれる２つの作業用の変数を配列の最初の整数に設定することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of the swapTwoValues(_:_:) function is identical to the body of the swapTwoInts(_:_:) function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>swapTwoValues(_:_:)関数の本文は、swapTwoInts(_:_:)関数の本文と同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The brackets tell Swift that T is a placeholder type name within the swapTwoValues(_:_:) function definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この括弧は、TがswapTwoValues(_:_:)関数定義内のプレースホルダ型名であるとスウィフトに教えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The call to increment(forCount:) happens only if increment(forCount:) exists—that is, if it isn’t nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>increment(forCount:)への呼び出しは、increment(forCount:)が存在する場合にのみ起こります ― すなわち、それがnilでない場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The call to the digitNames dictionary’s subscript is followed by an exclamation mark (!), because dictionary subscripts return an optional value to indicate that the dictionary lookup can fail if the key does not exist.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>digitNames辞書への呼び出しの添え字の後に感嘆符（!）が続きます、なぜなら、キーが存在しない場合は辞書検索が失敗し得ることを意味するために、辞書添え字がオプショナルの値を返すからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The capabilities described above for computing and observing properties are also available to global variables and local variables.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算するそして監視するプロパティに対して上で記述される可能なことは、また、グローバル変数とローカル変数に対して利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The case values of an enumeration are actual values, not just another way of writing their raw values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある列挙に属するケース節の値は実際の値です、単にそれらの生の値を別のやり方で書くことではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The chapter’s example of Overriding Property Getters and Setters has been rewritten to show how to override a description property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この章のプロパティゲッターとセッターのオーバーライドの例は書き直されて、descriptionプロパティをオーバーライドする方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The characters are visually similar, but do not have the same linguistic meaning:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの文字は視覚的には同じ形です、しかし同じ言語的意味を持ちません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class also defines a deinitializer, which prints a message to show when an HTMLElement instance is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスもデイニシャライザを定義します、それは、HTMLElementインスタンスが割り当て解除される場合に示すメッセージを出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class instance is not fully valid until the first phase ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第１段階が終わるまで、クラスインスタンスは充分に有効ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class is assumed to take a non-trivial amount of time to initialize.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（このクラスは、初期化するために取るに足らない量ではない時間がかかると仮定されます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closed range operator is useful when iterating over a range in which you want all of the values to be used, such as with a for-in loop:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>完結範囲演算子は、あなたがその値の全てが使われることを望む、ある範囲全体に渡って繰り返すときに役に立ちます、例えばfor-inループで：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure can be used to create a string representation of any integer greater than zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクロージャは、ゼロより大きいあらゆる整数の文字列表現を作るために使われることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure can then refer to and modify the values of those constants and variables from within its body, even if the original scope that defined the constants and variables no longer exists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャはそれから、その本文内からそれらの定数と変数の値に言及することや修正することができます、たとえその定数と変数を定義した本来のスコープがもはや存在しないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure expression also specifies a return type of String, to indicate the type that will be stored in the mapped output array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式はまた、Stringの戻り型を指定します、それによってマップされた出力配列の中に格納されることになる型を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure expression builds a string called output each time it is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式は、それが呼ばれるたびに、outputと呼ばれる文字列をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure expression examples below illustrate these optimizations by refining a single example of the sorted(by:) method over several iterations, each of which expresses the same functionality in a more succinct way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のクロージャ式の例は、これらの最適化を一つの例のsorted(by:)メソッドの改良をいくどか繰り返していくことで解説します、そして、そのそれぞれは同じ機能性をより簡潔な方法で表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure expression examples below use the sorted(by:) method to sort an array of String values in reverse alphabetical order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のクロージャ式の例は、sorted(by:)メソッドを使用してString値からなる配列を逆アルファベット順に分類します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure in the example above calculates and sets the appropriate color for each square on the board in a temporary array called temporaryBoard, and returns this temporary array as the closure’s return value once its setup is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例でのクロージャはtemporaryBoardと呼ばれる一時的な配列の中の板上の各正方形に対して適切な色を計算して設定します、そしてひとたびその準備が完了されたならば、この一時的な配列をクロージャの戻り値として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure is called once for each item in the array, and returns an alternative mapped value (possibly of some other type) for that item.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは、配列の中の各項目に対して一度だけ呼ばれて、その項目のための代わりの対応付けされた（おそらく何か他の型の）値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code above calls the continue keyword whenever it matches a vowel or a space, causing the current iteration of the loop to end immediately and to jump straight to the start of the next iteration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードは、それが母音または空白と合致するたびにcontinueキーワードを呼んで、ループの現在の繰り返しを直ちに終わって、次の繰り返しのスタートへまっすぐポンと飛ぶようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code above creates a dictionary of mappings between the integer digits and English-language versions of their names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードは、整数桁とそれらの名前の英語版の間で対応付けをする辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code above creates a new Counter instance; sets its data source to be a new ThreeSource instance; and calls the counter’s increment() method four times.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードは、新しいCounterインスタンスをつくり；それのデータ・ソースを新しいThreeSourceインスタンスであるように設定します；そして、counterのincrement()メソッドを４回呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code above succeeds when john.residence has a non-nil value and will set roomCount to an Int value containing the appropriate number of rooms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>john.residenceが非nil値を持って、roomCountを部屋の適当な数を含んでいるInt値に設定するとき、上のコードは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code above uses the ternary conditional operator and forced unwrapping (a!) to access the value wrapped inside a when a is not nil, and to return b otherwise.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードは、三項条件演算子と強制アンラップ（a!）を使って、aがnilでないならばa内部にラップされた値にアクセスします、それ以外ではbを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code below shows four examples of these special characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のコードは、これらの特殊文字の４つの例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code below shows how a closure delays evaluation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のコードは、どのようにクロージャが評価を遅らすかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code below shows the ArithmeticExpression recursive enumeration being created for (5 + 4) * 2:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のコードは、(5 + 4) * 2に対して作成されている再帰列挙ArithmeticExpressionを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code in a closure has access to things like variables and functions that were available in the scope where the closure was created, even if the closure is in a different scope when it is executed—you saw an example of this already with nested functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクロージャの中のコードは、そのクロージャが作成されたところのスコープ内で利用可能だった変数や関数といったものにアクセスをします、たとえそのクロージャが実行されるときに異なるスコープの中にあってもです ― あなたはこの例を入れ子にされた関数で既に見ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code is executed regardless of whether the function throws an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのコードは、関数がエラーをスローするかどうかに関係なく実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code snippets below define four model classes for use in several subsequent examples, including examples of multilevel optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のコード切れっぱしは、複数階層のオプショナル連鎖の例を含む以降のいくつかの例のために、４つのモデル・クラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code within a default case is executed only if no other cases match the control expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のいかなるケース節も制御式にマッチしない場合だけ、省略時のケース節内のコードは実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code you provide is run any time the value changes outside of an initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが提供したコードは、その値がイニシャライザの外側で変化する時はいつでも実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The colon in the declaration means “…of type…,” so the code above can be read as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言でのコロンは“…の型の…”を意味します、それで上のコードは次のように読まれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The column number in which it begins.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが開始するコラム番号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler also detects methods with override that don’t actually override any method in the superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラはまた、実際にはスーパークラスにおけるメソッドを少しもオーバーライドしないoverrideをもつメソッドも検出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler also implicitly adds the objc attribute to a class that inherits from another class marked with the objc attribute or a class defined in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラはまた、objc属性で印される別のクラスやObjective-Cで定義されたクラスから継承するクラスに暗黙的にobjc属性を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler is optimized for performance, and the language is optimized for development, without compromising on either.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラはパフォーマンスのために最適化されます、そして言語は開発のために最適化されます、どちらについても妥協することなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler uses an available attribute only when the attribute specifies a platform that matches the current target platform.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラはavailable属性を、ただその属性が現在の目標プラットホームに合致するあるプラットホームを指定するときにだけ使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler uses availability information in the SDK to verify that all of the APIs used in your code are available on the deployment target specified by your project.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラは、SDKの中の有効性情報を使って、あなたのコードの中で使用されるAPIの全てがあなたのプロジェクトで指定される開発対象で有効であることを確かめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler uses the information from the availability condition when it verifies that the APIs in that block of code are available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラは、有効性条件からの情報を、それがそのブロックの中のAPIが利用可能であることを確かめる時に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compound assignment operators do not return a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合代入演算子は、値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The computed numberOfRooms property simply returns the value of the count property from the rooms array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算numberOfRoomsプロパティは、単にrooms配列からcountプロパティの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The computed type property examples above are for read-only computed type properties, but you can also define read-write computed type properties with the same syntax as for computed instance properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の計算型プロパティの例は、読み出し専用の計算型プロパティのためのものです、しかしあなたはまた、計算インスタンスプロパティについては同じ構文をつかって読み書き両用の計算型プロパティを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The concept of a stack is used by the UINavigationController class to model the view controllers in its navigation hierarchy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックの概念は、UINavigationControllerクラスで使用されて、そのナビゲーション階層においてビュー・コントローラをモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The concept of optionals doesn’t exist in C or Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの概念は、CまたはObjective-Cの中に存在しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The condition can also be an optional binding declaration, as discussed in Optional Binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件はまた、オプショナル束縛で議論される、オプショナル束縛宣言であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The condition of a loop can be at the end instead, ensuring that the loop is run at least once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループの条件は終わりに置くことができます、その場合にはループが少なくとも一回は実行されることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The conditional form, as?, returns an optional value of the type you are trying to downcast to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件（仮定）形式as?は、あなたがダウンキャストしようとしている型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The contents of a Dictionary are inherently unordered, and iterating over them does not guarantee the order in which they will be retrieved.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Dictionaryの内容は本質的に順序付けされません、そしてそれらに繰り返すことはそれらが取り出される順番を保証しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The contents of a String can be accessed in various ways, including as a collection of Character values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるStringの内容は、いくつかのやり方でアクセスされることができます、それにはCharacter値からなるひとつのコレクションとしてを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The contents of this expression are also considered when performing type inference on the surrounding expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この式の内容はまた、型推論を実行する時に周囲の式上にあると見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The context and function name should make it clear that evaluation is being deferred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文脈と関数名は、評価が猶予されていることを明確にしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The context in which a type conforms to a particular protocol is the minimum of the type’s access level and the protocol’s access level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型が特定のプロトコルに準拠するところの前後関係は、その型のアクセス水準とプロトコルのアクセス水準の最も低いものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The convenience initializer must call one of the two designated initializers, because it can only call another initializer from the same class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは、２つの指定イニシャライザのうちの１つを呼ぶに違いありません、なぜなら、それが同じクラスから別のイニシャライザを呼ぶことができるだけだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corresponding argument must have no label in function or method calls.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対応する引数には、関数またはメソッドの呼び出しにおいてラベルがあってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corresponding argument must use the given argument label in function or method calls.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対応する引数は、この引数ラベルを関数またはメソッドの呼び出しにおいて使わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corresponding implementation for Vector2D instances performs this operation on both the x and y properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Vector2Dインスタンスのための対応する実装は、xとyプロパティ両方の上でこの操作を実行します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corresponding section in Strings and Characters has been removed, and various code examples have been updated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列と文字の中の関連する節は削除されました、そしてさまざまなコード例が更新されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The count of the characters returned by the characters property is not always the same as the length property of an NSString that contains the same characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>charactersプロパティによって返される文字の総数は、同じ文字を含むNSStringのlengthプロパティと常に同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current while loop execution then ends, and the loop’s condition is checked to see if the loop should be executed again.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在のwhileループ実行はそれから終了します、そしてループが再び実行されなければならないかどうか見るためにループの条件が調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current center position of a Rect can always be determined from its origin and size, and so you don’t need to store the center point as an explicit Point value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Rectの現在の中心位置は常にそのoriginとsizeから決定されることができます、なのであなたは中心点をわざわざPoint値として保存する必要ばありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current login attempt counter is declared as a variable, because this value must be incremented after each failed login attempt.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在のログイン試行の計数は、この値が失敗したログインの試みそれぞれの後で増加する必要があるので、変数として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current loop execution then ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在のループ実行はそれで終わりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The decimal fraction consists of a decimal point (.) followed by a sequence of decimal digits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>小数部は、小数点（.）に続く一連の10進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The declaration of SimpleClass doesn’t need any of its methods marked as mutating because methods on a class can always modify the class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SimpleClassの宣言はそのメソッドのどれも変化するとして印される必要はありません、なぜならあるクラスに属するメソッドは常にそのクラスを修正できるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default access level of internal already matches this requirement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のアクセス水準である内部は、既にこの要件に合致しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default inferred type of a string literal is String.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態で推論されるリテラル文字列の型は、Stringです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default initializer (when available) is always a designated initializer for a class, and can be used to create a new Vehicle instance with a numberOfWheels of 0:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のイニシャライザは（利用可能な場合は）、常にクラスのための指定イニシャライザです、そして0のnumberOfWheelsをもつ新しいVehicleインスタンスを作成するために使用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default initializer simply creates a new instance with all of its properties set to their default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のイニシャライザは、単に新しいインスタンスを、そのプロパティの全てをそれらの省略時の値に設定することで作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default memberwise initializer for a structure type is considered private if any of the structure’s stored properties are private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体型のための省略時のメンバー関連イニシャライザは、その構造体の保存プロパティのいずれかが非公開ならば、非公開であるとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default types are Int for integer literals, Double for floating-point literals, String for string literals, and Bool for Boolean literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の型は、整数リテラルのためのInt、浮動小数点リテラルのためのDouble、文字列リテラルのためのString、そしてブールのリテラルのためのBoolです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default value also makes it easier for you to take advantage of default initializers and initializer inheritance, as described later in this chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の値はまた、あなたが省略時のイニシャライザとイニシャライザ継承を活用することをより簡単にします、そのことはこの章の後で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The deferred statements may not contain any code that would transfer control out of the statements, such as a break or a return statement, or by throwing an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>延期される文は、制御をその文の外に、例えばbreakやreturn文、またはエラーをスローすることによって移すいかなるコードも含んではいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definition describes what the function does, what it expects to receive, and what it returns when it is done.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定義は、関数が何をするか、それが何を受け取るのを予想するか、そしてそれが実行し終わったとき、それが何を返すかを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definition makes it easy for the function to be called unambiguously from elsewhere in your code:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定義は、関数があなたのコードのどこか他の場所から誤解の余地なく呼び出されることを簡単にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definition of typealias ItemType = Int turns the abstract type of ItemType into a concrete type of Int for this implementation of the Container protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定義typealias ItemType = Intは、Containerプロトコルのこの実装のために、抽象的な型ItemTypeを具体的な型Intに変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definition of this convenience initializer makes RecipeIngredient instances quicker and more convenient to create, and avoids code duplication when creating several single-quantity RecipeIngredient instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この便宜イニシャライザの定義は、RecipeIngredientインスタンスを素早くより便利に作成されるようにします、そして数量１のRecipeIngredientインスタンスをいくつか作成する時にコードの繰り返しを防止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The deinitializer does not take any parameters and is written without parentheses:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、まったくパラメータを取りません、したがって丸括弧なしで書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The description above refers to the “copying” of strings, arrays, and dictionaries.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の記述は、文字列、配列、そして辞書の「コピー」について言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、そのスーパークラスのイニシャライザに、それ自身の保存プロパティに対して同じ作業を実行するように任せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The designated initializer makes sure that all of the subclass’s properties have a value, as per safety check 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、安全検査１のように、サブクラスのプロパティの全てが値を持つことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The designated initializer of a class must initialize all of the class’s declared properties and it must do so before calling any of its superclass’s designated initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスの指定イニシャライザは、そのクラスの指定するプロパティのすべてを初期化しなければ成りません、そしてそれは何であれそれのスーパークラスの指定イニシャライザを呼ぶ前にそうしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dice is rolled at the start of each loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さいころは、各ループの始まりで振られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference between open and public access is described below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>開放と公開アクセスの間の違いは下で解説されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The different barcode types can be checked using a switch statement, as before.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>異なるバーコード型は、前の通り、スイッチ文を使って調べられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The elements of a tuple can be referred to either by name or by number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるタプルの要素たちは、名前または番号で言及されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The elements of an array can be accessed through subscripting by specifying a valid index value in square brackets: someArray[0] refers to the element at index 0, "Alex".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の要素は、角括弧の中に有効なインデックス値を指定することによる添え字指定を通してアクセスされることができます：someArray[0]]は、インデックス0での要素、"Alex"に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The else clause of an if statement can contain another if statement to test more than one condition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文のelse節は、複数の条件をテストするために別のif文を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end result is the same, but the default value ties the property’s initialization more closely to its declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最終的な結果は同じものです、しかし省略時の値は、プロパティの初期化をより密接にその宣言に結び付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end result is two completely separate instances, which just happened to contain the same numeric values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最終的な結果は２つの完全に別々のインスタンスです、そしてそれらは、たまたま同じ数値を含むということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end result of calling this alternative version of the method will be exactly the same as for calling the earlier version.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドのこの代替版を呼ぶ最終結果は、以前の版を呼ぶことと正確に同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The entire type(of:) expression evaluates to the value of the runtime type of the expression, as the following example shows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例が示すように、type(of:)式の全体は、expression（式）の実行時型の値に評価されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The entire expression c?.property.performAction() has a value of an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式c?.property.performAction()の全体がオプショナル型の値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The entries in the capture list are initialized when the closure is created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャプチャリストの中の登録項目は、クロージャが作成されるときに初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The enumeration below is a refinement of the earlier CompassPoint enumeration, with string raw values to represent each direction’s name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の列挙は、前のCompassPoint列挙の改良版で、各方位の名前を表す文字列の生の値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The enumeration below is a refinement of the earlier Planet enumeration, with integer raw values to represent each planet’s order from the sun:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の列挙は、以前のPlanet列挙の改良で、太陽からの各惑星の順番を表す整数の生の値をもちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The enumeration cases north, south, east, and west therefore also have an access level of “public”:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この列挙のケース節north、south、east、そしてwestはしたがってまた「公開」のアクセス水準を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The enumeration type is pattern-matched against the enumeration case patterns in the case blocks of the switch statement, as described in Enumeration Case Pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙型は、switch文のケース節ブロックにおいて、列挙ケース節パターンに対してパターンのマッチされます、列挙ケース節パターンで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The enumeration’s toggle implementation is marked as mutating, to match the Togglable protocol’s requirements:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙のtoggle実装は、Togglableプロトコルの要件に適合するように、mutatingとして印されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The error that’s thrown continues to propagate until it’s handled by a catch clause of a do statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローされたエラーは、それがdo文のcatch節によって処理されるまで伝達を続けていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The escaped special characters \0 (null character), \\ (backslash), \t (horizontal tab), \n (line feed), \r (carriage return), \" (double quote) and \' (single quote)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エスケープされた特殊文字の\0（ヌル文字）、\\（バックスラッシュ）、\t（水平タブ）、\n（ラインフィード）、\r（キャリッジリターン）、\"（二重引用符）と\'（一重引用符）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exact meaning of “subscript” depends on the context in which it is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「添え字」の正確な意味は、それが使われる前後関係に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above also defines a new class called VideoMode, to describe a specific video mode for video display.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、また、ビデオ・ディスプレイのために特定のビデオ・モードを記述するために、VideoModeと呼ばれる新しいクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above calculates the value of one number to the power of another (in this case, 3 to the power of 10).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、ある数を他のもので乗算した値を計算します（この場合、3の10乗）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above checks whether the temperature is less than or equal to 32 degrees Fahrenheit (the freezing point of water).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、温度が華氏32度（水の氷点）以下かどうか確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above creates a Stack instance to store String values, and pushes three strings onto the stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、StackインスタンスをつくってString値を保存します、そしてスタック上へ３つの文字列をプッシュします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above defines a dictionary called testScores, which contains two key-value pairs that map a String key to an array of Int values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例はtestScoresと呼ばれる辞書型を定義します、それは、２つの「キーと値」対を含んでいて、それはStringキーをInt値を持つ配列と関連づけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above defines a new prefix operator called +++.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、+++と呼ばれる新しい接頭辞演算子を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above defines a new structure called Resolution, to describe a pixel-based display resolution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、ピクセルに基づくディスプレイ解像度を記述するために、Resolutionと呼ばれる新しい構造体を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above defines a variable called numberOfLegs and initializes it with a dictionary literal containing three key-value pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、numberOfLegsと呼ばれる変数を定義して、３つの「キーと値」の対を含んでいる辞書リテラルでそれを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above implements the unary minus operator (-a) for Vector2D instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、Vector2Dインスタンスのための単項マイナス演算子（-a）を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above in Accessing Properties Through Optional Chaining attempts to set an address value for john.residence, even though the residence property is nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を通してプロパティにアクセスするでの前の例は、あるaddress値をjohn.residenceに対して設定することを試みます、たとえresidenceプロパティがnilであるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above shows that the original values of someInt and anotherInt are modified by the swapTwoInts(_:_:) function, even though they were originally defined outside of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、someIntとanotherIntの本来の値が、たとえそれらが元々は関数の外側で定義されたとしても、swapTwoInts(_:_:)関数によって修正されることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above shows what happens if it is called with an input value of "Anna", and an input value of "Brian".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、それが"Anna"の入力値、そして"Brian"の入力値で呼ばれるならば、何が起こるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above uses a very simple approach to dice rolling.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、さいころ振りに対する非常に単純なアプローチを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above uses the default initializer for the ShoppingListItem class to create a new instance of the class with initializer syntax, written as ShoppingListItem(), and assigns this new instance to a variable called item.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、ShoppingListItemクラスのための省略時のイニシャライザを使って、このクラスの新しいインスタンスを作成します、ShoppingListItem()のように書かれる、イニシャライザ構文の所です、そしてこの新しいインスタンスをitemと呼ばれる変数に代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example also creates an Array instance initialized with an array literal containing the same three strings as the stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はまた、このスタックと同じ３つの文字列を含む配列リテラルで初期化されるArrayインスタンスをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example also defines a wishHappyBirthday(to:) function, The type of the celebrator parameter is Named &amp; Aged, which means “any type that conforms to both the Named and Aged protocols.” It doesn’t matter what specific type is passed to the function, as long as it conforms to both of the required protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はまた、wishHappyBirthday(to:)関数を定義します。celebratorパラメータの型はNamed &amp; Agedです、それは、「NamedとAgedプロトコルの両方に準拠するあらゆる型」を意味します。どんな具体的な型が関数に渡されるかは重要ではありません、それが必要とされるプロトコルの両方に従う限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example also defines two supporting structures called Size and Point, both of which provide default values of 0.0 for all of their properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はまた、SizeとPointと呼ばれる２つの支援の構造体を定義します、その両方はそれらのプロパティの全てに0.0の省略時の値を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example also implements the “not equal to” operator (!=), which simply returns the inverse of the result of the “equal to” operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、また「不等」演算子（!=）も実装します、それは、単純に「同等」演算子の結果の逆を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below adds a new mutating method called square to Swift’s Int type, which squares the original value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、squareと呼ばれる新しい可変メソッドをスウィフトのInt型に加えます、それは、もとの値を二乗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below calculates the arithmetic mean (also known as the average) for a list of numbers of any length:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、どんな長さの数のリストに対しても、算術平均（また平均としても知られるもの）を計算します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below calls the Address class’s buildingIdentifier() method through optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、オプショナル連鎖を通してAddressクラスのbuildingIdentifier()メソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below categorizes an (x, y) point on the following graph:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、続くグラフ上でポイント(x, y)を分類します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below creates a dictionary to store the names of international airports.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、国際空港の名前を格納するための辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below creates a set called favoriteGenres to store String values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、favoriteGenresと呼ばれる集合をString値を格納するために作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below creates an array called shoppingList to store String values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、String値を保存するshoppingListと呼ばれる配列をつくります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a base class called Vehicle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、Vehicleと呼ばれる基盤クラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a class called Document.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、Documentと呼ばれるクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a custom Rect structure to represent a geometric rectangle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、幾何学の長方形を表すためにあつらえのRect構造体を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a function called minMax(array:), which finds the smallest and largest numbers in an array of Int values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例はminMax(array:)と呼ばれる関数を定義します、それは、あるInt値の配列の中で最小および最大の数を見つけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a generic function called allItemsMatch, which checks to see if two Container instances contain the same items in the same order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例はallItemsMatchと呼ばれる総称体関数を定義します、それは、２つのContainerインスタンスが同じ順序で同じ項目を含むかどうか見るために調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a global function called someFunction(), without providing a specific access-level modifier for the function itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、その関数自身に特定のアクセス水準修飾子を提供することなく、someFunction()と呼ばれるグローバル関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a new class called StepCounter, which tracks the total number of steps that a person takes while walking.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、StepCounterと呼ばれる新しいクラスを定義します、それは、ある人が歩いている間にとる総歩数を追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a new structure called Fahrenheit to store temperatures expressed in the Fahrenheit scale.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、Fahrenheitと呼ばれる新しい構造体を定義して、華氏尺度で表される温度を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a protocol called Togglable, which defines a single instance method requirement called toggle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、Togglableと呼ばれるプロトコルを定義します、それは、toggleと呼ばれる１つのインスタンスメソッド要件を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a structure called Animal, with a constant String property called species.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、Animalと呼ばれるある構造体を、speciesと呼ばれる定数Stringプロパティを使って定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a structure called BlackjackCard, which models a playing card as used in the game of Blackjack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例はBlackjackCardと呼ばれる構造体を定義します、それは、「ブラックジャック」ゲームにおいて使われるときの遊戯カード、トランプカードをモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a structure called Chessboard, which models a board for the game of chess.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例はChessboardと呼ばれる構造体を定義します、それは、「チェス」ゲーム用の盤をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a structure called FixedLengthRange, which describes a range of integers whose range length cannot be changed once it is created:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例はFixedLengthRangeと呼ばれる構造体を定義します、それは、一旦それが作成されたならば範囲長が変更されることが出来ない、整数からなるある範囲を記述します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a structure called LevelTracker, which tracks a player’s progress through the different levels or stages of a game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例はLevelTrackerと呼ばれる構造体を定義します、それは、プレイヤーの進み具合をゲームの異なるレベルまたはステージを通して追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a structure called Size with two properties called width and height.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、widthとheightと呼ばれる２つのプロパティをもつSizeと呼ばれる構造体を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a structure called TrackedString, which keeps track of the number of times a string property is modified:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例はTrackedStringと呼ばれる構造体を定義します、それは、ある文字列プロパティが修正される回数を追跡します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a subclass of Product called CartItem.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、CartItemと呼ばれるProductのサブクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines an enumeration called OnOffSwitch.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、OnOffSwitchと呼ばれる列挙を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines an enumeration called TemperatureUnit, with three possible states (kelvin, celsius, and fahrenheit).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、３つの可能な状態（kelvin、celsius、そしてfahrenheit）を持つ、TemperatureUnitと呼ばれる列挙を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines two classes, Country and City, each of which stores an instance of the other class as a property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は２つのクラス、CountryとCityを定義します、そして、そのそれぞれは他のクラスのインスタンスをプロパティとして格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines two protocols for use with dice-based board games:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、さいころに基づく様々なボードゲームで使うために、２つのプロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines two variables, movieCount and songCount, which count the number of Movie and Song instances in the library array:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は２つの変数、movieCountとsongCountを定義します、それは、MovieとSongインスタンスの数をlibrary配列において数えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below exposes the getter for the enabled property of the ExampleClass to Objective-C code as isEnabled rather than just as the name of the property itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、ExampleClassのenabledプロパティのためのゲッターを、そのプロパティ自身の名前どおりにではなく、isEnabledとしてObjective-Cコードにさらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below implements an addition assignment operator method for Vector2D instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、Vector2Dインスタンスのために追加代入演算子メソッドを実装します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below is identical to the Person and Apartment example from above, with one important difference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、上記のPersonとApartment例に同一ですが、１つの重要な違いがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below iterates over each MediaItem in library, and prints an appropriate description for each item.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、上にlibraryの中の各々のMediaItemすべてに繰り返して、各項目の適切な説明を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below iterates over the items in the things array and queries the type of each item with a switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、things配列の中の項目のすべてに渡って繰り返して、switch文を使って各項目の型について問い合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a closure expression version of the backward(_:_:) function from earlier:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例は、以前のbackward(_:_:)関数のクロージャ式版を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a simplified version of the Swift standard library’s generic dictionary type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、スウィフト標準ライブラリの総称体辞書型の簡略版を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a version of the TrackedString structure in which the structure is defined with an explicit access level of public.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、TrackedString構造体のある改作を示します、そこにおいてこの構造体は公開の明示的なアクセス水準を使って定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows an init? failable initializer that produces an optional instance of a structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、ある構造体のオプショナルインスタンスを生成する、失敗できるイニシャライザinit?を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows how to implement the arithmetic addition operator (+) for a custom structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、あつらえの構造体のために算術加算演算子（+）を実装する方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows how you can create a strong reference cycle when using a closure that references self.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、selfに参照をつけるクロージャを使うとき、あなたがどのように強い参照循環をつくることができるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows the syntax for stored and computed type properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、保存型プロパティおよび計算型プロパティのための構文を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below takes an (x, y) point, expressed as a simple tuple of type (Int, Int), and categorizes it on the graph that follows the example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、ポイント(x, y)、型(Int, Int)の単純なタプルとして表されるもの、をとって、その例に続くグラフ上でそれを分類します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below takes an (x, y) point, expressed as a tuple of type (Int, Int), and categorizes it on the graph that follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例は、ポイント(x, y)をとって、型(Int, Int)のタプルとして表し、それをあとに続くグラフに分類します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below tries to access the street property of the address property of the residence property of john.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、johnのresidenceプロパティのaddressプロパティのstreetプロパティにアクセスしようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below tries to retrieve the name of the first room in the rooms array of the john.residence property using the subscript defined on the Residence class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、Residenceクラス上で定義される添え字を使って、john.residenceプロパティのrooms配列での最初の部屋の名前を取り出そうとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below uses fallthrough to create a textual description of a number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、fallthroughをある数の文章での説明をつくるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below uses a lazy stored property to avoid unnecessary initialization of a complex class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、ある複雑なクラスの必要でない初期化を避けるために遅延保存プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below uses the initializer to try to convert a String into an Int:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、このイニシャライザを使用してStringをIntに変えることを試みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below uses the nil-coalescing operator to choose between a default color name and an optional user-defined color name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、nil合体演算子を、省略時の色の名前とオプショナルの利用者定義の色の名前とで選択するために使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example can be read as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example creates an array called things, which can store values of type Any:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はthingsと呼ばれる配列をつくります、それは、Any型の値を格納することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example defines a Vector2D structure for a two-dimensional position vector (x, y), followed by a definition of an operator method to add together instances of the Vector2D structure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例は、２次元の位置ベクトル(x, y)のためのVector2D構造体を定義します。そして、Vector2D構造体のインスタンスたちを１つに加えるための演算子メソッドの定義が続きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example requires two supporting structures called Size and Point, both of which provide default values of 0.0 for all of their properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、SizeとPointと呼ばれる２つの補助する構造体を必要とします、その両方はそれらのプロパティすべてに0.0の省略時の値を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example shown above demonstrates a custom implementation of a binary infix operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で示される例は、二項接中辞演算子のあつらえの実装を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example starts by trying to downcast the current item as a Movie.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例は、現在のitemをMovieとしてダウンキャストすることを試みることによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example then creates a new Person instance called birthdayPerson and passes this new instance to the wishHappyBirthday(to:) function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、それからbirthdayPersonと呼ばれる新しいPersonインスタンスをつくって、この新しいインスタンスをwishHappyBirthday(to:)関数に渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example uses optional chaining to set the first item in the "Dave" array to 91; to increment the first item in the "Bev" array by 1; and to try to set the first item in an array for a key of "Brian".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、オプショナル連鎖を使って"Dave"配列の最初の項目を91に設定します；それから"Bev"配列の最初の項目を1だけ増加します；そしてそれから"Brian"のキーに対応する配列の最初の項目を設定することを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The examples above show how to use safe unowned references.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、どのようにsafe非所有参照を使うかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The examples below consider an array of strings representing the scene locations from the first two acts of Shakespeare’s Romeo and Juliet:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、シェークスピアのロミオとジュリエットの最初の２幕から、場面場所を表している文字列の配列を考えてみます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The examples for weak and unowned references above cover two of the more common scenarios in which it is necessary to break a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の弱いおよび非所有者参照のための例は、強い参照循環を壊すために不可欠なよくある筋書きのうちの２つを扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The examples in the previous section show how the cases of an enumeration are a defined (and typed) value in their own right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前の節での例は、列挙のケース節がどのように自分だけで定義された（そして型付けされた）値であるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The examples that follow use two stored type properties as part of a structure that models an audio level meter for a number of audio channels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あとに続く例は、いくつかのオーディオ・チャンネル用のオーディオ・レベルをモデル化する構造体の一部として、２つの保存型プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exclamation mark effectively says, “I know that this optional definitely has a value; please use it.” This is known as forced unwrapping of the optional’s value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>感嘆符は、実際上こう言っています、「私はこのオプショナルが間違いなくひとつの値を持つことを知っています；どうぞそれを使ってください」。これは、そのオプショナルの所有する値の強制アンラップとして知られます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exponent consists of an upper- or lowercase e prefix followed by a sequence of decimal digits that indicates what power of 10 the value preceding the e is multiplied by.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指数は、大文字または小文字の接頭辞e、それに続けてeの前の値が10の何乗を掛けられるかを示す一連の10進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exponent consists of an upper- or lowercase p prefix followed by a sequence of decimal digits that indicates what power of 2 the value preceding the p is multiplied by.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指数は、大文字または小文字のp接頭辞、それに続けてpの前の値が２の何乗を掛けられるかを示す一連の10進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression a += 2 is shorthand for a = a + 2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式a += 2は、a = a + 2の簡略な表現です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression a is always of an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>aの式は常にオプショナル型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression b must match the type that is stored inside a.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>bの式はaの中に格納される型に合致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression is evaluated when the closure is created, and the value is captured with the specified strength.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その式は、クロージャが作成される時に評価されます、そしてその値は、指定された強さでキャプチャされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression represented by the expression pattern is compared with the value of an input expression using the Swift standard library ~= operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式パターンによって表される式は、入力された式の値とスウィフト標準ライブラリ~=演算子を使って比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expressions you write inside parentheses within an interpolated string cannot contain an unescaped backslash (\), a carriage return, or a line feed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>書き入れられる文字列内においてあなたが丸括弧の内側に書く式は、エスケープされないバックスラッシュ（\）、キャリッジリターン、またはラインフィードを含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fact that asHTML is a lazy property means that you can refer to self within the default closure, because the lazy property will not be accessed until after initialization has been completed and self is known to exist.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>asHTMLが遅延プロパティだという事実は、あなたが省略時のクロージャ内でselfに言及することができることを意味します、なぜなら、遅延プロパティは、初期化が完了されてしまってselfが存在することを知られる後までアクセスされることはないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fact that it is queried through an optional chain means that the call to numberOfRooms will always return an Int? instead of an Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがオプショナル連鎖によって問い合わせられるという事実は、numberOfRoomsへの呼び出しが常にInt?を返すことを意味します、Intではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fact that structures and enumerations can define methods in Swift is a major difference from C and Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体と列挙がスウィフトにおいてはメソッドを定義することができるという事実は、CやObjective-Cとの重大な違いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The failable initializer for CartItem starts by validating that it has received a quantity value of 1 or more.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CartItemのための失敗できるイニシャライザは、それが1以上のquantity値を受け取ったことを検証することによって始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fifth and sixth codeUnit values (55357 and 56374) are a UTF-16 surrogate pair representation of the DOG FACE character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>５番目と６番目のcodeUnit値（55357と56374）は、DOG FACE文字のUTF-16代用対叙述です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure below illustrates how two of these audio channels can be combined to model a stereo audio level meter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の図は、これらの音声のチャンネルのうちの２つがステレオ音声のレベル・メーターをモデル化するために結合されることができる方法を図示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure below shows a more complex class hierarchy for four classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の図は、４つのクラスのためのより複雑なクラス階層を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure below shows the initializer chain for the Food class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の図は、Foodクラスのためのイニシャライザ連鎖を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure below shows the initializer chain for the RecipeIngredient class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の図は、RecipeIngredientクラスのためのイニシャライザ連鎖を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure below shows the overall initializer chain for all three classes:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の図は、３つのクラス全てのために全体的なイニシャライザ連鎖を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final else clause is optional, however, and can be excluded if the set of conditions does not need to be complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、最後のelse節は任意です、そして条件の集合が完全である必要がないならば、除外されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final else clause remains, and it prints a response for any temperatures that are neither too warm nor too cold.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後のelse節は同じままです、そしてそれはあまり暖かくもなくあまり寒くもないすべての気温に対しての応答を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final case, case let (x, y), declares a tuple of two placeholder constants that can match any value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後のケース節、case let (x, y)は、どんな値にでも適合することができるプレースホルダ定数を２つもつタプルを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final class in this model is called Address.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このモデルの中の最後のクラスは、Addressと呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final code snippet above shows that the deinitializers for the Customer instance and CreditCard instance both print their “deinitialized” messages after the john variable is set to nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の最後のコード断片は、CustomerインスタンスとCreditCardインスタンスのためのデイニシャライザが両方ともそれらの「デイニシャライズされた」メッセージを、john変数がnilに設定された後に出力することを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final snippet creates a constant array called library, which contains two Movie instances and three Song instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最終的な断片はlibraryと呼ばれる定数の配列をつくります、それは、２つのMovieインスタンスと３つのSongインスタンスを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first Rect initializer, init(), is functionally the same as the default initializer that the structure would have received if it did not have its own custom initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のRectイニシャライザ、init()は、構造体が独自のあつらえのイニシャライザを持たない場合に受け取る省略時のイニシャライザと機能的に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first and second requirements are defined in the function’s type parameter list, and the third and fourth requirements are defined in the function’s generic where clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初と２番目の要件は関数のもつ型パラメータリストにおいて定義されます、そして３番目と４番目の要件は関数のもつ総称体where節において定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first case, case (let x, 0), matches any point with a y value of 0 and assigns the point’s x value to the temporary constant x.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のケース節、case (let x, 0)は、0のy値をもつどんなポイントにでも適合して、そのポイントのx値を一時的な定数xに代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first dice roll always moves the player onto the board.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のさいころ振りは、常にプレーヤーを盤上で動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first example’s use of the ternary conditional operator means that rowHeight can be set to the correct value on a single line of code, which is more concise than the code used in the second example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の例の三項条件演算子の使用は、rowHeightがただ１行のコードで正しい値に設定されることができるのを意味します、それは２番目の例において使われるコードより簡潔です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first form allows code to be executed only when a condition is true and has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の形式は、条件が真である時にだけコードが実行されるようにし、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first form evaluates to the value of the expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の形式は、式の値に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first form is used to access a member of the superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の形式は、スーパークラスのメンバーにアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first form of a line control statement changes the values of the #line and #file literal expressions, beginning with the line of code following the line control statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の形式の行制御文は、#lineと#fileリテラル式の値を変更して、行制御文の後に続くコードの行で始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first function, printAndCount(string:), prints a string, and then returns its character count as an Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の関数、printAndCount(string:)は、ある文字列を出力して、それからその文字数をIntとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first initializer has a single initialization parameter with an argument label of fromFahrenheit and a parameter name of fahrenheit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のイニシャライザは、fromFahrenheitの引数ラベルとfahrenheitのパラメータ名を使うただ１つの初期化パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first is a type function called unlock(_:), which updates the value of highestUnlockedLevel whenever a new level is unlocked.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第一は、unlock(_:)と呼ばれる型関数です、それは、新しいレベルが錠を開けられるときはいつでも、highestUnlockedLevelの値を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first item in the array has an index of 0, not 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列での最初の項目が、1ではなく、0のインデックスを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first item in the array represents the top left square on the board and the last item in the array represents the bottom right square on the board.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の最初の項目は盤上の一番左上の正方形を表わします、そして配列の最後の項目は盤上の一番右下の正方形を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first kind of pattern is used for destructuring values in simple variable, constant, and optional bindings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の種類のパターンは、単純な変数、定数、およびオプショナル束縛での非構成の値に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first letter of the case name is capitalized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ケース節の最初の文字は大文字で書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first pair has a key of "YYZ" and a value of "Toronto Pearson".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の組みは、"YYZ"のキーと"Toronto Pearson"の値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first parameter is called mathFunction, and is of type (Int, Int) -&gt; Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のパラメータはmathFunctionと呼ばれていて、型(Int, Int) -&gt; Intです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first snippet defines a new base class called MediaItem.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の断片は、MediaItemと呼ばれる新しい基盤クラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first subclass, Movie, encapsulates additional information about a movie or film.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のサブクラスMovieは、映画またはフィルムに関する追加の情報をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first two calls succeed, because the testScores dictionary contains keys for "Dave" and "Bev".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の２つの呼び出しは成功します、なぜなら、testScores辞書は"Dave"と"Bev"のキーを含んでいるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first two properties, buildingName and buildingNumber, are alternative ways to identify a particular building as part of an address.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の２つのプロパティ、buildingNameとbuildingNumberは、アドレスの一部として特定の建物を同定するそれぞれ代替の方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first type parameter, T, has a type constraint that requires T to be a subclass of SomeClass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の型パラメータTは、TにSomeClassのサブクラスであることを要求する型制約を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first, resolution, is initialized with a new Resolution structure instance, which infers a property type of Resolution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一番目、resolutionは、新しいResolution構造体インスタンスで初期化されます、そしてそれは、Resolutionのプロパティ型を暗に意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first, thresholdLevel, defines the maximum threshold value an audio level can take.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その一番目、thresholdLevelは、音声レベルがとることができる最大の限界値を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fixity of the operator is specified by marking the operator declaration with the infix, prefix, or postfix declaration modifier before the operator keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子の定着性は、演算子定義をoperatorキーワードの前にinfix、prefix、またはpostfix宣言修飾子を使って印することによって指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following if statements are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のif文は同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following approaches are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の各取り組みは同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following are examples of literals:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下はリテラルの例です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following characters are considered whitespace: space (U+0020), line feed (U+000A), carriage return (U+000D), horizontal tab (U+0009), vertical tab (U+000B), form feed (U+000C) and null (U+0000).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の文字は、空白とみなされます：空白（U+0020）、行送り（U+000A）、復帰（U+000D）、水平タブ（U+0009）、垂直タブ（U+000B）、改ページ（U+000C）およびヌル（U+0000）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following closure expressions are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のクロージャ式は、等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example adds a new instance method called repetitions to the Int type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、repetitionsと呼ばれる新しいインスタンスメソッドをInt型に加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a Matrix structure, which represents a two-dimensional matrix of Double values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例はMatrix構造体を定義します、それはDouble値からなる２次元行列を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a class called SurveyQuestion, with an optional String property called response:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、responseと呼ばれるオプショナルのStringプロパティで、SurveyQuestionと呼ばれるクラスを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a custom Rect structure to represent a geometric rectangle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、あつらえのRect構造体を定義して、幾何学的な長方形を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a new class called AutomaticCar, which is a subclass of Car.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例はAutomaticCarと呼ばれる新しいクラスを定義します、それは、Carのサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a new class called Car, which is a subclass of Vehicle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、Carと呼ばれる新しいクラスを定義します、それは、Vehicleのサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a new custom infix operator called +-, which belongs to the precedence group AdditionPrecedence:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、+-と呼びれる新しいあつらえの接中辞演算子を定義します、それは優先順位グループAdditionPrecedenceに属します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a new subclass of Vehicle called Train, which overrides the makeNoise() method that Train inherits from Vehicle:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、Trainと呼ばれるVehicleの新しいサブクラスを定義します、それは、TrainがVehicleから受け継ぐmakeNoise()メソッドをオーバーライドします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a protocol with a single instance method requirement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、１つのインスタンスメソッド要件で、プロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a structure called Celsius, which stores temperatures expressed in degrees Celsius.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、Celsiusと呼ばれる構造体を定義します、それは、摂氏度数で表される温度を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a structure called Color, with three constant properties called red, green, and blue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例はColorと呼ばれる構造体を定義します、それはred、green、そしてblueと呼ばれる３つの定数プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a subclass called Bicycle, with a superclass of Vehicle:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、Vehicleのスーパークラスを持つ、Bicycleと呼ばれるサブクラスを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines an integer-counting class called Counter, which uses an external data source to provide its increment amount.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例はCounterと呼ばれる整数計数クラスを定義します、それは、その増加量を提供するために外部のデータ・ソースを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines two classes, Customer and CreditCard, which model a bank customer and a possible credit card for that customer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は２つのクラス、CustomerとCreditCardを定義します、それは、銀行顧客とその顧客のために可能なクレジットカードをモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example extends the generic Stack type to add a read-only computed property called topItem, which returns the top item on the stack without popping it from the stack:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は総称体Stack型を拡張して、topItemと呼ばれる読み出し専用の計算プロパティを加えます、それは、スタックの一番上の項目をスタックからそれをポップすることなく返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example removes all vowels and spaces from a lowercase string to create a cryptic puzzle phrase:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、秘密の謎の語句をつくるために、小文字の文字列から全ての母音と空白を削除します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example replaces "Chocolate Spread", "Cheese", and "Butter" with "Bananas" and "Apples":</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、"Chocolate Spread"、"Cheese"、そして"Butter"を、"Bananas"および"Apples"と取り替えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example reports a compile-time error:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、コンパイル時エラーを報告します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows designated initializers, convenience initializers, and automatic initializer inheritance in action.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、指定イニシャライザ、便宜イニシャライザ、そして自動的なイニシャライザ継承の動作を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows the behavior of the example above without using optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、オプショナル連鎖を使うことなく上の例の挙動を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows the difference in behavior between an optional string and an implicitly unwrapped optional string when accessing their wrapped value as an explicit String:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、オプショナルの文字列と、暗黙的にアンラップされるオプショナルの文字列の間での、明示的なStringとしてラップされるそれらにアクセスする場合での、挙動の違いを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example switches on a Character value and determines whether it represents a number symbol in one of four languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、あるCharacter値に基づいて切り替えて、それが数字シンボルを４つの言語のうちの一つで表わすかどうかを明らかにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example uses the break and continue statements with a labeled while loop for an adapted version of the Snakes and Ladders game that you saw earlier in this chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、breakとcontinue文をラベルが付いたwhileループと一緒に、あなたがこの章で以前に見た「ヘビとはしご」ゲームの改作板のために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares a computed variable or computed property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、計算変数または計算プロパティを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares a new infix operator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、新しい接中辞演算子を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares a new postfix operator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、新しい接尾辞演算子を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares a new prefix operator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、新しい接頭辞演算子を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares a stored variable or stored variable property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、保存変数または保存変数プロパティを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares an enumeration type that contains enumeration cases of any type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、随意の型の列挙ケース節を含む列挙型を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares an enumeration type that contains enumeration cases of the same basic type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、同じ基本の型をもつ列挙ケース節たちを含む列挙型を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares initializers for structures, enumerations, and designated initializers of classes:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、構造体、列挙のイニシャライザ、そしてクラスの指定イニシャライザを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following function calls are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の関数呼び出しは、等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following keywords are reserved and can’t be used as identifiers, unless they’re escaped with backticks, as described above in Identifiers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の識別子で記述されるように、以下のキーワードは予約済で、それらがバッククォートでエスケープされない限り、識別子として使われることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following requirements are placed on the function’s two type parameters:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の要件は、この関数の持つ２つの型パラメータ上に置かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following statement is not valid:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の文は、有効ではありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following tokens are reserved as punctuation and can’t be used as custom operators: (, ), {, }, [, ], ., ,, :, ;, =, @, #, &amp; (as a prefix operator), -&gt;, `, ?, and ! (as a postfix operator).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のトークンは、句読点として予約されます、そしてあつらえの演算子として使われることができません：(, ), {, }, [, ], ., ,, :, ;, =, @, #, &amp;（接頭辞演算子として）, -&gt;, `, ?, そして!（接尾辞演算子として）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The forced form, as!, attempts the downcast and force-unwraps the result as a single compound action.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強制形式as!は、一回の複合動作として、ダウンキャストとその結果の強制アンラップを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fourth codeUnit value (8252) is a decimal equivalent of the hexadecimal value 203C, which represents the Unicode scalar U+203C for the DOUBLE EXCLAMATION MARK character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>４番目のcodeUnit値（8252）は、16進数の値203Cです、それは、DOUBLE EXCLAMATION MARK文字に対するユニコード・スカラーU+203Cを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fourth codeUnit value (8252) is again a decimal equivalent of the hexadecimal value 203C, which represents the Unicode scalar U+203C for the DOUBLE EXCLAMATION MARK character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>４番目のcodeUnit値（8252）は、ふたたび16進数値203Cの10進の等価物です、それは、DOUBLE EXCLAMATION MARK文字に対するユニコード・スカラーU+203Cを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function definition still needs parentheses after the function’s name, even though it does not take any parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえそれが全くパラメータをとらないとしても、関数定義は依然として関数の名前の後に丸括弧を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function in the example below is called greet(person:), because that’s what it does—it takes a person’s name as input and returns a greeting for that person.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例の関数は、それがすることから、greet(person:)と呼ばれます ― それは、入力としてある人の名前をとって、その人のために挨拶を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function it returns has no parameters, and returns an Int value each time it is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが返す関数は、パラメータを持たず、それが呼ばれるたびにInt値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function name is also followed by an empty pair of parentheses when the function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関数が呼ばれるとき、関数名の後にまた空の丸括弧の対が続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function performs this swap by storing the value of a in a temporary constant called temporaryA, assigning the value of b to a, and then assigning temporaryA to b.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数はこの交換を、aの値をtemporaryAと呼ばれる一時的な定数の中に保存して、bの値をaに代入して、それからtemporaryAをbに代入することによって実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function prints “Function was called” before returning a value, which lets you see whether the right hand side of the = operator was evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は、値を返す前に「Function was called（関数は呼び出された）」を出力します、それはあなたに=演算子の右手側が評価されたかどうかをわかるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function returns a Boolean value of true if all items match and a value of false if they do not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は全ての項目が合致するならばブール値のtrueを、それらがそうしないならばfalseの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function returns a tailored greeting in each case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、それぞれの状況に合った挨拶を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function returns after it starts the operation, but the closure isn’t called until the operation is completed—the closure needs to escape, to be called later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、それが演算を開始した後に戻ります、しかしクロージャはその演算が完了されるまで呼び出されません—このクロージャは脱出する、後で呼び出される、必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function then considers the value of integerToDescribe using a switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、それからswitch文を使ってintegerToDescribeの値を考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function then iterates over the remaining values in the array and checks each value to see if it is smaller or larger than the values of currentMin and currentMax respectively.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数はそれから、配列の残りの値すべてに渡って繰り返します、そして各値をそれがcurrentMinおよびcurrentMaxの値より小さいかより大きいかそれぞれについて調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function value carries no context and uses the C calling convention.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数値は、コンテキストを持ち運ばず、C呼出規約を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function value is represented as a reference to the block object, which is an id-compatible Objective-C object that embeds its invocation function within the object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数値はそのプロックオブジェクトへの参照として表現されます、それはid互換Objective-Cオブジェクトで、それの呼出関数がそのオブジェクト内部に埋め込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function’s return type is a tuple type composed from two of the custom classes defined above in Custom Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数の戻り型は、上のあつらえの型で定義されるあつらえのクラスのうちの２つから作られるタプル型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The game board is represented by an array of Int values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲーム盤は、Int値の配列によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The game board is the same as before.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲーム盤は、前と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generic version of the function uses a placeholder type name (called T, in this case) instead of an actual type name (such as Int, String, or Double).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数の総称体版は、プレースホルダ型名（この場合、Tと呼ばれるもの）を実際の型名（例えばInt、String、またはDouble）の代わりに使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The getter and setter requirements can be satisfied by a conforming type in a variety of ways.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲッターとセッター要件は、準拠している型によっていろいろなやり方で満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The getter is used to read the value, and the setter is used to write the value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲッターが値を読むために使われます、そしてセッターが値を書くために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The given expression is evaluated when the function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>与えられた式は、関数が呼び出される時に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The global and local variables you have encountered in previous chapters have all been stored variables.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが前の章において遭遇したグローバルおよびローカル変数は、すべて保存変数でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The grammar described here is intended to help you understand the language in more detail, rather than to allow you to directly implement a parser or compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここで記述される文法は、あなたが更に詳細に言語を理解するのを手伝うつもりのもので、あなたに直ちにパーサーまたはコンパイラを実装させるようにするものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The grammar production above is equivalent to the following two productions, where the alternatives are spelled out explicitly:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の文法導出は以下の２つの導出に等しいです、そこでは代替物がそれぞれ分けて書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hexadecimal fraction consists of a decimal point followed by a sequence of hexadecimal digits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>16進の小数部は、小数点に続く一連の16進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hypothetical function above has two type parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の仮定の関数は、２つの型パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The illustration below depicts three sets—a, b and c—with overlapping regions representing elements shared among sets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の図は３つの集合—a、b、そしてc—を集合間で共有される要素を表している重なり合う領域とともに描写します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The illustration below depicts two sets—a and b—with the results of various set operations represented by the shaded regions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の図は、２つの集合—aとb—を網掛けの領域で表される様々な集合演算の結果とともに描写します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The illustration below shows the push / pop behavior for a stack:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のイラストは、あるスタックのプッシュ／ポップ挙動を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The illustration below shows the results of 11111111 &lt;&lt; 1 (which is 11111111 shifted to the left by 1 place), and 11111111 &gt;&gt; 1 (which is 11111111 shifted to the right by 1 place).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のイラストは、11111111 &lt;&lt; 1（それは、1桁だけ左へシフトされる11111111です）、そして11111111 &gt;&gt; 1（それは、1桁だけ右へシフトされる11111111です）の結果を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation of gameDidStart(_:) shown above uses the game parameter to print some introductory information about the game that is about to be played.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で示されるgameDidStart(_:)の実装は、gameパラメータを使って、プレイされようとしているゲームに関する若干の紹介の情報を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation of the vend(itemNamed:) method uses guard statements to exit the method early and throw appropriate errors if any of the requirements for purchasing a snack aren’t met.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>vend(itemNamed:)メソッドの実装はguard文を使って、購入スナックに必要な何かが満たされないならば早めにそのメソッドを終了して対応するエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The individual cases of an enumeration automatically receive the same access level as the enumeration they belong to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある列挙の個々のケース節は、自動的にそれらが属している列挙と同じアクセス水準を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The information about Accessing Properties Through Optional Chaining has been updated accordingly, and the examples of checking for method call success in Calling Methods Through Optional Chaining have been expanded to show how to check for property setting success.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を通してプロパティにアクセスするについての情報はそれを受けて更新されました、そしてオプショナル連鎖を通してメソッドを呼び出すの中のメソッド呼び出しがうまくいったかを確認する例は拡張されて、プロパティの設定がうまくいったかを確認する方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The inherited version of init() functions in exactly the same way as the Food version, except that it delegates to the RecipeIngredient version of init(name: String) rather than the Food version.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>init()の継承された改変板は、Food版と同じ正確に方法で機能しますが、それがFood板ではなくRecipeIngredient版のinit(name: String)に委任することを除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The init! Failable Initializer</seg>
      </tuv>
      <tuv lang="JA">
        <seg>init!失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initialization of airports could have been written in a shorter form instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>airportsの初期化は、代わりにより短い形式で書かれることもできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initialization of shoppingList could have been written in a shorter form instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>shoppingListの初期化は、前の代わりにより短い形式に書かれることもできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initialization of favoriteGenres could have been written in a shorter form instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>favoriteGenresの初期化は、代わりに次のような短い形式で書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializer expression can’t be present in a protocol declaration, but in all other contexts, the initializer expression is optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ式はプロトコル宣言に含まれることはできません、しかし全ての他の文脈ではそうではありません、イニシャライザ式は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializer expression is optional in the context of a class or structure declaration, but required elsewhere.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ式は、クラスまたは構造体宣言の文脈では任意です、しかしその他では必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializer call Celsius(37.0) is clear in its intent without the need for an argument label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ呼び出しCelsius(37.0)は、引数ラベルを必要としなくともその意図は明快です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializer can then fail if the provided parameters do not match an appropriate enumeration case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、提供されたパラメータが適切な列挙ケース節に適合しないならばその時に失敗できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializer for City is called from within the initializer for Country.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cityのためのイニシャライザは、Countryのためにイニシャライザの内部から呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializer then calls the structure’s automatic memberwise initializer init(origin:size:), which stores the new origin and size values in the appropriate properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザはそれから、構造体の自動的なメンバー関連イニシャライザinit(origin:size:)を呼びます、それは、新しい原点とサイズ値を適切なプロパティに保管します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The instances can then refer to each other without creating a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスは、そのあと強い参照循環をつくることなくお互いに言及することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The instance’s asHTML property holds a strong reference to its closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このインスタンスのasHTMLプロパティは、それのクロージャに対する強い参照を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The integers start at zero and count up by one for each item; if you enumerate over a whole array, these integers match the items’ indices.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その整数はゼロから始めて各項目に対して１ずつ数えていきます；あなたが配列全体をすべて列挙するならば、それらの整数はそれら項目のもつインデックスと一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interpolated expression can contain a string literal, but can’t contain an unescaped backslash (\), a carriage return, or a line feed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>差し込まれた式は、文字列リテラルを含むことができます、しかしエスケープされないバックスラッシュ（\）、キャリッジリターン、またはラインフィードを含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The invocation function uses the C calling convention.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この呼出関数はC呼出規約を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The items in someContainer can be checked with the not equal operator (!=) to see if they are different from each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>someContainerの中の項目は、それらがお互いと異なるかどうか見るために不等演算子（!=）を使って確認されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The items stored in library are still Movie and Song instances behind the scenes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>libraryに保存される項目は、依然として舞台裏ではMovieとSongインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key type of a dictionary must conform to the Swift standard library Hashable protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある辞書のキーの型は、スウィフト標準ライブラリHashableプロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key-value pairs are written as a list, separated by commas, surrounded by a pair of square brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「キーと値」の対はリストとして書かれます、それはコンマで区切られ、一対の角括弧に囲まれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last argument, *, is required and specifies that on any other platform, the body of the if executes on the minimum deployment target specified by your target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後の引数*は、必要で、あらゆる他のプラットホーム上を指定します、ifの本文は、あなたの対象で指定される、最小の開発対象で実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last expression in the array can be followed by an optional comma.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の最後の式の後に、１つの任意のコンマが続くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last expression in the dictionary can be followed by an optional comma.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書の最後の式の後に、１つの任意のコンマが続くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last four codeUnit values (240, 159, 144, 182) are a four-byte UTF-8 representation of the DOG FACE character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後の４つのcodeUnit値（240、159、144、182）は、DOG FACE文字の４バイトUTF-８叙述です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The length of an NSString is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるNSStringの長さは、その文字列のUTF-16表現内の16ビットコード単位の数に基づきます、その文字列内のユニコード拡張書記素クラスタの数ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The letter é can be represented as the single Unicode scalar é (LATIN SMALL LETTER E WITH ACUTE, or U+00E9).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字éは、単一のユニコード・スカラーé（LATIN SMALL LETTER E WITH ACUTE、またはU+00E9）として表わされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The line number on which it appears.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが現れる行番号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The listing below does the same assignment, but it uses a function to create the address.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下でのコード出力は、同じ代入を行います、しかしそれはある関数を使ってアドレスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The literal value 3 can be added directly to the literal value 0.14159, because number literals do not have an explicit type in and of themselves.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラル値3は、直接にリテラル値0.14159に加えられることができます、なぜなら数リテラルがそれら自身において明確な型を持たないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The literal value of 3 has no explicit type in and of itself, and so an appropriate output type of Double is inferred from the presence of a floating-point literal as part of the addition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラル値3は明確な型をそれ自体は持ちません、それで適切な出力のDouble型は、加算部分の浮動小数点リテラルの存在から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The logical NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理否定演算子は接頭辞演算子です、そして全く空白なしで、それが作用する値の直前に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The loop then ends, and control returns to the while condition to decide whether another turn is required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループはそれから終わります、そして制御はもう一つの回が必要かどうか決めるためにwhile条件に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The loop’s condition (while square &lt; finalSquare) is the same as before, but this time it’s not evaluated until the end of the first run through the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループの条件（while square &lt; finalSquare）は前と同じものです、しかし今回それは最初のループ通り抜けの終わりまで評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main difference is that during phase 1, Objective-C assigns zero or null values (such as 0 or nil) to every property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>主な違いは、段階１の間に、Objective-Cがゼロまたは無効な値（例えば0またはnil）をあらゆるプロパティに代入するということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main difference is that optional chaining fails gracefully when the optional is nil, whereas forced unwrapping triggers a runtime error when the optional is nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>大きな違いは、オプショナル連鎖はそのオプショナルがnilであるとき潔く失敗します、だけれども強制アンラップはそのオプショナルがnilであるとき実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main exception to this rule occurs when a parameter name for an instance method has the same name as a property of that instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この規則に対する主な例外は、インスタンスメソッドのパラメータ名がそのインスタンスのプロパティと同じ名前を持つ時に起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The matches succeeds if the ~= operator returns true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>~=演算子がtrueを返すならば、マッチは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The members of a module access the top-level declarations of that module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>モジュールのメンバーは、そのモジュールのトップレベルの宣言にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The members of a named type are named as part of the type’s declaration or extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前付きの型に属するメンバーは、型の宣言または拡張の一部として命名されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The members of a tuple are implicitly named using integers in the order they appear, starting from zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルのメンバーは、整数を使って、それらが現れる順序で、ゼロから始めて、暗黙のうちに名前をつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The memberwise initializer is a shorthand way to initialize the member properties of new structure instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メンバー関連イニシャライザは、新しい構造体インスタンスのメンバープロパティを初期化するための略記方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The memory for these stored properties is now initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの保存プロパティに対するメモリは、今や初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The memory is not yet initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのメモリは、まだ初期化されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The metatype of a class, structure, or enumeration type is the name of that type followed by .Type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラス、構造体、または列挙型のメタタイプは、その型の名前に.Typeが続くものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The metatype of a protocol type—not the concrete type that conforms to the protocol at runtime—is the name of that protocol followed by .Protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコル型 ― 実行時にそのプロトコルに準拠する具体的な型ではない ― のメタタイプは、そのプロトコルの名前に.Protocolが続くものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method can also assign a completely new instance to its implicit self property, and this new instance will replace the existing one when the method ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドはまた、完全に新しいインスタンスをその暗黙のselfプロパティに代入することができます、そして、そのメソッドが終了するとき、この新しいインスタンスは既存のものを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method can then mutate (that is, change) its properties from within the method, and any changes that it makes are written back to the original structure when the method ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドはそれからそれのプロパティをメソッド内部から変化させること（すなわち変更）ができます、そして、そのメソッドが終了するとき、それが行ったどんな変更も本来の構造体へ書き込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method returns a new Vector2D instance, whose x and y properties are initialized with the sum of the x and y properties from the two Vector2D instances that are added together.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドは、新しいVector2Dインスタンスを返します、それはxとyプロパティが一緒に加えられる２つのVector2Dインスタンスからのxとyプロパティの合計で初期化されるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The minimum value that a UInt8 can hold is zero, or 00000000 in binary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>UInt8が持つことができる最小限の値は、０、または２進数では00000000です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The minimum value that an Int8 can hold is -128, or 10000000 in binary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Int8が持つことができる最小限の数は、-128、または２進数での10000000です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of each case must be unique.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各ケース節の名前は、固有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of the declaration in which it appears.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが現れる宣言の名前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of the file in which it appears.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが現れるファイルの名前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nature of the mapping and the type of the returned value is left up to the closure to specify.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マッピング（対応付け）の性質と返される値の型は、指定するクロージャに委ねられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nearest thing in Objective-C is the ability to return nil from a method that would otherwise return an object, with nil meaning “the absence of a valid object.” However, this only works for objects—it doesn’t work for structures, basic C types, or enumeration values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cにおいて最も近いものは、オブジェクトを返すメソッドからそうできない場合にnilを返す能力です、そのときnilは「有効なオブジェクトの欠如」を意味しています。しかし、それは単にオブジェクトのためだけに働きます ― それは構造体、基本的なC型、または列挙値のために働きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nested incrementer() function captures two values, runningTotal and amount, from its surrounding context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされたincrementer()関数は、それを取り囲む前後関係から２つの値、runningTotalとamountを捕獲します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nested enumeration can now be used with any Int value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた列挙は今やあらゆるInt値で使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new Bicycle class automatically gains all of the characteristics of Vehicle, such as its currentSpeed and description properties and its makeNoise() method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この新しいBicycleクラスは、自動的にVehicleのすべての特徴を獲得します、例えばそれのcurrentSpeedおよびdescriptionプロパティやそれのmakeNoise()メソッドなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new array’s type is inferred from the type of the two arrays you add together:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい配列の型は、あなたが一緒に加える２つの配列の型から推論されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new name is displayed by the compiler when emitting an error about the use of a renamed declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい名前は、改名された宣言の使用についてのエラーを発するときにコンパイラによって表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new type can then be used wherever its access level permits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その新しい型はそれから、そのアクセス水準が許すところどこででも使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new value is passed to the willSet observer as a constant, and therefore it can’t be changed in the implementation of the willSet clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい値は、定数としてwillSetオブザーバーに渡されます、したがって、それはwillSet節の実装の中で変更されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next code snippet defines three variables of type Person?, which are used to set up multiple references to a new Person instance in subsequent code snippets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のコード断片は、型Person?の３つの変数を定義します、それは、以降のコード断片の中のある１つの新しいPersonインスタンスへの複数の参照を準備するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next example creates a subclass of Bicycle for a two-seater bicycle known as a “tandem”:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の例は、「タンデム」として知られる２座席自転車のために、Bicycleのサブクラスを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next example defines a subclass of Document called AutomaticallyNamedDocument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の例は、AutomaticallyNamedDocumentとよばれるDocumentのサブクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next example defines a subclass of Vehicle called Bicycle:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の例は、Bicycleと呼ばれるVehicleのサブクラスを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next example defines two simple functions called stepForward(_:) and stepBackward(_:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の例は、stepForward(_:)とstepBackward(_:)と呼ばれる２つの単純な関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next several code snippets demonstrate how optional chaining differs from forced unwrapping and enables you to check for success.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のいくつかのコード切れっぱしは、どのようにオプショナル連鎖が強制アンラップと異なるか、そして成功をどのようにあなたが確認できるかを例示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next snippet defines two subclasses of MediaItem.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の断片は、MediaItemの２つのサブクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next subscript index to the right refers to the element at that index in the array that’s nested one level in.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の右の添え字インデックスは、１段階内側の入れ子にされた配列の中のそのインデックスでの要素に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next three decimal codeUnit values (226, 128, 188) are a three-byte UTF-8 representation of the DOUBLE EXCLAMATION MARK character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の３つの10進のcodeUnit値（226、128、188）は、DOUBLE EXCLAMATION MARK文字の３バイトUTF-8叙述です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nil-coalescing operator is shorthand for the code below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>nil合体演算子は、以下のコードに対する簡略形です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nil-coalescing operator provides a more elegant way to encapsulate this conditional checking and unwrapping in a concise and readable form.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>nil合体演算子は、この条件検査およびアンラップを簡潔で判読しやすい形式にカプセル化するより洗練された方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The notation used to describe the formal grammar of the Swift programming language follows a few conventions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトプログラミング言語の形式文法を記述するために使用される表記法は、２、３の規則に従います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The observers are not called when the variable or property is first initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブザーバーは、変数またはプロパティが最初に初期化されるときには呼ばれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only difference is the type of the values that they accept (Int, String, and Double).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>唯一の違いは、それらが受け入れる値の型（Int、String、そしてDouble）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only exception is for required initializers (as defined in Required Initializers).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>唯一の例外は、必須イニシャライザに対してです（必須イニシャライザで定義されるように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only remaining strong reference to the Apartment instance is from the unit4A variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Apartmentインスタンスへの唯一の残っている強い参照は、unit4A変数からです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator method is defined as a type method on Vector2D, with a method name that matches the operator to be overloaded (+).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この演算子メソッドは、Vector2D上で型メソッドとして定義され、オーバーロードされる演算子と一致するメソッド名を持ちます（+）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator returns a new number whose bits are set to 1 if the bits are equal to 1 in either input number:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この演算子は、どちらかの入力数においてビットが1と等しいならばビットが1に設定される、ある新しい数を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator returns a new number whose bits are set to 1 where the input bits are different and are set to 0 where the input bits are the same:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この演算子は、入力ビットたちが異なっている所で1に設定され、入力ビットたちが同じである所で0に設定される、ある新しい数を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optimized behavior is known as call by reference; it satisfies all of the requirements of the copy-in copy-out model while removing the overhead of copying.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この最適化挙動は、参照呼び出しとして知られます；それはコピーイン・コピーアウトモデルの要件の全てを満足させる一方でコピーすることのオーバーヘッド（間接的経費）を取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional Int is accessed through optional binding to unwrap the integer and assign the nonoptional value to the roomCount variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルのIntは、オプショナル束縛を通してアクセスされることで、整数をアンラップして取り出して、その非オプショナル値をroomCount変数へ割り当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional version number consists of one or more positive integers, separated by periods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルのバージョン番号は、ビリオドで区切られた、１つ以上の正の整数から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional chaining question mark always follows immediately after the part of the expression that is optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖の疑問符は、常にオプショナルである式部分の直後に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional chaining question mark in this subscript call is placed immediately after john.residence, before the subscript brackets, because john.residence is the optional value on which optional chaining is being attempted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この添え字呼び出しでのオプショナル連鎖の疑問符は、john.residenceの直後、添え字の角括弧の前に置かれます、なぜなら、john.residenceがオプショナル連鎖が試みられているオプショナルの値であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional lets you track whether there is currently a player in the game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルは、プレーヤーが現在ゲーム中かどうかあなたに追跡させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional pattern provides a convenient way to iterate over an array of optional values in a for-in statement, executing the body of the loop only for non-nil elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルパターンは、for-in文においてオプショナルの値がはいった配列の全体にわたって、ループの本文を非nilの要素のみに実行して、繰り返すための便利な方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The order in which modifiers are specified when defining Custom Operators has changed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの演算子を定義する時に修飾子が指定される順番は変更されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The order of arguments in a function call must match the order of parameters in the function’s declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数呼び出しにおける引数の順序は、関数の宣言におけるパラメータの順番と一致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original array is not modified by the sorted(by:) method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>元の配列は、sorted(by:)メソッドによって修正されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other difference is that the generic function’s name (swapTwoValues(_:_:)) is followed by the placeholder type name (T) inside angle brackets (&lt;T&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の違いは、総称体関数の名前（swapTwoValues(_:_:)）は、後ろにプレースホルダ型名（T）が山形括弧内部（&lt;T&gt;）で続くということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other variation of the while loop, known as the repeat-while loop, performs a single pass through the loop block first, before considering the loop’s condition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>whileループのもう一方の変種、repeat-whileループとして知られるものは、ループの条件を考慮する前に、最初に一度だけループ・ブロックの通り抜けを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output constant (twoThousandAndOne) is inferred to be of type UInt16, because it is the sum of two UInt16 values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>出力された定数（twoThousandAndOne）は、型UInt16であると推測されます、それが２つのUInt16値の合計であるので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the compound expression doesn’t change, but the overall intention is clearer to the reader.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合式の出力は変わりません、しかし全体的な意図は読者にとってより明らかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The override of the description property starts by calling super.description, which returns the Vehicle class’s description property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>descriptionプロパティのオーバーライドは、super.descriptionを呼び出すことで始まります、それはVehicleクラスのdescriptionプロパティを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parameter name is used in the implementation of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ名は、関数の実装内において使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parentheses around a tuple pattern that contains a single element have no effect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ただ１つだけの要素を含むタプルパターンのまわりの丸括弧には、効果がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parentheses make it clear that the first two values are considered as part of a separate possible state in the overall logic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>丸括弧は、最初の２つの値が全体的な論理の中で１つの隔てられたあり得る状態の部分として考慮されることを明白にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pattern matches values of that single element’s type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターンは、そのただ１つの要素の型の値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The patterns can be written over multiple lines if the list is long.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのパターンは、そのリストが長いならば、複数行にわたって書かれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The phrase if !allowedEntry can be read as “if not allowed entry.” The subsequent line is only executed if “not allowed entry” is true; that is, if allowedEntry is false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>語句if !allowedEntryは、「許されたエントリでないならば」と読まれることができます。続く行は「許されたエントリでない」が真である場合；すなわち、allowedEntryがfalseである場合に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The phrase “of type String” means “can store any String value.” Think of it as meaning “the type of thing” (or “the kind of thing”) that can be stored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>フレーズ「型Stringの」は、「どんなString値でも保存することができる」ことを意味します。それを、保存されることができる「物の型」（または「物の種類」）の意味と思ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The placeholder type name doesn’t say anything about what T must be, but it does say that both a and b must be of the same type T, whatever T represents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレースホルダ型名はTが何でなければならないかについて何も言いません、しかし、aとbの両方ともが同じ型Tでなければならないと述べます、Tが表わすものが何であれ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The player has now left the game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレーヤーは、現在ゲームから離れました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The player moves forward by diceRoll squares, and the game logic checks for any snakes and ladders.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレーヤーはdiceRoll分の正方形を前進します、そして、ゲーム論理はあらゆるヘビとはしごについて調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The player’s purse now contains 2,100 coins, and the bank has only 7,900 coins left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレーヤーの財布は現在2,100個のコインを含みます、そして、胴元は7,900個のコインだけが残っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The player’s starting square is “square zero”, which is just off the bottom-left corner of the board.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレーヤーの出発する正方形は「正方形ゼロ」です、それは、盤の左下の角からちょっと離れています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The point (0, 0) would match case (0, 0) first, and so all other matching cases would be ignored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>点(0, 0)は最初のcase (0, 0)に合います、それで他の適合するケース節すべては無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The postfix ? operator makes an optional-chaining expression from an expression without changing the expression’s value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞?演算子は、オプショナル連鎖式をある式から、その式の値を変更することなく作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The precedence of an operator specifies how tightly the operator binds to its operands, in the absence of grouping parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある演算子の優先順位は、どのくらいきつくその演算子をそれの演算数に束縛するかを、グループ化の丸括弧がないところで指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The preceding example creates a new Matrix instance with two rows and two columns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前の例は、２つの行と２つの列で新しいMatrixインスタンスをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The preceding example creates a new Rect variable called square.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前の例は、squareと呼ばれる新しいRect変数をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The preceding example determines whether a positive or negative step is needed to move a variable called currentValue progressively closer to zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前の例は、currentValueと呼ばれる変数を次第にゼロにより近く動かすために正と負の一歩のどちらが必要とされるかを確定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The preceding example is shorthand for the code below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前の例は、下のコードの短縮形です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The present section describes which characters can be used to define custom operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いま目の前の節は、どの文字があつらえの演算子を定義するために使われることができるかを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous example shows how to retrieve the value of a property of optional type through optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前の例は、オプショナル連鎖を通してオプショナルの型のプロパティの値を取り出す方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The primary use of implicitly unwrapped optionals in Swift is during class initialization, as described in Unowned References and Implicitly Unwrapped Optional Properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでの暗黙的にアンラップされるオプショナルの主要な利用法は、非所有参照と暗黙的にアンラップされるオプショナルのプロパティで記述されるように、クラス初期化の間にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The principle of finding the index of a value in an array isn’t useful only for strings, however.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、配列の中の値のインデックスを見つける原理は、文字列のためにだけ役立つわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem lies with the equality check, “if value == valueToFind”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>問題は、同等性検査if value == valueToFindに横たわります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process is repeated until number is equal to 0, at which point the output string is returned by the closure, and is added to the output array by the map(_:) method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この処理はnumberが0に等しくなるまで繰り返されます、その時点でoutput文字列がクロージャによって返されて、そしてmap(_:)メソッドによって出力配列に加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process of defining your own implementations of the “equal to” and “not equal to” operators is described in Equivalence Operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「同等」および「不等」演算子のあなた独自の実施を定義する過程は、同等演算子で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process of initializing a structure’s declared properties is described in Initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある構造体の宣言されたプロパティを初期化する過程は、初期化で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program begins executing a loop by calling the next() method on the iterator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プログラムは、そのイテレータ上でnext()メソッドを呼ぶことによってループの実行を始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program executes the statements, and execution continues to step 2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プログラムが文を実行します、そして実行はステップ２に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program executes the statements, and execution returns to step 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プログラムは文を実行します、そして実行はステップ１に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol also specifies whether each property must be gettable or gettable and settable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルはまた、各プロパティが取得可能または取得可能かつまた設定可能でなければならないかどうか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのプロトコルは、それから、クラス、構造体、または列挙によって採用されることで、それらの要件の実際の実装を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol does not define what ItemType is—that information is left for any conforming type to provide.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは、ItemTypeが何であるかを定義しません ― その情報は、何であれそれに準拠する型が提供するようにそのままにされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol doesn’t specify anything else about the nature of the conforming type—it only specifies that the type must be able to provide a full name for itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは、その準拠型の性質について何ら指定しません ― それはただその型がそれ自身のフルネームを提供できなければならないことだけを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol doesn’t specify whether the property should be a stored property or a computed property—it only specifies the required property name and type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、そのプロパティが保存プロパティまたは計算プロパティでなければならないかどうかは指定しません ― それは、必要なプロパティ名と型を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol name is provided after the type name, separated by a colon, and an implementation of all requirements of the protocol is provided within the extension’s curly braces.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル名は、型名の後にコロンで区切られて提供されます、そして、プロトコルの全ての要件の実装は、拡張の波括弧内で提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol only specifies the three bits of functionality that any type must provide in order to be considered a Container.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、どんな型でもContainerとみなされるためには提供しなければならない小さな３つの機能性を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol states that any FullyNamed type must have a gettable instance property called fullName, which is of type String.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは、あらゆるFullyNamed型はfullNameと呼ばれる、String型である、取得可能なインスタンスプロパティを持たなければならないことを述べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The question mark indicates that the value it contains is optional, meaning that it might contain some Int value, or it might contain no value at all.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>疑問符はそれが含む値がオプショナルであることを示します、そしてそれが何かのInt値を含むかもしれない、あるいはそれがまったく値を含まないかもしれないことを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The range of numbers that can be stored in an integer constant or variable is different for each numeric type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数の定数または変数に保存されることができる数の範囲は、それぞれの数の型で異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The raw value for a particular enumeration case is always the same.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定の列挙ケース節のための生の値は、常に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The raw value initializer is a failable initializer, because not every raw value will return an enumeration case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値のイニシャライザは、失敗できるイニシャライザです、なぜなら、すべての生の値が列挙ケース節を返すわけではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The red component is obtained by performing a bitwise AND between the numbers 0xCC6699 and 0xFF0000.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>赤の構成要素は、数0xCC6699と0xFF0000との間のビット単位の論理積を実行することによって得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reference is called a “strong” reference because it keeps a firm hold on that instance, and does not allow it to be deallocated for as long as that strong reference remains.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この参照が「強い」参照と呼ばれるのはそれがそのインスタンスに対する堅い支配力を保つからです、そしてその強い参照が残る限りは、そのインスタンスがメモリ割り当て解除されるのを許しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The relationship between Customer and CreditCard is slightly different from the relationship between Apartment and Person seen in the weak reference example above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CustomerとCreditCardの関係は、上の弱い参照の例で見られるApartmentとPersonの関係と少しばかり異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remainder is treated the same way and may be split again.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>剰余は、同じ方法で扱われて、そして再び分割されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remainder operator (%) is also known as a modulo operator in other languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>剰余演算子（%）は、また、他の言語ではモジュロ演算子として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remaining arguments can appear in any order and specify additional information about the declaration’s lifecycle, including important milestones.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのままの引数は、任意の順番で現れることができます、そして重要なマイルストーンを含む、その宣言のライフサイクルについての追加の情報を指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remaining bits (known as the value bits) store the actual value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>残っているビット（値ビットとして知られるもの）は、実際の値を保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The response to a survey question cannot be known until it is asked, and so the response property is declared with a type of String?, or “optional String”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>意識調査への回答は、それが尋ねられるまでは知られることができません、なのでresponseプロパティはString?の型、すなわち「オプショナルのString」を使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is a sequence of diceRoll values that is always 1, 2, 3, 4, 5, 6, 1, 2 and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果は一連のdiceRoll値で、それは常に1、2、3、4、5、6、1、2など、となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is a specialized version of that generic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果は、その総称体型の特殊化版です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is exactly the same as if you place an exclamation mark after a normal optional that does not contain a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果は、あなたが値を含まない通常のオプショナルの後に感嘆符を置いた場合と正確に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result of item as? Movie is of type Movie?, or “optional Movie”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>item as? Movieの結果は、Movie?型、すなわち「オプショナルのMovie」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result of the i == 1 comparison is of type Bool, and so this second example passes the type-check.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>i == 1の比較の結果は型Boolです、それでこの第二の例は型チェックを通ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return type of makeIncrementer is () -&gt; Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>makeIncrementerの戻り型は、() -&gt; Intです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of john.residence?.address?.street is therefore also String?, even though two levels of optional chaining are applied in addition to the underlying optional type of the property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>john.residence?.address?.streetの戻り値は、したがってまた、String?です、その下のプロパティのオプショナル型に加えて２つのオプショナル連鎖の階層が適用されるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of a function can be ignored when it is called:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の戻り値は、それが呼ばれるとき無視されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned array value is stored in boardColors and can be queried with the squareIsBlackAtRow utility function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>返された配列値は、boardColorsに保存されて、便利な支援関数のsquareIsBlackAtRowで問い合わされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The role of printMathResult(_:_:_:) is to print the result of a call to a math function of an appropriate type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>printMathResult(_:_:_:)の役割は、適切な型の数学関数に対する呼び出しの結果を出力することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The row height should be 50 points taller than the content height if the row has a header, and 20 points taller if the row doesn’t have a header:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列の高さは、列にヘッダがあるならば内容の高さより50ポイント高く、列にヘッダがないならば20ポイント高くなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rules for combining numeric constants and variables are different from the rules for numeric literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数の定数や変数を結合することに対する規則は、数のリテラルに対する規則と異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rules for how initializer delegation works, and for what forms of delegation are allowed, are different for value types and class types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのようにイニシャライザ委任が働くか、そしてどんな委任の形式が許されるかの規則は、値型とクラス型で異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rules of the game are as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲームの規則は、次の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rules only affect how you write the implementation of the class’s initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの規則は、あなたがクラスのイニシャライザの実装を書く方法に影響を及ぼすだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same behavior applies to enumerations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じ挙動は、列挙にもあてはまります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same is not true for classes, which are reference types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じことはクラスにはあてはまりません、それは参照型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same is true for method parameters, because methods are just functions that are associated with a type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じことはメソッドパラメータにもあてはまります、なぜならメソッドは、あるひとつの型に結び付けられた単なる関数だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same is true if you attempt to set a property through optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じことは、あなたがプロパティをオプショナル連鎖を通して設定しようと試みる場合にも当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same method is applied when calculating the remainder for a negative value of a:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じメソッドが、負の値のaのための余りを計算するとき適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same product can be assigned a different type of barcode:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じ製品は、異なる型のバーコードを代入されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same value can appear in an array multiple times at different positions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じ値は、ひとつの配列の中で複数回異なる位置で現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The scope of a labeled statement is the entire statement following the statement label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラベルをつけられた文のスコープは、文ラベルに続いている文全体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The scope of each case can’t be empty.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのケース節のスコープは、空であることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second Rect initializer, init(origin:size:), is functionally the same as the memberwise initializer that the structure would have received if it did not have its own custom initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>二番目のRectイニシャライザ、init(origin:size:)は、構造体が独自のあつらえのイニシャライザを持たない場合に受け取る省略時のメンバー関連イニシャライザと機能的に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second and third parameters are called a and b, and are both of type Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２番目と３番目のパラメータはaとbと呼ばれます、そして両方ともInt型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second block is then closed, followed by the first block:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二のブロックはそれから閉じられます、そして最初のブロックが続きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second class in the hierarchy is a subclass of Food called RecipeIngredient.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この階層構造における第二のクラスは、RecipeIngredientと呼ばれるFoodのサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second form evaluates to the value of the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二の形式は、型の値に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second form is used to access the superclass’s subscript implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第２の形式は、スーパークラスの添え字実装にアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second form of a line control statement, #sourceLocation(), resets the source code location back to the default line numbering and filename.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２番目の形式の行制御文、#sourceLocation()はソースコード位置を再設定して、初期状態の行番号振りとファイル名に戻します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second form of an if statement provides an additional else clause (introduced by the else keyword) and is used for executing one part of code when the condition is true and another part of code when the same condition is false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文の２番目の形式は、追加のelse節（代わりの節）を提供します（elseキーワードで導入されます）、そして条件が真である場合はあるコード部分を、そして同じ条件が偽である場合は別のコード部分を実行するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second function, printWithoutCounting(string:), calls the first function, but ignores its return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二の関数、printWithoutCounting(string:)は、最初の関数を呼びます、しかしその戻り値を無視します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second initializer has a single initialization parameter with an argument label of fromKelvin and a parameter name of kelvin.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二のイニシャライザは、fromKelvinの引数ラベルとkelvinのパラメータ名を使うただ１つの初期化パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second is a convenience type function called isUnlocked(_:), which returns true if a particular level number is already unlocked.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二は、isUnlocked(_:)と呼ばれる便利な型関数です、それは、特定のレベル番号がすでに錠を開けられるならば、trueを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second kind of pattern is used for full pattern matching, where the values you’re trying to match against may not be there at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2番目の種類のパターンは、完全なパターンマッチングのために使われます、そこにおいてあなたがマッチを試みている対象である値は実行時にそこにないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second pair has a key of "DUB" and a value of "Dublin".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２番目の組みは、"DUB"のキーと"Dublin"の値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second subclass, Song, adds an artist property and initializer on top of the base class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二のサブクラスSongは、基盤クラスの上にartistプロパティとイニシャライザを加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second type parameter, U, has a type constraint that requires U to conform to the protocol SomeProtocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２番目の型パラメータUは、UにプロトコルSomeProtocolに準拠することを要求する型制約を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second type property is a variable stored property called maxInputLevelForAllChannels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二の型プロパティは、maxInputLevelForAllChannelsと呼ばれる変数保存プロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The self Property</seg>
      </tuv>
      <tuv lang="JA">
        <seg>selfプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sequence being iterated over is a range of numbers from 1 to 5, inclusive, as indicated by the use of the closed range operator (...).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに対して繰り返しを行われている連続物（シーケンス）は、完結範囲演算子（...）の使用によって示されるように、1から5までを含める数からなる範囲です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server either responds with the requested information, or it responds with a description of what went wrong.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのサーバーは要請された情報で応答するか、またはそれは何がうまくいかなかったかの説明で応答するかのどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The setter clause is optional, and when only a getter is needed, you can omit both clauses and simply return the requested value directly, as described in Read-Only Computed Properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッター節は任意です、そして、ゲッターだけが必要なとき、あなたは両方の節を省略することができます、そして読み出し専用の計算プロパティで記述されるように、単に直接に要請された値を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The setter clause is optional, and when only a getter is needed, you can omit both clauses and simply return the requested value directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッター節は任意です、そしてゲッターだけが必要なとき、あなたは両方の節を省略して、単に直接要請された値を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The shifting behavior is more complex for signed integers than for unsigned integers, because of the way signed integers are represented in binary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シフト挙動は、符号つき整数では符号なし整数よりももっと複雑です、なぜなら、符号つき整数が２進数において表される方法のためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The shorthand syntax for available attributes allows for availability for multiple platforms to be expressed concisely.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>available属性のための略記構文は、複数のプラットホームに対する有効性を許可して簡略に表されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sign bit is 0 (meaning “positive”), and the seven value bits are just the number 4, written in binary notation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号ビットは0です（「正」を意味します）、そして７つの値ビットはちょうど、２進数表記法で書かれる数4です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sign of b is ignored for negative values of b.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>bの符号は、負の値のbのために無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sign of a numeric value can be toggled using a prefixed -, known as the unary minus operator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数の値の符号は、単項マイナス演算子として知られる、接頭辞-を使うことによって切り換えられることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest entry in a parameter list has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ・リストの中の最も単純な項目は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest form of initializer syntax uses the type name of the class or structure followed by empty parentheses, such as Resolution() or VideoMode().</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ構文の最も単純な形式は、クラスまたは構造体の型名を使用して、それに空の丸括弧を続けます、例えばResolution()またはVideoMode()のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The single type parameter for findIndex(of:in:) is written as T: Equatable, which means “any type T that conforms to the Equatable protocol.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>findIndex(of:in:)のただ一つの型パラメータは、T: Equatableとして書かれます、それは、「Equatableプロトコルに準拠するあらゆる型T」を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The size of a geometric shape, perhaps encapsulating a width property and a height property, both of type Double.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>幾何学図形のサイズ、おそらくはwidthプロパティとheightプロパティ（両方ともDouble型）をカプセル化する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sorting closure needs to return true if the first value should appear before the second value, and false otherwise.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このソートを行うクロージャは、最初の値が第２の値の前に現れるべきならばtrueを、そうでないならばfalseを返す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The specialized version of the generic Dictionary type, Dictionary&lt;String, Int&gt; is formed by replacing the generic parameters Key: Hashable and Value with the concrete type arguments String and Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体Dictionary型の特殊化版、Dictionary&lt;String, Int&gt;は、総称体パラメータKey: HashableおよびValueを具体的な型引数StringおよびIntと置き換えて作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The specific implications of this guiding principle for different aspects of the language are covered in detail below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この言語の異なる面に対する、この原理指針の特定の影響は、詳細に下で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stack now holds four values, with the most recent one at the top.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックは現在は４つの値を持ちます、最も最近のものは一番上にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The start of the closure’s body is introduced by the in keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャのもつ本文の始まりは、inキーワードで紹介されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The statement if let somePlanet = Planet(rawValue: 11) creates an optional Planet, and sets somePlanet to the value of that optional Planet if it can be retrieved.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文if let somePlanet = Planet(rawValue: 11)は、オプショナルのPlanetを作成して、それが取り出されることができるならば、somePlanetをそのオプショナルのPlanetのもつ値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The statements in the defer statement can’t transfer program control outside of the defer statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>defer文の中の文は、プログラムの制御をdefer文の外側に移すことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The statements within the defer statement are executed no matter how program control is transferred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>defer文内の文は、どのようにプログラム制御が移されようと関係なく実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The static method is a member of one of the types whose values the operator takes as an argument—for example, an operator that multiplies a Double by an Int is implemented as a static method on either the Double or Int structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この静的メソッドは、その演算子が引数としてとる値の型のうちの１つに属するあるメンバーです、例えばDoubleにIntを掛ける演算子は静的メソッドとしてDoubleまたはInt 構造体のどちらかで実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stored or computed nature of an inherited property is not known by a subclass—it only knows that the inherited property has a certain name and type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>継承されたプロパティの保存または計算の種別は、サブクラスには知られません ― それは、継承されたプロパティが特定の名前と型を持つということを知っているだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string "123" can be converted into the numeric value 123, but the string "hello, world" does not have an obvious numeric value to convert to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列"123"は数の値123に変えられることができます、しかし文字列"hello, world"には変えるための明らかな数の値がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string retrieved from the digitNames dictionary is added to the front of output, effectively building a string version of the number in reverse.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>digitNames辞書から取り出される文字列はoutputの前方に加えられて、うまい具合に数の文字列版を逆の順序で造ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string-sorting closure from the Closure Expression Syntax section above can be written outside of the sorted(by:) method’s parentheses as a trailing closure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のクロージャ式構文の節の文字列を分類するクロージャは、後付クロージャとしてsorted(by:)関数の括弧の外側に書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The strong reference cycle prevents the Person and Apartment instances from ever being deallocated, causing a memory leak in your app.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強い参照循環はPersonとApartmentインスタンスがともかく割り当て解除されるのを妨げます。そして、あなたのアプリのメモリリークを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The strong references between the Person instance and the Apartment instance remain and cannot be broken.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>PersonインスタンスとApartmentインスタンスの間の強い参照は、残っていて、壊されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The strong references from the two variables (john and unit4A) and the links between the two instances are created as before:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの変数（johnとunit4A）からの強い参照と２つのインスタンスの繋がりは、前の通り作成されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The structure also defines a stored integer property called numberOfEdits, which is used to track the number of times that value is modified.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この構造体はまた、numberOfEditsと呼ばれる保存整数プロパティを定義します、それは、valueが修正される回数を追跡するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The structure defines a single initializer, init, with no parameters, which initializes the stored temperature with a value of 32.0 (the freezing point of water in degrees Fahrenheit).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この構造体は、パラメータのないただ一つのイニシャライザ、initを定義します、それは格納された温度を値32.0（華氏度数での水の氷点）で初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The structure does not need to inherit properties or behavior from another existing type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その構造体が、既存の別の型からプロパティまたは挙動を受け継ぐ必要がない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The structure of the repeat-while loop is better suited to this game than the while loop in the previous example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>repeat-whileループの構造は、前の例でのwhileループよりも更に良くこのゲームに適しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The structure’s members (including the numberOfEdits property) therefore have an internal access level by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体のメンバー（numberOfEditsプロパティを含む）は、したがって特に何もしなければ内部のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The structure’s primary purpose is to encapsulate a few relatively simple data values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その構造体の主要な目的は、比較的単純な２、３のデータ値をカプセル化することである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subclass in this figure has two designated initializers and one convenience initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この図の中のサブクラスは、２つの指定イニシャライザと１つの便宜イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subclass inherits characteristics from the existing class, which you can then refine.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスは既存のクラスから特徴を受け継ぎます、あなたはそのとき改良することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subclass object is not deallocated until all deinitializers in its inheritance chain have finished executing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスオブジェクトは、その継承連鎖の中の全てのデイニシャライザが実行を終えるまで、割り当て解除されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subclass’s implementation of that initializer must also be marked with the required modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザのサブクラスでの実装はまた、required修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subclass’s implementation of that initializer must also be marked with the required declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのイニシャライザのサブクラスの実装もまた、required宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subscript returns an optional value of the dictionary’s value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は辞書のもつ値型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The superclass does not itself have a further superclass, and so rule 1 does not apply.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このスーパークラスにはそれ自身には更にスーパークラスをもちません、なので規則１は適用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The superclass’s designated initializer makes sure that all of the superclass properties have a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスの指定イニシャライザは、スーパークラスのプロパティの全てが値を持つことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The superclass’s designated initializer now has an opportunity to customize the instance further (although it does not have to).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスの指定イニシャライザは、現在、さらにインスタンスを好みに合わせて作り返る機会があります（しかしながら、それはそうしなければならない訳ではない）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The switch cycles between three different power states (off, low and high) every time its next() method is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この切替えは、３つの異なる出力状態（off、lowとhigh）の間を、それのnext()メソッドが呼ばれるたびに循環します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax for creating instances is very similar for both structures and classes:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスをつくるための構文は、構造体とクラスの両方で非常に類似しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax for protocol inheritance is similar to the syntax for class inheritance, but with the option to list multiple inherited protocols, separated by commas:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル継承のための構文は、クラス継承のための構文に似ています、しかし複数の継承されたプロトコルをコンマで区切って列記する選択肢を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax for string creation and manipulation is lightweight and readable, with a string literal syntax that is similar to C. String concatenation is as simple as combining two strings with the + operator, and string mutability is managed by choosing between a constant or a variable, just like any other value in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列の作成と操作のための構文は、軽量で、読みやすく、Cに類似した文字列リテラル構文をもちます。文字列の連結は、２つの文字列を+演算子を使って繋ぎ合わせるくらい単純です、そして、文字列が変更可能かどうかは、スウィフトの他あらゆる値と同じように、定数または変数のどちらかを選ぶことによって管理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tenant property is optional because an apartment may not always have a tenant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アパートには常に賃借人がいるわけではないので、tenant（テナント、賃借人）プロパティはオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ternary conditional operator is shorthand for the code below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>三項条件演算子は、下のコードの短縮形です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ternary conditional operator provides an efficient shorthand for deciding which of two expressions to consider.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>三項条件演算子は、２つの式のどちらを考慮するべきか決定することについての効果的な短縮形を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third Rect initializer, init(center:size:), is slightly more complex.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第３のRectイニシャライザ、init(center:size:)は、わずかにより複雑です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third and final class in the hierarchy is a subclass of RecipeIngredient called ShoppingListItem.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この階層構造の中の３番目の最後のクラスは、ShoppingListItemと呼ばれるRecipeIngredientのサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third and fourth requirements combine to mean that the items in anotherContainer can also be checked with the != operator, because they are exactly the same type as the items in someContainer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>３番目と４番目の要件は組み合わされて、anotherContainerの中の項目が!=演算子を使って確認されることが同様に可能なことを意味します、なぜなら、それらはsomeContainerの中の項目と同じ正確に型であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third call fails, because the testScores dictionary does not contain a key for "Brian".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>３番目の呼び出しは失敗します、なぜなら、testScores辞書は"Brian"のキーを含んでいないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third form is used to access an initializer of the superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第３の形式は、スーパークラスのイニシャライザにアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third property, street, is used to name the street for that address:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第３のプロパティ、streetは、そのアドレスの通りのために使われます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three switch cases declare placeholder constants x and y, which temporarily take on one or both tuple values from anotherPoint.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>３つのswitchケース節はプレースホルダ定数xとyを宣言します、それは、一時的にanotherPointから１つまたは両方のタプル値を引き受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three switch cases declare placeholder constants x and y, which temporarily take on the two tuple values from yetAnotherPoint.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>３つのswitchケース節はプレースホルダ定数xとyとを宣言します、それは、一時的に２つタプル値をyetAnotherPointから引き受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three code snippets below define a hierarchy of classes and an array containing instances of those classes, for use in an example of type casting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の３つのコードの断片は、型キャストの例で使うために、あるクラス階層とそれらのクラスのインスタンスを含んでいる配列を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tokens =, -&gt;, //, /*, */, ., the prefix operators &lt;, &amp;, and ?, the infix operator ?, and the postfix operators &gt;, !, and ? are reserved.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トークン=、-&gt;、//、/*、*/、.、接頭辞演算子&lt;、&amp;、および?、そして接中辞演算子?、そして接尾辞演算子&gt;、!、および?は予約されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The top item in the stack is removed, or “popped”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックでの一番上の項目が、取り外除かれます、あるいは「ポンと飛び出されます」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The top-level code in a Swift source file consists of zero or more statements, declarations, and expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるスウィフトソースコードにおけるトップレベル・コードは、０個以上の文、宣言、そして式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The trailing closure is understood as an argument to the function, added after the last parenthesized argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後付クロージャは関数に対する引数として理解されます、そして、最後に括弧に入れた引数の後に加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two containers to be checked do not have to be the same type of container (although they can be), but they do have to hold the same type of items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>調べられる２つのコンテナは、同じ型のコンテナである必要はありません（とは言えそうでもよい）、しかしそれらは同じ型の項目を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type Optional&lt;Wrapped&gt; is an enumeration with two cases, none and some(Wrapped), which are used to represent values that may or may not be present.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型Optional&lt;Wrapped&gt;は、noneとsome(Wrapped)、２つのケース節をもつ列挙です、それは、存在しているかもしれないししていないかもしれない値を表わすために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type alias can provide concrete types for some or all of the generic parameters of the existing type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアスは、既存の型の総称体パラメータの一部またはすべてに具体的な型を提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type annotation (: type) is optional in a constant declaration when the type of the constant name can be inferred, as described in Type Inference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数名の型が推論されることができるとき、型推論で記述されるように、型注釈（: type）は定数宣言において任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type arguments are instead inferred from the type of the arguments passed to the function or initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型引数は、その代わりに関数またはイニシャライザに渡される引数の型から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type check operator returns true if the instance is of that subclass type and false if it is not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型確認演算子はそのインスタンスがそのサブクラス型ならばtrueを、それがそうでないならばfalseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type method can be used as an infix operator between existing Vector2D instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この型メソッドは既存のVector2Dインスタンスの間で接中辞演算子として使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of directionToHead is already known, and so you can drop the type when setting its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>directionToHeadの型はすでに知られています、それでその値を設定するとき、あなたは型を省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of directionToHead is inferred when it is initialized with one of the possible values of CompassPoint.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>directionToHeadの型は、それがCompassPointの可能な値のうちの１つで初期化されるとき、推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of newValue is the same as the return value of the subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>newValueの型は、添え字の戻り値と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of a Swift array is written in full as Array&lt;Element&gt;, where Element is the type of values the array is allowed to store.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト配列の型は、完全にはArray&lt;Element&gt;のように書かれます、そこにおいてElementはその配列が保存するのを許される値の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of a Swift dictionary is written in full as Dictionary&lt;Key, Value&gt;, where Key is the type of value that can be used as a dictionary key, and Value is the type of value that the dictionary stores for those keys.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの辞書型は、完全にはDictionary&lt;Key, Value&gt;のように書かれます、ここでKeyは辞書キーとして使われることができる値の型です、そしてValueは辞書がそれらのキーに対してたくわえる値の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of a Swift set is written as Set&lt;Element&gt;, where Element is the type that the set is allowed to store.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるスウィフト集合の型は、Set&lt;Element&gt;のように書かれます、そこにおいてElementはその集合が格納することを許される型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of both of these functions is (Int, Int) -&gt; Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの関数の型は両方とも、(Int, Int) -&gt; Intです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of each parameter must be included—it can’t be inferred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各パラメータの型は、含められなければなりません ― それは、推論されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the letters variable is inferred to be Set&lt;Character&gt;, from the type of the initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>letters変数の型は、そのイニシャライザの型から、Set&lt;Character&gt;と推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the numberOfLegs dictionary is inferred to be [String: Int].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>numberOfLegs辞書の型は、[String: Int]であると推測されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the library array is inferred by initializing it with the contents of an array literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>library配列の型は、ある配列リテラルの内容でそれを初期化することから推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the setter name must be the same as the return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッター名の型は、戻り型と同じものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the array is inferred to be [ShoppingListItem].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の型は、[ShoppingListItem]であると推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the property must conform to the NSCopying protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティの型は、NSCopyingプロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the variable or property must be an optional class type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この変数またはプロパティの型はまた、オプショナルクラス型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of these values is specified in the raw-value type and must represent an integer, floating-point number, string, or single character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの値の型は、生の値型において指定されて、整数、浮動小数点数、文字列または単一の文字を表さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of this function is () -&gt; Void, or “a function that has no parameters, and returns Void.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数の型は() -&gt; Voidです、あるいは「パラメータを持たず、Voidを返す関数」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of this property is String?.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロパティの型は、String?です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The types of orangesAreOrange and turnipsAreDelicious have been inferred as Bool from the fact that they were initialized with Boolean literal values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>orangesAreOrangeとturnipsAreDeliciousの型は、それらがブールのリテラル値で初期化されたという事実から、Boolとして推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The types used for any raw values or associated values in an enumeration definition must have an access level at least as high as the enumeration’s access level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙定義の中のあらゆる生の値または関連値のために使われる型は、少なくとも列挙のアクセス水準と同じの高さのアクセス水準を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unary minus operator (-) is prepended directly before the value it operates on, without any white space.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項マイナス演算子（-）は、それが作用する値の前に、全く空白なしで、直接に先頭に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unary minus operator is a prefix operator, and so this method has to be qualified with the prefix modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この単項マイナス演算子は、接頭辞演算子です、なのでこのメソッドはprefix修飾子で修飾されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unary plus operator (+i) balances with the unary minus operator (-i), and numbers lower than 10 are padded with zeros so that all board definitions align.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項プラス演算子（+i）が単項マイナス演算子（-i)と釣り合いをとります、そして10より低い数はゼロを詰められて全ての盤定義が整列するようにされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The underlying instance remains the same; it is simply treated and accessed as an instance of the type to which it has been cast.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>根底にあるインスタンスは、同じもののままです；それは単に、それがキャストされた型のインスタンスとして扱われ、アクセスされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The underscore character (_) used in place of a loop variable causes the individual values to be ignored and does not provide access to the current value during each iteration of the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ変数の代わりに使われるアンダースコア文字（_）は、その個別の値を無視されるようにして、ループの各繰り返しのときにその現在の値へのアクセスを提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unused expression is not evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>使っていない式は、評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unwrapped value of a forced-value expression can be modified, either by mutating the value itself, or by assigning to one of the value’s members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強制された値式のアンラップされた値は、値それ自体を変化させることによって、またはその値のメンバーの１つに代入することによってのどちらでも、修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unwrapped value of an optional-chaining expression can be modified, either by mutating the value itself, or by assigning to one of the value’s members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖のアンラップされた値は、その値自体を変化させることによって、またはその値のメンバーの１つに値に代入することによってのどちらでも修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of a two-phase initialization process makes initialization safe, while still giving complete flexibility to each class in a class hierarchy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２段階初期化処理の使用は初期化を安全にします、その一方でさらに、クラス階層において各クラスに完全な柔軟性を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of argument labels can allow a function to be called in an expressive, sentence-like manner, while still providing a function body that is readable and clear in intent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルの使用は、関数が、表現が豊かな、文章のようなやり方で呼び出されることを可能にします、その一方で、依然として読みやすくて意図が明白な関数本文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of the required modifier ensures that you provide an explicit or inherited implementation of the initializer requirement on all subclasses of the conforming class, such that they also conform to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>required修飾子の使用は、あなたがある明確なもしくは継承されたイニシャライザ要件の実装を準拠クラスの全てのサブクラス上で、それらもまたそのプロトコルに準拠するように、提供することを確かなものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of trailing closure syntax in the example above neatly encapsulates the closure’s functionality immediately after the function that closure supports, without needing to wrap the entire closure within the map(_:) method’s outer parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例での後付クロージャ構文の使用は、クロージャの機能性をクロージャが手助けする関数の直後に手際よく要約していて、クロージャ全体をmap(_:)メソッドの持つ外側の丸括弧の内部に包む必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of john.residence currently contains a valid Residence instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>john.residenceの値は、現在は有効なResidenceインスタンスを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of multiplier is also part of a larger expression later in the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>multiplierの値は、また、文字列の後半のより大きな式の一部でもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of invertedBits is 11110000, which is equal to an unsigned decimal value of 240.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>invertedBitsの値は11110000です、それは、符号なし10進の値の240と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of index is set to the first number in the range (1), and the statements inside the loop are executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>indexの値は、この範囲の最初の数（1）に設定されます、そしてループの内側の文が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a must not be greater than b.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>aの値はbより大きくてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a constant cannot be changed once it is set, whereas a variable can be set to a different value in the future.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数の値は、一旦それが設定されるならば変わることができません、一方で変数は将来異なる値に設定されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a constant doesn’t need to be known at compile time, but you must assign it a value exactly once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数の値はコンパイル時に知られている必要はありません、しかしあなたはそれに値を厳密に一度だけ代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a dictionary literal has type [Key: Value], where Key is the type of its key expressions and Value is the type of its value expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書リテラルの値は、型[Key: Value]を持ちます、そこで、Keyはそのキーの式の型です、そして、Valueはその値の式の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a selector expression is an instance of the Selector type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セレクタ式の値は、Selector型のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of an array literal has type [T], where T is the type of the expressions inside it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列リテラルの値は型[T]を持ちます、そこで、Tはそれの内部の式の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of an expression can be inserted into a string literal by placing the expression in parentheses after a backslash (\).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式の値は、バックスラッシュ（\）の後の丸括弧の中にその式を置くことによってリテラル文字列に差し込まれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of any condition in a guard statement must be of type Bool or a type bridged to Bool.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>guard文の中のあらゆる条件の値は、Bool型またはBoolにブリッジされる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of any condition in an if statement must be of type Bool or a type bridged to Bool.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文の中のあらゆる条件の値は、Bool型またはBoolにブリッジされる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the condition must be of type Bool or a type bridged to Bool.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>conditionの値は、Bool型またはBoolにブリッジされる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the control expression can even be matched to the value of a case in an enumeration and checked for inclusion in a specified range of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御式の値は、列挙でのケース節の値にさえマッチすることや、指定された範囲の値に包含されるかについて調べさえすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the expression is set to the value obtained by evaluating the value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式の値は、値を評価することによって得られる値に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the expression must have a type that conforms to the Error protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>expression（式）の値は、Errorプロトコルに準拠する型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of these properties cannot be set, and so it is not appropriate to provide a willSet or didSet implementation as part of an override.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのプロパティの値は設定されることができません、なのでオーバーライドの一部としてwillSetまたはdidSetの実装を提供することは適切ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value returned by a type’s hashValue property is not required to be the same across different executions of the same program, or in different programs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型のhashValueプロパティによって返される値は、同じプログラムの、または異なるプログラムでの、異なる実行にまたがって同じであることを要求されません、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value that remains within the bounds of the UInt8 after the overflow addition is 00000000, or zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー加算の後でUInt8の領域内に残る値は、00000000、またはゼロです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values defined in an enumeration (such as north, south, east, and west) are its enumeration cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙で定義される値（例えばnorth、south、east、そしてwest）は、それの列挙ケース節です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of finalSquare, board, square, and diceRoll are initialized in the same way as before:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>finalSquare、board、square、そしてdiceRollの値は、前と同じように初期化されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of finalSquare, board, square, and diceRoll are initialized in exactly the same way as with a while loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>finalSquare、board、square、そしてdiceRollの値は、正確にwhileループと同じやり方で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of a dictionary can be accessed through subscripting by specifying the corresponding key in square brackets: someDictionary["Alex"] refers to the value associated with the key "Alex".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書の値は、角括弧の中に対応するキーを指定することによる添え字指定を通してアクセスされることができます：someDictionary["Alex"]はキー"Alex"と結び付けられた値に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of expressions your code can branch on are very flexible.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードが分岐することができる式の値は、非常に柔軟です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of the conditions specified in a branch statement control how the program branches and, therefore, what block of code is executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>分岐文において指定される条件の値は、プログラムがどのように分岐するか、したがって、コードのどのブロックが実行されるかについて制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of these properties are of the appropriate-sized number type (such as UInt8 in the example above) and can therefore be used in expressions alongside other values of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのプロパティの値は、適切なサイズの数の型（例えば上の例でのUInt8）であり、したがって、式の中で同じ型の他の値と並べて使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values passed to a variadic parameter are made available within the function’s body as an array of the appropriate type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長パラメータに渡される値は、適切な型の配列として、関数の本文内で利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values that operators affect are operands.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子が影響を及ぼす値は、演算数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values within a tuple can be of any type and do not have to be of the same type as each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルの内部の値は、どんな型でもかまいません、そして互いに同じ型である必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The variable unsignedOverflow is initialized with the maximum value a UInt8 can hold (255, or 11111111 in binary).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数unsignedOverflowは、UInt8が持つことができる最大限の値で初期化されます（255、または２進数での11111111）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The various aspects of your code that can have access control applied to them (properties, types, functions, and so on) are referred to as “entities” in the sections below, for brevity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらに適用可能なアクセス制御を持つあなたのコードのさまざまな面（プロパティ、型、関数、その他）は、簡潔さのために、下記の節において「実在」として言及されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The version number for the swift() platform condition consists of a major and minor number, separated by a dot (.).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>swift()プラットホーム条件のためのバージョン番号は、ドット（.）で区切られるメジャーおよびマイナー番号からなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The version of serve(customer:) below performs the same operation but, instead of taking an explicit closure, it takes an autoclosure by marking its parameter’s type with the @autoclosure attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のバージョンのserve(customer:)は同じ演算を実行します、しかし明示的なクロージャを取るのではなく、それは自動クロージャを、それのパラメータの型を@autoclosure属性で記することによって取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The video mode is assigned a copy of the HD resolution of 1920 by 1080 from before.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビデオ・モードは、以前にHD解像度1920×1080のコピーを代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The whitespace around an operator is used to determine whether an operator is used as a prefix operator, a postfix operator, or a binary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子のまわりの空白は、演算子が接頭辞演算子か、接尾辞演算子か、または二項演算子として使われるかを決定するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The zeros in 0xFF0000 effectively “mask” the second and third bytes of 0xCC6699, causing the 6699 to be ignored and leaving 0xCC0000 as the result.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>0xFF0000のゼロは、0xCC6699の２番目と３番目のバイトを効果的に「マスク」します（隠して消します）、そして6699が無視されるようになって、結果として0xCC0000が残ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Their primary role is to ensure that new instances of a type are correctly initialized before they are used for the first time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの主要な役割は、ある型の新しいインスタンスが、それらが初めて使われる前に正しく初期化されることを保証することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Their return value is of type Double, and can be used within mathematical calculations wherever a Double is accepted:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの戻り値はDouble型です、そして数学計算内のDoubleが受け入れられるあらゆるところで使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Their syntax is similar to both instance method syntax and computed property syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの構文は、インスタンスメソッド構文と計算プロパティ構文に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Their type is inferred only at the point that they are evaluated by the compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの型は、それらがコンパイラによって評価される時点においてのみ、推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, declare a new variable called currentLoginAttempt, and give it an initial value of 0.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その後で、currentLoginAttemptと呼ばれる新しい変数を宣言して、それに0の初期値を与える。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two levels of optional chaining in use here, to chain through the residence and address properties, both of which are of optional type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここで使用されるオプショナル連鎖の２つの階層があります、そしてresidenceとaddressプロパティを通り抜けて繋げます、その両方ともオプショナル型です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a number of ways this task can fail, including the file not existing at the specified path, the file not having read permissions, or the file not being encoded in a compatible format.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この作業が失敗するたくさんの道筋があります、そのファイルが指定したパスで存在しない、ファイルが読み出し権限を持っていない、またはファイルが互換性のある形式で符号化されていないことを含めて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are currently three values on the stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在は３つの値がこのスタックにはあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are four type-casting operators: the is operator, the as operator, the as? operator, and the as! operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>４つの型キャスト演算子、is演算子、as演算子、as?演算子、そしてas!演算子があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are four ways to handle errors in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>４つの方法がエラーを取り扱うためにスウィフトにはあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no further superclasses to initialize, and so no further delegation is needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化するための更なるスーパークラスはありません、なので、更なる委任は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are now three strong references to this single Person instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在この一つのPersonインスタンスへの３つの強い参照があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several special forms that allow closures to be written more concisely:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャをより簡潔に書かれるようにする特別ないくつかの形式があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several types of control flow statements in Swift, including loop statements, branch statements, and control transfer statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの種類の制御の流れ文が、スウィフトにあります、それはループ文、分岐文、そして制御移動文を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several ways to handle errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの方法がエラーを取り扱うためにはあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three basic forms of an operator declaration, one for each fixity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子宣言の基本の書式は、各定着性に対して１つずつ、３つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three ways create an instance of a previously declared structure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以前に宣言された構造体のインスタンスを作成する方法が３つあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two basic forms of an if statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文の２つの基本の書式があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two cases in which a type identifier does not refer to a type with the same name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型識別子が型に同じ名前で言及しない２つの場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two compound types: function types and tuple types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの複合の型：関数型とタプル型があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two different things named a, the variable in the surrounding scope and the constant in the closure’s scope, but only one variable named b.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>aと名前をつけられる２つの異なるものがあります、囲んでいるスコープにおける変数とクロージャのスコープにおける定数、しかしbと名前をつけられる変数はただひとつのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two kinds of attributes in Swift, those that apply to declarations and those that apply to types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトには２種類の属性があります、宣言に適用されるもの、そして型に適用されるもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two type-casting patterns, the is pattern and the as pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの型キャスト・パターン、isパターンとasパターンがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two ways create an instance of a previously declared class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以前に宣言されたクラスのインスタンスをつくる方法が２つあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There can only ever be one Bank in the game, and so the Bank is implemented as a class with type properties and methods to store and manage its current state:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つのBankだけがゲームにおいて存在することができます、なのでBankは型プロパティと型メソッドをもつクラスとして実装されて、その現在の状態を保存および管理します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a new @noescape parameter declaration attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また新しい@noescapeパラメーター宣言属性もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no requirement for classes to subclass any standard root class, so you can include or omit a superclass as needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何らかの標準となるルートクラスのサブクラスであることは、クラスにとって必要条件ではありません、そのためあなたは必要に応じてスーパークラスを含めたり省略したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is one caveat to the rules above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つのただし書きが、上の規則にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is only one loop in the game, and therefore no ambiguity as to which loop the continue statement will affect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このゲームにはただ一つのループしかありません、それゆえにcontinue文が影響を及ぼすループはどれかについての曖昧さもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There must not be whitespace between &gt;= and the version number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&gt;=とバージョン番号の間に空白があってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There will only ever be one copy of these properties, no matter how many instances of that type you create.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらのプロパティのコピーはただ１つだけ存在することになります、あなたが作るその型のインスタンスがいくらあろうとも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thereafter, the game instantiator has the option to set the property to a suitable delegate.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その後は、このゲームのイニシャライザは、このプロパティを適当な委任先に設定する選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, RecipeIngredient automatically inherits all of its superclass’s convenience initializers too.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、RecipeIngredientは自動的にそのスーパークラスの便宜イニシャライザの全てもまた継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, ARC automatically sets a weak reference to nil when the instance that it refers to is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、ARCは自動的に、弱い参照をそれが言及するインスタンスが割り当て解除されるときnilに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, it is sometimes useful to be explicit about which loop or conditional statement you want a break statement to terminate.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、あなたがbreak文に終了して欲しいループまたは条件文はどれかについて明白にすることは、しばしば役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, it’s safe to check for a snake or a ladder as the first action in the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、ループでの最初の活動として、ヘビまたははしごについて調べるのは差し支えありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the names and types of an initializer’s parameters play a particularly important role in identifying which initializer should be called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、イニシャライザのパラメータの名前と型は、どのイニシャライザが呼ばれなければならないか識別することにおいて特に重要な役割を演じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the overall access level of the compound tuple type is “private” (the minimum access level of the tuple’s constituent types).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、この複合タプル型の全体としてのアクセス水準は「非公開」です（このタプルの構成要素の型の内の最小のアクセス水準）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, when you break the strong references held by the john and unit4A variables, the reference counts do not drop to zero, and the instances are not deallocated by ARC:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、あなたがjohnとunit4A変数によって保持される強い参照を壊すとき、参照総数はゼロに落ちません、なのでインスタンスはARCによって割り当て解除されません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, you can set it to an instance of any type that adopts the RandomNumberGenerator protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、あなたはそれをRandomNumberGeneratorプロトコルを採用するあらゆる型のインスタンスに設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, you can simply pass in the greater-than operator, and Swift will infer that you want to use its string-specific implementation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、あなたはただ単に「大なり」演算子を渡すことができます、そしてスウィフトはあなたがその文字列特有の実装を使いたいのだと推測します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, you do not need to specify a custom access level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、あなたはあつらえのアクセス水準を指定する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, you must write the override modifier before the subclass’s initializer definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、あなたはoverride修飾子をそのサブクラスのイニシャライザ定義の前に書かなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, your subclass is not (strictly speaking) providing an override of the superclass initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それゆえに、あなたのサブクラスはスーパークラスのイニシャライザのオーバーライドを（厳密に言えば）提供していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There’s actually an even shorter way to write the closure expression above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらにより短い方法が上のクロージャ式を書くために実際にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There’s an even simpler way to include values in strings: Write the value in parentheses, and write a backslash (\) before the parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いろいろな値を文字列の中に含めるさらに単純な方法があります：その値を丸括弧の中に書いてください、そして丸括弧の前にバックスラッシュ（\）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There’s no need to shift this to the right, as 0x000099 already equals 0x99, which has a decimal value of 153.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>0x000099がすでに0x99に等しいので、これを右へシフトする必要はありません、それは10進の値の153を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There’s nothing stopping you from having a tuple of type (Int, Int, Int), or (String, Bool), or indeed any other permutation you require.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが(Int, Int, Int)の型のタプル、または(String, Bool)、またはあなたが実際に必要とするあらゆる他の順列を持つのを止めるものは何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These attribute arguments are enclosed in parentheses, and their format is defined by the attribute they belong to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの属性引数は丸括弧に囲まれます、そして、それらの形式はそれらが属している属性によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These declarations can include both stored and computed properties, instance methods, type methods, initializers, a single deinitializer, subscripts, type aliases, and even other class, structure, and enumeration declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの宣言は、保存または計算プロパティの双方、インスタンスメソッド、型メソッド、イニシャライザ、一つだけのデイニシャライザ、添え字、型エイリアス、そして他のクラス、構造体、および列挙宣言さえも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These declarations can include both stored and computed properties, type properties, instance methods, type methods, initializers, subscripts, type aliases, and even other structure, class, and enumeration declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの宣言は、保存または計算プロパティの双方、型プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、添え字、型エイリアス、そして他の構造体、クラス、および列挙宣言さえも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These declarations can include computed properties, computed type properties, instance methods, type methods, initializers, subscript declarations, and even class, structure, and enumeration declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの宣言は、計算プロパティ、計算型プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、添え字宣言、そしてクラス、構造体、そして列挙宣言さえも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These access levels are relative to the source file in which an entity is defined, and also relative to the module that source file belongs to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのアクセス水準は、ある実在が定義されているソースファイルと関連しています、そのうえに、ソースファイルが属しているモジュールとも関連しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These actions are described in the following sections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの行いは、以下の節で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are custom classes, structures, and enumerations that can work with any type, in a similar way to Array and Dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、ArrayとDictionaryに類似した方法で、あらゆる型で扱うことができる特注のクラス、構造体、そして列挙があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are followed by a “check” digit to verify that the code has been scanned correctly:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの後にコードが正しくスキャンされたことを確認するための一つの「チェック」桁が続きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are known as constants, and are much more powerful than constants in C. Constants are used throughout Swift to make code safer and clearer in intent when you work with values that do not need to change.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは定数として知られています、そしてCにおける定数よりずっと強力です。定数は、変わる必要がない値をあなたが扱う時、コードをより安全により明白にする意図でスウィフトを通して使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are known as designated initializers and convenience initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、指定イニシャライザと便宜イニシャライザとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are used as the two input values for the provided math function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは提供された数学関数のための２つの入力値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These arguments begin with one of the following platform names:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの引数は、以下のプラットホーム名のうちの１つで始まります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These attributes are conceptually the same as their Objective-C counterparts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの属性は、概念的にそれらのObjective-Cでの対応物と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These classes expand upon the Person and Residence model from above by adding a Room and Address class, with associated properties, methods, and subscripts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのクラスは、関連するプロパティ、メソッド、そして添え字とともにRoomとAddressクラスを加えることによって、上記のPersonとResidenceモデルを拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These computed properties express that a Double value should be considered as a certain unit of length.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの計算プロパティは、Double値が長さの特定の単位とみなされなければならないことを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constants (or variables) can then be referenced in a corresponding where clause and throughout the rest of the code within the scope of the case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの定数（または変数）は、それから対応するwhere節の中で、そしてそのケース節のスコープ内のその他のコードのいたるところで参照されることができます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constants are used as part of a where clause, to create a dynamic filter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの定数は、where節の一部として動的なフィルタを作成するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These functions and methods are known as rethrowing functions and rethrowing methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの関数とメソッドは、再スロー関数と再スローメソッドとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These functions and methods are known as throwing functions and throwing methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの関数とメソッドはスロー関数およびスローメソッドとして知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These functions each take two Int values, and return an Int value, which is the result of performing an appropriate mathematical operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの関数は、各々２つのInt値をとって、１つのInt値を返します、そしてそれは、適切な数値演算の実行の結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include while loops to perform a task multiple times; if, guard, and switch statements to execute different branches of code based on certain conditions; and statements such as break and continue to transfer the flow of execution to another point in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、ある作業を複数回実行するwhileループ；特定の条件に基づいてコードの異なる分岐を実行するif、guard、およびswitch文；そして実行の流れをあなたのコードの別の地点に移す、breakおよびcontinueのような文を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、あなたがCとObjective-Cからお馴染みの、ビット単位およびビットシフト演算子の全てを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include enumeration case patterns, optional patterns, expression patterns, and type-casting patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、列挙ケース節パターン、オプショナルパターン、式パターン、および型キャストパターンを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include the UTF-8 encoding form (which encodes a string as 8-bit code units), the UTF-16 encoding form (which encodes a string as 16-bit code units), and the UTF-32 encoding form (which encodes a string as 32-bit code units).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、UTF-８符号化方式（それは、８ビット符号単位として文字列を符号化します）、UTF-16符号化方式（それは、16ビット符号単位として文字列を符号化します）、そしてUTF-32符号化方式（それは、32ビット符号単位として文字列を符号化します）を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include wildcard patterns, identifier patterns, and any value binding or tuple patterns containing them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらはワイルドカード・パターン、識別子パターン、そしてそれらを含むあらゆる値束縛やタプルパターンを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These initialization options are represented by three custom initializers that are part of the Rect structure’s definition:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの初期化オプションは、Rect構造体の定義の一部である３つのあつらえのイニシャライザによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These initializers can be used to create new Rect instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのイニシャライザが、新しいRect例をつくるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These integers follow a naming convention similar to C, in that an 8-bit unsigned integer is of type UInt8, and a 32-bit signed integer is of type Int32.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの整数は、８ビットの符号なし整数が型UInt8である、そして32ビットの符号つき整数が型Int32であるという点で、Cに似ている命名規則に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These keywords are described in the sections below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのキーワードは、以下の節で解説されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These kinds of closures or functions typically create a temporary value of the same type as the property, tailor that value to represent the desired initial state, and then return that temporary value to be used as the property’s default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの種類のクロージャまたは関数は、概してプロパティと同じ型の一時的な値をつくって、望み通りの初期状態を表すようにその値を仕立てて、それからその一時的な値がプロパティの省略時の値として使われるように返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These kinds of loops are best used when the number of iterations is not known before the first iteration begins.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの種類のループが最も使われるのは、繰り返しの回数が最初の繰り返しが始まる前にはわからないときです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These kinds of methods are called type methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの種類のメソッドは、型メソッドと呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These kinds of optionals are defined as implicitly unwrapped optionals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの種類のオプショナルは、暗黙的にアンラップされるオプショナルとして定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These kinds of properties are called type properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの種類のプロパティは、型プロパティと呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These methods are marked as mutating, because they need to modify (or mutate) the structure’s items array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのメソッドはmutatingとして印されます、なぜなら、それらが構造体のitems配列を修正する（または変化させる）必要があるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These methods are written as part of the protocol’s definition in exactly the same way as for normal instance and type methods, but without curly braces or a method body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのメソッドは、プロトコルの定義の一部として普通のインスタンスおよび型メソッドと正確に同じ方法で書かれます、しかし波括弧またはメソッド本文はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These names are valid identifiers within the scope of the closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの名前は、クロージャのスコープ内で有効な識別子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators all begin with an ampersand (&amp;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの演算子は、全てアンパサンド（&amp;）で始まります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators are now used only with String values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの演算子は今ではString値でのみ使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators can be used and adopted in your code like any of the predefined operators, and you can even extend existing types to support the custom operators you define.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの演算子は、あらかじめ定義された演算子のどれとも同じように、使用されることができ、あなたのコードにおいて取り入れられることができます、そして、あなたはあなたが定義するカスタム演算子をサポートするように既存の型を拡張することさえ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators can contain additional dots.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの演算子は、さらなるドットを含むことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These optimizations include:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの最適化は、以下を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These options are described later in this chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの選択肢は、この章の後刻に記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These overrides ensure that an AutomaticallyNamedDocument instance has an initial name value of "[Untitled]" if the instance is initialized without a name, or if an empty string is passed to the init(name:) initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのオーバーライドは、AutomaticallyNamedDocumentインスタンスが、そのインスタンスが名前なしで初期化されたならば、または空の文字列がinit(name:)イニシャライザに渡されたならば、初期name値の"[Untitled]"を持つことを確実にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These pairings are written within a pair of square braces, separated by commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの組合せは、一対の角括弧内に書かれて、コンマで区切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These properties are read-only computed properties, and so they are expressed without the get keyword, for brevity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのプロパティは、読み出し専用の計算プロパティです、それでそれらは簡潔さのために、getキーワードなしで表わされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These properties store a value between 0.0 and 1.0 to indicate the amount of red, green, and blue in the color.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのプロパティは、0.0と1.0の間の値を格納して、その色における赤、緑、および青の量を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These requirements define two different ways for data sources to provide an appropriate increment amount for a Counter instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの要件は、データ・ソースのためにCounterインスタンスに適切な増加量を用意する２つの異なる方法を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These requirements enable the allItemsMatch(_:_:) function to compare the two containers, even if they are of a different container type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの要件は、allItemsMatch(_:_:)関数に２つのコンテナを比較するのを可能にします、たとえそれらが異なるコンテナ型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These requirements mean:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの要件が意味するのは：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These responsibilities are described in Class Inheritance and Initialization below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの責任は、下記のクラス継承と初期化で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These rules apply even if your subclass adds further convenience initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの規則は、たとえあなたのサブクラスが更なる便宜イニシャライザを加えるとしてもあてはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These rules are illustrated in the figure below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの規則は、下の図で説明されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These rules don’t affect how users of your classes create instances of each class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの規則は、あなたのクラスのユーザーが各クラスのインスタンスを作成する方法に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These statements are indicated by the else keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの文は、elseキーワードによって指し示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These three capabilities match the requirements of the Container protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの３つの能力は、Containerプロトコルの要件に合致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These three methods have been incorporated into the game logic within the play() method above, and are called when a new game starts, a new turn begins, or the game ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの３つのメソッドは、上のplay()メソッド内のゲーム論理に組み込まれています、そして、新しいゲームが始まるとき、新しいターンを開始するとき、あるいはこのゲームが終わるとき、呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These tokens can’t be overloaded, nor can they be used as custom operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのトークンは、オーバーロードされることができませんし、それらはあつらえの演算子として使われることもできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two classes each store an instance of the other class as a property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの２つのクラスは、それぞれ他のクラスのインスタンスをプロパティとして格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two operators provide a simple and expressive way to check the type of a value or cast a value to a different type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの２つの演算子は、値の型を調べたり、値を異なる型にキャストする（配役する、投げ込む）ための単純で表現豊かな方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two properties are inferred to be of type Int by setting them to an initial integer value of 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの２つのプロパティは、それらを最初の整数値0に設定することによって型Intであると推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two statements call the subscript’s setter to set a value of 1.5 in the top right position of the matrix (where row is 0 and column is 1), and 3.2 in the bottom left position (where row is 1 and column is 0):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの２つの文は、添え字のセッターを呼び出して、この行列の右上位置（rowが0でcolumnが1のところ）に1.5の値を、そして左下位置（rowが1でcolumnが0のところ）に3.2を設定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These type parameters act as placeholders that are replaced by actual concrete type arguments when an instance of a generic type is created or a generic function or initializer is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型パラメータは、総称体型のインスタンスがつくられる、あるいは、総称体の関数やイニシャライザが呼ばれるとき、実際の具体的な型引数と取り替えられるプレースホルダの働きをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These types are specified in the associated value types tuple, immediately following the name of the case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型は、ケース節の名前の直後に、それら関連値型のタプルを使って指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These valid tokens form the lowest-level building blocks of the language and are used to describe the rest of the language in subsequent chapters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの公式のトークンは、言語の最も基本的な建物ブロックを形成して、以降の章において言語の残りの部分を記述するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These values are a high-surrogate value of U+D83D (decimal value 55357) and a low-surrogate value of U+DC36 (decimal value 56374).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの値は、前半代用値のU+D83D（10進の値55357）と後半代用値のU+DC36（10進の値56374）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These values are labeled min and max so that they can be accessed by name when querying the function’s return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの値は、minおよびmaxとラベルをつけられます、なのでそれらはこの関数の戻り値について問い合わせるときに名前によってアクセスされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These values are represented as optionals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このような値は、オプショナルであるとして表現されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These variations on function syntax are discussed below in Function Argument Labels and Parameter Names and Default Parameter Values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数構文上のこれらの差異は、関数の引数ラベルとパラメータ名と省略時のパラメータ値の下で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration’s current value, and instance methods to provide functionality related to the values the enumeration represents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらはクラスによってのみ伝統的に支えられる多くの特徴を採用します、例えば列挙の現在の値に関する追加の情報を提供する計算プロパティ、そして、列挙が表す値に関連した機能性を提供するインスタンスメソッドなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are prefix if they precede their target (such as -a) and postfix operators if they follow their target (such as b!).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、それがその目標に先行するならば接頭辞（例えば-a）、それがその目標の後に続くならば接尾辞演算子です（例えばb!）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are both optional, after all.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結局、それらは両方ともオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they do not need to be marked with the lazy modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、ただ１度だけ初期化されることを保証されます、複数のスレッドによって同時にアクセスされる場合でさえもです、そしてそれらはlazy修飾子で印されることを必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are not called while a class is setting its own properties, before the superclass initializer has been called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、スーパークラスイニシャライザが呼び出され終わる前、あるクラスがそれ自身のプロパティを設定している間には呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are not suited to the creation of complex data structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、複雑なデータ構造物の作成には適していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are often used in low-level programming, such as graphics programming and device driver creation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが、低階層のプログラミング、例えばグラフィックス・プログラミングやデバイスドライバー作成において、しばしば使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are stored by subtracting their absolute value from 2 to the power of n, where n is the number of value bits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、2のn乗からそれらの絶対値を減ずることによって保存されます、そこで、nは値ビットの数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can be used as expressions on their own, and they can be combined with other tokens to make prefix expressions, binary expressions, and postfix expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらはそれら自身で式として使われることができます、そしてそれらは接頭辞式、二項式、そして接尾辞式を作るために別のトークンと組み合わされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They cannot be added together directly, because they are not of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは直接にひとつに加算されることができません、それらが同じ型でないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can’t be adopted by structures or enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは構造体や列挙によって採用されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They continue to be a Circle, a Country and an Animal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、Circle、Country、そしてAnimalであり続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They must always explicitly declare their adoption of the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、常に明示的にそのプロトコルについてそれらが採用することを宣言しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They must always have a number (or hexadecimal number) on both sides of the decimal point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、常に小数点の両側で数（または16進の数）を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They must have a set value before first use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは最初に使用される前に値を設定される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They support the functionality of those instances, either by providing ways to access and modify instance properties, or by providing functionality related to the instance’s purpose.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、そういったもののインスタンスの機能性を、インスタンスプロパティにアクセスしたり修正したりする方法を提供することで、またはインスタンスの目的と関連がある機能性を提供することでのどちらかで支えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They themselves do not describe a specific resolution or video mode.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらはそれら自体で、特定の解像度またはビデオ・モードを記述しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think of it as meaning “they associate with the expression to their left,” or “they associate with the expression to their right.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは「それらは、式をそれらの左と結びつける」あるいは「それらは、式をそれらの右と結びつける」を意味すると考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think of this as adding implicit parentheses around these parts of the expression, starting from their left:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを、これらの式部分のまわりに、暗黙の括弧をそれらの左から開始して加えることと考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This switch statement does not have a default case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このswitch文にはdefaultケース節がない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This Player instance is stored in an optional Player variable called playerOne.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このPlayerインスタンスは、playerOneと呼ばれるオプショナルのPlayer変数に保存されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This default case does not need to perform any action, and so it is written with a single break statement as its body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このdefaultケース節はいかなる動作も実行する必要がありません、なのでそれはその本文としてbreak文ひとつだけを書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This action ensures that signed integers have the same sign after they are shifted to the right, and is known as an arithmetic shift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この動作は、符号つき整数が、それが右へシフトされた後に同じサインを持つことを確実にします、そして算術シフトとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aids code consistency and interoperability.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、コードの整合性と相互運用性を支援します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to define behavior on protocols themselves, rather than in each type’s individual conformance or in a global function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、それぞれの型の個々の準拠においてまたはグローバル関数においてではなく、プロトコルそれ自体に振る舞いを定義することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also means that if you assign a closure to two different constants or variables, both of those constants or variables will refer to the same closure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはまた、あなたがクロージャを２つの異なる定数または変数に代入するならば、それらの定数または変数の両方とも同じクロージャに言及することを意味します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach assumes that the method’s caller knows there is a special value to test against and remembers to check for it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このアプローチは、メソッドの呼び出し側が試験するべき特別な値があるのを知っていて、それについて調べるのを忘れないでいると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach avoids accidental fallthrough from one case to another and makes for safer code that is clearer in its intent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この取り組み方は、１つのケース節から他のものへの思いがけない抜け落ちを防止してより安全なコード、その意図するところがより明白であること、に寄与します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach avoids confusion about how the value is accessed in different contexts and simplifies the property’s declaration into a single, definitive statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この取り組み方は、値が異なる文脈においてアクセスされる方法についての混乱を避け、プロパティの宣言をただ１つの、決定的な文に単純化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach is different from string mutation in Objective-C and Cocoa, where you choose between two classes (NSString and NSMutableString) to indicate whether a string can be mutated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この取り組みは、Objective-Cとココアでの文字列変化と異なります、そこでは、あなたは文字列が変化することができるかどうか示すために、２つのクラス（NSStringとNSMutableString）のどちらかを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach is known as a logical shift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このやり方は、論理シフトとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This assumption is demonstrated by the use of count (rather than self.count) inside the three instance methods for Counter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この仮定は、Counterのための３つのインスタンスメソッド内部での（self.countではなく）countの使用によって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This attribute causes the property’s setter to be synthesized with a copy of the property’s value—returned by the copyWithZone(_:) method—instead of the value of the property itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性は、プロパティのセッターがそのプロパティの値のコピー ― copyWithZone(_:)メソッドによって返されるもの ― を使って合成されるようにします、プロパティそれ自体の値ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This attribute is used to delay the evaluation of an expression by automatically wrapping that expression in a closure with no arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性は、ある式の評価を、自動的にその式を引数のないクロージャの中に包み込むことによって延期するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This base class declares a stored property called numberOfWheels, with a default Int value of 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この基盤クラスはnumberOfWheelsと呼ばれる保存プロパティを、省略時の値としてInt値0を使って、宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This base class defines a stored property called currentSpeed, with a default value of 0.0 (inferring a property type of Double).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この基盤クラスは、currentSpeedと呼ばれる保存プロパティを定義します、それは0.0の省略時の値を持ちます（Doubleの型のプロパティと推論されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior can be used to match and ignore one or more cases in a switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、switch文の一つ以上のケース節を適合してから無視することのために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior gives extra safety when you work with numbers that are too large or too small.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、あまりに大きいかあまりに小さい数をあなたが扱うとき、追加の安全を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is communicated by a getter and setter in the same way as for computed properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、計算プロパティに関してと同様に、ゲッターとセッターによって伝えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is different from Foundation: NSString, NSArray, and NSDictionary are implemented as classes, not structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、Foundationとは異なります：NSString、NSArray、そしてNSDictionaryは、構造体ではなくクラスとして実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is different from other types, where a public type definition implies an access level of internal for the type’s members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は他の型とは異なります、そこにおいて、公開型定義は、その型のメンバーに対して内部アクセス水準を暗黙的に意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is due to structures being value types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、この構造体が値型であるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is known as copy-in copy-out or call by value result.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、コピーイン・コピーアウトまたは結果値による呼び出しとして知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is known as value binding, because the values are bound to temporary constants or variables within the case’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は値束縛として知られています、なぜなら値がそのケース節の本文内の一時的な定数または変数に束縛（バインド）されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is referred to as longest match or maximal munch.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、最長マッチまたは欲張り捕獲と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is summarized in the following rules:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、以下の規則において要約されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior prevents the reference from becoming part of a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、参照が強い参照循環の一部になるのを妨げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior removes the need for the array bounds check seen in the earlier version of the game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、ゲームの前の別版で見られた配列の境界検査の必要を取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This calculation yields the final answer of 17.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この計算は、最終的な答えの17を生みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This call to the insert(_:at:) method inserts a new item with a value of "Maple Syrup" at the very beginning of the shopping list, indicated by an index of 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>insert(_:at:)メソッドへのこの呼び出しは、"Maple Syrup"の値をもつ新しい項目を、0のインデックスによって指し示される、買い物リストのまさしくその開始位置で差し入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be read as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can happen if two class instances hold a strong reference to each other, such that each instance keeps the other alive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つのクラスインスタンスが強い参照にお互いを守らせるならば、これは起こることができます、各インスタンスが他を生かしておくようなものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This capture might occur because the closure’s body accesses a property of the instance, such as self.someProperty, or because the closure calls a method on the instance, such as self.someMethod().</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この捕獲は、例えばself.somePropertyのようにクロージャの本文がインスタンスのプロパティにアクセスするために、または例えばself.someMethod()のようにクロージャがインスタンスのメソッドを呼ぶために起こるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter describes parameters and arguments for generic types, functions, and initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この章は、総称体の型、関数、そしてイニシャライザに対するパラメータと引数を記載します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter describes the common operators in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この章は、スウィフトの通常の演算子を記載します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter describes those situations and shows how you enable ARC to manage all of your app’s memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この章は、それらの状況を記載して、あなたがどのようにARCにあなたのアプリのメモリの全てを管理させるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter discusses the types defined in the Swift language itself and describes the type inference behavior of Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この章は、スウィフト言語それ自身によって定義される型を議論して、スウィフトの型推論挙動を記載します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter now focuses more on the addition of new functionality in a subclass, and the modification of existing functionality with overrides.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この章は、今やサブクラスにおける追加された新しい機能性、そしてオーバーライドを使った既存の機能性の変更にもっと焦点を当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This character can be represented as a single code unit in UTF-16.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文字は、UTF-16において単一の符号単位で表わされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This check ensures that your overriding definition is correct.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この調査は、あなたのオーバーライドの定義が正しいことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class has four variable stored properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスは、４つの変数の保存プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class has three optional properties of type String?.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスは、型String?の３つのオプショナルのプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class implements a pseudorandom number generator algorithm known as a linear congruential generator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスは、線形合同法生成器として知られている擬似乱数生成器アルゴリズムを実装します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class implements the fullName property requirement as a computed read-only property for a starship.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスは、fullNameプロパティ要件をある宇宙船のための読み出し専用の計算プロパティとして実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class might be used with input data from a pedometer or other step counter to keep track of a person’s exercise during their daily routine.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスは、万歩計または他の歩数計からの入力データとともに、ある個人の日課の運動の経過を追うために使われるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class models a document that can be initialized with a name property that is either a nonempty string value or nil, but cannot be an empty string:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスはある書類をモデル化します、それは空でない文字列かnilのどちらかであるnameプロパティで初期化されることができます、しかし空の文字列であることはできません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class provides basic functionality for any kind of item that appears in a digital media library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスは、基本の機能性をデジタル・メディア図書館に現れるあらゆる種類の項目のために用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This code can be read as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このコードは、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This color is then decomposed into its red (CC), green (66), and blue (99) components by the bitwise AND operator (&amp;) and the bitwise right shift operator (&gt;&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この色はそれから、ビット単位の論理積演算子（&amp;）とビット単位の右シフト演算子（&gt;&gt;）によって、それの赤（CC）、緑（66）、そして青（99）の構成要素に分解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This computed property considers the rank of the card and initializes a new Values instance with appropriate values based on its rank.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この計算プロパティは、カードの等級を考慮して、その等級に基づいた適切な値で新しいValuesインスタンスを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This confirms that initialization has taken place.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、初期化が起こったことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This constraint ensures that each element of the sequence is equatable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この制約はシーケンスの各要素が同等比較可能であることを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This constraint prevents a situation in which additional essential setup provided in a more complex initializer is accidentally circumvented by someone using one of the automatic initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この制約は、あるより複雑なイニシャライザにおいて提供される追加の重要な準備が、自動的なイニシャライザのうちの１つを使う何かによって図らずも回避される状況を防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This continues up the class inheritance chain until the top of the chain is reached.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、クラス継承連鎖を上って、その連鎖の最上部に着くまで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This convenience initializer assumes a quantity of 1 for any RecipeIngredient instance that is created without an explicit quantity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この便宜イニシャライザは、はっきりした量なしで作成されるあらゆるRecipeIngredientインスタンスに対して数量1を仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This convenience initializer cannot yet modify any properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この便宜イニシャライザは、まだどのプロパティも修正することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This convenience initializer simply delegates across to the class’s designated initializer, passing in a quantity value of 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この便宜イニシャライザはそのクラスの指定イニシャライザに、単純にquantityに値1を渡して横に委任します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This creates a new instance of the class or structure, with any properties initialized to their default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、クラスまたは構造体の新しいインスタンスをつくり、どんなプロパティでもそれらの省略時の値に初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This data source is defined by the CounterDataSource protocol, which has two optional requirements:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このデータ・ソースはCounterDataSourceプロトコルによって定義されます、それは、２つのオプショナルの要件を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This default case is indicated by the default keyword, and must always appear last.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>defaultケース節は、キーワードdefaultによって示されて、常に最後に現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This definition does not provide any actual Int or String values—it just defines the type of associated values that Barcode constants and variables can store when they are equal to Barcode.upc or Barcode.qrCode.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この定義は、何ら実際のIntまたはString値を提供しません ― それは、ただ単に関連値の型を定義します、それは、Barcode定数と変数がBarcode.upcもしくはBarcode.qrCodeに等しいときに格納できる型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This definition indicates that a getter-setter block can consist of a getter clause followed by an optional setter clause, enclosed in braces, or a setter clause followed by a getter clause, enclosed in braces.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この定義は、１つのゲッターセッター・ブロックが、１つのゲッター節とそれに続く任意の１つのセッター節、それを波括弧でくくったもの、または、１つのゲッター節に１つのセッター節を続けて波括弧でくくったものから成ることができることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This definition of multiple subscripts is known as subscript overloading.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この複数の添え字の定義は、添え字オーバーロードとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This design pattern is implemented by defining a protocol that encapsulates the delegated responsibilities, such that a conforming type (known as a delegate) is guaranteed to provide the functionality that has been delegated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このデザイン・パターンは、委任された責務をカプセル化するプロトコルを定義することによって実装されます、例えば、委任プロトコルに拠準する型が（代表、委任先として知られるものが）その委任されている機能性を提供する責任を負わされるといったこと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This designated initializer matches a designated initializer from the superclass of Bicycle, and so the Bicycle version of this initializer is marked with the override modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この指定イニシャライザはBicycleのスーパークラスでのある指定イニシャライザと一致します、なのでこのイニシャライザのBicycle改変板はoverride修飾子で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This dictionary literal contains two String: String pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この辞書リテラルは、String: Stringの組みを２つ含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This distinction is not visible when the captured variable’s type has reference semantics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この相違は、キャプチャされた変数の型が参照意味論を持つ場合には見られません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This does not, however, cause the observer to be called again.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、しかし、このオブザーバーが再び呼び出されるようにしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This empty protocol indicates that a type can be used for error handling.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この空のプロトコルは、ある型がエラー処理のために使われることができるのを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables printMathResult(_:_:_:) to hand off some of its functionality to the caller of the function in a type-safe way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、printMathResult(_:_:_:)にその機能性の一部をその関数の呼び出し手に、ある型安全な方法で、手渡すことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables TrackedString to modify the numberOfEdits property internally, but to present the property as a read-only property when it is used outside the structure’s definition—including any extensions to TrackedString.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これがTrackedStringに可能にするのは、numberOfEditsプロパティを内部のように修正すること、しかしそのプロパティをそれが構造体の定義—TrackedStringに対するあらゆる拡張を含めて—の外側で使われる時は読み出し専用プロパティとして提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables both properties to be accessed directly (without optional unwrapping) once initialization is complete, while still avoiding a reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、一旦初期化が終了しているならば、両方のプロパティが直接にアクセスされるのを（オプショナルをアンラップすることなく）可能にします、その一方で、依然として参照循環を避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables structures and enumerations to adopt the protocol and satisfy that method requirement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、構造体と列挙に、そのプロトコルを採用してメソッド要件を満たすのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to be notified when the value of an inherited property changes, regardless of how that property was originally implemented.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、そのプロパティが元々どのように実装されるかに関係なく、継承されたプロパティの値が変わるとき通知されることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to catch and fix errors as early as possible in the development process.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたに開発過程においてエラーをできるだけ早く捕えて修復するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to check for a successful downcast.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたに成功したダウンキャストについて調べるのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to check for their existence within the closure’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、クロージャの本文内でそれらの存在について調べることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to check whether or not an update took place.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、更新が起こったかどうか、確認することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to create protocols that can only be adopted within a certain access context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたに特定のアクセス文脈内で採用されることだけができるプロトコルを作成するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to define a subclass for which initialization cannot fail, even though initialization of the superclass is allowed to fail.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、それに対しての初期化が失敗することが出来ないサブクラスを定義することを可能にします、たとえスーパークラスの初期化が失敗することが許されるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to drill down into subproperties within complex models of interrelated types, and to check whether it is possible to access properties, methods, and subscripts on those subproperties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、相互に関係づけられた型である複雑なモデルの内部の下位情報に掘り下げていくこと、そしてそれらの下位情報上でプロパティ、メソッド、そして添え字にアクセスすることが可能であるかどうか確認することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to extend other types to accept your own custom types as initializer parameters, or to provide additional initialization options that were not included as part of the type’s original implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたに別の型を拡張してあなた独自のあつらえの型をイニシャライザパラメータとして受け入れるようにすること、またはその型の最初の実装の一部として含まれなかった追加の初期化選択肢を提供することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to leave some aspects of a function’s implementation for the function’s caller to provide when the function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、ある関数の実装のいくつかの側面をその関数の呼び出し側のために、その関数が呼ばれるとき提供する目的で、取っておくことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to see whether instances of Person and Apartment are being deallocated as expected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたに期待されるようにPersonとApartmentのインスタンスが割り当て解除されているかどうか知ることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to store additional custom information along with the case value, and permits this information to vary each time you use that case in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、ケース節値とともに追加の特注の情報を格納するのを可能にして、あなたがあなたのコードにおいてそのケース節を使うたびにこの情報が変化するのを許します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to use an if statement to check whether it was possible to call the printNumberOfRooms() method, even though the method does not itself define a return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたにif文をprintNumberOfRooms()メソッドを呼び出すことが可能か調べるために使うことを可能にします、たとえそのメソッドがそれ自身では戻り値を定義しないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This encoding for negative numbers is known as a two’s complement representation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この負数のための符号化は、２の補数表現として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures that a CreditCard instance always has a customer instance associated with it when the CreditCard instance is created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、CreditCardインスタンスがつくられるとき、CreditCardインスタンスが常にそれと結びつけられるCustomerインスタンスを持つことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures that all of the protocol’s requirements will be visible on any type that adopts the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、プロトコルを採用するあらゆる型上で、プロトコルのもつ要件の全てが見えることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures that class instances do not take up space in memory when they are no longer needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、クラスインスタンスが、それらがもはや必要でない時に、メモリ上で場所を取らないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures that the numberOfWheels inherited property is initialized by Vehicle before Bicycle has the opportunity to modify the property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは継承されたプロパティnumberOfWheelsが、Bicycleがそのプロパティを変更する機会を得る前に、Vehicleによってイニシャライズされることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures that, no matter which part of the compound case matched, the code in the body of the case can always access a value for the bindings and that the value always has the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、たとえ複合ケース節のどの部分がマッチしたとしても、ケース節の本文のコードが常に束縛のための値にアクセスできること、そしてその値が常に同じ型を持つことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enumeration can store three kinds of arithmetic expressions: a plain number, the addition of two expressions, and the multiplication of two expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この列挙は、３種類の算術式：普通の数字、２つの式の加算、そして２つの式の乗算を格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enumeration toggles between two states, indicated by the enumeration cases on and off.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この列挙は、列挙のケース節onとoffで示される、２つの状態の間で切替えをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enumeration, called Kind, expresses the kind of number that a particular integer represents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この列挙は、Kindと呼ばれ、特定の整数を表わす数の種類を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This exactly matches the method type needed by the sorted(by:) method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、sorted(by:)メソッドによって必要とされるメソッド型に正確に適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example adds a new nested enumeration to Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、新しい入れ子にされた列挙をIntに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example adds an integer subscript to Swift’s built-in Int type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、整数添え字をスウィフトの組み込みのInt型に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example adds five computed instance properties to Swift’s built-in Double type, to provide basic support for working with distance units:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、５つの計算インスタンスプロパティをスウィフトの組み込みのDouble型に加えて、距離単位を扱うための基本的な支持を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example adds together the vectors (3.0, 1.0) and (2.0, 4.0) to make the vector (5.0, 5.0), as illustrated below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、下で図示されるように、ベクトル(3.0、1.0)と(2.0、4.0)を一緒に加えて、ベクトル(5.0, 5.0)を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example also adds a new computed instance property to Int, called kind, which returns the appropriate Kind enumeration case for that integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はまた、新しい計算インスタンスプロパティをIntに加えます、それは、kindと呼ばれ、その整数に対する適切なKind列挙ケース節を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example checks numberSymbol to determine whether it is a Latin, Arabic, Chinese, or Thai symbol for the numbers 1 to 4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、numberSymbolを、それが1から4のラテン、アラビア語、中国語、またはタイ語であるかどうか明らかにするために調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example considers two Bool values and only allows access if both values are true:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、２つのBool値を考慮して、両方の値がtrueの場合にのみアクセスを許します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example creates a new variable called productBarcode and assigns it a value of Barcode.upc with an associated tuple value of (8, 85909, 51226, 3).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、productBarcodeと呼ばれる新しい変数をつくって、それにあるひとつのBarcode.upcの値を関連したタプル値(8, 85909, 51226, 3)とともに代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example creates an array of TextRepresentable things:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、TextRepresentableなものの配列をつくります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example creates an empty dictionary of type [Int: String] to store human-readable names of integer values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、型[Int: String]の空の辞書を、整数値の人間の読み込み可能な名前を格納するために作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example declares a constant called hd and sets it to a Resolution instance initialized with the width and height of full HD video (1920 pixels wide by 1080 pixels high).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、hdと呼ばれる定数を宣言して、それをフルHDビデオの幅と高さ（1920ピクセル幅の広さで1080ピクセルの高さがある）で初期化されるResolutionインスタンスに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example declares a new String variable called description and assigns it an initial value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、descriptionと呼ばれる新しいString変数を宣言して、それに最初の値を代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example declares a new constant called tenEighty and sets it to refer to a new instance of the VideoMode class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、tenEightyと呼ばれる新しい定数を宣言して、それをVideoModeクラスの新しいインスタンスに言及するように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a class called ShoppingListItem, which encapsulates the name, quantity, and purchase state of an item in a shopping list:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はShoppingListItemと呼ばれるクラスを定義します、それは、ある購入品目リストにおける名前、量、そしてある項目の購入状態といったものをカプセル化します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a class called HTMLElement, which provides a simple model for an individual element within an HTML document:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はHTMLElementと呼ばれるクラスを定義します、それは、HTML文書内個々の要素に対する単純なモデルを用意します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a function called printMathResult(_:_:_:), which has three parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はprintMathResult(_:_:_:)と呼ばれる関数を定義します、それは３つのパラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a hierarchy of three classes called Food, RecipeIngredient, and ShoppingListItem, and demonstrates how their initializers interact.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、Food、RecipeIngredient、そしてShoppingListItemと呼ばれる３つのクラスの階層を定義して、それらのイニシャライザが相互に作用する方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a new class called Dice, which represents an n-sided dice for use in a board game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はDiceと呼ばれる新しいクラスを定義します、それは、ボードゲームで使うのためにn面のさいころを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a new protocol, PrettyTextRepresentable, which inherits from TextRepresentable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、ある新しいプロトコル、PrettyTextRepresentableを定義します、それは、TextRepresentableから継承を受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a new structure called Cuboid, which represents a 3D rectangular box with width, height, and depth properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はCuboidと呼ばれる新しい構造体を定義します、それは、width、height、そしてdepthプロパティで3D矩形の箱を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a protocol called HasArea, with a single property requirement of a gettable Double property called area:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、areaと呼ばれる取得可能なDoubleプロパティである１つだけのプロパティ要件をもつ、HasAreaと呼ばれるプロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a protocol called Named, with a single requirement for a gettable String property called name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、nameと呼ばれる取得可能なStringプロパティのための要件を１つ持つ、Namedと呼ばれるプロトコルを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a structure called Person, which represents a specific named person.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、Personと呼ばれる構造体を定義します、それは、特定の名前の人物を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines an enumeration for a three-state switch.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、３つの状態を切り替えるために、ある列挙を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines three structures for working with geometric shapes:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、幾何学形を扱うために３つの構造体を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines two classes called DataImporter and DataManager, neither of which is shown in full:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、DataImporterとDataManagerと呼ばれる２つのクラスを定義します、そのどちらも全部は示されません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines two classes called Person and Apartment, which model a block of apartments and its residents:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はPersonとApartmentと呼ばれる２つのクラスを定義します、それは、アパートの１区画とその居住者をモデル化します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines two new types, Bank and Player, for a simple game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、２つの新しい型BankとPlayerを、単純なゲームのために定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines two simple mathematical functions called addTwoInts and multiplyTwoInts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、addTwoIntsとmultiplyTwoIntsと呼ばれる２つの単純な数学的な関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example identifies Uranus from its raw value of 7:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、その生の値の7からUranus（天王星）を特定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example initializes a UInt8 integer with the binary value 00001111, which has its first four bits set to 0, and its second four bits set to 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、UInt8整数を２進数の値00001111で初期化します、それは、その最初の４つのビットを0に設定して、次の４つのビットを1に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example is sorting an array of String values, and so the sorting closure needs to be a function of type (String, String) -&gt; Bool.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はString値の配列を分類しています、なのでソート・クロージャは型(String, String) -&gt; Boolの関数である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example iterates through all items in the library array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、library配列の中の全ての項目の端が端まで繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example plays a simple game of Snakes and Ladders (also known as Chutes and Ladders):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、単純なゲームの「ヘビとはしご」（また、「荷すべらしとはしご」として知られます）で遊びます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example prints the first few entries in the five-times table:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、九九の５の段の表の最初のいくつかの項を出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example provides a type annotation for a variable called welcomeMessage, to indicate that the variable can store String values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、welcomeMessageと呼ばれる変数に対して、その変数はString値を保存できることを示すために型注釈を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example sets a constant called incrementByTen to refer to an incrementer function that adds 10 to its runningTotal variable each time it is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、incrementByTenと呼ばれる定数を、それが呼ばれるたびに10をそのrunningTotal変数に加えるあるインクリメンタ関数に言及するように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example starts with a simple class called Person, which defines a stored constant property called name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、Personと呼ばれる単純なクラスから始めます、それは、nameと呼ばれる保存定数プロパティを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example uses a UInt32 constant called pink to store a Cascading Style Sheets color value for the color pink.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、ピンク色のカスケーディング・スタイル・シートの色値を保存するために、pinkと呼ばれるUInt32定数を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example uses a switch statement to consider a single lowercase character called someCharacter:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はswitch文を一つの小文字の文字、someCharacterと呼ばれるものについて考察するために使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example uses multiple &amp;&amp; and || operators to create a longer compound expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、より長く複雑な式をつくるために複数の&amp;&amp;と||演算子を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example uses number intervals to provide a natural-language count for numbers of any size:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、自然言語の数え方をどんな大きさの数にも用意するために、数の区間を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example uses optional binding to try to access a planet with a raw value of 11.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、11の生の値で惑星にアクセスすることを試みるためにオプショナル束縛を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example’s willSet observer uses a custom parameter name of newTotalSteps for the upcoming new value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例のwillSetオブザーバーは、来るべき新しい値のためにあつらえのパラメータ名newTotalStepsを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This exception ensures that an older compiler doesn’t attempt to parse syntax introduced in a newer version of Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例外は、古いコンパイラがより新しいバージョンのスウィフトで導入される構文の解析を試みないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This expression calculates the value of Double(multiplier) * 2.5 and inserts the result (7.5) into the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この式は、Double(multiplier) * 2.5の値を計算して、結果（7.5）を文字列に差し込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This extension adopts the new protocol in exactly the same way as if Dice had provided it in its original implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この拡張は、まるでDiceがその最初の実装においてそれを提供したかのように、正確に同じふうに新しいプロトコルを採用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This extension states that it adopts the PrettyTextRepresentable protocol and provides an implementation of the prettyTextualDescription property for the SnakesAndLadders type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この拡張が述べるのは、それがPrettyTextRepresentableプロトコルを採用してprettyTextualDescriptionプロパティの実装をSnakesAndLadders型に提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This failure might be triggered by invalid initialization parameter values, the absence of a required external resource, or some other condition that prevents initialization from succeeding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この失敗は、無効な初期化パラメータ、必須の外部リソースの欠如、または初期化がうまくいくのを妨げる何か他の状況によって引き起こされるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この特徴によってあなたは、あなたのコードの実施詳細を隠すこと、そしてそれを通してそのコードがアクセスされ使用されることができる好ましいインタフェースを指定することが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature is represented by a structure called Values, which is nested within the Rank enumeration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この特徴はValuesと呼ばれる構造体で表されます、それは、Rank列挙の内部で入れ子にされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature prevents the assignment operator (=) from being used by accident when the equal to operator (==) is actually intended.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この特徴は、実際には同等演算子（==）が意図されるときに、偶然に代入演算子（=）が使われるのを防止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form of the operator will always return an optional value, and the value will be nil if the downcast was not possible.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子のこの形式は、常にオプショナルの値を返します、そしてダウンキャストが可能でなかったならばその値はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form of the operator will trigger a runtime error if you try to downcast to an incorrect class type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子のこの形式は、あなたが適切でないクラス型へのダウンキャストをためすならば、実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function does not compile as written above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は、上記のように書かれるとしてもコンパイルしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function evaluates a plain number by simply returning the associated value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は、普通の数字を単に関連値を返すことによって評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function makes use of in-out parameters to swap the values of a and b, as described in In-Out Parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は、値aとbを交換するためにin-outパラメータの利用を行います、In-Outパラメータで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function simply adds amount to runningTotal, and returns the result.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は、単にamountをrunningTotalに加えて、結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function takes a person’s name and whether they have already been greeted as input, and returns an appropriate greeting for that person:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は、人物の名前と彼らがすでに挨拶されたかどうかを入力として取って、ふさわしい挨拶をその人物に対して返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function takes two arguments called someContainer and anotherContainer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は、someContainerとanotherContainerと呼ばれる２つの引数をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function, printIntegerKinds(_:), takes an input array of Int values and iterates over those values in turn.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数、printIntegerKinds(_:)は、Int値の配列の入力を取り、それらの値に最初から終わりまで順番に繰り返していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This functionality is provided by the DataImporter class, which is assumed to take a non-trivial amount of time to initialize.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この機能性はDataImporterクラスによって提供されます、それは、初期化するために取るに足らない量ではない時間がかかると仮定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This future type can be referred to as “Element” anywhere within the structure’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この将来の型は、構造体の定義の範囲内のどこででも「Element」として参照されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives a reverse alphabetical sort, with "Barry" being placed before "Alex", and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、"Barry"が"Alex"の前に置かれるなどの、逆アルファベット順の分類を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This greeting is then passed back out of the function using the return keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挨拶は、それからreturnキーワードを使用して逆に関数の外に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This helps you remember that it’s possible to capture self by accident.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、偶然にselfを捕らえることは可能であるのをあなたが忘れないことを手助けします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This illustrates that the overall call to the sorted(by:) method has remained the same.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、sorted(by:)メソッドへの呼び出し全体が、同じもののままだったことを図解します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This implementation of HTMLElement is identical to the previous implementation, apart from the addition of a capture list within the asHTML closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>HTMLElementのこの実装は、asHTMLクロージャ内の捕獲リストの追加は別として、前の実装と同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes String, as shown here, as well as collection types such as Array, Dictionary, and Set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、ここで示すようにStringを、それだけでなくArray、Dictionary、そしてSetといったコレクション型も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes String, as shown here, as well as collection types such as Array, Dictionary, and Set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、ここで示すようにStringを、それだけでなくArray、Dictionary、そしてSetといったコレクション型も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes a protocol with an associated type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、関連型を使うプロトコルを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes the ability to extend types for which you do not have access to the original source code (known as retroactive modeling).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたが元々のソース・コードにアクセスをしないで型を拡張する能力を含みます（遡及モデリングとして知られます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer can be used to create a new Food instance with a specific name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザが、ある特定の名前を使って新しいFoodインスタンスをつくるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer checks if the species value passed to the initializer is an empty string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、イニシャライザに渡されるspecies値が空の文字列かどうか検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer has a parameter called generator, which is also of type RandomNumberGenerator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、generatorと呼ばれるパラメータを持ちます、それもまた、型RandomNumberGeneratorです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer has an empty body, represented by an empty pair of curly braces {}.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、一対の空の波括弧{}によって表される空の本文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer is described in more detail in Creating an Array with a Default Value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、更に詳細に配列を１つの初期値で作成するで記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer is therefore inherited by RecipeIngredient.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、したがって、RecipeIngredientによって継承されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer simply assigns the origin and size argument values to the appropriate stored properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、単に引数値originとsizeを適切な保存プロパティに代入します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer starts by assigning the passed quantity argument to the quantity property, which is the only new property introduced by RecipeIngredient.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、渡されたquantity引数をquantityプロパティに代入することによって始めます、それは、RecipeIngredientによって導入される唯一の新しいプロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a constant value of 10 for all AudioChannel instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、定数値で、全てのAudioChannelインスタンスのために10です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a stored property with willSet and didSet observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、willSetとdidSetオブザーバーを持つ保存プロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is also a comment</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これもコメントです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because functions and closures are reference types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、関数とクロージャが参照型であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because of the copy-in copy-out memory model for in-out parameters: The value is always written back to the property at the end of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、in-outパラメータのための「コピーイン、コピーアウト」メモリーモデルが理由です：値は常に、その関数の終わりでプロパティへと書き込まれて戻されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、型それ自身には初期化時に値を保存型プロパティに代入することができるイニシャライザがないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is equivalent to a decimal value of 15.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、10進の値の15に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is indicated by passing a value of 3 to the structure’s initializer as the value to use for the instance’s multiplier parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、値3をこの構造体のinitializerにインスタンスのmultiplierパラメータのために使う値として渡すことによって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is indicated by setting the optional playerOne variable to nil, meaning “no Player instance.” At the point that this happens, the playerOne variable’s reference to the Player instance is broken.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはオプショナルのplayerOne変数に、「Playerインスタンスがない」ことを意味する、nilを設定することによって示されます。これが起こる時点で、playerOne変数のもつPlayerインスタンスへの参照は壊れています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as closing over those constants and variables.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、そのような定数や変数をすっかりクローズする（閉じ込める）こととして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as overloading the existing operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存の演算子のオーバーロードとしてこれは知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as overriding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、オーバーライドとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as short-circuit evaluation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは短絡評価として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as short-circuit evaluation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは短絡評価として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、強い参照循環として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is necessary in order for it to be able to access the director or artist property of a Movie or Song for use in the description.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、それがその説明で使う目的でMovieまたはSongのもつdirectorまたはartistプロパティにアクセス可能になるために必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is often done by assigning a literal value (or literal) to the constant or variable at the point that you declare it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、リテラル値（またはリテラル）を定数または変数に、あなたがそれを宣言する時点で代入することによって、しばしば行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is particularly true when you work with functions or methods that take functions as one or more of their arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つ以上のそれの引数として関数をとる関数またはメソッドをあなたが扱うとき、これは特に当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is represented by the player’s coinsInPurse property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、プレーヤーのcoinsInPurseプロパティによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is simply an empty tuple, which is written as ().</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは単に空のタプルです、それは()のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the end of the first multiline comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（最初の複数行コメントの終わり。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the same as 0xCC, which has a decimal value of 204.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは0xCCと同じものです、それは、10進の値の204を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the second, nested multiline comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（第二の入れ子の複数行コメント。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the standard calling convention for function values in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、スウィフトにおける関数値のための標準的な呼出規約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the start of the first multiline comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（最初の複数行コメントの始まり。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is true even for constant stored properties, as described in Assigning Constant Properties During Initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化の間に定数プロパティを割り当てるで記述されるように、これは定数保存プロパティにさえあてはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is true even if the new value is the same as the current value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、たとえ新しい値が現在の値と同じものであるとしても当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is true even if you are overriding an automatically provided default initializer, as described in Default Initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、省略時のイニシャライザで記述されるように、あなたが自動的に提供される省略時のイニシャライザをオーバーライドしている場合にさえもあてはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is true even though increment(forCount:) is defined as returning a nonoptional Int value in the definition of CounterDataSource.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえincrement(forCount:)がCounterDataSourceの定義の中で非オプショナルのInt値を返すように定義されるとしても、これは当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is true even though type method requirements are prefixed with the class or static keyword when implemented by a class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ型メソッド要件がクラスによって実装されるときclassまたはstaticキーワードを前に置かれるとしても、これは当てはまります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is very similar to placing an exclamation mark (!) after an optional value to force the unwrapping of its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、その値を強制アンラップするためにオプショナルの値の後に感嘆符（!）を置くことに非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is why increment(forCount:) is also written with a question mark after its name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが、increment(forCount:)もまたその名前の後に疑問符を書かれる理由です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is why the m computed property returns self—the expression 1.m is considered to calculate a Double value of 1.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これがm計算プロパティがselfを返す理由です ― 式1.mは、1.0のDouble値を計算するものと考えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This keeps track of the maximum input value that has been received by any AudioChannel instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あらゆるAudioChannelインスタンスによって受け取られた最大入力値の情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This key-value type matches the type of the airports variable declaration (a dictionary with only String keys, and only String values), and so the assignment of the dictionary literal is permitted as a way to initialize the airports dictionary with two initial items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この「キーと値」型は、airports変数の宣言の型（Stringのキーのみ、そしてStringの値のみをもつ辞書）に合致します、なのでこの辞書リテラルを代入することは、２つの最初の項目でairports辞書を初期化する方法として許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This keyword indicates that the definition of the closure’s parameters and return type has finished, and the body of the closure is about to begin.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このキーワードはクロージャのパラメータと戻り型の定義が終わったことを示します、そして、クロージャの本文はまさに開始しようとしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of function call expression has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この種類の関数呼び出し式は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of function is known as a nested function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この種類の関数は、入れ子にされた関数として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This lets you call the throwing function inside a do-catch block and handle errors in the catch clause by throwing a different error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたにスロー関数をdo-catchプロックの内部で呼び出させ、そのcatch節において異なるエラーをスローすることによって、エラーを取り扱わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This list is transformed into a tree by applying operator precedence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このリストは、演算子優先順位を適用することによって、ツリー（木構造）に変えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes for highly readable code when working with explicitly-typed enumeration values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、明示的に型指定された列挙値を扱うとき、非常に可読性の高いコードにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it easy to create custom string values for display, storage, and printing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、表示、保存、そして出力するために個々の注文に応じた文字列値をつくることを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes the switch statement safer and easier to use than the one in C and avoids executing more than one switch case by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、switch文をCのものよりも安全で使いやすくして、誤って複数のswitchケース節を実行することを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This matches the single requirement of the FullyNamed protocol, and means that Person has correctly conformed to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、FullyNamedプロトコルの唯一の要件に適合します、したがってそのPersonが正しくそのプロトコルに従ったことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This matches the type of the shoppingList variable’s declaration (an array that can only contain String values), and so the assignment of the array literal is permitted as a way to initialize shoppingList with two initial items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはshoppingList変数の宣言（String値を含むことだけができる配列）の型に合致します、それでこの配列リテラルの代入は、２つの最初の項目でshoppingListを初期化するためのやり方として認められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means it is possible to have precedence groups with undefined relative precedence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが意味するのは、未定義の関係優先順位による優先順位グループを持つことは可能だということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that 4.75 becomes 4, and -3.9 becomes -3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、4.75が4に、そして-3.9が-3になることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that SomeInternalClass and someInternalConstant can be written without an explicit access-level modifier, and will still have an access level of internal:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、SomeInternalClassとsomeInternalConstantが明示的なアクセス水準修飾子なしで書かれることができ、それでもまだ内部のアクセス水準を持つことを意味します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that a % b and a % -b always give the same answer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、a % bとa % -bが常に同じ答えを与えることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that a defer statement can be used, for example, to perform manual resource management such as closing file descriptors, and to perform actions that need to happen even if an error is thrown.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはdefer文が、例えば、ファイル記述子を閉じることなどの手動リソース管理を実行するために、そしてたとえエラーがスローされるとしても起こることが必要な動作を実行するために使われることができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that a change to the value of a in the outer scope does not affect the value of a in the inner scope, nor does a change to a inside the closure affect the value of a outside the closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが意味するのは、外側のスコープのaの値に対する変更は内側のスコープのaの値に影響を及ぼさない、そしてまたクロージャ内部のaに対する変更はクロージャ外部のaに影響を及ぼさないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that a function can return another function as its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、ある関数が別の関数をその値として返すことができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that all of the information needed to infer an omitted type or part of a type in an expression must be accessible from type-checking the expression or one of its subexpressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、ある式における省略される型や型の一部分を推論するために必要とされる情報のすべては、型を調べているその式またはそれの下位式の１つからアクセス可能でなければならないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that any structure and enumeration instances you create—and any value types they have as properties—are always copied when they are passed around in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたがつくるあらゆる構造体や列挙のインスタンス ― そして、それらがプロパティとして持つあらゆる値型 ― は、あなたのコードの中であちこち渡される時に常にコピーされることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that classes have additional responsibilities for ensuring that all stored properties they inherit are assigned a suitable value during initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、クラスが、それが継承する全ての保存プロパティが初期化の間に適切な値を代入されることを確実にすることに対する追加の責任を持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that code that would otherwise run immediately after the call is never executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが意味するのは、そうでなければ呼び出しの直後に動作するコードは、決して実行されないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that data such as strings, arrays, and dictionaries are copied when they are assigned to a new constant or variable, or when they are passed to a function or method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、文字列、配列、および辞書などのデータが、それらが新しい定数や変数に代入される時に、またはそれらが関数やメソッドに渡される時に、コピーされることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that different characters—and different representations of the same character—can require different amounts of memory to store.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは異なる文字—さらに同じ文字の異なる表現—が、保存するために異なる量のメモリを必要とすることがあるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that in the example above, array3D[0] refers to [[1, 2], [3, 4]], array3D[0][1] refers to [3, 4], and array3D[0][1][1] refers to the value 4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、上の例で、array3D[0]は[[1, 2], [3, 4]]に言及し、array3D[0][1]は[3, 4]に言及し、そしてarray3D[0][1][1]は値４に言及することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that it returns a function, rather than a simple value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、それが関数を返すことを意味します、単純なひとつの値ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the (String, String) and Bool types do not need to be written as part of the closure expression’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、(String, String)およびBool型が、クロージャ式の定義の一部として書かれる必要がないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the capitalCity property has a default value of nil, like any other optional, but can be accessed without the need to unwrap its value as described in Implicitly Unwrapped Optionals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、暗黙的にアンラップされるオプショナルで記述されるように、capitalCityプロパティが、オプショナルの他のものの様に、nilの省略時の値を持つが、アンラップする必要なしでその値にアクセスされることができることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the Country initializer can start to reference and pass around the implicit self property as soon as the name property is set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはCountryイニシャライザが、nameプロパティが設定されるとすぐに、暗黙のselfプロパティに基づいて参照したり渡したりを可能であるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the letter "B" is “greater than” the letter "A", and the string "Tom" is greater than the string "Tim".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは文字"B"は文字"A"「より大きい」こと、そして文字列"Tom"は文字列"Tim"よりも大きいことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the value is allowed to outlive the lifetime of the call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、その値が呼び出しのライフタイムより長生きするのを許されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that they are suited to different kinds of tasks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、それらが異なる種類の作業に適していることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that they return a value of (), or an empty tuple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、それらが値()、または空のタプルを返すことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that when you break the strong reference held by the john variable by setting it to nil, there are no more strong references to the Person instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたがjohn変数によって保持される強い参照を、それをnilに設定することによって壊すとき、Personインスタンスへの強い参照がもうそれ以上ないことを意味します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you can change (or mutate) the collection after it is created by adding, removing, or changing items in the collection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたがそのコレクションをそれが作成された後に追加したり、取り除いたり、またはコレクションの中の項目を変えることによって、変更する（または変化させる）ことが出来るのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you can extend Array to conform to the Container protocol simply by declaring that Array adopts the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたがArrayを拡張してContainerプロトコルに準拠することが、Arrayがそのプロトコルを採用すると宣言することによって可能であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you can use self to disambiguate between type properties and type method parameters, just as you do for instance properties and instance method parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたが型プロパティと型メソッドパラメータの間で曖昧さをなくすためにselfを使うことができることを意味します、ちょうどあなたがインスタンスプロパティとインスタンスメソッドパラメータでするように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you cannot access any other property values from within your closure, even if those properties have default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、たとえそれらのプロパティには省略時の値があるとしても、あなたがあなたのクロージャ内から他のどのプロパティ値にもアクセスすることができないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you cannot insert a value of the wrong type into a collection by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたが間違った型の値を誤ってあるコレクションの中に入れることが不可能なことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you can’t accidentally access methods or properties that the class implements in addition to its protocol conformance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、クラスがそれのプロトコル準拠にさらに加えて実装するメソッドやプロパティにあなたが偶然にアクセスすることができないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you can’t change the value of a parameter by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたが誤ってパラメータの値を変えることができないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means you always get great performance when working with strings as value types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、値型として文字列を扱うとき、あなたは常に非常に大きいパフォーマンスを得ることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means you can use constants to name a value that you determine once but use in many places.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたが一度だけ決定するが多くの場所で使用する値に対して名前をつけるために定数を利用できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means, if you import Foundation, you can access those NSString methods on String without casting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが意味するのは、あなたがFoundationをインポートするならば、あなたはそれらNSStringメソッドにString上でキャストなしでアクセスできるという事です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This memory holds information about the type of the instance, together with the values of any stored properties associated with that instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメモリは、インスタンスの型に関する情報を、そのインスタンスと結びつけられるあらゆる保存プロパティの値と共に持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method calls the generator’s random() method to create a new random number between 0.0 and 1.0, and uses this random number to create a dice roll value within the correct range.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは、0.0と1.0の間で新しい乱数をつくるgeneratorのrandom()メソッドを呼んで、この乱数を正しい範囲内でさいころを振った値をつくるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method checks the properties of the address and returns buildingName if it has a value, or buildingNumber concatenated with street if both have values, or nil otherwise.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは、アドレスのプロパティを調べて、それが値を持つならばbuildingNameを、または両方とも値を持つならばbuildingNumberに繋げてstreetを、またはそれ以外ではnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method does not actually do anything for a base Vehicle instance, but will be customized by subclasses of Vehicle later on:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは実際に何かを基盤Vehicleインスタンスのために行うわけではありません、しかし後でVehicleのサブクラスによって目的に合わせて作り変えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method does not specify a return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは、戻り型を指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method removes the item at the specified index and returns the removed item (although you can ignore the returned value if you do not need it):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは、指定されたインデックスでの項目を取り除いて、取り除かれた項目を返します（けれども、あなたがそれを必要としないならば、返された値を無視することができます）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method removes the key-value pair if it exists and returns the removed value, or returns nil if no value existed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは、それが存在するならば「キーと値」の対を削除して、削除された値を返します、または値が存在しないならばnilを返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method returns a value of type String?.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは、型String?の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method unlocks the next level for all players and updates the player’s progress to move them to the next level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは、全てのプレーヤーたちのために次のレベルの錠をあけて、プレーヤーの進捗をかれらを次のレベルへ移動するために更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This might be a description of itself, or a text version of its current state:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、それ自身の説明、またはテキスト版のそれの現在の状態であるかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This might be because a DataImporter instance needs to open a file and read its contents into memory when the DataImporter instance is initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、DataImporterインスタンスが初期化されるとき、DataImporterインスタンスがファイルを開いてメモリーにその内容を読む必要があるからでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This modification tracking is implemented with a didSet property observer on the value property, which increments numberOfEdits every time the value property is set to a new value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修正追跡は、didSetプロパティオブザーバーとしてvalueプロパティ上で実行されます、それは、numberOfEditsをvalueプロパティが新しい値に設定されるたびに増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This new default can still be overridden within the extension for individual type members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この新しい省略時設定はさらに、個々の型メンバーのために拡張内でオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This new initializer starts by calculating an appropriate origin point based on the provided center point and size value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この新しいイニシャライザは、提供されたcenter点とsize値に基づいて適切な起源点を計算することによって始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This next code snippet defines an optional Customer variable called john, which will be used to store a reference to a specific customer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のコード断片は、johnと呼ばれる、オプショナルのCustomer変数を定義します。それは、特定の顧客への参照を保存するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This next code snippet defines two variables of optional type called john and unit4A, which will be set to a specific Apartment and Person instance below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この次のコード断片はjohnとunit4Aと呼ばれるオプショナルの型の２つの変数を定義します、それは、特定のApartmentとPersonインスタンスに以降で設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This next example shows a class called DiceGameTracker, which adopts the DiceGameDelegate protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この次の例はDiceGameTrackerと呼ばれるクラスを示します、それは、DiceGameDelegateプロトコルを採用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This number is then shifted 16 places to the right (&gt;&gt; 16).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この数は、それから右に16桁シフトされます（&gt;&gt; 16）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This observer performs two checks:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このオブザーバーは、２つのチェックをします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator adds together the x values of two vectors, and subtracts the y value of the second vector from the first.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この演算子は、２つのベクトルのx値を一緒に加えて、第二のベクトルのy値を最初のものから減じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator does not have an existing meaning in Swift, and so it is given its own custom meaning below in the specific context of working with Vector2D instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この演算子は、スウィフトにおいて既存の意味を持ちません、なので、それはVector2Dインスタンスを扱う特定の文脈の下で、独自のあつらえの意味を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This opt-in approach prevents hidden conversion errors and helps make type conversion intentions explicit in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このオプトインの（個々に決めていく）取り組み方は、隠された変換エラーを防いで、あなたのコードにおいて型変換の意図を明確にするのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This optional binding is written “if let movie = item as? Movie”, which can be read as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このオプショナル束縛は「if let movie = item as? Movie」のように書かれます、それは、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This optional value contains the old value for that key if one existed before the update, or nil if no value existed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このオプショナルの値は、それが更新の前に存在するならばそのキーに対する古い値を、値が存在しないならばnilを含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This output value is then shifted eight places to the right, giving a value of 0x66, which has a decimal value of 102.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この出力値は、それから８桁右にシフトされて、0x66の値を与えます、それは10進の値の102を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This part of the book describes the formal grammar of the Swift programming language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本のこの部分は、スウィフトプログラミング言語の形式文法を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This placeholder is replaced with the actual value of multiplier when the string interpolation is evaluated to create an actual string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプレースホルダーは、文字列補間が実際の文字列を作成するために評価されるとき、multiplierの実際の値と取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This procedure is known as switching on the value that is being considered.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この手順は、考察されている値での切り替え（スイッチング）として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process continues until the end of the range is reached.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この過程は、範囲の終わりに達するまで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that is required before the new instance is ready for use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この過程は、そのインスタンスの保存プロパティそれぞれに初期値を設定すること、および新しいインスタンスの使用準備が整う前に必要とされる他のあらゆる設定や初期化を行うことを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process is described in Resolving Strong Reference Cycles Between Class Instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この過程は、クラスインスタンス間の強い参照循環の解消で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process is described in Modifying Value Types from Within Instance Methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この過程は、値型をインスタンスメソッド内から修正するで記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process is described in Working with Characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このやり方は文字を扱うで記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process satisfies safety check 1 from Two-Phase Initialization above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この過程は、上記の２段階初期化の安全点検１を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process transforms it into the tree (2 + (3 * 5)).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この処理は、それをツリー(2 + (3 * 5))に変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process, known as initializer delegation, avoids duplicating code across multiple initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この処理、イニシャライザ委任として知られるものは、複数のイニシャライザにまたがってコードを繰り返し複製することを避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This property is of type String.UTF16View, which is a collection of unsigned 16-bit (UInt16) values, one for each 16-bit code unit in the string’s UTF-16 representation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロパティは型String.UTF16Viewです、そしてそれは、符号なし16ビット（UInt16）の値の集まりで、そのひとつがその文字列のUTF-16叙述における各16ビット符号単位です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This property is of type String.UTF8View, which is a collection of unsigned 8-bit (UInt8) values, one for each byte in the string’s UTF-8 representation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロパティは型String.UTF8Viewです、そしてそれは、符号なし８ビット（UInt8）の値の集まりで、それぞれがその文字列のUTF-８叙述における各バイトです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This property is of type UnicodeScalarView, which is a collection of values of type UnicodeScalar.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロパティは型UnicodeScalarViewです、そしてそれは、UnicodeScalar型の値の集まりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This property references a closure that combines name and text into an HTML string fragment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロパティは、nameとtextをHTML文字列断片に結合するクロージャに参照をつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This protocol doesn’t specify how the items in the container should be stored or what type they are allowed to be.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは、コンテナの中の項目が格納されなければならない方法やそれらが許される型が何であるかを指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This protocol, RandomNumberGenerator, requires any conforming type to have an instance method called random, which returns a Double value whenever it is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコル、RandomNumberGeneratorは、あらゆる準拠型にrandomと呼ばれるインスタンスメソッドを持つことを要求します、それは、それが呼ばれた時はいつでもDouble値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This provides a syntactically convenient way to defer the evaluation of an expression without needing to write an explicit closure when you call the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたがその関数を呼び出す時に明示的なクロージャを書く必要なしに、ある式の評価を延期する統語的に便利な方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This provision ensures that the switch statement is exhaustive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この条項は、switch文が徹底的であることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This public-facing interface is the application programming interface (or API) for the framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この公開向けインタフェースは、フレームワークのためのアプリケーション・プログラミング・インタフェース（またはAPI）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This pushes its binary representation just over the size that a UInt8 can hold, causing it to overflow beyond its bounds, as shown in the diagram below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、そのバイナリの表現をちょうどUInt8が持つことができる大きさ以上に押し広げて、それを、下の図で示すように、その境界を越えてあふれさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This relationship has the potential to create a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関係は、強い参照循環をつくる可能性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requests the sixth entry in the three-times-table, which returns a value of 18, or 3 times 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは九九の３の段において６番目の部分を要請します、それは値18、つまり3掛ける6を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requirement ensures that the public-facing API for a type is something you opt in to publishing, and avoids presenting the internal workings of a type as public API by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この要件は、ある型のための公開向けAPIがあなたが公開するように選ぶ何かであることを確実にして、ある型の内部の働きを誤って公開のAPIとして公表することを避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requirement is enforced by a type constraint on the key type for Dictionary, which specifies that the key type must conform to the Hashable protocol, a special protocol defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この要件は、Dictionaryのためのキー型に関する型制約によって強制されます、それは、キー型がスウィフト標準ライブラリで定義される特別なプロトコル、Hashableプロトコルに準拠しなければならないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requirement is expressed through a combination of type constraints and a generic where clause:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この要件は、型制約と総称体where節の組合せによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This restriction protects the implementation details of the TrackedString edit-tracking functionality, while still providing convenient access to an aspect of that functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この制限は、TrackedString編集追跡機能性の実装詳細を保護します、その一方でその機能性の一面への便利なアクセスを依然として提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This rule also applies to type aliases for associated types used to satisfy protocol conformances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この規則はまた、プロトコル準拠を満たすために使われる関連型のための型エイリアスにも適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This rule applies to stored properties as well as computed properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この規則は、保存プロパティに、それだけでなく計算プロパティにも適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This rule pertains even though type property requirements can be prefixed with the class or static keyword when implemented by a class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ型プロパティ要件がクラスによって実装されるときclassまたはstaticキーワードを前に置かれるとしても、この規則は当てはまります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This satisfies rules 2 and 3 from above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、上記の規則２と３を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This scenario is best resolved with a weak reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この筋書きは、弱い参照で最もよく解消されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This scenario is best resolved with an unowned reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この筋書きは、非所有者参照で最もよく解消されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section shows you how to set up such a relationship.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この節は、あなたにそのような関係を設定する方法を教えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section shows you how to write a generic collection type called Stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この節は、あなたにStackと呼ばれる総称体コレクション型を書く方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This square is represented by the blue square in the diagram below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この正方形は、下の図において青い正方形で表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This statement consists of the defer keyword and the statements to be executed later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文は、deferキーワードと後で実行される文から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This statement lets you do any necessary cleanup that should be performed regardless of how execution leaves the current block of code—whether it leaves because an error was thrown or because of a statement such as return or break.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文は、あなたに何らかの不可欠なクリーンアップを行わせます、それはどうやって実行が現在のコードプロックから離れるか ― それがエラーがスローされたためにまたはreturnまたはbreakのような文を理由に離れるかどうかに関係なく実行されるべきものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This strong reference cycle occurs because closures, like classes, are reference types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この強い参照循環は、クロージャが、クラスの様に参照型であるために起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This structure also has a read-only computed property called volume, which calculates and returns the current volume of the cuboid.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この構造体はまた、volumeと呼ばれる読み出し専用の計算プロパティを持ちます、それは、現在の立方体の体積を計算して、返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This structure encapsulates the fact that most cards have one value, but the Ace card has two values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この構造体は、大部分のカードが１つの値を持つという事実をカプセル化します、しかし「エース」カードは２つの値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This structure has two stored properties called width and height.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この構造体は、２つの保存プロパティ、widthとheightと呼ばれるものを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This structure uses an Array property called items to store the values in the stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この構造体は、itemsと呼ばれるArrayプロパティを使って値をスタックに保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This subscript [n] returns the decimal digit n places in from the right of the number:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この添え字[n]は、右の数からの10進桁n位置を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This subscript setting attempt also fails, because residence is currently nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この添え字設定の試みはまた失敗します、なぜならresidenceが現在nilだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This syntactic convenience lets you omit braces around a function’s parameter by writing a normal expression instead of an explicit closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この統語上の便宜は、明示的なクロージャの代わりに通常の関数を書くことによって、あなたに関数のパラメータのまわりの波括弧を省略させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This table describes the changes to The Swift Programming Language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この表は「スウィフトプログラミング言語」に対する変更点を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tag contains the optional text value if it exists, or no text content if text does not exist.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このタグは、それが存在するならばオプショナルのtext値を、あるいはtextが存在しないならば、無いテキスト内容を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tells Swift to execute the closure immediately.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、スウィフトにこのクロージャを直ちに実行するように言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tells Swift to “chain” on the optional residence property and to retrieve the value of numberOfRooms if residence exists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはスウィフトに、オプショナルのresidenceプロパティの上に「繋げて」、そしてresidenceが存在するならばnumberOfRoomsの値を取り出すように言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time around, the Apartment type’s tenant property is declared as a weak reference:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今度は、Apartment型のtenantプロパティは、弱い参照として宣言されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time around, the game has an extra rule:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このたびは、このゲームは特別な規則を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time, however, the associated values can be extracted as part of the switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合ではしかし、関連値がスイッチ文の一部として抽出されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time, the Residence class defines a variable property called rooms, which is initialized with an empty array of type [Room]:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今度は、Residenceクラスはroomsと呼ばれる変数プロパティを定義します、それは、型[Room]の空の配列で初期化されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time, the capture of self by the closure is an unowned reference, and does not keep a strong hold on the HTMLElement instance it has captured.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今度は、クロージャによるselfの捕獲は非所有者参照であって、それが捕獲しているHTMLElementインスタンスに対する強い支配力を保ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time, the sign bit is 1 (meaning “negative”), and the seven value bits have a binary value of 124 (which is 128 - 4):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今度は、符号ビットは1です（「負」を意味します）、そして、７つの値ビットは２進数の値の124を持ちます（それは、128 - 4です）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time, the type parameter Element is used as the type of the append(_:) method’s item parameter and the return type of the subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今度は、型パラメータElementが、append(_:)メソッドのitemパラメータの型および添え字の戻り型として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tour gives you enough information to start writing code in Swift by showing you how to accomplish a variety of programming tasks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このツアーはあなたにスウィフトでコードを書き始めるのに十分な情報を、どうやって様々なプログラミング作業を達成するかをあなたに示すことによって提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type parameter is written within a pair of angle brackets (&lt;Element&gt;) immediately after the structure’s name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この型パラメータは、構造体の名前の直後に一対の山形括弧の内部で（&lt;Element&gt;）書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This value is stored in a type property called highestUnlockedLevel.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この値は、highestUnlockedLevelと呼ばれる型プロパティに保管されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This variable has an initial value of nil, by virtue of being optional:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルであるおかげで、この変数はnilの初期値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This variable is initialized with a value of 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この変数は、値0で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This version is adapted to use a Dice instance for its dice-rolls; to adopt the DiceGame protocol; and to notify a DiceGameDelegate about its progress:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この版は改変され、それにより、それのさいころ振りにDiceインスタンスを使用します；DiceGameプロトコルを採用します；そして、その進歩についてDiceGameDelegateに通知します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This version of Residence also provides a method called printNumberOfRooms, which simply prints the number of rooms in the residence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Residenceのこの版もprintNumberOfRoomsと呼ばれるメソッドを提供します、それは、単にその住居の部屋数を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This version of the Shape class is missing something important: an initializer to set up the class when an instance is created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Shapeクラスのこの版は、重要なあるもの：インスタンスが作られるときにクラスを設定準備するイニシャライザ（初期化子）、が欠けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This version of the game is wrapped up as a class called SnakesAndLadders, which adopts the DiceGame protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲームのこの改作は、SnakesAndLaddersと呼ばれるクラスで包まれます、それは、DiceGameプロトコルを採用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This version of the game uses a while loop and a switch statement to implement the game’s logic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲームのこの改変板は、このゲームの論理を実装するためにwhileループとswitch文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This version of the mutating moveBy(x:y:) method creates a brand new structure whose x and y values are set to the target location.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変のmoveBy(x:y:)メソッドのこの改作は、xとyの値が目標場所に設定される、あるまっさらな構造体を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This would not be the case if you had written the initializer as part of the value type’s original implementation, as described in Initializer Delegation for Value Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型のためのイニシャライザ委任で記述されるように、あなたがイニシャライザをその値型の最初の実装の一部として書いたならば、それはこの場合にはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those two values are compared, and the result of that comparison determines the overall result of the tuple comparison.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのような２つの値が比較されます、するとその比較の結果がタプル比較の結果全体を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throw Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>throw文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throwing Functions and Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローを行う関数とメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throwing an error lets you indicate that something unexpected happened and the normal flow of execution can’t continue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーのスローがあなたに示すのは、何か予期せぬことが起こった、そして通常の実行の流れは続けることができないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throwing and rethrowing functions are described in Throwing Functions and Methods and Rethrowing Functions and Methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローおよび再スロー関数は、スロー関数とメソッドと再スロー関数とメソッドにおいて記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throwing and rethrowing functions can transfer program control to an appropriate catch block, even when they are nonreturning.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローおよび再スロー関数は、制御を適切なcatchプロックに移すことができます、それらが非復帰である場合でさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throwing initializers can propagate errors in the same way as throwing functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローするイニシャライザは、スローする関数と同じ方法でエラーを伝達できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throwing, catching, and propagating errors is covered in greater detail in Error Handling.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーのスロー、キャッチ、そして伝達は、詳細にエラー処理において扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To access an index farther away from the given index, you can use the index(_:offsetBy:) method instead of calling one of these methods multiple times.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>与えられたインデックスからもっと遠く離れたインデックスにアクセスするには、あなたはこれらのメソッドのうちの１つを複数回呼び出すことの代わりにindex(_:offsetBy:)メソッドを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To accomplish this, Swift enables you to define nested types, whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを達成するために、スウィフトはあなたに入れ子にされた型を定義するのを可能にします、それによってあなたは、補助の列挙、クラス、そして構造体をそれらが支援をする型の定義の範囲内で入れ子にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To accomplish this, you define one input parameter—a String value called person—and a return type of String, which will contain a greeting for that person:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを達成するために、あなたは１つの入力パラメータ ― personと呼ばれるString値 ― そしてその人のための挨拶を含むことになる、Stringの戻り型を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To achieve these aims, you can mark a loop statement or conditional statement with a statement label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの狙いを達成するために、あなたはループ文または条件文に文ラベルで印をつけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To achieve this, an extra rule is used when signed integers are shifted to the right: When you shift signed integers to the right, apply the same rules as for unsigned integers, but fill any empty bits on the left with the sign bit, rather than with a zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを達成するために、符号つき整数が右へシフトされるとき、特別な規則が使われます：あなたが符号つき整数を右にシフトする時は、符号なし整数と同じ規則を適用してください、しかし、その左のあらゆる空のビットを、ゼロではなく符号ビットで満たしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To achieve this, the Container protocol declares an associated type called ItemType, written as associatedtype ItemType.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを達成するために、ContainerプロトコルはItemTypeと呼ばれる関連型を宣言します、それはassociatedtype ItemTypeのように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To achieve this, the array’s size, and an initial cell value of 0.0, are passed to an array initializer that creates and initializes a new array of the correct size.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを達成するために、この配列の大きさ、そして0.0の初期セル値は、正しいサイズの新しい配列をつくって初期化する配列イニシャライザに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To assist with these assertions, Matrix includes a convenience method called indexIsValid(row:column:), which checks whether the requested row and column are inside the bounds of the matrix:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの表明を手伝うために、MatrixはindexIsValid(row:column:)と呼ばれるある便利なメソッドを含みます、それは要請されたrowとcolumnが行列の境界の内側にあるかどうか確認します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To calculate 9 % 4, you first work out how many 4s will fit inside 9:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>9 % 4を計算するために、あなたは最初にどれくらい多くの4が9の中に収まるかを考え出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To check the values of enumeration cases, use a switch statement, as shown in Matching Enumeration Values with a Switch Statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節の値を調べるために、スイッチ文で列挙値を照合するで示されるように、switch文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To check whether a set contains a particular item, use the contains(_:) method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある集合が特定の項目を含むかどうか調べるために、contains(_:)メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To check whether a string has a particular string prefix or suffix, call the string’s hasPrefix(_:) and hasSuffix(_:) methods, both of which take a single argument of type String and return a Boolean value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある文字列が特定の文字列接頭辞または接尾辞を持つかどうか調べるために、文字列のhasPrefix(_:)とhasSuffix(_:)メソッドを呼んでください、それらの両方ともただ一つのString型の引数をとって、ブールの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To compare tuples with seven or more elements, you must implement the comparison operators yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>７つまたはそれより多い要素のタプルを比較するには、あなたは比較演算子をあなた自身で実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To convert one specific number type to another, you initialize a new number of the desired type with the existing value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つの特定の数の型を他のものに変換するために、あなたは望む型の新しい数を既存の値で初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To cope with initialization conditions that can fail, define one or more failable initializers as part of a class, structure, or enumeration definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗の可能性がある初期化状況にうまく対処するために、一つ以上の失敗可能なイニシャライザをクラス、構造体、または列挙定義の一部として定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To cope with this requirement, you declare the capitalCity property of Country as an implicitly unwrapped optional property, indicated by the exclamation mark at the end of its type annotation (City!).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この必要条件に対処するために、あなたはCountryのcapitalCityプロパティを、暗黙的にアンラップされるオプショナルのプロパティとして、その型注釈の終わりに感嘆符で示して宣言します（City!）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To cope with this scenario, the code checks that square is less than the board array’s count property before adding the value stored in board[square] onto the current square value to move the player up or down any ladders or snakes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この事態に対処するために、コードは、squareがboard配列のcountプロパティより少ないことの確認を、はしごや蛇があればプレーヤーを上か下に動かすためにboard[square]に格納される値を現在のsquareの値に加える前に、行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To cope with this, the example above uses optional binding to check whether the optional Movie actually contains a value (that is, to find out whether the downcast succeeded.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これに対処するために、上の例は、オプショナル束縛を使って、オプショナルのMovieが実際に値を含むかどうか調べます（すなわち、ダウンキャストが成功したかどうか探り出します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create a property called items, which is initialized with an empty array of values of type Element</seg>
      </tuv>
      <tuv lang="JA">
        <seg>itemsと呼ばれるプロパティをつくる所で、それは、型Elementの値が入る空の配列で初期化されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create an empty String value as the starting point for building a longer string, either assign an empty string literal to a variable, or initialize a new String instance with initializer syntax:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より長い文字列をつくるための出発点として空のString値を作成するために、変数に空のリテラル文字列を代入するか、イニシャライザ構文で新しいStringインスタンスを初期化してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create an empty array or dictionary, use the initializer syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の配列または辞書を作成するために、初期化構文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a class or static method requirement in a protocol declaration, mark the method declaration with the static declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスまたは静的メソッド要件をあるプロトコル宣言において宣言するために、そのメソッド宣言をstatic宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a constant type property, mark the declaration with the static declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数型プロパティを宣言するために、宣言にstatic宣言修飾子で印をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a failable initializer that produces an implicitly unwrapped optional instance, append an exclamation mark instead (init!).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナルインスタンスを生成する失敗できるイニシャライザを宣言するために、代わりに感嘆符を加えてください（init!）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a failable initializer that produces an optional instance, append a question mark to the init keyword in the initializer declaration (init?).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルインスタンスを生成する失敗できるイニシャライザを宣言するために、イニシャライザ宣言において疑問符をinitキーワードに加えてください（init?）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a type variable property, mark the declaration with the static declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型変数プロパティを宣言するために、宣言にstatic宣言修飾子で印をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare convenience initializers for a class, mark the initializer declaration with the convenience declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスの便宜イニシャライザを宣言するために、そのイニシャライザ宣言をconvenience宣言修飾子を使って印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To define these requirements, the Container protocol needs a way to refer to the type of the elements that a container will hold, without knowing what that type is for a specific container.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの要件を定義するために、Containerプロトコルは、あるコンテナが保持することになる要素の型を参照する方法を必要とします、その型がどんなコンテナのためのものか知ることなしにです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To determine the answer for a % b, the % operator calculates the following equation and returns remainder as its output:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>a % bに対する答えを決定するために、%演算子は以下の等式を計算します、そしてその出力として余りを返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To discover the specific type of a constant or variable that is known only to be of type Any or AnyObject, you can use an is or as pattern in a switch statement’s cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型AnyまたはAnyObjectのものであることだけが知られている定数や変数の具体的な型を見つけるために、あなたはisまたはasパターンをswitch文のケース節の中で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To distinguish between methods or initializers whose names differ only by the names of their arguments, include the argument names in parentheses, with each argument name followed by a colon (:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前がそれらの引数の名前でだけ異なるものであるメソッド間またはイニシャライザ間で識別を行うために、丸括弧の中に引数名を、各引数名にコロン（:）を続けることで含めて下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To distinguish between overloaded methods, use a type annotation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバーロードされたメソッド間で識別を行うには、型注釈を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do that, you need to create an instance of the structure or class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それをするために、あなたは構造体またはクラスのインスタンスをつくる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do this, it needs to access each item as a true Movie or Song, and not just as a MediaItem.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これをするために、それは、ただMediaItemとしてではなく、本当のMovieまたはSongとして各項目にアクセスする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do this, you make parts of your code conditional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これをするために、あなたは、あなたのコードの一部を条件つきにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To enable indirection for a particular enumeration case, mark it with the indirect declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある特定の列挙ケース節に対して間接参照を可能にするには、それをindirect宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To enable indirection for all the cases of an enumeration, mark the entire enumeration with the indirect modifier—this is convenient when the enumeration contains many cases that would each need to be marked with the indirect modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある列挙の中のすべてのケース節に対して間接参照を可能にするには、その列挙全体をindirect修飾子で印してください—これはその列挙がそのそれぞれがindirect修飾子で印される必要がある多くのケース節を含んでいる時に適します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To enable this, Swift provides two identity operators:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを可能にするために、スウィフトは２つの同一性演算子を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ensure that an error is handled, use a catch clause with a pattern that matches all errors, such as a wildcard pattern (_).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーが処理されることが保証されるように、あるひとつのcatch節をどんなエラーにもマッチするパターンとともに使ってください、例えばワイルドカードパターン（_）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To evaluate the value of a subscript expression, the subscript getter for the expression’s type is called with the index expressions passed as the subscript parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字式の値を評価するために、この式のもつ型のための添え字ゲッターが、添え字パラメータとして渡されるインデックス式を使って呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To explicitly fall through at the end of a particular switch case, use the fallthrough keyword, as described in Fallthrough.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある特定のswitchケース節の終わりで明示的に抜け落ちるには、フォールスルーで記述されるように、fallthroughキーワードを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To express this fact, you write a type constraint of Equatable as part of the type parameter’s definition when you define the function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この事実を表すために、あなたはEquatableの型制約を型パラメータの定義の一部として、あなたが関数を定義する時に書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To find out the number of items in a set, check its read-only count property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合の中の項目数を知るために、それの読み出し専用のcountプロパティを調べてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To find out the number of items in an array, check its read-only count property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある配列の中の項目の数を知るために、その読み出し専用のcountプロパティを調べてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To handle an empty array safely, write the minMax(array:) function with an optional tuple return type and return a value of nil when the array is empty:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の配列を安全に取り扱うために、minMax(array:)関数をオプショナルタプルの戻り型を使って書いて、配列が空の時にnilの値を返してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To help manage the currentLevel property, LevelTracker defines an instance method called advance(to:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>currentLevelプロパティを管理するのを手伝うために、LevelTrackerはadvance(to:)と呼ばれるインスタンスメソッドを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To identify these places in your code, write the try keyword—or the try? or try! variation—before a piece of code that calls a function, method, or initializer that can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの場所をあなたのコードの中で識別するには、tryキーワードを ― またはその変種try?またはtry!を ― エラーをスローできる関数、メソッド、またはイニシャライザを呼び出すコードの前の場所に書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To implement the +++ operator, you add a type method called +++ to Vector2D as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>+++演算子を実装するには、あなたは+++と呼ばれる型メソッドを次のようにVector2Dに加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To indicate that a function, method, or initializer can throw an error, you write the throws keyword in the function’s declaration after its parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーをスローすることのできる関数、メソッド、またはイニシャライザを指し示すために、あなたはthrowsキーワードを関数の定義においてそれのパラメータの後に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To indicate that a subclass has a superclass, write the subclass name before the superclass name, separated by a colon:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるサブクラスがあるスーパークラスを持つことを表わすには、サブクラスの名前をスーパークラスの名前の前に、コロンで区切って書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To insert a single character into a string at a specified index, use the insert(_:at:) method, and to insert the contents of another string at a specified index, use the insert(contentsOf:at:) method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある単一の文字をある文字列中へ特定のインデックスで差し込むには、insert(_:at:)メソッドを使ってください、そして別の文字列の内容を特定のインデックスで差し込むには、insert(contentsOf:at:)メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To insert an item into the array at a specified index, call the array’s insert(_:at:) method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある項目を配列の中へ指定されたインデックスで差し入れるために、配列のinsert(_:at:)メソッドを呼んでください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To iterate over the keys or values of a dictionary in a specific order, use the sorted() method on its keys or values property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書のキーまたは値に特定の順序で繰り返していくために、sorted()メソッドをkeysまたはvaluesプロパティ上で使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To iterate over the values of a set in a specific order, use the sorted() method, which returns the set’s elements as an array sorted using the &lt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合の中の値に特定の順番で繰り返すには、sorted()メソッドを使ってください、それは集合の要素を&lt;演算子を使って格納される配列として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To learn how functions can return other functions, see Function Types as Return Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数が他の関数を返すことができる方法を学ぶために、戻り型としての関数型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To learn how to define new, custom operators, see Custom Operators and Operator Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい、あつらえの演算子を定義する方法を学ぶために、あつらえの演算子と演算子宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To learn how to overload existing operators, see Operator Methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存の演算子にオーバーロードする方法を学ぶために、演算子メソッドを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make a switch with a single case that matches both "a" and "A", combine the two values into a compound case, separating the values with commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ただ１つだけのケース節を持つあるswitchが"a"と"A"の両方にマッチするようにするには、２つの値をひとつの複合ケース節へと、コンマで値を隔てて結合してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make it more useful, you need to refine it to describe more specific kinds of vehicles.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それをより役に立つようにするために、あなたはそれを改良してより具体的な乗物の種類を記述する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make sure that instances don’t disappear while they are still needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがまだ必要な間にインスタンスが消えないことを確実にするために、ARCは、どれくらいのプロパティ、定数、および変数が目下のところ各クラスインスタンスに言及しているかを追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make the body of this function shorter, you can combine the message creation and the return statement into one line:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数の本文をより短くするために、あなたはメッセージ作成と返しの文を１行に結合することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make this possible, whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a strong reference to the instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを可能にするために、あなたがクラスインスタンスをプロパティ、定数、または変数に代入するときはいつでも、そのプロパティ、定数、または変数はそのインスタンスへの強い参照を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To model this restriction, the failable initializer triggers an initialization failure if an empty string is found.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この制約条件をモデル化するために、失敗できるイニシャライザは空の文字列が見つけられるならば初期化失敗を引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To nest a type within another type, write its definition within the outer braces of the type it supports.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型を別の型の内部で入れ子にするために、その定義をそれが支援する型の外側の波括弧の範囲内で書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To opt in to overflow behavior, use Swift’s second set of arithmetic operators that overflow by default, such as the overflow addition operator (&amp;+).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー挙動を選ぶために、初期状態でオーバフローするスウィフトの算術演算子の第二集合を使ってください、例えばオーバフロー加算演算子（&amp;+）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To override a characteristic that would otherwise be inherited, you prefix your overriding definition with the override keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうしなければ継承される特徴をオーバーライドするために、あなたは、あなたのオーバーライド定義の前にoverrideキーワードを置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To print a value without a line break after it, pass an empty string as the terminator—for example, print(someValue, terminator: "").</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある値をそれの後に改行なしで出力するには、空の文字列を終端子（ターミネータ）として渡してください ― 例えば、print(someValue, terminator:"")。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To put it another way:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言い換えれば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To reference the case of an enumeration type, use dot (.) syntax, as in EnumerationType.enumerationCase.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙型のケース節に言及するために、EnumerationType.enumerationCaseのように、ドット（.）構文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To reflect the fact that optional chaining can be called on a nil value, the result of an optional chaining call is always an optional value, even if the property, method, or subscript you are querying returns a nonoptional value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖はnil値上で呼ばれることができるという事実を反映するために、オプショナル連鎖呼び出しの結果は、たとえあなたが問い合わせているプロパティ、メソッド、または添え字が非オプショナルの値を返すとしても、常にオプショナルの値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To remove a single character from a string at a specified index, use the remove(at:) method, and to remove a substring at a specified range, use the removeSubrange(_:) method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある単一の文字をある文字列から特定のインデックスで削除するには、remove(at:)メソッドを使ってください、そして部分文字列を特定の範囲で削除するには、removeSubrange(_:)メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To represent this fact, ShoppingListItem introduces a Boolean property called purchased, with a default value of false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この事実を表すために、ShoppingListItemは、falseの省略時の値で、purchasedと呼ばれるブールのプロパティを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To represent this game board, the Chessboard structure has a single property called boardColors, which is an array of 64 Bool values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このゲーム板を表すために、Chessboard構造体はboardColorsと呼ばれる１つのプロパティだけを持ちます、それは64個のBool値の配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To represent this, board[03] is equal to +08, which is equivalent to an integer value of 8 (the difference between 3 and 11).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを表すために、board[03]は+08と等しいです、そしてそれは、整数値の８（3と11の差）に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To represent this, the Country class has a capitalCity property, and the City class has a country property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを表すために、CountryクラスはcapitalCityプロパティを持ちます、そして、Cityクラスはcountryプロパティを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To represent this, the Customer class has an optional card property, but the CreditCard class has an unowned (and nonoptional) customer property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを表すために、Customerクラスはオプショナルのカードプロパティを持ちます、しかし、CreditCardクラスは非オプショナルのcustomerプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To require that subclasses implement a superclass’s initializer, mark the superclass’s initializer with the required declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるスーパークラスの持つイニシャライザをそのサブクラスたちが実装することを要求するために、そのスーパークラスのイニシャライザをrequired宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To restrict the adoption of a protocol to class types only, mark the protocol with the class requirement by writing the class keyword as the first item in the inherited protocols list after the colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルの採用をクラス型のみに制限するために、classキーワードを継承されるプロトコルのリストの最初の項目としてコロンの後に書くことによって、class要件を持つそのプロトコルを印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To retrieve a count of the Character values in a string, use the count property of the string’s characters property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある文字列の中のCharacter値の総数を取り出すために、その文字列のcharactersプロパティのcountプロパティを使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To see an example of how to create and implement a new operator, see Custom Operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい演算子の作成と実装の方法の例を見るには、あつらえの演算子を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To see an example of how to use a do statement with several catch clauses, see Handling Errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>do文を複数のcatch節とともに使う方法の例を見るために、エラーを処理するを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To see examples of initializers in various type declarations, see Initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いろいろな型宣言におけるイニシャライザの例を見るために、初期化を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To set its value, the subscript setter is called in the same way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その値を設定するために、添え字セッターが同様に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To set up the interdependency between the two classes, the initializer for City takes a Country instance, and stores this instance in its country property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つのクラスの間で相互依存を設定するために、Cityのためのイニシャライザは、Countryインスタンスをとって、このインスタンスをそれのcountryプロパティに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To simplify the relationships between designated and convenience initializers, Swift applies the following three rules for delegation calls between initializers:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定と便宜イニシャライザの間の関係を単純化するために、スウィフトは以下の３つの規則をイニシャライザ間の委任呼び出しに対して適用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To specify an in-out parameter, prefix the parameter type with the inout keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータを指定するために、inoutキーワードをそのパラメータ型の前に置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To specify that the push(_:) method has a single parameter called item, which must be of type Element</seg>
      </tuv>
      <tuv lang="JA">
        <seg>push(_:)メソッドが一つのパラメータ、itemと呼ばれるものを持つことを指定する所で、それは、型Elementでなければなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To specify that the value returned by the pop() method will be a value of type Element</seg>
      </tuv>
      <tuv lang="JA">
        <seg>pop()メソッドによって返される値が型Elementの値であることを示す所で</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To support recursion, the compiler must insert a layer of indirection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再帰をサポートするために、コンパイラは間接参照の階層を差し入れる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use a function, you “call” that function with its name and pass it input values (known as arguments) that match the types of the function’s parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数を使うためには、あなたはその関数をそれの名前を使って「呼び出し」、それにその関数のパラメータの型に適合する入力値（引数として知られます）を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use a nested type outside of its definition context, prefix its name with the name of the type it is nested within:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた型をその定義の文脈外で使うために、その名前にそれが入れ子にされている型の名前で接頭辞を付けてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use a reserved word as an identifier, put a backtick (`) before and after it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子として予約語を使用するために、それの前後にバッククォート（`）を置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use it in the ternary conditional (? :) operator, it must have whitespace around both sides.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それを三項条件（? :）において使うためには、それは両側に空白を持ってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use optional chaining, use a question mark in place of the exclamation mark:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を使用するために、感嘆符の代わりに疑問符を使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use the ? as the optional-chaining operator, it must not have whitespace on the left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>?をオプショナル連鎖演算子として使うには、それは左側に空白を持ってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use the equivalence operators to check for equivalence of your own custom type, provide an implementation of the operators in the same way as for other infix operators:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなた独自のあつらえの型の同等について調べるために同等演算子を使用するには、他の接中辞演算子と同じやり方でこれらの演算子の実装を提供してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To win, you must land exactly on square 25.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>勝つために、あなたはぴったり正方形25に到着しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To work out the exact evaluation order to use, you also need to consider their associativity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>使用する的確な評価順序を解き明かすには、あなたはまたそれらの結合性を考慮する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Top-Level Code</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トップレベル・コード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tradition suggests that the first program in a new language should print the words “Hello, world!” on the screen.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>伝統は、新しい言語において最初のプログラムが画面上に語句「Hello, world!」を出力しなければならないことを示唆します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trailing Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後付クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trailing closure syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後付クロージャ構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trailing closures are most useful when the closure is sufficiently long that it is not possible to write it inline on a single line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャがそれをただ一つの行の行内に書くことが可能でないほど長いとき、後付クロージャは最も役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Try Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>try演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Try removing the conversion to String from the last line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後の行からStringへの転換を取り除いてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Try removing the default case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何れにも当てはまらない場合の部分（default: の部分）を取り除いてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trying to change the value of a function parameter from within the body of that function results in a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関数の本文内部から関数パラメータの値を変えようとすることは、コンパイル時エラーに終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trying to set an Int16 constant or variable to a number outside of this range causes an error:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Int16定数または変数をこの範囲の外側の数に設定する試みは、エラーを引き起こします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trying to use ! to access a nonexistent optional value triggers a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>存在しないオプショナルの値にアクセスするために!を使うことを試みることは、実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple Pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルパターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple patterns match values of corresponding tuple types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルパターンは、対応するタプル型の値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple types do not have a standalone definition in the way that classes, structures, enumerations, and functions do.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル型には、クラス、構造体、列挙、そして関数が行う方法での、独立した定義がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples are compared from left to right, one value at a time, until the comparison finds two values that aren’t equal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルは、左から右へと、一度に１つの値を、比較が等しくない２つの値を見つけるまで、比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples are particularly useful as the return values of functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルは、特に関数の戻り値として便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples are useful for temporary groups of related values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルは、関連した値の一時的なグループに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples can also be used as parameter types and return types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルもまた、パラメータ型および戻り型として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples enable you to create and pass around groupings of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルは、あなたに値のグループをつくってあちこち渡すことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two String values (or two Character values) are considered equal if their extended grapheme clusters are canonically equivalent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つのString値（または２つのCharacter）は、それらの拡張書記素クラスタたちが正準等価ならば、等しいとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two-Phase Initialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２段階初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two-phase initialization prevents property values from being accessed before they are initialized, and prevents property values from being set to a different value by another initializer unexpectedly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２段階初期化は、プロパティ値が初期化される前にアクセスされるのを妨げます、それによってプロパティ値が思いもよらず別のイニシャライザによって異なる値に設定されるのを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Alias Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアス宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Aliases</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Annotation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型注釈</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Annotations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さまざまな型注釈</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Attributes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Casting</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Casting for Any and AnyObject</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AnyおよびAnyObjectに対する型キャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Constraint Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型制約構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Constraints</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型制約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Constraints in Action</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型制約の動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Identifier</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型識別子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Inference</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型推論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Inheritance Clause</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型継承節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Property Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティ構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Safety and Type Inference</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型安全と型推論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Variable Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型変数プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type alias declarations are declared using the typealias keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアス宣言は、キーワードtypealiasを使って宣言されます、そして以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type aliases are useful when you want to refer to an existing type by a name that is contextually more appropriate, such as when working with data of a specific size from an external source:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアスは、あなたがより文脈上適切な名前で既存の型に言及したいとき役に立ちます、たとえば外部ソースからの特定の大きさのデータを扱う時など：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type aliases do not create new types; they simply allow a name to refer to an existing type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアスは、新しい型を作成しません；それらは、単にある名前が既存の型に言及できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type annotations begin with a colon (:) and end with a type, as the following examples show:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型注釈は、以下の例が示すように、コロン（:）で始まりひとつの型で終わります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type annotations can contain an optional list of type attributes before the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型注釈は、型の前に任意の型属性のリストを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type casting enables you to check and interpret the type of a class instance at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャストは、あなたにクラスインスタンスの型を実行時に調べて解釈することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type casting in Swift is implemented with the is and as operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでの型キャストは、isとas演算子を使って実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type casts that can fail at runtime now use the as? or as! operator, and type casts that are guaranteed not to fail use the as operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行時に失敗できる型キャストは、今ではas?またはas!演算子を使います、そして失敗しないことを保証される型キャストはas演算子を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type constraints specify that a type parameter must inherit from a specific class, or conform to a particular protocol or protocol composition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型制約は、型パラメータが特定のクラスから継承しなければならない、もしくはある特定のプロトコルまたはプロトコル合成に準拠しなければならないことを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type constraints, as described in Type Constraints, enable you to define requirements on the type parameters associated with a generic function or type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型制約で記述されるように、型制約によって、あなたは総称体関数または総称体型と結び付けられた型パラメータ上で要件を定義することが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type inference enables a compiler to deduce the type of a particular expression automatically when it compiles your code, simply by examining the values you provide.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型推論は、コンパイラに自動的に特定の式の型を演繹することを、それがあなたのコードをコンパイルする時に、単純にあなたが提供する値を調べることによって、可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type inference helps make Swift code more concise and readable when it initializes constants or variables with other values whose type is already known.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型推論は、スウィフトのコードを、それが定数または変数を型がすでに知られている他の値で初期化するとき、より簡潔で読みやすくするのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type inference in Swift operates at the level of a single expression or statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの型推論は、単一の式や文の水準で働きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type inference is particularly useful when you declare a constant or variable with an initial value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが最初の値で定数または変数を宣言するとき、型推論は特に役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type methods and properties now use the static keyword as a declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドとプロパティは今ではstaticキーワードを宣言修飾子として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type methods are called with dot syntax, like instance methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型メソッドは、インスタンスメソッドの様に、ドット構文で呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type methods are similar to class methods in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型メソッドは、Objective-Cにおけるクラスメソッドに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type parameters specify and name a placeholder type, and are written immediately after the function’s name, between a pair of matching angle brackets (such as &lt;T&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型パラメータは、プレースホルダ型を指定して命名します、そして関数の名前の直後に一対の山形括弧の間で書かれます（例えば&lt;T&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type properties are discussed in Type Properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティは、型プロパティで議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type properties are discussed in Type Properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティは、型プロパティで議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type properties are queried and set with dot syntax, just like instance properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティは、インスタンスプロパティのように、ドット構文で問い合わせられ設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type properties are useful for defining values that are universal to all instances of a particular type, such as a constant property that all instances can use (like a static constant in C), or a variable property that stores a value that is global to all instances of that type (like a static variable in C).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティは、特定の型の全てのインスタンスに共通なさまざまな値を定義することに役立ちます、例えば、全てのインスタンスが使うことができる定数プロパティ（Cでの静的定数のように）、またはその型の全てのインスタンスにグローバルである値を保存する変数プロパティ（Cでの静的変数のように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type safety helps you catch and fix errors as early as possible in the development process.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型安全は、あなたが開発プロセスにおいて可能な限り早期にエラーを捕まえて修復するのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type-Casting Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャスト演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type-Casting Patterns</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャスト・パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type-checking helps you avoid errors when you’re working with different types of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型をチェックすることは、あなたが異なる種類の値を扱っているとき、あなたがエラーを避ける手助けをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types can be nested to as many levels as are required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型は、必要とされるだけ多くの階層に入れ子にされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types do not automatically adopt a protocol just by satisfying its requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型は、単にその要件を満たすことだけによっては自動的にあるプロトコルを採用しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types that conform to the Hashable protocol must provide a gettable Int property called hashValue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Hashableプロトコルに適合する型は、取得可能なIntプロパティ、hashValueと呼ばれるものを提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically you don’t need to perform manual cleanup when your instances are deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>概して、あなたのインスタンスが割り当て解除されるとき、あなたが手動で掃除をする必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, you use the if statement to evaluate simple conditions with only a few possible outcomes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般的に、あなたはif文をほんの２、３の起こりうる結果だけを持つ単純な状況を評価するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UInt</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号なし整数（Unsigned Integer）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UTF-16 Representation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>UTF-16表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UTF-8 Representation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>UTF-8表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary prefix operators appear immediately before their target (such as !b), and unary postfix operators appear immediately after their target (such as c!).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項接頭辞演算子はそれらの目標の直前に現れます（例えば!bのように）、そして単項接尾辞演算子はそれらの目標の直後に現れます（例えばc!のように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary Minus Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項マイナス演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary Plus Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項プラス演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary operators operate on a single target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項演算子は、一つの目標に作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Underscores (_) are allowed between digits for readability, but are ignored and therefore don’t affect the value of the literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アンダースコア（_）は、可読性のために桁の間で認められます、しかし無視されることから、リテラルの値に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Underscores (_) are allowed between digits for readability, but they are ignored and therefore don’t affect the value of the literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アンダースコア（_）は、可読性のために桁の間で認められます、しかしそれらは無視されるのでリテラルの値に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, linking these two instances creates a strong reference cycle between them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>残念なことに、これらの２つのインスタンスを結ぶことは、それらの間で強い参照循環をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, the HTMLElement class, as written above, creates a strong reference cycle between an HTMLElement instance and the closure used for its default asHTML value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>残念なことに、このHTMLElementクラスは、上で書かれるように、HTMLElementインスタンスとその省略時のasHTML値のために使われるクロージャとの間に強い参照循環をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode Representations of Strings</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列のユニコード表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode Scalar Representation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニコード・スカラー表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode Scalars</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニコード・スカラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode scalar (\u{n}), where n is between one and eight hexadecimal digits</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニコード・スカラー（\u{n}）、ここでnは１から８桁の16進数です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode scalars do not include the Unicode surrogate pair code points, which are the code points in the range U+D800 to U+DFFF inclusive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニコード・スカラーは、ユニコードのサロゲート・ペアのコードポイントを含みません、それは、範囲U+D800からU+DFFFを含めてまでのコードポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode scalars for regional indicator symbols can be combined in pairs to make a single Character value, such as this combination of REGIONAL INDICATOR SYMBOL LETTER U (U+1F1FA) and REGIONAL INDICATOR SYMBOL LETTER S (U+1F1F8):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>地域標識記号のためのユニコード・スカラーは、単一のCharacter値を作るために２つ一組で組み合わされることが出来ます、例えばREGIONAL INDICATOR SYMBOL LETTER U（U+1F1FA）とREGIONAL INDICATOR SYMBOL LETTER S（U+1F1F8）の組み合わせのように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless otherwise specified, the default access level is internal, as described in Default Access Levels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に明記しない限り、省略時のアクセス水準で記述されるように、省略時のアクセス水準は内部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless otherwise specified, the default inferred type of a floating-point literal is the Swift standard library type Double, which represents a 64-bit floating-point number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に明記しない限り、初期状態で推論されるリテラル浮動小数点の型は、スウィフト標準ライブラリ型Doubleです、それは、64ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless otherwise specified, the default inferred type of an integer literal is the Swift standard library type Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に明記しない限り、初期状態で推論されるリテラル整数の型は、スウィフト標準ライブラリ型Intです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless the value of integerToDescribe is in the list of known prime numbers, it is not matched by the first switch case at all.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>integerToDescribeの値が知っている素数のリストの中にある場合を除いて、それは最初のswitchケース節に適合することはまったくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless you need to work with a specific size of integer, always use Int for integer values in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが整数の特定のサイズを扱う必要がない限り、常に、あなたのコードの整数値のためにIntを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike Boolean conditions, you can’t combine availability conditions using logical operators such as &amp;&amp; and ||.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブール条件と違って、あなたは論理演算子例えば&amp;&amp;や||などを使って有効性条件を連結することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike C and Objective-C, Swift enumeration cases are not assigned a default integer value when they are created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CおよびObjective-Cとは異なり、スウィフト列挙ケース節は、それらがつくられるとき省略時の整数値を代入されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike C, Swift allows multiple switch cases to consider the same value or values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cと違って、スウィフトは複数のswitchケース節に、同じ値または複数の値について考慮させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike Objective-C initializers, Swift initializers do not return a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cのイニシャライザと違って、スウィフトのイニシャライザは値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike Objective-C, Swift enables you to set sub-properties of a structure property directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cと違って、スウィフトはあなたに直接ある構造体プロパティの下位プロパティを設定するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike a switch statement in C, this switch statement does not match both "a" and "A".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cでのswitch文と違って、このswitch文は"a"と"A"の両方に合うものを見つけるわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike a default initializer, the structure receives a memberwise initializer even if it has stored properties that do not have default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のイニシャライザと違って、構造体はメンバー関連イニシャライザを、たとえその構造体が省略時の値を持たない保存プロパティを持つとしても、受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike a subscript, however, the updateValue(_:forKey:) method returns the old value after performing an update.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、添え字とは違い、updateValue(_:forKey:)メソッドは更新を実行した後に古い値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike a variable, the value of a constant cannot be changed once it is set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数とは異なり、一旦それが設定されるならば、定数の値は変わることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、弱い参照とは違い、非所有参照は他のインスタンスが同じ生涯またはより長い生涯を持つ場合に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike an if statement, a guard statement always has an else clause—the code inside the else clause is executed if the condition is not true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文と違って、guard文は常にelse節を持ちます—else節の内部のコードはその条件が真でないならば実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike arithmetic operators in C, arithmetic operators in Swift do not overflow by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cでの算術演算子と違って、スウィフトの算術演算子は、初期状態ではオーバフローしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike arrays, sets do not have an equivalent shorthand form.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列とは違い、集合は相当する短縮形を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike classes and structures, enumeration types do not have an implicitly provided default initializer; all initializers must be declared explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスや構造体と違って、列挙型には、暗黙のうちに提供される省略時のイニシャライザがありません；全てのイニシャライザは、明確に宣言されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike exception handling in many languages—including Objective-C—error handling in Swift does not involve unwinding the call stack, a process that can be computationally expensive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多くの言語 ― Objective-Cを含めて ― での例外処理と違い、スウィフトにおけるエラー処理はコールスタック、計算的に高くつく可能性がある処理、の巻き戻し（アンワインド）を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike instance methods, subscripts can be read-write or read-only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスメソッドと違って、添え字は読み書き用であるか読み出し専用であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike items in an array, items in a dictionary do not have a specified order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の中の項目と違って、辞書の中の項目には、指定された順番がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike lazy stored properties, global constants and variables do not need to be marked with the lazy modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延保存プロパティと違って、グローバルな定数と変数はlazy修飾子で印付けされる必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike many other languages, Swift does not require you to write a semicolon (;) after each statement in your code, although you can do so if you wish.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多くの他の言語とは異なり、スウィフトはあなたにあなたのコードにおいて各文の後にセミコロン（;）を書くことを要求しません、けれどもあなたが望むならば、あなたはそうすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike multiline comments in C, multiline comments in Swift can be nested inside other multiline comments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cでの複数行コメントと違って、スウィフトの複数行コメントは他の複数行コメント内部に入れ子にされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike other programming languages, Swift does not require you to create separate interface and implementation files for custom classes and structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のプログラミング言語と違って、スウィフトはあなたにカスタム・クラスおよび構造体のために別々のインタフェースおよび実装ファイルを作成することを要求しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike stored instance properties, you must always give stored type properties a default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存インスタンスプロパティと違って、あなたは保存型プロパティに省略時の値を常に与えなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike stored named values and stored variable properties, the value of a computed named value or a computed property is not stored in memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>保存される名前を付けられた値および保存変数プロパティと違って、計算される名前を付けられた値または計算プロパティの値は、メモリに保存されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike structures and enumerations, classes have two kinds of initializers: designated initializers and convenience initializers, as described in Initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体や列挙と違って、クラスは２種類のイニシャライザを持ちます：指定イニシャライザと便宜イニシャライザ、初期化で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike structures, class instances do not receive a default memberwise initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体と違って、クラスインスタンスは、自動生成のメンバー関連イニシャライザを授けられません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike subclasses in Objective-C, Swift subclasses do not inherit their superclass initializers by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでのサブクラスとは異なり、スウィフトのサブクラスは、特に何もしなくてもそれらのスーパークラスのイニシャライザを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike the arithmetic operators in C and Objective-C, the Swift arithmetic operators do not allow values to overflow by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CとObjective-Cの算術演算子と違って、スウィフトの算術演算子は、初期状態では値がオーバフローするのを許しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike the assignment operator in C and Objective-C, the assignment operator in Swift does not itself return a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CとObjective-Cの代入演算子と違って、スウィフトの代入演算子は、それ自身で値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike the cases in the first form, each case has an underlying value, called a raw value, of the same basic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の形式でのケース節と違って、それぞれのケース節は、同じ基本の型の、もととなる値、生の値と呼ばれるものを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike the condition of an if statement, the compilation condition is evaluated at compile time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文の条件とは違い、compilation condition（コンパイル条件）はコンパイル時に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike value types, reference types are not copied when they are assigned to a variable or constant, or when they are passed to a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型とは異なり、参照型は、それが変数や定数に代入される時に、あるいはそれが関数に渡される時に、コピーされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unowned References</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非所有者参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unowned References and Implicitly Unwrapped Optional Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非所有者参照と暗黙的にアンラップされるオプショナルのプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upcasting lets you use an expression as an instance of its type’s supertype, without using an intermediate variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アップキャストは、あなたにある式をそれのスーパータイプのインスタンスとして使用させます、中間生成物の変数の使用なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated Closures Are Reference Types to clarify the capturing rules for variables.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは参照型ですを新しくして、変数に対するキャプチャ規則を明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated Defining a Capture List to clarify the syntax for weak and unowned references in closure capture lists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>捕獲リストの定義を新しくして、クロージャ捕獲リスト内の弱いおよび非所有参照に対する構文を明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated Operators to explicitly mention examples of supported characters for custom operators, such as those in the Mathematical Operators, Miscellaneous Symbols, and Dingbats Unicode blocks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子を更新して、あつらえの演算子のためにサポートされる文字の例にはっきりと言及するようにしました、例えばMathematical Operators、Miscellaneous Symbols、そしてDingbatsユニコードブロックにおけるそれら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated Protocol Declaration to clarify protocol declaration scope and members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言を新しくして、プロトコル宣言スコープおよびメンバーを明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated Range Operators to note that a half-open range with the same start and end index will be empty.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>範囲演算子を新しくして、同じ開始および終止インデックスを持つ半開範囲が空になることを記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated Value Overflow to clarify the overflow behavior of signed and unsigned integers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値オーバフローを新しくして、符号つき及び符号なし整数のオーバフロー挙動を明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated a note in the Property Observers section to clarify the behavior of willSet and didSet observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節プロパティオブザーバーをwillSetとdidSetオブザーバーの挙動を理解しやすくするために更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated a note in the Type Properties section to mention that stored type properties are lazily initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティ節の注を更新して、保存型プロパティが遅延して初期化されることに言及した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated and expanded the Comparing Strings section to reflect and demonstrate that string and character comparison and prefix / suffix comparison are now based on Unicode canonical equivalence of extended grapheme clusters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節文字列を比較するを更新および拡張して、文字列および文字比較と接頭辞／接尾辞比較が今では拡張書記クラスタのユニコード正準等価に基づかれることを反映し例示しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated attribute arguments to use a colon in the Attributes chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>属性引数をコロンを使うように章属性において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated discussion throughout to use macOS instead of OS X, Error instead of ErrorProtocol, and protocol names such as ExpressibleByStringLiteral instead of StringLiteralConvertible.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>解説を隅から隅まで更新してmacOSをOS Xの代わりに、, ErrorをErrorProtocolの代わりに、ExpressibleByStringLiteralのようなプロトコル名をStringLiteralConvertibleの代わりに使うようにした</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated figures in the Weak References section to show the deallocation process more clearly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照節の図を更新して、デアロケーション過程をより明瞭に見せるようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 1.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 1.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 1.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 1.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 2.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 2.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 2.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 2.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 2.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 2.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 3.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 3.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 3.0.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 3.0.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated information about initializers that return nil before the instance is fully initialized in the Failable Initializers section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスが完全に初期化される前にnilを返すイニシャライザについての情報を失敗できるイニシャライザ節において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Accessing Properties Through Optional Chaining section to clarify how assignment through optional chaining behaves.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を通してプロパティにアクセスする節を更新して、オプショナル連鎖をを通した割り当てがどのように振る舞うかを明確にした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Accessing and Modifying a Dictionary section to note that Dictionary now has a Boolean isEmpty property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書へのアクセスと修正の節を更新してDictionaryが今やブールのisEmptyプロパティを持つことを記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Accessing and Modifying an Array section to note that you can no longer append a single item to an array with the += operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節配列へのアクセスと変更を更新して、あなたがもはや単一の項目を+=演算子を使って配列に加えることが出来ないことを注記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Attributes chapter to note that the @IBAction, @IBOutlet, and @NSManaged attributes imply the @objc attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>属性の章を更新して、@IBAction、@IBOutlet、そして@NSManaged属性が@objc属性を暗示することを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Break Statement section with information about labeled break statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節ブレーク文をラベルをつけられたブレーク文についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Capturing Values section to clarify how variables and constants are captured in closures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値を捕獲する節を更新してどのように変数と定数がクロージャにキャプチャされるかをわかりやすくした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Concatenating Strings and Characters section to reflect the fact that String and Character values can no longer be combined with the addition operator (+) or addition assignment operator (+=).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列と文字の連結節をStringとCharacter値はもはや加算演算子（+）または加算代入演算子（+=）を使って結合されることができないという事実を反映するために更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Declaration Attributes and Conditional Compilation Block sections with information about tvOS.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言属性と条件コンパイルプロック節をtvOSについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Declaration Attributes section to describe when you can apply the @objc attribute to classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言属性節を更新してあなたが@objc属性をクラスへ適用できる場合を記述した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Declaration Attributes section with information about the @available and @warn_unused_result attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節宣言属性を@availableと@warn_unused_result属性についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Expressions chapter to separate the discussion of parenthesized expressions and tuple expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式の章を更新して、括弧で囲まれた式とタプル式の解説を分離した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Initializer Inheritance and Overriding section to note that overrides of a designated initializer must now be marked with the override modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節イニシャライザの継承とオーバーライドを更新して、指定イニシャライザのオーバーライドは今やoverride修飾子で印付けされなければならないことを注記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Operators section with discussion of custom operators that contain a dot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子節をドットを含むカスタム演算子の議論で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Repeat-While section with information about the repeat-while loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節この間繰り返すをrepeat-whileループについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Representing and Throwing Errors section, now that all types can conform to the ErrorType protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーの表現とスロー節を更新した、現在ではすべての型がErrorTypeプロトコルに準拠できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Required Initializers section to note that the required modifier is now written before every subclass implementation of a required initializer, and that the requirements for required initializers can now be satisfied by automatically inherited initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節必須イニシャライザを更新して、required修飾子が今やすべてのサブクラス実装の必須イニシャライザの前に書かれること、そして必須イニシャライザのための必要条件は今や自動的に継承されるイニシャライザで満たされることが出来るのを注記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Special Characters in String Literals section with a more precise definition of Unicode scalars.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節文字列リテラル内の特別な文字をユニコードスカラーのより精密な定義づけで更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the String Interpolation and String Literals sections now that string interpolations can contain string literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列補間と文字列リテラル節を更新した、今では文字列補間は文字列リテラルを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the String Literals section to note that Unicode scalars inside string literals are now written as \u{n}, where n is a hexadecimal number between 0 and 10FFFF, the range of Unicode’s codespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラルの節を更新して文字列内部のユニコード・スカラーが今や\u{n}のように書かれることを記しました、ここでnは０から10FFFまでの16進数、ユニコードの符号空間です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Strings and Characters chapter to reflect the fact that Swift’s Character type now represents a single Unicode extended grapheme cluster.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列と文字の章を、スウィフトのCharacter型が今や単一のユニコード拡張書記素クラスタを表わすという事実を反映するために更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Strings and Characters chapter, now that String no longer conforms to the CollectionType protocol from the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節文字列と文字を更新した、現在ではStringはもはやスウィフト標準ライブラリ由来のCollectionTypeプロトコルに準拠しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Type Annotations section to note that multiple related variables can be defined on a single line with one type annotation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型注釈の節を更新して複数の関連する変数が１行だけで１つの型注釈で定義されることが出来ることを記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Type Attributes section with information about the @convention attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節型属性を@convention属性についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Type Properties section with information about stored and computed type properties for classes, structures, and enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節型プロパティをクラス、構造体、そして列挙のための保存および計算型プロパティについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Variadic Parameters section, now that variadic parameters can be declared in any position in a function’s parameter list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長パラメータ節を更新した、現在では可変長パラメータは関数のパラメータリストの中のあらゆる位置で宣言されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Operators reference to describe the revised rules.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>改められた規則を記述するために演算子リファレンスを更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the definition of Unicode scalars in string literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラルの中のユニコードスカラーの定義を新しくしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion about default parameters in the Default Parameter Values section, now that they can’t be reordered in function calls.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のパラメータについての議論を省略時のパラメータ値の節で更新した、今ではそれらは関数呼び出しにおいて再配列されることが出来ないので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in Functions that Never Return to use the new Never type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>決して返らない関数での議論を更新して新しいNever型を使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the Dynamic Type Expression section to use the new type(of:) syntax for dynamic type expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動的型式の節において議論を更新して、 新しいtype(of:)構文を動的型式に使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the Escaping Closures section, now that closures are nonescaping by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャを脱出するの節において議論を更新した、今ではクロージャは初期状態で非脱出です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the Generic Where Clauses section of the Generics chapter and in the Generic Parameters and Arguments chapter, now that generic where clauses are written at the end of a declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体の章の総称体where節の節および総称体パラメータと引数の章において議論を更新した、今では総称体where節は宣言の最後に書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the In-Out Parameters section to note that only nonescaping closures can capture in-out parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータの節において解説を更新して、非脱出クロージャのみがin-outパラメータをキャプチャできることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the Optional Binding section of the The Basics chapter and the While Statement section of the Statements chapter, now that if, while, and guard statements use a comma-separated list of conditions without where clauses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本の章のオプショナルを束縛するの節と文の章のwhile文の節での議論を更新した、今ではif、while、そしてguard文はwhere節なしでコンマで区切られた条件リストを使うからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of inout in the Function Declaration section to note that it appears in front of a parameter’s type instead of in front of a parameter’s name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>inoutの議論を関数定義の節において更新して、それが現れるのはパラメータの持つ型の前で、バラメータの名前の前でないことを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of associated types to use the associatedtype keyword in the Associated Types and Protocol Associated Type Declaration sections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型の議論をassociatedtypeキーワードを使うように関連型とプロトコル関連型宣言の節で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of function types in the Function Type section now that function argument labels are no longer part of a function’s type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型の解説を節関数型において更新した、今では関数引数ラベルはもはや関数の型の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of function types in the Function Type section to note that parentheses around the parameter types are required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型の解説を節関数型において更新して、パラメータ型の周りの丸括弧は必要とされることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of functions in the Functions chapter and the Function Declaration section to note that all parameters get an argument label by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の解説を章関数と節関数宣言において更新して、すべてのパラメータが引数ラベルを初期状態で受け取ることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of line control statements to use the #sourceLocation(file:line:) syntax in the Line Control Statement section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行制御文の解説を#sourceLocation(file:line:)構文を使うように行制御文の節において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of operators in the Advanced Operators chapter, now that you implement them as type methods instead of as global functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子の議論を先進の演算子の章において更新した、今ではあなたはそれらをグローバル関数としてではなく型メソッドとして実装するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of optional protocol requirements in the Optional Protocol Requirements section to clarify that they are used only in code that interoperates with Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルプロトコル要件の解説を節オプショナルのプロトコル要件において更新して、それらがObjective-Cと相互運用するコードにおいてのみ使用されることを明確にした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of protocol composition types in the Protocol Composition section of the Protocols chapter and in the Protocol Composition Type section of the Types chapter to use the new Protocol1 &amp; Protocol2 syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成型の議論をプロトコルの章のプロトコル合成の節において、そして型の章のプロトコル合成型の節において更新して、新しいProtocol1 &amp; Protocol2構文を使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of the @NSManaged attribute in the Declaration Attributes section, now that the attribute can be applied to certain instance methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@NSManaged属性の議論を宣言属性節において更新した、現在ではこの属性は特定のインスタンスメソッドに適用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of the @noescape and @autoclosure attributes in the Escaping Closures and Autoclosures sections and the Attributes chapter now that they are type attributes, rather than declaration attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@noescapeと@autoclosure属性の議論を脱出クロージャと自動クロージャの節および属性の章で更新した、今ではそれらは型属性です、宣言属性ではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of the @objc attribute in the Declaration Attributes section to note that enumerations and enumeration cases can use this attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@objc属性についての議論を宣言属性において更新して、列挙と列挙ケースがこの属性を使用できることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of weak and unowned references in the Automatic Reference Counting chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱いそして非所有参照の議論を自動参照カウントの章において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the entire book to refer to ..&lt; as the Half-Open Range Operator (rather than the “half-closed range operator”).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>..&lt;を半開範囲演算子と言うように本全体を更新しました（「半完結範囲演算子」ではなしに）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the example in Type Casting for Any and AnyObject to show how to check for and cast to a function type within a switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AnyおよびAnyObjectに対する型キャストでの例を更新して、switch文内のある関数型について調べてキャストする方法を示しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the information about Memberwise Initializers for Structure Types to clarify that the memberwise structure initializer is made available even if a structure’s stored properties do not have default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体型のためのメンバー関連イニシャライザについての情報が更新されて、メンバー関連の構造体初期化子が、ある構造体の持つ保存プロパティが省略時の値を持たなくてさえも、利用可能にされることをわかりやすくされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the information about Mutability of Collections and Arrays to reflect the new approach.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい取り組み方を反映するために、コレクションの可変性および配列についての情報が更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the rules for constant and constant property declaration and initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と定数プロパティの宣言と初期化についての規則を新しくしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated to ..&lt; rather than .. for the Half-Open Range Operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>半開範囲演算子に対して..ではなく..&lt;に更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use ..&lt; to make a range that omits its upper value, and use ... to make a range that includes both values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>..&lt;をその上側の値を除く範囲を作るために使ってください、そして...を両方の値を含む範囲を作るために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use Any and AnyObject only when you explicitly need the behavior and capabilities they provide.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが明白にそれらが提供する挙動と能力を必要とする時にだけ、AnyとAnyObjectを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use UInt only when you specifically need an unsigned integer type with the same size as the platform’s native word size.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが特にプラットホーム固有のワードサイズと同じ大きさで符号なし整数型を必要とする時にだけUIntを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use \() to include a floating-point calculation in a string and to include someone’s name in a greeting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>\()を、浮動小数点計算を文字列に含めるために、そして誰かの名前をある挨拶に含めるために使ってみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use class followed by the class’s name to create a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスを作成するためにclassを使ってその後にそのクラスの名前を続けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use defer to write a block of code that is executed after all other code in the function, just before the function returns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>deferを使って関数の中の全ての他のコードの後で、その関数が返る直前に実行されるひとかたまりのコードを書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use deinit to create a deinitializer if you need to perform some cleanup before the object is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトが割り当て解除される前にあなたがいくらかの掃除をする必要があるならば、デイニシャライザをつくるために、deinitを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use enum to create an enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙をつくるために、enumを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use extension to add functionality to an existing type, such as new methods and computed properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>機能性、例えば新しいメソッドや計算プロパティなどを、既存の型に加えるために、extensionを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use fileprivate(set), private(set), and internal(set) to change the access level of this synthesized setter in exactly the same way as for an explicit setter in a computed property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>fileprivate(set)、private(set)、そしてinternal(set)を使って、計算プロパティにおける明示的なセッターと正確に同じ方法で、この総合されたセッターのアクセス水準を変更してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use func to declare a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>funcを使うことで、あるひとつの関数を宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use iOS, macOS, watchOS, and tvOS for the platform names, and include the corresponding version numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プラットホーム名としてiOS、macOS、watchOS、そしてtvOSを、付随するバージョン番号を含めて使ってください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use if and switch to make conditionals, and use for-in, for, while, and repeat-while to make loops.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件文を作るためにifとswitchを使ってください、そしてループを作るためにfor-in、for、while、そしてrepeat-whileを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use let to make a constant and var to make a variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>letを使って定数を作りvarを使って変数を作ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use protocol to declare a protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルを宣言するために、protocolを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use struct to create a structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体を作成するために、structを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use throw to throw an error and throws to mark a function that can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるエラーをスローする（投げかける）ためにthrowを、そしてエラーをスローできる関数に印をつけるためにthrowsを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use where right before the body to specify a list of requirements—for example, to require the type to implement a protocol, to require two types to be the same, or to require a class to have a particular superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本文のまさに前に、必要なことのリストを指定するためにwhereを使ってください ― 例えば、型があるプロトコルを実装することを要求するために、２つの型が同じものであることを要求するために、またはあるクラスがある特定のスーパークラスを持つことを要求するために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use while to repeat a block of code until a condition changes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>whileを使って、コードのひとかたまり（ブロック）を、ある条件が変化するまで繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use -&gt; to separate the parameter names and types from the function’s return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>-&gt;を使って、パラメーター名とその関数の返す型とを隔ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use in to separate the arguments and return type from the body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>inを使って、引数および返す型を本文から切り離してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use init to create one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうしたものをつくるために、initを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a for-in loop with an array to iterate over its items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>for-inループを配列で使って、その項目のすべてに繰り返してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a class-only protocol when the behavior defined by that protocol’s requirements assumes or requires that a conforming type has reference semantics rather than value semantics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス専用プロトコルを、そのプロトコルの要件によって定義される挙動が想定されるまたは必要とされる時、準拠する型が値意味論ではなく参照意味論を持つ時に、使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a line control statement to change the source code location used by Swift for diagnostic and debugging purposes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行制御文を使ってスウィフトによって使われるソースコード位置を診断上のそしてデバッグの目的で変更してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a new key of the appropriate type as the subscript index, and assign a new value of the appropriate type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字インデックスとして適切な型の新しいキーを使ってください、そして適切な型の新しい値を割り当ててください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a single break statement if you don’t intend to execute any code in the body of a matched case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがマッチされたケース節の本文において何らコードを実行するつもりでないならば、ただ１つbreak文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a string literal as an initial value for a constant or variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラルを定数または変数の初期値として使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a tuple to make a compound value—for example, to return multiple values from a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある混成の値を作るために、タプル（一組にしたもの）を使ってください ― 例えば、関数から複数の値を返すために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a weak reference when the other instance has a shorter lifetime—that is, when the other instance can be deallocated first.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照を他のインスタンスがより短い生涯を持つ場合に使ってください — すなわち、他のインスタンスが最初にでアロケートされることが可能である時。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a wildcard pattern when you don’t care about the values being matched against.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがマッチされている値を気にかけない場合に、ワイルドカード・パターンを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use an assertion whenever a condition has the potential to be false, but must definitely be true in order for your code to continue execution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある条件が偽である可能性を持つが、あなたのコードが実行を続けるためには間違いなく真でなければならないときはいつでも、表明を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use an initializer expression to construct an instance of a type from that type’s metatype value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ式を使って、ある型のインスタンスをその型のメタタイプ値から組み立ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use an unowned reference only when you are sure that the reference always refers to an instance that has not been deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非所有者参照を、その参照が常にデアロケートされていないインスタンスに言及するとあなたが確信する時にだけ使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use comments to include nonexecutable text in your code, as a note or reminder to yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなた自身への注意事項または覚え書きとして、実行可能でないテキストをあなたのコードに含めるために、コメントを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use dot syntax to access the properties and methods of the instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのインスタンスのプロパティおよびメソッドにアクセスするためにドット構文を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use file-private access to hide the implementation details of a specific piece of functionality when those details are used within an entire file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それら詳細があるファイル全体の内部で使われる時に、機能性のある特定部分のそれら実装詳細を隠すために、ファイル外非公開アクセスを使ってください。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use optional chaining to conditionally perform an operation on an implicitly unwrapped optional expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある暗黙的にアンラップされるオプショナルの式に関して演算を条件付きで実行するために、オプショナル連鎖を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use other integer types only when they are specifically needed for the task at hand, because of explicitly-sized data from an external source, or for performance, memory usage, or other necessary optimization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>外部ソース由来の明確に大きさを設定されたデータのために、またはパフォーマンス、メモリ使用、または他の必要な最適化のためになど、目下の作業に特に必要とされる時だけ他の整数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use private access to hide the implementation details of a specific piece of functionality when those details are used only within a single declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それら詳細がある単一の宣言内部でのみ使われる時に、機能性のある特定部分のそれら実装詳細を隠すために、非公開アクセスを使ってください。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use statement labels with break and continue statements to be explicit about how you want to change control flow in a loop statement or a switch statement, as discussed in Break Statement and Continue Statement below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>breakとcontinue文で文ラベルを使って、あなたがループ文またはswitch文においてどのように制御の流れを変えたいかについて明示してください、下記のブレーク文と継続文で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the Int type for all general-purpose integer constants and variables in your code, even if they are known to be non-negative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Int型を全ての一般的な目的のための整数の定数と変数に対してあなたのコードにおいて使ってください、たとえそれらが負数でないことが知られているとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the indices property of the characters property to access all of the indices of individual characters in a string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>charactersプロパティのindicesプロパティを使って、ある文字列中の個々の文字のインデックスのすべてにアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the init?(rawValue:) initializer to make an instance of an enumeration from a raw value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>init?(rawValue:)イニシャライザを使用して、生の値から列挙のインスタンスを作ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the intersection(_:) method to create a new set with only the values common to both sets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>intersection(_:)メソッドを使って両方の集合に共通した値だけを持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the isDisjoint(with:) method to determine whether two sets have any values in common.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>isDisjoint(with:)メソッドを使って２つの集合が何らかの共通の値を持つかどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the isStrictSubset(of:) or isStrictSuperset(of:) methods to determine whether a set is a subset or superset, but not equal to, a specified set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>isStrictSubset(of:)またはisStrictSuperset(of:)メソッドを使ってある集合がある指定した集合の下位集合または上位集合、しかし等しくはない、かどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the isSubset(of:) method to determine whether all of the values of a set are contained in the specified set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>isSubset(of:)メソッドを使ってある集合のすべての値が指定した集合の値の中に含まれるかどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the isSuperset(of:) method to determine whether a set contains all of the values in a specified set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>isSuperset(of:)メソッドを使ってある集合がある指定した集合の値のすべてを含むかどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the startIndex property to access the position of the first Character of a String.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるStringの最初のCharacterの位置にアクセスするためにstartIndexプロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the subtracting(_:) method to create a new set with values not in the specified set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>subtracting(_:)メソッドを使って指定した集合にない値を持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the symmetricDifference(_:) method to create a new set with values in either set, but not both.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>symmetricDifference(_:)メソッドを使ってどちらかの集合にある、しかし両方にではない値を持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the union(_:) method to create a new set with all of the values in both sets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>union(_:)メソッドを使って両方の集合のすべての値を持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the rawValue property to access the raw value of an enumeration case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>rawValueプロパティを使用して、列挙ケース節の生の値にアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the String type’s append(_:) method to append a single Character value onto the end of a string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>String型のappend(_:)メソッドを単一のCharacter値を文字列の終わりに加えるために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the type check operator (is) to check whether an instance is of a certain subclass type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型確認演算子（is）を使用して、あるインスタンスが特定のサブクラス型であるかどうか調べてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the Boolean isEmpty property as a shortcut for checking whether the count property is equal to 0:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブールのisEmptyプロパティをcountプロパティが0と等しいかどうかを調べる近道として使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the classes defined above to create a new Person instance, and try to access its numberOfRooms property as before:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のクラス定義を使って、新しいPersonインスタンスをつくって、前のようにそのnumberOfRoomsプロパティにアクセスすることを試みてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the conditional form of the type cast operator (as?) when you are not sure if the downcast will succeed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがダウンキャストが成功するかどうかよくわからない場合には、条件形式の型キャスト演算子（as?）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the forced form of the type cast operator (as!) only when you are sure that the downcast will always succeed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがダウンキャストが常に成功すると確信する場合には、強制形式の型キャスト演算子（as!）を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the identity operators (=== and !==) to test whether an instance’s runtime type is the same as its compile-time type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同一性演算子（===と!==）を使って、あるインスタンスの実行時型がそれのコンパイル時型と同じかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the ternary conditional operator with care, however.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、注意して三項条件演算子を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the “is equal” operator (==) to determine whether two sets contain all of the same values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「同等」演算子（==）を使って２つの集合がすべて同じ値を含むかどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use these operators to check whether two constants or variables refer to the same single instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの定数または変数が同じ一つのインスタンスに言及するかどうか調べるためにこれらの演算子を使用してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use this approach if you need to add a potential failure state to an existing initialization process that does not otherwise fail.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、起こりうる失敗状況を、その場合にも失敗しない既存の初期化プロセスに加える必要がある場合に、このやり方を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use this attribute when you want to expose a different name to Objective-C for the entity the objc attribute applies to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を、objc属性が適用される実在のために、あなたがObjective-Cには異なる名前を見せたいときに使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use this form of an access-level modifier when you want to specify an access level for the setter of a variable or subscript that’s less than or equal to the access level of the variable or subscript itself, as discussed in Getters and Setters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス水準修飾子のこの形式は、あなたが変数または添え字のセッターにその変数または添え字それ自身のアクセス水準よりもより少ないか等しいアクセス水準を指定することを望むときに使ってください、ゲッターとセッターで議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use this form to access a type as a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値として型にアクセスするために、この形式を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use variables only for storing values that need to be able to change.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変更できる必要がある値を保存するためにだけ、変数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using try? lets you write concise error handling code when you want to handle all errors in the same way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>try?を使うことで、あなたに簡潔なエラー処理コードを書くことを可能にするのは、あなたがすべてのエラーを同じやり方で取り扱いたい時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using ARC in Swift is very similar to the approach described in Transitioning to ARC Release Notes for using ARC with Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでのARCの使用は、Objective-CでARCを使うためのTransitioning to ARC Release Notesで記述される取り組みに非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Function Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型を使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using a guard statement for requirements improves the readability of your code, compared to doing the same check with an if statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>guard文を必要条件に対して使うことは、あなたのコードの可読性を同じ検査確認をif文を使って実行するのと比べて向上します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using explicitly-sized types in these situations helps to catch any accidental value overflows and implicitly documents the nature of the data being used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの状況において明確に大きさを設定された型を使うことは、偶発的な何らかの値のオーバフローを捕えることや、使われているデータの性質を暗黙的に記録することの手助けになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using optionals is similar to using nil with pointers in Objective-C, but they work for any type, not just classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの使用は、Objective-Cのポインターでnilを使うことに似ています、しかしそれは、ただクラスだけでなく、どんな型のためにでも働きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the ! operator to unwrap an optional that has a value of nil results in a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>!演算子を使ってnilの値を持つあるオプショナルをアンラップすることは、実行時エラーの結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the gameLoop label makes it clear which control statement should be terminated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>gameLoopラベルを使用することは、どの制御文が終了されなければならないかを明確にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the default integer type in everyday situations means that integer constants and variables are immediately interoperable in your code and will match the inferred type for integer literal values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>日々の状況において初期状態として整数型を使うことは、整数の定数と変数があなたのコードにおいて直接に情報交換が可能で、いろいろな整数のリテラル値に対して推論される型と調和することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using this attribute is equivalent to calling the NSApplicationMain(_:_:) function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を使用することは、NSApplicationMain(_:_:)関数を呼ぶことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using this attribute is equivalent to calling the UIApplicationMain function and passing this class’s name as the name of the delegate class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を使用することは、UIApplicationMain関数を呼んで、このクラスの名前を委任クラスの名前として渡すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Valid arguments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効な引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value Bindings</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値束縛</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value Overflow</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値オーバフロー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value types (structures and enumerations) do not support inheritance, and so their initializer delegation process is relatively simple, because they can only delegate to another initializer that they provide themselves.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型（構造体と列挙）は、継承をサポートしません、なので、それらのイニシャライザ委任プロセスは比較的単純です、なぜなら、それらがそれら自身で提供する別のイニシャライザに委任できるだけだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value types are described in Structures and Enumerations Are Value Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型は「構造体と列挙は値型です」で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value-Binding Pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値束縛パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value-binding patterns that bind a matched value to the name of a constant begin with the let keyword; those that bind to the name of variable begin with the var keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マッチした値を定数の名前に束縛する値束縛パターンは、letキーワードで始まります；変数の名前と縛りつけるものは、varキーワードで始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values are never implicitly converted to another type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>なんらかの値が暗黙のうちに別の型に変換されることは決してありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values in switch cases can be checked for their inclusion in an interval.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switchケース節における値は、ある区間におけるそれの包含について調べられることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values in the matrix can be set by passing row and column values into the subscript, separated by a comma:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行列の中の値は、コンマで区切った行と列の値を添え字に渡すことによって設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variable Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数の宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variable declarations have several forms that declare different kinds of named, mutable values, including stored and computed variables and properties, stored variable and property observers, and static variable properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数宣言はいくつかの形式を持ちます、それらは、保存および計算の変数およびプロパティ、保存の変数およびプロパティのオブザーバー、そして静的変数プロパティを含む、異なる種類の名前をつけられた可変の値を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables and constants declared in the scope of a do statement can be accessed only within that scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>do文のスコープ内で宣言される変数と定数は、そのスコープ内でのみアクセスされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variadic Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variadic parameters are allowed, subject to the same rules as for normal methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長パラメータは、許され、普通のメソッドと同じ規則の支配下にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variadic parameters can be used if you name the variadic parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが可変長パラメータに名前をつけるならば、可変長パラメータが使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can’t wait to see what you create with it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>私達は、あなたがそれで何をつくるか知るのが待ち切れません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We simplified memory management with Automatic Reference Counting (ARC).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>私達は、Automatic Reference Counting（ARC）で、メモリ管理を単純化しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weak References</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weak and Unowned References</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱いおよび非所有者参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weak and unowned references enable one instance in a reference cycle to refer to the other instance without keeping a strong hold on it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱いおよび非所有者参照は、ある参照循環の中の１つのインスタンスに、他のインスタンスに言及することをそれに対する強い支配力を持つことなく可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weak references are always of an optional type, and automatically become nil when the instance they reference is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照は常にオプショナルの型です、そしてそれが参照をつけるインスタンスが割り当て解除されるとき、自動的にnilになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Welcome to Swift</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにようこそ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What about the second and third blocks?</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２番目と３番目のブロックはどうですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What error do you get?</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、どんなエラーを得ますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What greeting do you get?</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、どんな挨拶を得ますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What kind of error do you need to throw so that the error is handled by the first catch block?</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーが最初のcatchブロックによって取り扱われるためには、どんな種類のエラーをあなたはスローする必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When cinema was given the current value of hd, the values stored in hd were copied into the new cinema instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>cinemaがhdの現在の値を与えられたとき、hdに保存される値は新しいcinemaインスタンスにコピーされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When printMathResult(_:_:_:) is called, it is passed the addTwoInts(_:_:) function, and the integer values 3 and 5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>printMathResult(_:_:_:)が呼ばれるとき、それは、addTwoInts(_:_:)関数、そして整数値3と5を渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When rememberedDirection is assigned the value of currentDirection, it is actually set to a copy of that value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>rememberedDirectionがcurrentDirectionの値を代入されるとき、それは実際にはその値のコピーに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When residence is nil, as in the example above, this optional Int will also be nil, to reflect the fact that it was not possible to access numberOfRooms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>residenceがnilのとき、上の例の場合のように、このオプショナルのIntはまたnilになり、numberOfRoomsにアクセスすることは可能でなかったという事実を反映します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a break statement is followed by the name of a statement label, it ends program execution of the loop, if statement, or switch statement named by that label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>break文に文ラベルの名前が続くとき、それはそのラベルによって指定されるループ、if文、またはswitch文のプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a break statement is not followed by the name of a statement label, it ends program execution of the switch statement or the innermost enclosing loop statement in which it occurs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>break文に文ラベルの名前が続かないとき、それはswitch文またはそれが現れているところの最も内側のそれを囲んでいるループ文のプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a continue statement is followed by the name of a statement label, it ends program execution of the current iteration of the loop statement named by that label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>continue文に文ラベルの名前が続くとき、それは、そのラベルによって指名されるループ文の現在の繰り返しのプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a continue statement is not followed by the name of a statement label, it ends program execution of the current iteration of the innermost enclosing loop statement in which it occurs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>continue文に文ラベルの名前が続かないとき、それは、それが現れるところの一番内側のそれを囲んでいるループ文の現在の繰り返しのプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a return statement is followed by an expression, the value of the expression is returned to the calling function or method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>return文の後に式が続くとき、式の値は関数またはメソッドを呼んでいるところに返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a return statement is not followed by an expression, it can be used only to return from a function or method that does not return a value (that is, when the return type of the function or method is Void or ()).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>return文の後に式が続かないとき、それは値を返さない関数またはメソッド（すなわち、戻り型がVoidまたは()である関数またはメソッド）から返るためにだけ使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a Unicode string is written to a text file or some other storage, the Unicode scalars in that string are encoded in one of several Unicode-defined encoding forms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるUnicode文字列がテキスト・ファイルまたは何か他の記憶装置に書かれるとき、その文字列内のユニコード・スカラーはいくつかのUnicode定義の符号化方式のうちの１つで符号化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a channel’s audio level is 0, none of the lights for that channel are lit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネルの音声のレベルが0であるとき、そのチャンネルのための光のどれも点灯されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a class implements an initializer to satisfy a protocol’s initializer requirement, the initializer must be marked with the required declaration modifier if the class is not already marked with the final declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスがプロトコルのイニシャライザ要件を満たすためにイニシャライザを実装するとき、そのイニシャライザはrequired宣言修飾子を使って印される必要が、そのクラスが既にfinal宣言修飾子を使って印されていないならば、あります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a closure is the only argument to a function, you can omit the parentheses entirely.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつのクロージャが関数の唯一の引数である時、あなたは丸括弧をすっかり省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a closure’s type is already known, such as the callback for a delegate, you can omit the type of its parameters, its return type, or both.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャの型がすでに知られているとき、例えば委任先のためのコールバックなどでは、あなたはそのパラメータの型、その戻り型、あるいは両方を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a constant declaration occurs in the context of a class or structure declaration, it is considered a constant property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言がクラスまたは構造体宣言の文脈において起こるとき、それは定数プロパティとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a constant declaration occurs in the context of a function or method, it can be initialized later, as long as it is guaranteed to have a value set before the first time its value is read.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言が関数またはメソッドの文脈において現れるとき、それは後で初期化されることができます、それがある値をその値が読み出される最初の時の前に設定されてしまっているよう保証する限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a constant is declared at global scope, it must be initialized with a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数がグローバルなスコープで宣言されるとき、それはひとつの値で初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a declaration is obsoleted, it’s removed from the specified platform and can no longer be used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある宣言が廃止された場合は、それは指定されたプラットホームから取り除かれます、そしてもはや使用されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function encounters an error condition, it throws an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数がエラー状態に遭遇するとき、それはあるエラーをスローします（投げます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function throws an error, it changes the flow of your program, so it’s important that you can quickly identify places in your code that can throw errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数がエラーをスローするとき、それはあなたのプログラムの流れを変えます、そのため重要なのは、あなたがすばやくあなたのコードの中のエラーをスローできる場所を識別することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a member has the same name as a keyword, references to that member don’t need to be escaped with backticks, except when there is ambiguity between referring to the member and using the keyword—for example, self, Type, and Protocol have special meaning in an explicit member expression, so they must be escaped with backticks in that context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるメンバがあるキーワードと同じ名前を持つ時、そのメンバへの参照はバッククォートでエスケープされる必要はありません、そのメンバへの参照とキーワードの使用の間に曖昧さがある場合を除いては—例えば、self、Type、そしてProtocolは、特別な意味をある明示的なメンバ式の中で持ちます、それでそれらはバッククォートでエスケープされることがその文脈においては必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a protocol type inherits from other protocols, the set of requirements from those other protocols are aggregated together, and any type that inherits from the current protocol must conform to all of those requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル型が他のプロトコルから継承するとき、それらの他のプロトコルからの要件ひとそろいは一緒にまとめられます、そして、現在のプロトコルから継承するどんな型でもそれらの要件の全てに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a protocol type inherits from other protocols, the set of requirements from those other protocols are aggregated, and any type that inherits from the current protocol must conform to all those requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコル型が他のプロトコルから継承するとき、それらの他のプロトコルからの要件一式は、ひとまとめにされます、そして現在のプロトコルから継承するどんな型でも、それらの要件の全てに従わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a single else clause is present, an if statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ただ１つだけのelse節が含まれている時は、if文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a tuple pattern is used as the pattern in a for-in statement or in a variable or constant declaration, it can contain only wildcard patterns, identifier patterns, optional patterns, or other tuple patterns that contain those.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルパターンがfor-in文においてまたは変数や定数宣言においてパターンとして使われるとき、それはワイルドカード・パターン、識別子パターン、オプショナルパターン、またはそれらを含む他のタプルパターンだけを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a type alias is declared with generic parameters, the constraints on those parameters must match exactly the constraints on the existing type’s generic parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型エイリアスが総称体パラメータで宣言されるとき、それらのパラメータ上の制約は厳密に既存の型の持つ総称体パラメータ上の制約に一致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a variable declaration of this form is declared at global scope or the local scope of a function, it is referred to as a computed variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この形式の変数の宣言がグローバルなスコープまたは関数のローカルなスコープで宣言されるとき、それは計算変数と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a variable declaration of this form is declared at global scope or the local scope of a function, it is referred to as a stored variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この形式の変数の宣言がグローバルなスコープまたは関数のローカルなスコープで宣言されるとき、それは保存変数と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a variable declaration of this form is declared at global scope or the local scope of a function, the observers are referred to as stored variable observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この形式の変数の宣言がグローバルなスコープまたは関数のローカルスコープで宣言されるとき、オブザーバーは保存変数オブザーバーと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When accessing the elements in a multidimensional array, the left-most subscript index refers to the element at that index in the outermost array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多次元配列の要素にアクセスするとき、最も左の添え字インデックスは、最も外側の配列の中のそのインデックスでの要素に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When alternative productions are too long to read easily, they are broken into multiple grammar production rules on new lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代替の導出が簡単に読むにはあまりに長いとき、それらが新しい行で複数部分の文法導出規則へとばらされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an element of a tuple type has a name, that name is part of the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるタプル型の要素が名前を持つ場合、その名前は型の一部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an error is thrown, some surrounding piece of code must be responsible for handling the error—for example, by correcting the problem, trying an alternative approach, or informing the user of the failure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるエラーがスローされるとき、なかには周囲のコード部分がエラーを処理することに対して責任を持たなければならないこともあります ― 例えば、問題を訂正すること、代わりの取り組みを試みること、または失敗をユーザに知らせることによって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an instance of a value type is marked as a constant, so are all of its properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型のインスタンスが定数として印される時は、そのプロパティの全てがそうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When considered in isolation, the nested incrementer() function might seem unusual:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>切り離して考えたとき、入れ子にされたincrementer()関数は普通でないものに見えるかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When creating a selector for a property’s getter, the property name can be a reference to a variable or constant property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティのゲッターのためのセレクタを作成するとき、property nameは変数または定数プロパティへの参照であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When defining a class, the name of the superclass must appear first in the list of type identifiers, followed by any number of protocols the class must conform to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスを定義するとき、スーパークラスの名前は型識別子のリストにおいて最初に現れなければなりません、そしてそのクラスが準拠しなければならないいくらかのプロトコルが続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When defining a protocol, it is sometimes useful to declare one or more associated types as part of the protocol’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルを定義するとき、時々役に立つのは、プロトコルの定義の一部として一つ以上の関連型を宣言することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it is declared in the context of a class or structure declaration, it is referred to as a stored variable property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがクラスまたは構造体宣言の文脈において宣言されるとき、それは保存変数プロパティと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it is declared in the context of a class or structure declaration, the observers are referred to as property observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがクラスまたは構造体宣言の文脈において宣言されるとき、オブザーバーはプロパティオブザーバーと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it is declared in the context of a class, structure, or extension declaration, it is referred to as a computed property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがクラス、構造体、または拡張宣言の文脈において宣言されるとき、それは計算プロパティと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it is not appropriate to provide a case for every enumeration case, you can provide a default case to cover any cases that are not addressed explicitly:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての列挙ケース節にcaseを提供することが妥当でないとき、あなたは明確に指定されないあらゆるケース節を扱うためにdefaultの場合を提供することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When one class inherits from another, the inheriting class is known as a subclass, and the class it inherits from is known as its superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスが他のものから継承するとき、継承を受けているクラスはサブクラスとして知られています、そして、そこからそれが譲り受ける原点のクラスは、それのスーパークラスとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When set to true, an operator in the corresponding precedence group uses the same grouping rules during optional chaining as the assignment operators from the standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>trueに設定する場合、対応する優先順位グループの演算子は標準ライブラリ由来のassignment（割り当て）演算子と同じグループ化規則をオプショナル連鎖の間に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When specifying the type annotation for a literal value, the annotation’s type must be a type that can be instantiated from that literal value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるリテラル値に型注釈を指定するとき、その注釈の型は、そのリテラル値からインスタンス化されることができる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When strings are used for raw values, the implicit value for each case is the text of that case’s name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列が生の値のために使われる時、各ケース節のための暗黙的な値は、そのケース節の名前のテキストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When that case is matched by the switch statement, the break statement inside the case ends the switch statement’s execution immediately.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのケース節がswitch文によってマッチされるとき、ケース節の内側のbreak文は直ちにswitch文の実行を終えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the audio level is 10, all of the lights for that channel are lit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>音声のレベルが10であるとき、そのチャンネルのための光の全ては点灯されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the enumeration type can be inferred from context, you can omit it (the dot is still required), as described in Enumeration Syntax and Implicit Member Expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙型が前後関係から推論されることができるとき、列挙構文と暗黙のメンバー式で記述されるように、あなたはそれを省略することができます（ドットは依然必要です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the expression on the left hand side of a binary operator is marked with try, try?, or try!, that operator applies to the whole binary expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある二項演算子の左手側での式がtry、try?、またはtry!で印されるならば、その演算子は二項式全体に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the function is called, the value of the argument is copied.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数が呼ばれる時、その引数の値はコピー（複製）をつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the function returns, the copy’s value is assigned to the original argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数が戻る時、コピーの値はそのオリジナルの（元の）引数に代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the function returns, your changes to the original are overwritten with the value of the copy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数が戻る時、オリジナルへのあなたの変更はコピーの値で上書きされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the match succeeds, the value 42 is bound (assigned) to the constant name someValue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マッチが成功するとき、値42は、定数の名前のsomeValueに縛りつけられます（代入されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the pattern on the left-hand side of a variable or constant declaration is an identifier pattern, the identifier pattern is implicitly a subpattern of a value-binding pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数や定数宣言の左側のパターンが識別子パターンであるとき、その識別子パターンは暗黙のうちに値束縛パターンの下位パターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the second function is called, the message is still printed by the first function, but the returned value is not used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二の関数が呼ばれるとき、メッセージは最初の関数によって依然として出力されます、しかし返された値は使われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this detailed form is used, only the imported symbol (and not the module that declares it) is made available in the current scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この詳細な書式が使われるとき、インポートされたシンボルだけが（そしてそれを宣言するモジュールでなく）、現在のスコープにおいて利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this simply isn’t feasible (for instance, when the control expression’s type is Int), you can include a default case to satisfy the requirement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが単に実行可能でないとき（たとえば、制御式のもつ型がIntであるとき）、あなたはこの必要条件を満たすために省略時のケース節を含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When to Use Assertions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いつ表明を使うべきか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When two operators compete with each other for their operands, such as in the expression 2 + 3 * 5, the operator with the higher relative precedence binds more tightly to its operands.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの演算子がそれらの演算数に対して互いと比較される時、例えば式2 + 3 * 5などで、より高い関係優先順位を持つ演算子はよりきつくそれの演算数に束縛されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used as the default value of a function or method, the special literal’s value is determined when the default value expression is evaluated at the call site.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数やメソッドの省略時の値として使われる場合は、この特別なリテラルの値はその省略時の値の式が呼び出し現場で評価される時に確定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used inside a switch statement, break causes the switch statement to end its execution immediately and to transfer control to the code after the switch statement’s closing brace (}).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文の中に使われるとき、breakによってswitch文が直ちにその実行を終えて、switch文の閉じ波括弧（}）の後のコードへ制御を移します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used inside a loop statement, break ends the loop’s execution immediately and transfers control to the code after the loop’s closing brace (}).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文の内側で使われるとき、breakは直ちにループの実行を終えて、ループの閉じ波括弧（}）の後のコードへ制御を移します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When working with optional values, you can write ? before operations like methods, properties, and subscripting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの値を扱うとき、あなたはメソッド、プロパティ、そして添え字指定のような演算の前に?を書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you access a subscript on an optional value through optional chaining, you place the question mark before the subscript’s brackets, not after.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがオプショナル連鎖を通してオプショナルの値の上で添え字にアクセスするとき、あなたは添え字の角括弧の前に疑問符を置きます、後ろではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you assign a closure to a property, you are assigning a reference to that closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがクロージャをプロパティに代入するとき、あなたは参照をそのクロージャに代入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you assign a default value to a stored property, or set its initial value within an initializer, the value of that property is set directly, without calling any property observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある保存プロパティに省略時の値を代入する、またはその初期値をイニシャライザの内部で設定するとき、そのプロパティの値は、どんなプロパティオブザーバーも呼び出すことなく、直接に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you call a function that can throw an error, you prepend the try keyword to the expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがエラーをスローできる関数を呼ぶとき、あなたはtryキーワードをその式の前に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you call an overloaded generic function or initializer, the compiler uses these constraints to resolve which overloaded function or initializer to invoke.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがオーバーロードされた総称体関数またはイニシャライザを呼ぶとき、コンパイラはこれらの制約を使って、呼び出すことになるオーバーロードされた関数またはイニシャライザはどれか決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you declare a function that takes a closure as one of its parameters, you can write @escaping before the parameter’s type to indicate that the closure is allowed to escape.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある関数、それのパラメータの１つとしてクロージャをとるものを宣言する時、あなたは@escapingをパラメータの型の前に書くことによって、そのクロージャが脱出を許可されるのを指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you declare a generic type, function, or initializer, you specify the type parameters that the generic type, function, or initializer can work with.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある総称体型、関数、またはイニシャライザを宣言するとき、あなたはその総称体型、関数、またはイニシャライザが扱うことができる型パラメータを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you define a function, you can optionally define one or more named, typed values that the function takes as input, known as parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある関数を定義するとき、あなたは随意にその関数が入力としてとる、一つ以上の名前をつけられ型付けされた値、パラメータとして知られるものを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you define a protocol extension, you can specify constraints that conforming types must satisfy before the methods and properties of the extension are available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがプロトコル拡張を定義するとき、あなたは準拠している型がその拡張のメソッドやプロパティが利用可能になる前に満たさなければならない制約を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you define your own custom classes and structures, it is your responsibility to decide what qualifies as two instances being “equal”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが独自の特注のクラスと構造体を定義するとき、２つのインスタンスが「等しい」とする基準は何かを決めるのはなたの責任です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you define your own structures, classes, and enumerations, it can be useful to provide your own implementations of the standard Swift operators for these custom types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあなた自身の構造体、クラス、そして列挙を定義するとき、標準のスウィフト演算子のあなた自身の実施をそれらあつらえの型のために提供することは役に立つことがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you develop a framework, mark the public-facing interface to that framework as open or public so that it can be viewed and accessed by other modules, such as an app that imports the framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがフレームワークを開発する場合、そのフレームワークを開放または公開するために公開向けインタフェースとして印してください、それで、他のモジュール、例えばそのフレームワークをインポートするアプリによってそれが見られてアクセスされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you do so, you must mark the overridden subscript declaration with the override declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがそうするとき、あなたはオーバーライドされる添え字宣言をoverride宣言修飾子で印しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you don’t, Swift will automatically assign the values for you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがそうしない時は、スウィフトはあなたの代わりに自動的に値を割り当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you extend a generic type, you do not provide a type parameter list as part of the extension’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある総称体型を拡張する時、あなたは型パラメーターリストを拡張の定義の一部として提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you mark a member declaration with the dynamic modifier, access to that member is always dynamically dispatched using the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがメンバー宣言をdynamic修飾子で印する時は、そのメンバーへのアクセスは、常に動的にObjective-Cランタイムを使用してディスパッチされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you provide a method, property, or subscript override for a subclass, it is sometimes useful to use the existing superclass implementation as part of your override.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがサブクラスのためにメソッド、プロパティ、または添え字のオーバーライドを提供する時、既存のスーパークラスの実装をあなたのオーバーライドの一部として使うことは時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you use a method or property in an optional requirement, its type automatically becomes an optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがオプショナルの要件の中のメソッドやプロパティを使うとき、それの型は自動的にオプショナルになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you use the trailing closure syntax, you don’t write the argument label for the closure as part of the function call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが後付クロージャ構文を使うとき、あなたは引数ラベルをそのクロージャに対して関数呼び出しの一部として書きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you work with values whose type is a protocol type, methods outside the protocol definition are not available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その型があるプロトコル型である値をあなたが扱うとき、そのプロトコル定義の外部のメソッドは利用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you write a simple single-target app, the code in your app is typically self-contained within the app and does not need to be made available outside of the app’s module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが単純な単一ターゲットアプリを書いている場合、あなたのアプリのコードは概してそのアプリの内部に自身で持っていて、そしてそのアプリのモジュールの外側で利用可能にされることは必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you write a subclass initializer that matches a superclass designated initializer, you are effectively providing an override of that designated initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがスーパークラスの指定イニシャライザと一致するあるサブクラス・イニシャライザを書く時、あなたは事実上その指定イニシャライザのオーバーライドを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you write an app with a unit test target, the code in your app needs to be made available to that module in order to be tested.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがユニットテストターゲットを使ってアプリを書く場合、あなたのアプリのコードはテストされるためにそのモジュールに対して利用可能にされる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you write or extend a type to conform to a protocol, you must ensure that the type’s implementation of each protocol requirement has at least the same access level as the type’s conformance to that protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある型をプロトコルに準拠するように書く、または拡張する時は、あなたはその型のもつ各プロトコル要件の実装が少なくともそのプロトコルに対するその型の準拠と同じアクセス水準を持つことを確かにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you write the name of a generic superclass class after the colon, you must include the full name of that generic class, including its generic parameter clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがコロンの後に総称体スーパークラスの名前を書く時、あなたはその総称体クラスの名前全体を、それの総称体パラメーター節を含めて書く必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you’re working with enumerations that store integer or string raw values, you don’t have to explicitly assign a raw value for each case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが整数や文字列の生の値を格納する列挙を使って作業している時、あなたは各ケース節に生の値を明示的に割り当てる必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever a new Chessboard instance is created, the closure is executed, and the default value of boardColors is calculated and returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいChessboardインスタンスがつくられるときはいつでも、このクロージャは実行されます、そしてboardColorsの省略時の値が計算されて、返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever a new instance of the type that the property belongs to is initialized, the closure or function is called, and its return value is assigned as the property’s default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのプロパティが属している型の新しいインスタンスが初期化されるときはいつでも、そのクロージャまたは関数が呼ばれます、そしてその戻り値はプロパティの省略時の値として代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever an object in the array conforms to the HasArea protocol, the optional value returned by the as? operator is unwrapped with optional binding into a constant called objectWithArea.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列のオブジェクトがHasAreaプロトコルに準拠するときはいつでも、as?演算子によって返されるオプショナルの値は、オプショナル束縛によってobjectWithAreaと呼ばれる定数へとアンラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever this return value equals 7, the dice roll has become too large and is reset to a value of 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この戻り値が7に等しいときはいつでも、そのさいころの目は大きくなり過ぎているので、値1へ設定し直されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever you assign a function or a closure to a constant or a variable, you are actually setting that constant or variable to be a reference to the function or closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが関数やクロージャを定数または変数に代入するときはいつでも、あなたは実際はその定数または変数が関数やクロージャへの参照であると設定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever you define a new class or structure, you effectively define a brand new Swift type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが新しいクラスまたは構造体を定義するときはいつでも、あなたは実質的にまっさらなスウィフト型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever you set the currentSpeed property of an AutomaticCar instance, the property’s didSet observer sets the instance’s gear property to an appropriate choice of gear for the new speed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがAutomaticCarインスタンスのcurrentSpeedプロパティを設定したときはいつでも、そのプロパティのdidSetオブザーバーは、そのインスタンスのgearプロパティを新しい速度のために適切な選択に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where this is appropriate, you access the superclass version of a method, property, or subscript by using the super prefix:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これがふさわしい所で、あなたはsuper接頭辞を使用することによってスーパークラス版のメソッド、プロパティ、または添え字にアクセスします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where this is the case, the protocol names are written in exactly the same way as for a class or structure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合である所で、そのプロトコル名は、クラスまたは構造体についてと正確に同じ方法で書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where you believe this is the case, you can try to downcast to the subclass type with a type cast operator (as? or as!).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの場合であると思う所で、あなたはサブクラス型へのダウンキャストを試みることが型キャスト演算子（as?またはas!）を使ってできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初に評価</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Loops</seg>
      </tuv>
      <tuv lang="JA">
        <seg>whileループ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>while文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While it is most common for a subscript to take a single parameter, you can also define a subscript with multiple parameters if it is appropriate for your type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字がただ一つのパラメータをとることが最も普通であるけれども、あなたはまた、それがあなたの型に適切ならば、複数のパラメータをもつ添え字を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace and Comments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空白とコメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace has two uses: to separate tokens in the source file and to help determine whether an operator is a prefix or postfix (see Operators), but is otherwise ignored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空白には、２つの用途があります：ソース・ファイルの中のトークンを切り離すため、そして、演算子が接頭辞か接尾辞であるかについて決定することを手伝います（演算子を見てください）、それ以外では無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wildcard Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ワイルドカード式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wildcard Pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ワイルドカード・パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a conditional statement, you can use a statement label with the break statement to end the execution of the labeled statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件文では、あなたは文ラベルをbreak文とともに使うことで、ラベルをつけられた文の実行を終えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a loop statement, you can use a statement label with the break or continue statement to end or continue the execution of the labeled statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文では、あなたは文ラベルをbreakまたはcontinue文とともに使うことで、ラベルをつけられた文の実行を終えたり継続したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With an optional tuple type, the entire tuple is optional, not just each individual value within the tuple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルタプル型では、タプル全体がオプショナルです、単にタプルの内部の個々の値それぞれではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With the exception of the implicit unwrapping behavior, the following two declarations are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされる挙動を除けば、以下の２つの宣言は等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within the body of a type method, the implicit self property refers to the type itself, rather than an instance of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型メソッドの本文内で、暗黙のselfプロパティはその型自身に言及します、その型のインスタンスではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without the self prefix, Swift would assume that both uses of x referred to the method parameter called x.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>self接頭辞なしでは、スウィフトは両方のxの使用がxと呼ばれるメソッドパラメータに言及したものと仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without this conversion in place, the addition would not be allowed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>適切なこの変換なしでは、この加算は許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without this requirement, Dictionary could not tell whether it should insert or replace a value for a particular key, nor would it be able to find a value for a given key that is already in the dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この要件なしでは、Dictionaryはそれが特定のキーのために値を差し込んだり取り替えたりするべきかどうか伝えることができませんし、それはすでに辞書の中にある指定されたキーに対する値を見つけることもできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without this type alias, the sum function would have to refer to the associated type as T.Iterator.Element instead of T.Element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この型エイリアスな時では、sum関数は関連値をT.Iterator.Elementのように参照しなければならないでしょう、T.Elementではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>連鎖の最上部から逆に階層を下って、連鎖の中の各指定イニシャライザは、さらにインスタンスを好みに合わせて作り変える選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Working with Characters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字を扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wrap the name in parentheses and escape it with a backslash before the opening parenthesis:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>丸括弧にその名前を包んで、始めの括弧の前のバックスラッシュでそれをエスケープします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write a custom argument label before the parameter name, or write _ to use no argument label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの引数ラベルはパラメータ名の前に書いてください、または引数ラベルなしで使うためには_を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write a function that calculates the average of its arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その引数の平均を計算する関数を記述してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write a function that compares two Rank values by comparing their raw values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの生の値を比較することによって２つのRankの値を比較する関数を記述してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write a name inside angle brackets to make a generic function or type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体である関数や型を作るためには、その名前を山形括弧の中に書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write a question mark (?) after the type of a value to mark the value as optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある値がオプショナルであると印するために、その値の型の後に疑問符（?）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write a type annotation by placing a colon after the constant or variable name, followed by a space, followed by the name of the type to use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数か変数の名前のあとにコロンを置いて、１つの空白に続き、使用する型の名前を続けることによって型注釈を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write an enumeration that conforms to this protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルに準拠する列挙を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write an extension for the Double type that adds an absoluteValue property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Double型のために拡張をひとつ書いてください、それはabsoluteValueプロパティを加えるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write an optional binding for an if statement as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの束縛をif文のために次のように書いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write an underscore (_) for an argument with no name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前のない引数に対しては１つのアンダースコア（_）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write the required modifier before the definition of a class initializer to indicate that every subclass of the class must implement that initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>required修飾子をクラス・イニシャライザの定義の前に書いて、そのクラスの全てのサブクラスがそのイニシャライザを実装しなければならないことを示してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write variadic parameters by inserting three period characters (...) after the parameter’s type name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのパラメータの型名の後に３つのピリオド文字（...）を書き入れることによって、可変長パラメータを書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write your code using the model given by copy-in copy-out, without depending on the call-by-reference optimization, so that it behaves correctly with or without the optimization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードをコピーイン・コピーアウトによって与えられるモデルを使って描いてください、参照呼び出し最適化に依存することなしに、そうすることでそれは最適化があってもなくても正しく振舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing &lt;T: Equatable&gt; is the same as writing &lt;T&gt; ... where T: Equatable&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;T: Equatable&gt;と書くことは、&lt;T&gt; ... where T: Equatable&gt;と書くことと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You access and modify a dictionary through its methods and properties, or by using subscript syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、辞書へのアクセスおよび修正をそれのメソッドとプロパティを通して、または添え字構文を使うことで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You access and modify a set through its methods and properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは集合へのアクセス及び変更をそれのメソッドとプロパティを通して行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You access and modify a string through its methods and properties, or by using subscript syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは文字列へのアクセスと修正を、それのメソッドとプロパティを通して、または添え字構文を使うことによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You access and modify an array through its methods and properties, or by using subscript syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、そのメソッドとプロパティを通して、または添え字構文を使うことによって、配列にアクセスして修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You access the indices before and after a given index using the index(before:) and index(after:) methods of String.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある与えられたインデックスの前後のインデックスにStringのindex(before:)とindex(after:)メソッドを使ってアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You access the raw value of an enumeration case with its rawValue property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある列挙ケース節の生の値にそれのrawValueプロパティでアクセスしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also cannot use the implicit self property, or call any of the instance’s methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、暗黙のselfプロパティを使うことや、そのインスタンスのメソッドの何も呼ぶことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also don’t need to write semicolons at the end of every statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、すべての文の終わりにセミコロンを書く必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also saw how to use weak and unowned references to break these strong reference cycles.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、これらの強い参照循環を壊すために弱いおよび非所有者参照を使う方法を見ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also use an initializer expression to delegate to the initializer of a superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、スーパークラスのイニシャライザに委任するために、イニシャライザ式を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You always write the override modifier when overriding a superclass designated initializer, even if your subclass’s implementation of the initializer is a convenience initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはスーパークラスの指定イニシャライザをオーバーライドする時に常にoverride修飾子を書きます、そのイニシャライザのあなたのサブクラスでの実装が便宜イニシャライザであるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You apply the IBOutlet and IBInspectable attributes to property declarations of a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、IBOutletとIBInspectable属性をクラスのプロパティ宣言に適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You apply the IBAction attribute to method declarations of a class and the IBDesignable attribute to class declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、IBAction属性をクラスのメソッド宣言に、そしてIBDesignable属性をクラス宣言に適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are free to implement subscripts in the most appropriate way for your particular class or structure’s functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたの特定のクラスまたは構造体の機能性に最も適切な方法で、添え字を実装して結構です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are not allowed to call a deinitializer yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、デイニシャライザをあなた自身で呼び出すことは許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You assign a lower access level by writing fileprivate(set), private(set), or internal(set) before the var or subscript introducer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、より低いアクセス水準を割り当てることを、fileprivate(set)、private(set)、またはinternal(set)をvarまたはsubscript導入子の前に書くことによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You call an init? failable initializer in the same way that you call a nonfailable initializer, except that you must deal with the optionality of the result.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは失敗できるイニシャライザinit?を、オプショナルの結果を処理する必要があることを除き、失敗できないイニシャライザを呼び出すのと同じ方法で呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You call instance methods with the same dot syntax as properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、インスタンスメソッドをプロパティと同じドット構文を使って呼び出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You call the greet(person:) function by passing it a String value after the person argument label, such as greet(person: "Anna").</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、greet(person:)関数をそれにString値をperson引数ラベルの後で渡すことによって、例えばgreet(person: "Anna")のように呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You call the greet(person:alreadyGreeted:) function by passing it both a String argument value labeled person and a Bool argument value labeled alreadyGreeted in parentheses, separated by commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはgreet(person:alreadyGreeted:)関数をそれにpersonでラベルしたString引数値とalreadyGreetedでラベルしたBool引き数値を両方とも丸括弧内に、コンマで区切って渡すことで呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You call the UINavigationController class pushViewController(_:animated:) method to add (or push) a view controller on to the navigation stack, and its popViewControllerAnimated(_:) method to remove (or pop) a view controller from the navigation stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはUINavigationControllerクラスのpushViewController(_:animated:)メソッドをナビゲーション・スタックにビュー・コントローラを加える（またはプッシュする）ために、そしてそれのpopViewControllerAnimated(_:)メソッドをナビゲーション・スタックからビュー・コントローラを取り除くために呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can decompose a tuple’s contents into separate constants or variables, which you then access as usual:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはタプルの内容を個々の定数または変数に分解することができます。そして、あなたはそれから通常通りそれにアクセスします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access a UTF-16 representation of a String by iterating over its utf16 property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるStringのUTF-16叙述に、それのutf16プロパティのすべてに渡って繰り返していくことによってアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access a UTF-8 representation of a String by iterating over its utf8 property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるStringのUTF-８叙述に、それのutf8プロパティのすべてに渡って繰り返していくことによってアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access a Unicode scalar representation of a String value by iterating over its unicodeScalars property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるStringのUnicodeスカラー叙述に、それのunicodeScalarsプロパティのすべてに渡って繰り返していくことによってアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access the individual Character values for a String by iterating over its characters property with a for-in loop:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるStringの個々のCharacter値にアクセスすることが、それのcharactersプロパティの全体にわたってfor-inループで繰り返していくことによって可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access the minimum and maximum values of each integer type with its min and max properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、そのminとmaxプロパティで各整数型の最小と最大の値を得ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access the properties of an instance using dot syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ドット構文を使ってインスタンスのプロパティにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add a new item into a set by calling the set’s insert(_:) method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは新しい項目を集合に加えることが集合のinsert(_:)メソッドを呼ぶことによって行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add a new item to a dictionary with subscript syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、添え字構文を使って辞書に新しい項目を付け加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add a new item to the end of an array by calling the array’s append(_:) method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、配列のappend(_:)メソッドを呼ぶことによって配列の終わりに新しい項目を加えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add any number of additional branches using #elseif clauses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、任意の数の追加の分岐を加えることが#elseifを使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add property observers to any stored properties you define, except for lazy stored properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロパティオブザーバーをあなたが定義するどんな保存プロパティにでも加えることができます、しかし遅延保存プロパティは除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add property observers to any stored property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロパティオブザーバーをどんな保存プロパティにでも加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add protocol conformance to a previously declared type by adopting the protocol in an extension declaration of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロトコル準拠を以前に宣言された型に加えることが、その型の拡張宣言においてそのプロトコルを採用することによってできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also add a final additional branch using an #else clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、最後の追加の分岐を#else節を使って加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also add new characteristics to the subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、新しい特徴をサブクラスに加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass, as described in Overriding Property Observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、プロパティオブザーバーをあらゆる継承されたプロパティ（保存されるか、計算されるかに関係なく）にでも加えることが、サブクラスの内部でプロパティをオーバーライドすることによって、プロパティオブザーバーのオーバーライドで記述されるように、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、プロパティオブザーバーを、どんな継承されたプロパティにでも（保存されるか、計算されるかに関係なく）、サブクラス内でそのプロパティをオーバーライドすることによって加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also aggregate the conformance requirements of multiple protocols using protocol composition types, as described in Protocol Composition Type and Protocol Composition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、プロトコル合成型とプロトコル合成で記述されるように、複数のプロトコルの準拠要件をひとまとめにすることがプロトコル合成（コンポジション）型を使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also append a String value to an existing String variable with the addition assignment operator (+=):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、あるString値を既存のString変数に加算代入演算子（+=）を使って追加することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also attempt to set a property’s value through optional chaining:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまたプロパティの値をオプショナル連鎖を通して設定することを試みることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also bind an arbitrary expression to a named value in a capture list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、ある任意の式を、キャプチャリストの中の名前をつけられた値と結び付けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also compare tuples that have the same number of values, as long as each of the values in the tuple can be compared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、同数の値を持つタプルを比較することが、そのタプルの中の値が比較されることができる限りは、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also declare a stored variable or property with willSet and didSet observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、willSetとdidSetオブザーバーをもつ保存変数やプロパティを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also declare properties in the context of a protocol declaration, as described in Protocol Property Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルプロパティ宣言で記述されるように、あなたはまた、プロトコル宣言の文脈において、プロパティを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also declare subscripts in the context of a protocol declaration, as described in Protocol Subscript Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル添え字宣言で記述されるように、あなたはまた、プロトコル宣言の文脈において添え字を宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、ある便宜イニシャライザを定義して、そのクラスのインスタンスを特定の使用状況のために作成したり、値型を入力することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also define custom operators that begin with a dot (.).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、１つのドット（.）で始まるあつらえの演算子を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also define functions inside the bodies of other functions, known as nested functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、他の関数の本体の内側に関数を、入れ子にされた関数として知られるものを、定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also define methods that are called on the type itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、型それ自体の上で呼ばれるメソッドを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also define properties that belong to the type itself, not to any one instance of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、その型のどれかひとつのインスタンスにではなく、型それ自体に属しているいくらかのプロパティを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also delegate from init to init!, although doing so will trigger an assertion if the init! initializer causes initialization to fail.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、initからinit!へ委任することができます、もっともそうすることは、init!イニシャライザが初期化失敗の原因となるならば、ある表明を引き起こすことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also initialize a dictionary with a dictionary literal, which has a similar syntax to the array literal seen earlier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、辞書リテラルで辞書を初期化することができます、それは以前に見た配列リテラルに似ている構文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also initialize a set with an array literal, as a shorthand way to write one or more values as a set collection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、１つ以上の値を集合コレクションとして書くための省略法として、集合を配列リテラルを使って初期化することができます、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also initialize an array with an array literal, which is a shorthand way to write one or more values as an array collection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた配列リテラルを使って配列を初期化することができます、それは一つ以上の値を配列コレクションとして書くための短縮形の方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also iterate over a dictionary to access its key-value pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、辞書の端から端まで繰り返して、その「キーと値」の対にアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also make the generic Stack type conform to the Container protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、総称体Stack型をContainerプロトコルに準拠させることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also modify the inherited currentSpeed property of a Bicycle instance, and query the instance’s inherited description property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、あるBicycleインスタンスの継承されたcurrentSpeedプロパティを変更することが出来ます、そしてそのインスタンスの持つ継承されたdescriptionプロパティについて問い合わせることが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also name the elements of a tuple type and use those names to refer to the values of the individual elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、タプル型の要素に名をつけることができて、それらの名前を個々の要素の値に言及するために使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also optionally define a type of value that the function will pass back as output when it is done, known as its return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、随意にその関数が実行を終えたとき出力として逆に渡す値の型、その戻り型として知られるものを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also override a subscript declaration inherited from a superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、スーパークラスから継承した添え字宣言をオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also replace a type parameter with a type argument that is itself a specialized version of a generic type (provided it satisfies the appropriate constraints and requirements).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、型パラメータを、それ自身が総称体型の特殊化版である型引数と置き換えることができます（それが適切な制約と要件を満たすという条件で）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also retrieve an iterable collection of a dictionary’s keys or values by accessing its keys and values properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、そのkeysとvaluesプロパティにアクセスすることによって、ある辞書のキーまたは値からなる、for-in文で繰り返し可能なコレクション（集まり）を取り出すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also set and modify the initial value for a stored property during initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、初期化のときに保存プロパティに対して最初の値を設定および修正することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also specify the requirement that two types be identical, using the == operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、==演算子を使用して、２つの型が同一であるという要件を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use a declaration to extend the behavior of an existing named type and to import symbols into your program that are declared elsewhere.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、ある宣言を使うことで、既存の名前付きの型の振るまいを拡張することや、どこかほかで宣言されるシンボルをあなたのプログラムへインポートすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use a raw value to find a corresponding case, if there is one, by calling the enumeration’s failable initializer, as in ExampleEnum(rawValue: 5), which returns an optional case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた生の値を使用して対応するケース節を見つけることが、もしそれが１つあるならば、列挙の持つ失敗できるイニシャライザを呼ぶことによって可能です、例えばExampleEnum(rawValue: 5)のように、それはオプショナルのケース節を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use an asterisk (*) to indicate the availability of the declaration on all of the platform names listed above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、アスタリスク（*）を使って上でリストされるプラットホーム名の全てでその宣言の有効性を指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use an implicitly unwrapped optional with optional binding, to check and unwrap its value in a single statement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、暗黙的にアンラップされるオプショナルをオプショナル束縛とともに使うことができます、一つの文でその値を確認してアンラップするためには：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use dot syntax to assign a new value to a variable property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、新しい値を変数プロパティに代入するためにドット構文を使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use optional chaining and optional binding to conditionally perform an operation on an optional expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまたオプショナル連鎖とオプショナル束縛を使って、あるオプショナルの式に関して演算を条件付きで実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use optional chaining to call a method that returns a value of optional type, and to chain on that method’s return value if needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまたオプショナル連鎖を使って、オプショナルの型の値を返すメソッドを呼び出すこと、そして必要ならば、そのメソッドの戻り値の上で連鎖することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use strings or floating-point numbers as the raw type of an enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、列挙の生の型として、文字列または浮動小数点数を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use strings to insert constants, variables, literals, and expressions into longer strings, in a process known as string interpolation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた文字列を、文字列補間として知られているやり方で、定数、変数、リテラル、および式をより長い文字列に差し入れるために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use subscript syntax to change a range of values at once, even if the replacement set of values has a different length than the range you are replacing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、添え字構文を使って、ある範囲の値を一度に変えることができます、たとえ代替の値一式があなたが置き換えている範囲と異なる長さを持つとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use subscript syntax to change the value associated with a particular key:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、添え字構文を特定のキーと結びつけられる値を変えるために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use subscript syntax to retrieve a value from the dictionary for a particular key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、添え字構文を特定のキーに対する値を辞書から取り出すために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use type casting to check whether a type conforms to a protocol, as described in Checking for Protocol Conformance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、プロトコル準拠の確認で記述されるように、その型があるプロトコルに準拠しているどうか調べるために型キャストを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also write indirect before the beginning of the enumeration, to enable indirection for all of the enumeration’s cases that need it:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、列挙の始まりの前にindirectを書くことができます、それで間接参照がその列挙のそれを必要とするケース節のすべてに可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also write the type of a dictionary in shorthand form as [Key: Value].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、辞書の型を[Key: Value]のような省略形で書くこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also write the type of an array in shorthand form as [Element].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、短縮形形式で配列の型を[Element]のように書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can append a Character value to a String variable with the String type’s append() method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、Character値をString変数にそのString型のもつappend()メソッドを使って追加することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply a declaration attribute to declarations only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、宣言属性を宣言だけに適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply multiple available attributes on a single declaration to specify the declaration’s availability on different platforms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、複数のavailable属性を単一の宣言に適用して、その宣言の有効性を異なるプラットホームに関して指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply the optional modifier only to protocols that are marked with the objc attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはoptional修飾子をobjc属性で印されるプロトコルだけに適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply type attributes to types only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、型属性を型だけに適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can assign a Residence instance to john.residence, so that it no longer has a nil value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはjohn.residenceにResidenceインスタンスを代入することができます、それによってそれはもはやnil値を持ちません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can assign a value to a constant property at any point during initialization, as long as it is set to a definite value by the time initialization finishes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それが初期化終了時にある明確な値に設定されさえするならば、ある値を初期化の間のどの時点ででも定数プロパティに割り当てることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can assign specific access levels to individual types (classes, structures, and enumerations), as well as to properties, methods, initializers, and subscripts belonging to those types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは特定のアクセス水準を個々の型（クラス、構造体、および列挙）、それだけでなくそれらの型に属しているプロパティ、メソッド、イニシャライザ、そして添え字に、個別に割り当てることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can be confident that the string you are passed will not be modified unless you modify it yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたが渡される文字列があなたが自身でそれを修正しない限り修正されないことを確信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call self.init only from within an initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、self.initをイニシャライザ内からだけ呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call the greet(person:) function multiple times with different input values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、異なる入力値を使ってgreet(person:)関数を複数回呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call the swapTwoInts(_:_:) function with two variables of type Int to swap their values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、swapTwoInts(_:_:)関数を、それらの値を交換する２つのInt型の変数で呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call this function to swap the values in two Int variables:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、２つのInt変数の値を交換するためにこの関数を呼ぶことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can chain multiple if statements together to consider additional clauses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、複数のif文を一緒につないで追加の条項を考慮することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can change the value of an existing variable to another value of a compatible type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、既存の変数の値を、別の互換性を持つ型の値に変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can check for the existence of a value in the weak reference, just like any other optional value, and you will never end up with a reference to an invalid instance that no longer exists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のあらゆるオプショナルの値と同じように、あなたは弱い参照の中の値の存在について調べることができます、そして、あなたは既に存在しない無効なインスタンスへの参照に至ることは決してありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can check that an index is valid before using it by comparing it to the array’s count property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはあるインデックスが有効なことを、それを配列のcountプロパティと比較することによって、それを使う前に確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can combine compilation conditions using the logical operators &amp;&amp;, ||, and ! and use parentheses for grouping.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、コンパイル条件を結合させることが論理演算子&amp;&amp;、||、そして!を使って可能です、そして丸括弧をグループにするのに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can combine multiple logical operators to create longer compound expressions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、より長く複雑な式をつくるために複数の論理演算子を結合することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can combine multiple protocols into a single requirement with a protocol composition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロトコル合成を使って複数のプロトコルを１つの要件に結合することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can constrain a tuple pattern to match certain kinds of tuple types by using type annotations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、型注釈を使うことによって特定の種類のタプル型にマッチするようにタプルパターンに制約を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can construct a new Matrix instance by passing an appropriate row and column count to its initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、そのイニシャライザに適切な行と列の数を渡すことによって新しいMatrixインスタンスを造ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create a new array by adding together two existing arrays with compatible types with the addition operator (+).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、互換性を持つ型の２つの既存の配列を加算演算子（+）を使って一緒に加えることによって、新しい配列をつくることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create an array that holds Int values, or an array that holds String values, or indeed an array for any other type that can be created in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、Int値を保持する配列、またはString値を保持する配列、またはそれどころかスウィフトで作成可能なあらゆる他の型のためにも配列をつくることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create an empty array of a certain type using initializer syntax:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、特定の型の空の配列をイニシャライザ構文を使って作成できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create an empty set of a certain type using initializer syntax:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは特定の型の空の集合を初期化構文を使って作成することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create an instance of the Player class for a new player, and see what happens when the player completes level one:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、新しいプレーヤーのためにPlayerクラスのインスタンスをつくることができて、そのプレーヤーがレベル１を完了するとき、何が起こるか見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create and print an HTMLElement instance as before:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、HTMLElementインスタンスを前の通り作成して出力することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create multidimensional arrays by nesting pairs of square brackets, where the name of the base type of the elements is contained in the innermost pair of square brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、角括弧の対を入れにすることによって多次元配列をつくることができます、そこで要素の基本型の名前は最も内側の角括弧の対の中に含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create tuples from any permutation of types, and they can contain as many different types as you like.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、いろいろな型をどんな順列にしてタプルを作っても構いません、そして、それらはあなたが望むだけ多くの異なる型を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can customize the initialization process with input parameters and optional property types, or by assigning constant properties during initialization, as described in the following sections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、以下の節で記述されるように、入力パラメータとオプショナルプロパティ型を使って、または初期化の間に定数プロパティを割り当てることによって、初期化処理を目的に合わせて作り変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can declare and implement your own custom operators in addition to the standard operators provided by Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、スウィフトによって提供される標準の演算子に加えて、あなた独自のあつらえの演算子を宣言して実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can declare multiple constants or multiple variables on a single line, separated by commas:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは複数の定数または複数の変数を、コンマで区切ることで一つの行に宣言することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can declare operators of three different fixities: infix, prefix, and postfix.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、３つの異なる定着性の演算子を宣言することができます：接中辞、接頭辞、そして接尾辞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can decompose the tuple into temporary constants or variables as part of the iteration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、繰り返しの一部としてそのタプルを一時的な定数または変数に分解することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define optional requirements for protocols, These requirements do not have to be implemented by types that conform to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはプロトコルのためにオプショナルの要件を定義することができます。 それらの要件は、そのプロトコルに準拠する型によって実装されることは必要ではありません。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define Swift enumerations to store associated values of any given type, and the value types can be different for each case of the enumeration if needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはスウィフト列挙を、どんな与えられた型の関連値でも保存するように定義することができます、そして値の型は列挙のケース節それぞれで異なっていることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define a default value for any parameter in a function by assigning a value to the parameter after that parameter’s type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある関数のすべてのパラメータに対して省略時の値を定義することが、そのパラメーターの型の後でパラメーターに値を割り当てることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define a common set of related cases as part of one enumeration, each of which has a different set of values of appropriate types associated with it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、１つの列挙の一部として、関連したケース節のよくある集合を定義することができます、そのそれぞれはそれと結びつけられる適切な型の値の集合をそれぞれ別に持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある便宜イニシャライザを定義して、同じクラスからある指定イニシャライザをその便宜イニシャライザとして呼び出し、その指定イニシャライザのパラメータのいくつかを省略時の値に設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define anything from a simple utility function with a single unnamed parameter to a complex function with expressive parameter names and different parameter options.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ただ一つの無名のパラメータを持つ単純で便利な支援関数から、表現豊かなパラメータ名と種々のパラメータ・オプションを持つ複雑な関数まで何でも定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define multiple related variables of the same type on a single line, separated by commas, with a single type annotation after the final variable name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは同じ型の複数の関連した変数を、１行上に、コンマで区切って、型注釈を１つだけ最後の変数名の後につけて、定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define multiple subscripts for a single type, and the appropriate subscript overload to use is selected based on the type of index value you pass to the subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは一つの型のために複数の添え字を定義することができます、そしてあなたが添え字に渡すインデックス値の型に基づいて、使うのに適切な添え字のオーバーロードが選択されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define your own type constraints when creating custom generic types, and these constraints provide much of the power of generic programming.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、独自の型制約をあつらえの総称体型を作成する時に定義することができます、そして、それらの制約は総称体プログラミングの力の多くを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can delegate from init? to init! and vice versa, and you can override init? with init! and vice versa.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、init?からinit!への委任およびその逆が行えます、そしてあなたはinit?をinit!でオーバーライドすること、およびその逆もできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can do this even if that method does not define a return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえそのメソッドが戻り値を定義しないとしても、あなたはこれをすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can drill down into sub-properties, such as the width property in the resolution property of a VideoMode:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、下位プロパティへと掘り下っていくことができます、例えば、あるVideoModeのresolutionプロパティの中のwidthプロパティ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can efficiently perform fundamental set operations, such as combining two sets together, determining which values two sets have in common, or determining whether two sets contain all, some, or none of the same values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは効率的に基本的な集合演算を実行することができます、例えば２つの集合を１つに結合する、２つの集合が共通して持つ値はどれか決定する、または２つの集合が同じ値のすべて、いくつか、または全く含まないかどうかを決定するなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend a class, structure, or enumeration in any access context in which the class, structure, or enumeration is available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるクラス、構造体、または列挙を拡張することが、そこにおいてそのクラス、構造体、または列挙が利用可能であるあらゆるアクセス文脈において可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend an existing type to add conformance to a protocol, as described in Adding Protocol Conformance with an Extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、拡張を使ってプロトコル準拠を加えるで記述されるように、既存の型を拡張することでプロトコルへの準拠を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend an existing type to adopt and conform to a new protocol, even if you do not have access to the source code for the existing type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある新しいプロトコルを採用して準拠することで既存の型を拡張することができます、たとえあなたが既存の型のソース・コードにアクセスをしないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend the Rect structure to provide an additional initializer that takes a specific center point and size:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、Rect構造体を拡張して、特定の中心点と大きさをとる追加のイニシャライザを提供することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend the behavior of a class type with an extension declaration, as discussed in Extension Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはクラス型の挙動を拡張宣言を使って拡張することができます、拡張宣言で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend the behavior of a structure type with an extension declaration, as discussed in Extension Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは構造体型の挙動を拡張宣言を使って拡張することができます、拡張宣言で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend the behavior of an enumeration type with an extension declaration, as discussed in Extension Declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは列挙型の挙動を拡張宣言を使って拡張することができます、拡張宣言で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can fit two 4s inside 9, and the remainder is 1 (shown in orange).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは２つの4を9の内部に収めることができます、そして余りは1です（オレンジ色で示されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can give a setter a lower access level than its corresponding getter, to restrict the read-write scope of that variable, property, or subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、セッターにその対応するゲッターよりもより低いアクセス水準を与えて、その変数、プロパティ、または添え字の読み書きのスコープを制限することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can implement a protocol initializer requirement on a conforming class as either a designated initializer or a convenience initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、イニシャライザ要件プロトコルを準拠クラス上で指定イニシャライザまたは便宜イニシャライザとして実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can include as many optional bindings and Boolean conditions in a single if statement as you need to, separated by commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、単一のif文の中に、コンマで区切ったオプショナル束縛とブール条件をあなたが必要とするだけ多く含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can include predefined String values within your code as string literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あらかじめ定義されたString値を文字列リテラルとしてあなたのコードの内部に含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can initialize the Rect structure below in one of three ways—by using its default zero-initialized origin and size property values, by providing a specific origin point and size, or by providing a specific center point and size.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、以下のRect構造体を３つの方法のうちの１つで初期化することができます ― それの省略時の０で初期化されたoriginとsizeプロパティ値を使うことによって、特定の原点とサイズを提供することによって、または特定の中心点とサイズを提供することによって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can iterate over the entire set of values in an array with the for-in loop:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、for-inループを使って配列中の値ひとそろい全部に渡って繰り返すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can iterate over the key-value pairs in a dictionary with a for-in loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、for-inループを使って、ある辞書の中の「キーと値」のすべてに対して操作を繰り返し適用していくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can iterate over the string with a for-in statement, to access its individual Character values as Unicode extended grapheme clusters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは文字列の全体にわたってfor-in文を使って繰り返すことができます、それでユニコードの拡張書記素クラスタとしてのそれの個々のCharacter値にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can iterate over the values in a set with a for-in loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは集合の中の値すべてに渡って繰り返しすることがfor-inループによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can keep an index in a loop by using ..&lt; to make a range of indexes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、インデックス（索引）をループにおいて保持することが、..&lt;を使ってインデックスの範囲を作ることで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can limit protocol adoption to class types (and not structures or enumerations) by adding the class keyword to a protocol’s inheritance list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロトコル採用をクラス型に制限する（そして構造体や列挙で採用しない）ことがclassキーワードをプロトコルの継承リストに加えることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can link together multiple levels of optional chaining to drill down to properties, methods, and subscripts deeper within a model.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、オプショナル連鎖の複数の階層を結びつけて、あるモデル内のより深いプロパティ、メソッド、そして添え字に掘り下げていくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can list as many protocols as you need to, separating them by ampersands (&amp;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたが必要とするだけの多くのプロトコルを、アンパサンド（&amp;）でそれらを隔てて並べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can make generic forms of functions and methods, as well as classes, enumerations, and structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは関数やメソッドだけでなく、クラス、列挙、そして構造体も総称体の形式にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can make the structure’s numberOfEdits property getter public, and its property setter private, by combining the public and private(set) access-level modifiers:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、この構造体のnumberOfEditsプロパティゲッターを公開に、そしてそれのプロパティセッターを非公開にすることが、publicとprivate(set)アクセス水準修飾子を組み合わせることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can mark a declaration with one of the access-level modifiers below to specify the declaration’s access level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、宣言を以下のアクセス水準修飾子のうちの１つで印して、その宣言のアクセス水準を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can mark an entire class as final by writing the final modifier before the class keyword in its class definition (final class).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、そのクラス定義においてclassキーワードの前にfinal修飾子を書くことによって（final class）、そのクラス全体を最終版として印することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can mark designated and convenience initializers with the required declaration modifier to require that every subclass implement the initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは指定および便宜イニシャライザをrequired宣言修飾子で印して、全てのサブクラスがそのイニシャライザを実装することが必須であるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can match individual enumeration values with a switch statement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、switch文を使って個々の列挙値を照合することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can name the individual elements in a tuple when the tuple is defined:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、タプルの個々の要素に名前をつけることが、そのタプルが定義される時に可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can name the parameter or use the default parameter name of oldValue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはパラメータに名をつけること、または省略時のパラメータ名のoldValueを使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can nest labeled statements, but the name of each statement label must be unique.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはラベルをつけられた文を入れ子にすることができます、しかし、各文ラベルの名前は特有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now call the assigned function with the name mathFunction:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、今や、代入された関数を名前mathFunctionを使って呼ぶことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now create a Customer instance, and use it to initialize and assign a new CreditCard instance as that customer’s card property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、現在Customerインスタンスを作成して、それを使って、新しいCreditCardインスタンスを、その顧客のcardプロパティとして初期化して代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now create a new Person instance and assign it to one of these three variables:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、いま新しいPersonインスタンスを作成して、それをこれらの３つの変数のうちの１つに代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now create a specific Person instance and Apartment instance and assign these new instances to the john and unit4A variables:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、今や特定のPersonインスタンスとApartmentインスタンスを作成して、それらの新しいインスタンスをjohnおよびunit4A変数に代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now link the two instances together so that the person has an apartment, and the apartment has a tenant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは次に人がアパートを持つように、２つのインスタンスを結びつけることができます、するとアパートには賃借人があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now try to set a property’s value, assign to a subscript, or call a mutating method or operator through Optional Chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは今ではオプショナル連鎖を通して、プロパティの値を設定する、ある添え字に代入する、または可変メソッドまたは演算子を呼び出すことを試みることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now use chooseStepFunction(backward:) to obtain a function that will step in one direction or the other:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在あなたはchooseStepFunction(backward:)を使って、ある方向にまたはもう一方に進む関数を取得できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now use the numbers array to create an array of String values, by passing a closure expression to the array’s map(_:) method as a trailing closure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、現在、このnumbers配列をString値の配列をつくるために使うことが、あるクロージャ式を配列のmap(_:)メソッドに後付クロージャとして渡すことによって、可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now use these operators to check whether two Vector2D instances are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、現在２つのVector2Dインスタンスが等しいかどうか調べるために、これらの演算子を使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can only pass a variable as the argument for an in-out parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、in-outパラメータに対する引数として、変数を渡すことだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can opt in to this behavior by placing the mutating keyword before the func keyword for that method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、そのメソッドのためのfuncキーワードの前にmutatingキーワードを置くことによってこの挙動を取り入れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can opt in to value overflow behavior by using Swift’s overflow operators (such as a &amp;+ b).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、スウィフトのオーバフロー演算子を使用することによって、値オーバフロー挙動を選ぶことが可能です（例えばa &amp;+ bのように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can opt in to value overflow behavior by using Swift’s overflow operators, as described in Overflow Operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー演算子で記述されるように、あなたは、スウィフトのもつオーバフロー演算子を使うことによって、値オーバフロー挙動を選ぶことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can overload a generic function or initializer by providing different constraints, requirements, or both on the type parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、総称体の関数やイニシャライザをオーバーロードすることが、異なる制約、要件、または両方を型パラメータ上で提供することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can overload a subscript declaration in the type in which it is declared, as long as the parameters or the return type differ from the one you’re overloading.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある添え字宣言を、そこにおいてそれが宣言される型においてオーバーロードすることができます、パラメーターまたは戻り型があなたがオーバーロードしているものと異なる限りはです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can overload the ~= operator to provide custom expression matching behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、~=演算子をオーバーロードして、あつらえの式マッチング挙動を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override a failable initializer with a nonfailable initializer but not the other way around.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは失敗できるイニシャライザを、失敗できないイニシャライザでオーバーライドできます、しかし逆はできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override a nonreturning method, but the new method must preserve its return type and nonreturning behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは非復帰メソッドをオーバーライドすることができます、しかし新しいメソッドはそれの戻り型と非復帰挙動を維持しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override a property in a subclass by marking the subclass’s property declaration with the override declaration modifier, as described in Overriding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、オーバーライドで記述されるように、、サブクラスのプロパティ宣言をoverride宣言修飾子で印することによってサブクラスの中のプロパティをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override a superclass failable initializer in a subclass, just like any other initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、スーパークラスの失敗できるイニシャライザをサブクラスにおいてオーバーライドすることが、何らかの他のイニシャライザとまったく同じようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override an inherited instance or type method to provide a tailored or alternative implementation of the method within your subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある継承されたインスタンスまたは型メソッドをオーバーライドすることで、あなたのサブクラス内部でそのメソッドの特注のまたは代替の実装を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override an inherited instance or type property to provide your own custom getter and setter for that property, or to add property observers to enable the overriding property to observe when the underlying property value changes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは継承されたインスタンスまたは型プロパティをオーバーライドして、そのプロパティのためにあなた独自のあつらえのゲッターとセッターを用意したり、根底にあるプロパティ値がいつ変化するか監視することをオーバーライドしているプロパティに可能にするプロパティオブザーバーを加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override the default behavior for argument labels with one of the following forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは引数ラベルに対する初期状態の挙動をオーバーライドすることが以下の形式の１つで可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override this default behavior by marking the declaration with an access-level modifier, as described in Access Control Levels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、アクセス制御ラベルで記述されるように、この初期状態のふるまいをその宣言をアクセス水準修飾子で印することによってオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pass a value of any conforming type in to this parameter when initializing a new Dice instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいDiceインスタンスを初期化するとき、あなたはどんな準拠型の値でもこのパラメータに渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pass any function of that type as the argument for this first parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、この最初のパラメータに対する引数として、その型のどんな関数でも渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can prefix a loop statement, an if statement, a switch statement, or a do statement with a statement label, which consists of the name of the label followed immediately by a colon (:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはループ文、if文、switch文、またはdo文の前に文ラベルを置くことができます、それは、ラベルの名前とそれに直ちに続くコロン（:）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのサブクラスプロパティオーバーライドにおいてゲッターとセッターの両方を提供することによって、あなたは継承された読み出し専用のプロパティを、読み書き両用のプロパティとして提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can prevent a method, property, or subscript from being overridden by marking it as final.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはメソッド、プロパティ、または添え字がオーバーライドされるのを、それを最終版（final）と印することによって妨げることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can print the current value of a constant or variable with the print(_:separator:terminator:) function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、print(_:separator:terminator:)関数で定数または変数の現在の値を出力することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can propagate the error from a function to the code that calls that function, handle the error using a do-catch statement, handle the error as an optional value, or assert that the error will not occur.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、エラーを関数からその関数を呼び出しているコードに伝えて、そのエラーをdo-catch文を使って取り扱う、エラーをオプショナルとして取り扱う、またはそのエラーは起こらないことを表明することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide initialization parameters as part of an initializer’s definition, to define the types and names of values that customize the initialization process.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、イニシャライザの定義の一部として初期化パラメータを提供することができます、それによって初期化処理をカスタマイズする値の型と名前を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide a type annotation when you declare a constant or variable, to be clear about the kind of values the constant or variable can store.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたが定数または変数を宣言するとき、その定数または変数が保存することができる値の種類について明確にするために、型注釈を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide a custom getter (and setter, if appropriate) to override any inherited property, regardless of whether the inherited property is implemented as a stored or computed property at source.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あつらえののゲッターを（そして適切ならば、セッターも）提供することで、あらゆる継承されたプロパティをオーバーライドできます、継承されたプロパティがその発生源で保存プロパティもしくは計算プロパティとして実装されるかは関係しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide a default value for a stored property as part of its definition, as described in Default Property Values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のプロパティ値で記述されるように、あなたは保存プロパティのために省略時の値をその定義の一部として用意することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide an explicit name in parentheses after set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、setの後に括弧の中ではっきりとした名前を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide more than one type parameter by writing multiple type parameter names within the angle brackets, separated by commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、山形括弧内に複数の型パラメータ名をコンマで区切って書くことによって、複数の型パラメータを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide multiple catch blocks that handle specific errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それぞれが特定のエラーを取り扱う複数のcatchブロックを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can query the threeTimesTable instance by calling its subscript, as shown in the call to threeTimesTable[6].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、threeTimesTableインスタンスにその添え字を呼ぶことによって問い合わせることがthreeTimesTable[6]への呼び出しで示されるように可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can read this code as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、このコードを次のように読むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can refer to parameters by number instead of by name—this approach is especially useful in very short closures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、名前によってでなく、数によってパラメータに言及することができます ― この取り組み方は、特に非常に短いクロージャで役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can remove an item from a set by calling the set’s remove(_:) method, which removes the item if it’s a member of the set, and returns the removed value, or returns nil if the set did not contain it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはある項目を集合から取り除くことが集合のremove(_:)メソッドを呼ぶことによって行えます、それは、その項目をそれが集合のメンバーであるならば取り除きます、そして取り除かれた項目を返します、または集合がそれを含まないならばnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can revise the SurveyQuestion example from above to use a constant property rather than a variable property for the text property of the question, to indicate that the question does not change once an instance of SurveyQuestion is created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、上記のSurveyQuestion例を、変数プロパティではなく定数プロパティを質問のtextプロパティのために使うように見直して、その質問は一旦SurveyQuestionのインスタンスが作成されるならば変化しないことを示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can rewrite the TemperatureUnit example from above to use raw values of type Character and to take advantage of the init?(rawValue:) initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、上のTemperatureUnit例をCharacter型の生の値を使うように、そしてinit?(rawValue:)イニシャライザを活用するように書き直すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can rewrite the chooseStepFunction(backward:) example above to use and return nested functions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、入れ子にされた関数を使用して返すように、上記のchooseStepFunction(backward:)の例を書き直すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can rewrite the possibleNumber example from the Optionals section to use optional binding rather than forced unwrapping:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはオプショナル節のpossibleNumber例を、強制アンラップではなくて、オプショナル束縛を使うように書き直すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set a constant or variable to Planet.earth, and check for this value later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、定数または変数をPlanet.earthに設定することができて、後でその値について調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set a value in a dictionary by providing a key of the dictionary’s key type within subscript brackets, and assigning a value of the dictionary’s value type to the subscript:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、添え字角括弧内にその辞書のキー型のキーを提供し、そしてその添え字に辞書の値型の値を代入することによって、値を辞書に設定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set an initial value for a stored property within an initializer, or by assigning a default property value as part of the property’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、イニシャライザの内部で、またはそのプロパティの定義の一部として省略時のプロパティの値を代入することによって、保存プロパティのために初期値を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set the hasBasket property to true for a particular Bicycle instance after that instance is created:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、特定のBicycleインスタンスに対してhasBasketプロパティをtrueに設定することが、そのインスタンスを作成した後で行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set the initial value of a stored property from within an initializer, as shown above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはイニシャライザ内から保存プロパティの初期値を設定することが、上で示されるように、行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can simplify the declaration of a read-only computed property by removing the get keyword and its braces:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、読み出し専用の計算プロパティの宣言をgetキーワードとそれの波括弧を取り除くことによって単純化することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify a name for this parameter as part of your willSet implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたのwillSet実装の一部としてこのパラメータに名前を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify a type annotation for these patterns to constrain them to match only values of a certain type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは型注釈をこれらのパターンに指定して、それらがある特定の型の値だけにマッチするように制約を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify additional requirements on type parameters and their associated types by including a generic where clause right before the opening curly brace of a type or function’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、追加の要件を型パラメータおよびそれの関連型に指定することが総称体where節を型または関数の本文の開き波括弧のまさに前に含めることによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can still treat an implicitly unwrapped optional like a normal optional, to check if it contains a value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは依然として暗黙的にアンラップされるオプショナルを通常のオプショナルのように扱うことができます、それが値を含むかどうか確認するためには：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can subclass any class that can be accessed in the current access context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、現在のアクセス前後関係においてアクセスされることができるどんなクラスにでもサブクラスをつくることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can tell that the createAddress() function isn’t called, because nothing is printed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、createAddress()関数が呼ばれなかったと言うことができます、なぜなら何も出力されなかったからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can therefore call the allItemsMatch(_:_:) function with these two containers as its arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、したがって、allItemsMatch(_:_:)関数をその引数としてこれらの２つのコンテナを使って呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of an implicitly unwrapped optional as giving permission for the optional to be unwrapped automatically whenever it is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは暗黙的にアンラップされるオプショナルを、それが使われるときはいつでも自動的にアンラップされる許可をそのオプショナルに与えていると考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of the associated values as behaving like stored properties of the enumeration case instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはそれら関連値を、その列挙ケース節インスタンスに属する保存プロパティのように振る舞うものとして考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use if and let together to work with values that might be missing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ifとletを一緒に使って、見つからないかもしれない値を扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use defer to write setup and cleanup code next to each other, even though they need to be executed at different times.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、deferを使うことでセットアップおよびクリーンアップコードを隣り合わせに書くことができます、たとえそれらが異なる時に実行される必要があるにしても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a defer statement even when no error handling code is involved.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、defer文を使うことが、エラー処理コードを伴わない時でさえも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a type(of:) expression with an instance of a type to access that instance’s dynamic, runtime type as a value, as the following example shows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある型のインスタンスでtype(of:)式を使うことで、値としてそのインスタンスの動的な、実行時型にアクセスできます、以下の例が示すように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a capture list to explicitly control how values are captured in a closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはキャプチャリストを使って、どのようにあるクロージャにおいて値がキャプチャされるかを明示的に制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a failable initializer to select an appropriate enumeration case based on one or more parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、失敗できるイニシャライザを使って適切な列挙ケース節を１つ以上のパラメータに基づいて選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a function type as the return type of another function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある関数型をそれとは違う関数の戻り型として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a function type such as (Int, Int) -&gt; Int as a parameter type for another function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある関数型、例えば(Int, Int) -&gt; Intを、別の関数のためのパラメータ型として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a protocol name just like any other named type—for example, to create a collection of objects that have different types but that all conform to a single protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、何かほかの名前付きの型のようにプロトコル名を使用することができます ― 例えば、それぞれ異なる型を持つが全てがただ１つのプロトコルに準拠するオブジェクトたちのコレクションをつくるためなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a set instead of an array when the order of items is not important, or when you need to ensure that an item only appears once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、項目の順番が重要でないときに、またはあなたがひとつの項目がただ一度だけ現れることを確実にする必要があるときに、配列の代わりに集合を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a tuple to return multiple values from a function as a single compound value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはタプルを使って、関数から複数の値を一つの混成値として返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a tuple type as the return type for a function to return multiple values as part of one compound return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、関数の戻り型としてタプル型を使って、複数の値をひとつの複合の戻り値の一部として返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a tuple type as the return type of a function to enable the function to return a single tuple containing multiple values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、関数の戻り型としてタプル型を使って、その関数に複数の値を含んでいる一つのタプルを返すのを可能にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use all three of the inherited initializers to create a new ShoppingListItem instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、継承されたイニシャライザの３つ全てを新しいShoppingListItemインスタンスをつくるために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use an if statement to find out whether an optional contains a value by comparing the optional against nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、if文を、あるオプショナルが値を含むかどうか知るために使うことができます、それは、そのオプショナルをnilと比べることによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use an empty dictionary literal to create an empty dictionary literal of specified key and value types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、空の辞書リテラルを使って、指定されたキーと値型の空の辞書リテラルを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use an extension to add protocol conformance to a type that is declared elsewhere, or even to a type that you imported from a library or framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは１つの拡張を使用することで、どこかほかで宣言される型に、またはあなたがライブラリやフレームワークからインポートした型にさえもプロトコル準拠を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use an instance of ThreeSource as the data source for a new Counter instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ThreeSourceのインスタンスを新しいCounterインスタンスのためのデータ・ソースとして使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use an instance of TowardsZeroSource with the existing Counter instance to count from -4 to zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、TowardsZeroSourceのインスタンスを既存のCounterインスタンスとともに使って、-4からゼロへと数えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use bit shifting to encode and decode values within other data types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、他のデータ型内の値を符号化したり復号するために、ビットシフトを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use both classes and structures to define custom data types to use as the building blocks of your program’s code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたのプログラムのコードの建築ブロックとして使う特別あつらえのデータ型を定義するために、クラスと構造体のどちらでも使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use both constants and variables with optional binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、定数と変数の両方をオプショナル束縛で使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use forced unwrapping in an initializer to call a failable initializer from the superclass as part of the implementation of a subclass’s nonfailable initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、強制アンラップをイニシャライザの中で使うことで、失敗できるイニシャライザをスーパークラスから呼び出し、サブクラスの失敗できないイニシャライザの実装の一部とすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use nested functions to organize the code in a function that is long or complex.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、長いか複雑である関数においてコードを組織するために、入れ子にされた関数を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use optional binding to check whether this version of the minMax(array:) function returns an actual tuple value or nil:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、minMax(array:)関数のこの改作が返すのは本当のタプルなのかまたはnilなのかを調べるためにオプショナル束縛を使うことが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use optional chaining to call a method on an optional value, and to check whether that method call is successful.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはオプショナル連鎖を使って、オプショナルの値の上でメソッドを呼んで、そしてそのメソッド呼び出しが成功しているかどうか調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use optional chaining to try to retrieve and set a value from a subscript on an optional value, and to check whether that subscript call is successful.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、オプショナル連鎖を使って、あるオプショナルの値上の添え字から値を取り出したり設定したりすること、そしてその添え字がうまく呼び出されるかどうかを調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use optional chaining with calls to properties, methods, and subscripts that are more than one level deep.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、深さ１階層以上であるプロパティ、メソッド、そして添え字への呼び出しでオプショナル連鎖を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use parentheses to specify the precedence of operations by explicitly grouping expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは丸括弧を使って、明示的にいくらかの式をグループにまとめることによって演算の優先順位を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use property overriding to add property observers to an inherited property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロパティをオーバーライドすることを継承されたプロパティにプロパティオブザーバーを追加するために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use protocol extensions to provide a default implementation to any method or computed property requirement of that protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはプロトコル拡張を使うことで省略時の実装をそのプロトコルのどのメソッドまたは計算プロパティ要件に対しても提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use protocols to declare which methods a delegate of a class or structure should implement, as described in Delegation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはプロトコルを使って、あるクラスまたは構造体から委任を受ける側が実装しなければならないのはどのメソッドかを宣言することができます、委任で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use subscript syntax to access the Character at a particular String index.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、添え字構文を使うことで特定のStringインデックス位置でのCharacterへアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use subscript syntax to change an existing value at a given index:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、添え字構文を使って、与えられたインデックス位置にある既存の値を変えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use subscript syntax to remove a key-value pair from a dictionary by assigning a value of nil for that key:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは添え字構文を、そのキーに対してnilの値を代入することによって、辞書からある「キーと値」の対を削除するために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the AudioChannel structure to create two new audio channels called leftChannel and rightChannel, to represent the audio levels of a stereo sound system:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、AudioChannel構造体を、leftChannelとrightChannelと呼ばれる２つの新しい音声チャンネルをつくるために使用して、ステレオ・オーディオ・システムの音声のレベルを表すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the hasPrefix(_:) method with the romeoAndJuliet array to count the number of scenes in Act 1 of the play:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、劇の「一幕（Act 1）」の場面の数を数えるためにhasPrefix(_:)メソッドをromeoAndJuliet配列で使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the is and as operators described in Type Casting to check for protocol conformance, and to cast to a specific protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、型キャストで記述されるisとas演算子を特定のプロトコルへキャストするために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the renamed argument in conjunction with the unavailable argument and a type alias declaration to indicate to clients of your code that a declaration has been renamed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、renamed引数をunavailable引数および型エイリアス宣言と連携して使うことで、あなたのコードのクライアントに宣言が改名されたを指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the startIndex and endIndex properties and the index(before:), index(after:), and index(_:offsetBy:) methods on any type that conforms to the Collection protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、startIndexとendIndexプロパティそしてindex(before:)、index(after:)、およびindex(_:offsetBy:)メソッドをCollectionプロトコルに準拠するあらゆる型で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the rawValue property to access the raw value of an enumeration case, as in ExampleEnum.B.rawValue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、このrawValueプロパティを使って列挙ケース節の生の値にアクセスすることができます、例えばExampleEnum.B.rawValueのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the abbreviated form anytime the value’s type is already known.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、値の型がすでに知られているときはいつでも省略形を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the postfix self expression to access a type as a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、接尾辞self式を使って、ある型に値としてアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the the insert(_:at:), insert(contentsOf:at:), remove(at:), and removeSubrange(_:) methods on any type that conforms to the RangeReplaceableCollection protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、insert(_:at:)、insert(contentsOf:at:)、remove(at:)、そしてremoveSubrange(_:)メソッドをRangeReplaceableCollectionプロトコルに準拠するあらゆる型で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this argument to name classes, enumerations, enumeration cases, protocols, methods, getters, setters, and initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこの引数を、クラス、列挙、列挙ケース、プロトコル、メソッド、ゲッター、セッター、そしてイニシャライザに名前をつけるために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this failable initializer to choose an appropriate enumeration case for the three possible states and to cause initialization to fail if the parameter does not match one of these states:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、この失敗できるイニシャライザを使って、適切な列挙ケース節を３つの可能な状態に対して選び取るように、そしてパラメータが３つの状態の内の１つに合わない場合に初期化が失敗するようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this failable initializer to try to initialize a new Animal instance and to check if initialization succeeded:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、この失敗できるイニシャライザを使うことで、新しいAnimalインスタンスを初期化することを試みて、初期化が成功したか確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this initializer to initialize a new constant called theAceOfSpades:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、theAceOfSpadesと呼ばれる新しい定数を初期化するために、このイニシャライザを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this initializer to try to create a new instance of the enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、このイニシャライザを使って、この列挙の新しいインスタンスを作成するように試みることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this optional return value to check whether the optional chaining call was successful (the returned optional contains a value), or did not succeed due to a nil value in the chain (the returned optional value is nil).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、このオプショナルの戻り値を使って、オプショナル連鎖呼び出しが成功した（返されたオプショナルが値を含む）か、あるいは連鎖の中のnil値のために成功しなかった（返されたオプショナルの値がnilである）かどうか確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this type like any other type in Swift, which makes it easy to pass functions as parameters to other functions, and to return functions from functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはスウィフトの他のあらゆる型と同じようにこの型を使うことができます、そしてそれは、他の関数へのパラメータとして関数を渡して、関数から関数を返すことを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use tuples to test multiple values in the same switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、複数の値を同じswitch文において試験するためにタプルを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use type casting with a hierarchy of classes and subclasses to check the type of a particular class instance and to cast that instance to another class within the same hierarchy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、いくつかのクラスおよびサブクラスからなるある階層とともに型キャストを使って、特定のクラスインスタンスの型を調べて、そのインスタンスを同じ階層内の別のクラスにキャストすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use your own custom types as set value types or dictionary key types by making them conform to the Hashable protocol from Swift’s standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなた独自のあつらえの型を集合の値型または辞書のキー型として使用することが、それらをスウィフトの標準ライブラリからのHashableプロトコルに適合させることで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can write a closure without a name by surrounding code with braces ({}).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、名前なしで波括弧（{}）でコードを囲むことによってクロージャを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、重複を避けて、明快な、抽象化された手法で、その意図を表すコードを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can write the Fahrenheit structure from above in a simpler form by providing a default value for its temperature property at the point that the property is declared:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、上記のFahrenheit構造体を、そのtemperatureプロパティのために省略時の値をそのプロパティが宣言される時点で用意することによって、より単純な形式で書くことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can write the same functionality as a generic function by replacing any mention of strings with values of some type T instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは同じ機能性を総称体関数として書くことが、何であれ文字列への言及部分をその代わりにある何らかの型Tの値で置き換えることで行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot add property observers to inherited constant stored properties or inherited read-only computed properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロパティオブザーバーを、継承された定数保存プロパティに、または継承された読み出し専用の計算プロパティに加えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot define a failable and a nonfailable initializer with the same parameter types and names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、失敗できる及び失敗できないイニシャライザを同じパラメータの型と名前で定義することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot pass a constant or a literal value as the argument, because constants and literals cannot be modified.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは引数として定数またはリテラル値を渡すことができません、なぜなら定数とリテラルは修正されることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot provide an explicit access-level modifier for an extension if you are using that extension to add protocol conformance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがプロトコル準拠を加えるためにその拡張を使っているならば、あなたは明確なアクセス水準修飾子を拡張のために用意することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot set a protocol requirement to a different access level than the protocol it supports.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるプロトコル要件をそれが支えるプロトコルと異なるアクセス水準に設定することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot specify a different access level for individual enumeration cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、個々の列挙ケース節に対して異なるアクセス水準を指定することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot use a private type as the raw-value type of an enumeration with an internal access level, for example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはあるprivate型を、internalのアクセス水準をもつ列挙の「生の値」型として使うことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot write a public protocol that inherits from an internal protocol, for example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、例えば、内部のプロトコルから継承する公開のプロトコルを書くことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot, however, present an inherited read-write property as a read-only property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、しかし、継承された読み書き両用プロパティを、読み出し専用のプロパティとして提示することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t append a String or Character to an existing Character variable, because a Character value must contain a single character only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはStringまたはCharacterを既存のCharacter変数に追加することはできません、なぜならCharacter値がただ一つの文字だけを含まなければならないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t mark a variadic parameter or a return type with the inout keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、可変長パラメータまたは戻り型にinoutキーワードで印をつけることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t overload a function based only on whether the function can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはある関数を、その関数がエラーをスローできるかどうかのみに基づいてオーバーロードできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t pass in any type here, however—it has to be a type for which UInt16 provides an initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、あなたはあらゆる型をここに渡すことはできません ― それはUInt16がイニシャライザを提供する型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t pass the same argument to multiple in-out parameters because the order in which the copies are written back is not well defined, which means the final value of the original would also not be well defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、同じ引数を複数のin-outパラメータに渡すことができません、なぜならコピーが書き戻される順番はうまく定義されないからです、それはオリジナルの最終的な値もまたうまく定義されないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t use an unlabeled break statement to break out of an if statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ラベルを付けられないbreak文をif文を脱するために使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t use subscript syntax to append a new item to the end of an array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、添え字構文を使って配列の終わりに新しい項目を追加することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You check for an implementation of an optional method by writing a question mark after the name of the method when it is called, such as someOptionalMethod?(someArgument).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それが呼ばれるときに疑問符をそのメソッドの後に書くことによって、あるオプショナルメソッドの実装について確認することができます、例えばsomeOptionalMethod?(someArgument)のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You create a new Stack instance by writing the type to be stored in the stack within angle brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、新しいStackインスタンスを、角括弧の内側にそのスタックの中に格納される型を書くことによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You create a new instance of Vehicle with initializer syntax, which is written as a TypeName followed by empty parentheses:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、Vehicleの新しいインスタンスを初期化構文を使って作成します、それは１つのTypeNameに続く空の丸括弧として書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You declare constants with the let keyword and variables with the var keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、letキーワードを使って定数を、varキーワードを使って変数を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You define properties and methods to add functionality to your classes and structures by using exactly the same syntax as for constants, variables, and functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、機能性をあなたのクラスおよび構造体に加えるためにプロパティとメソッドを定義します、それには、定数、変数、そして関数に対するのとまったく同じ構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You define protocols in a very similar way to classes, structures, and enumerations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、クラス、構造体、および列挙と非常に類似した方法で、プロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You define this form of a variable declaration at global scope, the local scope of a function, or in the context of a class or structure declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、変数宣言のこの形式を、グローバルなスコープ、関数のローカルなスコープで、またはクラスおよび構造体宣言の文脈において定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You define this form of a variable declaration at global scope, the local scope of a function, or in the context of a class, structure, enumeration, or extension declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、変数宣言のこの形式を、グローバルなスコープ、関数のローカルなスコープで、またはクラス、構造体、列挙、および拡張宣言の文脈において定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You define type aliases with the typealias keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、typealiasキーワードで型エイリアスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You define type properties with the static keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、型プロパティをstaticキーワードを使って定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたがある継承されたイニシャライザの要件を満たすことができるならば、必須イニシャライザの明示的な実装を提供する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not have to provide convenience initializers if your class does not require them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのクラスがそれらを必要としないならば、あなたは便宜イニシャライザを提供する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not need to mark protocol initializer implementations with the required modifier on classes that are marked with the final modifier, because final classes cannot be subclassed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはfinal修飾子で印されるクラス上でプロトコルイニシャライザ実装をrequired修飾子で印する必要はありません、なぜなら、finalクラスはサブクラスを作られることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not need to specify the type of the closure’s input parameter, number, because the type can be inferred from the values in the array to be mapped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはクロージャの入力パラメータ、numberの型を指定する必要がありません、なぜならその型が対応付けされる配列の値から推論されることができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not specify a precedence when defining a prefix or postfix operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、接頭辞または接尾辞演算子を定義するときに優先順位を指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not write the override modifier when overriding a required designated initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、必須指定イニシャライザをオーバーライドする時にoverride修飾子を書きません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do this by defining a generic where clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこれを総称体where節を定義する事によって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do this by writing a complete function type immediately after the return arrow (-&gt;) of the returning function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、返すことになる関数の戻り矢印（-&gt;）の直後に完全な関数型を書くことによってこれをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do this by writing the break statement as the entire body of the case you want to ignore.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、break文をあなたが無視したいケース節の全本文として書くことによってこれをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do this with an empty extension, as described in Declaring Protocol Adoption with an Extension:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張を使ってプロトコル採用を宣言するで記述されるように、あなたは空の拡張でこれを行います</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don’t know in advance which actual class to use for each item, and so it is appropriate to use the conditional form of the type cast operator (as?) to check the downcast each time through the loop:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、前もって、各項目のために使われる実際のクラスがどれかを知りません、なので適切なのは、型キャスト演算子の条件形式（as?）を使用してループを通して毎回ダウンキャストを確認することです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don’t need to define property observers for nonoverridden computed properties, because you can observe and respond to changes to their value in the computed property’s setter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、オーバーライドされていない計算プロパティのためにプロパティオブザーバーを定義する必要はありません、なぜならあなたは計算プロパティのセッターにおいてそれらの値の変化を観察して応答することができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don’t need to import a separate library for functionality like input/output or string handling.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、入力／出力または文字列取り扱いのような機能性のために個々のライブラリをインポートする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You extract each associated value as a constant (with the let prefix) or a variable (with the var prefix) for use within the switch case’s body:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、関連値それぞれを定数（let接頭辞を使って）または変数（var接頭辞を使って）としてswitchのケース節の本文内で使用するために抽出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You get the same behavior of delayed evaluation when you pass a closure as an argument to a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが同じ挙動の延期した評価を得るのは、あなたがクロージャを引数として関数に渡す時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは関数にそれが何をするかについて識別する名前を与えます、そしてこの名前が必要なときその作業を実行するために関数を「呼び出す」のに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have access to the type parameters (and any of their associated types) in the rest of the type, function, or initializer declaration, including in the signature of the function or initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、そのままの型、関数、またはイニシャライザ宣言の中の、さらに含めて関数またはイニシャライザのシグネチャの中の、型パラメータ（およびあらゆるそれの関連型）にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have several options for writing closures more concisely.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、より簡潔にクロージャを書くためにいくつかの選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have the option to define either or both of these observers on a property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるプロパティに関してこれらのオブザーバーのどちらかまたは両方とも定義する選択肢を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You implement a prefix or postfix unary operator by writing the prefix or postfix modifier before the func keyword when declaring the operator method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、接頭辞または接尾辞単項演算子を、prefixまたはpostfix修飾子をfuncキーワードの前に演算子メソッドを宣言するときに書くことによって実装します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You implement this initialization process by defining initializers, which are like special methods that can be called to create a new instance of a particular type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこの初期化処理をイニシャライザを定義することによって実装します、それは、特定の型の新しいインスタンスをつくるために呼ばれることができる特別なメソッドのようなものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate a lazy stored property by writing the lazy modifier before its declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、lazy修飾子をその宣言の前に書くことによって遅延保存プロパティであることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate a weak reference by placing the weak keyword before a property or variable declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロパティまたは変数の宣言の前にweakキーワードを置くことによって弱い参照を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate an unowned reference by placing the unowned keyword before a property or variable declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロパティまたは変数の宣言の前にunownedキーワードを置くことによって非所有者参照を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate an unsafe unowned reference by writing unowned(unsafe).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、安全でない非所有参照をunowned(unsafe)を書くことによって指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate that an enumeration case is recursive by writing indirect before it, which tells the compiler to insert the necessary layer of indirection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある列挙ケース節が再帰することをそれの前にindirectを書くことによって指し示します、それは、コンパイラに不可欠な間接参照の階層を差し入れるように伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate the function’s return type with the return arrow -&gt; (a hyphen followed by a right angle bracket), which is followed by the name of the type to return.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、関数の戻り型を、戻り矢印-&gt;（ハイフンに続けて右の山形括弧）、それに続く返す型の名前で示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate type methods by writing the static keyword before the method’s func keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、型メソッドをstaticキーワードをメソッドのfuncキーワードの前に書くことによって示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate whether a particular String can be modified (or mutated) by assigning it to a variable (in which case it can be modified), or to a constant (in which case it cannot be modified):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、特定のStringが修正される（または変化する）ことができるかどうか、それを変数（その場合それは修が可能です）にまたは定数（その場合それは修正できません）に代入することによって示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You introduce classes with the class keyword and structures with the struct keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、classキーワードでクラスを、そしてstructキーワードで構造体を始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You introduce enumerations with the enum keyword and place their entire definition within a pair of braces:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、列挙をenumキーワードで始めて、一対の波括弧の内側にそれらの全ての定義を置きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You mark a compound assignment operator’s left input parameter type as inout, because the parameter’s value will be modified directly from within the operator method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは複合代入演算子の左入力パラメーター型をinoutとして印します、なぜなら、このパラメーターの値は直接にこの演算子メソッド内で修正されることになるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have noticed that the bodies of the swapTwoInts(_:_:), swapTwoStrings(_:_:), and swapTwoDoubles(_:_:) functions are identical.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、swapTwoInts(_:_:)、swapTwoStrings(_:_:)、そしてswapTwoDoubles(_:_:)関数の本文が同一であると気がついたかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may, however, want to mark some parts of your code as file private or private in order to hide their implementation details from other code within the app’s module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、しかし、あなたのコードのいくつかの部分をファイル外非公開または非公開として印して、それらの実施詳細をそのアプリのモジュール内の他のコードから隠したいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might expect this function to have the default access level of “internal”, but this is not the case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこの関数が省略時アクセス水準の「内部」を持つのを期待するかもしれません、しかし事実はそうではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might want to run an extra piece of code when an error occurs, or to display a message when a value becomes too high or too low.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、エラーが発生する時にコードの臨時の小片を実行したいかもしれません、またある値があまりに高いかあまりに低くなる時にお知らせを表示したいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must also write the required modifier before every subclass implementation of a required initializer, to indicate that the initializer requirement applies to further subclasses in the chain.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、required修飾子を必須イニシャライザの全てのサブクラス実装の前に書かなければなりません、そうすることでそのイニシャライザ要件がさらにその連鎖のサブクラスに適用されることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must always declare a lazy property as a variable (with the var keyword), because its initial value might not be retrieved until after instance initialization completes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは常に遅延プロパティを変数として（varキーワードを使って）宣言しなければなりません、なぜならその最初の値はインスタンスの初期化が完了する後まで取り出されないかもしれないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must always state both the name and the type of the property you are overriding, to enable the compiler to check that your override matches a superclass property with the same name and type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、常にあなたがオーバーライドしているプロパティの名前と型を明確に述べなければなりません、そうすることであなたのオーバーライドがスーパークラスの同じ名前と型をもつプロパティと合致することをコンパイラが確認できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must declare computed properties—including read-only computed properties—as variable properties with the var keyword, because their value is not fixed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、計算プロパティ ― 読み出し専用の計算プロパティを含む ― をvarキーワードをつかって変数プロパティとして宣言しなければなりません、なぜならそれらの値は固定されないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must specify the access level explicitly as part of the function’s definition if the function’s calculated access level does not match the contextual default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関数の計算されたアクセス水準が省略時の文脈に合致しないと思うならば、あなたは関数の定義の一部として明確にアクセス水準を指定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need to mark an entity as open or public only if you want it to become part of your framework’s API.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それにあなたのフレームワークのもつAPIの一部になってほしいならば、ある実在を開放または公開として印する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You now write prefix operator rather than operator prefix, for example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは今や、例えば、operator prefixではなくprefix operatorと書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You pass this function an expression that evaluates to true or false and a message that should be displayed if the result of the condition is false:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこの関数に、trueかfalseに評価されるひとつの式と、その条件の結果がfalseならば表示されるべきひとつのメッセージを渡します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You pass this initializer a default value of the appropriate type (called repeating): and the number of times that value is repeated in the new array (called count):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、このイニシャライザに対して、適切な型のひとつの初期値（repeatingと呼ばれます）、そしてその値が新しい配列の中で繰り返される回数（countと呼ばれます）とを渡します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You perform this comparison with the “equal to” operator (==) or the “not equal to” operator (!=).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、この比較を「同等」演算子（==）または「不等」演算子（!=）を使って実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You place an ampersand (&amp;) directly before a variable’s name when you pass it as an argument to an in-out parameter, to indicate that it can be modified by the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは変数の名前の直前に、あなたがin-outパラメータに対する引数としてそれを渡すときに、それが関数によって修正されることができることを示すために、アンパサンド（&amp;）を置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You represent errors using any type that adopts the Error protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、Errorプロトコルを採用するどんな型でも使用してエラーを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You resolve a strong reference cycle between a closure and a class instance by defining a capture list as part of the closure’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、クロージャの定義の一部として捕獲リストを定義することによってクロージャとクラスインスタンスの間で強い参照循環を解消します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You resolve strong reference cycles by defining some of the relationships between classes as weak or unowned references instead of as strong references.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、クラス間の関係の一部を強い参照としてでなくて弱い、または非所有者参照として定義することによって強い参照循環を解消します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You saw above how a strong reference cycle can be created when two class instance properties hold a strong reference to each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは上で、２つのクラスインスタンスプロパティが強い参照にお互いを守らせるとき、どのように強い参照循環がつくられることができるかを見ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You set an optional variable to a valueless state by assigning it the special value nil:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、あるオプショナルの変数を値が無い状態へと設定するには、それに特別な値nilを代入します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You specify a declaration modifier by writing the appropriate keyword or context-sensitive keyword between a declaration’s attributes (if any) and the keyword that introduces the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、宣言修飾子を適切なキーワードまたは文脈依存キーワードを宣言の属性（もしあれば）と宣言を導入するキーワードとの間に書くことによって指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You specify a default property value by assigning an initial value to the property when it is defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それが定義されるときプロパティに初期値を代入することによって、省略時のプロパティ値を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You specify an attribute by writing the @ symbol followed by the attribute’s name and any arguments that the attribute accepts:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、@記号に続いてその属性の名前そしてその属性が受け入れる任意の引数を書くことによって属性を指定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You specify optional chaining by placing a question mark (?) after the optional value on which you wish to call a property, method or subscript if the optional is non-nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはオプショナル連鎖を、そのオプショナルがnilで無いならばあなたがプロパティ、メソッド、または添え字を呼び出したいオプショナルの値の後に疑問符（?）を置くことによって指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You specify the associativity of an operator by writing one of the context-sensitive keywords left, right, or none—if your omit the associativity, the default is none.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはある演算子の結合性を文脈依存キーワードleft、right、またはnoneのうちの１つを書くことによって指定します—あなたが結合性を省略するならば、初期状態はnoneです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You typically define a failable initializer that creates an optional instance of the appropriate type by placing a question mark after the init keyword (init?).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは一般的に、適切な型のオプショナルのインスタンスを作成する失敗できるイニシャライザを、疑問符をinitキーワードの後において（init?）定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You typically use internal access when defining an app’s or a framework’s internal structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは概して内部アクセスを、アプリのまたはフレームワークの内部用の構造体を定義するときに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You typically use open or public access when specifying the public interface to a framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは概して開放または公開アクセスを、あるフレームワークに公開インタフェースを指定するときに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use for-in to iterate over items in a dictionary by providing a pair of names to use for each key-value pair.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはfor-inを使って、辞書の中の項目のすべてに対して繰り返すことを、一対の名前を提供してそれぞれの「キーと値」の対に使用することで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use try? to handle an error by converting it to an optional value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、try?を使って、あるエラーをオプショナルの値に変換することによって取り扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use error handling to respond to error conditions your program may encounter during execution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、エラー処理を使ってあなたのプログラムが実行の間に遭遇するエラー状態に応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use optional binding to find out whether an optional contains a value, and if so, to make that value available as a temporary constant or variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるオプショナルが値を含むかどうか知るために、そしてもしそうならば、その値を一時的な定数または変数として利用可能にするために、オプショナル束縛を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use optionals in situations where a value may be absent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはオプショナルを、ある値が不在かもしれない状況において使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use a defer statement to execute a set of statements just before code execution leaves the current block of code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはdefer文を使うことで、コード実行が現在のコードブロックから離れる直前に一揃いの文を実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use a do-catch statement to handle errors by running a block of code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるコードの塊を実行することによってエラーを処理するために、do-catch文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use a throw statement to throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはthrow文を使ってエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use a guard statement to require that a condition must be true in order for the code after the guard statement to be executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはguard文を使って、guard文の後のコードが実行されるためにはある条件が真でなけれればならないことを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use a dictionary when you need to look up values based on their identifier, in much the same way that a real-world dictionary is used to look up the definition for a particular word.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現実世界の辞書が特定の語の定義を調べるために使われるのと全く同様に、あなたが値をそれらの識別子に基づいて調べる必要があるとき、あなたは辞書を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use a variadic parameter to specify that the parameter can be passed a varying number of input values when the function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは可変長パラメータを、関数が呼ばれる時にそのパラメータが変動する数の入力値を渡されることができることを示すために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use an availability condition in an if or guard statement to conditionally execute a block of code, depending on whether the APIs you want to use are available at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、有効性条件をifまたはguard文の中で使って、あなたが使用したいAPIが実行時に有効かどうかに基づいて、条件付きでコードプロックを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use an assertion to make sure that an essential condition is satisfied before executing any further code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある必須の条件が何らかの更なるコードを実行する前に満たされることを確認するために表明を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use an availability condition to execute a block of code, depending on whether the APIs you want to use are available at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、有効性条件を使って、あなたが使用したいAPIが実行時に有効かどうかに基づいて、あるコードのブロックを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use function types just like any other types in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、関数型をスウィフトでのあらゆる他の型と同じように使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use it to create logical expressions in which only one of the two values has to be true for the overall expression to be true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはそれを、全体的な式がtrueになるためには２つの値のうちの１つだけがtrueであればよい論理式をつくるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use platform names such as iOS, macOS, watchOS, and tvOS—for the full list, see Declaration Attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、例えばiOS、macOS、watchOS、そしてtvOSのようなプラットホーム名を使います—完全なリストのために、宣言属性を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは添え字を使うことで、独立したメソッドを設定や検索のために必要とすることなしに、インデックスによって値を設定したり取得したりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the for-in loop to iterate over a sequence, such as ranges of numbers, items in an array, or characters in a string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはfor-inループを、ある連続物について、例えば数の範囲、配列の中の項目、または文字列の中の文字について、それに含まれるすべてに繰り返していくために使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the nonobjc attribute to resolve circularity for bridging methods in a class marked with the objc attribute, and to allow overloading of methods and initializers in a class marked with the objc attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、objc属性で印されるクラスの中のブリッジしているメソッドに対する循環性を解決するために、そしてobjc属性で印されるクラスにおいてメソッドとイニシャライザをオーバーロードすることを許可するためにnonobjc属性を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the self property to distinguish between the parameter name and the property name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、selfプロパティをパラメータ名とプロパティ名を区別するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the self property to refer to the current instance within its own instance methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、selfプロパティを現在のインスタンスに言及するためにそれ自身のインスタンスメソッド内で使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the case keyword to introduce new enumeration cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはcaseキーワードを使って、新しい列挙ケース節を導入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the initializer expression in a function call expression to initialize a new instance of a type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、イニシャライザ式を関数呼び出し式において使うことで、ある型の新しいインスタンスを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use these patterns in a case label of a switch statement, a catch clause of a do statement, or in the case condition of an if, while, guard, or for-in statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこれらのパターンをswitch文のケース節ラベル、do文のcatch節において、またはif、while、guard、およびfor-in文のケース節条件において使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write return nil within a failable initializer to indicate a point at which initialization failure can be triggered.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは失敗できるイニシャライザの内部でreturn nilを書くことで、そこにおいて初期化失敗が引き起こされる可能性がある地点を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write a failable initializer by placing a question mark after the init keyword (init?).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、失敗可能なイニシャライザを疑問符をinitキーワードの後に置くこと（init?）によって記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write a generic where clause right before the opening curly brace of a type or function’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、総称体where節を、型や関数のもつ本文の開き波括弧のまさに前に記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write a pattern after catch to indicate what errors that clause can handle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、catchの後にあるパターンを書いてどんなエラーをその節が取り扱えるかを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write a pattern after catch just as you do after case in a switch.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、まさにあなたがスイッチにおいてcaseの後にするように、catchの後にひとつのパターンを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write an argument label before the parameter name, separated by a space:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは引数ラベルを、パラメーター名の前に、空白で区切って書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write an assertion by calling the Swift standard library global assert(_:_:file:line:) function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、スウィフト標準ライブラリのグローバルなassert(_:_:file:line:)関数を呼び出すことによって表明を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write an implicitly unwrapped optional by placing an exclamation mark (String!) rather than a question mark (String?) after the type that you want to make optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは暗黙的にアンラップされるオプショナルを、あなたがオプショナルを作りたい型の後に疑問符（String?）ではなく感嘆符（String!）を置くことによって記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write an in-out parameter by placing the inout keyword right before a parameter’s type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、パラメータの型のすぐ前にinoutキーワードを置くことによってin-outパラメータを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write an instance method within the opening and closing braces of the type it belongs to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、インスタンスメソッドを、それが属している型の開始と終わりの波括弧の内部に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write an optional tuple return type by placing a question mark after the tuple type’s closing parenthesis, such as (Int, Int)? or (String, Int, Bool)?.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはオプショナルタプルの戻り型をタプル型の閉じ括弧の後に疑問符を置くことによって書きます、例えば(Int、Int)?または(String、Int、Bool)?など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write deinitializers with the deinit keyword, similar to how initializers are written with the init keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、イニシャライザがinitキーワードで書かれる方法と同様に、デイニシャライザをdeinitキーワードを使って書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write nested comments by starting a multiline comment block and then starting a second multiline comment within the first block.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはひとつの複数行コメント・ブロックを始めて、それから第二の複数行を最初のブロック以内に始めることによって入れ子にされたコメントを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write subscript definitions with the subscript keyword, and specify one or more input parameters and a return type, in the same way as instance methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、添え字定義をsubscriptキーワードを使って書きます、そしてインスタンスメソッドと同じ方法で、一つ以上の入力パラメータと戻り型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write these constraints after the name of the protocol you’re extending using a generic where clause, as described in Generic Where Clauses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、これらの制約をあなたが拡張しているプロトコルの名前の後に、総称体where節で記述される総称体where節を使って書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write these initializers as part of the protocol’s definition in exactly the same way as for normal initializers, but without curly braces or an initializer body:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、これらのイニシャライザをプロトコル定義の一部として普通のイニシャライザと正確に同じ方法で書くことができます、しかし波括弧またはイニシャライザ本文はありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write type constraints by placing a single class or protocol constraint after a type parameter’s name, separated by a colon, as part of the type parameter list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、型パラメーターリストの一部として、型パラメータの名前の後にコロンで区切って一つのクラスまたはプロトコル制約を置くことによって、型制約を書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You’re not limited to the predefined operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あらかじめ定義された演算子に制限されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You’ve actually been using value types extensively throughout the previous chapters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、実際に前の章を通して広く値型を使っていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Zeros are inserted in the spaces left behind after the original bits are moved to the left or right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>元のビットが左または右へ移動した後に残される空きに、ゼロが差し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Zeros become ones, and ones become zeros.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゼロは１になります、そして１はゼロになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but is written over multiple lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（しかし複数行にわたって書かれます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>giving a remainder value of -1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして-1の余り値を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>where some multiplier is the largest number of multiples of b that will fit inside a.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでいくらかの乗数はaの内部に収まるbの倍数の最も大きな数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“A function type that has two parameters, both of type Int, and that returns a value of type Int.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「２つのパラメータを持ち、両方とも型Intで、そして型Intの値をひとつ返す関数型」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Consider the value of directionToHead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「directionToHeadの値を考慮する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Declare a new constant called maximumNumberOfLoginAttempts, and give it a value of 10.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「maximumNumberOfLoginAttemptsと呼ばれるある新しい定数を宣言して、それに10というひとつの値を与える。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Declare a variable called welcomeMessage that is of type String.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「welcomeMessageと呼ばれる型Stringの変数を宣言する。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Define a variable called mathFunction, which has a type of ‘a function that takes two Int values, and returns an Int value.’ Set this new variable to refer to the function called addTwoInts.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「『２つのInt値をとり、１つのInt値を返す関数』の型を持ち、mathFunctionと呼ばれる、ある変数を定義する。この新しい変数をaddTwoIntsと呼ばれる関数に言及するように設定する。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Define an enumeration type called Barcode, which can take either a value of upc with an associated value of type (Int, Int, Int, Int), or a value of qrCode with an associated value of type String.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「Barcodeと呼ばれる列挙型を定義します、それは型（Int、Int、Int、Int）の関連値をもつupcの値、または型Stringの関連値をもつqRCodeの値をとることができます。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Equal to” means that two instances are considered “equal” or “equivalent” in value, for some appropriate meaning of “equal”, as defined by the type’s designer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「同等」は、２つのインスタンスが、値で「等しい」あるいは「相当する」と、ある適切な「等しい」の意味で、型の設計者によって定義されたとおりに、考慮されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Identical to” means that two constants or variables of class type refer to exactly the same class instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「同一」は、クラス型の２つの定数または変数が、正確に同じクラスインスタンスに言及することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“If the optional Int returned by Int(possibleNumber) contains a value, set a new constant called actualNumber to the value contained in the optional.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「Int(possibleNumber)によって返されるオプショナルのIntが値を含むならば、ある新しい定数actualNumberをそのオプショナルに含まれる値に設定してください。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Try to access item as a Movie.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「itemにMovieとしてアクセスを試みてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>…and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>…などなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>…and so on:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>…などなど：</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
