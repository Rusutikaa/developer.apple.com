<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.1.1_0_9688" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Irreflexivity)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（非反射）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Reflexivity)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（反射性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Symmetry)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（対称性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Transitive comparability)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（推移的比較性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Transitive incomparability)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（推移的比較不能性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Transitivity)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（推移性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/   than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/   ゼロより大きいか等しくなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ 'firstCopy' and 'secondCopy' are [1, 2, 3, 4, 5]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'firstCopy' と 'secondCopy' は [1, 2, 3, 4, 5] です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ 'numbers' is [100, 200, 300, 4, 5]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'numbers' は [100, 200, 300, 4, 5] です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ 'p' has a binary representation of 11111110_00001100</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'p' はバイナリ表現 11111110_00001100 を持ちます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ 'q' has a binary representation of 00001100</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'q' はバイナリ表現 00001100 を持ちます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ 'rawPointer' points to memory initialized with `Int` values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'rawPointer' は `Int` 値で初期化されるメモリを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ - Complexity: O(n)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ - 計算量: O(n)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ - Parameter element: The element to set the new count on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ - パラメータ element: 新しく数えることになる要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ - Parameter n: The new count for `element`. `n` must be greater</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ - パラメータ n: `element`に対する新しい総数。`n`は</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ A floating-point value initialized using an integer literal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 整数リテラルを使って初期化される浮動小数点値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ A for-in loop over 'ranges' accesses each range:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 「ranges」に対するfor-inループは、各範囲にアクセスします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ A point in an x-y coordinate system.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ x-y座標システムでのある点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ A set is never a strict subset of itself:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ A集合は決してそれ自身の狭義の下位集合ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Accessing 'numberPointer' is undefined behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'numberPointer' へのアクセスは未定義挙動となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ All properties are *computed* based on members of the Header</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ すべてのプロパティは「ヘッダ」のメンバに基づいて*計算*されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ All successes are equivalent, so none is before any other</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ すべての成功は等しい、なので何か他の前に来るものはありません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ An array of 'Double'</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 「Double」の配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ An array of 'Int'</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'Int' の配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ An array of 'Int' elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'Int' 要素の配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ An array of 'String' elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'String' 要素の配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ An integer type with reference semantics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 参照意味論を持つ整数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Ben's family is moving to another state</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ ベンの家族は別の州に引っ越そうとしています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Characters out of bounds</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 文字列が範囲外</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Comparing with the equal-to operator never returns 'true'</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 同等演算子で比較することは決して'true'を返しません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Equivalent to the C 'ceil' function:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ C 'ceil'関数の等価物：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Equivalent to the C 'floor' function:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ C 'floor'関数の等価物：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Equivalent to the C 'round' function:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ C 'round'関数の等価物：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Equivalent to the C 'trunc' function:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ C 'trunc'関数の等価物：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Error: ...the result would be less than UInt.min</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ エラー: ... 結果がUInt.minより少なくなっている</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Error: Double value cannot be converted...</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ エラー: Double値が変換できない...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Error: Not enough bits to represent...</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ エラー: 表すのにビットが足りない...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Includes whitespace</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 空白を含む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Incorrect exponent format</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 不正な指数形式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Interleave two sequences that yield the same element type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 同じ要素型を生み出す２つのシーケンスを交互に重ねます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Invalid character</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 無効な文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Invalid format</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 無効な形式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Iterate over all powers of two (ignoring overflow)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ ２の階乗すべてにわたって繰り返します（オーバーフローは無視します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Just forward to subscript</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 単に添え字に転送する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Load a value from the last two allocated bytes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 最後の２つのアロケート済みバイトから値をロードする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Load a value from the memory referenced by 'bytesPointer'</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'bytesPointer' によって参照されるメモリから値をロードする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Modifications to an instance are visible from either array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ あるインスタンスへの修正はどちらの配列からも見ることができます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Order errors before successes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 成功の前にエラーを並べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Order errors by code</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ エラーをコードによって並べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Out of range</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 範囲外</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Performs an intersection with an Array&lt;Int&gt;</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ あるArray&lt;Int&gt;との共通部分を求める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Prints "The two groups start the same."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 「２つのグループは同じものから始まります」を出力します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Prints "false" because `Int` and `UInt8` are different types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 「false」を出力します、`Int` と `UInt8` は異なる型であるから</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Replacements, additions, and removals are still visible</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 取替、追加、そして削除もやはり見えますが</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Returns an array containing the results of</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 以下の結果を含んでいる配列を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Shortened forms are preferred</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 短縮形式が好まれます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Test with the 'isNaN' property instead</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 代わりに'isNaN'プロパティでテストしてください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Tests whether primes is a subset of a Range&lt;Int&gt;</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ primesが、あるRange&lt;Int&gt;の下位集合かどうかテストする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ The full type name is also allowed</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 完全な型名も受け入れられます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ The storage for 'numbers' is copied here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'numbers' のストレージはここでコピーされます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Triggers runtime error: Index out of range</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 実行時エラーの引き金となります：範囲外インデックス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Type inferred as 'Double'</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 型は「Double」と推論される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Type inferred as 'Int'</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'Int' と型推論されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Updates the count stored in the set for the given element,</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 与えられた要素に対して集合の中に格納された総数を更新しながら、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Use 'abs(_:)' instead of 'magnitude'</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'abs(_:)' を 'magnitude' の代わりに使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Use 'joined()' to access each element of each range:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 「joined()」を使うことで、各範囲の各要素にアクセスしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ Walk the elements of a tree from a node up to the root</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ あるツリーの要素をあるノードからルートへとさかのぼって移動します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ William is signing up for a different class</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ ウィリアムは違うクラスを受講します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ adding the element if necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 必要なら要素を追加する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ error: ambiguous use of 'subscript'</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ エラー：「添え字」のあいまいな使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ error: cannot convert value of type '[String?]' to type 'NSArray'</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ エラー：型 '[String?]' の値を型 'NSArray' に変換することはできません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ error: closure use of non-escaping parameter 'predicate'...</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ エラー: 非脱出パラメータ 'predicate' のクロージャ使用 ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ error: passing non-escaping parameter 'f'...</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ エラー: 非脱出パラメータ 'f' を渡している...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ error: passing non-escaping parameter 'g'...</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ エラー: 非脱出パラメータ 'g' を渡している...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ extend 'r' to fill 16 bits</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'r' を 16ビットを満たすように拡張します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ for each prefix `p` of `self`, in order from shortest to</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ これは「self」の各接頭辞「p」に対して、順番を最短から</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ fractional value, representable</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 小数値、表現可能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ implementation details</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 実装詳細</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ integral value, nonrepresentable</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 整数値、表現不可能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ integral value, representable</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 整数値、表現可能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ longest.  For example:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 最長へです。例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ node is leaf, then leaf.parent, then leaf.parent.parent, etc.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ nodeはleafです、それからleaf.parent、その次にleaf.parent.parent、等々。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ number == -3, perhaps</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ number == -3、たぶん</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ only in the modified array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ ただ修正された配列においてのみです</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ truncate 'q' to fit in 8 bits</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ 'q' を 8ビットに合うように切り詰めます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>/ value is 1, then 2, then 4, then 8, etc.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>/ valueは１です、それから２、その次に８、等々。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>Table 1<ept i="0">&lt;/a0&gt;</ept> lists the prefix operators, <bpt i="1" x="1">&lt;a1&gt;</bpt>Table 2<ept i="1">&lt;/a1&gt;</ept> lists the postfix operators, and <bpt i="2" x="2">&lt;a2&gt;</bpt>Table 3<ept i="2">&lt;/a2&gt;</ept> lists the infix operators, including their associativity and precedence group.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>表 1<ept i="0">&lt;/a0&gt;</ept>は、前置演算子を一覧にします、<bpt i="1" x="1">&lt;a1&gt;</bpt>表 2<ept i="1">&lt;/a1&gt;</ept>は後置演算子を一覧にします、そして<bpt i="2" x="2">&lt;a2&gt;</bpt>表 3<ept i="2">&lt;/a2&gt;</ept>は中置演算子を一覧にします、それらの結合性と優先順位グループを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(true, new<ph x="2">&lt;w2/&gt;</ph>Member)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>new<ph x="5">&lt;w5/&gt;</ph>Member<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> was not contained in the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(true, new<ph x="2">&lt;w2/&gt;</ph>Member)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>new<ph x="5">&lt;w5/&gt;</ph>Member<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>がこの集合の中に含まれなかったならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-infinity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> compares less than all values except for itself and NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-infinity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、それ自身とNaNを除くすべての値より少ないと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-infinity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> compares less than or equal to all values except NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-infinity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、NaNを除くすべての値より少ないか等しいと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>.data<ph x="2">&lt;w2/&gt;</ph>Corrupted<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> indicates that the data is corrupted or otherwise invalid.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>.data<ph x="2">&lt;w2/&gt;</ph>Corrupted<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、データが不正またはそうでなくとも無効であることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>.invalid<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> indicates that an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Encoder<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> or its containers could not encode the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>.invalid<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Encoder<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>またはそれのコンテナが与えられた値でエンコードできなかったことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>.key<ph x="2">&lt;w2/&gt;</ph>Not<ph x="3">&lt;w3/&gt;</ph>Found<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> indicates that a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Keyed<ph x="6">&lt;w6/&gt;</ph>Decoding<ph x="7">&lt;w7/&gt;</ph>Container<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> was asked for an entry for the given key, but did not contain one.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>.key<ph x="2">&lt;w2/&gt;</ph>Not<ph x="3">&lt;w3/&gt;</ph>Found<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Keyed<ph x="6">&lt;w6/&gt;</ph>Decoding<ph x="7">&lt;w7/&gt;</ph>Container<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が与えられたキーに対して尋ねられた、しかし何も含まなかったことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>.type<ph x="2">&lt;w2/&gt;</ph>Mismatch<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> indicates that a value of the given type could not be decoded because it did not match the type of what was found in the encoded payload.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>.type<ph x="2">&lt;w2/&gt;</ph>Mismatch<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、与えられた型の値がデコードできなかった、なぜならエンコードされたペイロードの中に見つけられた何かの型に合致しなかったことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>.value<ph x="2">&lt;w2/&gt;</ph>Not<ph x="3">&lt;w3/&gt;</ph>Found<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> indicates that a non-optional value of the given type was expected, but a null value was found.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>.value<ph x="2">&lt;w2/&gt;</ph>Not<ph x="3">&lt;w3/&gt;</ph>Found<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、与えられた型の非オプショナル値が期待された、しかしnull値が見つかったことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Object<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> can also be used as the concrete type for an instance of a type that bridges to an Objective-C class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Object<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はまた、Objective-Cクラスへとブリッジするある型のインスタンスに対する具象型として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bool<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> represents Boolean values in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bool<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はブール値をSwiftにおいて表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Empty<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not have any element indices, so it is not possible to advance indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Empty<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、全く要素インデックスを持ちません、それでインデックスを進めることは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Enumerated<ph x="2">&lt;w2/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is a sequence of pairs (<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>, <bpt i="4" x="4">&lt;e4&gt;</bpt>x<ept i="4">&lt;/e4&gt;</ept>), where <bpt i="5" x="5">&lt;e5&gt;</bpt>n<ept i="5">&lt;/e5&gt;</ept>s are consecutive <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> values starting at zero, and <bpt i="8" x="8">&lt;e8&gt;</bpt>x<ept i="8">&lt;/e8&gt;</ept>s are the elements of a base sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Enumerated<ph x="2">&lt;w2/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、ペア (<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>, <bpt i="4" x="4">&lt;e4&gt;</bpt>x<ept i="4">&lt;/e4&gt;</ept>) からなるシーケンスです、ここで<bpt i="5" x="5">&lt;e5&gt;</bpt>n<ept i="5">&lt;/e5&gt;</ept>はゼロで始まる連続した<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です、そして<bpt i="8" x="8">&lt;e8&gt;</bpt>x<ept i="8">&lt;/e8&gt;</ept>は基盤シーケンスの要素です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float80<ph x="2">&lt;w2/&gt;</ph>.significand<ph x="3">&lt;w3/&gt;</ph>Bit<ph x="4">&lt;w4/&gt;</ph>Count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is 63, even though 64 bits are used to store the significand in the memory representation of a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Float80<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float80<ph x="2">&lt;w2/&gt;</ph>.significand<ph x="3">&lt;w3/&gt;</ph>Bit<ph x="4">&lt;w4/&gt;</ph>Count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は63です、たとえ64ビットが使用されて仮数を<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Float80<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスのメモリ表現に格納するとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Bidirectional<ph x="3">&lt;w3/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> requires that the base collection’s <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>subscript(_: Index)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> setter does not invalidate indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Bidirectional<ph x="3">&lt;w3/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が必要とするのは、基盤コレクションの持つ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>subscript(_: Index)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のセッターがインデックスを無効にしないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Random<ph x="3">&lt;w3/&gt;</ph>Access<ph x="4">&lt;w4/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> requires that the base collection’s <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>subscript(_: Index)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> setter does not invalidate indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Random<ph x="3">&lt;w3/&gt;</ph>Access<ph x="4">&lt;w4/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が必要とするのは、基盤コレクションの持つ<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>subscript(_: Index)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>のセッターがインデックスを無効にしないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Replaceable<ph x="4">&lt;w4/&gt;</ph>Bidirectional<ph x="5">&lt;w5/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> requires that the base collection’s <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>subscript(_: Index)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> setter does not invalidate indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Replaceable<ph x="4">&lt;w4/&gt;</ph>Bidirectional<ph x="5">&lt;w5/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が必要とするのは、基盤コレクションの持つ<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>subscript(_: Index)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>のセッターがインデックスを無効にしないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Replaceable<ph x="4">&lt;w4/&gt;</ph>Random<ph x="5">&lt;w5/&gt;</ph>Access<ph x="6">&lt;w6/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> requires that the base collection’s <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>subscript(_: Index)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> setter does not invalidate indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Replaceable<ph x="4">&lt;w4/&gt;</ph>Random<ph x="5">&lt;w5/&gt;</ph>Access<ph x="6">&lt;w6/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が必要とするのは、基盤コレクションの持つ<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>subscript(_: Index)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>のセッターがインデックスを無効にしないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Replaceable<ph x="4">&lt;w4/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> requires that the base collection’s <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>subscript(_: Index)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> setter does not invalidate indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Replaceable<ph x="4">&lt;w4/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が必要とするのは、基盤コレクションの持つ<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>subscript(_: Index)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>のセッターがインデックスを無効にしないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> requires that the base collection’s <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>subscript(_: Index)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> setter does not invalidate indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が必要とするのは、基盤コレクションの持つ<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>subscript(_: Index)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>のセッターがインデックスを無効にしないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances can represent an empty interval, unlike <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Closed<ph x="4">&lt;w4/&gt;</ph>Range<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、空の間隔を表すことができます、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Closed<ph x="4">&lt;w4/&gt;</ph>Range<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>とは違って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a &lt; a<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is always <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> (Irreflexivity)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a &lt; a<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は常に<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>（非反射）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a &lt; b<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b &lt; c<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> implies <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>a &lt; c<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> (Transitivity)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a &lt; b<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>かつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b &lt; c<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>a &lt; c<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を意味する（推移）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a &lt; b<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implies <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>!(b &lt; a)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> (Asymmetry)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a &lt; b<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>!(b &lt; a)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を意味する（非対称）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a == a<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is always <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> (Reflexivity)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a == a<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、常に<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>（反射）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a == b<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b == c<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> implies <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>a == c<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> (Transitivity)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a == b<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>かつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b == c<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>a == c<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を意味する（推移）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a == b<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implies <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b == a<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> (Symmetry)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a == b<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b == a<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を意味する（対称）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>are<ph x="2">&lt;w2/&gt;</ph>Equivalent(a, a)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is always <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>true<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>are<ph x="2">&lt;w2/&gt;</ph>Equivalent(a, a)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は常に<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>true<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>are<ph x="2">&lt;w2/&gt;</ph>Equivalent(a, b)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implies <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>are<ph x="5">&lt;w5/&gt;</ph>Equivalent(b, a)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>are<ph x="2">&lt;w2/&gt;</ph>Equivalent(a, b)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>are<ph x="5">&lt;w5/&gt;</ph>Equivalent(b, a)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>are<ph x="2">&lt;w2/&gt;</ph>In<ph x="3">&lt;w3/&gt;</ph>Increasing<ph x="4">&lt;w4/&gt;</ph>Order(a, a)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is always <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>false<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>are<ph x="2">&lt;w2/&gt;</ph>In<ph x="3">&lt;w3/&gt;</ph>Increasing<ph x="4">&lt;w4/&gt;</ph>Order(a, a)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は常に<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>false<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>as<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>as?<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>as!<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>as<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>as?<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, および <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>as!<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is executed each time the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>next()<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method is called on the resulting iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、結果として生じるイテレータで<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>next()<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドが呼び出されるたびに実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>.joined().map(f)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> maps eagerly and returns a new array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>.joined().map(f)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は先行にマップを行い、新しい配列を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>.joined()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not create new storage</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>.joined()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は新しいストレージを作りません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>.lazy<ph x="3">&lt;w3/&gt;</ph>.joined().map(f)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> maps lazily and returns a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Lazy<ph x="6">&lt;w6/&gt;</ph>Map<ph x="7">&lt;w7/&gt;</ph>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>.lazy<ph x="3">&lt;w3/&gt;</ph>.joined().map(f)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は遅延にマップして、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Lazy<ph x="6">&lt;w6/&gt;</ph>Map<ph x="7">&lt;w7/&gt;</ph>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>.lazy<ph x="3">&lt;w3/&gt;</ph>.reversed().map(f)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> maps lazily and returns a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Lazy<ph x="6">&lt;w6/&gt;</ph>Map<ph x="7">&lt;w7/&gt;</ph>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>.lazy<ph x="3">&lt;w3/&gt;</ph>.reversed().map(f)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は遅延にマップして<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Lazy<ph x="6">&lt;w6/&gt;</ph>Map<ph x="7">&lt;w7/&gt;</ph>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>.reversed().map(f)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> maps eagerly and returns a new array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>.reversed().map(f)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、先行にマップして新しい配列を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>.reversed()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not create new storage</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>.reversed()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、新しいストレージを作成しません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>condition<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is not evaluated in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-Ounchecked<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> builds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>condition<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-Ounchecked<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビルドにおいては評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>condition<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is only evaluated in playgrounds and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-Onone<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> builds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>condition<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はただプレイグラウンドと<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-Onone<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>において評価されるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must not be negative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、負であってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>default<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>optional<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> have the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>default<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>optional<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は同じ型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>default<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is the same type as the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Wrapped<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type of <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>optional<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>default<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>optional<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Wrapped<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型と同じ型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>elements<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be finite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>elements<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection that is not equal to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はコレクションの有効なインデックスで、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティと等しくないものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はコレクションのひとつの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is always reachable from <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> by zero or more applications of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>index(after:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、常に<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>から<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>index(after:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>のゼロまたはそれ以上の適用によって到達可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is not a valid argument to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>subscript<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, and is always reachable from <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>start<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> by zero or more applications of <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>index(after:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>subscript<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に対する有効な引数ではありません、そして常に<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>start<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>からゼロまたはそれ以上の<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>index(after:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>の適用によって到達可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>greatest<ph x="2">&lt;w2/&gt;</ph>Finite<ph x="3">&lt;w3/&gt;</ph>Magnitude<ph x="4">&lt;w4/&gt;</ph>.ulp<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is a finite number, even though the next greater representable value is <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>infinity<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>greatest<ph x="2">&lt;w2/&gt;</ph>Finite<ph x="3">&lt;w3/&gt;</ph>Magnitude<ph x="4">&lt;w4/&gt;</ph>.ulp<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は有限数です、たとえ次のより大きい表現可能な値が<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>infinity<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>であるとしても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index of the string that is not equal to the string’s end index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、この文字列の有効なインデックスでなければなりません、そしてこの文字列の持つ末尾インデックスと等しくてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be greater than <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>start<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>start<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>より大きくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be in the range <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>0..&lt;count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、範囲<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>0..&lt;count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の中でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be less than <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>より少なくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be less than the string’s end index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は文字列の末尾インデックスより少なくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index into the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はコレクションに対する有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index of the array or equal to its <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、配列の有効なインデックスまたはそれの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は配列の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection that is not equal to the collection’s end index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、このコレクションの有効なインデックスでなければなりません、そしてこのコレクションの持つ末尾インデックスと等しくてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はコレクションの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index of the dictionary, and must not equal the dictionary’s end index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は辞書の有効なインデックスでなければなりません、そして辞書の末尾インデックスと同じではなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be an element in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String(utf16).indices<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String(utf16).indices<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の中の要素でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be an element of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String(unicode<ph x="4">&lt;w4/&gt;</ph>Scalars).indices<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String(unicode<ph x="4">&lt;w4/&gt;</ph>Scalars).indices<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の要素でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be an element of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String(utf8).indices<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String(utf8).indices<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の中の要素でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>start<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and less than <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>end<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>start<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>より大きいか等しくそして<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>end<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>より小さくなくてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>initial<ph x="2">&lt;w2/&gt;</ph>Result<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is passed to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>next<ph x="5">&lt;w5/&gt;</ph>Partial<ph x="6">&lt;w6/&gt;</ph>Result<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> the first time the closure is executed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>initial<ph x="2">&lt;w2/&gt;</ph>Result<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>next<ph x="5">&lt;w5/&gt;</ph>Partial<ph x="6">&lt;w6/&gt;</ph>Result<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に、クロージャが実行される最初の時に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Known<ph x="3">&lt;w3/&gt;</ph>Uniquely<ph x="4">&lt;w4/&gt;</ph>Referenced(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> checks only for strong references to the given object—if <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>object<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> has additional weak or unowned references, the result may still be <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>true<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Known<ph x="3">&lt;w3/&gt;</ph>Uniquely<ph x="4">&lt;w4/&gt;</ph>Referenced(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は与えられたオブジェクトに対する強い参照に対してのみ確認します — <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>object<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>がさらに弱いまたは非所有参照を持つ場合、結果は依然として<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>true<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Length<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Length<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> may be positive, negative, or zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は整数、負数、またはゼロであることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero and must not exceed the number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません、そしてコレクションの中の要素の数を超えてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません、そしてコレクションの要素数より少ないか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has a specific meaning in Swift—the absence of a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はSwiftでは特別な意味を持ちます—値の不在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, which gets passed as a null pointer,</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、それはヌルポインターとして渡されます、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>offset<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be nonnegative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>offset<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、非負でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be finite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection that is not equal to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はコレクションの有効なインデックスで、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティと等しくないものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection that is not equal to the collection’s end index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、このコレクションの有効なインデックスでなければなりません、そしてこのコレクションの持つ末尾インデックスと等しくてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index of the dictionary and not equal to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、この辞書の有効なインデックスで、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と等しくない必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index of the range, and must not equal the range’s end index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、この範囲の有効なインデックスでなければなりません、そしてこの範囲の持つ末尾インデックスと等しくてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index of the set, and must not be equal to the set’s end index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、この集合の有効なインデックスでなければなりません、そしてこの集合の持つ末尾インデックスと等しくてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be less than the view’s end index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はこのビューの末尾インデックスより少なくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>possible<ph x="2">&lt;w2/&gt;</ph>Strict<ph x="3">&lt;w3/&gt;</ph>Subset<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be finite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>possible<ph x="2">&lt;w2/&gt;</ph>Strict<ph x="3">&lt;w3/&gt;</ph>Subset<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>possible<ph x="2">&lt;w2/&gt;</ph>Strict<ph x="3">&lt;w3/&gt;</ph>Superset<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be finite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>possible<ph x="2">&lt;w2/&gt;</ph>Strict<ph x="3">&lt;w3/&gt;</ph>Superset<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>possible<ph x="2">&lt;w2/&gt;</ph>Superset<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be finite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>possible<ph x="2">&lt;w2/&gt;</ph>Superset<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>s<ph x="2">&lt;w2/&gt;</ph>.joined().map(f)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> maps eagerly and returns a new array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>s<ph x="2">&lt;w2/&gt;</ph>.joined().map(f)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は先行にマップを行い、新しい配列を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>s<ph x="2">&lt;w2/&gt;</ph>.joined()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not create new storage</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>s<ph x="2">&lt;w2/&gt;</ph>.joined()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は新しいストレージを作りません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>s<ph x="2">&lt;w2/&gt;</ph>.lazy<ph x="3">&lt;w3/&gt;</ph>.filter { ... }<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, for an arbitrary sequence <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>s<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, is a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Lazy<ph x="8">&lt;w8/&gt;</ph>Filter<ph x="9">&lt;w9/&gt;</ph>Sequence<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>s<ph x="2">&lt;w2/&gt;</ph>.lazy<ph x="3">&lt;w3/&gt;</ph>.filter { ... }<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、随意のシーケンス<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>s<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のための、ひとつの<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Lazy<ph x="8">&lt;w8/&gt;</ph>Filter<ph x="9">&lt;w9/&gt;</ph>Sequence<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>s<ph x="2">&lt;w2/&gt;</ph>.lazy<ph x="3">&lt;w3/&gt;</ph>.joined().map(f)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> maps lazily and returns a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Lazy<ph x="6">&lt;w6/&gt;</ph>Map<ph x="7">&lt;w7/&gt;</ph>Sequence<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>s<ph x="2">&lt;w2/&gt;</ph>.lazy<ph x="3">&lt;w3/&gt;</ph>.joined().map(f)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は遅延にマップして、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Lazy<ph x="6">&lt;w6/&gt;</ph>Map<ph x="7">&lt;w7/&gt;</ph>Sequence<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>size<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must not be negative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>size<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、負であってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be representable in this type after truncation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、切り詰め後にこの型において表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be representable in this type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、この型で表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はコレクションのひとつの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>transform<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>transform<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はこのシーケンスのひとつの要素をそれのパラメータとして受け取り、同じもしくは異なる型の変換された値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>transform<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> accepts each value of the dictionary as its parameter and returns a transformed value of the same or of a different type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>transform<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、辞書の各値をそれのパラメータとして受け取って、同じまたは異なる型の変換した値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is contained in the range; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>がこの範囲に含まれるならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> reference the same memory address; otherwise, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が同じメモリアドレスを参照するならば；そうでなければ<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is greater than or equal to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>; otherwise, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>より大きいか等しいならば返します；そうでなければ、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> references a memory address earlier than <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>; otherwise, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>より前のメモリアドレスを参照するならば；そうでなければ、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>member<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> exists in the set; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>member<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>がこの集合に含まれるならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>object<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is known to have a single strong reference; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>object<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が強い参照をただ１つだけ持つものと知られているならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> has the same value as this instance; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>がこのインスタンスと同じ値を持つならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is less than this value; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>がこの値より小さいならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> have the same elements; otherwise, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が同じ要素を持つならば；そうでなければ<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the element was found in the sequence; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素がシーケンスにおいて見つけられなかったならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the initial elements of the sequence are equivalent to the elements of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>possible<ph x="4">&lt;w4/&gt;</ph>Prefix<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>false<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もしシーケンスの冒頭の要素が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>possible<ph x="4">&lt;w4/&gt;</ph>Prefix<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の要素と等しいならば；そうでなければ<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>false<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the initial elements of the sequence are the same as the elements of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>possible<ph x="4">&lt;w4/&gt;</ph>Prefix<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>false<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もしシーケンスの冒頭の要素が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>possible<ph x="4">&lt;w4/&gt;</ph>Prefix<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の要素と同じならば；そうでなければ<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>false<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the sequence contains an element that satisfies <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>predicate<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>predicate<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を満たす要素を含むならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the set has no elements in common with <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、この集合が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と共通の要素を持たないならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the set is a strict subset of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もしこの集合が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の狭義の部分集合ならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the set is a strict superset of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、この集合が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の狭義の上位集合であるならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the set is a strict superset of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>possible<ph x="4">&lt;w4/&gt;</ph>Strict<ph x="5">&lt;w5/&gt;</ph>Subset<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もしこの集合が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>possible<ph x="4">&lt;w4/&gt;</ph>Strict<ph x="5">&lt;w5/&gt;</ph>Subset<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の狭義の上位集合であるならば；そうでなければ、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the set is a subset of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、この集合が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の部分集合ならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the set is a subset of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>possible<ph x="4">&lt;w4/&gt;</ph>Superset<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>false<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もしこの集合が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>possible<ph x="4">&lt;w4/&gt;</ph>Superset<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の部分集合ならば；そうでなければ、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>false<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the set is a superset of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、この集合が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の上位集合であるならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the set is a superset of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>possible<ph x="4">&lt;w4/&gt;</ph>Subset<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>false<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、この集合が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>possible<ph x="4">&lt;w4/&gt;</ph>Subset<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の上位集合であるならば；そうでなければ、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>false<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the string ends with <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>suffix<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もし文字列が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>suffix<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>で終わるならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the translation detected encoding errors in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>input<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もし翻訳が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>input<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>においてエンコーディングエラーを検出したならば；そうでなければ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if this range and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> have at least one element in common; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もしこの範囲と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が少なくとも１つの共通の要素を持つならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if this sequence and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> contain equivalent items, using <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>are<ph x="6">&lt;w6/&gt;</ph>Equivalent<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> as the equivalence test; otherwise, <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>false.<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、このシーケンスと<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>are<ph x="6">&lt;w6/&gt;</ph>Equivalent<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を同等性テストとして使って同じ要素らを含むならば；そうでなければ、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>false<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if this sequence and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> contain the same elements in the same order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もしこのシーケンスと<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が同じ要素を同じ順序で含んでいるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if this sequence precedes <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> in a dictionary ordering as ordered by <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>are<ph x="6">&lt;w6/&gt;</ph>In<ph x="7">&lt;w7/&gt;</ph>Increasing<ph x="8">&lt;w8/&gt;</ph>Order<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>; otherwise, <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>false<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もしこのシーケンスが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>are<ph x="6">&lt;w6/&gt;</ph>In<ph x="7">&lt;w7/&gt;</ph>Increasing<ph x="8">&lt;w8/&gt;</ph>Order<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>によって並べられる通りの辞書順序において先行するならば；そうでなければ、<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>false<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if this sequence precedes <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> in a dictionary ordering; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もしこのシーケンスが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に、ある辞書順序において先行するならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if this value is ordered below <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> in a total ordering of the floating-point type; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もしこの値が浮動小数点型の全順序において<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>より下に並べられるならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> iff some characters were converted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくらかの文字が変換されなかった場合に限り<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is the set is strict subset of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>possible<ph x="4">&lt;w4/&gt;</ph>Strict<ph x="5">&lt;w5/&gt;</ph>Superset<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ならばこの集合は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>possible<ph x="4">&lt;w4/&gt;</ph>Strict<ph x="5">&lt;w5/&gt;</ph>Superset<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の狭義の部分集合です；そうでなければ、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>upper<ph x="2">&lt;w2/&gt;</ph>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is always reachable from <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>lower<ph x="5">&lt;w5/&gt;</ph>Bound<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> by zero or more applications of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>index(after:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>upper<ph x="2">&lt;w2/&gt;</ph>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、常に<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>lower<ph x="5">&lt;w5/&gt;</ph>Bound<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>から<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>index(after:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>のゼロまたはそれ以上の適用によって到達可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>upper<ph x="2">&lt;w2/&gt;</ph>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is not a valid subscript argument and is always reachable from <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>lower<ph x="5">&lt;w5/&gt;</ph>Bound<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> by zero or more applications of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>index(after:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>upper<ph x="2">&lt;w2/&gt;</ph>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は有効な添え字引数ではありません、そして常に<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>lower<ph x="5">&lt;w5/&gt;</ph>Bound<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>から<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>index(after:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>のゼロまたはそれ以上の適用によって到達可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>v<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid Unicode scalar value, in the range <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>0...0x<ph x="4">&lt;w4/&gt;</ph>D7FF<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0x<ph x="7">&lt;w7/&gt;</ph>E000...0x10FFFF<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>v<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、有効なユニコードスカラー値、範囲<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>0...0x<ph x="4">&lt;w4/&gt;</ph>D7FF<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>または<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0x<ph x="7">&lt;w7/&gt;</ph>E000...0x10FFFF<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>v<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid Unicode scalar value, in the range <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>0...0x<ph x="4">&lt;w4/&gt;</ph>D7FF<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0x<ph x="7">&lt;w7/&gt;</ph>E000...0x<ph x="8">&lt;w8/&gt;</ph>FFFF<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>v<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、有効なユニコードスカラー値、範囲<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>0...0x<ph x="4">&lt;w4/&gt;</ph>D7FF<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>または<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0x<ph x="7">&lt;w7/&gt;</ph>E000...0x<ph x="8">&lt;w8/&gt;</ph>FFFF<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>v<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a valid Unicode scalar value, in the ranges <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>0...0x<ph x="4">&lt;w4/&gt;</ph>D7FF<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0x<ph x="7">&lt;w7/&gt;</ph>E000...0x10FFFF<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>v<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、有効なユニコードスカラー値、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>0...0x<ph x="4">&lt;w4/&gt;</ph>D7FF<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>および<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0x<ph x="7">&lt;w7/&gt;</ph>E000...0x10FFFF<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の範囲でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>without<ph x="2">&lt;w2/&gt;</ph>Actually<ph x="3">&lt;w3/&gt;</ph>Escaping(_:<ph x="4">&lt;w4/&gt;</ph>do:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> provides a temporarily-escapable copy of <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>predicate<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> that <bpt i="7" x="7">&lt;e7&gt;</bpt>can<ept i="7">&lt;/e7&gt;</ept> be used in a call to the lazy view’s <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>filter(_:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>without<ph x="2">&lt;w2/&gt;</ph>Actually<ph x="3">&lt;w3/&gt;</ph>Escaping(_:<ph x="4">&lt;w4/&gt;</ph>do:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>predicate<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の一時的脱出可能なコピーを提供します、それは遅延ビューのもつ<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>filter(_:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>メソッドに対する呼び出しにおいて使用<bpt i="7" x="7">&lt;e7&gt;</bpt>できます<ept i="7">&lt;/e7&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x as T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x as T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.contains(e) &amp;&amp; y<ph x="3">&lt;w3/&gt;</ph>.contains(e)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if and only if <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ph x="6">&lt;w6/&gt;</ph>.intersection(y).contains(e)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.contains(e) &amp;&amp; y<ph x="3">&lt;w3/&gt;</ph>.contains(e)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if and only if <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ph x="6">&lt;w6/&gt;</ph>.intersection(y).contains(e)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> （xがeを含みかつyもeを含むのは、xとyの交差がeを含む場合に限る）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.contains(e)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implies <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>x<ph x="5">&lt;w5/&gt;</ph>.union(y).contains(e)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.contains(e)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implies <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>x<ph x="5">&lt;w5/&gt;</ph>.union(y).contains(e)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> （xがeを含むならば、暗黙的にxとyの合併はeを含む）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.is<ph x="3">&lt;w3/&gt;</ph>Strict<ph x="4">&lt;w4/&gt;</ph>Subset(of: y)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if and only if <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x<ph x="7">&lt;w7/&gt;</ph>.is<ph x="8">&lt;w8/&gt;</ph>Subset(of: y) &amp;&amp; x != y<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.is<ph x="3">&lt;w3/&gt;</ph>Strict<ph x="4">&lt;w4/&gt;</ph>Subset(of: y)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if and only if <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x<ph x="7">&lt;w7/&gt;</ph>.is<ph x="8">&lt;w8/&gt;</ph>Subset(of: y) &amp;&amp; x != y<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> （xがyの狭義の上位集合であるのは、yがxの下位集合でありかつxがyと等しくない場合に限る）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.is<ph x="3">&lt;w3/&gt;</ph>Strict<ph x="4">&lt;w4/&gt;</ph>Superset(of: y)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if and only if <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x<ph x="7">&lt;w7/&gt;</ph>.is<ph x="8">&lt;w8/&gt;</ph>Superset(of: y) &amp;&amp; x != y<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.is<ph x="3">&lt;w3/&gt;</ph>Strict<ph x="4">&lt;w4/&gt;</ph>Superset(of: y)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if and only if <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x<ph x="7">&lt;w7/&gt;</ph>.is<ph x="8">&lt;w8/&gt;</ph>Superset(of: y) &amp;&amp; x != y<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> （xがyの狭義の上位集合であるのは、xがyの上位集合でありかつxがyと等しくない場合に限る）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.is<ph x="3">&lt;w3/&gt;</ph>Subset(of: y)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if and only if <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>y<ph x="6">&lt;w6/&gt;</ph>.is<ph x="7">&lt;w7/&gt;</ph>Superset(of: x)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.is<ph x="3">&lt;w3/&gt;</ph>Subset(of: y)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if and only if <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>y<ph x="6">&lt;w6/&gt;</ph>.is<ph x="7">&lt;w7/&gt;</ph>Superset(of: x)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> （xがyの部分集合であるのは、yがxの上位集合である場合に限る）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.union(y).contains(e)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implies <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>x<ph x="5">&lt;w5/&gt;</ph>.contains(e) || y<ph x="6">&lt;w6/&gt;</ph>.contains(e)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.union(y).contains(e)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implies <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>x<ph x="5">&lt;w5/&gt;</ph>.contains(e) || y<ph x="6">&lt;w6/&gt;</ph>.contains(e)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> （xとyの合併がeを含むならば、暗黙的にxがeを含むかもしくはyがeを含む）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>x<ph x="17">&lt;w17/&gt;</ph>.is<ph x="18">&lt;w18/&gt;</ph>Zero<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept> is equivalent to the following comparison: <bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>x == 0<ph x="21">&lt;w21/&gt;</ph>.0<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>x<ph x="17">&lt;w17/&gt;</ph>.is<ph x="18">&lt;w18/&gt;</ph>Zero<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>は次の比較に相当するものです：<bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>x == 0<ph x="21">&lt;w21/&gt;</ph>.0<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Double<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is a binary floating-point type that has a radix of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>2<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Double<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>はバイナリ浮動小数点型で<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>2<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の基数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is also the base protocol for the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Hashable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Comparable<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> protocols, which allow more uses of your custom type, such as constructing sets or sorting the elements of a collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>はまた、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Hashable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Comparable<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>プロトコルのための基盤プロトコルです、それらはあなたのあつらえの型のさらなる利用を可能します、例えば集合の組み立てやコレクション要素のソートなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Optional<ph x="4">&lt;w4/&gt;</ph>.none<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is equivalent to the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Optional<ph x="4">&lt;w4/&gt;</ph>.none<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>リテラルに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be zero or greater.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、ゼロまたはより大きくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must not be negative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は負数であってはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>n<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must not be negative unless the collection conforms to the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Bidirectional<ph x="6">&lt;w6/&gt;</ph>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>n<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、そのコレクションが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Bidirectional<ph x="6">&lt;w6/&gt;</ph>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルに準拠するのでない限り、負であってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>radix<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be in the range <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>2...36<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>radix<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、範囲<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>2...36<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の中でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must not be zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、ゼロではなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>s<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must contain exactly one extended grapheme cluster.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>s<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、厳密に１つの拡張書記素クラスタを含んでいなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>source<ph x="4">&lt;w4/&gt;</ph>.count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be less than or equal to this buffer’s <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>count<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>source<ph x="4">&lt;w4/&gt;</ph>.count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、このバッファのもつ<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>count<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>より少ないか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>sum<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> would be better implemented using <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>reduce<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>].</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>sum<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>reduce<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を使ってもっとよく実装されるでしょう。］</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>type<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and the type of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> must have the same size of memory representation and compatible memory layout.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>type<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の型は、同じ大きさのメモリ表現を持ち、互換メモリレイアウトを持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be an element in <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String(utf8).utf16<ph x="6">&lt;w6/&gt;</ph>.indices<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String(utf8).utf16<ph x="6">&lt;w6/&gt;</ph>.indices<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の中の一要素でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be an element of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String(unicode<ph x="6">&lt;w6/&gt;</ph>Scalars).utf16<ph x="7">&lt;w7/&gt;</ph>.indices<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String(unicode<ph x="6">&lt;w6/&gt;</ph>Scalars).utf16<ph x="7">&lt;w7/&gt;</ph>.indices<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の要素でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be an element in <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String(utf16).utf8<ph x="6">&lt;w6/&gt;</ph>.indices<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String(utf16).utf8<ph x="6">&lt;w6/&gt;</ph>.indices<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の中の一要素でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be an element of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String(unicode<ph x="6">&lt;w6/&gt;</ph>Scalars).utf8<ph x="7">&lt;w7/&gt;</ph>.indices<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String(unicode<ph x="6">&lt;w6/&gt;</ph>Scalars).utf8<ph x="7">&lt;w7/&gt;</ph>.indices<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の要素でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Any<ph x="5">&lt;w5/&gt;</ph>Object<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> can be used as the concrete type for an instance of any class, class type, or class-only protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Any<ph x="5">&lt;w5/&gt;</ph>Object<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は、あらゆるクラス、クラス型、またはクラス専用プロパティのインスタンスに対する具象型として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Default<ph x="5">&lt;w5/&gt;</ph>Precedence<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> has no associativity and a precedence immediately higher than <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Ternary<ph x="8">&lt;w8/&gt;</ph>Precedence<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Default<ph x="5">&lt;w5/&gt;</ph>Precedence<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Ternary<ph x="8">&lt;w8/&gt;</ph>Precedence<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>のすぐ上の結合性と優先順位を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Shipping<ph x="5">&lt;w5/&gt;</ph>Options<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> includes a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>raw<ph x="8">&lt;w8/&gt;</ph>Value<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> property of type <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Int<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> that stores the bit mask of available shipping options.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Shipping<ph x="5">&lt;w5/&gt;</ph>Options<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は、型<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Int<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>の<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>raw<ph x="8">&lt;w8/&gt;</ph>Value<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>プロパティを含みます、それは可能な出荷オプションのビットマスクを格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Static<ph x="5">&lt;w5/&gt;</ph>String<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> provides limited, pointer-based access to its contents, unlike Swift’s more commonly used <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>String<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Static<ph x="5">&lt;w5/&gt;</ph>String<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は、制限された、ポインタに基づくアクセスをそれの内容に提供します、Swiftのより一般的な<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>String<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> 型とは違って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>T<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> may have a lower minimal alignment that trades runtime performance for space efficiency.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>T<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は、空間能率に対する実行時性能と引き換えに、より低い極小の引数を持ってもかまいません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> must not be negative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は負数であってはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>element<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is contained in the range if it is between the two bounds or equal to either bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>element<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は、それが２つの境界の間またはどちらかの境界と等しいならば、その範囲に含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>max<ph x="5">&lt;w5/&gt;</ph>Splits<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>max<ph x="5">&lt;w5/&gt;</ph>Splits<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>element<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is contained in the range if it is greater than or equal to the lower bound and less than the upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>element<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が範囲の中のに含まれるのは、それが下方境界より大きいか等しく上方境界より少ない場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> must not be negative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は、負数であってはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>unicode<ph x="6">&lt;w6/&gt;</ph>Scalar<ph x="7">&lt;w7/&gt;</ph>Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> must be an element in <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>String(utf16).unicode<ph x="10">&lt;w10/&gt;</ph>Scalar<ph x="11">&lt;w11/&gt;</ph>Index<ph x="12">&lt;w12/&gt;</ph>.indices<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>unicode<ph x="6">&lt;w6/&gt;</ph>Scalar<ph x="7">&lt;w7/&gt;</ph>Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>String(utf16).unicode<ph x="10">&lt;w10/&gt;</ph>Scalar<ph x="11">&lt;w11/&gt;</ph>Index<ph x="12">&lt;w12/&gt;</ph>.indices<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>の中の一要素でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>unicode<ph x="6">&lt;w6/&gt;</ph>Scalar<ph x="7">&lt;w7/&gt;</ph>Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> must be an element of <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>String(utf8).unicode<ph x="10">&lt;w10/&gt;</ph>Scalars<ph x="11">&lt;w11/&gt;</ph>.indices<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>unicode<ph x="6">&lt;w6/&gt;</ph>Scalar<ph x="7">&lt;w7/&gt;</ph>Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>String(utf8).unicode<ph x="10">&lt;w10/&gt;</ph>Scalars<ph x="11">&lt;w11/&gt;</ph>.indices<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>の中の一要素でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Unsafe<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> provides no automated memory management or alignment guarantees.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Unsafe<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は、自動メモリ管理またはアラインメント保証を提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>for<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>-<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>in<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> loops are safe in this regard.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>for<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>-<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>in<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>ループはこの点に関して安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>n<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> may be positive, negative, or zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>n<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は、正、負、またはゼロが許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Unsafe<ph x="8">&lt;w8/&gt;</ph>Mutable<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> provides no automated memory management or alignment guarantees.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Unsafe<ph x="8">&lt;w8/&gt;</ph>Mutable<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は、自動メモリ管理またはアラインメント保証を提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>128<ph x="9">&lt;w9/&gt;</ph>.25<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> is rounded to <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>128<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>, which is not representable as an <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Int8<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> instance, triggering a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>128<ph x="9">&lt;w9/&gt;</ph>.25<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>は、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>128<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>へ丸められます、それは<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Int8<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>インスタンスによって表現可能ではなく、実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Optional<ph x="9">&lt;w9/&gt;</ph>.some(Wrapped)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> stores a wrapped value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Optional<ph x="9">&lt;w9/&gt;</ph>.some(Wrapped)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>は、あるラップされた値を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Binary<ph x="10">&lt;w10/&gt;</ph>Floating<ph x="11">&lt;w11/&gt;</ph>Point<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> is implemented in the standard library by <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Float<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>, <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Double<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>, and <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>Float80<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> where available.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Binary<ph x="10">&lt;w10/&gt;</ph>Floating<ph x="11">&lt;w11/&gt;</ph>Point<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>は、標準ライブラリにおいて<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Float<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>、<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Double<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>、そして利用可能なところでは<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>Float80<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>によって実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Range<ph x="10">&lt;w10/&gt;</ph>Replaceable<ph x="11">&lt;w11/&gt;</ph>Collection<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> provides default implementations of all its other methods using this initializer and method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Range<ph x="10">&lt;w10/&gt;</ph>Replaceable<ph x="11">&lt;w11/&gt;</ph>Collection<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>は、それの他のメソッドすべての省略時の実装をこのイニシャライザとメソッドを使って提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Expressible<ph x="11">&lt;w11/&gt;</ph>By<ph x="12">&lt;w12/&gt;</ph>Nil<ph x="13">&lt;w13/&gt;</ph>Literal<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> conformance for types that use <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>nil<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> for other purposes is discouraged.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>nil<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>を他の目的に使う型のための<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Expressible<ph x="11">&lt;w11/&gt;</ph>By<ph x="12">&lt;w12/&gt;</ph>Nil<ph x="13">&lt;w13/&gt;</ph>Literal<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>準拠は、 推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Initialized<ept i="0">&lt;/e0&gt;</ept> memory has a value that can be read using a pointer’s <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>pointee<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> property or through subscript notation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>初期化済<ept i="0">&lt;/e0&gt;</ept>メモリは、<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>pointee<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロパティまたは添え字表記法を使って読み出し可能な値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Signed<ept i="0">&lt;/e0&gt;</ept> integer types can represent both positive and negative values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>符号付き<ept i="0">&lt;/e0&gt;</ept>整数型は、正および負の値の両方を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="1" x="1">&lt;e1&gt;</bpt>Unsigned<ept i="1">&lt;/e1&gt;</ept> integer types can represent only nonnegative values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;e1&gt;</bpt>符号なし<ept i="1">&lt;/e1&gt;</ept>整数型は、非負数のみ表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>Required<ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>必須<ept i="0">&lt;/s0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A  nonowning collection interface to the bytes in a region of memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリのいち領域中のバイトに対する非所有コレクションインターフェイス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A 16-bit signed integer value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>16ビット符号つき整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A 16-bit unsigned integer value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>16ビット符号なし整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A 32-bit floating point type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>32ビット浮動小数点型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A 32-bit signed integer value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>32ビット符号つき整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A 32-bit unsigned integer value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>32ビット符号なし整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A 64-bit floating point type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>64ビット浮動小数点型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Closed<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance contains both its lower and upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Closed<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、それの下方および上方境界の両方を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that can contain the same elements as this one, possibly with a simpler type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このものと同じ要素を、出来る限りより簡単な型で、含むある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> whose elements consist of those in a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Base<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> passed through a transform function returning <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Element<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、その要素は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Base<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の中のものから成り、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Element<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を返す変換関数を通して渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Closed<ph x="3">&lt;w3/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance contains both its lower bound and its upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Closed<ph x="3">&lt;w3/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、それの下側の境界とそれの上側の境界を両方とも含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Custom<ph x="2">&lt;w2/&gt;</ph>Reflectable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> class can control how its mirror will represent ancestor classes by initializing the mirror with a <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Ancestor<ph x="5">&lt;w5/&gt;</ph>Representation<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Custom<ph x="2">&lt;w2/&gt;</ph>Reflectable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クラスは、どのようにそれのミラーが先祖クラスを表すかを<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Ancestor<ph x="5">&lt;w5/&gt;</ph>Representation<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を使うことで制御できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Expression<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> can convert itself to a <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Range&lt;Bound&gt;<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> of indices within a given collection; the collection can then slice itself with that <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Range<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Expression<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、それ自身を与えられたコレクション内のインデックスの<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Range&lt;Bound&gt;<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に変換できます；そのコレクションはそれからそれ自身その<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Range<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>でスライスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> of values formed by striding over a closed interval.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある完結間隔の全体をまたいで行くことによって形成されるいくつかの値からなる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> of values formed by striding over a half-open interval.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある半開間隔の全体をまたいで行くことによって形成されるいくつかの値からなる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that can contain the same elements as this one, possibly with a simpler type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このものと同じ要素を、できる限りより簡単な型で、含む<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> whose elements consist of those in a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Base<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Sequence<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> passed through a transform function returning <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Element<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、それの要素は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Element<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を返すある変換関数を通した<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Base<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Sequence<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の中のものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Single<ph x="2">&lt;w2/&gt;</ph>Value<ph x="3">&lt;w3/&gt;</ph>Decoding<ph x="4">&lt;w4/&gt;</ph>Container<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is a container which can support the storage and direct decoding of a single non-keyed value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Single<ph x="2">&lt;w2/&gt;</ph>Value<ph x="3">&lt;w3/&gt;</ph>Decoding<ph x="4">&lt;w4/&gt;</ph>Container<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、単一非キー値のストレージおよび直接デコーディングをサポートできるコンテナです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> argument selects the first <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Child<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> with a matching label.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>引数は、一致するラベルを持つ最初の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Child<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> was parsed successfully</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がうまく構文解析された</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value indicates an unkeyed container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値は、キー付けされないコンテナを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Reversed<ph x="4">&lt;w4/&gt;</ph>Collection<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance wraps an underlying collection and provides access to its elements in reverse order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Reversed<ph x="4">&lt;w4/&gt;</ph>Collection<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスは、基礎をなすコレクションをラップして、それの要素へのアクセスを逆順で提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Reversed<ph x="4">&lt;w4/&gt;</ph>Random<ph x="5">&lt;w5/&gt;</ph>Access<ph x="6">&lt;w6/&gt;</ph>Collection<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance wraps an underlying collection and provides access to its elements in reverse order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Reversed<ph x="4">&lt;w4/&gt;</ph>Random<ph x="5">&lt;w5/&gt;</ph>Access<ph x="6">&lt;w6/&gt;</ph>Collection<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスは、基礎をなすコレクションをラップして、それの要素へのアクセスを逆順で提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instance does not contain its upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスはそれの上方の境界を含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>binade<ept i="0">&lt;/e0&gt;</ept> is a set of binary floating-point values that all have the same sign and exponent.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>binade<ept i="0">&lt;/e0&gt;</ept>は、バイナリ浮動小数点値の一揃いです、それは全てが同じ符号と指数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>decimal value<ept i="0">&lt;/e0&gt;</ept> contains the significand, a sequence of decimal digits that may include a decimal point.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>10進の値<ept i="0">&lt;/e0&gt;</ept>は仮数、小数点を含んでも良い一連の10進の桁を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>hexadecimal value<ept i="0">&lt;/e0&gt;</ept> contains the significand, either <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>0X<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>0x<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, followed by a sequence of hexadecimal digits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>16進数値<ept i="0">&lt;/e0&gt;</ept>は、仮数、<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>0X<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>0x<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>のどちらかに続く16進の桁を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>normal<ept i="0">&lt;/e0&gt;</ept> value is a finite number that uses the full precision available to values of a type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ノーマル<ept i="0">&lt;/e0&gt;</ept>値は、有限数で、ある型の値に利用可能な完全な精度を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>subnormal<ept i="0">&lt;/e0&gt;</ept> value is a nonzero number that has a lesser magnitude than the smallest normal number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>サブノーマル<ept i="0">&lt;/e0&gt;</ept>値は、非ゼロ数で、最も小さいノーマル数よりも少ない規模を持つものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>trivial type<ept i="0">&lt;/e0&gt;</ept> can be copied bit for bit with no indirection or reference-counting operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>自明な型<ept i="0">&lt;/e0&gt;</ept>は、ビット対ビットでコピーされることが、何らかの間接参照または参照カウント操作なしで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value indicating whether the Unicode scalar is an ASCII character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このユニコードスカラーがあるASCII文字であるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value indicating whether the collection is empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションが空かどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value indicating whether the instance is NaN (“not a number”).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスがNaN（非数）であるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value indicating whether the instance is a signaling NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスがsignaling NaNであるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value indicating whether the instance is equal to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスがゼロと等しいかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value indicating whether the instance is infinite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスが無限大であるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value indicating whether the instance is subnormal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスがサブノーマルであるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value indicating whether the instance’s representation is in the canonical form.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスの表現が正準形式であるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value indicating whether the range contains no elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲が何の要素も含まないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value indicating whether the static string stores a pointer to ASCII or UTF-8 code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>静的文字列がASCIIまたはUTF-8コードユニットへのポインタを格納しているかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value indicating whether this instance is finite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスが有限であるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value indicating whether this instance is normal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスがノーマルであるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value indicating whether this type is a signed integer type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型が符号付き整数型であるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value that indicates whether the dictionary is empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書が空かどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value that indicates whether the set has no elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合が要素をひとつも持たないかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value that indicates whether the set is empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合が空かどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Boolean value that is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the static string stores a pointer to ASCII code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>静的文字列がASCIIコードユニットへのポインタを格納するならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>であるブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A DoubleWidth&lt;Self&gt; value containing the high and low parts of a double-width integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２倍幅整数の高および低部分を含んでいるDoubleWidth&lt;Self&gt;値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A GUI view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>GUIの見え方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A NaN compares not equal, not greater than, and not less than every value, including itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NaNは、それ自身を含めてあらゆる値に対して等しくない、大きくない、少なくないと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A NaN passed as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> results in another NaN, with a signaling NaN value converted to quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>として渡されるNaNは、シグナルNaN値はクワイエットNaNに変換されて、別のNaNという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A NaN value may also include a payload in parentheses following the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"nan"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるNaN値はまた、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"nan"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>キーワードに続けて丸括弧の中にペイロードを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Quick Look can be created for an instance of any type by using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Playground<ph x="2">&lt;w2/&gt;</ph>Quick<ph x="3">&lt;w3/&gt;</ph>Look(reflecting:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「クイックルック」は、あらゆる型のインスタンスに対して作成されることが、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Playground<ph x="2">&lt;w2/&gt;</ph>Quick<ph x="3">&lt;w3/&gt;</ph>Look(reflecting:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを使うことで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A UTF-16 code sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-16コードシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A UTF-16 encoding of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のUTF-16符号化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A UTF-8 code sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-8コードシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A UTF-8 encoding of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のUTF-8符号化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Unicode encoding form that translates between Unicode scalar values and form-specific code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるユニコード符号化形式、それはユニコードスカラー値と形式特有のコード単位の間で翻訳します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Unicode scalar value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるユニコードスカラー値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Unicode string value that is a collection of characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコード文字列値で、いくらかの文字からなる１つのコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Uniform Resource Locator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>統一資源識別子（ユニフォームリソースロケータ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A bezier path.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ベジェパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A binary floating-point type’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>exponent<ph x="2">&lt;w2/&gt;</ph>Bit<ph x="3">&lt;w3/&gt;</ph>Count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> imposes a limit on the range of the exponent for normal, finite values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バイナリ浮動小数点型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>exponent<ph x="2">&lt;w2/&gt;</ph>Bit<ph x="3">&lt;w3/&gt;</ph>Count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、正規化数の、有限の値に対する指数の範囲に限界を課します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A bit pattern to use for the address of the new pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいポインタのアドレスのために使われるビットパターン。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A bit pattern to use for the address of the new raw pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい生のポインタのアドレスのために使われるビットパターン。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A bitwise AND operation results in a value that has each bit set to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> where <bpt i="2" x="2">&lt;e2&gt;</bpt>both<ept i="2">&lt;/e2&gt;</ept> of its arguments have that bit set to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>1<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位AND演算は、ある値という結果になります、それが各ビットを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に設定するのは、<bpt i="2" x="2">&lt;e2&gt;</bpt>両方<ept i="2">&lt;/e2&gt;</ept>のそれの引数が、そのビットを<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>1<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に設定するところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A bitwise OR operation results in a value that has each bit set to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> where <bpt i="2" x="2">&lt;e2&gt;</bpt>one or both<ept i="2">&lt;/e2&gt;</ept> of its arguments have that bit set to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>1<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位OR演算は、ある値という結果になります、それが各ビットを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に設定するのは、<bpt i="2" x="2">&lt;e2&gt;</bpt>一方または両方<ept i="2">&lt;/e2&gt;</ept>のそれの引数が、そのビットを<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>1<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に設定するところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> where <bpt i="2" x="2">&lt;e2&gt;</bpt>one or the other but not both<ept i="2">&lt;/e2&gt;</ept> of its arguments had that bit set to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>1<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位XOR演算、または排他的OR演算として知られるものは、１つの値という結果になり、それは各ビットが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に設定されます、そこにおいて<bpt i="2" x="2">&lt;e2&gt;</bpt>一方または他方しかし両方でなく<ept i="2">&lt;/e2&gt;</ept>それの引数がそのビットを<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>1<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A boolean value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A buffer into which to store the bytes from the receiver.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの中にレシーバからのバイトを格納することになるバッファ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A capitalized representation of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that is produced using the current locale.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の頭文字表現、現在のロケールを使って生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A capitalized representation of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>語頭を大文字にした表現の文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A capitalized string is a string with the first character in each word changed to its corresponding uppercase value, and all remaining characters set to their corresponding lowercase values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>語頭を大文字にした文字列は、各単語において最初の文字をそれの対応している大文字値へ変更した、そしてすべての残りの文字をそれらの対応している子文字値へ設定した文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A character view to convert to a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列へと変換されることになる文字ビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A character view’s “past the end” position—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字ビューの「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A class instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラスインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A class whose instances contain a property of type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Header<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and raw storage for an array of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, whose size is determined at instance creation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラス、そのインスタンスは型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Header<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のプロパティと、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>からなる、そのサイズがインスタンス作成時に決められる配列のための生のストレージを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closed range that forms a collection of consecutive values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>連続した値のコレクションを形成する完結範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that accepts an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>inout<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> state and returns the next element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>inout<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>状態を受け取り、そしてそのシーケンスの次の要素を返すクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that accepts an element of this collection as its argument and returns an optional value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはこのコレクションのひとつの要素をそれの引数として受け取って、ひとつのオプショナルの値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that accepts an element of this sequence as its argument and returns a sequence or collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはこのシーケンスのひとつの要素をそれの引数として受け取って、あるシーケンスまたはコレクションを返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that accepts an element of this sequence as its argument and returns an optional value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはこのシーケンスのひとつの要素をそれの引数として受け取って、ひとつのオプショナルの値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that accepts the previous sequence element and returns the next element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それは前のシーケンス要素を受け取り、次の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ph x="2">&lt;w2/&gt;</ph>Partial<ph x="3">&lt;w3/&gt;</ph>Result<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure or returned to the caller.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それは蓄積値をシーケンスのいち要素と結合して新しい蓄積値へとし、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ph x="2">&lt;w2/&gt;</ph>Partial<ph x="3">&lt;w3/&gt;</ph>Result<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャの次の呼び出しにおいて使われるか、呼び出し側に返されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that is called with the values for any duplicate keys that are encountered.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャで、出くわす何らかの重複キーに対するそれら値とともに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that processes one <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>output<ph x="2">&lt;w2/&gt;</ph>Encoding<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> code unit at a time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それは１度に１つの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>output<ph x="2">&lt;w2/&gt;</ph>Encoding<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>コードユニットを処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if its argument should be used to split the sequence; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つのクロージャ、それはそれの引数が使われてシーケンスを分割するならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that returns a key for each element in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>values<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>values<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中の各要素に対するキーを返すクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that returns an optional element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはあるオプショナルの要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes a  typed pointer to the same memory as this pointer, only bound to type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それは、型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に束縛しただけの、このポインタと同じメモリへの型付ポインタをとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes a buffer pointer to the static string’s UTF-8 code unit sequence as its sole argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それは静的文字列のもつUTF-8コード単位シーケンスへのバッファポインタをそれの唯一の引数として取るものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes a character view as its argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはある文字ビューをそれの引数として取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes a key-value pair as its argument and returns a Boolean value indicating whether the pair should be included in the returned dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー値ペアをそれの引数として取り、返される辞書にそのペアが含まれるべきかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes a mutable pointer to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>arg<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as its sole argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>arg<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への可変ポインタをそれの唯一の引数として取るクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes a mutable typed pointer to the same memory as this pointer, only bound to type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それは、型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に束縛しただけの、このポインタと同じメモリへの可変の型付ポインタをとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes a pointer to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>arg<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as its sole argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>arg<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>へのポインタをそれの唯一の引数として取るクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes a raw buffer pointer to the bytes of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>arg<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as its sole argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>arg<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のバイトへの生のバッファポインタをそれの唯一の引数として取るクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それは１つの要素を引数として取り、コレクションがその要素で分割されるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes an element as its argument and returns a Boolean value indicating whether the element should be included in the returned set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはある要素をそれの引数として取り、その要素が返される集合に含まれるべきかどうかを示すブール値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それは１つの要素をそれの引数として取り、渡された要素が合致するものであるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes an element of the collection as its argument and returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the element should be included or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはコレクションの１つの要素をそれの引数として取り、その要素が含まれるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、またはそうでなければ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes an element of the collection as its argument and returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the element should be skipped or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはコレクションの１つの要素をそれの引数として取り、その要素が省かれるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、またはそうでなければ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes an element of the sequence as a parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはシーケンスの１要素を引数として取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes an element of the sequence as its argument and returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the element should be included or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> if it should be excluded.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が含まれるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をまたはそれが除外されるべきならば<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes an element of the sequence as its argument and returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the element should be included or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が含まれるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、またはそうでなければ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes an element of the sequence as its argument and returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the element should be skipped or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> if it should be included.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が省かれるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をまたはそれが含まれるべきならば<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes an element of the sequence as its argument and returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the element should be skipped or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が省かれるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、またはそうでなければ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が合致するものかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が結果に含まれるべきかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が返される配列に含まれるべきかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ、それはこのシーケンスの１つの要素をそれの引数として取り、渡された要素が合致するものであるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes the current and new values for any duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャで、何らかの重複キーに対する現在および新しい値それぞれをとるもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that takes the unwrapped value of the instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスのアンラップされた値をとるクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that transforms a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値を変換するクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that will be immediately executed, receiving an escapable copy of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>closure<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as an argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>直ちに実行されるクロージャ、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>closure<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の脱出可能コピーを引数として受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure to execute that depends on the lifetime of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> being extended.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>延長されている<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の生涯に依存して実行するクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure with a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>CVa<ph x="2">&lt;w2/&gt;</ph>List<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter that references the arguments passed as <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>args<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>args<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>として渡される引数を参照する<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>CVa<ph x="2">&lt;w2/&gt;</ph>List<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータを持つクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure with a pointer parameter that points to a null-terminated sequence of UTF-8 code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-8コード単位のnull終端シーケンスを指し示すポインタパラメータを持つクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure with a pointer parameter that points to a null-terminated sequence of code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コード単位からなるnull終端シーケンスを指し示すポインタパラメータを持つクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure with an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Buffer<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter that points to the contiguous storage for the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャで<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Buffer<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータを持ち、それはその配列のための隣接ストレージを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure with an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter that points to the contiguous storage for the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャで<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータを持ち、それはその配列のための隣接ストレージを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure with an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Buffer<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter that points to the contiguous storage for the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャで<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Buffer<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータを持ち、それはその配列のための隣接ストレージを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure with an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter that points to the contiguous storage for the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャで<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータを持ち、それはその配列のための隣接ストレージを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure with an pointer parameter that points to a null-terminated sequence of UTF-8 code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-8コード単位からなるnull終端シーケンスを指し示すポインタパラメータを持つ、あるクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure with an pointer parameter that points to a null-terminated sequence of code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コード単位からなるnull終端シーケンスを指し示すポインタパラメータを持つ、あるクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection and its slices share the same indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションとそれのスイラスは同じインデックスを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection containing a single element of type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素をただ１つだけ含んでいるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection containing just the keys of the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書のキーだけを含んでいるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection containing just the values of the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の値だけを含んでいるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection containing the same elements as a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> collection, but on which some operations such as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>map<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>filter<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> are implemented lazily.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>コレクションと同じ要素を含んでいるあるコレクション、しかしそれの上で何らかの演算、例えば<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>map<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>や<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>filter<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が遅延に実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements to insert into the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列へ挿入されることになる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素からなるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Child<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements describing the structure of the reflected subject.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Child<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素のコレクションで、リフレクションされる主題の構造体を記述しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素からなるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection of Unicode scalar values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードスカラー値のコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection of code units encoded in the ecoding specified in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ph x="2">&lt;w2/&gt;</ph>Encoding<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ph x="2">&lt;w2/&gt;</ph>Encoding<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>において指定されたエンコーディングでエンコードされたコード単位からなるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection of indices for an arbitrary bidirectional collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>随意に２方向に辿っていくコレクションのためのインデックスのコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection of indices for an arbitrary collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>随意なコレクションのためのインデックスのコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection of indices for an arbitrary random-access collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>随意な無作為アクセスのコレクションのためのインデックスのコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection on which normally-eager operations such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>filter<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> are implemented lazily.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコレクション、それにおいては通常は先行な演算、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>filter<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、遅延に実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection or finite sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションまたは有限のシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection that contains <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements that are all <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>個の要素を含んでいるコレクション、それはすべてが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection that presents the elements of its base collection in reverse order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコレクション、それは、それの基盤コレクションの要素を逆順で提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection that represents a contiguous subrange of the collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションのもつ要素の隣接下位範囲を表すコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection that supports backward as well as forward traversal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前方にだけでなく後方へ辿っていくこともサポートするコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection that supports efficient random-access index traversal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>効率のよい無作為アクセスのインデックス探査をサポートするコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection that supports replacement of an arbitrary subrange of elements with the elements of another collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>随意の下位範囲の要素を別のコレクションの要素で置き換えることをサボートするコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection that supports subscript assignment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字を使った代入をサポートするコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection whose element type is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> but that is always empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの要素型は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>である、しかし常に空であるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection whose elements are all identical.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコレクション、その要素は全て同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection whose elements are key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの要素がキー値ペアであるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>indices<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>indices<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、そのコレクション自身に対する強い参照を保持でき、そのコレクションが非特有に参照されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>indices<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property can hold a strong reference to the collection itself, causing the collection to be nonuniquely referenced.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>indices<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、そのコレクション自身に対する強い参照を保持でき、そのコレクションが非特有に参照されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A color.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A concatenation of the elements of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素を鎖状にひとつらなりに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A concrete container that provides a view into an decoder’s storage, making the encoded properties of an decodable type accessible by keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある具体的なコンテナで、あるデコーダの持つストレージへのビューを提供します、デコーダ可能型のエンコードされたプロパティをキーによってアクセス可能にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A concrete container that provides a view into an encoder’s storage, making the encoded properties of an encodable type accessible by keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある具体的なコンテナで、あるエンコーダの持つストレージへのビューを提供します、エンコード可能型のエンコードされたプロパティをキーによってアクセス可能にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>準拠しているシーケンスでコレクションではないものは、２番目の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ループにおいて幾つかの要素からなる随意のシーケンスを生み出すことを許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A conforming type may contain a subset of values which are treated as exceptional—that is, values that are outside the domain of meaningful arguments for the purposes of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>準拠している型は、普通でないものとして扱われる値の下位集合を含むでしょう — すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルの用途のための意味のある引数の領域の外側である値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A conforming type may use any integer radix, but values other than 2 (for binary floating-point types) or 10 (for decimal floating-point types) are extraordinarily rare in practice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>準拠する型は、あらゆる整数基数を使うことができます、しかし２（バイナリ浮動小数点型に対して）または10（10進浮動小数点型に対して）より他の値は、実際には非常に稀です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A container that can support the storage and direct encoding of a single non-keyed value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単一非キー値のストレージおよび直接エンコーディングをサポートできるコンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A contiguously stored array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>隣接保管の配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A contiguously stored null-terminated UTF-8 representation of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>隣接格納されるヌル終端UTF-8表現のこの文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A custom playground Quick Look for this instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスのためのあつらえのプレイグラウンド「クイックルック」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A decimal value may also include an exponent following the significand, indicating the power of 10 by which the significand should be multiplied.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>10進の値はまた、それによって仮数が乗算されるべき10の冪を指し示す指数を、仮数に続けて含んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A decoded Unicode scalar value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デコードされたユニコードスカラー値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A decoded value of the requested type, or <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Decoder<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> does not have an entry associated with the given key, or if the value is a null value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要求された型にデコード済みの値、または<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Decoder<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が与えられたキーに関連する登録項目を持たない場合は、またはその値がnull値の場合は。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A decoded value of the requested type, or <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the value is a null value, or if there are no more elements to decode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要求された型にデコード済みの値、または<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もしその値がnull値ならば、またはもしデコードする要素がそれ以上ないならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A description of what went wrong, for debugging purposes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何がうまくいかなかったかの記述、デバッグ目的のため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A dictionary containing the keys and transformed values of this dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この辞書のキーと変換された値を含んでいる辞書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A dictionary is a type of hash table, providing fast access to the entries it contains.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書はある種のハッシュテーブルであり、それが含んでいる登録項目への高速なアクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A dictionary literal is <bpt i="0" x="0">&lt;e0&gt;</bpt>not<ept i="0">&lt;/e0&gt;</ept> the same as an instance of <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Dictionary<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> or the similarly named <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Dictionary<ph x="5">&lt;w5/&gt;</ph>Literal<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書リテラルは、<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Dictionary<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>または同じような名前を付けられる<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Dictionary<ph x="5">&lt;w5/&gt;</ph>Literal<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型のインスタンスと同じでは<bpt i="0" x="0">&lt;e0&gt;</bpt>ありません<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A dictionary literal is a comma-separated list of key-value pairs, in which a colon separates each key from its associated value, surrounded by square brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書リテラルは、「キーと値」の組（キー値ペア）のコンマ区切りのリストで角括弧で囲まれています、このキー値ペアではコロンが各キーをそれの関連値から切り離します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A dictionary literal is a simple way of writing a list of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書リテラルは、「キー値」ペアのリストを書く簡単な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A dictionary of the key-value pairs that <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Included<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> allows.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Included<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が認めるキー値ペアからなる辞書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A dictionary’s indices stay valid across additions to the dictionary as long as the dictionary has enough capacity to store the added values without allocating more buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書のインデックスは、その辞書への追加をまたいで有効なままです、加えられた値をもっとバッファを割り当てることなく格納するために辞書が十分な容量を持つ限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A double precision floating-point numeric value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>倍精度浮動小数点数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A double-precision, floating-point value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>倍精度、浮動小数点値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A dynamic plain-text Unicode string object, for use instead of a <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>String<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> variable in cases that require reference semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>動的なプレーンテキストユニコード文字列オブジェクト、参照意味論を必要とする場合に<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>String<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>変数の代わりに使うため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A flattened view of a base collection of collections.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数コレクションからなる基盤コレクションを平坦に見たもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A flattened view of the elements of this collection of collections.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数コレクションからなるこのコレクションの要素を平坦に見たもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A flattened view of the elements of this sequence of sequences.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数のシーケンスからなるこのシーケンスの要素のある平坦なビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A floating-point numeric type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A floating-point value to compare to this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と比較される浮動小数点値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A floating-point value to convert to an integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数へと変換する浮動小数点値．</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A floating-point value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある浮動小数点値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function that produces the initial <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Header<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance stored in the buffer, given the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>buffer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> object and a function that can be called on it to get the actual number of allocated elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファに格納される初期<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Header<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを生成する関数、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>buffer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>オブジェクトおよびそれの上で呼び出されて割り当てられた要素の実際の数を得る関数を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A graphical sprite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>画像スプライト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A half-open interval over a comparable type, from a lower bound up to, but not including, an upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある比較可能な型に関する間隔、下側の境界から、上側の境界までをしかし含めずに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A half-open range that forms a collection of consecutive values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>連続した値のコレクションを形成する半開範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A hash value, provided by a type’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>hash<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property, is an integer that is the same for any two instances that compare equally.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるハッシュ値、ある型の持つ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>hash<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティによって提供されるものは、１つの整数で、等しいと比較される何らかの２つのインスタンスに対して同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A hashable value to wrap.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ラップすることになるハッシュ化値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A hexadecimal value may also include an exponent following the significand, indicating the power of 2 by which the significand should be multiplied.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>16進数値はまた、それによって仮数が乗算されるべき２の冪を指し示す指数を、仮数に続けて含んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A key path from a specific root type to a specific resulting value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特定の根本の型から特定の結果値の型へのキーパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A key path that supports reading from and writing to the resulting value with reference semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果値からのよみ出し及びそれへの書き込みを参照意味論でサポートするキーパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A key path that supports reading from and writing to the resulting value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果値からのよみ出し及びそれへの書き込みをサポートするキーパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A keyed decoding container view into <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>へのキー付きデコーディングコンテナビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A lazy <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bidirectional<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> wrapper that includes the elements of an underlying collection after any initial consecutive elements that satisfy a predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延な<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bidirectional<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ラッパー、それは根底にあるコレクションのうち、ある術部を満足させる何らかの最初の連続した要素の後ろの要素らを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A lazy <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bidirectional<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> wrapper that includes the initial consecutive elements of an underlying collection that satisfy a predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延な<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bidirectional<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ラッパー、それは根底にあるコレクションのうち、ある述部を満足させる、最初の連続した要素を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A lazy <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> wrapper that includes the elements of an underlying collection after any initial consecutive elements that satisfy a predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延な<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ラッパー、それは根底にあるコレクションのうち、ある術部を満足させる何らかの最初の連続した要素の後ろの要素らを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A lazy <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> wrapper that includes the elements of an underlying collection that satisfy a predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延な<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ラッパー、それは根底にあるコレクションの要素のうち、ある術部を満足させるものを含めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A lazy <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> wrapper that includes the initial consecutive elements of an underlying collection that satisfy a predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延な<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ラッパー、それは根底にあるコレクションのうち、ある述部を満足させる、最初の連続した要素を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A lightweight collection of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー値ペアの軽量コレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A lowercase copy of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の小文字でのコピー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A lowercase version of the string that is produced using the current locale.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の小文字バージョン、現在のロケールを使って生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mapping closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>マップを行うクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mask to specify options to use for converting the receiver’s contents to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>encoding<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> (if conversion is necessary).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>レシーバの内容を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>encoding<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>へ変換するために使うオプションを指定するマスク（もし変換が必要ならば）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A member of the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合の中のひとつのメンバ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A memory location may only be bound to one type at a time, so accessing the same memory as an unrelated type without first rebinding the memory is undefined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるメモリ位置は１度に１つの型へとバインド（束縛）されるだけでしょう、なので同じメモリに関連のない型として最初にメモリ再バインドすることなしにアクセスすることは、未定義となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A memory location may only be bound to one type at a time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるメモリ位置は、一度に１つの型に束縛されるだけでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bool<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bool<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int64<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int64<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt64<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt64<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その配列を反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その辞書を反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのイテレータを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mirror that reflects the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その集合を反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mutable nonowning collection interface to the bytes in a region of memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリのいち領域中のバイトに対する可変の非所有コレクションインターフェイス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mutable pointer to the elements of an array is implicitly created when you pass the array using inout syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の要素への可変ポインタは、あなたが配列をinout構文を使って渡す時に暗黙的に作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A mutable pointer-to-ObjC-pointer argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変のpointer-to-ObjC-pointer引数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A namespace for Unicode utilities.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードユーティリティのための名前空間。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A negative value that uses the full precision of the floating-point type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>負の値、それは浮動小数点型の最大精度を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A negative, nonzero number that does not use the full precision of the floating-point type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>負の、非ゼロの数、それは浮動小数点型の最大精度を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to pass to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>super<ph x="4">&lt;w4/&gt;</ph>.init(from:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>super<ph x="4">&lt;w4/&gt;</ph>.init(from:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に渡すための新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Encoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to pass to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>super<ph x="4">&lt;w4/&gt;</ph>.encode(to:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>super<ph x="4">&lt;w4/&gt;</ph>.encode(to:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に渡すための新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Encoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new dictionary initialized with the elements of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>keys<ph x="2">&lt;w2/&gt;</ph>And<ph x="3">&lt;w3/&gt;</ph>Values<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>keys<ph x="2">&lt;w2/&gt;</ph>And<ph x="3">&lt;w3/&gt;</ph>Values<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素で初期化された新しい辞書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new dictionary with the combined keys and values of this dictionary and <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この辞書と<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のキーと値を組み合わせた新しい辞書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new empty single value container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい空の単一値コンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new empty unkeyed container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい空のキー付けされないコンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new instance initialized with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>raw<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> will be equivalent to this instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>raw<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>で初期化された新しいインスタンスは、このインスタンスに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new instance of type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, copied from the buffer pointer’s memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の新しいインスタンス、バッファポインタのもつメモリからコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new instance of type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, read from the raw bytes at <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>offset<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の新しいインスタンス、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>offset<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>で生のバイトから読み込んだもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new instance of type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>U<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, cast from <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>U<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の新しいインスタンス、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>からキャストされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new keyed encoding container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいキー付けされるエンコーディングコンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new range clamped to the bounds of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>limits<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>limits<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の境界内に制限された、新しい範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new set with the unique elements of this set and <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合と<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>との特有な要素を持つ新しい集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new unkeyed encoding container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいキー付けされないエンコーディングコンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new value that is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>amount<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> added to this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>amount<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が加えられる新しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A nil-coalescing operation unwraps the left-hand side if it has a value, or it returns the right-hand side as a default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>nil合体演算は、左手側をそれが値を持つならばアンラップします、またはそれは右手側を省略時のものとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A nil-coalescing operation unwraps the left-hand side if it has a value, or returns the right-hand side as a default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>nil合体演算は、左手側をそれが値を持つならばアンラップします、または右手側を省略時のものとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A non-escaping closure value that will be made escapable for the duration of the execution of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非脱出クロージャ値で、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャの実行の間に脱出可能にされるもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A non-owning collection interface to a buffer of elements stored contiguously in memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリ中に隣接して格納された、いくらかの要素のバッファに対する非所有コレクションインターフェイス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A non-owning collection interface to a buffer of mutable elements stored contiguously in memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリ中に隣接して格納された、可変のいくらかの要素のバッファに対する非所有コレクションインターフェイス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A nonstable sort may change the relative order of elements for which <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>are<ph x="2">&lt;w2/&gt;</ph>In<ph x="3">&lt;w3/&gt;</ph>Increasing<ph x="4">&lt;w4/&gt;</ph>Order<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not establish an order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>安定ではないソートは、それに対して<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>are<ph x="2">&lt;w2/&gt;</ph>In<ph x="3">&lt;w3/&gt;</ph>Increasing<ph x="4">&lt;w4/&gt;</ph>Order<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が順序を確立しない要素らの相対順序を変更するかもしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A nonstable sort may change the relative order of elements that compare equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>安定ではないソートは、等しいと比較される要素らの相対順序を変更するかもしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A numeric representation of the Unicode scalar.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードスカラーの数値表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A numeric value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A partial half-open interval up to, and including, an upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある上側の境界までの、そしてそれを含んでいる部分的な半開間隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A partial half-open interval up to, but not including, an upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上側の境界までの、しかしそれを含まない部分的半開間隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A partial interval extending upward from a lower bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある下側の境界から上向きに拡張する部分的な間隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A partially type-erased key path, from a concrete root type to any resulting value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある部分的な型消去キーパス、具体的な根本の型から何らかの結果値の型への。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A point.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある一点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer advanced from this pointer by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;Pointee&gt;.stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタから<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;Pointee&gt;.stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バイトだけ繰り上げられるポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer for accessing  data of a specific type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある特定の型のデータにアクセスするためのポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer for accessing and manipulating data of a specific type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある特定の型のデータにアクセスおよび操作するためのポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer offset backward from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> by <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instances of the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスだけ後方へ補われたポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer offset from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> by <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instances of the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスだけ補われたポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer offset from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> by <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instances of the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンス分だけ補われたポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer offset from this pointer by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタから<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バイトをオフセットしたポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer offset from this pointer by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタから<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>個の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型のインスタンス分だけ補われたポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer shifted backward from this pointer by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;Pointee&gt;.stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタから後ろへ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;Pointee&gt;.stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バイトだけずらされるポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer to a newly allocated region of memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しくアロケートされたメモリ領域へのポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer to a null-terminated UTF-8 code sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ヌル終端のコードシーケンスへのポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer to a null-terminated code sequence encoded in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>encoding<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>encoding<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>でエンコードされたヌル終端のコードシーケンスへのポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer to a sequence of contiguous code units in the encoding specified in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ph x="2">&lt;w2/&gt;</ph>Encoding<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, ending just before the first zero code unit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ph x="2">&lt;w2/&gt;</ph>Encoding<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>で指定のエンコーディングでの、最初のゼロコード単位の直前で終わっている隣接コード単位シーケンスへのポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer to a sequence of contiguous, UTF-8 encoded bytes ending just before the first zero byte.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初のゼロバイト直前で終わっている、隣接の、UTF-8エンコードされた幾らかのバイトに対するポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer to advance in place.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その場で進められることになるポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer to at least <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initialized instances of type <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>少なくとも<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>個の初期化された型<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のインスタンスに対するポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer to the beginning of the string’s UTF-8 encoded representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列のUTF-8符号化表現の最初の部分へのポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer to the first byte of the buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファへの最初のバイトへのポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer to the first element of the buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このバッファの最初の要素へのポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer to the memory to copy bytes from.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そこからバイトをコピーすることになるメモリへのポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer to the start of the buffer, or <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファの始まりへのポインタ、または<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer to the values to copy.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コピーされる値に対するポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Closed<ph x="3">&lt;w3/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Closed<ph x="3">&lt;w3/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Flatten<ph x="2">&lt;w2/&gt;</ph>Bidirectional<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Flatten<ph x="2">&lt;w2/&gt;</ph>Bidirectional<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Flatten<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Flatten<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Drop<ph x="3">&lt;w3/&gt;</ph>While<ph x="4">&lt;w4/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Lazy<ph x="7">&lt;w7/&gt;</ph>Drop<ph x="8">&lt;w8/&gt;</ph>While<ph x="9">&lt;w9/&gt;</ph>Bidirectional<ph x="10">&lt;w10/&gt;</ph>Collection<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Drop<ph x="3">&lt;w3/&gt;</ph>While<ph x="4">&lt;w4/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Lazy<ph x="7">&lt;w7/&gt;</ph>Drop<ph x="8">&lt;w8/&gt;</ph>While<ph x="9">&lt;w9/&gt;</ph>Bidirectional<ph x="10">&lt;w10/&gt;</ph>Collection<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Prefix<ph x="3">&lt;w3/&gt;</ph>While<ph x="4">&lt;w4/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Lazy<ph x="7">&lt;w7/&gt;</ph>Prefix<ph x="8">&lt;w8/&gt;</ph>While<ph x="9">&lt;w9/&gt;</ph>Bidirectional<ph x="10">&lt;w10/&gt;</ph>Collection<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Prefix<ph x="3">&lt;w3/&gt;</ph>While<ph x="4">&lt;w4/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Lazy<ph x="7">&lt;w7/&gt;</ph>Prefix<ph x="8">&lt;w8/&gt;</ph>While<ph x="9">&lt;w9/&gt;</ph>Bidirectional<ph x="10">&lt;w10/&gt;</ph>Collection<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF16View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF16Viewiew<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF8View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF8View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in a string instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列インスタンスの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列の中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in a string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ph x="2">&lt;w2/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ph x="2">&lt;w2/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in a string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF8View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF8View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in a string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in a string’s collection of UTF-16 code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列の持つUTF-16コード単位のコレクションの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view of the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>other<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>other<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>パラメータの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view of a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>パラメータの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view of a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A position in the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>パラメータの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A positive value that uses the full precision of the floating-point type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正の値、それは浮動小数点型の最大精度を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A positive, nonzero number that does not use the full precision of the floating-point type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正の、非ゼロの数、それは浮動小数点型の最大精度を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A possible prefix to test against this string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この文字列に対してテストすることになる可能性のある接頭辞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A possible suffix to test against this string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この文字列に対してテストすることになる可能性のある接尾辞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A predicate that returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if its first argument should be ordered before its second argument; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある述部、それはそれの最初の引数がそれの２番目の引数の前に並べられるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A predicate that returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if its two arguments are equivalent; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある述部、それはそれの２つの引数が等しいならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A predicate used to partition the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションに仕切りをするのに使われる述部。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A quiet NaN (“not a number”).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クワイエットNaN（非数）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A radix-2 (binary) floating-point type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるradix-2（バイナリ）浮動小数点型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A range of integers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数からなる範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A range of the collection’s indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションのもつインデックスのある範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A range of the range’s indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この範囲のインデックスの範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A range suitable for slicing <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライスする<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して適している範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A range to check for elements in common.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>共通の要素を調べる範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A range to compare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>比較する範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A range to convert to a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Closed<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Closed<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスへと変換するある範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A range to convert to a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Closed<ph x="3">&lt;w3/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Closed<ph x="3">&lt;w3/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスへと変換するある範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A range to convert to a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスへと変換するある範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A range to convert to a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスへ変換することになるある範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A range-replaceable collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲置換可能なコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A raw pointer for accessing and manipulating untyped data.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付けされないデータにアクセスおよび操作するための生のポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A raw pointer for accessing untyped data.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付けされないデータにアクセスするための生のポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A raw pointer to the same address as this pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタと同じアドレスに対する生のポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A raw-representable instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の表現が可能なインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A rectangle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>矩形。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A reference to compare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>比較する参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A representation of the string that is suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その文字列のひとつの表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A representation of this integer with the byte order swapped.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この整数のバイト順交換した表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A rule for rounding a floating-point number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点数を丸める為のある規則。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A second raw-representable instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第２の生の表現が可能なインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence built around an iterator of type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のイテレータに基づいて構築されるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence consisting of all the elements contained in each segment contained in some <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>シーケンスに含まれる各断片の中に含まれるいくらかの要素から成るシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence containing the same elements as a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> sequence, but on which some operations such as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>map<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>filter<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> are implemented lazily.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>シーケンスと同じ要素を含んでいるシーケンス、しかしそれの上で何らかの演算、例えば<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>map<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>や<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>filter<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が遅延に実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence containing the same elements as this one, possibly with a simpler type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このものと同じ要素を、できる限りより簡単な型で、含むシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence containing the same elements as this sequence, but on which some operations, such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>filter<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, are implemented lazily.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスと同じ要素を含んでいるシーケンス、しかしそれの上で何らかの演算、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>filter<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が遅延に実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence is a list of values that you can step through one at a time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスは値のリストで、あなたが１度に１つずつ段階処理していくことができるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(Key, Value)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> tuples to use for the new dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(Key, Value)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>タプルからなるシーケンス、新しい辞書に使うためのもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(Key, Value)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> tuples.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(Key, Value)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>タプルからなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence of Unicode scalar values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードスカラー値のシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence of characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの文字からなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence of elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの要素からなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence of pairs built out of two underlying sequences.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの根底にあるシーケンスから組み立てられるペアからなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence of pairs enumerating the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスを列挙している、ペアからなるあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence of tuple pairs, where the elements of each pair are corresponding elements of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sequence1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>sequence2<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対のタプルからなるシーケンス、そこにおいて各対の要素らは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sequence1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>sequence2<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の要素に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence of values to group into a dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書へとグループにする幾つかの値からなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence on which normally-eager operations such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>filter<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> are implemented lazily.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンス、それにおいては通常は先行な演算、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>filter<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、遅延に実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence should provide its iterator in O(1).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスはそれのイテレータをO(1)で提供すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence that can represent a contiguous subrange of the collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの要素の隣接下位範囲を表すことのできるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence that presents the elements of a base sequence of sequences concatenated using a given separator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンス、それはいくらかのシーケンスからなるある基盤となるシーケンスの要素らを、与えられたセパレータを使って連結して提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence that represents a contiguous subrange of the collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの要素の隣接下位範囲を表すシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence that starts with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and continues with every value returned by passing the previous element to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>next<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンス、それは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>で始まり、そして前の要素を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>next<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に渡すことによって返される値どれもが続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence that yields each successive value from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンス、それは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から連続した値各々をもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence to compare to this sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンス、このシーケンスと比べることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence to insert between each of this sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスの要素それぞれの間に挿入されるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence whose elements are produced via repeated applications of a closure to some mutable state.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャをある何らかの可変の状態へ繰り返し適用することでその要素が生み出されるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence whose elements can be traversed multiple times, nondestructively, and accessed by indexed subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンス、それの要素は複数回探査されることが非破壊的に可能です、そして添え字で指し示すことによってアクセスされることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence whose elements consist of the elements of some base sequence that also satisfy a given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンス、それは何らかの基盤シーケンスの要素でさらにまた与えられた述部を満足させるものから成る要素たちです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence whose elements consist of the elements that follow the initial consecutive elements of some base sequence that satisfy a given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンス、それの要素は何かの基盤シーケンスの要素で、与えられた述部を満足させる最初の連続したものらに続く要素から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sequence whose elements consist of the initial consecutive elements of some base sequence that satisfy a given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンス、それの要素は何かの基盤シーケンスのもので、与えられた述部を満足させる最初の連続した要素から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A set of the elements that <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Included<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> allows.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Included<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が許可する要素からなる集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A set of the same type as the current set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>現在の集合と同じ型の集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A set of the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じ型の集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A signaling NaN (“not a number”).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シグナルNaN（非数）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A signaling NaN sets the floating-point exception status when used in many floating-point operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シグナルNaNは、多くの浮動小数点演算において使われる時に、浮動小数点例外状態を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A signed integer value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号付き整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A signed number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号付きの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A signed, fixed-width integer type can represent values from <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>-(2 ** (bit<ph x="7">&lt;w7/&gt;</ph>Width - 1))<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> through <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>(2 ** (bit<ph x="10">&lt;w10/&gt;</ph>Width - 1)) - 1<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号付きの、固定長整数型は、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>-(2 ** (bit<ph x="7">&lt;w7/&gt;</ph>Width - 1))<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>から<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>(2 ** (bit<ph x="10">&lt;w10/&gt;</ph>Width - 1)) - 1<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>までの値を表せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A silent NaN (“not a number”) value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>silent NaN（非数）値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A single extended grapheme cluster that approximates a user-perceived character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある単一の拡張書記素クラスタで、１つのユーザ知覚文字におおよそ相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A single precision floating-point numeric value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単精度浮動小数点数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A single string can have greatly differing lengths when measured by its different views.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある単一の文字列は、それの異なるビューによって測られる時に大きく違っていることがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A single value container view into <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への単一コンテナビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A single, concatenated string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単一の、連結された文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A single-precision, floating-point value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単精度、浮動小数点値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A size.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>大きさ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A slice holds a reference to the entire storage of a larger array, not just to the portion it presents, even after the original array’s lifetime ends.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるスライスは、単にそれが提示する一部分に対してではなく、より大きな配列のストレージ全体への参照を保持します、元の配列の寿命が終わった後でさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A slice inherits the value or reference semantics of its base collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライスは、それの基盤コレクションのもつ値意味論もしくは参照意味論を継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A slice may hold a reference to the entire storage of a larger collection, not just to the portion it presents, even after the base collection’s lifetime ends.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるスライスは、単にそれが提示する一部分に対してではなく、より大きなコレクションのストレージ全体への参照を保持します、元のコレクションの寿命が終わった後でさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションのスライスは、ゼロまたはそれ以上の元のコレクションの要素を含み、元のコレクションのもつ意味論を共有できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A slice of a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のスライス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A slice of an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Contiguous<ph x="4">&lt;w4/&gt;</ph>Array<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, or <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Array<ph x="7">&lt;w7/&gt;</ph>Slice<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Contiguous<ph x="4">&lt;w4/&gt;</ph>Array<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、または<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Array<ph x="7">&lt;w7/&gt;</ph>Slice<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスの断片。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A slice stores a base collection and the start and end indices of the view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるスライス（切り取り）は、基盤コレクションおよびビューの始まりと終わりのインデックスを格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sorted array of the collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションのもつ要素からなるソートされた配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sorted array of the sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンス要素のソート済み配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サウンド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A source of text-streaming operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>テキストストリーミング操作のソース。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A static plain-text Unicode string object, for use instead of a <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>String<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> constant in cases that require reference semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>静的なプレーンテキストユニコード文字列オブジェクト、参照意味論を必要とする場合に<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>String<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>定数の代わりに使うため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A static string can store its value as a pointer to an ASCII code unit sequence, as a pointer to a UTF-8 code unit sequence, or as a single Unicode scalar value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>静的文字列は、それの値をASCIIコード単位シーケンスへのポインタとして、UTF-8コード単位シーケンスへのポインタとして、または単一のユニコードスカラー値として格納できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string is a collection of <bpt i="0" x="0">&lt;e0&gt;</bpt>extended grapheme clusters<ept i="0">&lt;/e0&gt;</ept>, which approximate human-readable characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列は、<bpt i="0" x="0">&lt;e0&gt;</bpt>拡張書記素クラスタ<ept i="0">&lt;/e0&gt;</ept>のコレクションです、それらはだいたいは人間が読むことができる文字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string is a series of characters, such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"Swift"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列は一続きの文字です、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"Swift"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string literal is a series of characters enclosed in quotes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列リテラルは、引用符に囲まれた一連の文字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string representation of the Boolean value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブール値の文字列表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string representation of the scalar.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スカラーの文字列表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string representation of the static string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>静的文字列の文字列表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string that represents the contents of the dictionary, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の内容を表すテキスト、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string that represents the contents of the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の内容を表すテキスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string that represents the contents of the set, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合の内容を表すテキスト、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string that represents the contents of the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合の内容を表すテキスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string to append.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>追加される文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string to insert between each of the elements in this sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスの要素のそれぞれの間に挿入されることになる文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string to print between each item.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各項目の間に出力する文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string to print if <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>condition<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is evaluated to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> in a playground or <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>-Onone<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> build.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>condition<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がプレイグラウンドまたは<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>-Onone<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ビルドにおいて<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に評価されるならば出力する文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string to print if <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>condition<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is evaluated to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>condition<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と等しいならば出力する文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string to print in a playground or <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-Onone<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> build.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレイグラウンドまたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-Onone<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビルドにおいて出力される文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string type designed to represent text that is known at compile time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイル時に知られるテキストを表現するために設計される文字列型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property is a collection of Unicode scalar values, the 21-bit codes that are the basic unit of Unicode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、ユニコードの基本単位である21ビットコード、ユニコードスカラー値いくつかからなるコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property is a collection of UTF-16 code units, the 16-bit encoding form of the string’s Unicode scalar values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、その文字列のもつユニコードスカラー値の16ビット符号化形式、UTF-16コード単位いくつかからなるコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property is a collection of UTF-8 code units, the 8-bit encoding form of the string’s Unicode scalar values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、その文字列のもつユニコードスカラー値の８ビット符号化形式、UTF-８コード単位いくつかからなるコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string’s UTF-16 view encodes the string’s Unicode scalar values as 16-bit integers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列のもつUTF-16ビューは、文字列のもつユニコードスカラー値を16ビット整数として符号化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string’s UTF-8 view encodes the string’s Unicode scalar values as 8-bit integers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の持つUTF-8ビューは、文字列の持つユニコードスカラー値を8ビット整数として符号化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string’s Unicode scalar values can be up to 21 bits in length.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の持つユニコードスカラー値は、長さが21ビットに至るまで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string’s data is only copied lazily, upon mutation, when more than one string instance is using the same buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つ以上の文字列インスタンスが同じバッファを使っている時、変化において、ある文字列の持つデータは遅延にのみコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string’s “past the end” position—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence leaving off the last element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスの最後の要素を取り除いたあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence leaving off the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数の要素を取り去ったシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence of the initial, consecutive elements that satisfy <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を満たす冒頭の、隣接する要素からなる下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence starting after the first element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスの最初の要素の後から始まるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence starting after the initial, consecutive elements that satisfy <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を満たす冒頭の、隣接する要素の後で始まる下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence starting after the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数の要素の後から始まる下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence starting at the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>位置から始まる下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence starting at the beginning of this collection with at most <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Length<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションの先端で始まる多くとも<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Length<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素の下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence starting at the beginning of this sequence with at most <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Length<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスの先端で始まる多くとも<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Length<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素の下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence terminating at the end of the collection with at most <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Length<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの末端で終わっていて多くとも<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Length<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素を持つ下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence terminating at the end of this sequence with at most <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Length<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの末端で終わる多くとも<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Length<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素の下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence that leaves off <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements from the end.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある下位シーケンス、それは終わりから<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素を取り除いたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence that leaves off the specified number of elements at the end.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数の要素が末尾から無くなっているシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence up to, and including, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>位置に至るまでの、そしてそれを含む、下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subsequence up to, but not including, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>位置に至るまでの、しかしそれを含まないシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A substring holds a reference to the entire storage of the string it came from, not just to the portion it presents, even when there is no other reference to the original string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位文字列はそれが由来する文字列のストレージ全体への参照を保持します、それが存在する部分に対してだけではありません、本来の文字列への他の参照が存在しないときでさえもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A substring to convert to a standalone <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある下位文字列を独立した<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A suggestion of how a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mirror<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>subject<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is to be interpreted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのように<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mirror<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の持つ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>subject<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が解釈されるようになるかの提案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of the Boolean value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブール値のテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of the Unicode scalar.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードスカラーのテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of the array and its elements, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列とそれの要素のテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of the array and its elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列とそれの要素のテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of the buffer, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのバッファのテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of the character, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その文字のテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of the identifier, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その識別子のテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of the pointer, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのポインタのテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of the range, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲のテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of the range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲のテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of the static string, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>静的文字列のテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of the value, or <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その値のテキスト表現、または<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of the value, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その値のテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of the value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その値のテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of this instance, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのインスタンスのテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of this instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスのテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A textual representation of this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値のテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A third value to compare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>比較する３番目の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A trivial type can be copied bit for bit with no indirection or reference-counting operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自明な型は、ビット対ビットでコピーされることが、何らかの間接参照または参照カウント操作なしで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A trivial type can be copied with just a bit-for-bit copy without any indirection or reference-counting operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自明な型は、単にビット対ビットコピーでコピーされることが、何らかの間接的または参照カウント操作なしで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A tuple containing the quotient and remainder of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>dividend<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> divided by <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>dividend<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>で除算した商と余りを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A tuple containing the quotient and remainder of this value divided by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によって除算されたこの値の商と余りを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A tuple containing the result of the addition along with a flag indicating whether overflow occurred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加算の結果とそれだけでなくオーバーフローがその演算において起こったかどうかを示すフラグを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A tuple containing the result of the division along with a flag indicating whether overflow occurred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>除算の結果とそれだけでなくオーバーフローがその演算において起こったかどうかを示すフラグを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A tuple containing the result of the multiplication along with a flag indicating whether overflow occurred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>乗算の結果とそれだけでなくオーバーフローがその演算において起こったかどうかを示すフラグを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A tuple containing the result of the subtraction along with a flag indicating whether overflow occurred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>減算の結果とそれだけでなくオーバーフローがその演算において起こったかどうかを示すフラグを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A tuple of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素からなるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A tuple of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素のタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A tuple of the lower and upper bounds of the range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この範囲の下方および上方境界からなるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A tuple with the new string and a Boolean value that indicates whether any repairs were made.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい文字列と、あらゆる修復がなされたかどうかを指し示すブール値を持つタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A two-element tuple with the key and value corresponding to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に該当するキーと値を持つ２要素タプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type for propagating an unmanaged object reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある管理されないオブジェクト参照を伝達するための型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type for which the conforming type provides a containment test.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型、それに対して準拠しているが格納テストを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type representing an error value that can be thrown.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スローされることが可能なあるエラー値を表している型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be compared for value equality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値等式によって比較される型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be compared using the relational operators <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&lt;=<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>&gt;=<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>&gt;<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関係演算子<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&lt;=<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>&gt;=<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、そして<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>&gt;<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を使って比較されるある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be converted to and from an associated raw value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある関連値型へおよびそれから変換できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be initialized by string interpolation with a string literal that includes expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくらかの式を含むある文字列リテラルを使う文字列補間によって初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be initialized using a dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある辞書リテラルを使って初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be initialized using an array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列リテラルを使って初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be initialized using the nil literal, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>nilリテラル、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be initialized with a floating-point literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある浮動小数点リテラルを使って初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be initialized with a string literal containing a single Unicode scalar value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単一のユニコードスカラー値を含んでいるある文字列リテラルで初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be initialized with a string literal containing a single extended grapheme cluster.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ただ１つの拡張書記素クラスタを含んでいるある文字列リテラルを使って初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be initialized with a string literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列リテラルを使って初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be initialized with an integer literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数リテラルで初期化できるある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be initialized with the Boolean literals <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブールリテラル<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使って初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be represented as a string in a lossless, unambiguous way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるロスレスの、曖昧さのない方法で、文字列として表できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be the target of text-streaming operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>テキストストリーミング操作のターゲットであることができる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can be used as a key for encoding and decoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エンコーディングとデコーディングのためのキーとして使われる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can convert itself into and out of an external representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それ自身を外部表現へとそしてそれをもとに変換できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can decode itself from an external representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それ自身が外部表現からデコードできる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can decode values from a native format into in-memory representations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値をネイティブ形式からインメモリ表現へとデコードできる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can encode itself to an external representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それ自身を外部表現へとエンコードできる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can encode values into a native format for external representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値を外部表現のためにネイティブ形式へとエンコードできる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can represent a string as a collection of characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列を文字のコレクションとして表すことができる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can represent any written exponent.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの書かれた指数を表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can represent both positive and negative values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正と負の値の両方を表せる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that can represent the absolute value of any possible value of the conforming type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>準拠する型の何らかの可能な値の絶対値を表すことのできる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> can choose how to respond when this method is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠する型は、このメソッドが呼ばれた時どのような応答をするか選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Floating<ph x="2">&lt;w2/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol provides the value for <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>pi<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> at its best possible precision.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Floating<ph x="2">&lt;w2/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>pi<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に対する値をそれの最もよい可能な精度で提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that explicitly supplies its own mirror, but whose descendant classes are not represented in the mirror unless they also override <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>custom<ph x="2">&lt;w2/&gt;</ph>Mirror<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>明示的にそれ独自のMirrorを提供するある型、しかしそれの子孫クラスはそれらがまた<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>custom<ph x="2">&lt;w2/&gt;</ph>Mirror<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をオーバーライドしない限りはMirrorで表現されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that explicitly supplies its own mirror.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>明示的にそれ自身のMirrorを提供する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that explicitly supplies its own playground Quick Look.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>明示的にそれ自身のプレイグラウンド「クイックルック」を提供する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that iterates over a collection using its indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコレクション全体に渡ってそれのインデックスを使って繰り返し処理する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that presents a mathematical set interface to a bit set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数学的なセットインターフェイスをビットセットに与える型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that provides a view into a decoder’s storage and is used to hold the encoded properties of a decodable type in a keyed manner.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型で、あるデコーダの持つストレージへのビューを提供し、そしてデコーダ可能型のエンコードされたプロパティをキー流儀で保持するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that provides a view into a decoder’s storage and is used to hold the encoded properties of a decodable type sequentially, without keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型で、あるデコーダの持つストレージへのビューを提供し、そしてデコーダ可能型のエンコードされたプロパティを順次的に、キーなしで保持するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that provides a view into an encoder’s storage and is used to hold the encoded properties of an encodable type in a keyed manner.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型で、あるエンコーダの持つストレージへのビューを提供し、そしてエンコード可能型のエンコードされたプロパティをキー流儀で保持するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that provides a view into an encoder’s storage and is used to hold the encoded properties of an encodable type sequentially, without keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型で、あるエンコーダの持つストレージへのビューを提供し、そしてエンコード可能型のエンコードされたプロパティを順次的に、キーなしで保持するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that provides an integer hash value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある整数ハッシュ値を提供する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that provides mathematical set operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数学的な集合演算を提供する型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that provides sequential, iterated access to its elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>順次的な、繰り返されるアクセスをそれの要素に提供するある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that provides subscript access to its elements, with bidirectional index traversal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>二方向性のインデックス探査で、それの要素に対する添え字アクセスを提供するある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that provides subscript access to its elements, with forward index traversal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前方インデックス探査で、それの要素に対する添え字アクセスを提供するある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that provides subscript access to its elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの要素にアクセスする添え字を提供するある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that provides the collection’s iteration interface and encapsulates its iteration state.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのコレクションの持つ反復インターフェイスを提供してそれの反復状態をカプセル化するある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that provides the sequence’s iteration interface and encapsulates its iteration state.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのシーケンスの持つ反復インターフェイスを提供してそれの反復状態をカプセル化するある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents a Boolean literal, such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bool<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブールリテラルを表すある型、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bool<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents a Unicode scalar literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードスカラーリテラルを表すある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents a floating-point literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点リテラルを表すある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents a position in the range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲の中のある位置を表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents a string literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列リテラルを表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents a subsequence of some of the sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのシーケンスのもつ要素の幾つかからなる下位シーケンスを表すある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents a valid position in the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>有効な位置をそのコレクションにおいて表している型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents an extended grapheme cluster literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張書記素クラスタリテラルを表すある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents an integer literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある整数リテラルを表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents either a wrapped value or <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the absence of a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ラップされた値または、値の不在、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のどちらかを表すある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents the distance between two pointers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのポインタの間の隔たりを表すある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents the encoded exponent of a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値のエンコードされた指数を表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents the encoded significand of a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値のエンコードされた仮数を表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents the indices that are valid for subscripting the collection, in ascending order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>昇順での、コレクションの添え字として有効なインデックスを表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents the number of steps between a pair of indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一対のインデックスの間の段階数を表すある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that represents the number of steps between two <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ph x="2">&lt;w2/&gt;</ph>.Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> values, where one value is reachable from the other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一方の値が他方から到達可能であるところの２つの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ph x="2">&lt;w2/&gt;</ph>.Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値の間の段階数を表すある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that supplies the values of a sequence one at a time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンスに属する値を１度に１つ提供する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type that supports replacement of an arbitrary subrange of elements with the elements of another collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>随意の下位範囲の要素を別のコレクションの要素で置き換えることをサボートする型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type which can be used to slice a collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションをスライスするために使われるある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type whose instances can produce the elements of this sequence, in order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型、それのインスタンスがこのシーケンスの要素を順序正しく生み出すもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type with a customized textual representation suitable for debugging purposes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デバッグ目的に都合がよいようにカスタマイズされた原文の表現を持つ型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type with a customized textual representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>カスタマイズされた原文の表現を持つ型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type-erased hashable value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型消去ハッシュ化値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type-erased iterator of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の型消去イテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type-erased key path, from any root type to any resulting value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型消去キーパス、何らかの根本の型から何らかの結果値の型への。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type-erased wrapper over any collection with indices that support bidirectional traversal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２方向に辿っていくことをサポートするインデックスを持つあらゆるコレクションを覆う型消去ラッパー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type-erased wrapper over any collection with indices that support forward traversal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前へ辿っていくことをサポートするインデックスを持つあらゆるコレクションを覆う型消去ラッパー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type-erased wrapper over any collection with indices that support random access traversal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無作為アクセスで辿っていくことをサポートするインデックスを持つあらゆるコレクションを覆う型消去ラッパー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A typed pointer to the memory referenced by this raw pointer, offset by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index * Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;T&gt;.stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この生の値によって参照されるメモリに対する型付ポインタ、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index * Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;T&gt;.stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バイトによってオフセットされたもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A typed pointer to the memory referenced by this raw pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この生のポインタによって参照されるメモリへの型付ポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A typed pointer to the newly bound memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しく束縛されたメモリへの型付ポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A typed pointer to the same memory as this raw pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この生のポインタと同じメモリに対する型付ポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type’s size does not include any dynamically allocated or out of line storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型の大きさは、あらゆる動的にアロケートされるおよび慣行に合わないストレージを含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A unique identifier for a class instance or metatype.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラスインスタンスまたはメタタイプのための固有な識別子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A user-defined key for providing context during encoding and decoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エンコーディングおよびデコーディングの間にコンテキストを提供するためのユーザ定義のキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A valid buffer class is non-<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>@objc<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, with no declared stored properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>有効なバッファクラスは、非<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>@objc<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>で、宣言された保存プロパティを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A valid index of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この配列の有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A valid index of the character view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字ビューの有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A valid index of the collection to use as a limit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>限度として使うためのコレクションの有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションのひとつの有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A valid index of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A valid index of the view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このビューの有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value equal to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+infinity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+infinity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に等しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value equal to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-infinity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-infinity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に等しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value equal to zero with a negative sign.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>負の符号を持つゼロに等しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value equal to zero with a positive sign.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正の符号を持つゼロに等しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value from which to use the magnitude.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そこからの値が規模に使われることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value from which to use the sign.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それからの値が符号に使われることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value less than or equal to the number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションの中の要素の数より少ないか等しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value less than or equal to the number of elements in the sequence, calculated nondestructively.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの要素数より少ないか等しい値、非破壊的に計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value of <bpt i="0" x="0">&lt;e0&gt;</bpt>NaN<ept i="0">&lt;/e0&gt;</ept> contains the string <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>"nan"<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, case insensitive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>NaN<ept i="0">&lt;/e0&gt;</ept>の値は、文字列<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>"nan"<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を含みます、大文字小文字に影響されずに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value of <bpt i="0" x="0">&lt;e0&gt;</bpt>infinity<ept i="0">&lt;/e0&gt;</ept> contains one of the strings <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>"inf"<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>"infinity"<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, case insensitive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>無限大<ept i="0">&lt;/e0&gt;</ept>の値は、文字列<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>"inf"<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>"infinity"<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>のうちの１つを含みます、大文字小文字に影響されずに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value of the requested type, if present for the given key and convertible to the requested type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要請された型の値、もし与えられたキーに対して存在して要請された型に変換可能ならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value of the requested type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要請された型の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value representative of the type to describe.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>描写することになる型の典型であるある値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value stored into a subscript of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance must subsequently be accessible at that same position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスのある添え字へと格納される値は、その後にその同じ位置でアクセス可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value to calculate the distance to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それへの隔たりを計算されるある値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value to compare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>比較する値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value to convert to this type of integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型の整数に変換される値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value to match against <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>とマッチさせることになる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value to use as a default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時のものとして使うための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value to use as the big-endian representation of the new integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい整数のビッグエンディアン表現として使う値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value to use as the little-endian representation of the new integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい整数のリトルエンディアン表現として使う値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value to use as the source of the new instance’s binary representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいインスタンスの持つバイナリ表現のソースとして使うための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value type whose instances are either <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値型、そのインスタンスは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>か<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>floating<ph x="2">&lt;w2/&gt;</ph>Point<ph x="3">&lt;w3/&gt;</ph>Class<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property describes its “class” as described by the <bpt i="4" x="4">&lt;a4&gt;</bpt>IEEE 754 specification<ept i="4">&lt;/a4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>floating<ph x="2">&lt;w2/&gt;</ph>Point<ph x="3">&lt;w3/&gt;</ph>Class<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、それの“class”を<bpt i="4" x="4">&lt;a4&gt;</bpt>IEEE 754仕様<ept i="4">&lt;/a4&gt;</ept>で記述される通りに記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A variadic list of elements of the new array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい配列の要素からなる可変長引数リスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A variadic list of elements of the new set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい集合の要素からなる可変長引数リスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A view into a subsequence of elements of another collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある見方、別のコレクションのいくらかの要素からなる下位シーケンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A view of a dictionary’s keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書のもつキーのあるビュー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A view of a dictionary’s values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書のもつ値のあるビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A view of a string’s contents as a collection of UTF-16 code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列の内容のひとつの見方、いくらかのUTF-16コード単位のコレクションとして。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A view of a string’s contents as a collection of UTF-8 code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列の内容のひとつの見方、いくらかのUTF-8コード単位のコレクションとして。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A view of a string’s contents as a collection of Unicode scalar values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列の内容のひとつの見方、いくらかのユニコードスカラー値のコレクションとして。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A view of a string’s contents as a collection of characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列の内容のひとつの見方、いくらかの文字のコレクションとして。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A view of the string’s contents as a collection of characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字のコレクションとしてのその文字列のもつ内容のあるビュー（見方）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A view onto this collection that provides lazy implementations of normally eager operations, such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>filter<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションのある見方で、それは通常は先行な演算、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>filter<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>などの遅延な実装を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A word is any sequence of characters delimited by spaces, tabs, or line terminators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単語は、空白、タブ、または行終端子によって区切られた何らかの文字の連なりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A word-aligned buffer pointer covering a region of memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ワードアラインされたバッファポインタ、あるメモリ領域に変換されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A wrapper around an opaque C pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>不透明Cポインターの周りのラッパー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A wrapper over an underlying index that hides the specific underlying type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>根底にあるインデックスを覆うラッパー、根底にある特定の型を隠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>ASCII characters have a scalar value between 0 and 127, inclusive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ASCII文字は、０と127の間の、それらを含む、スカラー値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access a pointer to a variable in memory for explicit passing to C functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリ中のある変数へのポインタに明示的にC関数を渡すためにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance referenced by <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>により参照される<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>th element of the raw array pointed to by <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によって指し示される生の配列の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>番目の要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access to the raw argc value from C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cからの生のargc値にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access to the raw argv value from C. Accessing the argument vector through this pointer is unsafe.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生のargv値にCからアクセスします。引数ベクトルにこのポインタを通してアクセスすることは安全ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access to the swift arguments, also use lazy initialization of static properties to safely initialize the swift arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>swift引数にアクセスします、また静的プロパティの遅延初期化を使って安全にswift引数を初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses a contiguous subrange of the array’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列のもつ要素らの中のある連続した下位範囲にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses a contiguous subrange of the collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションのもついくらかの要素からなるある連続した下位範囲にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the Unicode scalar value at the given position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された位置でユニコードスカラーにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the Unicode scalar values in the given range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた範囲の中のユニコードスカラー値にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the byte at the given offset in the memory region as a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたオフセットでメモリ領域において<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値としてバイトにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the bytes in the specified memory region.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたメモリ領域においてバイトにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the character at the given position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた位置で文字にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the characters in the given range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた範囲の中の文字にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the code unit at the given position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた位置でのコード単位にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the code unit at the specified position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された位置でのコード単位にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the contiguous subrange of elements enclosed by the specified range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された範囲によって囲まれる要素からなるある連続した下位範囲にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the element at <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>での要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the element at specified position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された位置で要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the element at the given position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた位置での要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the element at the specified position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素に指定された位置でアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the element indicated by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によって指し示される要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the element with the given key, or the specified default value, if the dictionary doesn’t contain the given key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたキーを持つ要素にアクセスします、または辞書が与えられたキーを含まないならば、指定された省略時の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the instance referenced by this pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタによって参照されるインスタンスにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the key-value pair at the specified position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された位置でキー値ペアにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the member at the given position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた位置でのメンバにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the pointee at the specified offset from this pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタから指定されたオフセットでPointeeにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the subsequence bounded by the given range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた範囲によって仕切られた下位シーケンスにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accesses the value associated with the given key for reading and writing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたキーに結び付けられる値に読出しと書き込みのためにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as a type that is unrelated to the underlying memory’s bound type is undefined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基礎をなすメモリの境界型と関係のない型として<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>にアクセスすることは、未定義です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Array Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の値にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Buffer Contents</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファ内容にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Individual Elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>個々の要素にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Keys and Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーと値にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Numeric Constants</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数に関する定数にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Objective-C Methods and Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cのメソッドやプロパティへのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Slices of a Collection</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコレクションのスライスにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing String Elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列要素にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing String View Elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列ビュー要素にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Underlying Storage</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基礎をなすストレージにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing a Pointer's Memory</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインタの持つメモリにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing a Pointer’s Memory as a Different Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインタのもつメモリに異なる型としてアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing a String’s Unicode Representation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列のユニコード表現にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing a type’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>description<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property directly or using <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>String<ph x="5">&lt;w5/&gt;</ph>Convertible<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> as a generic constraint is discouraged.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>description<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティに直にアクセスすることや<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>String<ph x="5">&lt;w5/&gt;</ph>Convertible<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を総称体制約として使うことは推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing memory as type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> requires that the memory be bound to that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリに型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>としてアクセスすることは、メモリがその型に束縛されることを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing memory through the returned pointer is undefined if the memory has not been bound to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>T<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返されるポインタによってメモリにアクセスすることは、メモリが<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>T<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に束縛されていないならば未定義です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing the Raw Value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の値にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing this collection’s bytes does not bind the underlying memory to <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>UInt8<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションのもつバイトにアクセスすることは、基礎をなすメモリを<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>UInt8<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>へとバインドしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing this property in the case of a <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> value is a serious programming error and could lead to undefined behavior or a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>値の場合にこのプロパティにアクセスすることは、重大なプログラミングエラーです、そして未定義挙動または実行時エラーに至らせるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing this property when <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>has<ph x="2">&lt;w2/&gt;</ph>Pointer<ph x="3">&lt;w3/&gt;</ph>Representation<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> triggers a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>has<ph x="2">&lt;w2/&gt;</ph>Pointer<ph x="3">&lt;w3/&gt;</ph>Representation<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>である時にこのプロパティにアクセスすることは、実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing this property when <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>has<ph x="2">&lt;w2/&gt;</ph>Pointer<ph x="3">&lt;w3/&gt;</ph>Representation<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>true<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> triggers a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>has<ph x="2">&lt;w2/&gt;</ph>Pointer<ph x="3">&lt;w3/&gt;</ph>Representation<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>true<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>である時にこのプロパティにアクセスすることは、実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Custom<ph x="2">&lt;w2/&gt;</ph>Debug<ph x="3">&lt;w3/&gt;</ph>String<ph x="4">&lt;w4/&gt;</ph>Convertible<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom types by defining a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>debug<ph x="7">&lt;w7/&gt;</ph>Description<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Custom<ph x="2">&lt;w2/&gt;</ph>Debug<ph x="3">&lt;w3/&gt;</ph>String<ph x="4">&lt;w4/&gt;</ph>Convertible<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>debug<ph x="7">&lt;w7/&gt;</ph>Description<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロパティを定義することによって加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Custom<ph x="2">&lt;w2/&gt;</ph>String<ph x="3">&lt;w3/&gt;</ph>Convertible<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom types by defining a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>description<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Custom<ph x="2">&lt;w2/&gt;</ph>String<ph x="3">&lt;w3/&gt;</ph>Convertible<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>description<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロパティを定義することによって加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Comparable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> conformance to your own custom types when you want to be able to compare instances using relational operators or use standard library methods that are designed for <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Comparable<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが関係演算子を使ってインスタンスの比較ができることや<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Comparable<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型のために設計される標準ライブラリメソッドを使うことを望む場合は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Comparable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>準拠をあなた独自のあつらえの型に加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add and assign</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加算して代入する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add multiple elements at the same time by passing another array or a sequence of any kind to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>append(contents<ph x="4">&lt;w4/&gt;</ph>Of:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>append(contents<ph x="4">&lt;w4/&gt;</ph>Of:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドに別の配列や何らかの種類のシーケンスを渡すことによって、複数の要素を同時に加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add the capability to be initialized with an array literal to your own custom types by declaring an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(array<ph x="2">&lt;w2/&gt;</ph>Literal:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(array<ph x="2">&lt;w2/&gt;</ph>Literal:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを宣言することによって、配列リテラルで初期化される能力をあなた独自のあつらえの型に加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add with overflow</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバーフロー加算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adding <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom types means that you can use more convenient APIs when searching for particular instances in a collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に追加することが意味するのは、あなたがより便利なAPIを特定のインスタンスをあるコレクションの中で探す時に使用できるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adding Elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素の追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adding IteratorProtocol Conformance to Your Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>IteratorProtocol準拠をあなたの型に加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adding Keys and Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーと値を追加する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adding and Removing Elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素の追加と削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Additional Considerations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>追加の考慮すべきこと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adds a new element at the end of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい要素を配列の終わりに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adds an element to the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある要素をコレクションの終わりに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adds the elements of a sequence or collection to the end of this collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンスまたコレクションに属するいくつかの要素をこのコレクションの終わりに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adds the elements of a sequence to the end of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンスに属する要素を配列の終わりに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adds the elements of the given set to the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた集合の要素をこの集合に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adds the given element to the option set if it is not already a member.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた要素を、それがすでにメンバでないならばオプションセットに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adds the product of the two given values to this value in place, computed without intermediate rounding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの与えられた値の積をこの値にその場で加えます、中間の丸めなしで計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adds two values and produces their sum, rounded to a representable value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値を加算してそれらの合計を生成します、表現可能な値へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adds two values and produces their sum.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値を加算してそれらの合計を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adds two values and stores the result in the left-hand-side variable, rounded to a representable value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値を加算して、結果を左手側の変数に格納します、表現可能な値へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adds two values and stores the result in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値を加算して、結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adopted By</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>採用先</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adopting this protocol in your custom types lets you perform set-related operations such as membership tests, unions, and intersections on those types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型をあなたのあつらえの型において採用することは、あなたにセット関連演算を行わせます、例えば、それらの型上での帰属テスト、合併、そして交叉など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Advanced Collection Topics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>先進のコレクション話題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Advanced Numerics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>先進の数値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Advances a pointer by a specified number of instances of the pointer’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるポインタを、そのポインタの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型の指定された数のインスタンスだけ進めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Advances to the next byte and returns it, or <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if no next byte exists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次のバイトへ進んでそれを返します、または次のバイトが存在しないならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Advances to the next element and returns it, or <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if no next element exists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の要素へ進んでそれを返します、または次の要素が存在しないならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After a call to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>initialize(to:<ph x="4">&lt;w4/&gt;</ph>count:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the memory referenced by this pointer is initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>initialize(to:<ph x="4">&lt;w4/&gt;</ph>count:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の呼び出しの後、このポインタによって参照されるメモリは初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After adding <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Custom<ph x="2">&lt;w2/&gt;</ph>Debug<ph x="3">&lt;w3/&gt;</ph>String<ph x="4">&lt;w4/&gt;</ph>Convertible<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance by implementing the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>debug<ph x="7">&lt;w7/&gt;</ph>Description<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> property, <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Point<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> provides its own custom debugging representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Custom<ph x="2">&lt;w2/&gt;</ph>Debug<ph x="3">&lt;w3/&gt;</ph>String<ph x="4">&lt;w4/&gt;</ph>Convertible<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠を<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>debug<ph x="7">&lt;w7/&gt;</ph>Description<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロパティを実装することによって追加後は、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Point<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>はそれ独自のあつらえのデバッグ表現を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After adding <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Custom<ph x="2">&lt;w2/&gt;</ph>String<ph x="3">&lt;w3/&gt;</ph>Convertible<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance by implementing the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>description<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> property, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Point<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> provides its own custom representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Custom<ph x="2">&lt;w2/&gt;</ph>String<ph x="3">&lt;w3/&gt;</ph>Convertible<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠を<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>description<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロパティの実装によって加えた後、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Point<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>はそれ独自のあつらえの表現を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After assigning the new value (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"Butler"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) at a specific position, that value is immediately available at that same position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい値（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"Butler"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を指定された位置で割り当てた後、その値はすぐにその同じ位置で利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After calling <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bind<ph x="2">&lt;w2/&gt;</ph>Memory(to:<ph x="3">&lt;w3/&gt;</ph>capacity:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the first four bytes of the memory referenced by <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>bytes<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> are bound to the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Int8<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> type, though they remain uninitialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bind<ph x="2">&lt;w2/&gt;</ph>Memory(to:<ph x="3">&lt;w3/&gt;</ph>capacity:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼んだ後、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>bytes<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>によって参照されるメモリの最初の４バイトは<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Int8<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>型に束縛されます、もっともそれらは未初期化のままであるけれども。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After calling <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>copy<ph x="2">&lt;w2/&gt;</ph>Bytes(from:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>source<ph x="5">&lt;w5/&gt;</ph>.count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> bytes of memory referenced by this pointer are initialized to raw bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>copy<ph x="2">&lt;w2/&gt;</ph>Bytes(from:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出した後、このポインタによって参照されるメモリの<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>source<ph x="5">&lt;w5/&gt;</ph>.count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>バイトは生のバイトに初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After calling <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>copy<ph x="2">&lt;w2/&gt;</ph>Bytes(from:<ph x="3">&lt;w3/&gt;</ph>count:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>count<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> bytes of memory referenced by this pointer are initialized to raw bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>copy<ph x="2">&lt;w2/&gt;</ph>Bytes(from:<ph x="3">&lt;w3/&gt;</ph>count:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出した後、このポインタによって参照されるメモリの<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>count<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>バイトは生のバイトに初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After calling <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>move()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the memory is uninitialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>move()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の呼び出しの後、メモリは初期化されない状態です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After calling <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>store<ph x="2">&lt;w2/&gt;</ph>Bytes(of:<ph x="3">&lt;w3/&gt;</ph>to<ph x="4">&lt;w4/&gt;</ph>Byte<ph x="5">&lt;w5/&gt;</ph>Offset:<ph x="6">&lt;w6/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the memory is initialized to the raw bytes of <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>value<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>store<ph x="2">&lt;w2/&gt;</ph>Bytes(of:<ph x="3">&lt;w3/&gt;</ph>to<ph x="4">&lt;w4/&gt;</ph>Byte<ph x="5">&lt;w5/&gt;</ph>Offset:<ph x="6">&lt;w6/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出した後、メモリは<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>value<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>の生のバイトに初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After calling <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>deinitialize(count:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, the memory is uninitialized, but still bound to the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Pointee<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>deinitialize(count:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の呼び出しの後、メモリは初期化されない状態です、しかし依然として<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Pointee<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>への境界です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After calling <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>assign(from:<ph x="8">&lt;w8/&gt;</ph>count:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, the region is initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>assign(from:<ph x="8">&lt;w8/&gt;</ph>count:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の呼び出し後、この領域は初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After calling <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>initialize(from:<ph x="8">&lt;w8/&gt;</ph>count:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, the region is initialized and the memory region <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>source..&lt;(source + count)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> is uninitialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>initialize(from:<ph x="8">&lt;w8/&gt;</ph>count:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の呼び出し後、この領域は初期化されます、そしてメモリ領域<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>source..&lt;(source + count)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>は未初期化状態にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After calling <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>initialize(from:<ph x="8">&lt;w8/&gt;</ph>count:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, the region is initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>initialize(from:<ph x="8">&lt;w8/&gt;</ph>count:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の呼び出し後、この領域は初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After calling this method on a raw pointer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the region starting at <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>p + index * Memory<ph x="4">&lt;w4/&gt;</ph>Layout&lt;T&gt;.stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and continuing up to <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>p + (index + count) * Memory<ph x="7">&lt;w7/&gt;</ph>Layout&lt;T&gt;.stride<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is bound to type <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>T<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> and initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドを生のボインタ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>で呼び出した後、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>p + index * Memory<ph x="4">&lt;w4/&gt;</ph>Layout&lt;T&gt;.stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>で始まって<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>p + (index + count) * Memory<ph x="7">&lt;w7/&gt;</ph>Layout&lt;T&gt;.stride<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>まで続く領域は、型<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>T<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>に束縛されて初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After calling this method on a raw pointer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the region starting at <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>p<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and continuing up to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>p + count * Memory<ph x="6">&lt;w6/&gt;</ph>Layout&lt;T&gt;.stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is bound to type <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>T<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> and initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドを生のボインタ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>上で呼び出した後、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>p<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>で始まって<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>p + count * Memory<ph x="6">&lt;w6/&gt;</ph>Layout&lt;T&gt;.stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>まで続く領域は、型<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>T<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に束縛されて初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After executing <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, this method rebinds memory back to the original <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>実行の後、このメソッドは、オリジナルの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型へとメモリを再束縛し戻します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After implementing the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>description<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property and declaring <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>String<ph x="5">&lt;w5/&gt;</ph>Convertible<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> conformance, the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Point<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type provides its own custom representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>description<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティの実装と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>String<ph x="5">&lt;w5/&gt;</ph>Convertible<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>準拠の宣言の後は、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Point<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型はそれ自身のあつらえの表現を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After partitioning a collection, there is a pivot index <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> where no element before <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>p<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> satisfies the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>belongs<ph x="6">&lt;w6/&gt;</ph>In<ph x="7">&lt;w7/&gt;</ph>Second<ph x="8">&lt;w8/&gt;</ph>Partition<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> predicate and every element at or after <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>p<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> satisfies <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>belongs<ph x="13">&lt;w13/&gt;</ph>In<ph x="14">&lt;w14/&gt;</ph>Second<ph x="15">&lt;w15/&gt;</ph>Partition<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションを仕切った後、あるピボットインデックス<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>があります、そこで<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>p<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の前の要素は１つも<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>belongs<ph x="6">&lt;w6/&gt;</ph>In<ph x="7">&lt;w7/&gt;</ph>Second<ph x="8">&lt;w8/&gt;</ph>Partition<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>述部を満たさず、そして<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>p<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>でのまたは後のあらゆる要素は<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>belongs<ph x="13">&lt;w13/&gt;</ph>In<ph x="14">&lt;w14/&gt;</ph>Second<ph x="15">&lt;w15/&gt;</ph>Partition<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After rebinding the memory referenced by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>uint8Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>UInt64<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, accessing that pointer’s referenced memory as a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>UInt8<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance is undefined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>uint8Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によって参照されるメモリを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>UInt64<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に再束縛する後、そのポインタの参照したメモリに<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>UInt8<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスとしてアクセスすることは未定義です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After using <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index(of:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to find the position of a particular element in a collection, you can use it to access the element by subscripting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index(of:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って特定の要素の位置をあるコレクションの中で見つけた後、あなたは添え字によって要素にアクセスするのにそれを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Algebraic Sets</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代数的集合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Aliases for Imported C Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポートされたC型に対するエイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All 100 bytes of memory must eventually be deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリの100バイトすべては、そのうち割り当てられなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All binary floating-point types have a radix of 2.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バイナリ浮動小数点型は、２の基数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All elements satisfying this predicate are ordered after all elements not satisfying it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この述部を満たす全ての要素は、それを満たさない全ての要素の後に並べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of the standard library’s integer types, such as <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Int<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>UInt32<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, conform to <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Binary<ph x="9">&lt;w9/&gt;</ph>Integer<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリの持つ整数型の全て、例えば<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Int<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>UInt32<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>などは、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Binary<ph x="9">&lt;w9/&gt;</ph>Integer<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All other values of the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Index<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type, such as the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>start<ph x="10">&lt;w10/&gt;</ph>Index<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> property of a different collection, are invalid indices for this collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Index<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型の他の値すべて、例えば異なるコレクションの<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>start<ph x="10">&lt;w10/&gt;</ph>Index<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロパティなどは、このコレクションに対する無効なインデックスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All the elements following <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are moved to close the gap.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に続く要素すべては、隙間を埋めるように移動されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All the elements following the specified position are moved to close the gap.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された位置に続く要素すべては、隙間を埋めるように移動されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All the elements following the specified position are moved up to close the gap.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された位置に続く要素すべては、隔たりを埋めるように繰り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All the keys the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has for this container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がこのコンテナに対して持っている全てのキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All values other than NaN and infinity are considered finite, whether normal or subnormal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NaNと無限大の他の全ての値は、ノーマルまたはサブノーマルかにかかわらず、有限と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Allocate and manage memory manually.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリを手動でアロケートして管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Allocates uninitialized memory for the specified number of instances of type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の指定された数のインスタンスに対して初期化されないメモリをアロケートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Allocates uninitialized memory with the specified size and alignment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>未初期化メモリを指定された大きさとアライメントでアロケートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Allow values of your type to be expressed using different kinds of literals.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの型の値に異なる種類のリテラルを使って表されることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Allow your custom types to be used with simple collection operations, such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>contains(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, and standard comparison operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのあつらえの型に、単純なコレクション演算、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>contains(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>など、そして標準比較演算子とともに使用させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Allows a nonescaping closure to temporarily be used as if it were allowed to escape.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非脱出クロージャに、一時的にそれが脱出することを許可されたかのように使われることを許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, a predicate can be satisfied by a range of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements or a general condition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるいは、述部は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素のある範囲またはある一般的条件によって満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, if you need to test whether <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>obj<ph x="2">&lt;w2/&gt;</ph>.get<ph x="3">&lt;w3/&gt;</ph>Integer<ph x="4">&lt;w4/&gt;</ph>Value()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> exists, use optional binding before calling the method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるいは、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>obj<ph x="2">&lt;w2/&gt;</ph>.get<ph x="3">&lt;w3/&gt;</ph>Integer<ph x="4">&lt;w4/&gt;</ph>Value()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が存在するかテストする必要があるならば、オプショナル束縛をそのメソッドを呼び出す前に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, if your type can act as its own iterator, implementing the requirements of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Iterator<ph x="2">&lt;w2/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol and declaring conformance to both <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Sequence<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Iterator<ph x="7">&lt;w7/&gt;</ph>Protocol<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> are sufficient.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるいはまた、あなたの型がそれ自身イテレータとして振る舞うならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Iterator<ph x="2">&lt;w2/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルの要件を実装することと<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Sequence<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>および<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Iterator<ph x="7">&lt;w7/&gt;</ph>Protocol<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の両方に対する準拠を宣言することで十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, to create an option set instance with multiple members, assign an array literal with multiple static members of the option set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるいはまた、複数のメンバをもつ１つのオプションセットインスタンスを作成するには、オプションセットの複数の静的メンバをもつ配列リテラルを割り当ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, use this method to sort a collection of elements that do conform to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> when you want the sort to be descending instead of ascending.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうではなくて、あなたが昇順ではなく降順でソートしたい場合は、このメソッドを使って<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠する要素からなるコレクションをソートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, you can access the same memory as a different type without rebinding through untyped memory access, so long as the bound type and the destination type are trivial types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、あなたは同じメモリに異なる型として再束縛することなしにアクセスすることが型なしメモリアクセスを通して可能です、束縛される型と行き先の型が自明型である限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, you can use Swift’s <bpt i="0" x="0">&lt;e0&gt;</bpt>implicit bridging<ept i="0">&lt;/e0&gt;</ept> to pass a pointer to an instance or to the elements of an array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるいはまた、あなたはSwiftの<bpt i="0" x="0">&lt;e0&gt;</bpt>暗黙的ブリッジ<ept i="0">&lt;/e0&gt;</ept>を使ってポインタをインスタンスへまたは配列の要素へと渡せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although a sequence can be consumed as it is traversed, a collection is guaranteed to be multipass: Any element may be repeatedly accessed by saving its index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスはそれが辿って行かれるとき消費されることが可能な一方、コレクションはマルチパスであることを保証されます：どんな要素もそれのインデックスを保存することによって繰り返しアクセスされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although strings in Swift have value semantics, strings use a copy-on-write strategy to store their data in a buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftにおける文字列は値意味論を持ちますが、文字列はコピーオンライト戦略を使ってそれらのデータをバッファに格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although the Swift overlay updates many Objective-C methods to return native Swift indices and index ranges, some still return instances of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSRange<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftオーバーレイが多くのObjective-Cメソッドを更新してSwift生来のインデックスおよびインデックス範囲を返すとはいえ、いくつかはまだ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSRange<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always remember to deallocate any memory that you allocate yourself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあなた自身でアロケートするメモリは何であれデアロケートするのを必ず忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>常に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>常に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always traps.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>常にトラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always use a multiple of a type’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instead of its <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>size<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> when allocating memory or accounting for the distance between instances in memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリをアロケートするまたはメモリ中のインスタンス間の隔たりを計上する場合には、常にある型の持つ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の倍数を使ってください、それの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>size<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always use the slice’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property instead of assuming that its indices start at a particular value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>常にスライスの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使ってください、それのインデックスが特定の値で始まると決めてかかるのではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always use the slice’s <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>start<ph x="13">&lt;w13/&gt;</ph>Index<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> and <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>end<ph x="16">&lt;w16/&gt;</ph>Index<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> properties instead of assuming that its indices start or end at a particular value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>常にスライスの<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>start<ph x="13">&lt;w13/&gt;</ph>Index<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>と<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>end<ph x="16">&lt;w16/&gt;</ph>Index<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>プロパティを使ってください、それのインデックスが特定の値で始まると決めてかかるのではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always zero, just like <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>常にゼロ、ちょうど<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always zero, just like <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>常にゼロ、ちょうど<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always zero, which is the index of the first byte in a nonempty buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>常にゼロ、それはある「空でない」バッファにおける最初のバイトのインデックスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An 8-bit signed integer value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>8ビット符号つき整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An 8-bit unsigned integer value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>8ビット符号なし整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Bidirectional<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance forwards its operations to a base collection having the same <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Element<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type, hiding the specifics of the underlying collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Bidirectional<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、それの操作を同じ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Element<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型を持っている基盤コレクションへと転送して、基礎をなすコレクションの特殊化を隠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance forwards its operations to a base collection having the same <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Element<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type, hiding the specifics of the underlying collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、それの操作を同じ<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Element<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型を持っている基盤コレクションへと転送して、基礎をなすコレクションの特殊化を隠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Random<ph x="3">&lt;w3/&gt;</ph>Access<ph x="4">&lt;w4/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance forwards its operations to a base collection having the same <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Element<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> type, hiding the specifics of the underlying collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Random<ph x="3">&lt;w3/&gt;</ph>Access<ph x="4">&lt;w4/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、それの操作を同じ<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Element<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>型を持っている基盤コレクションへと転送して、基礎をなすコレクションの特殊化を隠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Buffer<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is a view into memory and does not own the memory that it references.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Buffer<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、メモリに対するあるビューであり、それが参照するメモリ自体ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is a view into memory and does not own the memory that it references.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、メモリに対するある見方（ビュー）であり、それが参照するメモリ自体ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<it pos="begin" x="8">&lt;UInt8&gt;</it><ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance allocated with eight bytes of memory, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>uint8Pointer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, will be used for the examples below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>8バイトのメモリデアロケートされる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<it pos="begin" x="8">&lt;UInt8&gt;</it><ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンス、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>uint8Pointer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は、下の例で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Buffer<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is a view into memory and does not own the memory that it references.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Buffer<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、メモリに対するある見方（ビュー）であり、それが参照するメモリ自体ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Buffer<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is a view of the raw bytes in a region of memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Buffer<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、メモリのある領域の中の生のバイトのある見方（ビュー）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<it pos="begin" x="8">&lt;UInt8&gt;</it><ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance allocated with eight bytes of memory, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>uint8Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, will be used for the examples below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>8バイトのメモリデアロケートされる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<it pos="begin" x="8">&lt;UInt8&gt;</it><ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンス、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>uint8Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は、下の例で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is a view into memory and does not own the memory that it references.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、メモリに対するある見方（ビュー）であり、それが参照するメモリ自体ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is a view of the raw bytes in a region of memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、メモリのある領域の中の生のバイトのある見方（ビュー）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>extended grapheme cluster<ept i="0">&lt;/e0&gt;</ept> is a group of one or more Unicode code points that approximates a single user-perceived character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>拡張書記素クラスタ<ept i="0">&lt;/e0&gt;</ept>は、ひとまとめにした１つ以上のユニコードコード点です、それは単一のユーザ知覚文字におおよそ相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An all-zeros exponent is reserved for subnormals and zeros, and an all-ones exponent is reserved for infinity and NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全てゼロの指数は非正規化数とゼロのために予約されます、そして全て１の指数は無限大とNaNのために予約されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An array can store any kind of elements—from integers to strings to classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある配列は、整数から文字列まで、あるクラスであるどんなものであることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An array containing the elements of this sequence in reverse order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスの要素を逆順に含んでいる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An array containing the transformed elements of this sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスの変換済み要素を含んでいる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An array literal is a simple way of expressing a list of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列リテラルは、値のリストを表す簡単な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An array literal is not the same as an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列リテラルは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスと同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An array of arguments to convert to a C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>va_list<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数からなる配列で、C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>va_list<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ポインタに変換されることになるもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An array of subsequences, split from this collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションの要素を分割した、下位シーケンスいくらかからなる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An array of subsequences, split from this sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスの要素を分割した、下位シーケンスいくらかからなる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An array of the elements that <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Included<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> allowed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Included<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が許可する要素からなる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An array of the non-<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> results of calling <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>transform<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> with each element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの各要素で<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>transform<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を呼ぶことの非<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の結果の配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An array that is the sole owner of its storage can perform mutating operations in place.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それのストレージのただ一人のオーナーである配列は、変化を伴う操作をそこで実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An attributed string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>属性付き文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An element equal to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>new<ph x="2">&lt;w2/&gt;</ph>Member<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the set already contained such a member; otherwise, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>nil<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合がすでにそのようなメンバを含んでいるならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>new<ph x="2">&lt;w2/&gt;</ph>Member<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に等しい要素；そうでなければ、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>nil<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションのある要素は、基盤となるコレクションの中と同じスライスの中のインデックスのもとに位置を突き止められます、コレクションもスライスもスライスが作成された時からずっと変化していない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An element of a slice is located under the same index in the slice and in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライスの要素は、スライスにおいてそして基盤コレクションにおいて同じインデックス下に位置します、コレクションもスライスもスライスが作成されてから変化させられない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An element of the reflected instance’s structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リフレクションされる（自己言及、自己参照の対象の）インスタンスの持つ構造体の中のある要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An element to insert into the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合に挿入されることになる要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An element to look for in the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合において捜される要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An element to search for in the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションにおいて捜される要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An element to search for in the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合において捜される要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An empty <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance has equal lower and upper bounds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、等しい下方および上方境界を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An empty array literal alone doesn’t provide enough information for the compiler to infer the intended type of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の配列リテラルそれだけでは、コンパイラが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの意図される型を推論するのに十分な情報を提供していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An empty range has equal lower and upper bounds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の範囲は、等しい下方と上方範囲を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An encoding error was detected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エンコーディングエラーが検知された。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An enumeration of the elements of a sequence or collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスまたはコレクションの要素の列挙。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An equivalent range must be representable as an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Closed<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同等の範囲が、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Closed<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスとして表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An equivalent range must be representable as an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Closed<ph x="3">&lt;w3/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同等の範囲が、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Closed<ph x="3">&lt;w3/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスとして表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An equivalent range must be representable as an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同等の範囲が、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスとして表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An equivalent range must be representable as an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同等の範囲が、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスとして表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An error that occurs during the decoding of a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値のデコーディングの間に起こるエラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An error that occurs during the encoding of a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値のエンコーディングの間に起こるエラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An escaped textual representation of the Unicode scalar, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードスカラーのエスケープされたテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An extended-precision, floating-point value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張倍精度、浮動小数点値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An image.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>画像。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An immutable pointer to the elements of an array is implicitly created when you pass the array as an argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の要素への不変ポインタは、あなたが配列を引数として渡す時に暗黙的に作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An index offset by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> from the index <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, unless that index would be beyond <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>limit<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> in the direction of movement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>だけインデックス<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>から補われたインデックス、そのインデックスが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>limit<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を移動方向において越える場合を除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An index offset by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> from the index <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>だけインデックス<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>から補われるインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An index that traverses the same positions as an underlying index, with inverted traversal direction.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基礎をなすインデックスが指すのと同じ諸処の位置を、逆の走査順で辿っていくインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An index to compare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>比較するインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An indication of a decoding error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デコードエラーのしるし。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An indication that an overflow did occur in the operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバーフローがこの演算において実際に起こったことを指し示すもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An indication that no more Unicode scalars are available in the input.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この入力の中にこれ以上利用可能なユニコードスカラーがないしるし。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An indication that no overflow occurred in the operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバーフローがこの演算において全く起こらなかったことを指し示すもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An indicator of whether an arithmetic operation overflowed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある算術演算がオーバーフローしたかどうかを指し示すもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Enumerated<ph x="2">&lt;w2/&gt;</ph>Iterator<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> wraps a base iterator and yields successive <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Int<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> values, starting at zero, along with the elements of the underlying base iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Enumerated<ph x="2">&lt;w2/&gt;</ph>Iterator<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、基盤イテレータをラップして、連続する<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Int<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>値を、ゼロで開始して、基礎をなす基盤イテレータの要素と一緒に生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> from the given integer, or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> if the given integer does not correspond to any instance of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Self<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた整数からの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンス、または与えられた整数が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Self<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のどのインスタンスにも対応しないならば<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> from the given string, or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> if the given string does not correspond to any instance of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Self<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字列からの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンス、または与えられた文字列が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Self<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のどのインスタンスにも対応しないならば<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An instance of a class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラスのインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An instance that is expressed as a literal can also be used with this operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リテラルとして表されるインスタンスはまた、この演算子とともに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An instance to preserve until the execution of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is completed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の実行が完了するまで保護するインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An instance to temporarily access through a mutable raw buffer pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変の生のバッファポインタを通して一時的にアクセスされることになるインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An instance to temporarily access through a raw buffer pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生のバッファポインタを通して一時的にアクセスされることになるインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An instance to temporarily use via pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインタ経由で一時的に使われることになるインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An integer argument <bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept> select the <bpt i="5" x="5">&lt;e5&gt;</bpt>n<ept i="5">&lt;/e5&gt;</ept>th <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Child<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数引数<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>は、<bpt i="5" x="5">&lt;e5&gt;</bpt>n<ept i="5">&lt;/e5&gt;</ept>番目の<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Child<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An integer numeric value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An integer to compare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>比較する整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An integer to convert to this type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型へと変換する整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An integer to convert.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変換する整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An integer type that can represent both positive and negative values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正および負の値の両方を表すことができる整数型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An integer type that can represent only nonnegative values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非負値だけを表すことができる整数型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An integer type that uses a fixed size for every instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆるインスタンスに対して固定された大きさを使う整数型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An integer type with a binary representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バイナリ表現での整数型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An integer value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An interval over a comparable type, from a lower bound up to, and including, an upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある比較可能な型に関する間隔、下側の境界から、上側の境界までを含めて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Stride<ph x="2">&lt;w2/&gt;</ph>Through&lt;Element&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Stride<ph x="2">&lt;w2/&gt;</ph>Through&lt;Element&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のためのイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Stride<ph x="2">&lt;w2/&gt;</ph>To&lt;Element&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Stride<ph x="2">&lt;w2/&gt;</ph>To&lt;Element&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のためのイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Zip2Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Zip2Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のためのイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator for the elements in the buffer referenced by an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Buffer<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Unsafe<ph x="6">&lt;w6/&gt;</ph>Mutable<ph x="7">&lt;w7/&gt;</ph>Buffer<ph x="8">&lt;w8/&gt;</ph>Pointer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Buffer<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Unsafe<ph x="6">&lt;w6/&gt;</ph>Mutable<ph x="7">&lt;w7/&gt;</ph>Buffer<ph x="8">&lt;w8/&gt;</ph>Pointer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>によって参照されるバッファの中の要素のためのイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator of code units to be translated, encoded as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>input<ph x="2">&lt;w2/&gt;</ph>Encoding<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>翻訳されることになるいくらかのコードユニットからなるあるイテレータ、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>input<ph x="2">&lt;w2/&gt;</ph>Encoding<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>としてエンコードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator over the Unicode scalars that make up a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>コレクションを作り上げているユニコードスカラーのすべてを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator over the bytes viewed by a raw buffer pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある生のバッファポインタによるビューでのバイトすべてに対するイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator over the dictionary with elements of type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(key: Key, value: Value)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(key: Key, value: Value)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素を持つ辞書のすべてを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator over the elements of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Closed<ph x="3">&lt;w3/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Closed<ph x="3">&lt;w3/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの要素のすべてを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator over the elements of this buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このパッファの要素すべてを対象としたイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator over the elements traversed by a base iterator that follow the initial consecutive elements that satisfy a given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある基盤イテレータによって辿られる要素で、与えられた述部を満足させる最初の連続した要素に続くものすべてを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator over the elements traversed by some base iterator that also satisfy a given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの基盤イテレータによって辿られるいくらかの要素でさらにまた与えられた述部を満足させるものを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator over the initial elements traversed by a base iterator that satisfy a given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある基盤イテレータによって辿られるもので、与えられた述部を満足させる最初の要素らを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator over the members of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary&lt;Key, Value&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary&lt;Key, Value&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のメンバーすべてを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator over the members of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set&lt;Element&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set&lt;Element&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のメンバーすべてを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator over this collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションのもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素すべてを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator that never produces an element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>決して要素を生成しないイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator that presents the elements of the sequences traversed by a base iterator, concatenated using a given separator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるイテレータ、それは基盤イテレータによって辿っていかれるいくらかのシーケンスに属する要素らを、与えられたセパレータを使って連結して提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator that produces one or fewer instances of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスを１つまたは少数生み出すイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator that produces the elements contained in each segment produced by some <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> Iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イテレータによって生成される各断片の中に含まれるいくらかの要素を生成するイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An iterator to type-erase.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型消去することになるイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An object representing a dynamic collection of key-value pairs, for use instead of a <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Dictionary<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> variable in cases that require reference semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー値ペアからなる動的なコレクションを表しているオブジェクト、参照意味論を必要とする場合に<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Dictionary<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>変数の代わりに使うため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An object representing a dynamic ordered collection, for use instead of an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Array<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> variable in cases that require reference semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>静的な順序付きコレクションを表しているオブジェクト、参照意味論を必要とする場合に<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Array<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>変数の代わりに使うため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An object representing a dynamic, unordered, uniquing collection, for use instead of a <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Set<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> variable in cases that require reference semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>動的な、順序なしの、特有なコレクションを表しているオブジェクト、参照意味論を必要とする場合に<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Set<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>変数の代わりに使うため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An object representing a static collection of key-value pairs, for use instead of a <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Dictionary<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> constant in cases that require reference semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー値ペアからなる静的なコレクションを表しているオブジェクト、参照意味論を必要とする場合に<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Dictionary<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>定数の代わりに使うため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An object representing a static ordered collection, for use instead of an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Array<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> constant in cases that require reference semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>静的な順序付きコレクションを表しているオブジェクト、参照意味論を必要とする場合に<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Array<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>定数の代わりに使うため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An object representing a static, unordered, uniquing collection, for use instead of a <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Set<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> constant in cases that require reference semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>静的な、順序なしの、特有なコレクションを表しているオブジェクト、参照意味論を必要とする場合に<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Set<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>定数の代わりに使うため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An opaque C pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>不透明Cポインター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An opaque pointer to the value of this unmanaged reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この管理されない参照の値への不透明ポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An optional type that allows implicit member access.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的なメンバーアクセスが可能なオプショナル型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An optional value to compare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>比較することになるオプショナル値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An optional value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An ordered, random-access collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>順序付けられた、無作為アクセスのコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An output stream to receive the text representation of each item.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各項目のテキスト表現を受け取る出力ストリーム。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An output stream.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある出力ストリーム。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An overshift results in <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>-1<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> for a negative value of <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>lhs<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> or <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>0<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> for a nonnegative value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバーシフトは、負の値の<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>lhs<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に対して<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>-1<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>または非負値に対して<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>0<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unkeyed container view into <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>へのキー無しコンテナビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unkeyed decoding container view into <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>へのキー無しデコーディングコンテナビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unmanaged class reference to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への管理されないクラス参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unmanaged reference to the object passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡されるオブジェクトへの管理されない参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unordered collection of unique elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特有な要素の順番付けられないコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unsigned integer numeric value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号なし整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unsigned integer that can be used as a hash table address.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ハッシュテーブルアドレスとして使われる符号なし整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unsigned integer value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号なし整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unsigned, fixed-width integer type can represent values from 0 through <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(2 ** bit<ph x="2">&lt;w2/&gt;</ph>Width) - 1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, where <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>**<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is exponentiation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号なしの、固定長整数型は、０から<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(2 ** bit<ph x="2">&lt;w2/&gt;</ph>Width) - 1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>までの値を表せます、そこで<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>**<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は冪演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unspecified result is supplied automatically by the Swift standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>未指定の結果はSwift標準ライブラリによって自動的に提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An uppercase copy of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この文字列の大文字でのコピー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An uppercase version of the string that is produced using the current locale.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の大文字バージョン、現在のロケールを使って生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And because <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Array<ph x="8">&lt;w8/&gt;</ph>Slice<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> presents the same interface as <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Array<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>, you can generally perform the same operations on a slice as you could on the original array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そして<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Array<ph x="8">&lt;w8/&gt;</ph>Slice<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Array<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>と同じインターフェイスを提供するので、あなたは一般的にあなたが元の配列上でできるのと同じ操作をスライス上で実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another floating-point value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう１つの浮動小数点値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another index to compare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう一方の比較するインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another integer to compare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>比較するもう一方の整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another integer value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう１つの整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another optional value to compare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう一方の比較するオプショナル値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>別のポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another range to compare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう一方の比較する範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another range-replaceable collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう一方の範囲置換可能なコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another reference to compare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう一方の比較する参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう一方の集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>別の文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another tuple of elements of the same type as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と同じ型の要素からなる別のタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another type-erased hashable value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう一方の型消去ハッシュ化値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの別の有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another value to compare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう一方の比較する値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance can be bridged to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSString<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> using the type-cast operator (<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>as<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>), and any <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>String<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instance that originates in Objective-C may use an <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>NSString<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> instance as its storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSString<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>へブリッジされることが型キャスト演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>as<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）を使って行えます、そして何らかの<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>String<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスでObjective-C起源のものは<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>NSString<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>インスタンスをそれのストレージとして使っても構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any contextual information set by the user for decoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デコーディングに対するユーザによって設定される何らかの前後関係情報。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any contextual information set by the user for encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エンコーディングのためのユーザによって設定される何らかの前後関係情報。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any memory in the region <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>source..&lt;(source + count)<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> that does not overlap with the destination region is returned to an uninitialized state.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>領域<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>source..&lt;(source + count)<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>の中の何らかのメモリで行き先の領域と重ならないものは、未初期化状態に戻されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any padding is performed by <bpt i="0" x="0">&lt;e0&gt;</bpt>sign-extending<ept i="0">&lt;/e0&gt;</ept> the passed value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆる詰め物は、渡された値を<bpt i="0" x="0">&lt;e0&gt;</bpt>符号拡張<ept i="0">&lt;/e0&gt;</ept>することによって実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Hashable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol can be used as a dictionary’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Key<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type, including all of Swift’s basic types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftの基本的な型のすべてを含めて、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Hashable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するあらゆる型は、辞書の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Key<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any type that declares conformance to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Error<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol can be used to represent an error in Swift’s error handling system.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Error<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルへの準拠を宣言するあらゆる型は、エラーをSwiftのエラー処理システムにおいて表すために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any value whose magnitude is so great that it would round to a value outside the range of representable numbers is rounded to <bpt i="0" x="0">&lt;e0&gt;</bpt>infinity<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの規模が大きすぎるので表現可能な数の範囲外の値に丸められるであろう何らかの値は、<bpt i="0" x="0">&lt;e0&gt;</bpt>無限大<ept i="0">&lt;/e0&gt;</ept>に丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Append operations that trigger reallocation have a performance cost, but they occur less and less often as the array grows larger.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>再割り当ての引き金となる追加操作はある性能コストを持ちます、しかしそれらは配列がより大きく成長するにつれて大抵ますます少ない頻度でしか生じません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Appending Strings and Characters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列と文字を追加する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Appends the Unicode scalar values in the given sequence to the view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたシーケンスの中のユニコードスカラー値をビューに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Appends the characters in the given sequence to the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたシーケンスの中の文字を文字列へ追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Appends the elements of a sequence to a range-replaceable collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンスの要素を範囲置換コレクションに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Appends the given Unicode scalar to the view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたユニコードスカラーをビューに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Appends the given character to the character view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字を文字ビューへ加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Appends the given string to the stream.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字列をストリームへ追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Appends the given string to this string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字列をこの文字列へ加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Applies the given closure to a mutable view of the string’s characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクロージャをその文字列の持つ文字の可変のビューに適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Are you measuring the number of characters that will be displayed on the screen, or are you measuring the amount of storage needed for the string in a particular encoding?</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが画面上に表示される文字の数を数えているのか、またはあなたはある特定の符号化での文字列に必要とされるストレージの量を測っているのか？。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Arithmetic</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>算術</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Arithmetic with Assignment</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代入での算術</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Arrays and Dictionaries</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列と辞書</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Arrays are one of the most commonly used data types in an app.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列は、アプリにおいて最も一般的に使われるデータ型の１つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Arrays need to follow a geometric allocation pattern for appending elements to achieve amortized constant-time performance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ならし定数時間性能を達成するために、配列は要素を追加するのにある幾何数級的なアロケートパターンに従う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Arrays, like all variable-size collections in the standard library, use copy-on-write optimization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列は、標準ライブラリにおける可変サイズコレクションのすべてと同じく、コピーオンライト最適化を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Arrays, sets, and option sets all conform to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Array<ph x="4">&lt;w4/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, and your own custom types can as well.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列、集合、またはオプションセットは、すべて<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Array<ph x="4">&lt;w4/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠します、そしてあなた独自のあつらえの型もまたそうできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a consequence, don’t assume that multiple <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>for<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>-<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>in<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> loops on a sequence will either resume iteration or restart from the beginning:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、あるシーケンス上での複数の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>for<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>-<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>in<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ループが反復を途中から再開するかまたは初めから再度着手するか、どちらかを決めてかからないでください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, each view of the string <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"🇵🇷"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> reports a different length.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、文字列<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"🇵🇷"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の各ビューは異なる長さを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, you can chain multiple <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>??<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> operators together.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、あなたは複数の<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>??<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を一緒に鎖状につなげることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an example, consider a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Grid<ph x="2">&lt;w2/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type that describes a location in a grid of buttons.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つの例として、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Grid<ph x="2">&lt;w2/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型を考えてみてください、それはある格子状配列のボタンにおけるある場所を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an example, consider a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Street<ph x="2">&lt;w2/&gt;</ph>Address<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> structure that holds the parts of a street address: a house or building number, the street name, and an optional unit number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例として、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Street<ph x="2">&lt;w2/&gt;</ph>Address<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>構造体を考えてください、それは通り住所の部分；家またはビル番地、通りの名、そして随意に戸番号を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an example, here’s an implementation of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Date<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> structure that stores the year, month, and day of a date:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例として、ある日付の年、月、そして日を格納するある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Date<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>構造体の実装がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an example, here’s an implementation of an output stream that converts any input to its plain ASCII representation before sending it to standard output.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一例として、ここに出力ストリームの実装があります、それは何らかの入力を標準出力に送る前にそれの標準ASCII表現に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つの例として、あるシーケンスが特定の値を含むかどうか確認するために、あなたは各値を順次テストすることが、あなたが一致するものを見つけるかそのシーケンスの終わりに達するまで行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As is typical in Swift, you can call the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(address:<ph x="2">&lt;w2/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function with an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Raw<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftでは普通であるように、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(address:<ph x="2">&lt;w2/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Raw<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスとともに呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As is typical in Swift, you can call the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(address:<ph x="2">&lt;w2/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function with an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Raw<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftでは普通であるように、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(address:<ph x="2">&lt;w2/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Raw<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスとともに呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As is typical in Swift, you can call the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print<ph x="2">&lt;w2/&gt;</ph>Int(at<ph x="3">&lt;w3/&gt;</ph>Address:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function with an <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Unsafe<ph x="6">&lt;w6/&gt;</ph>Mutable<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftでは普通であるように、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print<ph x="2">&lt;w2/&gt;</ph>Int(at<ph x="3">&lt;w3/&gt;</ph>Address:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Unsafe<ph x="6">&lt;w6/&gt;</ph>Mutable<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスとともに呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As is typical in Swift, you can call the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print<ph x="2">&lt;w2/&gt;</ph>Int(at<ph x="3">&lt;w3/&gt;</ph>Address:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function with an <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Unsafe<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftでは普通であるように、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print<ph x="2">&lt;w2/&gt;</ph>Int(at<ph x="3">&lt;w3/&gt;</ph>Address:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Unsafe<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスとともに呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As soon as the sequence has run out of elements, all subsequent calls return <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスが要素を使い果たすやいなや、全てのその後の呼び出しは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As such, it should be possible to re-create an instance from its string representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それなので、それはそれの文字列表現からインスタンスの再度作成が可能であるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As the dictionary is built, the initializer calls the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>combine<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure with the current and new values for any duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書が組み立てられるとき、このイニシャライザは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>combine<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャをすべての重複とともに現在および新規の値とともに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As the key-value pairs are merged with the dictionary, the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>combine<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> closure is called with the current and new values for any duplicate keys that are encountered.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらキー値ペアが辞書に結合されるときに、出くわした全ての重複キーに対してその現在および新しい値とともに<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>combine<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>クロージャが呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with any basic operation, if this value is outside the representable range of the type, overflow or underflow occurs, and zero, a subnormal value, or infinity may result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆる基本的演算でのように、この値がその型の表現可能な範囲の外側ならば、オーバーフローまたはアンダーフローが起こります、そしてゼロ、サブノーマル値、または無限大が結果となるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As you can see, complexity for each element of the argument list depends on the argument type and capabilities of the collection used to initialize the corresponding subject’s parent’s mirror.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ご覧のように、引数リストの各要素に対する複雑さは、付随する主題の親のミラーの初期化に使われる引数型とコレクションの能力に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assign</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代入する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assigning into a ranged subscript of an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Buffer<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance copies bytes into the memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Buffer<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの範囲指定された添え字に対してアサインすることは、それらバイトをメモリにコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Associated Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Associativity</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結合性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assume that <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>S<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is a custom type that conforms to the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Set<ph x="7">&lt;w7/&gt;</ph>Algebra<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> protocol, <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>y<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> are instances of <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>S<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>, and <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>e<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> is of type <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>S<ph x="18">&lt;w18/&gt;</ph>.Element<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>—the type that the set holds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>S<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Set<ph x="7">&lt;w7/&gt;</ph>Algebra<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロトコルに準拠するあつらえの型、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>と<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>y<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>は<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>S<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>のインスタンス、そして<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>e<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>は型<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>S<ph x="18">&lt;w18/&gt;</ph>.Element<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> — 集合が保持する型、と仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Asynchronous calls are another type of API that typically escape their closure arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非同期呼び出しは別の種類のAPIで、それは一般的にそれらのクロージャ引数を脱出させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At least one of the sequences must be finite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>少なくともシーケンスのうちの一方は有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Attempting to remove more elements than exist in the collection triggers a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの中に存在するより多くの要素の削除を試みることは実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Avoid that name because it has different meanings in different languages, which can lead to confusion, and because it suggests that it is a good tolerance to use for comparisons, which it almost never is.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その名前を避けてください、それが異なる言語において異なる意味を持ち、それが混乱を招くので、そしてそれは比較に使うのに良い公差であると提案され、それはほとんど全くそうではないので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Basic Arithmetic</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基本算術</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Basic Behaviors</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基本の挙動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Basic Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基本的な値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Basic string operations are not sensitive to locale settings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基本の文字列演算は、ロケール設定に影響されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be aware that although an <bpt i="4" x="4">&lt;e4&gt;</bpt>actual<ept i="4">&lt;/e4&gt;</ept> <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Dictionary<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is arbitrarily-ordered, the ordering of the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Mirror<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>’s <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>children<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> will exactly match that of the literal you pass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>気をつけるべきは、たとえ<bpt i="4" x="4">&lt;e4&gt;</bpt>実際<ept i="4">&lt;/e4&gt;</ept>の<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Dictionary<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>が随意の順番であるとしても、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Mirror<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>の<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>children<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>の順番は正確にあなたが渡したリテラルと一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be aware, therefore, that general operations on <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Lazy<ph x="12">&lt;w12/&gt;</ph>Drop<ph x="13">&lt;w13/&gt;</ph>While<ph x="14">&lt;w14/&gt;</ph>Bidirectional<ph x="15">&lt;w15/&gt;</ph>Collection<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> instances may not have the documented complexity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自覚すべきは、したがって、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Lazy<ph x="12">&lt;w12/&gt;</ph>Drop<ph x="13">&lt;w13/&gt;</ph>While<ph x="14">&lt;w14/&gt;</ph>Bidirectional<ph x="15">&lt;w15/&gt;</ph>Collection<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>インスタンス上での操作全般が複雑に記述されるものを持たないようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be aware, therefore, that general operations on <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Lazy<ph x="12">&lt;w12/&gt;</ph>Drop<ph x="13">&lt;w13/&gt;</ph>While<ph x="14">&lt;w14/&gt;</ph>Collection<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> instances may not have the documented complexity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自覚すべきは、したがって、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Lazy<ph x="12">&lt;w12/&gt;</ph>Drop<ph x="13">&lt;w13/&gt;</ph>While<ph x="14">&lt;w14/&gt;</ph>Collection<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>インスタンス上での操作全般が複雑に記述されるものを持たないようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be aware, therefore, that general operations on <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Lazy<ph x="12">&lt;w12/&gt;</ph>Filter<ph x="13">&lt;w13/&gt;</ph>Collection<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> instances may not have the documented complexity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自覚すべきは、したがって、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Lazy<ph x="12">&lt;w12/&gt;</ph>Filter<ph x="13">&lt;w13/&gt;</ph>Collection<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>インスタンス上での全体的な演算が複雑に記述されるものを持たないようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be aware, therefore, that general operations on <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Lazy<ph x="12">&lt;w12/&gt;</ph>Prefix<ph x="13">&lt;w13/&gt;</ph>While<ph x="14">&lt;w14/&gt;</ph>Bidirectional<ph x="15">&lt;w15/&gt;</ph>Collection<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> instances may not have the documented complexity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自覚すべきは、したがって、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Lazy<ph x="12">&lt;w12/&gt;</ph>Prefix<ph x="13">&lt;w13/&gt;</ph>While<ph x="14">&lt;w14/&gt;</ph>Bidirectional<ph x="15">&lt;w15/&gt;</ph>Collection<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>インスタンス上での操作全般が複雑に記述されるものを持たないようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be aware, therefore, that general operations on <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Lazy<ph x="12">&lt;w12/&gt;</ph>Prefix<ph x="13">&lt;w13/&gt;</ph>While<ph x="14">&lt;w14/&gt;</ph>Collection<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> instances may not have the documented complexity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自覚すべきは、したがって、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Lazy<ph x="12">&lt;w12/&gt;</ph>Prefix<ph x="13">&lt;w13/&gt;</ph>While<ph x="14">&lt;w14/&gt;</ph>Collection<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>インスタンス上での操作全般が複雑に記述されるものを持たないようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be aware, therefore, that general operations on <bpt i="17" x="17">&lt;c17&gt;</bpt><bpt i="18" x="18">&lt;s18&gt;</bpt>Flatten<ph x="19">&lt;w19/&gt;</ph>Collection<ept i="18">&lt;/s18&gt;</ept><ept i="17">&lt;/c17&gt;</ept> instances may not have the documented complexity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自覚すべきは、したがって、<bpt i="17" x="17">&lt;c17&gt;</bpt><bpt i="18" x="18">&lt;s18&gt;</bpt>Flatten<ph x="19">&lt;w19/&gt;</ph>Collection<ept i="18">&lt;/s18&gt;</ept><ept i="17">&lt;/c17&gt;</ept>インスタンス上での操作全般が複雑に記述されるものを持たないようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be aware, therefore, that general operations on <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>Flatten<ph x="20">&lt;w20/&gt;</ph>Bidirectional<ph x="21">&lt;w21/&gt;</ph>Collection<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> instances may not have the documented complexity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自覚すべきは、したがって、<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>Flatten<ph x="20">&lt;w20/&gt;</ph>Bidirectional<ph x="21">&lt;w21/&gt;</ph>Collection<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>インスタンス上での操作全般が複雑に記述されるものを持たないようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be sure to deallocate any memory that you manually allocate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが手動でアロケートしてあらゆるメモリをデアロケートするのを確実にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is the default type for an array literal, without writing any other code, you can declare an array with a particular element type by providing one or more values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は配列リテラルのための省略時の型なので、なんら他のコードを書くことなく、あなたはひとつ以上の値を提供することによって特定の要素型を持つ配列を宣言できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Integer<ph x="2">&lt;w2/&gt;</ph>Ref<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is a class, its instances can be compared using the identical-to operator (<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>===<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Integer<ph x="2">&lt;w2/&gt;</ph>Ref<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がクラスであるので、それのインスタンスは同一性演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>===<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）を使って比較されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> represents a half-open range, a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Range<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance does not contain its upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は半開範囲を表すことから、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Range<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスはそれの上方の境界を含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(address:<ph x="2">&lt;w2/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> requires an immutable pointer, although this is syntactically valid, it isn’t necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(address:<ph x="2">&lt;w2/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が不変ポインタを要求することから、これは構文的には有効ですが、必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print<ph x="2">&lt;w2/&gt;</ph>Int(at<ph x="3">&lt;w3/&gt;</ph>Address:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> requires an immutable pointer, although this is syntactically valid, it isn’t necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print<ph x="2">&lt;w2/&gt;</ph>Int(at<ph x="3">&lt;w3/&gt;</ph>Address:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が不変ポインタを要求することから、これは構文的には有効ですが、必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>NSString<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> is immutable, it is just as though the storage was shared by a copy: The first in any sequence of mutating operations causes elements to be copied into unique, contiguous storage which may cost O(<bpt i="20" x="20">&lt;e20&gt;</bpt>n<ept i="20">&lt;/e20&gt;</ept>) time and space, where <bpt i="21" x="21">&lt;e21&gt;</bpt>n<ept i="21">&lt;/e21&gt;</ept> is the length of the string’s encoded representation (or more, if the underlying <bpt i="22" x="22">&lt;c22&gt;</bpt><bpt i="23" x="23">&lt;s23&gt;</bpt>NSString<ept i="23">&lt;/s23&gt;</ept><ept i="22">&lt;/c22&gt;</ept> has unusual performance characteristics).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>NSString<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>は不変であることから、それはストレージがいくつかのコピーによって共有されたとしても相変わらずです：何らかの変更を行う一連の演算の中の最初のものは、要素が固有の、隣接するストレージへとコピーされる原因となり、それはO(<bpt i="20" x="20">&lt;e20&gt;</bpt>n<ept i="20">&lt;/e20&gt;</ept>)の時間と空間がかかります、そこにおいて<bpt i="21" x="21">&lt;e21&gt;</bpt>n<ept i="21">&lt;/e21&gt;</ept>は文字列表現の長さです（またはそれ以上のもの、基盤となる<bpt i="22" x="22">&lt;c22&gt;</bpt><bpt i="23" x="23">&lt;s23&gt;</bpt>NSString<ept i="23">&lt;/s23&gt;</ept><ept i="22">&lt;/c22&gt;</ept>が通常でない性能特質を持つならば）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because NaN compares not less than nor greater than any value, this method returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> when called on NaN or when NaN is passed as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NaNはあらゆる値より少なくもないし大きくもないと比較されるので、このメソッドが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返すのは、NaN上で呼ばれた時またはNaNが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>として渡された場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because NaN is incomparable with any value, this method returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> when called on NaN or when NaN is passed as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NaNはあらゆる値と比較不可能なので、このメソッドが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返すのは、NaN上で呼ばれた時またはNaNが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>として渡された場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because NaN is not equal to any value, including NaN, use this property instead of the equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) or not-equal-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>!=<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>) to test whether a value is or is not NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NaNは、NaNを含めてあらゆる値と等しくないので、同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）または不等演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>!=<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）の代わりにこのプロパティを使うことで、ある値がNaNであるのかまたはないのかをテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because Swift can’t guarantee at compile time that these methods and properties are actually available on an <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Any<ph x="9">&lt;w9/&gt;</ph>Object<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> instance’s underlying type, these <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>@objc<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> symbols are available as implicitly unwrapped optional methods and properties, respectively.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftはそれらのメソッドやプロパティが<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Any<ph x="9">&lt;w9/&gt;</ph>Object<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>インスタンスの下に横たわる型で実際に利用可能であるとコンパイル時に保証しないため、これら<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>@objc<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>シンボルは暗黙的にアンラップされるオプショナルのメソッドやプロパティとしてそれぞれ利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because Swift provides several ways to safely unwrap optional values, you can choose the one that helps you write clear, concise code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftは安全にオプショナル値をアンラップするために複数の方法を提供するので、あなたは明快な、簡潔なコードを記述する助けとしてその１つを選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Partial<ph x="3">&lt;w3/&gt;</ph>Range<ph x="4">&lt;w4/&gt;</ph>From<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> sequence counts upward indefinitely, do not use one with methods such as <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>map(_:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>filter(_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, or <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>suffix(_:)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> that read the entire sequence before returning.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Partial<ph x="3">&lt;w3/&gt;</ph>Range<ph x="4">&lt;w4/&gt;</ph>From<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>シーケンスは上向きに無限に数えることから、返す前にシーケンス全体を読み出す<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>map(_:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>filter(_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>、または<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>suffix(_:)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>のようなメソッドと一緒には使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a NaN always compares not equal to itself, to test whether a floating-point value is NaN, use its <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Na<ph x="3">&lt;w3/&gt;</ph>N<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property instead of the equal-to operator (<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>==<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NaNは常にそれ自身に対して等しくないと比較されることから、浮動小数点値がNaNかどうかテストするには、それの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Na<ph x="3">&lt;w3/&gt;</ph>N<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを同等演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>==<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）の代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a Unicode scalar value can require more than a single ASCII character’s worth of storage, additional allocation may be necessary when adding to a Unicode scalar view after a call to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるユニコードスカラー値が単一ASCII文字相当のストレージより多く要求する可能性があることから、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への呼び出しの後に文字ビューにあるユニコードスカラー値を追加する場合は、追加割り当てが必要かもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a closed range cannot represent an empty range, this property is always <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>完結範囲は空の範囲を表すことができないので、このプロパティは常に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a closed range includes its upper bound, a closed range whose lower bound is equal to the upper bound contains one element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>完結範囲はそれの上側の境界を含むことから、それの下側の境界が上側の境界と等しい完結範囲は１つの要素を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a closed range includes its upper bound, the ranges in the following example also overlap:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>完結範囲はそれの上方の境界を含むことから、以下の例の範囲もまた重なります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a half-open range does not include its upper bound, the ranges in the following example do not overlap:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>半壊範囲はそれの上方の範囲を含まないことから、以下の例の範囲は重なりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a mutable typed pointer can be implicitly cast to an immutable pointer with the same <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type when passed as a parameter, you can also call <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>print<ph x="4">&lt;w4/&gt;</ph>Int(at<ph x="5">&lt;w5/&gt;</ph>Address:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> with an <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Unsafe<ph x="8">&lt;w8/&gt;</ph>Mutable<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変の型付ポインタは同じ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型を持つ不変のポインタに暗黙的にキャストされることがパラメータとして渡される時に可能なことから、あなたはまた<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>print<ph x="4">&lt;w4/&gt;</ph>Int(at<ph x="5">&lt;w5/&gt;</ph>Address:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Unsafe<ph x="8">&lt;w8/&gt;</ph>Mutable<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスとともに呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a sequence created with the postfix range operator counts upward indefinitely, do not use one with methods such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>filter(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, or <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>suffix(_:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> that read the entire sequence before returning.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後置範囲演算子で作成されるシーケンスは上向きに無限に数えることから、返す前にシーケンス全体を読み出す<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>filter(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、または<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>suffix(_:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のようなメソッドと一緒には使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a set is not an ordered collection, the “first” element may not be the first element that was added to the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合は順序付けられたコレクションではないことから、「最初」の要素は集合に加えられた最初の要素ではないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because any arbitrary subclass of <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>NSString<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> can become a <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>String<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> instance, there are no guarantees about representation or efficiency when a <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>String<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> instance is backed by <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>NSString<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>NSString<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>の随意のサブクラスは何であれ<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>String<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>インスタンスになれるので、<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>String<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>インスタンスが<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>NSString<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>ストレージによって裏打ちされる場合、表現または効率についての保障はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because any arbitrary subclass of <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>NSArray<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> can become an <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Array<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>, there are no guarantees about representation or efficiency in this case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何であれ随意の<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>NSArray<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>のサブクラスが<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Array<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>になることが可能であるので、表現や効率についてはこの場合保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because arrays increase their allocated capacity using an exponential strategy, appending a single element to an array is an O(1) operation when averaged over many calls to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>append(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列はそれらの割り当てられた容量を指数戦略で増やすので、ある単一の要素を配列に加えることは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>append(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドへの多くの呼び出しにわたって平均した場合は、O(1)演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because calculating the average of the observations involves combining every value of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>temps<ph x="2">&lt;w2/&gt;</ph>Fahrenheit<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array, any NaN values cause the result to also be NaN, as seen in this example:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>観測の平均の算出は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>temps<ph x="2">&lt;w2/&gt;</ph>Fahrenheit<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列のすべての値を足し合わせることを必然的に含むことから、何らかのNaN値はまたNaNになるという結果を引き起こします、この例で見られるように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because default implementations of the remainder of the relational operators are provided by the standard library, you’ll be able to use <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>!=<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>, <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>&gt;<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>, <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>&lt;=<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>, and <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>&gt;=<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> with instances of your type without any further code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関係演算子の残りの省略時の実装は標準ライブラリによって提供されることから、あなたは<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>!=<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>、<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>&gt;<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>、<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>&lt;=<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>、そして<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>&gt;=<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>をあなたの型のインスタンスにおいてなんらこれ以上のコード無しに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because each character in a string can be made up of one or more Unicode code points, the number of characters in a string may not match the length of the Unicode code point representation or the length of the string in a particular binary representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列中の各文字はひとつ以上のユニコード点から成り立つので、ある文字列の文字数はユニコードコード点表現の長さ、または特定のバイナリ表現での文字列の長さと一致しないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because each character in a string can require more than a single ASCII character’s worth of storage, additional allocation may be necessary when adding characters to a string after a call to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列中の各文字が単一ASCII文字相当のストレージより多く要求する可能性があることから、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への呼び出しの後に文字列に文字を追加する場合は、追加割り当てが必要かもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because each element of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is its own index, for the range <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>(-99..&lt;100)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> the element at index <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>0<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの各要素がそれ自身インデックスであることから、範囲<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>(-99..&lt;100)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に対してインデックス<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>での要素は<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>0<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because each element of a character view can require more than a single ASCII character’s worth of storage, additional allocation may be necessary when adding characters to the character view after a call to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字ビューの各要素が単一ASCII文字相当のストレージより多く要求する可能性があることから、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への呼び出しの後に文字ビューに文字を追加する場合は、追加割り当てが必要かもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because floating-point types such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Double<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> are their own <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> types, they cannot be used as the bounds of a countable range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点型、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Double<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、それら独自の<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型であるので、それらは可付番範囲の境界として使われることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because it is used much less frequently than the usual comparisons, there is no operator form of this relation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは普通の比較と比べてあまり頻繁に使われないことから、この関係の演算子形式はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because many functions and initializers fully specify the types of their parameters, you can often use an array literal with or without elements as a parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>多くの関数とイニシャライザはそれらのパラメータの型を完全に指定することから、あなたはしばしば要素のあるまたはない配列リテラルをパラメータとして使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because testing whether one NaN is equal to another NaN results in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, use the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>is<ph x="4">&lt;w4/&gt;</ph>Na<ph x="5">&lt;w5/&gt;</ph>N<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property to test whether a value is NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるNaNが別のNaNと等しいかどうかテストすることは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の結果になることから、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>is<ph x="4">&lt;w4/&gt;</ph>Na<ph x="5">&lt;w5/&gt;</ph>N<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティを使うことである値がNaNかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Grid<ph x="2">&lt;w2/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type is not hashable yet, it can’t be used as the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Element<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type for a set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Grid<ph x="2">&lt;w2/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型はまだハッシュ化されていないので、それは集合のための<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Element<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型として使われることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Signed<ph x="2">&lt;w2/&gt;</ph>Numeric<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol provides default implementations of both of its required methods, you don’t need to do anything beyond declaring conformance to the protocol and ensuring that the values of your type support negation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Signed<ph x="2">&lt;w2/&gt;</ph>Numeric<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルはそれの必須メソッドの両方の省略時の実装を提供することから、あなたは、プロトコルへの準拠を宣言することおよびあなたの型の値が負をサポートするのを確実にすること以上に何もする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(reflecting:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer works for instances of <bpt i="2" x="2">&lt;e2&gt;</bpt>any<ept i="2">&lt;/e2&gt;</ept> type, returning an instance’s <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>debug<ph x="5">&lt;w5/&gt;</ph>Description<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> if the value passed conforms to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Custom<ph x="8">&lt;w8/&gt;</ph>Debug<ph x="9">&lt;w9/&gt;</ph>String<ph x="10">&lt;w10/&gt;</ph>Convertible<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, accessing a type’s <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>debug<ph x="13">&lt;w13/&gt;</ph>Description<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> property directly or using <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Custom<ph x="16">&lt;w16/&gt;</ph>Debug<ph x="17">&lt;w17/&gt;</ph>String<ph x="18">&lt;w18/&gt;</ph>Convertible<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> as a generic constraint is discouraged.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(reflecting:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザが<bpt i="2" x="2">&lt;e2&gt;</bpt>あらゆる<ept i="2">&lt;/e2&gt;</ept>型のインスタンスに対して働いて、渡される値が<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>debug<ph x="5">&lt;w5/&gt;</ph>Description<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠するならばインスタンスの<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Custom<ph x="8">&lt;w8/&gt;</ph>Debug<ph x="9">&lt;w9/&gt;</ph>String<ph x="10">&lt;w10/&gt;</ph>Convertible<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を返すので、ある型の<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>debug<ph x="13">&lt;w13/&gt;</ph>Description<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>プロパティに直にアクセスすることや、総称体制約として<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Custom<ph x="16">&lt;w16/&gt;</ph>Debug<ph x="17">&lt;w17/&gt;</ph>String<ph x="18">&lt;w18/&gt;</ph>Convertible<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>を使うことは推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Error<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol has no requirements of its own, you can declare conformance on any custom type you create.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Error<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルはそれ自身の要件を持たないので、あなたは準拠を宣言することがあなたが作成するあらゆるあつらえの型で可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>hypotenuse(_:<ph x="5">&lt;w5/&gt;</ph>_:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> function uses a generic parameter constrained to the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Floating<ph x="8">&lt;w8/&gt;</ph>Point<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> protocol, you can call it using any floating-point type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>hypotenuse(_:<ph x="5">&lt;w5/&gt;</ph>_:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>関数は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Floating<ph x="8">&lt;w8/&gt;</ph>Point<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>プロトコルに制約された総称体パラメータを使うので、あなたはそれを呼び出すことがあらゆる浮動小数点型を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the result of this nil-coalescing operation is itself an optional value, you can chain default values by using <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>??<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> multiple times.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このnil合体演算の結果がそれ自体オプショナル値であることから、あなたは幾らかの省略時の値を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>??<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を複数回使うことで連鎖することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the strings are identical up to the 14th character, comparing only those characters results in a return value of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>0<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これら文字列が14番目の文字に至るまで全く同じなので、それらの文字だけ比較することは<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>0<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の値を返す結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the underlying types of <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>y<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> are different, the two variables do not compare as equal despite having equal underlying values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>と<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>y<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>の基礎をなす型は異なることから、２つの変数は等しい基礎をなす値を持つにもかかわらず等しいと比較されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because this initializer does not perform any checks, it should be used as an optimization only when you are absolutely certain that <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lower<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is less than or equal to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>upper<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは何ら確認を行わないので、それは、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lower<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>upper<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>より少ないか等しいことを絶対に確信している場合にのみ１つの最適化として使われるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because this pointer’s memory is no longer bound to its <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type while the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>body<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> closure executes, do not access memory using the original pointer from within <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>body<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタのメモリがそれの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型にはもはや<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>body<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>クロージャが実行される間は束縛されないことから、メモリにオリジナルのポインタを使って<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>body<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>内からアクセスしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because typed pointers can be implicitly cast to raw pointers when passed as a parameter, you can also call <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(address:<ph x="2">&lt;w2/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with any mutable or immutable typed pointer instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付ポインタは暗黙的に生のポインタにキャストされることがパラメータとして渡される時に可能なことから、あなたはまた<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(address:<ph x="2">&lt;w2/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を何らかの可変または不変の型付ポインタとともに呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because typed pointers can be implicitly cast to raw pointers when passed as a parameter, you can also call <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(address:<ph x="2">&lt;w2/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with any mutable typed pointer instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付ポインタは暗黙的に生のポインタにキャストされることがパラメータとして渡される時に可能なことから、あなたはまた<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(address:<ph x="2">&lt;w2/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を何らかの可変の型付ポインタとともに呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because weak and unowned references cannot be the only reference to an object, passing a weak or unowned reference as <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>object<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> always results in <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>false<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>弱いおよび非所有の参照は、あるオブジェクトに対する唯一の参照ではありえないので、弱いまたは非所有参照を<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>object<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>として渡すことは常に<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>false<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Before appending, the array allocates new storage that is large enough store the resulting elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>追加の前に、この配列は新しいストレージを割り当てます、それは結果として生じる要素らを格納するのに十分に大きいものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Behind the scenes, Swift uses the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>animals<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array’s iterator to loop over the contents of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>舞台裏で、Swiftは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>animals<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列のもつイテレータを使って、その配列の要素のすべてにわたって繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Besides maintaining the order of the original dictionary literal, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Dictionary<ph x="5">&lt;w5/&gt;</ph>Literal<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> also allows duplicates keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>元の辞書リテラルの順番を維持する他に、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Dictionary<ph x="5">&lt;w5/&gt;</ph>Literal<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>はまた他とそっくり同じキーを許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bidirectional collections can therefore offer additional operations, such as a <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>last<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> property that provides efficient access to the last element and a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>reversed()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> method that presents the elements in reverse order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>二方向性のコレクションは、従って追加の演算を提案します、例えば最後の要素への手際のよいアクセスを提供する<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>last<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロパティ、そして要素を逆順で提示する<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>reversed()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>メソッドなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bidirectional collections offer traversal backward from any valid index, not including a collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>二方向性のコレクションは、あらゆる有効な、しかしコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を含まないインデックスから後方へ辿っていくことを提案します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>BidirectionalCollection Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>BidirectionalCollection実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>BinaryFloatingPoint Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>BinaryFloatingPoint 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>BinaryInteger Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>BinaryInteger実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Binds the memory to the specified type and returns a typed pointer to the bound memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリを指定された型へ束縛して、束縛されたメモリに対する型付ポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bit Pattern Conversion</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビットパターン変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bit Shift</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビットシフト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise AND</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の論理積</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise AND and assign</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の論理積と代入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise NOT</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の論理否定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise OR</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の論理和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise OR and assign</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の論理和と代入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise Operations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位演算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise XOR</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の排他的論理和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise XOR and assign</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の排他的論理和と代入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise left shift</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の左シフト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise right shift</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の右シフト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both parameters must be valid indices of the collection that are not equal to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方のパラメータは、このコレクションの有効なインデックスで、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と等しくない必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bounds checks are always performed in debug mode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>境界検査は、デバッグモードにおいて常に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bounds checks for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are performed only in debug mode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対する境界検査は、デバッグモードでのみ実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bridging Between Array and NSArray</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ArrayとNSArrayの間のブリッジ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bridging Between Dictionary and NSDictionary</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>DictionaryとNSDictionaryの間のブリッジ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bridging Between Set and NSSet</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>SetとNSSetの間のブリッジ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bridging between String and NSString</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>StringとNSStringの間のブリッジ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bridging from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSArray<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> takes O(1) time and O(1) space if the array’s elements are already instances of a class or an <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>@objc<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol; otherwise, it takes O(<bpt i="6" x="6">&lt;e6&gt;</bpt>n<ept i="6">&lt;/e6&gt;</ept>) time and space.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSArray<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>へのブリッジは、配列のもつ要素がすでにあるクラスまたは<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>@objc<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルのインスタンスであるならば、O(1)時間とO(1)空間をとります；そうでなければ、それはO(<bpt i="6" x="6">&lt;e6&gt;</bpt>n<ept i="6">&lt;/e6&gt;</ept>)の時間と空間をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bridging from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSDictionary<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> always takes O(1) time and space.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSDictionary<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>へのブリッジは、常にO(1)時間と空間をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bridging from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSDictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Dictionary<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> first calls the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>copy(with:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method (<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>- copy<ph x="8">&lt;w8/&gt;</ph>With<ph x="9">&lt;w9/&gt;</ph>Zone:<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> in Objective-C) on the dictionary to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSDictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Dictionary<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>へのブリッジは、最初に<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>copy(with:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッド（Objective-Cでの<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>- copy<ph x="8">&lt;w8/&gt;</ph>With<ph x="9">&lt;w9/&gt;</ph>Zone:<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>）をその辞書上で呼び出して可変のコピーを取得して、それからO(1)時間を取る追加的なSwift簿記作業を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bridging from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSSet<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Set<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> first calls the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>copy(with:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method (<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>- copy<ph x="8">&lt;w8/&gt;</ph>With<ph x="9">&lt;w9/&gt;</ph>Zone:<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> in Objective-C) on the set to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSSet<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Set<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>へのブリッジは、最初に<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>copy(with:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッド（Objective-Cにおける<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>- copy<ph x="8">&lt;w8/&gt;</ph>With<ph x="9">&lt;w9/&gt;</ph>Zone:<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>）を集合上で呼び出すことで可変のコピーを取得して、それからO(1)時間をとる追加的なSwift簿記作業を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bridging from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSSet<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> always takes O(1) time and space.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSSet<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>へのブリッジは、常にO(1)の時間と空間をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Buffer Implementation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Buffer 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Build your own buffer-backed collection types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなた独自のバッファ裏付けのコレクション型を組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, Swift’s integer and pointer types are usable as the bounds of a countable range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、Swiftの整数およびポインタ型は可付番範囲の境界として使用に適します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, a collection conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol by supplying <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Indexing<ph x="4">&lt;w4/&gt;</ph>Iterator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> as its associated <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Iterator<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態で、あるコレクションは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Indexing<ph x="4">&lt;w4/&gt;</ph>Iterator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>をそれの関連<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Iterator<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>型として提供することによって準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, a representation is automatically generated and any <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>custom<ph x="13">&lt;w13/&gt;</ph>Mirror<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> implementation is bypassed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、ある表現は自動的に生成されてどのような<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>custom<ph x="13">&lt;w13/&gt;</ph>Mirror<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>実装も迂回されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, any custom collection type you create will inherit a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>make<ph x="2">&lt;w2/&gt;</ph>Iterator()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method that returns an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Indexing<ph x="5">&lt;w5/&gt;</ph>Iterator<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance, making it unnecessary to declare your own.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態で、あなたが作成するあらゆるあつらえのコレクション型は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Indexing<ph x="5">&lt;w5/&gt;</ph>Iterator<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスを返す<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>make<ph x="2">&lt;w2/&gt;</ph>Iterator()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを継承していて、それをあなた自身で宣言する必要がないようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, most types in the standard library are hashable, including strings, numeric and Boolean types, enumeration cases without associated values, and even sets themselves.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態で、標準ライブラリの中のほとんどの型はハッシュ化されています、文字列、数のおよびブールの型、関連値なしの列挙ケース節、そして集合それら自身さえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By sending the output of the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>print(_:<ph x="8">&lt;w8/&gt;</ph>to:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> function to an instance of <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>ASCIILogger<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>, you invoke its <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>write(_:)<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>print(_:<ph x="8">&lt;w8/&gt;</ph>to:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>関数の出力を<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>ASCIILogger<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>のインスタンスに送ることによって、あなたはそれの<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>write(_:)<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>メソッドを発動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>C Interoperability</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>C Variadic Functions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C可変長引数関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>C and Objective-C Pointers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>CおよびObjective-Cポインタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calculates the additive inverse of a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値の加法の逆元を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calculates the result of shifting a value’s binary representation the specified number of digits to the right, masking the shift amount to the type’s bit width, and stores the result in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値のバイナリ表現を指定された桁数だけ右にシフトする結果を計算します、シフト量をその型の持つビット幅にマスクしています、そして結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calculating <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>count<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> can be an O(<bpt i="7" x="7">&lt;e7&gt;</bpt>n<ept i="7">&lt;/e7&gt;</ept>) operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>count<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の算出は、O(<bpt i="7" x="7">&lt;e7&gt;</bpt>n<ept i="7">&lt;/e7&gt;</ept>)演算であるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>s to the stored <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Header<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> and raw <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Element<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>格納<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Header<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>および<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Element<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>生ストレージそれぞれへの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使って<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Element<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ストレージへの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使って<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>body<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to the stored <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Header<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この格納<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Header<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使って<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>body<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index(where:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> again, this time on the slice created in step 2.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index(where:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をもう一度呼び出します、今回は手順２で作成したスライス上で。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index(where:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to find the index of the first element in the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>absences<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> array that is greater than zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index(where:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼んで<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>absences<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>配列の中の、ゼロより大きい最初の要素がもつインデックスを手に入れてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Call the given output stream’s <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>write(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> method in your implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた出力ストリームのもつ<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>write(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>メソッドをあなたの実装において呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Callers should apply the same preconditions to the return value as they would to a range provided directly by the user.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>呼び出し側は、同じ前提条件を戻り値に適用すべきです、それらがユーザによって直接に提供される範囲にするように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>flat<ph x="2">&lt;w2/&gt;</ph>Map(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> on a collection <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>c<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is equivalent to calling <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>c<ph x="7">&lt;w7/&gt;</ph>.map(transform).joined()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>flat<ph x="2">&lt;w2/&gt;</ph>Map(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をあるコレクション<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>c<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>上で呼び出すことは、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>c<ph x="7">&lt;w7/&gt;</ph>.map(transform).joined()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を呼び出すことに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>flat<ph x="2">&lt;w2/&gt;</ph>Map(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> on a sequence <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>s<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is equivalent to calling <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>s<ph x="7">&lt;w7/&gt;</ph>.map(transform).joined()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>flat<ph x="2">&lt;w2/&gt;</ph>Map(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をあるシーケンス<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>s<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>上で呼び出すことは、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>s<ph x="7">&lt;w7/&gt;</ph>.map(transform).joined()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を呼び出すことに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling <bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>store<ph x="17">&lt;w17/&gt;</ph>Bytes(of:<ph x="18">&lt;w18/&gt;</ph>to<ph x="19">&lt;w19/&gt;</ph>Byte<ph x="20">&lt;w20/&gt;</ph>Offset:<ph x="21">&lt;w21/&gt;</ph>as:)<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept> does not change the bound type of the memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>store<ph x="17">&lt;w17/&gt;</ph>Bytes(of:<ph x="18">&lt;w18/&gt;</ph>to<ph x="19">&lt;w19/&gt;</ph>Byte<ph x="20">&lt;w20/&gt;</ph>Offset:<ph x="21">&lt;w21/&gt;</ph>as:)<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>を呼び出すことは、そのメモリの束縛される型を変更しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>swap<ph x="5">&lt;w5/&gt;</ph>At(_:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> with the same index as both <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>i<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> and <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>j<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> has no effect.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>swap<ph x="5">&lt;w5/&gt;</ph>At(_:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>i<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>と<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>j<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>両方で同じインデックスで呼び出すことは、効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>move()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method on a pointer <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>p<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> that references memory of type <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is equivalent to the following code, aside from any cost and incidental side effects of copying and destroying the value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>move()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを、型<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のメモリを参照するポインタ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>p<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>上で呼び出すことは、その値のコピーおよび破棄のあらゆるコストと付随する副作用を除いて、以下のコードと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method on a dictionary with bridged storage triggers a copy to contiguous storage even if the existing storage has room to store <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>minimum<ph x="5">&lt;w5/&gt;</ph>Capacity<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドをブリッジされたストレージを持つ辞書で呼び出すことは、隣接ストレージへのコピーを引き起こします、たとえ既存のストレージに<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>minimum<ph x="5">&lt;w5/&gt;</ph>Capacity<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>キー値ペアを格納する余地があるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method on a set with bridged storage triggers a copy to contiguous storage even if the existing storage has room to store <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>minimum<ph x="5">&lt;w5/&gt;</ph>Capacity<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドをブリッジされたストレージを持つ集合で呼び出すことは、隣接ストレージへのコピーを引き起こします、たとえ既存のストレージに<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>minimum<ph x="5">&lt;w5/&gt;</ph>Capacity<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>要素を格納する余地があるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method on an array with bridged storage triggers a copy to contiguous storage even if the existing storage has room to store <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>minimum<ph x="5">&lt;w5/&gt;</ph>Capacity<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドをブリッジされたストレージを持つ配列で呼び出すことは、隣接ストレージへのコピーを引き起こします、たとえ既存のストレージに<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>minimum<ph x="5">&lt;w5/&gt;</ph>Capacity<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>要素を格納する余地があるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>remove<ph x="5">&lt;w5/&gt;</ph>Subrange(_:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method instead is preferred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>remove<ph x="5">&lt;w5/&gt;</ph>Subrange(_:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドを代わりに呼ぶことが好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling the <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>insert(contents<ph x="11">&lt;w11/&gt;</ph>Of:<ph x="12">&lt;w12/&gt;</ph>at:)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> method instead is preferred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>insert(contents<ph x="11">&lt;w11/&gt;</ph>Of:<ph x="12">&lt;w12/&gt;</ph>at:)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>メソッドを代わりに呼ぶことが好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling the function with different class types shows how the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>get<ph x="8">&lt;w8/&gt;</ph>Default<ph x="9">&lt;w9/&gt;</ph>Value()<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> class method is only conditionally available.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数を異なるクラス型で呼び出すことは、どのように<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>get<ph x="8">&lt;w8/&gt;</ph>Default<ph x="9">&lt;w9/&gt;</ph>Value()<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>クラスメソッドが条件付きでのみ利用可能であるのかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling the related <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sorted()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method is equivalent to calling this method and passing the less-than operator (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&lt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>) as the predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連した<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sorted()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを呼び出すことは、このメソッドを呼び出して、より小さい演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&lt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）を述部として渡すことと等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling this function breaks the guarantees of Swift’s type system; use with extreme care.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数を呼ぶことは、Swiftの型システムの保証を壊します；最大限の注意を払ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling this initializer copies the contents of the substring to a new string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザを呼ぶことは、下位文字列の内容を新しい文字列にコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling this method invalidates all indices with respect to the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドを呼び出すことは、この辞書に関するすべてのインデックスを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling this method invalidates any existing indices for use with this dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドを呼び出すことは、この辞書で使うためのあらゆる既存のインデックスを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling this method invalidates any existing indices for use with this string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドを呼び出すことは、この文字列で使うためのあらゆる既存のインデックスを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling this method may invalidate all saved indices of this collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドを呼び出すことは、このコレクションの全ての保存されたインデックスを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling this method may invalidate any existing indices for use with this collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドを呼び出すことは、このコレクションで使うためのあらゆる既存のインデックスを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calls a closure with a pointer to the array’s contiguous storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャを配列のもつ隣接ストレージへのポインタとともに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calls the given closure on each element in the sequence in the same order as a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたクロージャをそのシーケンスの各要素上で<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ループと同じ順番で呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calls the given closure with a mutable pointer to the given argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクロージャを与えられた引数に対する可変ポインタを使って呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calls the given closure with a pointer to the array’s mutable contiguous storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクロージャを配列のもつ可変の隣接ストレージへのポインタとともに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calls the given closure with a pointer to the contents of the string, represented as a null-terminated sequence of UTF-8 code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>null終端のUTF-8コード単位シーケンスとして表される、文字列の内容へのポインタとともに与えられたクロージャを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calls the given closure with a pointer to the contents of the string, represented as a null-terminated sequence of code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>null終端のコード単位シーケンスとして表される、文字列の内容へのポインタとともに与えられたクロージャを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calls the given closure with a pointer to the underlying bytes of the array’s contiguous storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクロージャを、配列の隣接ストレージの基礎をなすバイトへのポインタとともに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calls the given closure with a pointer to the underlying bytes of the array’s mutable contiguous storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクロージャを、配列の可変の隣接ストレージの基礎をなすバイトへのポインタとともに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Case transformations aren’t guaranteed to be symmetrical or to produce strings of the same lengths as the originals.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>大文字小文字変換は、対称的であることを、または元と同じ長さの文字列を生み出すことを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Casting AnyObject Instances to a Known Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>AnyObjectインスタンスを既知の型へキャストする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Casting Between Integer Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数型の間でキャストする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Casting is always safe in the context of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>switch<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キャストは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>switch<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>文の文脈においては常に安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Changing Case</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>大文字小文字の変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Checking for Containment</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>制約を調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Checks a necessary condition for making forward progress.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは進捗を前へ進めるために必要な条件を確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Choosing the Smallest and Largest Value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最小および最大値を選ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Clamping Conversion</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>固定変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Clamping a Range</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲を固定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class instance identity, on the other hand, is compared using the triple-equals identical-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>===<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一方、クラスインスタンス同一性は、３つの等号の同一性演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>===<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closed range</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>完結範囲</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closure Casting</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャのキャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Coalescing Nil Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>nil値の合体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Collection Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクション実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Collection Literals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Collection Mutability</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの可変性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Collection Traversal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクション横断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Collections</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さまざまなコレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Collections are used extensively throughout the standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションは標準ライブラリの至る所で広範囲にわたって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Collections of Indices</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インデックスのコレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Collections that conform to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> gain the ability to change the value of their elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するコレクションは、それらの要素の値を変更する能力を獲得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Combine strings using the concatenation operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>連結演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って文字列を結合してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Combining Sets</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合を結合する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Combining Unicode scalars do not have their own position in a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結合ユニコードスカラーは、それら自身の位置を文字列において持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Command Line Input</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コマンドライン入力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Command-line arguments for the current process.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>現在のプロセスに対するコマンドライン引数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Common conversions that are supported by the standard library include the following:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリによってサポートされる普通の変換は、以下を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Common data structures such as <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Array<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>, <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Dictionary<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>, and <bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Set<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一般的なデータ構造体、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Array<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>、<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Dictionary<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>、そして<bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Set<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept>など</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparable Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Comparable 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparable Requirements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Comparable 要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compare tuples of between two and six <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements using these comparative operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つと６つの間の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素のタプルをそれらの比較演算を使って比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compare tuples of between two and six <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements for equality or inequality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つと６つの間の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素のタプルを同等性または不当性について比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compare two <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Strideable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Strideable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compares strings as sorted by the Finder.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列をFinderでソートされるように比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compares the string and a given string using a case-insensitive, localized, comparison.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>大文字小文字を考慮しない、ローカライズされた比較を使って、文字列を与えられた文字列と比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compares the string and a given string using a localized comparison.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ローカライズされた比較を使って、文字列を与えられた文字列と比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compares the string using the specified options and returns the lexical ordering for the range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列を指定されたオプションを使って比較して、範囲の語彙的順序を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Across Integer Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さまざまな整数型を比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Array Slices</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列スライスを比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Arrays</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Boolean Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブール値を比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Buffers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファの比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Characters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Dictionaries</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Doubles</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Doubleを比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Floats</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Floatの比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Identity</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同一性の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Indices</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インデックスの比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Optional Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル値の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Pointers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインタを比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Ranges</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Sets</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合を比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Strings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Strings Using Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列を演算子を使って比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing strings for equality using the equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) or a relational operator (like <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&lt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>&gt;=<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>) is always performed using the Unicode canonical representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）または関係演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&lt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>&gt;=<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のような）を使う文字列の比較は、常にユニコード正準表現を使って実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing strings using the equal-to operator (==) or a relational operator (like &lt; and &gt;=) is always performed using the Unicode canonical representation, so that different representations of a string compare as being equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列を同等演算子（==）または関係演算子（&lt;および&gt;=）を使って比較することは、常にユニコード正準表現を使って実行されます、そのためある文字列の異なる表現は同等であると比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparison</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compile-Time Strings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイル時文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: Amortized O(1) if the dictionary does not wrap a bridged <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSDictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：この辞書が、ブリッジされた<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSDictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をラップしないならば均してO(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: Amortized O(1) if the dictionary does not wrap a bridged <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSDictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, the performance is unspecified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：この辞書が、ブリッジされた<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSDictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をラップしないならば均してO(1)；それ以外では、性能は不特定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: Amortized O(1) if the set does not wrap a bridged <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSSet<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：この集合がブリッジされた<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSSet<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をラップしないならば、均してO(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: Amortized O(1) over many additions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：多くの追加にわたって均してO(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: Averages to O(1) over many calls to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>pop<ph x="2">&lt;w2/&gt;</ph>First()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：多くの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>pop<ph x="2">&lt;w2/&gt;</ph>First()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対する呼び出しにわたって均してO(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(1)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(1) if <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Random<ph x="4">&lt;w4/&gt;</ph>Access<ph x="5">&lt;w5/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; O(<bpt i="6" x="6">&lt;e6&gt;</bpt>n<ept i="6">&lt;/e6&gt;</ept>) otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Random<ph x="4">&lt;w4/&gt;</ph>Access<ph x="5">&lt;w5/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するならばO(1)；そうでないならばO(<bpt i="6" x="6">&lt;e6&gt;</bpt>n<ept i="6">&lt;/e6&gt;</ept>)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(1) if <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Random<ph x="4">&lt;w4/&gt;</ph>Access<ph x="5">&lt;w5/&gt;</ph>Collection<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; O(<bpt i="6" x="6">&lt;e6&gt;</bpt>n<ept i="6">&lt;/e6&gt;</ept>) otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Random<ph x="4">&lt;w4/&gt;</ph>Access<ph x="5">&lt;w5/&gt;</ph>Collection<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するならばO(1)；そうでないならばO(<bpt i="6" x="6">&lt;e6&gt;</bpt>n<ept i="6">&lt;/e6&gt;</ept>)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Random<ph x="2">&lt;w2/&gt;</ph>Access<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>), where <bpt i="5" x="5">&lt;e5&gt;</bpt>n<ept i="5">&lt;/e5&gt;</ept> is the absolute value of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>n<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(1)、もしコレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Random<ph x="2">&lt;w2/&gt;</ph>Access<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば；そうでなければ、O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>)、そこで<bpt i="5" x="5">&lt;e5&gt;</bpt>n<ept i="5">&lt;/e5&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>n<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の値の絶対値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Random<ph x="2">&lt;w2/&gt;</ph>Access<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>), where <bpt i="5" x="5">&lt;e5&gt;</bpt>n<ept i="5">&lt;/e5&gt;</ept> is the length of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：コレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Random<ph x="2">&lt;w2/&gt;</ph>Access<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば、O(1)；そうでなければ、O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>)、そこで<bpt i="5" x="5">&lt;e5&gt;</bpt>n<ept i="5">&lt;/e5&gt;</ept>はコレクションの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Random<ph x="2">&lt;w2/&gt;</ph>Access<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>), where <bpt i="5" x="5">&lt;e5&gt;</bpt>n<ept i="5">&lt;/e5&gt;</ept> is the resulting distance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(1)、もしコレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Random<ph x="2">&lt;w2/&gt;</ph>Access<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば；そうでなければ、O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>)、そこで<bpt i="5" x="5">&lt;e5&gt;</bpt>n<ept i="5">&lt;/e5&gt;</ept>は結果となる隔たりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Random<ph x="2">&lt;w2/&gt;</ph>Access<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(1) コレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Random<ph x="2">&lt;w2/&gt;</ph>Access<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば；そうでなければ、O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(1) on average, over many additions to the same collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：同じコレクションへの多くの追加に対して、均してO(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(1).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subrange<ph x="2">&lt;w2/&gt;</ph>.count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) if you are replacing a suffix of the array with an empty collection; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept> is the length of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：あなたが配列の末尾を空のコレクションで置き換えるならばO(<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subrange<ph x="2">&lt;w2/&gt;</ph>.count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>)；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>は配列の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>m<ept i="2">&lt;/e2&gt;</ept> is the length of this sequence and <bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept> is the length of the result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>m<ept i="2">&lt;/e2&gt;</ept>はこのシーケンスの長さで、<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>は結果の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept> is the combined length of the character view and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Elements<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>は文字ビューと<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Elements<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を合わせた長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept> is the combined length of the collection and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Elements<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はコレクションと<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Elements<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を合わせた長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept> is the combined length of the string and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Elements<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>は文字列と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Elements<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を合わせた長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept> is the combined length of the view and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Elements<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>はビューと<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Elements<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を合わせた長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>) if the array is bridged, where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the array; otherwise, O(1).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：配列がブリッジされるならばO(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は配列の長さです；そうでなければ、O(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>) if the underlying string is bridged from Objective-C, where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the string; otherwise, O(1).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：基礎をなす文字列がObjective-CからブリッジされるならばO(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は文字列の長さです；そうでなければ、O(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>max<ph x="4">&lt;w4/&gt;</ph>Length<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>max<ph x="4">&lt;w4/&gt;</ph>Length<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the absolute value of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>n<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、そこで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>n<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の値の絶対値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the capacity being reserved.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は確保されている容量です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the combined length of the string and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Elements<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は文字列と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Elements<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を合わせた長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>substring<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>substring<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は配列の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はコレクションの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the resulting array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は結果となる配列の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the resulting collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は結果となるコレクションの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the resulting view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は結果となるビューの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はシーケンスの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は文字列の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the number of elements in the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は配列の中の要素数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はコレクションの中の要素数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the number of elements to drop from the beginning of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はコレクションの始まりから省かれる要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the number of elements to drop from the beginning of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はシーケンスの始まりから省かれる要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the number of elements to drop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は省く要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the number of key-value pairs in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は辞書の中のキー値ペアの数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the ratio between unfiltered and filtered collection counts.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はコレクションのフィルタされないものとフィルタされたもの数の比率です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the resulting distance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は結果となる隔たりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は指定された要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complexity: Reading an element from an array is O(1).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算量：ある要素を配列から読み出すことはO(1)です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Concatenating Collections</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションを連結する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to ExpressibleByArrayLiteral</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ExpressibleByArrayLiteralに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to ExpressibleByExtendedGraphemeClusterLiteral</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ExpressibleByExtendedGraphemeClusterLiteralに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to ExpressibleByFloatLiteral</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ExpressibleByFloatLiteralに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to ExpressibleByIntegerLiteral</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ExpressibleByIntegerLiteralに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to ExpressibleByStringLiteral</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ExpressibleByStringLiteralに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to ExpressibleByUnicodeScalarLiteral</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ExpressibleByUnicodeScalarLiteralに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the BidirectionalCollection Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>BidirectionalCollectionプロトコルへの準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the Collection Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Collectionプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the Comparable Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Comparableプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the CustomDebugStringConvertible Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>CustomDebugStringConvertibleプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the CustomStringConvertible Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>CustomStringConvertibleプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the Equatable Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Equatableプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the ExpressibleByDictionaryLiteral Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ExpressibleByDictionaryLiteralプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the ExpressibleByStringInterpolation Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ExpressibleByStringInterpolationプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the FixedWidthInteger Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>FixedWidthIntegerプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the Hashable Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Hashableプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the MutableCollection Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>MutableCollectionプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the Numeric Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Numericプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the RandomAccessCollection Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>RandomAccessCollectionプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the RangeReplaceableCollection Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>RangeReplaceableCollectionプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the Sequence Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Sequenceプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the SetAlgebra Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>SetAlgebraプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the SignedNumeric Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>SignedNumericプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the TextOutputStream Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>TextOutputStreamプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming to the TextOutputStreamable Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>TextOutputStreamableプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforming types are notionally continuous, one-dimensional values that can be offset and measured.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>準拠する型は、概念上連続的な、一次元の値で、それはオフセットできて計測できるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conforms To</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次に準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Consider a class called <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Integer<ph x="2">&lt;w2/&gt;</ph>Ref<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that wraps an integer value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Integer<ph x="2">&lt;w2/&gt;</ph>Ref<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と呼ばれるクラスを考えてください、それはある整数値をラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Construct from an integer offset.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数オフセットから組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Construct with value <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>v<ph x="2">&lt;w2/&gt;</ph>.value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>v<ph x="2">&lt;w2/&gt;</ph>.value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Contains a buffer object, and provides access to an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Header<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and contiguous storage for an arbitrary number of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instances stored in that buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファオブジェクトを収容します、そして<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Header<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスへのアクセスおよびそのバッファに格納される随意の数の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスの隣接保管を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Contains context for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デバッグのための前後関係を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Contains the attempted key, along with context for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>試みられるキー、それだけでなくデバッグのための前後関係を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Contains the attempted type, along with context for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>試みられる型、それだけでなくデバッグのための前後関係を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Contains the attempted value, along with context for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>試みられる値、それだけでなくデバッグのための前後関係を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property is an O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>) operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>反対に、前方または双方向性のコレクションはコレクション全体を辿っていくことで含まれる要素の数を数えるので、それの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティにアクセスすることはO(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>)演算になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conversely, the comparison returns <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>false<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> if only one of the arguments is <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>nil<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> or if the two arguments wrap values that are not equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>反対に、この比較が<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>false<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を返すのは、引数のうち１つだけが<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>nil<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>であるか、２つの引数が等しくない値をラップする場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conversion stops when the buffer fills or when the conversion isn’t possible due to the chosen encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファが一杯になる場合または選択されたエンコーディングによって変換が可能でない場合は、変換は停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Convert your pointer to an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance and then use the raw pointer’s <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>load(from<ph x="7">&lt;w7/&gt;</ph>Byte<ph x="8">&lt;w8/&gt;</ph>Offset:<ph x="9">&lt;w9/&gt;</ph>as:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>store<ph x="12">&lt;w12/&gt;</ph>Bytes(of:<ph x="13">&lt;w13/&gt;</ph>to<ph x="14">&lt;w14/&gt;</ph>Byte<ph x="15">&lt;w15/&gt;</ph>Offset:<ph x="16">&lt;w16/&gt;</ph>as:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> methods to read and write values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのポインタを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスに変換して、それから生のポインタのもつ<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>load(from<ph x="7">&lt;w7/&gt;</ph>Byte<ph x="8">&lt;w8/&gt;</ph>Offset:<ph x="9">&lt;w9/&gt;</ph>as:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>と<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>store<ph x="12">&lt;w12/&gt;</ph>Bytes(of:<ph x="13">&lt;w13/&gt;</ph>to<ph x="14">&lt;w14/&gt;</ph>Byte<ph x="15">&lt;w15/&gt;</ph>Offset:<ph x="16">&lt;w16/&gt;</ph>as:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>メソッドを使って値を読み書きしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Convert your pointer to an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance and then use the raw pointer’s <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>load(from<ph x="6">&lt;w6/&gt;</ph>Byte<ph x="7">&lt;w7/&gt;</ph>Offset:<ph x="8">&lt;w8/&gt;</ph>as:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method to read values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのポインタを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスに変換して、それから生のポインタのもつ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>load(from<ph x="6">&lt;w6/&gt;</ph>Byte<ph x="7">&lt;w7/&gt;</ph>Offset:<ph x="8">&lt;w8/&gt;</ph>as:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドを使って値を読みだしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converting Between Numeric Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数値型の間で変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converting Between Range Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲型の間で変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converting Exactly</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正確に変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converting Floating-Point Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点値の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converting Integers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converting Numeric Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数値を変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converting Other Types to Strings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の型を文字列に変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converting Pointers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインタの変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converting Ranges</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲を変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converting Strings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converting a C String</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C文字列を変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converting a Substring to a String</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>SubstringをStringに変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converts a typed <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to an opaque C pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付けされた<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を不透明Cポインタへと変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converts a typed <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to an opaque C pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付けされた<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を不透明Cポインタへと変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converts the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>’s content to a given encoding and stores them in a buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のもつ内容を与えられた符号化に変換してそれらをバッファに格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Copies from a collection of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> into this buffer’s memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>からなるコレクションからこのバッファのメモリにコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Copies the specified number of bytes from the given raw pointer’s memory into this buffer’s memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたバイト数を、与えられた生のボインタのもつメモリからこのバッファのもつメモリにコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Copies the specified number of bytes from the given raw pointer’s memory into this pointer’s memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた生のポインタの持つメモリからこのポインタの持つメモリに指定されたバイト数をコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Copying a value of type <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Unsafe<ph x="6">&lt;w6/&gt;</ph>Buffer<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> does not copy the instances stored in the underlying memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Unsafe<ph x="6">&lt;w6/&gt;</ph>Buffer<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の値をコピーすることは、基礎をなすメモリをコピーしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Copying a value of type <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Unsafe<ph x="7">&lt;w7/&gt;</ph>Mutable<ph x="8">&lt;w8/&gt;</ph>Buffer<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> does not copy the instances stored in the underlying memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Unsafe<ph x="7">&lt;w7/&gt;</ph>Mutable<ph x="8">&lt;w8/&gt;</ph>Buffer<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の値をコピーすることは、基礎をなすメモリをコピーしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Copying a variable or constant of type <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Unsafe<ph x="7">&lt;w7/&gt;</ph>Raw<ph x="8">&lt;w8/&gt;</ph>Buffer<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> does not copy the underlying memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Unsafe<ph x="7">&lt;w7/&gt;</ph>Raw<ph x="8">&lt;w8/&gt;</ph>Buffer<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の変数や定数をコピーすることは、基礎をなすメモリをコピーしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Copying a variable or constant of type <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Unsafe<ph x="8">&lt;w8/&gt;</ph>Mutable<ph x="9">&lt;w9/&gt;</ph>Raw<ph x="10">&lt;w10/&gt;</ph>Buffer<ph x="11">&lt;w11/&gt;</ph>Pointer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> does not copy the underlying memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Unsafe<ph x="8">&lt;w8/&gt;</ph>Mutable<ph x="9">&lt;w9/&gt;</ph>Raw<ph x="10">&lt;w10/&gt;</ph>Buffer<ph x="11">&lt;w11/&gt;</ph>Pointer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の変数や定数をコピーすることは、基礎をなすメモリをコピーしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Copying an iterator is safe, but advancing one copy of an iterator by calling its <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>next()<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method may invalidate other copies of that iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるイテレータをコピーすることは安全です、しかしあるインスタンスの１つのコピーをそれのメソッド<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>next()<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドを呼び出すことによって前に進めることは、そのイテレータの他のコピーを無価値にするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Copying bytes directly from nontrivial, in-memory values does not produce valid copies and can only be done by calling a C API, such as <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>memmove()<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自明でない、メモリ中の値から直接にバイトをコピーすることは、有効なコピーを生成しません、そして<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>memmove()<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>のようなC APIを呼び出すことでのみ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Copying memory that contains values of nontrivial types can only be done safely with a typed pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自明でない型の値を含むメモリをコピーすることは、型付ポインタでのみ安全になされることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create a collection of all the values in a range by using the half-open (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>..&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) and closed (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>...<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>) range operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある範囲の中のすべての値からなる１つのコレクションを半開（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>..&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）および完結（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>...<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）範囲演算子を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance from the new index values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを新しいインデックス値から作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create a new dictionary by using a dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい辞書を辞書リテラルを使って作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create a new instance of the most-derived class, calling <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>factory<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> on the partially-constructed object to generate an initial <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Header<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最も派生したクラスの新しいインスンタスを作成します、部分的に組み立てられたオブジェクト上で<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>factory<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出して初期<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Value<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create a new range using the closed range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>...<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい範囲を完結範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>...<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create a new range using the half-open range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>..&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい範囲を半開範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>..&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create a slice of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>absences<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array starting after the index found in step 1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>absences<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列のスライスを、手順１で見つけたインデックスの後から開始して作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create a slice of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>absences<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array that holds the second half of the days.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>学期後半の日付を保持する、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>absences<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列のスライスを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create a stride that steps over values between two boundaries using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>stride(from:<ph x="2">&lt;w2/&gt;</ph>to:<ph x="3">&lt;w3/&gt;</ph>by:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>stride(from:<ph x="6">&lt;w6/&gt;</ph>through:<ph x="7">&lt;w7/&gt;</ph>by:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの境界の間の値をまたぐストライドを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>stride(from:<ph x="2">&lt;w2/&gt;</ph>to:<ph x="3">&lt;w3/&gt;</ph>by:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>stride(from:<ph x="6">&lt;w6/&gt;</ph>through:<ph x="7">&lt;w7/&gt;</ph>by:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>関数を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create an enumeration that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Error<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol with a case for each possible error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Error<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する列挙を、各ありうるエラーに対して１つのケース節で作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create instances of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Bool<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> by using one of the Boolean literals <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>true<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> or <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, or by assigning the result of a Boolean method or operation to a variable or constant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Bool<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のインスタンスをブールリテラルの<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>true<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>または<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>のうち１つを使うことによって、またはブールのメソッドや演算の結果を変数や定数に代入することによって作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create new instances of floating-point types using integer or floating-point literals.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点型の新しいインスタンスを、整数または浮動小数点リテラルを使って作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create with new storage containing an initial <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Header<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and space for at least <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>minimum<ph x="4">&lt;w4/&gt;</ph>Capacity<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>element<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある初期<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Header<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と少なくとも<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>minimum<ph x="4">&lt;w4/&gt;</ph>Capacity<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>element<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に対する空間を格納している新しいストレージを使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a NaN (“not a number”) value with the specified payload.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたペイロードをもつNaN（「非数」）値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a Unicode scalar with the specified numeric value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数値を使ってユニコードスカラーを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a Unicode scalar with the specified value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された値を使ってユニコードスカラーを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a buffer over the same memory as the given buffer slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたバッファスライスと同じメモリのすべてを覆うバッファを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a buffer over the specified number of contiguous bytes starting at the given pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数の隣接バイトすべてを覆うバッファを、与えられたポインタで開始して作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a character containing the given Unicode scalar value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたユニコードスカラー値を含んでいるひとつの文字を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a character from a single-character string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある単一文字の文字列から１つの文字を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a character with the specified value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された値でひとつの文字を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a collection containing the specified number of the given element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数の与えられた要素を含んでいるコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a dictionary initialized with a dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書リテラルで初期化される辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a dictionary with at least the given number of elements worth of buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>少なくとも指定された要素の数に相当するバッファを持つ辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a duplicate of the given Unicode scalar.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたユニコードスカラーの複製を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a flattened view of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の平坦な見方を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a mutable typed pointer referencing the same memory as the given immutable pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変の型付ポインタを作成します、与えられた不変ポインタと同じメモリを参照しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance from the given dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを与えられた辞書リテラルから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new Boolean value from the given string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字列から新しいブール値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new array containing the specified number of a single, repeated value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数の、ある単一の値の繰り返しを含んでいる新しい配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new buffer over the same memory as the given buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたバッファと同じメモリのすべてを覆う新しいバッファを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new buffer pointer over the specified number of contiguous instances beginning at the given pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたポインタで始まっている指定された数の隣接インスタンスすべてを覆う新しいバッファポインタを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new collection by concatenating the elements of a collection and a sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコレクションとあるシーケンスの要素を連結することによって新しいコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new collection by concatenating the elements of a sequence and a collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンスとあるコレクションの要素を連結することによって新しいコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new collection by concatenating the elements of two collections.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのコレクションの要素を連結することによって新しいコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new collection containing the specified number of a single, repeated value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数の、ある単一の値の繰り返しを含んでいる新しいコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new dictionary from the key-value pairs in the given sequence, using a combining closure to determine the value for any duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい辞書を与えられたシーケンスの中のキー値ペアから作成します、結び付けられているクロージャを使ってあらゆる重複キーに対する値を特定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new dictionary from the key-value pairs in the given sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい辞書を与えられたシーケンスの中のキー値ペアから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new dictionary where the keys are the groupings returned by the given closure and the values are arrays of the elements that returned each specific key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい辞書を作成します、そこにおいてキーは与えられたクロージャによって返されるグループ分けです、そして値は特定のキーそれぞれで返される要素からなる配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new floating-point value using the sign of one value and the magnitude of another.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値の符号ともう一方の規模とを使って新しい浮動小数点値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new index into a reversed collection for the position before the specified index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>逆にされたコレクションへのある新しいインデックスを、指定されたインデックスの前の位置に対して、作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new index wrapping <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をラップしている新しいインデックスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new instance by decoding from the given decoder.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたデコーダからデコードすることで新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new instance from the bit pattern of the given instance by sign-extending or truncating to fit this type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型に適合するように符号拡張または切り詰めることによって、指定インスタンスのビットパターンから新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new instance from the given integer, if it can be represented exactly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた整数から新しいインスタンスを作成します、もしそれが正確に表現できるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new instance from the given integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた整数から新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new instance from the given string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値から新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new instance from the given value, rounded to the closest possible representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値から新しいインスタンスを作成します、最も近い可能な表現に丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new instance from the specified sign and bit patterns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された符号とビットパターンから新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new instance initialized to the given value, if it can be represented without rounding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが丸めなしに表されるならば、与えられた値に初期化される新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new instance initialized to the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値に初期化される新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new instance of a collection containing the elements of a sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンスの要素を含んでいるあるコレクションの新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new instance that approximates the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値におおよそ相当する新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new instance with the representable value that’s closest to the given integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた整数に最も近い表現可能な値を使って新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new instance with the same memory representation as the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値と同じメモリ表現で新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new instance with the specified raw value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された生の値を持つ新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new integer value from the given string and radix.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい整数値を与えられた文字列と基数から作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new mutable buffer over the same memory as the given buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたバッファと同じメモリを覆う新しい可変バッファを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new mutable raw pointer from the given immutable raw pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい可変の生のポインタを与えられた不変の生のポインタから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new option set from the given raw value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた生の値から新しいオプションセットを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new pointer from the given typed pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた型付ポインタから新しいポインタを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new pointer, offset backward from a pointer by a specified number of instances of the pointer’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいポインタを返します、あるポインタからそのポインタの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスを指定された数だけ後方へ補います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new pointer, offset from a pointer by a specified number of instances of the pointer’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいポインタを返します、あるポインタからそのポインタの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスを指定された数だけ補います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new raw pointer from an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Autoreleasing<ph x="2">&lt;w2/&gt;</ph>Unsafe<ph x="3">&lt;w3/&gt;</ph>Mutable<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい生のポインタを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Autoreleasing<ph x="2">&lt;w2/&gt;</ph>Unsafe<ph x="3">&lt;w3/&gt;</ph>Mutable<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new raw pointer from the given address, specified as a bit pattern.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい型付ポインタを与えられたアドレスから作成します、ビットパターンとして指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new raw pointer from the given mutable raw pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい生のポインタを与えられた可変の生のポインタから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new raw pointer from the given opaque pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい生のポインタを与えられた不透明ポインタから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new raw pointer from the given raw or typed pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた生のまたは型付ポインタから新しい生のポインタを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new raw pointer from the given typed pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい生のポインタを与えられた型付ポインタから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new sequence that wraps and forwards operations to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をラップしてそれへと演算を転送する新規シーケンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new set from a finite sequence of items.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの要素からなる有限のシーケンスから集合を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new string by concatenating the given interpolations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた補間を連結することによって新しい文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new string by copying and validating the null-terminated UTF-8 data referenced by the given pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい文字列を、与えられたポインタによって参照されるヌル終端のUTF-8データをコピーして検証することによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new string by copying the null-terminated UTF-8 data referenced by the given pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい文字列を、与えられたポインタによって参照されるヌル終端のUTF-8データをコピーすることによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new string by copying the null-terminated data referenced by the given pointer using the specified encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい文字列を、与えられたポインタによって参照されるヌル終端のデータをコピーすることによって作成します、指定された符号化を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new string containing the characters in the given sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたシーケンスの中のいくらかの文字を含んでいるある新しい文字を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new string from the given substring.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい文字列を与えられた下位文字列から作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new string representing the given string repeated the specified number of times.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された回数繰り返された与えられた文字列を表している新しい文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new typed pointer from the given address, specified as a bit pattern.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい型付ポインタを、ビットパターンとして指定された与えられたアドレスから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new typed pointer from the given opaque pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた不透明ポインタから新しい型付ポインタを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new value from the given floating-point literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた不動小数点リテラルから新しい値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new value from the given integer literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた整数リテラルから新しい値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new value from the given sign, exponent, and significand.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた符号、指数、そして仮数から新しい値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new value with the bit pattern of the given pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたポインタのビットパターンで新しい値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new value with the given bit pattern.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたビットパターンから新しい値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new value, rounded to the closest possible representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい値を作成します、最も近い可能な表現へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new, empty array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい、空の配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new, empty collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい、空のコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a new, empty set with at least the specified number of elements’ worth of buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>少なくとも指定された要素の数に相当するバッファを持つ新しい、空の集合を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a raw buffer over the contiguous bytes in the given typed buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された型付バッファの中の隣接バイトすべてを覆う生のバッファを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a raw buffer over the same memory as the given raw buffer slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された生のバッファスライスと同じメモリのすべてを覆う生のバッファを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a sequence of pairs built out of two underlying sequences.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの根底にあるシーケンスから組み立てられるペアからなるシーケンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a sequence that presents the elements of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> sequences concatenated using <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>separator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンス、それは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>シーケンスたちの要素を、与えられた<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>separator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使って連結して提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a sequence whose <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>make<ph x="2">&lt;w2/&gt;</ph>Iterator()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method forwards to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>make<ph x="5">&lt;w5/&gt;</ph>Underlying<ph x="6">&lt;w6/&gt;</ph>Iterator<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>make<ph x="2">&lt;w2/&gt;</ph>Iterator()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>make<ph x="5">&lt;w5/&gt;</ph>Underlying<ph x="6">&lt;w6/&gt;</ph>Iterator<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>へと転送するあるシーケンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a set containing the elements of the given array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた配列リテラルの要素を含んでいる集合を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a string containing the given character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字を含んでいる文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a string containing the given expression’s textual representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた式のもつテキスト表現を含んでいる文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a string containing the given value’s textual representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値のもつテキスト表現を含んでいる文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a string corresponding to the given collection of Unicode scalars.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたユニコードスカラーのコレクションに対応する文字列を組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a string corresponding to the given sequence of UTF-16 code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたUTF-16コード単位の連続に対応する文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a string corresponding to the given sequence of UTF-8 code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたUTF-8コード単位の連続に対応する文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a string from the given Unicode code units in the specified encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたユニコード単位から指定されたエンコーディングで文字列を作成する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a string from the given character view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字ビューから文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a string from the null-terminated sequence of bytes at the given pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたポインタでのnull終端のバイトシーケンスから文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a string from the null-terminated, UTF-8 encoded sequence of bytes at the given pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あたらえれたポインタでの、null終端の、UTF-8エンコードされたバイトシーケンスから文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a string representing the given character repeated the specified number of times.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された回数繰り返された与えられた文字を表している文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a string representing the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値を表している文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a string with a detailed representation of the given value, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値の詳細な表現での文字列を作成します、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a type-erased collection that wraps the given collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたコレクションをラップする型消去コレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a type-erased hashable value that wraps the given instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型消去ハッシュ化値を作成します、それは与えられたインスタンスをラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a value initialized to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゼロに初期化される値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a view into the given collection that allows access to elements within the specified range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたコレクションに関するあるビューを作成します、それは指定された範囲の内の要素にアクセスを与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates a view of the given string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字列のビューを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Bidirectional<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> having the same underlying collection as <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>other<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Bidirectional<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を作成します、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>other<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と同じ基礎をなすコレクションを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> having the same underlying collection as <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>other<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を作成します、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>other<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と同じ基礎をなすコレクションを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Random<ph x="3">&lt;w3/&gt;</ph>Access<ph x="4">&lt;w4/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> having the same underlying collection as <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>other<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Random<ph x="3">&lt;w3/&gt;</ph>Access<ph x="4">&lt;w4/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を作成します、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>other<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>と同じ基盤コレクションを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Opaque<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> from a given address in memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリ中の与えられたアドレスから<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Opaque<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an array containing the elements of a sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンスの要素を含んでいる配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an array from the given array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された配列リテラルから配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an empty character view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の文字ビューを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an empty dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an empty option set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空のオプションセットを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an empty set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の集合を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an empty static string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の静的文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an empty string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an empty substring.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の下位文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an empty view instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空のビューインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an immutable typed pointer referencing the same memory as the given mutable pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>不変の型付ポインタを作成します、与えられた不変ポインタと同じメモリを参照しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an index in the given UTF-16 view that corresponds exactly to the specified <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF8View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたUTF-16ビューの中のあるインデックスを作成します、それは指定された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF8View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>位置に正確に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an index in the given UTF-16 view that corresponds exactly to the specified <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたUTF-16ビューの中のあるインデックスを作成します、それは指定された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>位置に正確に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an index in the given UTF-16 view that corresponds exactly to the specified string position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたUTF-16ビューの中のあるインデックスを作成します、それは指定された文字列位置に正確に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an index in the given UTF-8 view that corresponds exactly to the specified <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF16View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたUTF-8ビューの中のあるインデックスを作成します、それは指定された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF16View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>位置に正確に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an index in the given UTF-8 view that corresponds exactly to the specified <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたUTF-8ビューの中のあるインデックスを作成します、それは指定された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>位置に正確に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an index in the given UTF-8 view that corresponds exactly to the specified string position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたUTF-8ビューの中のあるインデックスを作成します、それは指定された文字列位置に正確に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an index in the given Unicode scalars view that corresponds exactly to the specified <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF16View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたユニコードスカラービューの中のあるインデックスを作成します、それは指定された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF16View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>位置に正確に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an index in the given Unicode scalars view that corresponds exactly to the specified <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF8View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたユニコードスカラービューの中のあるインデックスを作成します、それは指定された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF8View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>位置に正確に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an index in the given Unicode scalars view that corresponds exactly to the specified string position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたユニコードスカラービューの中のあるインデックスを作成します、それは指定された文字列位置に正確に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an index in the given string that corresponds exactly to the specified <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF16View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字列の中のあるインデックスを作成します、それは指定された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF16View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>位置に正確に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an index in the given string that corresponds exactly to the specified <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF8View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字列の中のあるインデックスを作成します、それは指定された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF8View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>位置に正確に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an index in the given string that corresponds exactly to the specified <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字列の中のあるインデックスを作成します、それは指定された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>位置に正確に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance containing just <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ただ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>だけを含んでいるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance equal to the given Boolean value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたブール値と同じインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance equivalent to the given range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた範囲と等しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance from the description of a given <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lossless<ph x="2">&lt;w2/&gt;</ph>String<ph x="3">&lt;w3/&gt;</ph>Convertible<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lossless<ph x="2">&lt;w2/&gt;</ph>String<ph x="3">&lt;w3/&gt;</ph>Convertible<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの叙述からインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance initialized to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に初期化されるインスタクスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance initialized to a single character that is made up of one or more Unicode code points.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつ以上のユニコードコード点でできているある単一の文字へと初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance initialized to the given Boolean value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたブール値に初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance initialized to the given string value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字列値へ初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance initialized to the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値に初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance initialized to the specified Boolean literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたブールリテラルに初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance initialized to the specified floating-point value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された浮動小数点値に初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance initialized to the specified integer value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された整数値に初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance initialized to the value of a string literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列リテラルの値へと初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance initialized with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>で初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance initialized with the given elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた要素で初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance initialized with the given key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた「キー値」ペアで初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance of the UTF-16 codec.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-16コーデックのインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance of the UTF-32 codec.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-32コーデックのインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance of the UTF-8 codec.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-8コーデックのインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance of the codec.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコーデックのインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance that stores the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値を格納するインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance that uniquely identifies the given class instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクラスインスタンスを固有に識別するインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance that uniquely identifies the given metatype.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたメタタイプを固有に識別するインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance whose iterator is a copy of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それのイテレータが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のコピーであるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance with the given bounds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた境界を使ってインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つのインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an integer from its big-endian representation, changing the byte order if necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それのビッグエンディアン表現から整数を作成します、必要ならばバイト順を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an integer from its little-endian representation, changing the byte order if necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それのリトルエンディアン表現から整数を作成します、必要ならばバイト順を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an integer from the given floating-point value, if it can be represented exactly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた浮動小数点値から整数を作成します、もしそれが正確に表現可能ならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an integer from the given floating-point value, truncating any fractional part.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた浮動小数点値から整数を作成します、どんな小数部分も切り詰めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an integer that captures the full value of the given object identifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたオブジェクト識別子の完全な値を捕獲する整数を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an integer using the specified big-endian representation, changing the byte order if necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたビッグエンディアンを使って整数を作成します、必要ならばバイト順を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an integer using the specified little-endian representation, changing the byte order if necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたリトルエンディアンを使って整数を作成します、必要ならばバイト順を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an iterator that presents the elements of the sequences traversed by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, concatenated using <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>separator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるイテレータ、それは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によって辿っていかれるいくらかのシーケンスに属するいくらかの要素を、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>separator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使って連結して提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an iterator that wraps a base iterator but whose type depends only on the base iterator’s element type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基盤イテレータをラップするイテレータを作成します、しかしそれの型は基盤イテレータのもつ要素型にのみ影響を受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an iterator that wraps the given closure in its <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクロージャをそれの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中にラップするイテレータを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an unmanaged reference with an unbalanced retain.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>管理されない参照を不均衡なリテイン（保持）で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creates an unmanaged reference without performing an unbalanced retain.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>管理されない参照を不均衡なリテイン（保持）を実行することなしに作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a Boolean From Another Value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>別の値からあるブールを作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a Buffer</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a Character</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a Dictionary</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a New Collection</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいコレクションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a Nil Value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>nil値の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a Range</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a Range Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲式を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a Set</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a String</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a String Using Formats</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列を様々な形式を使って作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a String from Unicode Data</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列をユニコードデータから作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a String from a File or URL</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ファイルまたはURLから文字列を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a Value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating an Array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating an Optional Value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル値の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating an Unbounded Range</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無限範囲の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating and iterating over a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countdown<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> sequence uses a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Countdown<ph x="4">&lt;w4/&gt;</ph>Iterator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to handle the iteration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countdown<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>シーケンス全体にわたっての作成や反復は、その反復を取り扱う<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Countdown<ph x="4">&lt;w4/&gt;</ph>Iterator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Custom Encoding and Decoding</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>カスタムエンコーディングとデコーディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Customizing Your Type's Reflection</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの型のリフレクションのカスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deallocates memory referenced by the pointer with the specified size and alignment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタによって参照されるメモリを指定された大きさとアライメントでデアロケートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deallocates memory that was allocated for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>個の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のインスタンスに対してアロケートされたメモリをデアロケートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deallocates the memory viewed by this buffer pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このバッファポインタによるビューでのメモリを割り当て解除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Debugging and Reflection</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デバッグとリフレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declare a <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>next()<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method that advances one step in the related sequence and returns the current element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>next()<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドを宣言してください、それは関連シーケンスにおいて一歩前へ進みます、そして現在の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declare additional preconfigured option set values as static properties initialized with an array literal containing other option values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>追加のあらかじめ構成されるオプションセット値を、他のオプション値を含んでいる配列リテラルで初期化される静的プロパティとして宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declares methods backing binary arithmetic operators–such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>*<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>–and their mutating counterparts.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バイナリ算術演算 – 例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>そして<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>*<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> – そしてそれらの可変の相当物などを裏打ちするメソッドを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decoders should provide types conforming to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unkeyed<ph x="2">&lt;w2/&gt;</ph>Decoding<ph x="3">&lt;w3/&gt;</ph>Container<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for their format.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらデコーダーは、それらの形式に対して<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unkeyed<ph x="2">&lt;w2/&gt;</ph>Decoding<ph x="3">&lt;w3/&gt;</ph>Container<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠する型を提供すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decodes a nested container and returns a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance for decoding <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>super<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> from that container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされたコンテナをデコードして、デコードする<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>super<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対する<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスをそのコンテナから返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decodes a nested container keyed by the given type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた型によってキー付けされる入れ子にされたコンテナをデコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decodes a null value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>null値をデコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decodes a single value of the given type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた型の単一の値をデコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decodes a value of the given type for the given key, if present.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された型の値を与えられたキーに対してデコードします、もし存在するならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decodes a value of the given type for the given key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された型の値を与えられたキーに対してデコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decodes a value of the given type, if present.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた型の値をデコードします、もし存在するならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decodes a value of the given type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた型の値をデコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decodes an unkeyed nested container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー付けされない入れ子にされたコンテナをデコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decoding Containers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デコーディングコンテナ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Default Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Default Literal Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時のリテラル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Default Types for Literals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リラテルのための省略時の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Default implementation provided.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の実装の提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Default implementations provided.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの省略時の実装の提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deinitializes the specified number of values starting at this pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタで開始して、指定された数の値をデイニシャライズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deinitializing typed memory does not unbind that memory’s type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付メモリのデイニシャライズは、そのメモリの型を束縛解除しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Depending on the type, it may make sense to allocate more or less storage than requested or to take no action at all.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型によって、要請されたよりも多くまたは少なく割り当てるまたは全く行動を起こさないことが道理にかなっているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Depending on the type, it may make sense to allocate more or less storage than requested, or to take no action at all.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型によって、要請されたよりも多くまたは少なく割り当てること、または全く行動を起こさないことが道理にかなっているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Depending on your needs, you may find it useful to “upgrade” instances of this type to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Bidirectional<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Any<ph x="6">&lt;w6/&gt;</ph>Random<ph x="7">&lt;w7/&gt;</ph>Access<ph x="8">&lt;w8/&gt;</ph>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのさまざまな必要に応じて、この型のインスタンスを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Bidirectional<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Any<ph x="6">&lt;w6/&gt;</ph>Random<ph x="7">&lt;w7/&gt;</ph>Access<ph x="8">&lt;w8/&gt;</ph>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に「アップグレード」するのは便利なことをあなたは発見するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deprecated</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非推奨</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deprecated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非推奨。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Describes the parts—such as stored properties, collection elements, tuple elements, or the active enumeration case—that make up a particular instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さまざまな部品—例えば保存プロパティ、コレクションの要素、タプルの要素、またはアクティブな列挙ケース節など—特定のインスタンスを作り上げるものを叙述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Describing a Boolean</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブールを記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Describing a Character</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字の説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Describing a Dictionary</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある辞書の記述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Describing a Double</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるDoubleの記述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Describing a Float</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Floatを記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Describing a Pointer</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるポインタの記述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Describing a Range</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲を記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Describing a Set</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるSetの記述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Describing a String</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列を記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Describing an Array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列を記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Describing an Error</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーを記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Describing an Integer</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数を記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Description</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Determining Composed Character Sequences</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>合成文字シーケンスを特定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Determining Line and Paragraph Ranges</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行と段落範囲を特定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dictionaries are empty when created with an initializer or an empty dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書は、イニシャライザまたは空の辞書リテラルで作成した場合は空です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dictionary Literals as Function Parameters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数パラメータとしての辞書リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dictionary has two subscripting interfaces:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書は２つの添え字インターフェイスを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Different keyed containers from the same <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> may return different keys here; it is possible to encode with multiple key types which are not convertible to one another.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>からの異なるキー付けコンテナは、異なるキーをここで返すかもしれません；互いに変換できないところの複数のキー型を使ってエンコードすることは可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Discussion</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>解説</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Divide</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>除算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Divide and assign</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>除算と代入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Divides the first value by the second and stores the quotient in the left-hand-side variable, rounding to a representable value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の値を２番目の値で除算して、商を左手側の変数に格納します、表現可能な値へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Divides the first value by the second and stores the quotient in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の値を２番目の値で除算して、商を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Divides the first value by the second and stores the remainder in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の値を２番目の値で除算して、余りを左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dividing by zero is not an error when using this method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゼロによる除算は、このメソッドを使う場合はエラーではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not assign an instance of a nontrivial type through <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to uninitialized memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自明でない型のインスタンスを、未初期化メモリへの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を通してアサインしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not assign an instance of a nontrivial type through the subscript to uninitialized memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自明でない型のインスタンスを未初期化メモリへの添え字を通してアサインしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not call this initializer directly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザを直接に呼ばないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not escape it from the closure for later use.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それを後で使うためにクロージャから脱出させないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not persist the hash value across program runs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数のプログラム実行にまたがるハッシュ値に固執しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not rely on a previously stored index value after altering a collection with any operation that can change its length.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコレクションをそれの長さを変える何らかの演算で手直し後に、以前に格納されたインデックス値を当てにしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not rely on anything about the array that is the target of this method during execution of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure; it might not appear to have its correct value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドのターゲットである配列について<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャの実行の間に何であれ依存しないでください：それは、それの正しい値を持つように見えないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not save hash values to use during a future execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>将来の実行の間に使うためにハッシュ値を保存しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not store or return the pointer for later use.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後で使うためにポインタを格納したり返したりしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not use <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>unsafe<ph x="12">&lt;w12/&gt;</ph>Bit<ph x="13">&lt;w13/&gt;</ph>Cast(_:<ph x="14">&lt;w14/&gt;</ph>to:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> with class or pointer types; doing so may introduce undefined behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>unsafe<ph x="12">&lt;w12/&gt;</ph>Bit<ph x="13">&lt;w13/&gt;</ph>Cast(_:<ph x="14">&lt;w14/&gt;</ph>to:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>をクラスまたはポインタ型で使わないでください；そうすることは未定義挙動を導きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not use the string that is the target of this method inside the closure passed to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, as it may not have its correct value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドのターゲットである文字列を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡されるクロージ内部で使わないでください、それがそれの正しい値を持たないかもしれないので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not use this property to check whether a floating point value is negative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティを使って、ある浮動小数点値が負かどうか調べないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Does not NULL-terminate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ヌル終端しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Don’t expect any particular ordering of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの特定のキー値ペア順番付けを当てにしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Don’t expect any particular ordering of set elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの特定の集合要素順番を当てにしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Don’t store substrings longer than you need to perform a specific operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが特定の演算を実行するのに必要とするより長く下位文字列を貯蔵しておかないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Don’t use the equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to test whether a value is NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使ってある値がNaNかどうかをテストしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Double-Width Integers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２倍幅整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Download the playground below to get started.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレイグラウンドを下でダウンロードして始めましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dumps an object’s contents using its mirror to standard output.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるオブジェクトの内容をそれのミラーを使って標準出力にダンプします（どさっと落とします）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dumps an object’s contents using its mirror to the specified output stream.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクトの内容をそれのミラーを使って指定された出力ストリームにダンプします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>During the registration period, you need to add and remove names as students add and drop the class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>履修期間の間、あなたはそのクラスに生徒を加えたり落としたりするたびに名前を加えたり取り除いたりする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dynamic Sequences</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>動的なシーケンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> argument results in a linear search.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>引数は線形検索という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Decoding<ph x="3">&lt;w3/&gt;</ph>Result<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance can represent a Unicode scalar value, an indication that no more Unicode scalars are available, or an indication of a decoding error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Decoding<ph x="3">&lt;w3/&gt;</ph>Result<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、ユニコードスカラー値、これ以上利用可能なユニコードスカラーがないしるし、またはデコードエラーのしるしとして表されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each array has an independent value that includes the values of all of its elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各配列はひとつの独立した値を持ち、それはそれのいくらかある要素の値すべてを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each bit of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>raw<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> potentially represents an element of the option set, though raw values may include bits that are not defined as distinct values of the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Option<ph x="5">&lt;w5/&gt;</ph>Set<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>raw<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の各ビットは、潜在的にオプションセットの１つの要素を表します、けれども生の値は他とまったく異なった<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Option<ph x="5">&lt;w5/&gt;</ph>Set<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型の値として定義されないビットを含んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each byte in memory is viewed as a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>UInt8<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> value independent of the type of values held in that memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリ中の各バイトは、そのメモリ中に保持される値の型に影響を受けない<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>UInt8<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>値として眺められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each byte in memory is viewed as a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt8<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> value independent of the type of values held in that memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリ中の各バイトは、そのメモリ中に保持される値の型に影響を受けない<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt8<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>値として眺められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each code unit is stored as a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>UInt16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各コード単位は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>UInt16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスとして格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each code unit is stored as a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>UInt8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各コード単位は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>UInt8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスとして格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each element of a <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Character<ph x="5">&lt;w5/&gt;</ph>View<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> collection is a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Character<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Character<ph x="5">&lt;w5/&gt;</ph>View<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>コレクションの要素それぞれは、ひとつの<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Character<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each element of a string is represented by a <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Character<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の各要素は、ある<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Character<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスによって表現されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each element of the range is its own corresponding index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲の各要素はそれ自身の付随インデックスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each entry in the table is identified using its key, which is a hashable type such as a string or number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのテーブル（表）の中の登録項目はそれのキーを使って特定され、そのキーはハッシュ化型、例えば文字列や数などです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each floating-point type has its own possible range and precision.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各浮動小数点型は、それ独自の可能な範囲と精度を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each key in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>elements<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be unique.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各キーは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>elements<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>において特有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each key in the keys collection has a unique value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このキーコレクションの中の各キーは、特有な値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each of these scalar values, in turn, is too large to fit into a single UTF-16 or UTF-8 code unit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらスカラー値のそれぞれは、今度は、ある単一のUTF-16またはUTF-8コード単位にぴったり合うには大きすぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each property provides access to a view of the string as a series of code units, each encoded in a different Unicode representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各プロパティは、文字列のあるビューへのアクセスを一続きのコード単位として提供し、それぞれが異なるユニコード表現においてエンコードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each scalar value is represented by a <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unicode<ph x="5">&lt;w5/&gt;</ph>.Scalar<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance and is equivalent to a UTF-32 code unit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各スカラー値は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unicode<ph x="5">&lt;w5/&gt;</ph>.Scalar<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスによって表されて、ひとつのUTF-32コード単位と同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each segment of the string literal before, between, and after any included expressions, along with the individual expressions themselves, are passed to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(string<ph x="2">&lt;w2/&gt;</ph>Interpolation<ph x="3">&lt;w3/&gt;</ph>Segment:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆる含められた式の前、間、後の文字列リテラル各分節は、個々の式それ自体も含めて、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(string<ph x="2">&lt;w2/&gt;</ph>Interpolation<ph x="3">&lt;w3/&gt;</ph>Segment:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each time an element of the lazy sequence is accessed, an element of the underlying array is accessed and transformed by the closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延シーケンスの中のある要素がアクセスされるたびに、基礎をなす配列の中のある要素がアクセスされてクロージャによって変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each time the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method is called on a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Countdown<ph x="4">&lt;w4/&gt;</ph>Iterator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance, it calculates the new next value, checks to see whether it has reached zero, and then returns either the number, or <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> if the iterator is finished returning elements of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Countdown<ph x="4">&lt;w4/&gt;</ph>Iterator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンス上で呼ばれるたびに、それは新しい次の値を計算し、それがゼロに届いたか見るために調べ、そしてそれからその数、またはそのイテレータがシーケンスの要素を返すことを完了するならば<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>のどちらかを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Elements are sorted in ascending order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素は昇順にソートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Elements that are in only one or the other are left out of the result of the intersection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どちらか一方にだけある要素は、交叉の結果から除外されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Elements that are used to split the collection are not returned as part of any subsequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションを分割するのに使われる要素らは、どれかの下位シーケンスの一部として返されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Elements that are used to split the sequence are not returned as part of any subsequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスを分割するのに使われる要素らは、どれかの下位シーケンスの一部として返されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encoders and Decoders</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エンコーダとデコーダ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encoders should provide types conforming to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Keyed<ph x="2">&lt;w2/&gt;</ph>Encoding<ph x="3">&lt;w3/&gt;</ph>Container<ph x="4">&lt;w4/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for their format.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらエンコーダは、それらの形式に対して<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Keyed<ph x="2">&lt;w2/&gt;</ph>Encoding<ph x="3">&lt;w3/&gt;</ph>Container<ph x="4">&lt;w4/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠する型を提供すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encoders should provide types conforming to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unkeyed<ph x="2">&lt;w2/&gt;</ph>Encoding<ph x="3">&lt;w3/&gt;</ph>Container<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for their format.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エンコーダは、それらの形式に対して<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unkeyed<ph x="2">&lt;w2/&gt;</ph>Encoding<ph x="3">&lt;w3/&gt;</ph>Container<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠する型を提供するべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encodes a Unicode scalar as a UTF-32 code unit by calling the given closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-32コード単位としてのユニコードスカラーを与えられたクロージャを呼び出すことによってエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encodes a Unicode scalar as a series of code units by calling the given closure on each code unit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクロージャを各コード単位上で呼び出すことによって、ユニコードスカラーを一連のコード単位としてエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encodes a nested container and returns an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Encoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance for encoding <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>super<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> into that container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされたコンテナをエンコードして、エンコードする<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>super<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対する<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Encoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスをそのコンテナに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encodes a nested container keyed by the given type and returns it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた型によってキー付けされる入れ子にされたコンテナをエンコードしてそれを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encodes a null value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>null値をエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encodes a single value of the given type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた型の単一の値をエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encodes an unkeyed encoding container and returns it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー付けされないエンコーディングコンテナをエンコードしてそれを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encodes the elements of the given sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたシーケンスに属する要素をエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encodes the given object weakly for the given key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたキーに対する与えられた値を弱くエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encodes the given object weakly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたオブジェクトを弱くエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encodes the given value for the given key if it is not <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたキーに対する与えられた値をエンコードします、それが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>でないならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encodes the given value for the given key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたキーに対する与えられた値をエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encodes the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値をエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encodes this value into the given encoder.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値を与えられたエンコーダにエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encoding Containers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エンコーディングコンテナ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encoding and Decoding</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エンコーディングとデコーディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encoding and Decoding Custom Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あつらえの型のエンコーディングとデコーディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encoding and Storage</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エンコードとストレージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Encoding, Decoding, and Serialization</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エンコード、デコード、そしてシリアライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerates all the lines in a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のすべての行を列挙します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerates the substrings of the specified type in the specified range of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された範囲の文字列の中の指定された型の下位文字列を列挙します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumeration Case</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙ケース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumeration Cases</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙ケース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations with Raw Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の値を持つ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Equal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Equality and Ordering</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同等性と順序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Equality implies substitutability—any two instances that compare equally can be used interchangeably in any code that depends on their values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同等性は代替可能性を暗黙的に意味します—同等性を比較されるあらゆる２つのインスタンスは、それらの値に影響を受けるあらゆるコードにおいて入れ替えて使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Equality is Separate From Identity</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同等性は同一性と別個のものです</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Equality is the inverse of inequality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同等性は、不等性の裏返しです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Equatable Requirements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Equatable 要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Equivalent to</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次に等価です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Equivalent to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ph x="2">&lt;w2/&gt;</ph>.range<ph x="3">&lt;w3/&gt;</ph>Of<ph x="4">&lt;w4/&gt;</ph>String(other) != nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次に等しい <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ph x="2">&lt;w2/&gt;</ph>.range<ph x="3">&lt;w3/&gt;</ph>Of<ph x="4">&lt;w4/&gt;</ph>String(other) != nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Equivalent to calling <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>super<ph x="2">&lt;w2/&gt;</ph>Decoder(for<ph x="3">&lt;w3/&gt;</ph>Key:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Key(string<ph x="6">&lt;w6/&gt;</ph>Value: "super", int<ph x="7">&lt;w7/&gt;</ph>Value: 0)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>super<ph x="2">&lt;w2/&gt;</ph>Decoder(for<ph x="3">&lt;w3/&gt;</ph>Key:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Key(string<ph x="6">&lt;w6/&gt;</ph>Value: "super", int<ph x="7">&lt;w7/&gt;</ph>Value: 0)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を呼び出すことと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Equivalent to calling <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>super<ph x="2">&lt;w2/&gt;</ph>Encoder(for<ph x="3">&lt;w3/&gt;</ph>Key:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Key(string<ph x="6">&lt;w6/&gt;</ph>Value: "super", int<ph x="7">&lt;w7/&gt;</ph>Value: 0)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>super<ph x="2">&lt;w2/&gt;</ph>Encoder(for<ph x="3">&lt;w3/&gt;</ph>Key:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Key(string<ph x="6">&lt;w6/&gt;</ph>Value: "super", int<ph x="7">&lt;w7/&gt;</ph>Value: 0)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を呼び出すことと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Errors</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Errors are written into the inout <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>error<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーはインアウト<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>error<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>引数へ書き込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Escaping the pointer to use after the execution of the function is undefined behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数の実行の後に使うためにポインタを脱出させることは、未定義の挙動となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Evaluates a closure while ensuring that the given instance is not destroyed before the closure returns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャを評価する一方で与えられたインスタンスがそのクロージャが返る前に破棄されないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Evaluates the given closure when this <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is not <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, passing the unwrapped value as a parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクロージャをこの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>でない場合に評価します、アンラップされた値をパラメータとして渡しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Evaluation of the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>||<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> operator is one of the following:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>||<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>演算子の評価は、次のうちの１つです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Evaluation of the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>&amp;&amp;<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> operator is one of the following:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>&amp;&amp;<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>演算子の評価は、次のうちの１つです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though the barrier guarantees that neither closure will escape the function, the <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>async(execute:)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> method still requires that the closures passed be marked as <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>@escaping<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>, so the first version of the function does not compile.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえこの障壁がどちらのクロージャも関数を脱出しないことを保証するとしても、<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>async(execute:)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>メソッドは依然としてこれらの渡されるクロージャが<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>@escaping<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>として印されることを要求します、それで最初のバージョンの関数はコンパイルしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is composed of one or more Unicode code points that are grouped together as an <bpt i="2" x="2">&lt;e2&gt;</bpt>extended grapheme cluster<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、１つの<bpt i="2" x="2">&lt;e2&gt;</bpt>拡張書記素クラスタ<ept i="2">&lt;/e2&gt;</ept>として一緒にまとめられる１つの以上のユニコードコード点から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Float<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Double<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> value is canonical, but noncanonical values of the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Float80<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type exist, and noncanonical values may exist for other types that conform to the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Floating<ph x="10">&lt;w10/&gt;</ph>Point<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Float<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Double<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>値は正準です、しかし<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Float80<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型の非正準値も存在します、そして<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Floating<ph x="10">&lt;w10/&gt;</ph>Point<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロトコルに準拠する他の型に対して非正準値が存在するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every array reserves a specific amount of memory to hold its contents.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての配列はある特定の量のメモリを確保することでその内容を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every dictionary is an unordered collection of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての辞書は、キー値ペアの順番付けられないコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every distinct value of the conforming type has a corresponding unique value of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Raw<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type, but there may be values of the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Raw<ph x="5">&lt;w5/&gt;</ph>Value<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type that don’t have a corresponding value of the conforming type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>準拠する型のすべての個々の値は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Raw<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型の対応する特有な値を持ちます、しかし準拠する型の値に対応しない<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Raw<ph x="5">&lt;w5/&gt;</ph>Value<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型の値があっても構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every element of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>numbers<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> up to, but not including, the first negative value is included in the result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の負の値までの、しかしそれを含まない、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>numbers<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のすべての要素は、この結果の中に含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every key in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>keys<ph x="4">&lt;w4/&gt;</ph>And<ph x="5">&lt;w5/&gt;</ph>Values<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be unique.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>keys<ph x="4">&lt;w4/&gt;</ph>And<ph x="5">&lt;w5/&gt;</ph>Values<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の中のすべてのキーは特有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every unsigned integer is its own magnitude, so for any value <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == x<ph x="4">&lt;w4/&gt;</ph>.magnitude<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての符号なし整数は、それ自身が規模（magnitude）です、それで何らかの値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>にとって、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == x<ph x="4">&lt;w4/&gt;</ph>.magnitude<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every value except NaN compares less than or equal to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+infinity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NaNを除くあらゆる値は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+infinity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>より少ないか等しいと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every value except for NaN and <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+infinity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> compares less than <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>+infinity<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NaNと<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+infinity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を除くあらゆる値は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>+infinity<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>より少ないと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Exact Conversion</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>厳密変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Example Buffer Class</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファクラスの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Example:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Exceptional values need not take part in the strict total order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それら普通でない値は、全順序において役割を果たすには及びません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Exchange the values of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の値を交換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Exchanges the values at the specified indices of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのコレクションの指定インデックスでの値を交換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Excluding Elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素を排除する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Executes the given closure while temporarily binding the specified number of instances to the given type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクロージャを実行します、その間は指定された数のインスタンスを与えられた型に一時的に束縛しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Existential Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>存在型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Exiting a Program</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プログラムの終了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Expanding this set to include types that represent more than simple Boolean values is discouraged.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単純なブール値より多く表現する型を含めるためにこの集合を拡大することは推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Expected Performance</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>期待される性能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Experiment with Swift standard library types and learn high-level concepts using visualizations and practical examples.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いろいろなSwift標準ライブラリ型を試したり、視覚化や実践例を使うことで高水準概念を学んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Explicit construction from an UnsafeMutablePointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UnsafeMutablePointerからの明示的な組み立て。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Explore the Standard Library</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリ探索</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Exposing nonvalue aspects of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Equatable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> types other than class identity is discouraged, and any that <bpt i="6" x="6">&lt;e6&gt;</bpt>are<ept i="6">&lt;/e6&gt;</ept> exposed should be explicitly pointed out in documentation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Equatable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型の非値の面を露出することはクラス識別子を除いて推奨されません、そして露出<bpt i="6" x="6">&lt;e6&gt;</bpt>される<ept i="6">&lt;/e6&gt;</ept>ものは何でも、明白に文書において指摘されるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>ExpressibleByExtendedGraphemeClusterLiteral Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ExpressibleByExtendedGraphemeClusterLiteral 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>ExpressibleByIntegerLiteral Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ExpressibleByIntegerLiteral 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>ExpressibleByStringLiteral Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ExpressibleByStringLiteral 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extended Precision Floating-Point Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張精度浮動小数点値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extending the compared character count to 15 includes the differing characters, so a nonzero result is returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>比較する文字を15を数えるまで広げることは異なる文字を含みます、それで非ゼロの結果が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Numeric<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> provide default implementations for the protocol’s nonmutating methods based on the mutating variants.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Numeric<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>への拡張は、そのプロトコルの非可変メソッドに対する省略時実装を可変版に基づいて提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Failure to satisfy that assumption is a serious programming error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>了解事項を満たすことの失敗は、重大なプログラミングエラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, memory that was allocated previously may have been deallocated, leaving existing pointers referencing unallocated memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結局、以前にアロケートされたメモリはデアロケートされるかもしれません、アロケートされないメモリを参照している既存のポインタはそのままです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, report the average temperature and observation counts:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後に、平均温度と観測数を報告します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finding Characters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字を見つける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finding Elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素を見つける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finding Substrings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位文字列を見つける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finding the Absolute Value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>絶対値を見つける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finding the Sign and Magnitude</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号と規模を見つける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finds and returns the range in the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> of the first character from a given character set found in a given range with given options.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた範囲の中の見つけられる措定された文字集合からの最初の文字の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>での範囲を見つけて返します、与えられたオプションを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finds and returns the range of the first occurrence of a given string within a given range of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, subject to given options, using the specified locale, if any.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた範囲の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>内で与えられた文字列の最初の出現の範囲を見つけて返します、与えられたオプションに従います、指定されたロケールを使います、もしあれば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finds and returns the range of the first occurrence of a given string, taking the current locale into account.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字列の最初の出現の範囲を見つけて返します、アカウントに対する現在のロケールをとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>First Steps</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初歩</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>First, a set of observations in Celsius is parsed from strings to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> values:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>まず、摂氏での観測の一揃いは、文字列から<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値へ解析されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>First, retrieve a sequence’s iterator, and then call the iterator’s <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>next()<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method until it returns <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>まず、あるシーケンスのもつイテレータを見つけて取ってきてください、そしてそのイテレータの持つ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>next()<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドを、それが<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を返すまで呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>First, the function finds the position of the last even number as a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Reversed<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in a reversed view of the array of numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初に、この関数は最後の偶数の位置を、数からなる配列の逆にされたビューにおける<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Reversed<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として捜します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>FixedWidthInteger Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>FixedWidthInteger実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Floating Point</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Floating-Point Operators for Double</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Double用の浮動小数点演算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Floating-Point Type Aliases</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点型エイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Floating-point types are used to represent fractional numbers, like 5.5, 100.0, or 3.14159274.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点型は、5.5、100.0、または3.14159274のような、小数を表すために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Floating-point types represent values that are neither finite numbers nor infinity as NaN, an abbreviation for “not a number.” Comparing a NaN with any value, including another NaN, results in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点型は、有限数でも無限大でもない値を「not a number」の略語、NaNで表します。NaNを別のNaNを含む何らかの値と比較することは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Floating-point values are represented as a <bpt i="0" x="0">&lt;e0&gt;</bpt>sign<ept i="0">&lt;/e0&gt;</ept> and a <bpt i="1" x="1">&lt;e1&gt;</bpt>magnitude<ept i="1">&lt;/e1&gt;</ept>, where the magnitude is calculated using the type’s <bpt i="2" x="2">&lt;e2&gt;</bpt>radix<ept i="2">&lt;/e2&gt;</ept> and the instance’s <bpt i="3" x="3">&lt;e3&gt;</bpt>significand<ept i="3">&lt;/e3&gt;</ept> and <bpt i="4" x="4">&lt;e4&gt;</bpt>exponent<ept i="4">&lt;/e4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点値は、<bpt i="0" x="0">&lt;e0&gt;</bpt>符号<ept i="0">&lt;/e0&gt;</ept>と<bpt i="1" x="1">&lt;e1&gt;</bpt>規模<ept i="1">&lt;/e1&gt;</ept>として表されます、そこにおいて規模はその型の<bpt i="2" x="2">&lt;e2&gt;</bpt>基数<ept i="2">&lt;/e2&gt;</ept>とインスタンスの<bpt i="3" x="3">&lt;e3&gt;</bpt>仮数<ept i="3">&lt;/e3&gt;</ept>と<bpt i="4" x="4">&lt;e4&gt;</bpt>指数<ept i="4">&lt;/e4&gt;</ept>を使って計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>FloatingPoint Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>FloatingPoint 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Encoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>s that implement this functionality, this will only encode the given object and associate it with the given key if it is encoded unconditionally elsewhere in the payload (either previously or in the future).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この機能性を実装する<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Encoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、これは与えられたオブジェクトをエンコードしてそれを与えられたキーと関連付けるだけです、それがペイロードのどこか他で無条件にエンコードされるならば（以前にまたはこれから先のどちらでも）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Encoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>s that implement this functionality, this will only encode the given object if it is encoded unconditionally elsewhere in the payload (either previously or in the future).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この機能性を実装する<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Encoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、これは与えられたオブジェクトをエンコードするだけです、それがペイロードのどこか他で無条件にエンコードされるならば（以前にまたはこれから先のどちらでも）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a buffer pointer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, all <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>p<ph x="4">&lt;w4/&gt;</ph>.count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> bytes referenced by <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>p<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> are deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファポインタ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、すべての<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>p<ph x="4">&lt;w4/&gt;</ph>.count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>バイトで<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>p<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>によって参照されるものは、割り当て解除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a pointer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the memory at <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>p + i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be initialized when reading the value by using the subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるポインタ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>p + i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>でのメモリは、添え字を使うことで値を読み出すとき初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a pointer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the memory at <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>p + i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるポインタ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>p + i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>でのメモリは、初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a type <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>F<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, positive and negative infinity are represented as <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>F<ph x="5">&lt;w5/&gt;</ph>.infinity<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>-F<ph x="8">&lt;w8/&gt;</ph>.infinity<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, respectively.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>F<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に対して、正と負の無限大はそれぞれ<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>F<ph x="5">&lt;w5/&gt;</ph>.infinity<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>-F<ph x="8">&lt;w8/&gt;</ph>.infinity<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>のように表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a type <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the resulting value is in the range <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ph x="6">&lt;w6/&gt;</ph>.min...T<ph x="7">&lt;w7/&gt;</ph>.max<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して、結果となる値は範囲<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ph x="6">&lt;w6/&gt;</ph>.min...T<ph x="7">&lt;w7/&gt;</ph>.max<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の中です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a value <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the comparison <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.sign == .minus<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is not necessarily the same as <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x &lt; 0<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、比較<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.sign == .minus<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は必ずしも<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x &lt; 0<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>と同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a value <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the result of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.divided<ph x="5">&lt;w5/&gt;</ph>Reporting<ph x="6">&lt;w6/&gt;</ph>Overflow(by: 0)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>(x, .overflow)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.divided<ph x="5">&lt;w5/&gt;</ph>Reporting<ph x="6">&lt;w6/&gt;</ph>Overflow(by: 0)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の結果は<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>(x, .overflow)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a value <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>x<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> of a floating-point type <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>F<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, the magnitude can be calculated as the following, where <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>**<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is exponentiation:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点型<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>F<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の値<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>x<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に対して、規模は次のように計算されることができます、ここで<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>**<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は冪演算です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>start<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is always zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスに対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>start<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は常にゼロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Contiguous<ph x="2">&lt;w2/&gt;</ph>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is always zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Contiguous<ph x="2">&lt;w2/&gt;</ph>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスに対して、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は常にゼロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For any enumeration with a string, integer, or floating-point raw type, the Swift compiler automatically adds <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Raw<ph x="2">&lt;w2/&gt;</ph>Representable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列、整数、または浮動小数点の生の型を持つ何らかの列挙に対して、Swiftコンパイラは自動的に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Raw<ph x="2">&lt;w2/&gt;</ph>Representable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For any finite value <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.next<ph x="5">&lt;w5/&gt;</ph>Down<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is greater than <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの有限の値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.next<ph x="5">&lt;w5/&gt;</ph>Down<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>より大きいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For any finite value <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.next<ph x="5">&lt;w5/&gt;</ph>Up<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is greater than <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの有限値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.next<ph x="5">&lt;w5/&gt;</ph>Up<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>より大きいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For any floating-point value <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> of type <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>F<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of the following is equal to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, with the distinction that the result is canonicalized if <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is in a noncanonical encoding:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>F<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の何らかの浮動小数点値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、以下の結果は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と等しいです、その違いは<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>が非正準符号化になるならば結果は正準化されることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For any numeric value <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.magnitude<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is the absolute value of <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの数値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.magnitude<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の絶対値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For any representable power of two, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>significand<ph x="2">&lt;w2/&gt;</ph>Width<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is zero, because <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>significand<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>1<ph x="7">&lt;w7/&gt;</ph>.0<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆる表現可能な２の冪に対して、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>significand<ph x="2">&lt;w2/&gt;</ph>Width<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はゼロです、なぜなら<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>significand<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>1<ph x="7">&lt;w7/&gt;</ph>.0<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For any two integers <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, their quotient <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>q<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, and their remainder <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>r<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>a == b * q + r<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの２つの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、それらの商<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>q<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、そしてそれらの余り<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>r<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に対して、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>a == b * q + r<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For any value <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.magnitude<ph x="5">&lt;w5/&gt;</ph>.sign<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>.plus<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.magnitude<ph x="5">&lt;w5/&gt;</ph>.sign<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>.plus<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For any values <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>a != b<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> implies that <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>a == b<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>false<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>a != b<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>a == b<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>が<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>false<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For any values <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>a == b<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> implies that <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>a != b<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>false<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>a == b<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>a != b<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>が<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>false<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For arrays of most <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types, this storage is a contiguous block of memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型の配列に対して、このストレージは隣接メモリブロックです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For arrays with an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type that is a class or <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>@objc<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol type, this storage can be a contiguous block of memory or an instance of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>NSArray<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列で<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型がクラスや<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>@objc<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコル型であるものに対して、このストレージは隣接メモリブロックまたは<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>NSArray<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>のインスタンスであることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For bridging to be possible, the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Element<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type of a set must be a class, an <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>@objc<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> protocol (a protocol imported from Objective-C or marked with the <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>@objc<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> attribute), or a type that bridges to a Foundation type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブリッジが可能にされるには、集合の<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Element<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型は、クラス、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>@objc<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロトコル（Objective-Cからインポートされるまたは<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>@objc<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>属性で印されるプロトコル）、またはあるFoundation型にブリッジする型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For bridging to be possible, the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Element<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type of your array must be a class, an <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>@objc<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> protocol (a protocol imported from Objective-C or marked with the <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>@objc<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> attribute), or a type that bridges to a Foundation type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブリッジが可能にされるには、あなたの配列の<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Element<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型は、あるクラス、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>@objc<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロトコル（Objective-Cからインポートされるまたは<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>@objc<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>属性で印されるプロトコル）、またはあるFoundation型にブリッジされる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For bridging to be possible, the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Key<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> and <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Value<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> types of a dictionary must be classes, <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>@objc<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> protocols, or types that bridge to Foundation types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブリッジが可能にされるには、辞書の<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Key<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>と<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Value<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>型がクラス、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>@objc<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>プロトコル、またはFoundation型にブリッジする型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For clearer, more concise code, the example above could use the array’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>contains(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method, which every sequence inherits from <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Sequence<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, instead of iterating manually:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より明確な、もっと簡潔なコードのために、上のコードは、すべてのシーケンスが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Sequence<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>から継承する、配列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>contains(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドを使うことが、労力を要する反復の代わりに可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For collections that don’t conform to <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Random<ph x="7">&lt;w7/&gt;</ph>Access<ph x="8">&lt;w8/&gt;</ph>Collection<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, accessing the <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>count<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> property iterates through the elements of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Random<ph x="7">&lt;w7/&gt;</ph>Access<ph x="8">&lt;w8/&gt;</ph>Collection<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠しないコレクションに対して、<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>count<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>プロパティにアクセスすることはコレクションの要素を始めから終わりまで反復します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example,</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Countable<ph x="7">&lt;w7/&gt;</ph>Range<it pos="begin" x="8">&lt;Int8&gt;</it><ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance can use <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Int8<ph x="10">&lt;w10/&gt;</ph>.max<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> as its upper bound, but it can’t represent a range that includes <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Int8<ph x="13">&lt;w13/&gt;</ph>.max<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Countable<ph x="7">&lt;w7/&gt;</ph>Range<it pos="begin" x="8">&lt;Int8&gt;</it><ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスは<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Int8<ph x="10">&lt;w10/&gt;</ph>.max<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>をそれの上側の境界として使うことができます、しかしそれは<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Int8<ph x="13">&lt;w13/&gt;</ph>.max<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>を含む範囲を表すことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, a country’s Unicode flag character is made up of two regional indicator code points that correspond to that country’s ISO 3166-1 alpha-2 code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ある国のユニコードの国旗文字は、その国のISO 3166-1 alpha-2コードに対応する２つの地域指定コード点から作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, a random-access collection, which can measure the distance between two indices in O(1) time, will be able to calculate its <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property in O(1) time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ランダムアクセスのコレクションは、２つのインデックス間の隔たりをO(1)時間で測ることが可能で、それの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティをO(1)時間で計算できるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, a random-access collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property is calculated in O(1) instead of requiring iteration of an entire collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、無作為アクセスコレクションのもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、コレクション全体の反復を要求したりせずにO(1)で計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, adding <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>UInt8<ph x="5">&lt;w5/&gt;</ph>.max<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> to itself results in a value that can’t be represented by an <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt8<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instance without overflowing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>UInt8<ph x="5">&lt;w5/&gt;</ph>.max<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>をそれ自身に加えることは、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt8<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスではオーバーフローなしに表せない値という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, after filtering a set of prime numbers to remove any below 10, you can create a new set by using this initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ひとそろいの素数をフィルタして10の前のどんなものも削除した後で、あなたは新しい集合をこのイニシャライザを使って作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, an ASCII character like the capital letter <bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept> is represented by a single element in each of its four views.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、大文字の<bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept>のようなあるひとつのASCII文字は、それの４つのビューのそれぞれにおいて単一の要素で表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, an attempt to convert the position of a UTF-16 trailing surrogate returns <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、UTF-16の後続サロゲートの位置を変換する試みは<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, an attempt to convert the position of a UTF-16 trailing surrogate returns <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>nil<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、UTF-16の後続サロゲートの位置を変換する試みは<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>nil<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, an attempt to convert the position of a UTF-8 continuation byte returns <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、UTF-8の継続バイトの位置を変換する試みは<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, an attempt to convert the position of a UTF-8 continuation byte returns <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、UTF-8の継続バイトの位置を変換する試みは<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, an attempt to convert the position of a UTF-8 continuation byte returns <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>nil<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、UTF-8の継続バイトの位置を変換する試みは<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>nil<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, an attempt to convert the position of the combining acute accent (<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>"\u{0301}"<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>) fails.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、結合文字のアキュートアクセント（<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>"\u{0301}"<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>）の位置を変換する試みは失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, an attempt to convert the position of the trailing surrogate of a UTF-16 surrogate pair fails.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、UTF-16のサロゲートペアの後続サロゲートの位置を変換する試みは失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, an instance of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> can represent the value <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>500<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, so the first conversion in the code sample below succeeds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のインスタンスは値<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>500<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を表せます、それで下のコード例の最初の変換は成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, because UTF-8 and UTF-16 represent high Unicode code points differently, an attempt to convert the position of a UTF-8 continuation byte fails.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、UTF-8とUTF-16は高位ユニコードコード点を異なって表すので、UTF-8の継続バイトの位置を変換する試みは失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, because UTF-8 and UTF-16 represent high Unicode code points differently, an attempt to convert the position of the trailing surrogate of a UTF-16 surrogate pair fails.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、UTF-8とUTF-16は高位ユニコードコード点を異なって表すので、UTF-16のサロゲートペアの後続サロゲートの位置を変換する試みは失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, bridging from <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>NSArray<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> to <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Array&lt;Int&gt;<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> performs such a copy.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>NSArray<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>から<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Array&lt;Int&gt;<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>へのブリッジは、そのようなコピーを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider a custom <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countdown<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あるあつらえの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countdown<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>シーケンスを考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider a custom type called <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Shipping<ph x="2">&lt;w2/&gt;</ph>Options<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that is an option set of the possible ways to ship a customer’s purchase.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Shipping<ph x="2">&lt;w2/&gt;</ph>Options<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と呼ばれるあつらえの型を考えてください、それは顧客の購入品を出荷する可能な方法のオプションセットです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, given an eager <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>scan<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method defined as follows</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のように定義される即時<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>scan<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドを与えられて</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if a variable has the type <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int?<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, that’s just another way of writing <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Optional&lt;Int&gt;<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ある変数が型<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int?<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を持つとすれば、それは<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Optional&lt;Int&gt;<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を記述することのありきたりのやり方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if the two <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>year<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> properties are equal but the two <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>month<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> properties are not, the date with the lesser value for <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>month<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is the lesser of the two dates.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、２つの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>year<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは等しいけれども２つの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>month<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティは異なるならば、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>month<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に対してより少ない値を持つ日付は２つの日付のうちより少ないものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if you update the last element of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>absences<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array from <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>0<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>2<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>second<ph x="8">&lt;w8/&gt;</ph>Half<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> slice is unchanged.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>absences<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列の最後の要素を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>0<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>から<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>2<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に更新する場合、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>second<ph x="8">&lt;w8/&gt;</ph>Half<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>スライスは変化していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if you want to print only the first word in a string, search for the index of the first space, and then create a subsequence up to that position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたがある文字列の最初の単語のみを出力したいならば、最初の空白のインデックスを捜して、それからその位置までの下位シーケンスを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if your array’s elements conform to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, you can call the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>sort()<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method without using arguments to sort the elements of your array in ascending order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたの配列のもつ要素が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するならば、あなたは<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>sort()<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドを引数を使うことなく呼び出して、あなたの配列の要素を昇順にソートすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, in a fixed-width integer type with a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bit<ph x="2">&lt;w2/&gt;</ph>Width<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value of 8, the number -8 has three trailing zeros.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、8の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bit<ph x="2">&lt;w2/&gt;</ph>Width<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を持つ固定長整数型において、数-8は後に続くゼロを３つ持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, in a fixed-width integer type with a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bit<ph x="2">&lt;w2/&gt;</ph>Width<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value of 8, the number 31 has five bits equal to 1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、８の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bit<ph x="2">&lt;w2/&gt;</ph>Width<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を持つ固定長整数型において、数31は５つの１に等しいビットを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, in a fixed-width integer type with a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bit<ph x="2">&lt;w2/&gt;</ph>Width<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value of 8, the number 31 has three leading zeros.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、８の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bit<ph x="2">&lt;w2/&gt;</ph>Width<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を持つ固定長整数型において、数31は３つの先頭のゼロを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, it would be reasonable to implement alternative operations in which operating on a signaling NaN triggers a runtime error or results in a diagnostic for debugging purposes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、それらにおいてはシグナルNaNに関する演算が実行時エラーを引き起こすまたはデバッグ目的の診断という結果になるといった、代替の演算を実装するのが妥当であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, iterating over an instance of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Countable<ph x="4">&lt;w4/&gt;</ph>Partial<ph x="5">&lt;w5/&gt;</ph>Range<ph x="6">&lt;w6/&gt;</ph>From&lt;Int&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> traps when the sequence’s next value would be above <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Int<ph x="9">&lt;w9/&gt;</ph>.max<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Countable<ph x="4">&lt;w4/&gt;</ph>Partial<ph x="5">&lt;w5/&gt;</ph>Range<ph x="6">&lt;w6/&gt;</ph>From&lt;Int&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のインスタンスの全体にわたって反復することは、そのシーケンスの次の値が<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Int<ph x="9">&lt;w9/&gt;</ph>.max<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>より上となる場合にトラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, passing a closed range with an upper bound of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int<ph x="4">&lt;w4/&gt;</ph>.max<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> triggers a runtime error, because the resulting half-open range would require an upper bound of <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int<ph x="7">&lt;w7/&gt;</ph>.max + 1<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, which is not representable as an <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Int<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int<ph x="4">&lt;w4/&gt;</ph>.max<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の上方境界を持つ完結範囲を渡すことは実行時エラーの引き金となります、結果の半開範囲は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int<ph x="7">&lt;w7/&gt;</ph>.max + 1<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の上方境界を要求するからです、それはある<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Int<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>では表せません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, passing a closed range with an upper bound of <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Int<ph x="5">&lt;w5/&gt;</ph>.max<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> triggers a runtime error, because the resulting half-open range would require an upper bound of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int<ph x="8">&lt;w8/&gt;</ph>.max + 1<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, which is not representable as an <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Int<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、完結範囲で<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Int<ph x="5">&lt;w5/&gt;</ph>.max<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の上方境界を持つものを渡すことは実行時エラーの引き金となります、結果の半開範囲は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int<ph x="8">&lt;w8/&gt;</ph>.max + 1<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の上方境界を要求するからです、それはある<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Int<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>として表せません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, passing an empty range as <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>other<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> triggers a runtime error, because an empty range cannot be represented by a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Closed<ph x="7">&lt;w7/&gt;</ph>Range<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、空の範囲を<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>other<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>として渡すことは実行時エラーの引き金となります、空の範囲は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Closed<ph x="7">&lt;w7/&gt;</ph>Range<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスによって表現されることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, passing an empty range as <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>other<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> triggers a runtime error, because an empty range cannot be represented by a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Countable<ph x="8">&lt;w8/&gt;</ph>Closed<ph x="9">&lt;w9/&gt;</ph>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、空の範囲を<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>other<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>として渡すことは実行時エラーの引き金となります、空の範囲は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Countable<ph x="8">&lt;w8/&gt;</ph>Closed<ph x="9">&lt;w9/&gt;</ph>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスによって表現されることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, suppose you have an array holding the number of absences from each class during a session.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたがある学期（２学期制）の各クラスの欠席者数が入った配列を持つと考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Counter<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> enumeration defined here has an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> raw value type and gives the first case a raw value of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>1<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ここで定義される<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Counter<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>列挙は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の生の値型を持ち、そして最初のケース節に生の値の<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>1<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を与えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type has an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>exponent<ph x="4">&lt;w4/&gt;</ph>Bit<ph x="5">&lt;w5/&gt;</ph>Count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> of 8, which gives an exponent bias of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>127<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> by the calculation above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、８の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>exponent<ph x="4">&lt;w4/&gt;</ph>Bit<ph x="5">&lt;w5/&gt;</ph>Count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を持ちます、それは<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>127<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の指数バイアスを上記の計算によって与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>contains()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method on <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>allowed<ph x="4">&lt;w4/&gt;</ph>Moves<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> performs a bitwise AND operation to check whether the option set contains an element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>contains()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソドは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>allowed<ph x="4">&lt;w4/&gt;</ph>Moves<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>上で、ビット単位AND演算を実行して、オプションセットがある要素を含むかどうか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>keys<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property of a dictionary isn’t an array with its own storage, it’s a collection that maps its elements from the dictionary only when they’re accessed, saving the time and space needed to allocate an array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、辞書の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>keys<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティはそれ自身のストレージを持つことになる配列ではありません、それはコレクションです、それはそれの要素らをそれらがアクセスされた時に限り辞書からマップします、そして配列を割り当てるのに必要とされる時間と空間を節約しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(address:<ph x="2">&lt;w2/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function in the following code sample takes an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Raw<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance as its first parameter:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(address:<ph x="2">&lt;w2/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は以下のコード例において、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Raw<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスをそれの最初のパラメータとして取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(address:<ph x="2">&lt;w2/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function in the following code sample takes an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Raw<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance as its first parameter:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(address:<ph x="2">&lt;w2/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は以下のコード例において、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Raw<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスをそれの最初のパラメータとして取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print<ph x="2">&lt;w2/&gt;</ph>Int(at<ph x="3">&lt;w3/&gt;</ph>Address:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function in the following code sample expects an <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Unsafe<ph x="6">&lt;w6/&gt;</ph>Mutable<ph x="7">&lt;w7/&gt;</ph>Pointer&lt;Int&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance as its first parameter:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print<ph x="2">&lt;w2/&gt;</ph>Int(at<ph x="3">&lt;w3/&gt;</ph>Address:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は以下のコード例において、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Unsafe<ph x="6">&lt;w6/&gt;</ph>Mutable<ph x="7">&lt;w7/&gt;</ph>Pointer&lt;Int&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスをそれの最初のパラメータとして期待します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print<ph x="2">&lt;w2/&gt;</ph>Int(at<ph x="3">&lt;w3/&gt;</ph>Address:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function in the following code sample expects an <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Unsafe<ph x="6">&lt;w6/&gt;</ph>Pointer&lt;Int&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance as its first parameter:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print<ph x="2">&lt;w2/&gt;</ph>Int(at<ph x="3">&lt;w3/&gt;</ph>Address:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は以下のコード例において、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Unsafe<ph x="6">&lt;w6/&gt;</ph>Pointer&lt;Int&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスをそれの最初のパラメータとして期待します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sum(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function shown here takes an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> array as a parameter:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ここで示す<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sum(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>リテラルをパラメータとしてとります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Int8<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> type has a <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>bit<ph x="15">&lt;w15/&gt;</ph>Width<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> value of 8 and can store any integer in the range <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>-128...127<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Int8<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>型は、８の<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>bit<ph x="15">&lt;w15/&gt;</ph>Width<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>値を持ち、範囲<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>-128...127<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>の中の何らかの整数を格納できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>remove<ph x="14">&lt;w14/&gt;</ph>Subrange(_:)<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> method is implemented by calling <bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>replace<ph x="17">&lt;w17/&gt;</ph>Subrange(_:<ph x="18">&lt;w18/&gt;</ph>with:)<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept> with an empty collection for the <bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>new<ph x="21">&lt;w21/&gt;</ph>Elements<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>remove<ph x="14">&lt;w14/&gt;</ph>Subrange(_:)<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>メソッドは、<bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>replace<ph x="17">&lt;w17/&gt;</ph>Subrange(_:<ph x="18">&lt;w18/&gt;</ph>with:)<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>を<bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>new<ph x="21">&lt;w21/&gt;</ph>Elements<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept>パラメータに対して空のコレクションで呼び出すことによって実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Direction<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> type defines an option set for the four directions you can move in a game.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Direction<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>型はオプションセットをあるゲームにおいてあなたが動かせる４つの方向のために定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>log(name:<ph x="4">&lt;w4/&gt;</ph>value:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> function shown here has an unconstrained generic <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>value<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ここで示す<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>log(name:<ph x="4">&lt;w4/&gt;</ph>value:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>関数は、制約のない総称体の<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>value<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>digits()<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> function in the following example creates an iterator over a collection that lazily maps the elements of a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Countable<ph x="7">&lt;w7/&gt;</ph>Range&lt;Int&gt;<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance to strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下の例の<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>digits()<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>関数は、あるコレクションを覆うイテレータを作成します、それは<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Countable<ph x="7">&lt;w7/&gt;</ph>Range&lt;Int&gt;<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスの要素を文字列へと遅延にマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the code sample below creates a dictionary with string keys and values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、下のコード見本はある辞書を文字列のキーと値で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code provides a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>binary<ph x="6">&lt;w6/&gt;</ph>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> property on every fixed-width integer that represents the number’s binary representation, split into 8-bit chunks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードは<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>binary<ph x="6">&lt;w6/&gt;</ph>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロパティをあらゆる固定長整数に関して提供します、それは数のバイナリ表現を、８ビットの塊へと分割して表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code sample creates a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance with a value of <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>7<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコード見本は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>7<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の値で作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code sample creates a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance with a value of <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>밥<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, the Korean word for rice:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコード見本は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスをコリアン単語での米、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>밥<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の値で作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code sample creates a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance with a value of an emoji character:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコード見本は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスをあるemoji文字の値で作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code sample does not compile, because it attempts to use the integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in a logical context:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードサンプルはコンパイルしません、なぜならそれが整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を論理的文脈において使おうとするからです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code sample finds the index of the first space in a string and then converts that to the same position in the UTF-16 view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコード見本は最初の空白のインデックスを文字列の中で見つけて、それからそれをUTF-16ビューでの同じ位置に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code sample finds the index of the first space in the string’s character view and then converts that to the same position in the UTF-8 view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下の例は最初の空白のインデックスを文字列のもつ文字ビューの中で見つけて、それからそれをUTF-8ビューでの同じ位置に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following conversions result in <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、次の変換は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>という結果になります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following conversions result in <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>nil<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下の変換は<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>nil<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>という結果になります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the integer value 1050 can be represented in its entirety as the string “1050”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、整数値1050はそっくりそのまま文字列「1050」として表されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the parameter passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>print<ph x="4">&lt;w4/&gt;</ph>Smiley<ph x="5">&lt;w5/&gt;</ph>Info(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> function in the example below is an instance of the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Smiley<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> class or one of its subclasses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、下の例において<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>print<ph x="4">&lt;w4/&gt;</ph>Smiley<ph x="5">&lt;w5/&gt;</ph>Info(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>関数に渡されるパラメータは、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Smiley<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>クラスまたはそれのサブクラスの１つのインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the result of the failable <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Int<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> initializer is unconditionally unwrapped in the example below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、この失敗できる<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Int<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>イニシャライザの結果は、下の例において無条件にアンラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the special “not a number” value for floating-point types (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Floating<ph x="4">&lt;w4/&gt;</ph>Point<ph x="5">&lt;w5/&gt;</ph>.nan<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>) compares as neither less than, greater than, nor equal to any normal floating-point value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、浮動小数点型のための特別な「数でない」値（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Floating<ph x="4">&lt;w4/&gt;</ph>Point<ph x="5">&lt;w5/&gt;</ph>.nan<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）は、何らかの通常の浮動小数点値とより少ないでも、より大きいでも、等しいでもないような比較をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, this custom <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> struct uses the default representation supplied by the standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、このあつらえの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> structは、標準ライブラリによって提供される省略時の表現を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, this custom <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> struct uses the default representation supplied by the standard library:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、このあつらえの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> structは、標準ライブラリによって提供される省略時の表現を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, to check whether an array contains a particular value, you can pass the value itself to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>contains(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method when the array’s element conforms to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Equatable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instead of providing a closure that determines equivalence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ある配列がある特定の値を含むかどうか調べるには、あなたはその値自体を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>contains(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドに渡すことが、その配列の要素が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Equatable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に準拠する場合には、同等を判定するクロージャを提供する代わりに可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, to display the last 20 children of a mirror if they can be accessed efficiently, you might write:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あるミラーの最後の20のchildrenを、もしそれらが効率的にアクセス可能なら、表示するには、あなたは以下を書くことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, to find the key for a particular value in a dictionary, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index(where:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ある特定の値に対するキーを辞書の中で捜すには、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index(where:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, to get the reversed version of a string, reverse its characters and initialize a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance from the result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ある文字列の逆版を得るには、それの文字を逆にして、新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスをその結果から初期化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, to get the reversed version of an array, initialize a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance from the result of this <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>reversed()<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ある配列の逆順版を手に入れるには、新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを、この<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>reversed()<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドの結果から初期化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, to replace a value stored in a raw pointer <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>p<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, where <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>U<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> is the current type and <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>T<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> is the new type, use a typed pointer to access and deinitialize the current value before initializing the memory with a new value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、生のポインタ<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>p<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に格納される値を置き換えるには、そこで<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>U<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>は現在の型で<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>T<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>は新しい型です、型付ポインタを使ってアクセスして現在の値をデイニシャライズしてください、新しい値でメモリを初期化する前にです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, to retrieve the first word of a longer string, you can search for a space and then create a substring from a prefix of the string up to that point:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ある長い文字列の最初の単語を取り出すには、あなたは空白を捜して、それから前の部分からその地点までの下位文字列を作成してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, to retrieve the first word of a longer string, you can search the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>characters<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view for a space and then create a new string from a prefix of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>characters<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view up to that point.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ある長い文字列の最初の単語を取り出すには、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>characters<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューの空白を捜して、それから新しい文字列を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>characters<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューの前の部分からその地点までから作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, use this initializer to create a string with ten <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"0"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> characters in a row.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、このイニシャライザを使うことで、10個の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"0"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>文字を１行に持つ文字列を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, use this initializer to create a string with ten <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"ab"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> strings in a row.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、このイニシャライザを使うことで、10個の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"ab"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>文字列を１行に持つ文字列を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, when converting a 16-bit value to an 8-bit type, only the lower 8 bits of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>source<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> are used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、16bit値を8bit型へ変換する場合、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>source<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の最も下位の8ビットが使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can add elements to an array of strings by calling any of the inserting or appending operations that the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol defines.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはいくつかの要素をある配列に加えることが、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルが定義する何らかの挿入または追加を行う演算を呼び出すことによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can also access the first character of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>text<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> using the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>first<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> property, which has the value of the first element of the collection, or <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> if the collection is empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはまた<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>text<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の最初の文字にアクセスすることが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>first<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロパティを使って行えます、それはコレクションの最初の要素の値、またはコレクションが空ならば<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can concatenate the elements of a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Range&lt;Int&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance and an integer array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはある<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Range&lt;Int&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスとある整数配列とに属する要素を連結することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can concatenate the elements of an integer array and a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Range&lt;Int&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはある整数配列とある<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Range&lt;Int&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスとに属する要素を連結することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can concatenate the elements of two integer arrays.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたは２つの整数配列に属する要素を連結することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can efficiently test a set for membership of an element or check its intersection with another set:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはある要素の帰属について能率的にテストすること、またはそれの別の集合との交差を調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can replace an element of an array by using its subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたは配列の中のある要素をそれの添え字を使うことによって置き換えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can sort <bpt i="0" x="0">&lt;e0&gt;</bpt>part<ept i="0">&lt;/e0&gt;</ept> of a mutable collection by calling the mutable <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>sort()<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> method on a subscripted subsequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはある可変コレクションの<bpt i="0" x="0">&lt;e0&gt;</bpt>一部分<ept i="0">&lt;/e0&gt;</ept>をソートすることが可変<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>sort()<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>メソッドを添え字で指定した下位シーケンス上で行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can test whether the first <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>UInt8<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> value in a string’s UTF-8 encoding is equal to the first <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>UInt32<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> value in its Unicode scalar view:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはある文字列のUTF-8符号化の中の最初の<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>UInt8<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>値が、それのユニコードスカラー値での最初の<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>UInt32<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>と等しいかどうかを試験できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can test whether the first <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>UInt8<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> value in a string’s UTF-8 encoding is not equal to the first <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>UInt32<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> value in its Unicode scalar view:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはある文字列のUTF-8符号化の中の最初の<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>UInt8<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>値が、それのユニコードスカラー値での最初の<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>UInt32<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>と等しくないかどうかを試験できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can use this method on an array of numbers to find their sum or product.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはこのメソッドを数値からなる配列で使うことで、それらの合計を見つけるまたは生成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can use this method to call an API that expects a pointer to a different type that is layout compatible with your pointer’s <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Pointee<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはこのメソッドを使うことで、異なる型へのポインタを期待するもので、あなたのポインタのもつ<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Pointee<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>と互換のレイアウトである、あるAPIを呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you could create an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ph x="2">&lt;w2/&gt;</ph>Pairs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> structure that holds a list of two-integer tuples and use an initializer that accepts a <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Dictionary<ph x="5">&lt;w5/&gt;</ph>Literal<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ph x="2">&lt;w2/&gt;</ph>Pairs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>構造体を作成することができます、それは２整数のタプルのリストを保持して、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Dictionary<ph x="5">&lt;w5/&gt;</ph>Literal<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスを受け入れるイニシャライザを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you create an empty <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance with either this initializer or with an empty array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたは空の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを、このイニシャライザでまたは空の配列リテラルでのどちらかで作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you might typically use a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>for<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>-<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>in<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> loop to print each of the elements in an array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたは概して<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>for<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>-<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>in<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>ループを使って、ある配列の中の各要素を出力するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you might want to create an array with the integers from 1 through 7.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたは配列を１から７までの整数で作成したいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For extensible floating-point types, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>significand<ph x="2">&lt;w2/&gt;</ph>Bit<ph x="3">&lt;w3/&gt;</ph>Count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> should be the maximum allowed significand width (without counting any leading integral bit of the significand).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張可能な浮動小数点型に対して、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>significand<ph x="2">&lt;w2/&gt;</ph>Bit<ph x="3">&lt;w3/&gt;</ph>Count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は許される最大仮数幅であるはずです（全く仮数の先頭整数ビットを数えることなく）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For fixed-width floating-point types, this is the actual number of fractional significand bits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>固定長浮動小数点型に対して、これは小数部仮数ビットの実際の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For formats which don’t support this feature, the default implementation encodes the given object unconditionally.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この機能性をサポートしない形式に対して、省略時の実装は与えられたオブジェクトを無条件にエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instances of <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>NSDictionary<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> that are already immutable, <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>copy(with:)<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> usually returns the same dictionary in O(1) time; otherwise, the copying performance is unspecified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すでに可変の<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>NSDictionary<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>のインスタンスに対しては、<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>copy(with:)<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>は通常同じインスタンスをO(1)時間で返します；そうでなければ、このコピー性能は不定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instances of <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>NSSet<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> that are already immutable, <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>copy(with:)<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> returns the same set in constant time; otherwise, the copying performance is unspecified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>元から不変である<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>NSSet<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>のインスタンスに対しては、<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>copy(with:)<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>は同じ集合を定数時間で返します；そうでなければ、コピーすることの性能は不定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instances of <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>NSArray<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> that are already immutable, <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>copy(with:)<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> usually returns the same array in O(1) time; otherwise, the copying performance is unspecified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>元から不変である<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>NSArray<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>のインスタンスに対しては、<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>copy(with:)<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>は大抵は同じ配列をO(1)時間で返します；そうでなければ、コピーする性能は不定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For integer types, any remainder of the division is discarded.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数型に対して、除算の余りは何であれ破棄されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about operation declarations, see <bpt i="3" x="3">&lt;a3&gt;</bpt>Operator Declaration<ept i="3">&lt;/a3&gt;</ept> in <bpt i="4" x="4">&lt;a4&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="4">&lt;/a4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子宣言についての更なる情報として、<bpt i="3" x="3">&lt;a3&gt;</bpt>演算子宣言<ept i="3">&lt;/a3&gt;</ept>を<bpt i="4" x="4">&lt;a4&gt;</bpt>Swiftプログラミング言語（Swift 4）<ept i="4">&lt;/a4&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about the Unicode terms used in this discussion, see the <bpt i="0" x="0">&lt;a0&gt;</bpt>Unicode.org glossary<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この解説において使われるユニコード用語についてのさらなる情報は、<bpt i="0" x="0">&lt;a0&gt;</bpt>Unicode.org用語集<ept i="0">&lt;/a0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about the available rounding rules, see the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Floating<ph x="2">&lt;w2/&gt;</ph>Point<ph x="3">&lt;w3/&gt;</ph>Rounding<ph x="4">&lt;w4/&gt;</ph>Rule<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> enumeration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>利用可能な丸め規則についてのさらなる情報として、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Floating<ph x="2">&lt;w2/&gt;</ph>Point<ph x="3">&lt;w3/&gt;</ph>Rounding<ph x="4">&lt;w4/&gt;</ph>Rule<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>列挙を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about using arrays, see <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Array<ph x="4">&lt;w4/&gt;</ph>Slice<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, with which <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Contiguous<ph x="7">&lt;w7/&gt;</ph>Array<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> shares most properties and methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の使用についてのさらなる情報は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Array<ph x="4">&lt;w4/&gt;</ph>Slice<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を見てください、それらと<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Contiguous<ph x="7">&lt;w7/&gt;</ph>Array<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>はほとんどのプロパティとメソッドを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about using arrays, see <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Contiguous<ph x="4">&lt;w4/&gt;</ph>Array<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, with which <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Array<ph x="7">&lt;w7/&gt;</ph>Slice<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> shares most properties and methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の使用についてのさらなる情報として、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Contiguous<ph x="4">&lt;w4/&gt;</ph>Array<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を見てください、それらと<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Array<ph x="7">&lt;w7/&gt;</ph>Slice<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>はほとんどのプロパティとメソッドを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For most numbers <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, this is the difference between <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and the next greater (in magnitude) representable number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、これは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と次の（規模における）より大きい表現可能な数との間の差異です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For most purposes, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Managed<ph x="2">&lt;w2/&gt;</ph>Buffer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> class works fine for this purpose, and can simply be used on its own.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの用途に対して、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Managed<ph x="2">&lt;w2/&gt;</ph>Buffer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クラスはこの目的のためにすぐれて機能します、そして簡単に単独で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For operations that require adding or removing elements, see the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Range<ph x="5">&lt;w5/&gt;</ph>Replaceable<ph x="6">&lt;w6/&gt;</ph>Collection<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素の追加や削除を要求する演算に対しては、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Range<ph x="5">&lt;w5/&gt;</ph>Replaceable<ph x="6">&lt;w6/&gt;</ph>Collection<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルを代わりに見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For ordinary sets, an element equal to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>member<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>member<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is contained in the set; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>普通の集合に対して、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>member<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に等しい要素、もし<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>member<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が集合に含まれているならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For ordinary sets, an element equal to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>new<ph x="2">&lt;w2/&gt;</ph>Member<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the set already contained such a member; otherwise, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>nil<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>普通の集合に対して、集合がすでにそのようなメンバを含んでいるならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>new<ph x="2">&lt;w2/&gt;</ph>Member<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に等しい要素；そうでなければ、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>nil<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For other collections the counters may be out of range or of the wrong type to use as an index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他のコレクションに対してこれらのカウンタは、インデックスとして使うのには範囲外または間違った型になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For other values of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ph x="8">&lt;w8/&gt;</ph>.significand<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is defined as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>別の値<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に対して、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ph x="8">&lt;w8/&gt;</ph>.significand<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は次のように定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For performance reasons, the size of the newly allocated storage might be greater than the requested capacity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>性能上の理由から、新しく割り当てられたストレージは要請された容量より大きいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For sets where the set type and element type are the same, like <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Option<ph x="2">&lt;w2/&gt;</ph>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types, this method returns any intersection between the set and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>[member]<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, or <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> if the intersection is empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Option<ph x="2">&lt;w2/&gt;</ph>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型など、集合型と要素型が同じであるところの集合に対して、このメソッドは集合と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>[member]<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の間の何らかの交叉、または交叉が空ならば<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For sets where the set type and element type are the same, like <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Option<ph x="2">&lt;w2/&gt;</ph>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types, this method returns any intersection between the set and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>[new<ph x="5">&lt;w5/&gt;</ph>Member]<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, or <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> if the intersection is empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Option<ph x="2">&lt;w2/&gt;</ph>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型など、集合型と要素型が同じであるところの集合に対して、このメソッドは集合と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>[new<ph x="5">&lt;w5/&gt;</ph>Member]<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の間の何らかの交叉、または交叉が空ならば<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For signed integer types, this value is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(2 ** (bit<ph x="2">&lt;w2/&gt;</ph>Width - 1)) - 1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, where <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>**<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is exponentiation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号付き整数型に対して、この値は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(2 ** (bit<ph x="2">&lt;w2/&gt;</ph>Width - 1)) - 1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です、そこで<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>**<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は冪演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For signed integer types, this value is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-(2 ** (bit<ph x="2">&lt;w2/&gt;</ph>Width - 1))<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, where <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>**<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is exponentiation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号付き整数型に対して、この値は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-(2 ** (bit<ph x="2">&lt;w2/&gt;</ph>Width - 1))<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です、そこで<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>**<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は冪演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For signed integer types, this value is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-(2 ** (bit<ph x="4">&lt;w4/&gt;</ph>Width - 1))<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, where <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>**<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is exponentiation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号付き整数型に対して、この値は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-(2 ** (bit<ph x="4">&lt;w4/&gt;</ph>Width - 1))<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です、そこで<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>**<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は冪演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For signed integer types, this value is <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>(2 ** (bit<ph x="7">&lt;w7/&gt;</ph>Width - 1)) - 1<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号付き整数型に対して、この値は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>(2 ** (bit<ph x="7">&lt;w7/&gt;</ph>Width - 1)) - 1<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For simple types such as integers and other structures, this means that when you change a value in one array, the value of that element does not change in any copies of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば整数および他の構造体のような単純な型にとって、これは、あなたがある配列の中のある値を変更する場合、その要素の値はその配列の何らかのコピーにおいては変化しないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For the inherited methods to work properly, conforming types must meet the following axioms.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>継承されたメソッドを適切に働かせるためには、準拠する型は以下の原則に応じる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For this reason, imported Objective-C types frequently use <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Any<ph x="7">&lt;w7/&gt;</ph>Object<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> as the type for properties, method parameters, and return values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この理由から、インポートされたObjective-C型はしばしば<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Any<ph x="7">&lt;w7/&gt;</ph>Object<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>をプロパティ、メソッドパラメータ、そして戻り値の型として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For this reason, the first operation that uses the contents of the dictionary may take O(<bpt i="10" x="10">&lt;e10&gt;</bpt>n<ept i="10">&lt;/e10&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この理由のために、辞書の内容を使う最初の演算はO(<bpt i="10" x="10">&lt;e10&gt;</bpt>n<ept i="10">&lt;/e10&gt;</ept>)をとるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For two finite values <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the remainder <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>r<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> of dividing <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> by <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>y<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> satisfies <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>x == y * q + r<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>, where <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>q<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> is the integer nearest to <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>x / y<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの有限値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>y<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>で割った余り<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>r<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>は<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>x == y * q + r<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>を満足させます、ここで<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>q<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>は<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>x / y<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>に最も近い整数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For two tuples to compare as equal, each corresponding pair of components must be equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのタプルが等しいと比較されるには、対応する構成要素同士がそれぞれ等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For two values <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>d<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ph x="6">&lt;w6/&gt;</ph>.advanced(by: d)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is equal to <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>x + d<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>—a new value <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>y<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> such that <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>x<ph x="13">&lt;w13/&gt;</ph>.distance(to: y)<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> approximates <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>d<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>d<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ph x="6">&lt;w6/&gt;</ph>.advanced(by: d)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の結果は<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>x + d<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に等しいです—新しい値<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>y<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>は、<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>x<ph x="13">&lt;w13/&gt;</ph>.distance(to: y)<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>が<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>d<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>の近似です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For two values <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>maximum(x, y)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> if <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x &gt; y<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>y<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> if <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>x &lt;= y<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>, or whichever of <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>x<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> or <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>y<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> is a number if the other is a quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>maximum(x, y)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の結果は<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x &gt; y<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>ならば<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>、<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>x &lt;= y<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>ならば<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>y<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>、または他のものがクワイエットNaNならば<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>x<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>か<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>y<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>どちらか数である方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For two values <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>maximum<ph x="6">&lt;w6/&gt;</ph>Magnitude(x, y)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>x<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> if <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>x<ph x="11">&lt;w11/&gt;</ph>.magnitude &gt; y<ph x="12">&lt;w12/&gt;</ph>.magnitude<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>y<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> if <bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>x<ph x="17">&lt;w17/&gt;</ph>.magnitude &lt;= y<ph x="18">&lt;w18/&gt;</ph>.magnitude<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>, or whichever of <bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>x<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept> or <bpt i="21" x="21">&lt;c21&gt;</bpt><bpt i="22" x="22">&lt;s22&gt;</bpt>y<ept i="22">&lt;/s22&gt;</ept><ept i="21">&lt;/c21&gt;</ept> is a number if the other is a quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>maximum<ph x="6">&lt;w6/&gt;</ph>Magnitude(x, y)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の結果は、<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>x<ph x="11">&lt;w11/&gt;</ph>.magnitude &gt; y<ph x="12">&lt;w12/&gt;</ph>.magnitude<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>ならば<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>x<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>、<bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>x<ph x="17">&lt;w17/&gt;</ph>.magnitude &lt;= y<ph x="18">&lt;w18/&gt;</ph>.magnitude<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>ならば<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>y<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>、または他のものがクワイエットNaNならば<bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>x<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept>か<bpt i="21" x="21">&lt;c21&gt;</bpt><bpt i="22" x="22">&lt;s22&gt;</bpt>y<ept i="22">&lt;/s22&gt;</ept><ept i="21">&lt;/c21&gt;</ept>どちらか数である方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For two values <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>minimum(x, y)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> if <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x &lt;= y<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>y<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> if <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>y &lt; x<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>, or whichever of <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>x<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> or <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>y<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> is a number if the other is a quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>minimum(x, y)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の結果は<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x &lt;= y<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>ならば<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>、<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>y &lt; x<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>ならば<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>y<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>、または他のものがクワイエットNaNならば<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>x<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>か<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>y<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>どちらか数である方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For two values <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>minimum<ph x="6">&lt;w6/&gt;</ph>Magnitude(x, y)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>x<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> if <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>x<ph x="11">&lt;w11/&gt;</ph>.magnitude &lt;= y<ph x="12">&lt;w12/&gt;</ph>.magnitude<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>y<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> if <bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>y<ph x="17">&lt;w17/&gt;</ph>.magnitude &lt; x<ph x="18">&lt;w18/&gt;</ph>.magnitude<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>, or whichever of <bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>x<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept> or <bpt i="21" x="21">&lt;c21&gt;</bpt><bpt i="22" x="22">&lt;s22&gt;</bpt>y<ept i="22">&lt;/s22&gt;</ept><ept i="21">&lt;/c21&gt;</ept> is a number if the other is a quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>minimum<ph x="6">&lt;w6/&gt;</ph>Magnitude(x, y)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の結果は<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>x<ph x="11">&lt;w11/&gt;</ph>.magnitude &lt;= y<ph x="12">&lt;w12/&gt;</ph>.magnitude<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>ならば<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>x<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>、<bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>y<ph x="17">&lt;w17/&gt;</ph>.magnitude &lt; x<ph x="18">&lt;w18/&gt;</ph>.magnitude<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>ならば<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>y<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>、または他のものがクワイエットNaNならば<bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>x<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept>か<bpt i="21" x="21">&lt;c21&gt;</bpt><bpt i="22" x="22">&lt;s22&gt;</bpt>y<ept i="22">&lt;/s22&gt;</ept><ept i="21">&lt;/c21&gt;</ept>どちらか数である方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For two values <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ph x="6">&lt;w6/&gt;</ph>.distance(to: y)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is equal to <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>y - x<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>—a distance <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>d<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> such that <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>x<ph x="13">&lt;w13/&gt;</ph>.advanced(by: d)<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> approximates <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>y<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ph x="6">&lt;w6/&gt;</ph>.distance(to: y)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の結果は<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>y - x<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に等しいです—隔たり<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>d<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>は、<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>x<ph x="13">&lt;w13/&gt;</ph>.advanced(by: d)<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>が<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>y<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>の近似です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For unsigned integer types, this value is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(2 ** bit<ph x="2">&lt;w2/&gt;</ph>Width) - 1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, where <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>**<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is exponentiation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号なし整数型に対して、この値は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(2 ** bit<ph x="2">&lt;w2/&gt;</ph>Width) - 1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です、そこで<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>**<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は冪演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For unsigned integer types, this value is always <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>0<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号なし整数型に対して、この値は常に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>0<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For value equality, see the equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) and the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値の同等性については、同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）そして<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For value inequality, see the not-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>!=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) and the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値の不等性については、不等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>!=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）そして<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For values <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and their truncated integer quotient <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>q<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, the remainder <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>r<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> satisfies <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x == y * q + r<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>および切り捨てられる整数指数<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>q<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に対して、余り<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>r<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x == y * q + r<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を満足させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fortify your code with runtime checks, and examine your values' runtime representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコードを実行時チェックで強化し、そしてあなたの値の実行時表現を検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Framework</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>フレームワーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>From Protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>由来プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions that use a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Text<ph x="8">&lt;w8/&gt;</ph>Output<ph x="9">&lt;w9/&gt;</ph>Stream<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> target may call <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>write(_:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> multiple times per writing operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Text<ph x="8">&lt;w8/&gt;</ph>Output<ph x="9">&lt;w9/&gt;</ph>Stream<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>ターゲットを使う関数は、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>write(_:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>を書き込み操作のたびに複数回呼び出すでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fundamental data types such as <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Int<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>, <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Double<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>, and <bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>String<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基本的なデータ型、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Int<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>、<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Double<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>、そして<bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>String<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept>など</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Further modifications to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>numbers<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> are made in place, while the two copies continue to share the original storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>numbers<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>への以降の修正は、そこでなされます、一方２つのコピーは元々のストレージの共有を続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generally, a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Character<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance matches what the reader of a string will perceive as a single character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一般的に、ある<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Character<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスがマッチするのは、ある文字列の読み手が単一の文字と知覚するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generally, native Swift types that do not contain strong or weak references are trivial, as are imported C structs and enums.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一般に、生粋のSwift型で強いまたは弱い参照を含まないものは自明です、インポートされたCのstructとenumのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generally, native Swift types that do not contain strong or weak references or other forms of indirection are trivial, as are imported C structs and enumerations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一般に、生粋のSwift型で強いまたは弱い参照または他形式の間接参照を含まないものは自明です、インポートされたCの構造体と列挙のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generally, native Swift types that do not contain strong or weak references or other forms of indirection are trivial, as are imported C structs and enums.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一般に、生粋のSwift型で強いまたは弱い参照または他形式の間接参照を含まないものは自明です、インポートされたCのstructとenumのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generate a default mirror for all ancestor classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全ての先祖クラスに対するある省略時のミラーを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generic Constraints</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体制約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generic Instance Method</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体インスタンスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Gets the value of this unmanaged reference as a managed reference and consumes an unbalanced retain of it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この管理されない参照の値を管理された参照として取得します、そしてそれのある不均衡なリテイン（保持）を使い果たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Gets the value of this unmanaged reference as a managed reference without consuming an unbalanced retain of it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この管理されない参照の値を管理された参照として取得します、それのある不均衡なリテイン（保持）を使い果たすことなしにです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Getting C Strings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C文字列を扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Getting Characters and Bytes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字とバイトを取得する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Getting Strings with Mapping</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列をマップして取得する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Getting Substrings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位文字列を取得する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Getting a dictionary’s value using a key returns an optional value, so <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>image<ph x="2">&lt;w2/&gt;</ph>Paths["star"]<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has type <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Optional&lt;String&gt;<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> or, written in the preferred manner, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>String?<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の持つ値をあるキーを使って取得することはあるオプショナル値を返します、それで<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>image<ph x="2">&lt;w2/&gt;</ph>Paths["star"]<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は型<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Optional&lt;String&gt;<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>または、より好ましい流儀で書かれて、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>String?<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Getting an Offset Value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オフセット値の取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Getting and Setting Dictionary Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の値の取得と設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Given a version like this, though,</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、このようなバージョンを与えられるならば、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Given two tuples <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(a1, a2, ..., a<ph x="2">&lt;w2/&gt;</ph>N)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>(b1, b2, ..., b<ph x="5">&lt;w5/&gt;</ph>N)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, the first tuple is after or the same as the second tuple if and only if <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>a1 &gt; b1<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> or (<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>a1 == b1<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>(a2, ..., a<ph x="12">&lt;w12/&gt;</ph>N) &gt;= (b2, ..., b<ph x="13">&lt;w13/&gt;</ph>N)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのタプル<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(a1, a2, ..., a<ph x="2">&lt;w2/&gt;</ph>N)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>(b1, b2, ..., b<ph x="5">&lt;w5/&gt;</ph>N)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を与えられて、最初のタプルが２番目のタブルより後かそれと同じであるのは、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>a1 &gt; b1<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>または(<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>a1 == b1<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>および<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>(a2, ..., a<ph x="12">&lt;w12/&gt;</ph>N) &gt;= (b2, ..., b<ph x="13">&lt;w13/&gt;</ph>N)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>)である場合に限ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Given two tuples <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(a1, a2, ..., a<ph x="2">&lt;w2/&gt;</ph>N)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>(b1, b2, ..., b<ph x="5">&lt;w5/&gt;</ph>N)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, the first tuple is after the second tuple if and only if <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>a1 &gt; b1<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> or (<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>a1 == b1<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>(a2, ..., a<ph x="12">&lt;w12/&gt;</ph>N) &gt; (b2, ..., b<ph x="13">&lt;w13/&gt;</ph>N)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのタプル<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(a1, a2, ..., a<ph x="2">&lt;w2/&gt;</ph>N)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>(b1, b2, ..., b<ph x="5">&lt;w5/&gt;</ph>N)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を与えられて、最初のタプルが２番目のタブルより後であるのは、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>a1 &gt; b1<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>または(<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>a1 == b1<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>および<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>(a2, ..., a<ph x="12">&lt;w12/&gt;</ph>N) &gt; (b2, ..., b<ph x="13">&lt;w13/&gt;</ph>N)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>)である場合に限ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Given two tuples <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(a1, a2, ..., a<ph x="2">&lt;w2/&gt;</ph>N)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>(b1, b2, ..., b<ph x="5">&lt;w5/&gt;</ph>N)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, the first tuple is before or the same as the second tuple if and only if <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>a1 &lt; b1<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> or (<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>a1 == b1<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>(a2, ..., a<ph x="12">&lt;w12/&gt;</ph>N) &lt;= (b2, ..., b<ph x="13">&lt;w13/&gt;</ph>N)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのタプル<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(a1, a2, ..., a<ph x="2">&lt;w2/&gt;</ph>N)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>(b1, b2, ..., b<ph x="5">&lt;w5/&gt;</ph>N)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を与えられて、最初のタプルが２番目のタブルより前かそれと同じであるのは、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>a1 &lt; b1<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>または(<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>a1 == b1<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>および<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>(a2, ..., a<ph x="12">&lt;w12/&gt;</ph>N) &lt;= (b2, ..., b<ph x="13">&lt;w13/&gt;</ph>N)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>)である場合に限ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Given two tuples <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(a1, a2, ..., a<ph x="2">&lt;w2/&gt;</ph>N)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>(b1, b2, ..., b<ph x="5">&lt;w5/&gt;</ph>N)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, the first tuple is before the second tuple if and only if <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>a1 &lt; b1<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> or (<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>a1 == b1<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>(a2, ..., a<ph x="12">&lt;w12/&gt;</ph>N) &lt; (b2, ..., b<ph x="13">&lt;w13/&gt;</ph>N)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのタプル<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>(a1, a2, ..., a<ph x="2">&lt;w2/&gt;</ph>N)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>(b1, b2, ..., b<ph x="5">&lt;w5/&gt;</ph>N)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を与えられて、最初のタプルが２番目のタブルより後であるのは、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>a1 &lt; b1<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>または(<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>a1 == b1<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>(a2, ..., a<ph x="12">&lt;w12/&gt;</ph>N) &lt; (b2, ..., b<ph x="13">&lt;w13/&gt;</ph>N)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>)である場合に限ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Given:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次を与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Global Numeric Functions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>グローバルな数値関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Global functions such as <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>print(_:<ph x="3">&lt;w3/&gt;</ph>separator:<ph x="4">&lt;w4/&gt;</ph>terminator:)<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> and <bpt i="5" x="5">&lt;a5&gt;</bpt><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>abs(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept><ept i="5">&lt;/a5&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>グローバル関数、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>print(_:<ph x="3">&lt;w3/&gt;</ph>separator:<ph x="4">&lt;w4/&gt;</ph>terminator:)<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>そして<bpt i="5" x="5">&lt;a5&gt;</bpt><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>abs(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept><ept i="5">&lt;/a5&gt;</ept>など</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Greater than</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より大きい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Greater than or equal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より大きいか、等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Growing the Size of an Array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の大きさの増大</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Half-open range</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>半開範囲</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hash values are not guaranteed to be equal across different executions of your program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ハッシュ値は、あなたのプログラムの異なる実行をまたいで等しいことを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here a default path is supplied for an image that is missing from <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>image<ph x="8">&lt;w8/&gt;</ph>Paths<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここで省略時のパスは、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>image<ph x="8">&lt;w8/&gt;</ph>Paths<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>から見つからない画像に対して提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, a set of strings is created from an array literal holding only strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、文字列の集合が文字列のみを保持する配列リテラルから作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, an array of strings is created from an array literal holding only strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、文字列からなる配列が、文字列だけを保持している配列リテラルから作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, an array of strings is created from an array literal holding only strings:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、文字列の配列が、文字列だけを保持する配列リテラルから作成されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, the assignment to <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>dest<ph x="10">&lt;w10/&gt;</ph>Bytes<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> creates a new, nonowning buffer pointer covering the first <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>n<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> bytes of the memory that <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>some<ph x="15">&lt;w15/&gt;</ph>Bytes<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> references—nothing is copied:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここで、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>dest<ph x="10">&lt;w10/&gt;</ph>Bytes<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>への割り当ては、<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>some<ph x="15">&lt;w15/&gt;</ph>Bytes<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>が参照するメモリの最初の<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>n<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>バイトを変換して、新しい、非所有のバッファポインタを作成します — コピーされるものは何もありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, the assignment to <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>dest<ph x="11">&lt;w11/&gt;</ph>Bytes<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> creates a new, nonowning buffer pointer covering the first <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>n<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> bytes of the memory that <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>some<ph x="16">&lt;w16/&gt;</ph>Bytes<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> references—nothing is copied:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここで、<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>dest<ph x="11">&lt;w11/&gt;</ph>Bytes<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>への割り当ては、<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>some<ph x="16">&lt;w16/&gt;</ph>Bytes<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>が参照するメモリの最初の<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>n<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>バイトを変換して、新しい、非所有のバッファポインタを作成します — コピーされるものは何もありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, the value for the key <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"Coral"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is updated from <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>18<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and a new key-value pair is added for the key <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>"Cerise"<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、キー<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"Coral"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対する値が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>から<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>18<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に更新され、そして新しいキー値ペアがキー<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>"Cerise"<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に対して加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, three elements in the middle of an array of integers are replaced by the five elements of a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Repeated&lt;Int&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、整数からなるある配列の真ん中の３つの要素が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Repeated&lt;Int&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスの５つの要素によって置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, we find the length of the first sentence and create an uppercase version.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここで、私たちは最初の文の長さを見つけます、そして大文字バージョンを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a definition of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countdown<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> sequence that serves as its own iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countdown<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>シーケンスの定義があります、それはそれ自身イテレータとしての務めを果たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of a type that declares the minimal requirements for a collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにある型の例があります、それはあるコレクションのための最小限の要件を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of accessing the first character in a string through its subscript:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにあるのはある文字列の最初の文字にそれの添え字を通してアクセスする例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of creating a set and an array using array literals:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに配列リテラルを使って集合と配列を作成する例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of creating an array initialized with five strings containing the letter <bpt i="0" x="0">&lt;e0&gt;</bpt>Z<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、字<bpt i="0" x="0">&lt;e0&gt;</bpt>Z<ept i="0">&lt;/e0&gt;</ept>を含んでいる５つの文字列で初期化される配列を作成する例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of inserting a range of integers into an array of the same type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに整数の範囲を同じ型の配列へ挿入する例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of sorting a list of students’ names.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、生徒名のリストをソートする例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of the number -8.5 represented as an instance of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type, which defines a radix of 2.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のあるインスタンスとして表される数-8.5の例があります、それは２の基数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of transforming a string to all lowercase letters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、ある文字列を小文字の文字に変換する例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example that finds a student name that begins with the letter “A”:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、文字「A」で始まる生徒名を見つける例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example that sorts the first half of an array of integers:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにある例があります、それは整数からなるある配列の前半分をソートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an implementation of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reduce1(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reduce1(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドの実装があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an implementation of those steps, showing how to retrieve a substring described by an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSRange<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance from the middle of a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにこれらの手順のひとつの実装があります、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSRange<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスによって叙述される下位文字列をある文字列の真ん中から取り出す方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an implementation of those steps:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにこれらの手順の実装があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how to find the longest string in a sequence, using the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>animals<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> array introduced earlier as an example:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに最も長い文字列をあるシーケンスの中で見つける方法があります、前に導入された<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>animals<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>配列を例として使っています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how you can catch any <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>XMLParsing<ph x="2">&lt;w2/&gt;</ph>Error<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> errors thrown by the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>parse(_:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> function:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにあるのは、あなたが<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>parse(_:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>関数によってスローされる何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>XMLParsing<ph x="2">&lt;w2/&gt;</ph>Error<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>エラーを捕まえる方法です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how you would create a dictionary of HTTP response codes and their related messages:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにあるのは、あなたがHTTP応答コードとそれらの関連メッセージの辞書を作成する方法です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s the definition for <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Integer<ph x="5">&lt;w5/&gt;</ph>Ref<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>==<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> function that makes it conform to <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Equatable<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Integer<ph x="5">&lt;w5/&gt;</ph>Ref<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>とそれを<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Equatable<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に準拠させる<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>==<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>関数の定義があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s the initial declaration of the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Grid<ph x="5">&lt;w5/&gt;</ph>Point<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Grid<ph x="5">&lt;w5/&gt;</ph>Point<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型の初期宣言があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s the initial declaration of the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Street<ph x="5">&lt;w5/&gt;</ph>Address<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Street<ph x="5">&lt;w5/&gt;</ph>Address<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型の初期宣言があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>count<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> may be zero even for a non-<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>nil<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>start<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>count<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は非<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>nil<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>start<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>に対してでさえもゼロでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>count<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> may be zero even for a non-<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>nil<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>start<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>count<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>は非<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>nil<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>の<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>start<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>に対してもゼロであるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, a buffer can have a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>count<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> of zero even with a non-<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> base address.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、バッファはゼロの<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>count<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を非<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に基づくアドレスでも持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if two arrays contain references to the same object, you can observe changes to that object’s properties from both arrays.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、２つの配列が同じオブジェクトへの参照を含むならば、あなたは両方の配列からそのオブジェクトの持つプロパティへの変更を観察するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if you pass <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>19<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the method first bitmasks <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>3<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, and then uses that masked value as the number of bits to shift <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>lhs<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>19<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>として渡すならば、このメソッドは最初に<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>3<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>にビットマスクして、それからそのマスクされた値をビット数として使うことで<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>lhs<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>をシフトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if you use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>19<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the operation first bitmasks <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>3<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, and then uses that masked value as the number of bits to shift <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>lhs<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>19<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>として使うならば、この演算は最初に<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>3<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>にビットマスクして、それからそのマスクされた値をビット数として使うことで<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>lhs<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>をシフトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, in cases where objects of various different classes must serve as storage, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Managed<ph x="5">&lt;w5/&gt;</ph>Buffer<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is needed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、種々の異なるクラスのオブジェクトがストレージとして供されなければならない場合には、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Managed<ph x="5">&lt;w5/&gt;</ph>Buffer<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が必要とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, in optimized builds (<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>-O<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>), no check is performed to ensure that the current instance actually has a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、最適化ビルド（<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>-O<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>）において、現在のインスタンスが実際に値を持つか確かめる確認は全く実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, in order to meet the complexity guarantees of a random-access collection, either the index for your custom type must conform to the <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Strideable<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> protocol or you must implement the <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>index(_:<ph x="16">&lt;w16/&gt;</ph>offset<ph x="17">&lt;w17/&gt;</ph>By:)<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> and <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>distance(from:<ph x="20">&lt;w20/&gt;</ph>to:)<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> methods with O(1) efficiency.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、無作為アクセスコレクションの計算量（複雑さ）保証を達成する手段として、あなたのあつらえの型に対するインデックスが<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Strideable<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>プロトコルに準拠する、またはあなたが<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>index(_:<ph x="16">&lt;w16/&gt;</ph>offset<ph x="17">&lt;w17/&gt;</ph>By:)<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>と<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>distance(from:<ph x="20">&lt;w20/&gt;</ph>to:)<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>メソッドをO(1)の効率で実装する、いずれかをしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, initializing another collection with an <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Unsafe<ph x="12">&lt;w12/&gt;</ph>Mutable<ph x="13">&lt;w13/&gt;</ph>Buffer<ph x="14">&lt;w14/&gt;</ph>Pointer<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> instance copies the instances out of the referenced memory and into the new collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、別のコレクションを<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Unsafe<ph x="12">&lt;w12/&gt;</ph>Mutable<ph x="13">&lt;w13/&gt;</ph>Buffer<ph x="14">&lt;w14/&gt;</ph>Pointer<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>インスタンスで初期化することは、インスタンスを参照されたメモリから外へそして新しいコレクションへとコピーします、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, initializing another collection with an <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Unsafe<ph x="12">&lt;w12/&gt;</ph>Raw<ph x="13">&lt;w13/&gt;</ph>Buffer<ph x="14">&lt;w14/&gt;</ph>Pointer<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> instance copies bytes out of the referenced memory and into the new collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、別のコレクションを<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Unsafe<ph x="12">&lt;w12/&gt;</ph>Raw<ph x="13">&lt;w13/&gt;</ph>Buffer<ph x="14">&lt;w14/&gt;</ph>Pointer<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>インスタンスで初期化することは、バイトを参照されたメモリから外へそして新しいコレクションへとコピーします、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, initializing another collection with an <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Unsafe<ph x="14">&lt;w14/&gt;</ph>Mutable<ph x="15">&lt;w15/&gt;</ph>Raw<ph x="16">&lt;w16/&gt;</ph>Buffer<ph x="17">&lt;w17/&gt;</ph>Pointer<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> instance copies bytes out of the referenced memory and into the new collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、別のコレクションを<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Unsafe<ph x="14">&lt;w14/&gt;</ph>Mutable<ph x="15">&lt;w15/&gt;</ph>Raw<ph x="16">&lt;w16/&gt;</ph>Buffer<ph x="17">&lt;w17/&gt;</ph>Pointer<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>インスタンスで初期化することは、バイトを参照されたメモリから外へそして新しいコレクションへとコピーします、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, initializing another collection with an <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Unsafe<ph x="10">&lt;w10/&gt;</ph>Buffer<ph x="11">&lt;w11/&gt;</ph>Pointer<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> instance copies the instances out of the referenced memory and into the new collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、別のコレクションを<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Unsafe<ph x="10">&lt;w10/&gt;</ph>Buffer<ph x="11">&lt;w11/&gt;</ph>Pointer<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>インスタンスで初期化することは、インスタンスを参照されたメモリから外へそして新しいコレクションへとコピーします、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, subscripting that range still works in a generic context:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、この範囲に添え字を使うことは総称体の文脈では依然として働きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the type of a function, method, or closure always includes a return type, which is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Void<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if otherwise unspecified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、関数、メソッド、またはクロージャは、常に戻り型を含みます、それは指定されないならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Void<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Identical</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同一である</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Identical to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と同一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Integer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, then <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self<ph x="6">&lt;w6/&gt;</ph>.advanced(by: x) == other<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Integer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するならば、そのとき<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self<ph x="6">&lt;w6/&gt;</ph>.advanced(by: x) == other<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Integer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, then <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self<ph x="6">&lt;w6/&gt;</ph>.distance(to: x) == n<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Integer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するならば、そのとき<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self<ph x="6">&lt;w6/&gt;</ph>.distance(to: x) == n<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>are<ph x="2">&lt;w2/&gt;</ph>Equivalent(a, b)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>are<ph x="5">&lt;w5/&gt;</ph>Equivalent(b, c)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> are both <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>true<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, then <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>are<ph x="10">&lt;w10/&gt;</ph>Equivalent(a, c)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> is also <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>true<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>are<ph x="2">&lt;w2/&gt;</ph>Equivalent(a, b)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>are<ph x="5">&lt;w5/&gt;</ph>Equivalent(b, c)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が両方とも<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>true<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>ならば、そのとき<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>are<ph x="10">&lt;w10/&gt;</ph>Equivalent(a, c)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>もまた<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>true<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>are<ph x="2">&lt;w2/&gt;</ph>In<ph x="3">&lt;w3/&gt;</ph>Increasing<ph x="4">&lt;w4/&gt;</ph>Order(a, b)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>are<ph x="7">&lt;w7/&gt;</ph>In<ph x="8">&lt;w8/&gt;</ph>Increasing<ph x="9">&lt;w9/&gt;</ph>Order(b, c)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> are both <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>true<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>, then <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>are<ph x="14">&lt;w14/&gt;</ph>In<ph x="15">&lt;w15/&gt;</ph>Increasing<ph x="16">&lt;w16/&gt;</ph>Order(a, c)<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> is also <bpt i="17" x="17">&lt;c17&gt;</bpt><bpt i="18" x="18">&lt;s18&gt;</bpt>true<ept i="18">&lt;/s18&gt;</ept><ept i="17">&lt;/c17&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>are<ph x="2">&lt;w2/&gt;</ph>In<ph x="3">&lt;w3/&gt;</ph>Increasing<ph x="4">&lt;w4/&gt;</ph>Order(a, b)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>are<ph x="7">&lt;w7/&gt;</ph>In<ph x="8">&lt;w8/&gt;</ph>Increasing<ph x="9">&lt;w9/&gt;</ph>Order(b, c)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>が両方とも<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>true<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>ならば、そのとき<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>are<ph x="14">&lt;w14/&gt;</ph>In<ph x="15">&lt;w15/&gt;</ph>Increasing<ph x="16">&lt;w16/&gt;</ph>Order(a, c)<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>もまた<bpt i="17" x="17">&lt;c17&gt;</bpt><bpt i="18" x="18">&lt;s18&gt;</bpt>true<ept i="18">&lt;/s18&gt;</ept><ept i="17">&lt;/c17&gt;</ept>である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bit<ph x="2">&lt;w2/&gt;</ph>Pattern<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is zero, the result is <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>nil<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bit<ph x="2">&lt;w2/&gt;</ph>Pattern<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がゼロならば、結果は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>nil<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has a return value, it is used as the return value for the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>CString(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が戻り値を持つならば、それは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>CString(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドの戻り値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has a return value, it is used as the return value for the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>CString(encoded<ph x="5">&lt;w5/&gt;</ph>As:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が戻り値を持つならば、それは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>CString(encoded<ph x="5">&lt;w5/&gt;</ph>As:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドの戻り値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> contains ill-formed UTF-8 code unit sequences, this initializer replaces them with the Unicode replacement character (<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>"\u{FFFD}"<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が文法的に正しくないUTF-8コードユニットシーケンスを含むならば、それらをある代替文字（<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>"\u{FFFD}"<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>description<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is any string other than <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>"true"<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"false"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, the result is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>description<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>"true"<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"false"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と違う何らかの文字列ならば、結果は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>start<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result is zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>start<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に等しいならば、結果はゼロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, an empty subsequence is returned in the result for each consecutive pair of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>separator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> elements in the collection and for each instance of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>separator<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> at the start or end of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ならば、このコレクション中の連続する<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>separator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>要素の対それぞれに、そしてコレクションの始めと終わりの<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>separator<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスそれぞれに、１つの空の下位シーケンスが結果において返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, an empty subsequence is returned in the result for each consecutive pair of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>separator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> elements in the sequence and for each instance of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>separator<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> at the start or end of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ならば、このシーケンス中の連続する<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>separator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>要素の対それぞれに、そしてシーケンスの始めと終わりの<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>separator<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスそれぞれに、１つの空の下位シーケンスが結果において返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>is<ph x="4">&lt;w4/&gt;</ph>Separator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> predicate and for each element at the start or end of the collection satisfying the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>is<ph x="7">&lt;w7/&gt;</ph>Separator<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ならば、結果において<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>is<ph x="4">&lt;w4/&gt;</ph>Separator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>述部を満たす隣接する要素のペアそれぞれに対しておよび<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>is<ph x="7">&lt;w7/&gt;</ph>Separator<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>述部を満たすコレクションの始まりまたは終わりでの要素それぞれに対して１つの空の下位シーケンスが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>is<ph x="4">&lt;w4/&gt;</ph>Separator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> predicate and for each element at the start or end of the sequence satisfying the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>is<ph x="7">&lt;w7/&gt;</ph>Separator<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ならば、結果において<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>is<ph x="4">&lt;w4/&gt;</ph>Separator<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>述部を満たす隣接する要素のペアそれぞれに対しておよび<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>is<ph x="7">&lt;w7/&gt;</ph>Separator<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>述部を満たすシーケンスの始まりまたは終わりでの要素それぞれに対して１つの空の下位シーケンスが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>from<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of this initializer is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>from<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、このイニシャライザの結果は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i &gt; c<ph x="2">&lt;w2/&gt;</ph>.start<ph x="3">&lt;w3/&gt;</ph>Index &amp;&amp; i &lt;= c<ph x="4">&lt;w4/&gt;</ph>.end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>c<ph x="8">&lt;w8/&gt;</ph>.index(after: c<ph x="9">&lt;w9/&gt;</ph>.index(before: i)) == i<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i &gt; c<ph x="2">&lt;w2/&gt;</ph>.start<ph x="3">&lt;w3/&gt;</ph>Index &amp;&amp; i &lt;= c<ph x="4">&lt;w4/&gt;</ph>.end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ならば<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>c<ph x="8">&lt;w8/&gt;</ph>.index(after: c<ph x="9">&lt;w9/&gt;</ph>.index(before: i)) == i<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i &gt;= c<ph x="2">&lt;w2/&gt;</ph>.start<ph x="3">&lt;w3/&gt;</ph>Index &amp;&amp; i &lt; c<ph x="4">&lt;w4/&gt;</ph>.end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>c<ph x="8">&lt;w8/&gt;</ph>.index(before: c<ph x="9">&lt;w9/&gt;</ph>.index(after: i)) == i<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i &gt;= c<ph x="2">&lt;w2/&gt;</ph>.start<ph x="3">&lt;w3/&gt;</ph>Index &amp;&amp; i &lt; c<ph x="4">&lt;w4/&gt;</ph>.end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ならば、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>c<ph x="8">&lt;w8/&gt;</ph>.index(before: c<ph x="9">&lt;w9/&gt;</ph>.index(after: i)) == i<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to the string’s end index, this methods appends <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が文字列の末尾インデックスと等しいならば、このメソッドは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を文字列へ追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to the string’s end index, this methods appends the contents of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Elements<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が文字列の末尾インデックスと等しいならば、このメソッドは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Elements<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の内容を文字列へ追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>instance<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>Debug<ph x="5">&lt;w5/&gt;</ph>String<ph x="6">&lt;w6/&gt;</ph>Convertible<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol, the result is <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>instance<ph x="9">&lt;w9/&gt;</ph>.debug<ph x="10">&lt;w10/&gt;</ph>Description<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>instance<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が準拠するのが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>Debug<ph x="5">&lt;w5/&gt;</ph>String<ph x="6">&lt;w6/&gt;</ph>Convertible<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルならば、結果は<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>instance<ph x="9">&lt;w9/&gt;</ph>.debug<ph x="10">&lt;w10/&gt;</ph>Description<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>instance<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>String<ph x="5">&lt;w5/&gt;</ph>Convertible<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol, the result is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>instance<ph x="8">&lt;w8/&gt;</ph>.description<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>instance<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が準拠するのが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>String<ph x="5">&lt;w5/&gt;</ph>Convertible<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルならば、結果は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>instance<ph x="8">&lt;w8/&gt;</ph>.description<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>instance<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Text<ph x="4">&lt;w4/&gt;</ph>Output<ph x="5">&lt;w5/&gt;</ph>Streamable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol, the result is obtained by calling <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>instance<ph x="8">&lt;w8/&gt;</ph>.write(to: s)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> on an empty string <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>s<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>instance<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が準拠するのが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Text<ph x="4">&lt;w4/&gt;</ph>Output<ph x="5">&lt;w5/&gt;</ph>Streamable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルならば、結果は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>instance<ph x="8">&lt;w8/&gt;</ph>.write(to: s)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を空の文字列<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>s<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>上で呼び出すことによって入手されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Repairing<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>false<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and an ill-formed sequence is detected, this method returns <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Repairing<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>false<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>で誤形式シーケンスが検出されるならば、このメソッドは<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Splits + 1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> subsequences are returned, the last one is a suffix of the original collection containing the remaining elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Splits + 1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の下位シーケンスが返されるならば、最後のものは、残りの要素を含んでいる元コレクションの後ろ部分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Splits + 1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Splits + 1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の下位シーケンスが返されるならば、最後のものは、残りの要素を含んでいる元シーケンスの後ろ部分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n &gt; 0<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>limit<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> has no effect if it is less than <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>i<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n &gt; 0<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>limit<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、それが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>i<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>より少ないならば効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n &gt; 0<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, a limit that is less than <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> has no effect.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n &gt; 0<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ならば、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>より少ない限度は効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> can’t be represented as an instance of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Double<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> without rounding, the result of this initializer is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Double<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のインスタンスとして表されることが丸めることなしには可能でないならば、このイニシャライザの結果は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> can’t be represented as an instance of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Float80<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> without rounding, the result of this initializer is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Float80<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のインスタンスとして表されることが丸めることなしには可能でないならば、このイニシャライザの結果は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> can’t be represented as an instance of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Float<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> without rounding, the result of this initializer is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Float<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のインスタンスとして表されることが丸めることなしには可能でないならば、このイニシャライザの結果は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、結果は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> matches every element in the sequence, the result is an empty sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がシーケンスの中のすべての要素に合致するならば、結果は空のシーケンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> matches every element in the sequence, the resulting sequence contains every element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がシーケンスの中のすべての要素に合致するならば、結果のシーケンスはそのシーケンスのすべての要素を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is outside the bounds of this type after truncation, a runtime error may occur.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が切り詰め後にこの型の境界の外側ならば、実行時エラーが起こるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>starts<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>count<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> must be zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>starts<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>count<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>はゼロでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>Debug<ph x="5">&lt;w5/&gt;</ph>String<ph x="6">&lt;w6/&gt;</ph>Convertible<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol, the result is <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>subject<ph x="9">&lt;w9/&gt;</ph>.debug<ph x="10">&lt;w10/&gt;</ph>Description<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が準拠するのが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>Debug<ph x="5">&lt;w5/&gt;</ph>String<ph x="6">&lt;w6/&gt;</ph>Convertible<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルならば、結果は<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>subject<ph x="9">&lt;w9/&gt;</ph>.debug<ph x="10">&lt;w10/&gt;</ph>Description<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>String<ph x="5">&lt;w5/&gt;</ph>Convertible<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol, the result is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>subject<ph x="8">&lt;w8/&gt;</ph>.description<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が準拠するのが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>String<ph x="5">&lt;w5/&gt;</ph>Convertible<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルならば、結果は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>subject<ph x="8">&lt;w8/&gt;</ph>.description<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Text<ph x="4">&lt;w4/&gt;</ph>Output<ph x="5">&lt;w5/&gt;</ph>Streamable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol, the result is obtained by calling <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>subject<ph x="8">&lt;w8/&gt;</ph>.write(to: s)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> on an empty string <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>s<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が準拠するのが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Text<ph x="4">&lt;w4/&gt;</ph>Output<ph x="5">&lt;w5/&gt;</ph>Streamable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルならば、結果は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>subject<ph x="8">&lt;w8/&gt;</ph>.write(to: s)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を空の文字列<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>s<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>上で呼び出すことによって入手されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is not a class instance, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>ancestor<ph x="4">&lt;w4/&gt;</ph>Representation<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is ignored.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がクラスインスタンスでないならば、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>ancestor<ph x="4">&lt;w4/&gt;</ph>Representation<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>text<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is in an invalid format or contains characters that are out of range for the given <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>radix<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, or if the value it denotes in the given <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>radix<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is not representable, the result is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>text<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> が無効な形式になっているか指定<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>radix<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の範囲外の文字列を含むならば、または指定<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>radix<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>においてそれが意味する値が表現可能でないならば、結果は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, newline characters and character combinations are stripped from the result; otherwise, newline characters or character combinations are preserved.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ならば、改行文字および文字組み合わせは結果から剥ぎ取られます；そうでなければ、改行文字および文字組み合わせは保全されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the set’s buffer capacity is preserved; if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the underlying buffer is released.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ならば、集合が持つバッファ容量を維持します；<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば基盤をなすバッファは解放されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>user<ph x="2">&lt;w2/&gt;</ph>Prefs[greeting<ph x="3">&lt;w3/&gt;</ph>Key]<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has a value, that value is assigned to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>greeting<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>user<ph x="2">&lt;w2/&gt;</ph>Prefs[greeting<ph x="3">&lt;w3/&gt;</ph>Key]<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が値を持つならば、その値は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>greeting<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> contains unpaired UTF-16 surrogates, the result is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がペアでないUTF-16サロゲートを含むならば、結果は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is an ill-formed UTF-8 code sequence, the result is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が文法的に正しくないUTF-8コードシーケンスを含むならば、結果は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is +/-infinity or NaN, then <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.exponent<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int<ph x="7">&lt;w7/&gt;</ph>.max<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が+/-infinityまたはNaNならば、そのとき<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.exponent<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int<ph x="7">&lt;w7/&gt;</ph>.max<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is 10, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.significand<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>1<ph x="7">&lt;w7/&gt;</ph>.01<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> in binary, so <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x<ph x="10">&lt;w10/&gt;</ph>.significand<ph x="11">&lt;w11/&gt;</ph>Width<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> is 2.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が10ならば、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.significand<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は２進数で<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>1<ph x="7">&lt;w7/&gt;</ph>.01<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>です、それで<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x<ph x="10">&lt;w10/&gt;</ph>.significand<ph x="11">&lt;w11/&gt;</ph>Width<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>は２です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-greatest<ph x="4">&lt;w4/&gt;</ph>Finite<ph x="5">&lt;w5/&gt;</ph>Magnitude<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, then <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ph x="8">&lt;w8/&gt;</ph>.next<ph x="9">&lt;w9/&gt;</ph>Down<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>-infinity<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-greatest<ph x="4">&lt;w4/&gt;</ph>Finite<ph x="5">&lt;w5/&gt;</ph>Magnitude<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、そのとき<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ph x="8">&lt;w8/&gt;</ph>.next<ph x="9">&lt;w9/&gt;</ph>Down<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>-infinity<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-infinity<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, then <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ph x="6">&lt;w6/&gt;</ph>.next<ph x="7">&lt;w7/&gt;</ph>Up<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>-greatest<ph x="10">&lt;w10/&gt;</ph>Finite<ph x="11">&lt;w11/&gt;</ph>Magnitude<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-infinity<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、そのとき<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ph x="6">&lt;w6/&gt;</ph>.next<ph x="7">&lt;w7/&gt;</ph>Up<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>-greatest<ph x="10">&lt;w10/&gt;</ph>Finite<ph x="11">&lt;w11/&gt;</ph>Magnitude<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-least<ph x="4">&lt;w4/&gt;</ph>Nonzero<ph x="5">&lt;w5/&gt;</ph>Magnitude<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, then <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ph x="8">&lt;w8/&gt;</ph>.next<ph x="9">&lt;w9/&gt;</ph>Up<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>-0<ph x="12">&lt;w12/&gt;</ph>.0<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-least<ph x="4">&lt;w4/&gt;</ph>Nonzero<ph x="5">&lt;w5/&gt;</ph>Magnitude<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、そのとき<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ph x="8">&lt;w8/&gt;</ph>.next<ph x="9">&lt;w9/&gt;</ph>Up<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>-0<ph x="12">&lt;w12/&gt;</ph>.0<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>greatest<ph x="4">&lt;w4/&gt;</ph>Finite<ph x="5">&lt;w5/&gt;</ph>Magnitude<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, then <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ph x="8">&lt;w8/&gt;</ph>.next<ph x="9">&lt;w9/&gt;</ph>Up<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>infinity<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>greatest<ph x="4">&lt;w4/&gt;</ph>Finite<ph x="5">&lt;w5/&gt;</ph>Magnitude<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、そのとき<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ph x="8">&lt;w8/&gt;</ph>.next<ph x="9">&lt;w9/&gt;</ph>Up<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>infinity<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>infinity<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, then <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ph x="6">&lt;w6/&gt;</ph>.next<ph x="7">&lt;w7/&gt;</ph>Down<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>greatest<ph x="10">&lt;w10/&gt;</ph>Finite<ph x="11">&lt;w11/&gt;</ph>Magnitude<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>infinity<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、そのとき<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ph x="6">&lt;w6/&gt;</ph>.next<ph x="7">&lt;w7/&gt;</ph>Down<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>greatest<ph x="10">&lt;w10/&gt;</ph>Finite<ph x="11">&lt;w11/&gt;</ph>Magnitude<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is Float.pi, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.significand<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>1<ph x="7">&lt;w7/&gt;</ph>.10010010000111111011011<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> in binary, and <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x<ph x="10">&lt;w10/&gt;</ph>.significand<ph x="11">&lt;w11/&gt;</ph>Width<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> is 23.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がFloat.piならば、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.significand<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は２進数で<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>1<ph x="7">&lt;w7/&gt;</ph>.10010010000111111011011<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>です、それで<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x<ph x="10">&lt;w10/&gt;</ph>.significand<ph x="11">&lt;w11/&gt;</ph>Width<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>は23です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is NaN, then <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.significand<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がNaNならば、そのとき<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.significand<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>はNaNです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is infinity, then <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.significand<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is 1.0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が無限大ならば、そのとき<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.significand<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は1.0です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is not a finite number, then <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.ulp<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が有限数でないならば、そのとき<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.ulp<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>はNaNです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is very small in magnitude, then <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.ulp<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> may be a subnormal number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が規模において非常に小さいならば、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.ulp<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>はサブノーマル数かもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is zero, then <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.exponent<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int<ph x="7">&lt;w7/&gt;</ph>.min<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がゼロならば、そのとき<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.exponent<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int<ph x="7">&lt;w7/&gt;</ph>.min<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is zero, then <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.next<ph x="5">&lt;w5/&gt;</ph>Down<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>-least<ph x="8">&lt;w8/&gt;</ph>Nonzero<ph x="9">&lt;w9/&gt;</ph>Magnitude<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がゼロならば、そのとき<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.next<ph x="5">&lt;w5/&gt;</ph>Down<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>-least<ph x="8">&lt;w8/&gt;</ph>Nonzero<ph x="9">&lt;w9/&gt;</ph>Magnitude<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is zero, then <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.next<ph x="5">&lt;w5/&gt;</ph>Up<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>least<ph x="8">&lt;w8/&gt;</ph>Nonzero<ph x="9">&lt;w9/&gt;</ph>Magnitude<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がゼロならば、そのとき<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.next<ph x="5">&lt;w5/&gt;</ph>Up<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>least<ph x="8">&lt;w8/&gt;</ph>Nonzero<ph x="9">&lt;w9/&gt;</ph>Magnitude<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is zero, then <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.significand<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is 0.0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がゼロならば、そのとき<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ph x="4">&lt;w4/&gt;</ph>.significand<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は0.0です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>T<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> is a nontrivial type, you must eventually deinitialize or move from the values in this region to avoid leaks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>T<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>が非自明型ならば、あなたはゆくゆくはデイニシャライズするかまたはこの領域の値から移動してリークを防がなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>n<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> is negative, this is the same value as the result of <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>-n<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> calls to <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>index(before:)<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>n<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>が負ならば、これは<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>-n<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>が<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>index(before:)<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>を呼び出すの結果と同じ値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>copy(with:)<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> returns the same array, the instances of <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>NSArray<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> and <bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>Array<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept> share storage using the same copy-on-write optimization that is used when two instances of <bpt i="22" x="22">&lt;c22&gt;</bpt><bpt i="23" x="23">&lt;s23&gt;</bpt>Array<ept i="23">&lt;/s23&gt;</ept><ept i="22">&lt;/c22&gt;</ept> share storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>copy(with:)<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>が同じ配列を返すならば、<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>NSArray<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>と<bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>Array<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept>のインスタンスは同じコピーオンライト最適化を使ってストレージを共有します、それは<bpt i="22" x="22">&lt;c22&gt;</bpt><bpt i="23" x="23">&lt;s23&gt;</bpt>Array<ept i="23">&lt;/s23&gt;</ept><ept i="22">&lt;/c22&gt;</ept>の２つのインスタンスがストレージを共有するとき使う最適化です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>x / y<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> is exactly halfway between two integers, <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>q<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> is chosen to be even.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>x / y<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>が正確に２つの整数の間の中ほどならば、<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>q<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>は偶数である方を選ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>a<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>b<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> are incomparable, and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>b<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>c<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> are incomparable, then <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>a<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> and <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>c<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> are also incomparable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>a<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>b<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が比較できないならば、そして<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>b<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>と<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>c<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>が比較できないならば、そのとき<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>a<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>と<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>c<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>もまた比較できない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>body<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> has a return value, it is used as the return value for the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>with<ph x="6">&lt;w6/&gt;</ph>Memory<ph x="7">&lt;w7/&gt;</ph>Rebound(to:<ph x="8">&lt;w8/&gt;</ph>capacity:<ph x="9">&lt;w9/&gt;</ph>_:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>body<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が戻り値を持つならば、それは<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>with<ph x="6">&lt;w6/&gt;</ph>Memory<ph x="7">&lt;w7/&gt;</ph>Rebound(to:<ph x="8">&lt;w8/&gt;</ph>capacity:<ph x="9">&lt;w9/&gt;</ph>_:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドの戻り値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>body<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> has a return value, it is used as the return value for the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>without<ph x="6">&lt;w6/&gt;</ph>Actually<ph x="7">&lt;w7/&gt;</ph>Escaping(_:<ph x="8">&lt;w8/&gt;</ph>do:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>body<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が値を返すならば、それは<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>without<ph x="6">&lt;w6/&gt;</ph>Actually<ph x="7">&lt;w7/&gt;</ph>Escaping(_:<ph x="8">&lt;w8/&gt;</ph>do:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>関数のための戻り値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is not found in the collection, returns <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>がコレクションの中に見つけられないならば、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>key<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> already exists in the dictionary, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>value<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> replaces the existing associated value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>key<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が既に辞書の中に存在するならば、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>value<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が既存の結び付けられる値に取って代わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> contains multiple instances of equivalent elements, only the first instance is kept.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が同等の要素を複数含むならば、最初の要素だけが残されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, the result is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>0<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ならば、結果は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>0<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is outside the range <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>0..<ph x="6">&lt;lhs&lt;w6/&gt;</ph>.bit<ph x="7">&lt;w7/&gt;</ph>Width<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, it is masked to produce a value within that range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が範囲<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>0..<ph x="6">&lt;lhs&lt;w6/&gt;</ph>.bit<ph x="7">&lt;w7/&gt;</ph>Width<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の外側ならば、それはマスクされてその範囲内の値を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>start<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>count<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> must be zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>start<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ならば、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>count<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>はゼロでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>text<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> has invalid characters or is in an invalid format, the result is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>text<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が無効な文字を持つまたは無効な形式であるならば、結果は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>stop<ph x="5">&lt;w5/&gt;</ph>On<ph x="6">&lt;w6/&gt;</ph>Error<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>false<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, the entire iterator will be exhausted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>stop<ph x="5">&lt;w5/&gt;</ph>On<ph x="6">&lt;w6/&gt;</ph>Error<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>false<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>ならば、イテレータ全体が使い尽くされることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>body<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> has a return value, it is used as the return value for the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>with<ph x="8">&lt;w8/&gt;</ph>Unsafe<ph x="9">&lt;w9/&gt;</ph>Buffer<ph x="10">&lt;w10/&gt;</ph>Pointer(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>body<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が戻り値を持つならば、それは<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>with<ph x="8">&lt;w8/&gt;</ph>Unsafe<ph x="9">&lt;w9/&gt;</ph>Buffer<ph x="10">&lt;w10/&gt;</ph>Pointer(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>メソッドの戻り値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>n<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is positive, this is the same value as the result of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>n<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> calls to <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>index(after:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>n<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が正ならば、これは<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>n<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>で<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>index(after:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を呼び出すの結果と同じ値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is zero, the result of the division is infinity, with the sign of the result matching the sign of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>lhs<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>がゼロならば、除算の結果は無限大です、結果の符号は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>lhs<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の符号と一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>source<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is less than the smallest representable value in this type, the result is the type’s <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>min<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>source<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>がこの型の最も小さい表現可能な値より小さいならば、結果はこの型の<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>min<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is equal to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>y<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, returns <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>y<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>と等しいならば、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is equal to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>y<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, returns <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>y<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>y<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>と等しいならば、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>y<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>body<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> has a return value, it is used as the return value for the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>with<ph x="9">&lt;w9/&gt;</ph>Unsafe<ph x="10">&lt;w10/&gt;</ph>Bytes(_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>body<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>が戻り値を持つならば、それは<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>with<ph x="9">&lt;w9/&gt;</ph>Unsafe<ph x="10">&lt;w10/&gt;</ph>Bytes(_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>メソッドの戻り値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>body<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> has a return value, it is used as the return value for the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>with<ph x="9">&lt;w9/&gt;</ph>Unsafe<ph x="10">&lt;w10/&gt;</ph>Mutable<ph x="11">&lt;w11/&gt;</ph>Buffer<ph x="12">&lt;w12/&gt;</ph>Pointer(_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>body<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>が戻り値を持つならば、それは<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>with<ph x="9">&lt;w9/&gt;</ph>Unsafe<ph x="10">&lt;w10/&gt;</ph>Mutable<ph x="11">&lt;w11/&gt;</ph>Buffer<ph x="12">&lt;w12/&gt;</ph>Pointer(_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>メソッドの戻り値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>i<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is equal to the collection’s <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>end<ph x="9">&lt;w9/&gt;</ph>Index<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> property, the complexity is O(<bpt i="10" x="10">&lt;e10&gt;</bpt>n<ept i="10">&lt;/e10&gt;</ept>), where <bpt i="11" x="11">&lt;e11&gt;</bpt>n<ept i="11">&lt;/e11&gt;</ept> is the length of <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>new<ph x="14">&lt;w14/&gt;</ph>Elements<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>i<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>がコレクションの<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>end<ph x="9">&lt;w9/&gt;</ph>Index<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>プロパティと等しいならば、計算量はO(<bpt i="10" x="10">&lt;e10&gt;</bpt>n<ept i="10">&lt;/e10&gt;</ept>)です、ここで<bpt i="11" x="11">&lt;e11&gt;</bpt>n<ept i="11">&lt;/e11&gt;</ept>は<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>new<ph x="14">&lt;w14/&gt;</ph>Elements<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>body<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> has a return value, it is used as the return value for the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>with<ph x="10">&lt;w10/&gt;</ph>Unsafe<ph x="11">&lt;w11/&gt;</ph>Mutable<ph x="12">&lt;w12/&gt;</ph>Bytes(_:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>body<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>が戻り値を持つならば、それは<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>with<ph x="10">&lt;w10/&gt;</ph>Unsafe<ph x="11">&lt;w11/&gt;</ph>Mutable<ph x="12">&lt;w12/&gt;</ph>Bytes(_:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>メソッドの戻り値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>body<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> has a return value, it is used as the return value for the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>with<ph x="10">&lt;w10/&gt;</ph>Va<ph x="11">&lt;w11/&gt;</ph>List(_:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>body<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>が値を返すならば、それは<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>with<ph x="10">&lt;w10/&gt;</ph>Va<ph x="11">&lt;w11/&gt;</ph>List(_:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>関数のための戻り値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>key<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> isn’t already a key of the dictionary, the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>(key, value)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> pair is added.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>key<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>がまだこの辞書のキーでないならば、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>(key, value)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>ペアが加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>object<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>nil<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>, the return value is <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>false<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>object<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>が<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>nil<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>ならば、戻り値は<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>false<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>true<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, only nonempty subsequences are returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>true<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>ならば、空でない下位シーケンスだけが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>possible<ph x="9">&lt;w9/&gt;</ph>Prefix<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> has no elements, the return value is <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>true<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>possible<ph x="9">&lt;w9/&gt;</ph>Prefix<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>が１つも要素を持たないならば、戻り値は<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>true<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>next<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> never returns <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>nil<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>, the sequence is infinite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>next<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>が決して<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>nil<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>を返さないならば、 このシーケンスは果てがありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>true<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>, only nonempty subsequences are returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>true<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>ならば、空でない下位シーケンスだけが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> is not NaN, <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>x<ph x="12">&lt;w12/&gt;</ph>.magnitude<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> is the absolute value of <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>x<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>がNaNでないならば、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>x<ph x="12">&lt;w12/&gt;</ph>.magnitude<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>は<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>x<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>の絶対値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>T<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> is a nontrivial type, you must eventually deinitialize or move from the values in this region to avoid leaks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>T<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>が非自明型ならば、あなたはゆくゆくはデイニシャライズするかまたはこの領域の値から移動してリークを防がなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If EOF has already been reached when <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>read<ph x="2">&lt;w2/&gt;</ph>Line()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is called, the result is <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>nil<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>read<ph x="2">&lt;w2/&gt;</ph>Line()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が呼ばれるときEOFがすでに到達されているならば、結果は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>nil<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a type does not support subnormals, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x<ph x="7">&lt;w7/&gt;</ph>.ulp<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> may be rounded to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型がサブノーマルをサポートしないならば、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x<ph x="7">&lt;w7/&gt;</ph>.ulp<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>はゼロに丸められるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a type’s radix is 2, then for finite nonzero numbers, the significand is in the range <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>1<ph x="2">&lt;w2/&gt;</ph>.0 ..&lt; 2<ph x="3">&lt;w3/&gt;</ph>.0<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型の基数が２であるならば、そのとき有限の非ゼロの数に対して、仮数は範囲<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>1<ph x="2">&lt;w2/&gt;</ph>.0 ..&lt; 2<ph x="3">&lt;w3/&gt;</ph>.0<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an arithmetic overflow occurs, the behavior is undefined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>算術オーバーフローが起こるならば、その挙動は未定義です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an element equal to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>new<ph x="2">&lt;w2/&gt;</ph>Member<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is already contained in the set, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>new<ph x="5">&lt;w5/&gt;</ph>Member<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> replaces the existing element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>new<ph x="2">&lt;w2/&gt;</ph>Member<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に等しい要素が既にこの集合に含まれるならば、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>new<ph x="5">&lt;w5/&gt;</ph>Member<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は既存の要素と置き換わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an element equal to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>new<ph x="2">&lt;w2/&gt;</ph>Member<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is already contained in the set, this method has no effect.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>new<ph x="2">&lt;w2/&gt;</ph>Member<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に等しい要素が既にこの集合に含まれるならば、このメソッドは効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an element equal to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>new<ph x="8">&lt;w8/&gt;</ph>Member<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> was already contained in the set, the method returns <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>(false, old<ph x="11">&lt;w11/&gt;</ph>Member)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>, where <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>old<ph x="14">&lt;w14/&gt;</ph>Member<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> is the element that was equal to <bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>new<ph x="17">&lt;w17/&gt;</ph>Member<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>new<ph x="8">&lt;w8/&gt;</ph>Member<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に等しい要素が既に集合に含まれたならば、メソッドは<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>(false, old<ph x="11">&lt;w11/&gt;</ph>Member)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>を返します、ここで<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>old<ph x="14">&lt;w14/&gt;</ph>Member<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>は<bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>new<ph x="17">&lt;w17/&gt;</ph>Member<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>に等しかった要素です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If any are found, the result of the initializer is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何か見つけられるならば、イニシャライザの結果は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If both <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>x<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> and <bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>y<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept> are NaN, or either <bpt i="22" x="22">&lt;c22&gt;</bpt><bpt i="23" x="23">&lt;s23&gt;</bpt>x<ept i="23">&lt;/s23&gt;</ept><ept i="22">&lt;/c22&gt;</ept> or <bpt i="24" x="24">&lt;c24&gt;</bpt><bpt i="25" x="25">&lt;s25&gt;</bpt>y<ept i="25">&lt;/s25&gt;</ept><ept i="24">&lt;/c24&gt;</ept> is a signaling NaN, the result is NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>x<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>と<bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>y<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept>の両方がNaN、または<bpt i="22" x="22">&lt;c22&gt;</bpt><bpt i="23" x="23">&lt;s23&gt;</bpt>x<ept i="23">&lt;/s23&gt;</ept><ept i="22">&lt;/c22&gt;</ept>または<bpt i="24" x="24">&lt;c24&gt;</bpt><bpt i="25" x="25">&lt;s25&gt;</bpt>y<ept i="25">&lt;/s25&gt;</ept><ept i="24">&lt;/c24&gt;</ept>のどちらかがシグナルNaNならば、結果はNaNです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If both <bpt i="23" x="23">&lt;c23&gt;</bpt><bpt i="24" x="24">&lt;s24&gt;</bpt>x<ept i="24">&lt;/s24&gt;</ept><ept i="23">&lt;/c23&gt;</ept> and <bpt i="25" x="25">&lt;c25&gt;</bpt><bpt i="26" x="26">&lt;s26&gt;</bpt>y<ept i="26">&lt;/s26&gt;</ept><ept i="25">&lt;/c25&gt;</ept> are NaN, or either <bpt i="27" x="27">&lt;c27&gt;</bpt><bpt i="28" x="28">&lt;s28&gt;</bpt>x<ept i="28">&lt;/s28&gt;</ept><ept i="27">&lt;/c27&gt;</ept> or <bpt i="29" x="29">&lt;c29&gt;</bpt><bpt i="30" x="30">&lt;s30&gt;</bpt>y<ept i="30">&lt;/s30&gt;</ept><ept i="29">&lt;/c29&gt;</ept> is a signaling NaN, the result is NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="23" x="23">&lt;c23&gt;</bpt><bpt i="24" x="24">&lt;s24&gt;</bpt>x<ept i="24">&lt;/s24&gt;</ept><ept i="23">&lt;/c23&gt;</ept>と<bpt i="25" x="25">&lt;c25&gt;</bpt><bpt i="26" x="26">&lt;s26&gt;</bpt>y<ept i="26">&lt;/s26&gt;</ept><ept i="25">&lt;/c25&gt;</ept>の両方がNaN、または<bpt i="27" x="27">&lt;c27&gt;</bpt><bpt i="28" x="28">&lt;s28&gt;</bpt>x<ept i="28">&lt;/s28&gt;</ept><ept i="27">&lt;/c27&gt;</ept>または<bpt i="29" x="29">&lt;c29&gt;</bpt><bpt i="30" x="30">&lt;s30&gt;</bpt>y<ept i="30">&lt;/s30&gt;</ept><ept i="29">&lt;/c29&gt;</ept>のどちらかがシグナルNaNならば、結果はNaNです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If both values are <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, the operator returns <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>false<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方の値が<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>ならば、演算子は<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>false<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If closure throws error while sorting, order of elements may change.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャがソートの間にエラーをスローするならば、要素の順番は変化するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If either of the values is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, the operator returns <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>false<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値のどちらかが<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>ならば、演算子は<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>false<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If included, the exponent is separated by a single character, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>e<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>E<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, and consists of an optional plus or minus sign character and a sequence of decimal digits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし含むならば、指数は１つの文字<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>e<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>もしくは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>E<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>によって区切られます、そして随意のプラスまたはマイナス符号文字と一連の10進の桁から成り立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If included, the exponent is separated by a single character, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>P<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, and consists of an optional plus or minus sign character and a sequence of decimal digits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし含むならば、指数は１つの文字<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>もしくは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>P<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>によって区切られます、そして随意のプラスまたはマイナス符号文字と一連の10進の桁から成り立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If necessary, the byte order of this value is reversed from the typical byte order of this integer type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>必要ならば、この値のバイト順はこの整数型の典型的なバイト順からひっくり返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If no elements in the collection match <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>belongs<ph x="7">&lt;w7/&gt;</ph>In<ph x="8">&lt;w8/&gt;</ph>Second<ph x="9">&lt;w9/&gt;</ph>Partition<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, the returned index is equal to the collection’s <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>end<ph x="12">&lt;w12/&gt;</ph>Index<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの中の要素が１つも<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>belongs<ph x="7">&lt;w7/&gt;</ph>In<ph x="8">&lt;w8/&gt;</ph>Second<ph x="9">&lt;w9/&gt;</ph>Partition<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に一致しないならば、返されるインデックスはコレクションの<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>end<ph x="12">&lt;w12/&gt;</ph>Index<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If no elements in the collection satisfy the given predicate, returns <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの要素が与えられた述部を満たすことがないならば、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If no such storage exists, it is created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのようなストレージが存在しないならば、それは作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If not, any value in <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>defaults[greeting<ph x="8">&lt;w8/&gt;</ph>Key]<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> will succeed, and if not that, <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>greeting<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> will be set to the non-optional default value, <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>"Greetings!"<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでないならば、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>defaults[greeting<ph x="8">&lt;w8/&gt;</ph>Key]<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の中の何らかの値が後を継ぎます、そしてそれもないならば、<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>greeting<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>は非オプショナルの省略時の値、<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>"Greetings!"<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type has a maximal value, it can serve as an upper bound but can never be contained in a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Countable<ph x="4">&lt;w4/&gt;</ph>Range&lt;Bound&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型が最大の値を持つならば、それは上側の境界としての務めを果たすことができますが、決して<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Countable<ph x="4">&lt;w4/&gt;</ph>Range&lt;Bound&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスには含まれることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is empty, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is equal to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>start<ph x="8">&lt;w8/&gt;</ph>Index<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが空ならば、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>start<ph x="8">&lt;w8/&gt;</ph>Index<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is empty, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is equal to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>end<ph x="8">&lt;w8/&gt;</ph>Index<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが空ならば、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>end<ph x="8">&lt;w8/&gt;</ph>Index<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ph x="2">&lt;w2/&gt;</ph>Address<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> of this buffer is <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>nil<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, the count is zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このバッファの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ph x="2">&lt;w2/&gt;</ph>Address<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>nil<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>ならば、総数はゼロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> bytes of memory referenced by this pointer are bound to a type <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, then <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> must be a trivial type, this pointer and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>source<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> must be properly aligned for accessing <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>T<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>, and <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>count<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> must be a multiple of <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Memory<ph x="14">&lt;w14/&gt;</ph>Layout&lt;T&gt;.stride<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタによって参照されるメモリの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バイトが型<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に束縛されるならば、そのとき<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は自明型でなければならず、このポインタと<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>source<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>T<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>にアクセスするために適切にアラインされなければならず、そして<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>count<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>は<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Memory<ph x="14">&lt;w14/&gt;</ph>Layout&lt;T&gt;.stride<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>の倍数でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>overflow<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> component is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.none<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>partial<ph x="6">&lt;w6/&gt;</ph>Value<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> component contains the entire difference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>overflow<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>構成部分が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.none<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>partial<ph x="6">&lt;w6/&gt;</ph>Value<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>構成部分は差異そのままを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>overflow<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> component is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.none<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>partial<ph x="6">&lt;w6/&gt;</ph>Value<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> component contains the entire product.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>overflow<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>構成部分が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.none<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>partial<ph x="6">&lt;w6/&gt;</ph>Value<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>構成部分は積そのままを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>overflow<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> component is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.none<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>partial<ph x="6">&lt;w6/&gt;</ph>Value<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> component contains the entire quotient.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>overflow<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>構成部分が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.none<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>partial<ph x="6">&lt;w6/&gt;</ph>Value<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>構成部分は商そのままを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>overflow<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> component is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.none<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>partial<ph x="6">&lt;w6/&gt;</ph>Value<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> component contains the entire sum.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>overflow<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>構成部分が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.none<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>partial<ph x="6">&lt;w6/&gt;</ph>Value<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>構成部分は合計そのままを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ph x="2">&lt;w2/&gt;</ph>.count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> bytes of memory referenced by this pointer are bound to a type <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>T<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, then <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>T<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> must be a trivial type, the underlying pointer must be properly aligned for accessing <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>T<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, and <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>source<ph x="11">&lt;w11/&gt;</ph>.count<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> must be a multiple of <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Memory<ph x="14">&lt;w14/&gt;</ph>Layout&lt;T&gt;.stride<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタによって参照されるメモリの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ph x="2">&lt;w2/&gt;</ph>.count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バイトが型<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>T<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に束縛されるならば、そのとき<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>T<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は自明型でなければならず、基盤となるポインタは<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>T<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>にアクセスするために適切にアラインされなければならず、そして<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>source<ph x="11">&lt;w11/&gt;</ph>.count<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>は<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Memory<ph x="14">&lt;w14/&gt;</ph>Layout&lt;T&gt;.stride<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>の倍数でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>overflow<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> component is <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>.overflow<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>, an overflow occurred and the <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>partial<ph x="13">&lt;w13/&gt;</ph>Value<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> component contains the truncated product of this value and <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>rhs<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>overflow<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>構成部分が<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>.overflow<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>であるならば、オーバーフローが起こったそして<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>partial<ph x="13">&lt;w13/&gt;</ph>Value<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>構成部分はこの値と<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>rhs<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>の積の切り詰められたものを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>overflow<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> component is <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>.overflow<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>, an overflow occurred and the <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>partial<ph x="13">&lt;w13/&gt;</ph>Value<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> component contains the truncated quotient.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>overflow<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>構成部分が<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>.overflow<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>であるならば、オーバーフローが起こったそして<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>partial<ph x="13">&lt;w13/&gt;</ph>Value<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>構成部分は商の切り詰められたものを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>overflow<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> component is <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>.overflow<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>, an overflow occurred and the <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>partial<ph x="13">&lt;w13/&gt;</ph>Value<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> component contains the truncated result of <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>rhs<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> subtracted from this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>overflow<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>構成部分が<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>.overflow<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>であるならば、オーバーフローが起こったそして<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>partial<ph x="13">&lt;w13/&gt;</ph>Value<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>構成部分はこの値から<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>rhs<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>を減算した結果の切り詰められたもの含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>overflow<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> component is <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>.overflow<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>, an overflow occurred and the <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>partial<ph x="13">&lt;w13/&gt;</ph>Value<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> component contains the truncated sum of this value and <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>rhs<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>overflow<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>構成部分が<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>.overflow<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>であるならば、オーバーフローが起こったそして<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>partial<ph x="13">&lt;w13/&gt;</ph>Value<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>構成部分はこの値と<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>rhs<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>の合計の切り詰められたものを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the UTF-8 view is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-8ビューが空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the array is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列が空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the array is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列が空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the array is empty, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>start<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is equal to <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>end<ph x="10">&lt;w10/&gt;</ph>Index<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列が空ならば、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>start<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>end<ph x="10">&lt;w10/&gt;</ph>Index<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the array is empty, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>start<ph x="8">&lt;w8/&gt;</ph>Index<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is equal to <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>end<ph x="11">&lt;w11/&gt;</ph>Index<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列が空ならば、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>start<ph x="8">&lt;w8/&gt;</ph>Index<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>end<ph x="11">&lt;w11/&gt;</ph>Index<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the array is empty, these properties are <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その配列が空であるならば、これらのプロパティは<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the array uses a bridged <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSArray<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance as its storage, the efficiency is unspecified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この配列が、ブリッジされた<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSArray<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスをそれのストレージとして使うならば、効率は不特定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the array uses a bridged <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSArray<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance as its storage, the efficiency is unspecified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この配列が、ブリッジされた<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSArray<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスをそれのストレージとして使うならば、効率は不特定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the array’s <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Element<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> type is a struct or enumeration, <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>Array<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> and <bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>Contiguous<ph x="17">&lt;w17/&gt;</ph>Array<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept> should have similar efficiency.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Element<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>型が構造体または列挙であるならば、<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>Array<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>と<bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>Contiguous<ph x="17">&lt;w17/&gt;</ph>Array<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>は同じような効率を持つはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the call to <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>replace<ph x="7">&lt;w7/&gt;</ph>Subrange(_:<ph x="8">&lt;w8/&gt;</ph>with:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> simply removes characters at the end of the view, the complexity is O(<bpt i="9" x="9">&lt;e9&gt;</bpt>n<ept i="9">&lt;/e9&gt;</ept>), where <bpt i="10" x="10">&lt;e10&gt;</bpt>n<ept i="10">&lt;/e10&gt;</ept> is equal to <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>bounds<ph x="13">&lt;w13/&gt;</ph>.count<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>replace<ph x="7">&lt;w7/&gt;</ph>Subrange(_:<ph x="8">&lt;w8/&gt;</ph>with:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>への呼び出しが単にいくらかの文字をビューの終わりから削除するだけならば、計算量はO(<bpt i="9" x="9">&lt;e9&gt;</bpt>n<ept i="9">&lt;/e9&gt;</ept>)です、ここで<bpt i="10" x="10">&lt;e10&gt;</bpt>n<ept i="10">&lt;/e10&gt;</ept>は<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>bounds<ph x="13">&lt;w13/&gt;</ph>.count<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the call to <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>replace<ph x="7">&lt;w7/&gt;</ph>Subrange(_:<ph x="8">&lt;w8/&gt;</ph>with:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> simply removes elements at the end of the string, the complexity is O(<bpt i="9" x="9">&lt;e9&gt;</bpt>n<ept i="9">&lt;/e9&gt;</ept>), where <bpt i="10" x="10">&lt;e10&gt;</bpt>n<ept i="10">&lt;/e10&gt;</ept> is equal to <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>bounds<ph x="13">&lt;w13/&gt;</ph>.count<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>replace<ph x="7">&lt;w7/&gt;</ph>Subrange(_:<ph x="8">&lt;w8/&gt;</ph>with:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>への呼び出しが単に要素を文字列の終わりから削除するだけならば、計算量はO(<bpt i="9" x="9">&lt;e9&gt;</bpt>n<ept i="9">&lt;/e9&gt;</ept>)です、ここで<bpt i="10" x="10">&lt;e10&gt;</bpt>n<ept i="10">&lt;/e10&gt;</ept>は<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>bounds<ph x="13">&lt;w13/&gt;</ph>.count<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the call to <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>replace<ph x="7">&lt;w7/&gt;</ph>Subrange(_:<ph x="8">&lt;w8/&gt;</ph>with:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> simply removes text at the end of the string, the complexity is O(<bpt i="9" x="9">&lt;e9&gt;</bpt>n<ept i="9">&lt;/e9&gt;</ept>), where <bpt i="10" x="10">&lt;e10&gt;</bpt>n<ept i="10">&lt;/e10&gt;</ept> is equal to <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>bounds<ph x="13">&lt;w13/&gt;</ph>.count<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>replace<ph x="7">&lt;w7/&gt;</ph>Subrange(_:<ph x="8">&lt;w8/&gt;</ph>with:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>への呼び出しが単にテキストを文字列の終わりから削除するだけならば、計算量はO(<bpt i="9" x="9">&lt;e9&gt;</bpt>n<ept i="9">&lt;/e9&gt;</ept>)です、ここで<bpt i="10" x="10">&lt;e10&gt;</bpt>n<ept i="10">&lt;/e10&gt;</ept>は<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>bounds<ph x="13">&lt;w13/&gt;</ph>.count<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the call to <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>replace<ph x="7">&lt;w7/&gt;</ph>Subrange<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> simply appends the contents of <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>new<ph x="10">&lt;w10/&gt;</ph>Elements<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> to the collection, the complexity is O(<bpt i="11" x="11">&lt;e11&gt;</bpt>n<ept i="11">&lt;/e11&gt;</ept>), where <bpt i="12" x="12">&lt;e12&gt;</bpt>n<ept i="12">&lt;/e12&gt;</ept> is the length of <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>new<ph x="15">&lt;w15/&gt;</ph>Elements<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>replace<ph x="7">&lt;w7/&gt;</ph>Subrange<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>への呼び出しが単に<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>new<ph x="10">&lt;w10/&gt;</ph>Elements<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>の内容をコレクションに追加するだけならば、計算量はO(<bpt i="11" x="11">&lt;e11&gt;</bpt>n<ept i="11">&lt;/e11&gt;</ept>)です、ここで<bpt i="12" x="12">&lt;e12&gt;</bpt>n<ept i="12">&lt;/e12&gt;</ept>は<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>new<ph x="15">&lt;w15/&gt;</ph>Elements<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the closure has a return value, it is used as the return value of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>with<ph x="2">&lt;w2/&gt;</ph>UTF8Buffer(invoke:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャが戻り値を持つならば、それは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>with<ph x="2">&lt;w2/&gt;</ph>UTF8Buffer(invoke:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドの戻り値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the closure has a return value, it is used as the return value of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Bytes(of:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャが戻り値を持つならば、それは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Bytes(of:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>関数の戻り値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the closure has a return value, it is used as the return value of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Bytes(of:<ph x="7">&lt;w7/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャが戻り値を持つならば、それは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Bytes(of:<ph x="7">&lt;w7/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>関数の戻り値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the closure has a return value, it is used as the return value of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Pointer(to:<ph x="7">&lt;w7/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャが戻り値を持つならば、それは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Pointer(to:<ph x="7">&lt;w7/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>関数の戻り値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the closure has a return value, it is used as the return value of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Pointer(to:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャが戻り値を持つならば、それは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Pointer(to:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>関数の戻り値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the collection does not have sufficient capacity for another element, additional storage is allocated before appending <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>new<ph x="2">&lt;w2/&gt;</ph>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションが別の要素に対して十分な容量を持たないならば、追加のストレージが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>new<ph x="2">&lt;w2/&gt;</ph>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を追加する前に割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the collection is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書が空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the collection is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションが空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the collection is empty, the value of this property is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションが空であるならば、このプロパティは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the dictionary doesn’t contain the key, the key and value are added as a new key-value pair.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書がそのキーを含まないならば、キーと値は新しいキー値ペアとして加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the dictionary wraps a bridged <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSDictionary<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the performance is unspecified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書が、ブリッジされた<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSDictionary<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>をラップするならば、性能は不特定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the dynamic type of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>obj<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> doesn’t implement a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>get<ph x="4">&lt;w4/&gt;</ph>Integer<ph x="5">&lt;w5/&gt;</ph>Value()<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method, the system returns a runtime error when you initialize <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>certain<ph x="8">&lt;w8/&gt;</ph>Value<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>obj<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の動的型が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>get<ph x="4">&lt;w4/&gt;</ph>Integer<ph x="5">&lt;w5/&gt;</ph>Value()<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドを実装しないならば、システムは実行時エラーをあなたが<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>certain<ph x="8">&lt;w8/&gt;</ph>Value<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を初期化する時に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the dynamic type of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>Playground<ph x="5">&lt;w5/&gt;</ph>Quick<ph x="6">&lt;w6/&gt;</ph>Lookable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, returns the result of calling its <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>custom<ph x="9">&lt;w9/&gt;</ph>Playground<ph x="10">&lt;w10/&gt;</ph>Quick<ph x="11">&lt;w11/&gt;</ph>Look<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の動的型が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>Playground<ph x="5">&lt;w5/&gt;</ph>Quick<ph x="6">&lt;w6/&gt;</ph>Lookable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するならば、それの<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>custom<ph x="9">&lt;w9/&gt;</ph>Playground<ph x="10">&lt;w10/&gt;</ph>Quick<ph x="11">&lt;w11/&gt;</ph>Look<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>プロパティを呼び出すことの結果が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the dynamic type of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>Reflectable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the resulting mirror is determined by its <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>custom<ph x="7">&lt;w7/&gt;</ph>Mirror<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の動的型が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>Reflectable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するならば、結果として生じるミラーは、それの<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>custom<ph x="7">&lt;w7/&gt;</ph>Mirror<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロパティによって決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the dynamic type of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has value semantics, subsequent mutations of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>subject<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> will not observable in <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Mirror<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の動的型が値意味論を持つならば、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>subject<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の下位セグメント変異体たちは<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Mirror<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の中で見分けがつかないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the elements in an array are instances of a class, the semantics are the same, though they might appear different at first.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列に属する要素らがクラスのインスタンスらであるならば、意味論は同じです、にもかかわらずそれらは最初は異なっているように思うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the given key is found in the dictionary, this method returns an index into the dictionary that corresponds with the key-value pair.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたキーがこの辞書の中に見つかるならば、このメソッドは辞書の中へのあるインデックスを返し、それがそのキー値ペアに対応するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the given key is not present in the dictionary, this method adds the key-value pair and returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたキーがこの辞書の中に存在しないならば、このメソッドはそのキー値ペアを加えて<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the instance passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>object<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is being accessed by multiple threads simultaneously, this function may still return <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>object<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡されるインスタンスが複数のスレッドによって同時にアクセスされる場合、この関数は依然として<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the key is found in the dictionary, this method returns the key’s associated value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーが辞書の中に見つけられるならば、このメソッドはそのキーの結び付けられる値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the key isn’t found in the dictionary, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>remove<ph x="2">&lt;w2/&gt;</ph>Value(for<ph x="3">&lt;w3/&gt;</ph>Key:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> returns <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーがコレクションの中に見つけられないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>remove<ph x="2">&lt;w2/&gt;</ph>Value(for<ph x="3">&lt;w3/&gt;</ph>Key:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最大長がコレクションの要素の数を超えるならば、結果はコレクションの要素すべてを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the maximum length exceeds the number of elements in the collection, the result contains the entire collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最大長がコレクションの要素の数を超えるならば、結果はコレクション全体を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最大長がシーケンスの要素の数を超えるならば、結果はシーケンスの要素すべてを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the memory is bound to a type <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>U<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> that is layout compatible with <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>T<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>, then it contains a value of type <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>U<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリが型<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>U<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>で<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>T<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>とレイアウト互換であるものに束縛されるならば、そのときそれは型<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>U<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>の値を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the memory is bound to type <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>T<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, then it contains values of type <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>T<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリが型<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>T<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に束縛されるならば、そのときそれは型<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>T<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>の値を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the memory is uninitialized, it is still uninitialized after being bound to <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>T<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリが未初期化であるならば、それは<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>T<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>に束縛された後も依然として未初期化です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省かれることになる要素の数がコレクションの要素の数を超えるならば、結果は空の下位シーケンスになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty subsequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>取り除く要素の数がシーケンスの要素数を超えるならば、結果は空の文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the passed instance conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Custom<ph x="9">&lt;w9/&gt;</ph>String<ph x="10">&lt;w10/&gt;</ph>Convertible<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, the <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>String(describing:)<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> initializer and the <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>print(_:)<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> function use the instance’s custom <bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>description<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>渡されたインスタンスが<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Custom<ph x="9">&lt;w9/&gt;</ph>String<ph x="10">&lt;w10/&gt;</ph>Convertible<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に準拠するならば、<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>String(describing:)<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>イニシャライザと<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>print(_:)<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>関数はそのインスタンスのあつらえの<bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>description<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the payload contains any other characters, it is ignored.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ペイロードが何か他の文字を含むならば、それは無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the position passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> doesn’t have an exact corresponding position in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>unicode<ph x="4">&lt;w4/&gt;</ph>Scalars<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of the initializer is <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡された位置がまさにその対応する位置を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>unicode<ph x="4">&lt;w4/&gt;</ph>Scalars<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>において持たないならば、イニシャライザの結果は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the position passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> doesn’t have an exact corresponding position in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of the initializer is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡された位置がまさにその対応する位置を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>において持たないならば、イニシャライザの結果は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the position passed in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> doesn’t have an exact corresponding position in <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>other<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, the result of the initializer is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡された位置がまさにその対応する位置を<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>other<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>において持たないならば、イニシャライザの結果は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the position passed in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> doesn’t have an exact corresponding position in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of the initializer is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡された位置がまさにその対応する位置を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>において持たないならば、イニシャライザの結果は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the position passed in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> doesn’t have an exact corresponding position in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>unicode<ph x="4">&lt;w4/&gt;</ph>Scalars<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of the initializer is <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡された位置がまさにその対応する位置を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>unicode<ph x="4">&lt;w4/&gt;</ph>Scalars<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>において持たないならば、イニシャライザの結果は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the position passed in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> doesn’t have an exact corresponding position in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of the initializer is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡された位置がまさにその対応する位置を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>において持たないならば、イニシャライザの結果は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the position passed in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> doesn’t have an exact corresponding position in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of the initializer is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡された位置がまさにその対応する位置を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>において持たないならば、イニシャライザの結果は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the quotient of dividing <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>dividend<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> by <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is too large to represent in the type, a runtime error may occur.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>dividend<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>で除算した商がこの型で表すのに大きすぎるならば、実行時エラーが起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the sequence has no elements, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ph x="2">&lt;w2/&gt;</ph>Partial<ph x="3">&lt;w3/&gt;</ph>Result<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is never executed and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>initial<ph x="6">&lt;w6/&gt;</ph>Result<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is the result of the call to <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>reduce(_:<ph x="9">&lt;w9/&gt;</ph>_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスが１つも要素を持たないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ph x="2">&lt;w2/&gt;</ph>Partial<ph x="3">&lt;w3/&gt;</ph>Result<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は決して実行されません、そして<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>initial<ph x="6">&lt;w6/&gt;</ph>Result<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>reduce(_:<ph x="9">&lt;w9/&gt;</ph>_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>への呼び出しの結果となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the sequence has no elements, returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスが要素を持たないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the sequence has no elements, returns <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスが要素を持たないならば、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the sequence has no elements, the result is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>initial<ph x="2">&lt;w2/&gt;</ph>Result<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスが１つも要素を持たないならば、結果は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>initial<ph x="2">&lt;w2/&gt;</ph>Result<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the sequence has no elements, the result is an empty subsequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスが１つも要素を持たないならば、結果は空のシーケンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the set already contains one or more elements that are also in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the existing members are kept.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中にもある１つ以上の要素をこの集合がすでに含むならば、既存のメンバはそのままにしておかれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the set is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合が空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the set is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合が空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the set is empty, returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合が空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the set is empty, the value of this property is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合が空であるならば、このプロパティは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the set wraps a bridged <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSSet<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the performance is unspecified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合が、ブリッジされた<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSSet<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>をラップするならば、性能は不特定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the static string stores a single Unicode scalar value, the value of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>ASCII<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is unspecified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>静的文字列が単一のユニコードスカラー値を格納するならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>ASCII<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の値は不特定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the static string stores a single Unicode scalar value, the value of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8Code<ph x="2">&lt;w2/&gt;</ph>Unit<ph x="3">&lt;w3/&gt;</ph>Count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is unspecified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>静的文字列が単一のユニコードスカラー値を格納するならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8Code<ph x="2">&lt;w2/&gt;</ph>Unit<ph x="3">&lt;w3/&gt;</ph>Count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の値は不特定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the string is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列が空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the two ranges do not overlap, the result is a single-element range at the upper or lower bound of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>limits<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの範囲が重ならないならば、結果は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>limits<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の上方または下方での単一要素範囲です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the two ranges do not overlap, the result is an empty range within the bounds of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>limits<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの範囲が重ならないならば、結果は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>limits<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の境界内の空の範囲です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the two sequences passed to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>zip(_:<ph x="2">&lt;w2/&gt;</ph>_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are different lengths, the resulting sequence is the same length as the shorter sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>zip(_:<ph x="2">&lt;w2/&gt;</ph>_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡された２つのシーケンスが異なる長さであるならは、結果のシーケンスはより短いシーケンスと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the type supports subnormal values, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>least<ph x="2">&lt;w2/&gt;</ph>Nonzero<ph x="3">&lt;w3/&gt;</ph>Magnitude<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is smaller than <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>least<ph x="6">&lt;w6/&gt;</ph>Normal<ph x="7">&lt;w7/&gt;</ph>Magnitude<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>; otherwise they are equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その型がサブノーマル値をサポートするならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>least<ph x="2">&lt;w2/&gt;</ph>Nonzero<ph x="3">&lt;w3/&gt;</ph>Magnitude<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>least<ph x="6">&lt;w6/&gt;</ph>Normal<ph x="7">&lt;w7/&gt;</ph>Magnitude<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>より小さいです；そうでなければそれらは等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the underlying collection stored by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not satisfy <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Bidirectional<ph x="4">&lt;w4/&gt;</ph>Collection<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result is <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によって格納される基礎をなすコレクションが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Bidirectional<ph x="4">&lt;w4/&gt;</ph>Collection<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の条件を満たさないならば、結果は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the underlying collection stored by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not satisfy <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Random<ph x="4">&lt;w4/&gt;</ph>Access<ph x="5">&lt;w5/&gt;</ph>Collection<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によって格納される基礎をなすコレクションが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Random<ph x="4">&lt;w4/&gt;</ph>Access<ph x="5">&lt;w5/&gt;</ph>Collection<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の条件を満たさないならば、結果は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value fails to encode anything, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>encoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> will encode an empty keyed container in its place.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値が何かをエンコードに失敗するならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>encoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は空のキー付きコンテナをその場でエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of the operation is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>; if the value is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, the result is <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>true<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、この演算の結果は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です；値が<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>ならば、結果は<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>true<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of an existing key is updated, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>update<ph x="2">&lt;w2/&gt;</ph>Value(_:<ph x="3">&lt;w3/&gt;</ph>for<ph x="4">&lt;w4/&gt;</ph>Key:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> returns the original value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>既存のキーの値が更新されるならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>update<ph x="2">&lt;w2/&gt;</ph>Value(_:<ph x="3">&lt;w3/&gt;</ph>for<ph x="4">&lt;w4/&gt;</ph>Key:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は元の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of the payload is larger than can be stored as the payload of a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Double<ph x="8">&lt;w8/&gt;</ph>.nan<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, the least significant bits are used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ペイロードの値が<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Double<ph x="8">&lt;w8/&gt;</ph>.nan<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>のペイロードとして格納可能であるより大きいならば、最下位ビットが使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of the payload is larger than can be stored as the payload of a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Float80<ph x="8">&lt;w8/&gt;</ph>.nan<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, the least significant bits are used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ペイロードの値が<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Float80<ph x="8">&lt;w8/&gt;</ph>.nan<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>のペイロードとして格納可能であるより大きいならば、最下位ビットが使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of the payload is larger than can be stored as the payload of a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Float<ph x="8">&lt;w8/&gt;</ph>.nan<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, the least significant bits are used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ペイロードの値が<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Float<ph x="8">&lt;w8/&gt;</ph>.nan<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>のペイロードとして格納可能であるより大きいならば、最下位ビットが使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is greater than the maximum representable value in this type, the result is the type’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>max<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡された値がこの型において最大限の表現可能な値より大きいならば、結果はこの型の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>max<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is not representable exactly, the result is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡された値が正確に表現可能でないならば、結果は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is not representable in this type, a runtime error may occur.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡された値がこの型で表現可能でないならば、実行時エラーが起こるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value you pass to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>significand<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is NaN, the result is NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>significand<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡す値がNaNならば、結果はNaNです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value you pass to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>significand<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is zero or infinite, the result is zero or infinite, regardless of the value of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>exponent<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>significand<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡す値がゼロまたは無限大ならば、結果はゼロまたは無限大です、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>exponent<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の値に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If there are additional details about the error that could be helpful for recovery, use associated values to include that information.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>復旧の助けになりうるそのエラーについての追加の詳細があるならば、関連値を使ってその情報を含めてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If there are multiple equal greatest arguments, the result is the last one.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>等しい最大の引数が複数あるならば、結果は最後のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If there are multiple equal least arguments, the result is the first one.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数の最も少ない引数があるならば、結果は最初の１つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If there is no upper limit, then <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>significand<ph x="6">&lt;w6/&gt;</ph>Bit<ph x="7">&lt;w7/&gt;</ph>Count<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> should be <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Int<ph x="10">&lt;w10/&gt;</ph>.max<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上限がないならば、そのとき<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>significand<ph x="6">&lt;w6/&gt;</ph>Bit<ph x="7">&lt;w7/&gt;</ph>Count<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Int<ph x="10">&lt;w10/&gt;</ph>.max<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If there is no value of the type that corresponds with the specified raw value, this initializer returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された生の値に対応する型の値が１つもないならば、このイニシャライザは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this index does not have an exact corresponding position in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>characters<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, this method returns <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスがまさにその対応する位置を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>characters<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>において持たないならば、イニシャライザの結果は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this index does not have an exact corresponding position in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, this method returns <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスがまさにその対応する位置を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>において持たないならば、イニシャライザの結果は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this index does not have an exact corresponding position in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, this method returns <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスがまさにその対応する位置を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>において持たないならば、イニシャライザの結果は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this index does not have an exact corresponding position in <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>unicode<ph x="5">&lt;w5/&gt;</ph>Scalars<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, this method returns <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスがまさにその対応する位置を<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>unicode<ph x="5">&lt;w5/&gt;</ph>Scalars<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>において持たないならば、イニシャライザの結果は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this instance is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, returns <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ならば、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this type has value semantics, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Playground<ph x="2">&lt;w2/&gt;</ph>Quick<ph x="3">&lt;w3/&gt;</ph>Look<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance should be unaffected by subsequent mutations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型が値意味論を持つならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Playground<ph x="2">&lt;w2/&gt;</ph>Quick<ph x="3">&lt;w3/&gt;</ph>Look<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はその後の変化によって影響を受けないべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型が値意味論を持つならば、ミラーはインスタンスのその後の変化によって影響を受けないべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this value and <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are both finite numbers, the truncating remainder has the same sign as this value and is strictly smaller in magnitude than <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が両方とも有限の数ならば、切り捨てられる余りはこの値と同じ符号を持ち、そして厳密に<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>より小さい規模になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this value and <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are finite numbers, the remainder is in the closed range <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-abs(other / 2)...abs(other / 2)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が有限数ならば、あまりは完結範囲<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-abs(other / 2)...abs(other / 2)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の中に入ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this value is a finite nonzero number, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>significand<ph x="2">&lt;w2/&gt;</ph>Width<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is the number of fractional bits required to represent the value of <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>significand<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>; otherwise, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>significand<ph x="7">&lt;w7/&gt;</ph>Width<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is -1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値が有限の非ゼロ数ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>significand<ph x="2">&lt;w2/&gt;</ph>Width<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>significand<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の値を表すのに必要とされる小数部ビットの数です；そうでなければ、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>significand<ph x="7">&lt;w7/&gt;</ph>Width<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は-1です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If two representable values are equally close, the result is the value with more trailing zeros in its significand bit pattern.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの表現可能な値が同等であるくらい近いならば、結果はその仮数ビットパターンにおいてより多く後ろに続くゼロを持つ値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are adding a known number of elements to a collection, use this method to avoid multiple reallocations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが数のわかった要素をコレクションに加えているならば、このメソッドを使って複数の再割り当てを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are adding a known number of elements to a set, use this method to avoid multiple reallocations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが数のわかった要素を集合に加えているならば、このメソッドを使って複数の再割り当てを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are adding a known number of elements to an array, use this method to avoid multiple reallocations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが数のわかった要素を配列に加えているならば、このメソッドを使って複数の再割り当てを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are adding a known number of key-value pairs to a dictionary, use this method to avoid multiple reallocations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが数のわかったキー値ペアを辞書に加えているならば、このメソッドを使って複数の再割り当てを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are not satisfied with the representation supplied for your type by default, you can make it conform to the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Custom<ph x="6">&lt;w6/&gt;</ph>Playground<ph x="7">&lt;w7/&gt;</ph>Quick<ph x="8">&lt;w8/&gt;</ph>Lookable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol and provide a custom <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Playground<ph x="11">&lt;w11/&gt;</ph>Quick<ph x="12">&lt;w12/&gt;</ph>Look<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが初期状態であなたの型に対して提供される表現に満足しないならば、あなたはそれを<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Custom<ph x="6">&lt;w6/&gt;</ph>Playground<ph x="7">&lt;w7/&gt;</ph>Quick<ph x="8">&lt;w8/&gt;</ph>Lookable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルに準拠するようにして、あつらえの<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Playground<ph x="11">&lt;w11/&gt;</ph>Quick<ph x="12">&lt;w12/&gt;</ph>Look<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>インスタンスを提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are sorting strings to present to the end user, use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> APIs that perform localized comparison instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが文字列をソートしてエンドユーザに提供するならば、代わりに<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> APIを使うべきです、それはローカライズされた比較を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are sorting strings to present to the end user, use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> APIs that perform localized comparison.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが文字列をソートしてエンドユーザに提供するならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> APIを使うべきです、それはローカライズされた比較を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are using the memory for a specific type, allocate memory using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<ph x="4">&lt;w4/&gt;</ph>.allocate(capacity:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> static method instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがメモリを特定の型に対して使っているならば、メモリを代わりに<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<ph x="4">&lt;w4/&gt;</ph>.allocate(capacity:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>静的メソッドを使ってアロケートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are writing a collection and mutations need to invalidate indices, don’t use <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Mutable<ph x="7">&lt;w7/&gt;</ph>Slice<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> as its subsequence type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがインデックスを無効にする必要があるあるコレクションや変異体らを書いているならば、それの下位シーケンス型として<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Mutable<ph x="7">&lt;w7/&gt;</ph>Slice<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are writing a collection and mutations need to invalidate indices, don’t use <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Mutable<ph x="8">&lt;w8/&gt;</ph>Bidirectional<ph x="9">&lt;w9/&gt;</ph>Slice<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> as its subsequence type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがインデックスを無効にする必要があるあるコレクションや変異体らを書いているならば、それの下位シーケンス型として<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Mutable<ph x="8">&lt;w8/&gt;</ph>Bidirectional<ph x="9">&lt;w9/&gt;</ph>Slice<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are writing a collection and mutations need to invalidate indices, don’t use <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Mutable<ph x="9">&lt;w9/&gt;</ph>Random<ph x="10">&lt;w10/&gt;</ph>Access<ph x="11">&lt;w11/&gt;</ph>Slice<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> as its subsequence type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがインデックスを無効にする必要があるあるコレクションや変異体らを書いているならば、それの下位シーケンス型として<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Mutable<ph x="9">&lt;w9/&gt;</ph>Random<ph x="10">&lt;w10/&gt;</ph>Access<ph x="11">&lt;w11/&gt;</ph>Slice<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>を使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are writing a collection and mutations need to invalidate indices, don’t use <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Mutable<ph x="9">&lt;w9/&gt;</ph>Range<ph x="10">&lt;w10/&gt;</ph>Replaceable<ph x="11">&lt;w11/&gt;</ph>Slice<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> as its subsequence type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがインデックスを無効にする必要があるあるコレクションや変異体らを書いているならば、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Mutable<ph x="9">&lt;w9/&gt;</ph>Range<ph x="10">&lt;w10/&gt;</ph>Replaceable<ph x="11">&lt;w11/&gt;</ph>Slice<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>をそれの下位シーケンス型として使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are writing a collection and mutations need to invalidate indices, don’t use <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Mutable<ph x="10">&lt;w10/&gt;</ph>Range<ph x="11">&lt;w11/&gt;</ph>Replaceable<ph x="12">&lt;w12/&gt;</ph>Bidirectional<ph x="13">&lt;w13/&gt;</ph>Slice<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> as its subsequence type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがインデックスを無効にする必要があるあるコレクションや変異体らを書いているならば、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Mutable<ph x="10">&lt;w10/&gt;</ph>Range<ph x="11">&lt;w11/&gt;</ph>Replaceable<ph x="12">&lt;w12/&gt;</ph>Bidirectional<ph x="13">&lt;w13/&gt;</ph>Slice<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>をそれの下位シーケンス型として使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are writing a collection and mutations need to invalidate indices, don’t use <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Mutable<ph x="11">&lt;w11/&gt;</ph>Range<ph x="12">&lt;w12/&gt;</ph>Replaceable<ph x="13">&lt;w13/&gt;</ph>Random<ph x="14">&lt;w14/&gt;</ph>Access<ph x="15">&lt;w15/&gt;</ph>Slice<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> as its subsequence type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがインデックスを無効にする必要があるあるコレクションや変異体らを書いているならば、<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Mutable<ph x="11">&lt;w11/&gt;</ph>Range<ph x="12">&lt;w12/&gt;</ph>Replaceable<ph x="13">&lt;w13/&gt;</ph>Random<ph x="14">&lt;w14/&gt;</ph>Access<ph x="15">&lt;w15/&gt;</ph>Slice<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>をそれの下位シーケンス型として使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you assign <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as the value for the given key, the dictionary removes that key and its associated value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが与えられたキーに値として<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を割り当てるならば、辞書はそのキーとそれの結び付けられた値を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you assign <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to an existing key, the key and its associated value are removed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を既存のキーに割り当てるならば、そのキーとそれの関連値は削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you change a reference to an object in one array, only that array has a reference to the new object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある配列におけるあるオブジェクトへの参照を変更するならば、単にその配列が新しいオブジェクトへの参照を持つだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol in order to give a more useful and more efficient interface for sequence and collection operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがそれの要素に繰り返しアクセスを提供できるあつらえのシーケンスを作成しているならば、より実用的でより効率的なインターフェイスをシーケンスおよびコレクション演算に与えるために、それの型が<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するのを確実にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you declare a new operator without specifying a precedence group, it is a member of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Default<ph x="2">&lt;w2/&gt;</ph>Precedence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> precedence group.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが新しい演算子を優先順位グループを指定せずに宣言するならば、それは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Default<ph x="2">&lt;w2/&gt;</ph>Precedence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>優先順位グループのメンバです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you do need to access memory that is bound to one type as a different type, Swift’s pointer types provide type-safe ways to temporarily or permanently change the bound type of the memory, or to load typed instances directly from raw memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある型に束縛されるメモリに異なる型としてアクセスする必要があるならば、Swiftのポインタ型は型安全な方法を提供することで、一時的にまたは永続的にメモリの束縛される型を変更します、または型付インスタンスを直接に生のメモリからロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you have prior knowledge that an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Object<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance has a particular type, you can use the unconditional downcast operator (<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>as!<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Object<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスがある特定の型を持つという事前の知識を持つならば、無条件のダウンキャスト演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>as!<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）を使うことも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you implement a custom data structure backed by an array that grows dynamically, naively calling the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method can lead to worse than expected performance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが動的に増大する配列によって裏打ちされる誂えのデータ構造を実装するならば、無邪気に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを呼び出すと予想される性能よりずっと悪くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you know approximately how many elements you will need to store, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method before appending to the array to avoid intermediate reallocations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのくらい多くの要素をあなたが格納する必要があるかをあなたがおおよそ知っているならば、配列に追加する前に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って中間的な再割り当てを回避するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがコレクションをそれのインデックス全体に反復している間に変化させるならば、ある強い参照はそのコレクションの予期されない複製の原因となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you mutate the collection while iterating over its indices, a strong reference can result in an unexpected copy of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがコレクションをそれのインデックス全体に反復している間に変化させるならば、ある強い参照はそのコレクションの予期しない複製という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが同じ型での逆にされたコレクションを必要とするならば、あなたはコレクションのもつシーケンス基盤のまたはコレクション基盤のイニシャライザを使うことができるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need an array that is preinitialized with a fixed number of default values, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array(repeating:<ph x="2">&lt;w2/&gt;</ph>count:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある固定された数の省略時の値であらかじめ初期化される配列を必要とするならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array(repeating:<ph x="2">&lt;w2/&gt;</ph>count:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need an ordered collection of key-value pairs and don’t need the fast key lookup that <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> provides, see the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Dictionary<ph x="4">&lt;w4/&gt;</ph>Literal<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type for an alternative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが順番付けられたキー値ペアのコレクションを必要とするそして<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が提供する高速な検索を必要としないならば、代わりのものとして<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Dictionary<ph x="4">&lt;w4/&gt;</ph>Literal<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need more control over the capacity of your array, implement your own geometric growth strategy, passing the size you compute to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあなたの配列の容量に関してより制御を必要とするならば、あなた独自の幾何数級的戦略を実装して、あなたが算出する大きさを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to access a specific position in a UTF-16 view, use Swift’s index manipulation methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがUTF-16ビューにおいて特定の位置にアクセスする必要があるならば、Swiftのインデックス操作メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to access the contents of a string as encoded in different Unicode encodings, use one of the string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>utf16<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, or <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>utf8<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある文字列の内容に異なるユニコードエンコーディングでエンコードされたようにアクセスする必要があるならば、その文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>utf16<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、または<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>utf8<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロパティの１つを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to create a range that includes the maximal value of its <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type, see the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Countable<ph x="4">&lt;w4/&gt;</ph>Closed<ph x="5">&lt;w5/&gt;</ph>Range<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがそれの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型の最大の値を含む範囲を作成する必要があるならば、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Countable<ph x="4">&lt;w4/&gt;</ph>Closed<ph x="5">&lt;w5/&gt;</ph>Range<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to iterate over consecutive floating-point values, see the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>stride(from:<ph x="10">&lt;w10/&gt;</ph>to:<ph x="11">&lt;w11/&gt;</ph>by:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが連続した不動小数点値にわたって反復適用していく必要があるならば、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>stride(from:<ph x="10">&lt;w10/&gt;</ph>to:<ph x="11">&lt;w11/&gt;</ph>by:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>関数を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to iterate over consecutive floating-point values, see the <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>stride(from:<ph x="11">&lt;w11/&gt;</ph>through:<ph x="12">&lt;w12/&gt;</ph>by:)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが連続した不動小数点値にわたって反復適用していく必要があるならば、<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>stride(from:<ph x="11">&lt;w11/&gt;</ph>through:<ph x="12">&lt;w12/&gt;</ph>by:)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>関数を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to pass those keys to a method that takes an array, however, use this initializer to convert that list from its type of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Lazy<ph x="4">&lt;w4/&gt;</ph>Map<ph x="5">&lt;w5/&gt;</ph>Collection&lt;Dictionary&lt;String, Int&gt;, Int&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to a simple <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>[String]<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、あなたが配列を取るメソッドにそれらキーを渡す必要があるならば、このイニシャライザを使ってそのリストをそれの型の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Lazy<ph x="4">&lt;w4/&gt;</ph>Map<ph x="5">&lt;w5/&gt;</ph>Collection&lt;Dictionary&lt;String, Int&gt;, Int&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>から単純な<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>[String]<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>へ変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to store a copy of a nontrivial value into memory, or to store a value into memory that contains a nontrivial value, you cannot use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>store<ph x="2">&lt;w2/&gt;</ph>Bytes(of:<ph x="3">&lt;w3/&gt;</ph>to<ph x="4">&lt;w4/&gt;</ph>Byte<ph x="5">&lt;w5/&gt;</ph>Offset:<ph x="6">&lt;w6/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが非自明の値のコピーをメモリに格納する、またはある値を非自明の値を含むメモリに格納する必要がある場合、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>store<ph x="2">&lt;w2/&gt;</ph>Bytes(of:<ph x="3">&lt;w3/&gt;</ph>to<ph x="4">&lt;w4/&gt;</ph>Byte<ph x="5">&lt;w5/&gt;</ph>Offset:<ph x="6">&lt;w6/&gt;</ph>as:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to test whether values are contained within a closed interval bound by floating-point values, see the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Closed<ph x="8">&lt;w8/&gt;</ph>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが、いくつかの値がある完結間隔境界内に含まれるかどうかを、いくつかの浮動小数点値によってテストする必要があるならば、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Closed<ph x="8">&lt;w8/&gt;</ph>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to test whether values are contained within an interval bound by floating-point values, see the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが、いくつかの値がある間隔境界内に含まれるかどうかを、いくつかの浮動小数点値によってテストする必要があるならば、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you pass <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the operation preserves the buffer capacity that the collection has, otherwise the underlying buffer is released.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を渡すならば、演算はそのコレクションが持つバッファ容量を保全します、そうでなければ基礎をなすバッファは解放されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you pass a zero-length range as the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subrange<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter, this method inserts the elements of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Elements<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> at <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>subrange<ph x="7">&lt;w7/&gt;</ph>.start<ph x="8">&lt;w8/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがゼロ長範囲を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subrange<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータとして渡すならば、このメソッドは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>new<ph x="4">&lt;w4/&gt;</ph>Elements<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の要素を<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>subrange<ph x="7">&lt;w7/&gt;</ph>.start<ph x="8">&lt;w8/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>で挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you pass the array’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property as the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> parameter, the new element is appended to the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが配列の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>パラメータとして渡すならば、新しい要素が配列に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you pass the collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property as the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> parameter, the new element is appended to the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>パラメータとして渡すならば、新しい要素がコレクションに追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you pass the collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property as the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> parameter, the new elements are appended to the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>パラメータとして渡すならば、いくらかの新しい要素がコレクションに追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>11<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is overshifted such that all of its bits are set to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>11<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>として使うならば、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は、それのビットのすべてがゼロに設定されるような、オーバーシフトをされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>2<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> as the right-hand-side value in an operation on <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, the shift amount requires no masking.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>2<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を右手側の値として<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に関する演算において使うならば、シフト量はマスクを必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>2<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> as the right-hand-side value in an operation on <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, the value is shifted left by two bits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>2<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>上での演算の右手側の値として使うならば、値は2ビットだけ左にシフトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>2<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> as the right-hand-side value in an operation on <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, the value is shifted right by two bits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>2<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>上での演算の右手側の値として使うならば、値は2ビットだけ右にシフトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you will be adding a known number of elements to a collection, use this method to avoid multiple reallocations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが数のわかった要素をコレクションに加えることになっているならば、このメソッドを使って複数の再割り当てを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If your array’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type is a class or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>@objc<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol and you do not need to bridge the array to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>NSArray<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> or pass the array to Objective-C APIs, using <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Contiguous<ph x="8">&lt;w8/&gt;</ph>Array<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> may be more efficient and have more predictable performance than <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Array<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの配列の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型がクラスまたは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>@objc<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルで、あなたがその配列を<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>NSArray<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>にブリッジしたりその配列をObjective-C APIに渡したりする必要がないならば、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Contiguous<ph x="8">&lt;w8/&gt;</ph>Array<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を使うことは<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Array<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>よりもより効率的でありそしてより予測どおりの性能を持つでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If your sequence might have duplicate keys, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary(_:<ph x="2">&lt;w2/&gt;</ph>uniquing<ph x="3">&lt;w3/&gt;</ph>Keys<ph x="4">&lt;w4/&gt;</ph>With:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのシーケンスが重複するキーを持つかもしれないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary(_:<ph x="2">&lt;w2/&gt;</ph>uniquing<ph x="3">&lt;w3/&gt;</ph>Keys<ph x="4">&lt;w4/&gt;</ph>With:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you’re sure of the dynamic type of <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>obj<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>, you can call <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>get<ph x="20">&lt;w20/&gt;</ph>Integer<ph x="21">&lt;w21/&gt;</ph>Value()<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> directly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>obj<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>の動的型に確信を持つならば、あなたは<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>get<ph x="20">&lt;w20/&gt;</ph>Integer<ph x="21">&lt;w21/&gt;</ph>Value()<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>を直接に呼び出すこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you’re writing a hash function for a custom type, choose a hashing algorithm that is appropriate for kinds of data your type comprises.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあつらえの型に対してハッシュ関数を書いているならば、あなたの型が構成されているデータの種類に適切なハッシュ化アルゴリズムを選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Ill-formed sequences are replaced with the Unicode replacement character (<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>"\u{FFFD}"<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>誤形式シーケンスは、ユニコード代替文字（<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>"\u{FFFD}"<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>）で置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Imagine you have a set of temperature data for which you need to report some general statistics: the total number of observations, the number of valid observations, and the average temperature.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが幾つかの一般統計：観測総数、有効観測数、そして平均温度を報告しなければならない一揃いの温度データを持つと想像してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Implementing an iterator that conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Iterator<ph x="2">&lt;w2/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is simple.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Iterator<ph x="2">&lt;w2/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するイテレータを実装するのは簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Implicit Casting and Bridging</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的なキャストとブリッジ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Important</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>重要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In -O builds, has no effect.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>-Oビルドでは、影響はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In -Ounchecked builds, the optimizer may assume that this function is never called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>-Ouncheckedビルドでは、最適化はこの関数が決して呼ばれないと決めてかかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-O<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> builds (the default for Xcode’s Release configuration), <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>condition<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is not evaluated, and there are no effects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-O<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビルド（省略時のXcodeのRelease構成）では、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>condition<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は評価されません、そして影響はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-O<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> builds (the default for Xcode’s Release configuration), stops program execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-O<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビルド（XcodeのRelease構成の初期設定）では、プログラム実行を停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-O<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> builds (the default for Xcode’s Release configuration): If <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>condition<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> evaluates to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, stop program execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-O<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビルド（省略時のXcodeのRelease構成）では：<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>condition<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に評価されるならば、プログラム実行を止めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-Ounchecked<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> builds, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>condition<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is not evaluated, but the optimizer may assume that it <bpt i="4" x="4">&lt;e4&gt;</bpt>always<ept i="4">&lt;/e4&gt;</ept> evaluates to <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>true<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-Ounchecked<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビルドにおいて、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>condition<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は評価されません、しかし最適化は、それが<bpt i="4" x="4">&lt;e4&gt;</bpt>常に<ept i="4">&lt;/e4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>true<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に評価されると決めてかかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-Ounchecked<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> builds, the optimizer may assume that this function is never called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-Ounchecked<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビルドでは、最適化はこの関数が決して呼ばれないと決めてかかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, <bpt i="0" x="0">&lt;e0&gt;</bpt>reachability<ept i="0">&lt;/e0&gt;</ept> refers to the ability to produce one value from the other through zero or more applications of <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>index(after:)<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftでは、<bpt i="0" x="0">&lt;e0&gt;</bpt>到達可能性 reachability<ept i="0">&lt;/e0&gt;</ept>は、ゼロ以上の<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>index(after:)<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の適用を通して、ある値を別のものから生み出す能力のことを言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, every string provides a view of its contents as characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftでは、あらゆる文字列はそれの内容のビューを文字列として提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, only class instances and metatypes have unique identities.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftでは、クラスインスタンスとメタタイプだけが固有な識別子を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ph x="2">&lt;w2/&gt;</ph>Of<ph x="3">&lt;w3/&gt;</ph>One<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>end<ph x="6">&lt;w6/&gt;</ph>Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is always identical to <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>index(after: start<ph x="9">&lt;w9/&gt;</ph>Index)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ph x="2">&lt;w2/&gt;</ph>Of<ph x="3">&lt;w3/&gt;</ph>One<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスにおいて、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>end<ph x="6">&lt;w6/&gt;</ph>Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は常に<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>index(after: start<ph x="9">&lt;w9/&gt;</ph>Index)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>と同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Zip2Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance, the elements of the <bpt i="2" x="2">&lt;e2&gt;</bpt>i<ept i="2">&lt;/e2&gt;</ept>th pair are the <bpt i="3" x="3">&lt;e3&gt;</bpt>i<ept i="3">&lt;/e3&gt;</ept>th elements of each underlying sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Zip2Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスにおいて、<bpt i="2" x="2">&lt;e2&gt;</bpt>i<ept i="2">&lt;/e2&gt;</ept>番目の対に属する要素らは、基盤となるシーケンスそれぞれの<bpt i="3" x="3">&lt;e3&gt;</bpt>i<ept i="3">&lt;/e3&gt;</ept>番目の要素です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a case like this, where a generic parameter <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is bound to a protocol <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>P<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, the type parameter is not statically known to be a protocol type in the body of the generic function, so <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>type(of:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> can only produce the concrete metatype <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>P<ph x="10">&lt;w10/&gt;</ph>.Protocol<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このような場合において、総称体パラメータ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>がプロトコル<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>P<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に束縛されるところでは、その型パラメータは、プロトコル型であることを総称体関数の本文において静的に知られません、それで<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>type(of:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は具象メタタイプ<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>P<ph x="10">&lt;w10/&gt;</ph>.Protocol<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を生み出すことだけ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a collection, the subsequence should also conform to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Collection<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコレクションにおいて、下位シーケンスはまた<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Collection<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a mutable <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance, you can modify in place a value that you’ve accessed through a keyed subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスでは、あなたがキーによる添え字を通してアクセスしたある値をその場で修正できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to changing the value of an individual element, you can also change the values of a slice of elements in a mutable collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある一個の要素の値を変えることに加えて、あなたはまた可変コレクションの要素のスライスに属するいくらかの値を変更することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to creating a character from a single-character string literal, you can also convert a unicode scalar value or single-character string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字を単一文字文字列リテラルから作成することに加えて、あなたはまた、あるユニコードスカラー値や単一文字文字列を変換できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to creating a string from a single string literal, you can also create an empty string, a string containing an existing group of characters, or a string repeating the contents of another string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単独の文字列リテラルから文字列を作成することに加えて、あなたはまた、空の文字列、既存のいくつかの文字からなるグループを含んでいる文字列、または別の文字列の内容を繰り返している文字列を作成できます、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to its collection interface, an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Buffer<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance also supports the following methods provided by <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Unsafe<ph x="8">&lt;w8/&gt;</ph>Mutable<ph x="9">&lt;w9/&gt;</ph>Raw<ph x="10">&lt;w10/&gt;</ph>Pointer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, including bounds checks in debug mode:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それのコレクションインターフェイスに加えて、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Buffer<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスはまた、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Unsafe<ph x="8">&lt;w8/&gt;</ph>Mutable<ph x="9">&lt;w9/&gt;</ph>Raw<ph x="10">&lt;w10/&gt;</ph>Pointer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>によって提供される以下のメソッドをサポートし、デバッグモードにおける境界検査を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to its collection interface, an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance also supports the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>load(from<ph x="7">&lt;w7/&gt;</ph>Byte<ph x="8">&lt;w8/&gt;</ph>Offset:<ph x="9">&lt;w9/&gt;</ph>as:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> method provided by <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Unsafe<ph x="12">&lt;w12/&gt;</ph>Raw<ph x="13">&lt;w13/&gt;</ph>Pointer<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>, including bounds checks in debug mode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それのコレクションインターフェイスに加えて、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスはまた、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>load(from<ph x="7">&lt;w7/&gt;</ph>Byte<ph x="8">&lt;w8/&gt;</ph>Offset:<ph x="9">&lt;w9/&gt;</ph>as:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>メソッドを<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Unsafe<ph x="12">&lt;w12/&gt;</ph>Raw<ph x="13">&lt;w13/&gt;</ph>Pointer<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>によって提供されてサポートし、デバッグモードにおける境界検査を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to representing specific numbers, floating-point types also have special values for working with overflow and nonnumeric results of calculation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特定の数を表すことに加えて、浮動小数点型はまた、オーバーフローおよび非数の計算結果で使うための特別な値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type’s set operations, you can use any nonmutating sequence or collection methods with a set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型の持つ集合演算に加えて、あなたはあらゆる非可変のシーケンスまたはコレクションメソッドを集合で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to the methods that collections inherit from the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, you gain access to methods that depend on accessing an element at a specific position when using a collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルから継承するメソッドに加えて、あなたは、コレクション使用時に特定の位置での要素へのアクセスを当てにするメソッドへのアクセスを手に入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to using a dictionary literal, you can also create a dictionary using these initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書リテラルを使うことに加えて、あなたはまた辞書をこれらのイニシャライザを使って作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to using an array literal, you can also create a set using these initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列リテラルを使うことに加えて、あなたはまた集合をこれらのイニシャライザを使って作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to using an array literal, you can also create an array using these initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列リテラルを使うことに加えて、あなたはまた配列をこれらのイニシャライザを使って作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, because <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>abs(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> always returns a value of the same type, even in a generic context, using the function instead of the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>magnitude<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> property is encouraged.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加えて、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>abs(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は常に同じ型の値を返すことから、総称体の文脈においてさえも、この関数を<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>magnitude<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロパティの代わりに使うことは推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, because <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Integer<ph x="7">&lt;w7/&gt;</ph>Ref<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> conforms to the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Equatable<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> protocol, instances can also be compared using the equal-to operator (<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>==<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加えて、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Integer<ph x="7">&lt;w7/&gt;</ph>Ref<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Equatable<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロトコルに準拠することから、インスタンスはまた同等性演算子（<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>==<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>）を使って比較されることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, bidirectional collections have more efficient implementations of some sequence and collection methods, such as <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>suffix(_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらに加えて、二方向性のコレクションはいくらかのシーケンスおよびコレクションメソッドのもっと手際の良い実装を持ちます、例えば<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>suffix(_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, the following conditions must hold:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加えて、以下の条件が保持されなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, there are two other edge cases:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加えて、２つの別の境界事例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In an empty UTF-16 view, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空のUTF-16ビューにおいて、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In an empty UTF-8 view, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空のUTF-8ビューにおいて、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In an empty Unicode scalars view, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空のユニコードスカラービューにおいて、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In an empty character view, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の文字ビューにおいて、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In an empty character view, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の文字ビューにおいて、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In an empty collection, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index == end<ph x="3">&lt;w3/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空のコレクションでは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index == end<ph x="3">&lt;w3/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In an empty range, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lower<ph x="2">&lt;w2/&gt;</ph>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>upper<ph x="5">&lt;w5/&gt;</ph>Bound<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の範囲では、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lower<ph x="2">&lt;w2/&gt;</ph>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>upper<ph x="5">&lt;w5/&gt;</ph>Bound<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In an empty range, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>upper<ph x="2">&lt;w2/&gt;</ph>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>lower<ph x="5">&lt;w5/&gt;</ph>Bound<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の範囲では、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>upper<ph x="2">&lt;w2/&gt;</ph>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>lower<ph x="5">&lt;w5/&gt;</ph>Bound<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In an empty string, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列が空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In an empty string, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の文字列において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In case an invalid input value, nil is returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無効な入力値の場合、nilが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In case of an invalid input value, nil is returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無効な入力値の場合には、nilが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In case of an invalid unicode scalar value, nil is returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無効なユニコードスカラー値の場合には、nilが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In cases like this, the simplest fix is often to simply remove the call to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, and let the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>append(_:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method grow the array for you.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このような場合に、最も簡単な修正はしばしば単純に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の呼出しを取り除いて、そして<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>append(_:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドがあなたの代わりの配列を成長させるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In code, the absence of a value is typically written using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> literal rather than the explicit <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.none<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> enumeration case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コードにおいて、ある値の不在は一般的に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>リテラルを使って書かれます、明示的な<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.none<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>列挙ケース節ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In debug builds (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-Onone<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>), the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>unsafely<ph x="4">&lt;w4/&gt;</ph>Unwrapped<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property has the same behavior as using the postfix <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>!<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> operator and triggers a runtime error if the instance is <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デバッグビルド（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-Onone<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）において、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>unsafely<ph x="4">&lt;w4/&gt;</ph>Unwrapped<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティは後置<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>!<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>演算子を使うのと同じ挙動を持ち、そしてインスタンスが<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>ならば実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In fact, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>s<ph x="2">&lt;w2/&gt;</ph>.flat<ph x="3">&lt;w3/&gt;</ph>Map(transform)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>  is equivalent to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Array(s<ph x="6">&lt;w6/&gt;</ph>.map(transform).joined())<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実際のところ、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>s<ph x="2">&lt;w2/&gt;</ph>.flat<ph x="3">&lt;w3/&gt;</ph>Map(transform)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Array(s<ph x="6">&lt;w6/&gt;</ph>.map(transform).joined())<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In general, though, the observability of such mutations is unspecified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一般には、けれども、そのような変異体の識別性は指定されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In most cases, it’s best to ignore this protocol and use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bidirectional<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol instead, because it has a more complete interface.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの場合において、このプロトコルを無視して代わりに<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bidirectional<ph x="2">&lt;w2/&gt;</ph>Collection<ph x="3">&lt;w3/&gt;</ph>Type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使うことが最良です、それがより完全なインターフェースを持つので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In most cases, it’s best to ignore this protocol and use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol instead, because it has a more complete interface.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの場合には、このプロトコルを無視して、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルを代わりに使うのが最良です、なぜならそれがより完全なインターフェイスを持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In most cases, it’s best to ignore this protocol and use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol instead, because it has a more complete interface.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの場合には、このプロトコルを無視して、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルを代わりに使うのが最良です、なぜならそれがより完全なインターフェイスを持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In most cases, it’s best to ignore this protocol and use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Random<ph x="2">&lt;w2/&gt;</ph>Access<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol instead, because it has a more complete interface.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの場合には、このプロトコルを無視して、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Random<ph x="2">&lt;w2/&gt;</ph>Access<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルを代わりに使うのが最良です、なぜならそれがより完全なインターフェイスを持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In most cases, it’s best to ignore this protocol and use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol instead, because it has a more complete interface.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの場合には、このプロトコルを無視して、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルを代わりに使うのが最良です、なぜならそれがより完全なインターフェイスを持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In most cases, you should use the equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to test whether two instances are equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの場合、あなたは同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って２つのインスタンスが等しいかどうかをテストするべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In other languages, similar data types are known as hashes or associated arrays.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の言語では、同じようなデータ型はハッシュまたは連想配列として知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In other words, for ordinary collections <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>c<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> having bidirectional indices:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>言い換えると、二方向性のインデックスを持つ通常のコレクション<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>c<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In other words, for ordinary collections <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>c<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>言い換えれば、よくあるコレクション<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>c<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In other words, for ordinary sequences <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>s<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>言い換えれば、よくあるシーケンス <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>s<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In other words, initializing the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant in the example above using string interpolation is equivalent to the following code:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>言い換えれば、文字列補間を使う上の例での<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数の初期化は、以下のコードと等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;T&gt;.size<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, when <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>T<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is a class type, is the same regardless of how many stored properties <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>T<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> has.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;T&gt;.size<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>T<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>がクラス型の時、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>T<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>がどのくらい多くのプロパティを格納しているかに関係なく同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>x<ph x="9">&lt;w9/&gt;</ph>.sign == .minus<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> if <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>x<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> is -0, and while <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>x &lt; 0<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> is always <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>false<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> if <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>x<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> is NaN, <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>x<ph x="20">&lt;w20/&gt;</ph>.sign<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> could be either <bpt i="21" x="21">&lt;c21&gt;</bpt><bpt i="22" x="22">&lt;s22&gt;</bpt>.plus<ept i="22">&lt;/s22&gt;</ept><ept i="21">&lt;/c21&gt;</ept> or <bpt i="23" x="23">&lt;c23&gt;</bpt><bpt i="24" x="24">&lt;s24&gt;</bpt>.minus<ept i="24">&lt;/s24&gt;</ept><ept i="23">&lt;/c23&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とりわけ、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>x<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>が-0ならば<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>x<ph x="9">&lt;w9/&gt;</ph>.sign == .minus<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>、一方で<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>x<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>がNaNならば、<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>x<ph x="20">&lt;w20/&gt;</ph>.sign<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>が<bpt i="21" x="21">&lt;c21&gt;</bpt><bpt i="22" x="22">&lt;s22&gt;</bpt>.plus<ept i="22">&lt;/s22&gt;</ept><ept i="21">&lt;/c21&gt;</ept>または<bpt i="23" x="23">&lt;c23&gt;</bpt><bpt i="24" x="24">&lt;s24&gt;</bpt>.minus<ept i="24">&lt;/s24&gt;</ept><ept i="23">&lt;/c23&gt;</ept>のどちらでも、<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>x &lt; 0<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>は常に<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>false<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, because <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>cafe<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> was declared using the decomposed form of the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>"é"<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> character, <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>unicode<ph x="11">&lt;w11/&gt;</ph>Scalars<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> contains the code points for both the letter <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>"e"<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> (101) and the accent character <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>"´"<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> (769).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とりわけ、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>cafe<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は分解形式の<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>"é"<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>文字を使って宣言されたことから、<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>unicode<ph x="11">&lt;w11/&gt;</ph>Scalars<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>は字<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>"e"<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>（101）とアクセント文字<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>"´"<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>（769）両方のコード点を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, do not use implicit bridging when calling an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とりわけ、暗黙的ブリッジを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを呼ぶ時に使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, do not use implicit bridging when calling an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とりわけ、暗黙的ブリッジを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを呼ぶ時に使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, do not use implicit bridging when calling an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とりわけ、暗黙的ブリッジを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを呼ぶ時に使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, do not use implicit bridging when calling an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とりわけ、暗黙的ブリッジを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを呼ぶ時に使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, in -O builds, no test is performed to ensure that <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> actually has dynamic type <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に、-Oビルドでは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が実際に動的型<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を持つことを請け合う目的でテストは実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とりわけ、符号付きの、固定長整数型の最小値を負にすることは、表現できない値という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, note that <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>j<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the index of the second day with absences, was found in a slice of the original array and then used to access a value in the original <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>absences<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> array itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に、欠席者のいる第２の日付のインデックス、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>j<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が、オリジナル配列のひとつのスライス上で捜されて、それから値のアクセスのためにオリジナルの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>absences<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>配列自身において使われる点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, passing NaN as <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>other<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> always results in <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>nil<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とりわけ、NaNを<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>other<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>として渡すことは常に<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>nil<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>の結果となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, pointers and class instances all have the same contiguous memory footprint, regardless of the size of the referenced data.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に、ポインタおよびクラスインスタンスは、すべて同じ隣接メモリフットプリントを持ちます、参照されたデータの大きさに関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, that slice, unlike an array, may have a nonzero <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and an <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>end<ph x="8">&lt;w8/&gt;</ph>Index<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> that is not equal to <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>count<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に、そのスライスは、配列と違い、非ゼロの<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>count<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>に等しくない<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>end<ph x="8">&lt;w8/&gt;</ph>Index<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を持つかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, the absolute value of a signed, fixed-width integer type’s minimum cannot be represented.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とりわけ、符号付きの、固定長整数型の最小数の絶対値は、表現することは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, the names <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>"Alicia"<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>, <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>"Chris"<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>, and <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>"Diana"<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> are removed from <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>employees<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> while the name <bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>"Forlani"<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept> is added.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>個別的には、名前<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>"Alicia"<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>、<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>"Chris"<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>、そして<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>"Diana"<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>は、<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>employees<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>から削除される一方で名前<bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>"Forlani"<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept>は加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, the names <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>"Alicia"<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>, <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>"Chris"<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>, and <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>"Diana"<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> are removed from <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>employees<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> while the names <bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>"Forlani"<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept> and <bpt i="22" x="22">&lt;c22&gt;</bpt><bpt i="23" x="23">&lt;s23&gt;</bpt>"Greta"<ept i="23">&lt;/s23&gt;</ept><ept i="22">&lt;/c22&gt;</ept> are added.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>個別的には、名前<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>"Alicia"<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>、<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>"Chris"<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>、そして<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>"Diana"<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>は、<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>employees<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>から削除される一方で名前<bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>"Forlani"<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept>と<bpt i="22" x="22">&lt;c22&gt;</bpt><bpt i="23" x="23">&lt;s23&gt;</bpt>"Greta"<ept i="23">&lt;/s23&gt;</ept><ept i="22">&lt;/c22&gt;</ept>は加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, the names <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>"Bethany"<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> and <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>"Eric"<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> do not appear in <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>either<ph x="20">&lt;w20/&gt;</ph>Neighbors<ph x="21">&lt;w21/&gt;</ph>Or<ph x="22">&lt;w22/&gt;</ph>Employees<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>個別的には、名前<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>"Bethany"<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>と<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>"Eric"<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>は、<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>either<ph x="20">&lt;w20/&gt;</ph>Neighbors<ph x="21">&lt;w21/&gt;</ph>Or<ph x="22">&lt;w22/&gt;</ph>Employees<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>の中に現れません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, the names <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"Alicia"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>"Chris"<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>"Diana"<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> are removed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>個別的には、名前<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"Alicia"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>"Chris"<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>"Diana"<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>は、削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, the names <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"Bethany"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>"Eric"<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> are removed from <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>employees<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>個別的には、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"Bethany"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>"Eric"<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>が<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>employees<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>から削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, this discussion mentions <bpt i="1" x="1">&lt;a1&gt;</bpt>extended grapheme clusters<ept i="1">&lt;/a1&gt;</ept> and <bpt i="2" x="2">&lt;a2&gt;</bpt>Unicode scalar values<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とりわけ、この解説は<bpt i="1" x="1">&lt;a1&gt;</bpt>拡張書記素クラスタ<ept i="1">&lt;/a1&gt;</ept>と<bpt i="2" x="2">&lt;a2&gt;</bpt>ユニコードスカラー値<ept i="2">&lt;/a2&gt;</ept>について言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, this discussion mentions <bpt i="1" x="1">&lt;a1&gt;</bpt>extended grapheme clusters<ept i="1">&lt;/a1&gt;</ept>, <bpt i="2" x="2">&lt;a2&gt;</bpt>Unicode scalar values<ept i="2">&lt;/a2&gt;</ept>, and <bpt i="3" x="3">&lt;a3&gt;</bpt>canonical equivalence<ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とりわけ、この解説は<bpt i="1" x="1">&lt;a1&gt;</bpt>拡張書記素クラスタ<ept i="1">&lt;/a1&gt;</ept>、<bpt i="2" x="2">&lt;a2&gt;</bpt>ユニコードスカラー値<ept i="2">&lt;/a2&gt;</ept>、そして<bpt i="3" x="3">&lt;a3&gt;</bpt>正準等価<ept i="3">&lt;/a3&gt;</ept>について言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, to find the value matching a key, you must search through every element of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に、あるキーに合った値を見つけるには、あなたはコレクションのすべての要素を通して検索しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In playgrounds and -Onone builds (the default for Xcode’s Debug configuration), stop program execution in a debuggable state after printing <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレイグラウンドおよび-Ononeビルド（省略時のXcodeのDebug構成）では、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を出力した後にデバッグ可能状態でプログラム実行を停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In playgrounds and <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-Onone<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> builds (the default for Xcode’s Debug configuration), stops program execution in a debuggable state after printing <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>message<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレイグラウンドおよび<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-Onone<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビルド（XcodeのDebug構成の初期設定）では、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>message<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を出力した後デバッグ可能な状態でプログラム実行を停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In playgrounds and <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-Onone<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> builds (the default for Xcode’s Debug configuration): If <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>condition<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> evaluates to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, stop program execution in a debuggable state after printing <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>message<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレイグラウンドおよび<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-Onone<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビルド（省略時のXcodeのDebug構成）において：<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>condition<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に評価されるならば、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>message<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を出力した後にデバッグ可能状態でプログラム実行を停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In short, this function is suitable for exploring the structure of a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Mirror<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> in a REPL or playground, but don’t expect it to be efficient.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>短くいえば、この関数はREPLやプレイグラウンドにおける<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Mirror<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の構造体の探索に適します、しかしそれが効率的であるのを期待できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In some cases, <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>old<ph x="20">&lt;w20/&gt;</ph>Member<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> may be distinguishable from <bpt i="21" x="21">&lt;c21&gt;</bpt><bpt i="22" x="22">&lt;s22&gt;</bpt>new<ph x="23">&lt;w23/&gt;</ph>Member<ept i="22">&lt;/s22&gt;</ept><ept i="21">&lt;/c21&gt;</ept> by identity comparison or some other means.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの場合には、<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>old<ph x="20">&lt;w20/&gt;</ph>Member<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>は同一性比較または何らかの他の意味で<bpt i="21" x="21">&lt;c21&gt;</bpt><bpt i="22" x="22">&lt;s22&gt;</bpt>new<ph x="23">&lt;w23/&gt;</ph>Member<ept i="22">&lt;/s22&gt;</ept><ept i="21">&lt;/c21&gt;</ept>から区別可能であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In some cases, a returned element may be distinguishable from <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>new<ph x="8">&lt;w8/&gt;</ph>Member<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> by identity comparison or some other means.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの場合には、ある返される要素は、同一性比較または何らかの他の意味で<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>new<ph x="8">&lt;w8/&gt;</ph>Member<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>から区別可能であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In some cases, the returned element may be distinguishable from <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>new<ph x="7">&lt;w7/&gt;</ph>Member<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> by identity comparison or some other means.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの場合には、返される要素は、同一性比較または何らかの他の意味で<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>new<ph x="7">&lt;w7/&gt;</ph>Member<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>から区別可能であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In some uses, such as in a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>class<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> initializer, you may find that the language rules do not allow you to use <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>with<ph x="9">&lt;w9/&gt;</ph>Va<ph x="10">&lt;w10/&gt;</ph>List(_:<ph x="11">&lt;w11/&gt;</ph>_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> as intended.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくらの利用では、例えば<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>class<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>でのように、あなたは言語規則があなたに<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>with<ph x="9">&lt;w9/&gt;</ph>Va<ph x="10">&lt;w10/&gt;</ph>List(_:<ph x="11">&lt;w11/&gt;</ph>_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>を意図したように利用させないのを発見するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In that case, a string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view contains more elements than the string itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その場合には、文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューは、その文字列それ自体より多くの要素を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In that case, the method returns <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その場合には、このメソッドは<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Zip2Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance returned by this function, the elements of the <bpt i="2" x="2">&lt;e2&gt;</bpt>i<ept i="2">&lt;/e2&gt;</ept>th pair are the <bpt i="3" x="3">&lt;e3&gt;</bpt>i<ept i="3">&lt;/e3&gt;</ept>th elements of each underlying sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数によって返される<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Zip2Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスにおいて、<bpt i="2" x="2">&lt;e2&gt;</bpt>i<ept i="2">&lt;/e2&gt;</ept>番目の対の要素らは、基盤となる各シーケンスの<bpt i="3" x="3">&lt;e3&gt;</bpt>i<ept i="3">&lt;/e3&gt;</ept>番目の要素らです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the case of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Directions<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> option set, an instance can contain zero, one, or more of the four defined directions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Directions<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>オプションセットの場合では、あるインスタンスは４つ定義された方向のうちゼロ、１つ、またはそれ以上を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the encoded representation of a Unicode scalar value, each UTF-8 code unit after the first is called a <bpt i="0" x="0">&lt;e0&gt;</bpt>continuation byte<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるユニコードスカラー値の符号化された表現において、最初のものの後の各UTF-8コード単位は、<bpt i="0" x="0">&lt;e0&gt;</bpt>継続バイト<ept i="0">&lt;/e0&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>more<ph x="2">&lt;w2/&gt;</ph>Numbers<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has the same type as <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>numbers<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, which is <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>[Int]<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>more<ph x="2">&lt;w2/&gt;</ph>Numbers<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>numbers<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と同じ型を持ちます、それは<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>[Int]<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>first<ph x="7">&lt;w7/&gt;</ph>Space<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is used to extract the prefix that contains elements up to that index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例において、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>first<ph x="7">&lt;w7/&gt;</ph>Space<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は、そのインデックスまでの要素を含んでいる前の部分を抜き取るために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array is created along with two copies that share the same storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列は２つのコピーと連れだって作成されます、それは同じストレージを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>obj<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has a static type of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Any<ph x="4">&lt;w4/&gt;</ph>Object<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and a dynamic type of <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Integer<ph x="7">&lt;w7/&gt;</ph>Ref<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>obj<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Any<ph x="4">&lt;w4/&gt;</ph>Object<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の静的型と<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Integer<ph x="7">&lt;w7/&gt;</ph>Ref<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の動的型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example, because the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>express<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> static property is assigned an array literal with the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>next<ph x="4">&lt;w4/&gt;</ph>Day<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>second<ph x="7">&lt;w7/&gt;</ph>Day<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> options, it will contain those two elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>express<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>静的プロパティは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>next<ph x="4">&lt;w4/&gt;</ph>Day<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>second<ph x="7">&lt;w7/&gt;</ph>Day<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>オプションを持つ配列リテラルを割り当てられるので、それはそれら２つの要素を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following code, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> variable has the same static and dynamic type: <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のコードにおいて、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>変数は同じ静的および動的型：<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>ptr<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is a pointer to memory initialized with a value of <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>23<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>ptr<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>23<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の値で初期化されるメモリに対するポインタです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>y<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>y<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>はNaNです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, a new element is inserted into <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>class<ph x="5">&lt;w5/&gt;</ph>Days<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, a set of days of the week.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、新しい要素が、一揃いの曜日<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>class<ph x="5">&lt;w5/&gt;</ph>Days<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>へ挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例において、数からなる配列は、30より大きな要素に合致するという述部によって仕切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>ascii<ph x="2">&lt;w2/&gt;</ph>Table<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> sequence is made by zipping together the characters in the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>alphabet<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> string with a partial range starting at 65, the ASCII value of the capital letter A. Iterating over two zipped sequence continues only as long as the shorter of the two sequences, so the iteration stops at the end of <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>alphabet<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>ascii<ph x="2">&lt;w2/&gt;</ph>Table<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>シーケンスは、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>alphabet<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>文字列中の文字を65で始まるある部分範囲と一緒に閉じ合わせることによって作られます。２つの閉じ合わされたシーケンスに反復することは、より短いほうと同じだけ続きます、それでこの反復は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>alphabet<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の終わりで停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>ascii<ph x="2">&lt;w2/&gt;</ph>Table<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> sequence is made by zipping together the characters in the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>alphabet<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> string with a partial range starting at 65, the ASCII value of the capital letter A. Iterating over two zipped sequences continues only as long as the shorter of the two sequences, so the iteration stops at the end of <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>alphabet<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>ascii<ph x="2">&lt;w2/&gt;</ph>Table<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>シーケンスは、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>alphabet<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>文字列中の文字を65で始まるある部分範囲と一緒に閉じ合わせることによって作られます。２つの閉じ合わされたシーケンスそれらに反復することは、より短いほうと同じだけ続きます、それでこの反復は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>alphabet<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の終わりで停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>attendees<ph x="2">&lt;w2/&gt;</ph>And<ph x="3">&lt;w3/&gt;</ph>Visitors<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set is made up of the elements of the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>attendees<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>visitors<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> sets:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>attendees<ph x="2">&lt;w2/&gt;</ph>And<ph x="3">&lt;w3/&gt;</ph>Visitors<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>attendees<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>visitors<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>集合の要素から作り上げられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>attendees<ph x="2">&lt;w2/&gt;</ph>And<ph x="3">&lt;w3/&gt;</ph>Visitors<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set is made up of the elements of the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>attendees<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> set and the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>visitors<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> array:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>attendees<ph x="2">&lt;w2/&gt;</ph>And<ph x="3">&lt;w3/&gt;</ph>Visitors<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>attendees<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>集合と<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>visitors<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>配列の要素から作り上げられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>both<ph x="2">&lt;w2/&gt;</ph>Neighbors<ph x="3">&lt;w3/&gt;</ph>And<ph x="4">&lt;w4/&gt;</ph>Employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set is made up of the elements that are in <bpt i="5" x="5">&lt;e5&gt;</bpt>both<ept i="5">&lt;/e5&gt;</ept> the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>employees<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> and <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>neighbors<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> sets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>both<ph x="2">&lt;w2/&gt;</ph>Neighbors<ph x="3">&lt;w3/&gt;</ph>And<ph x="4">&lt;w4/&gt;</ph>Employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>employees<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>と<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>neighbors<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>集合の<bpt i="5" x="5">&lt;e5&gt;</bpt>両方<ept i="5">&lt;/e5&gt;</ept>にある要素から作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>either<ph x="2">&lt;w2/&gt;</ph>Neighbors<ph x="3">&lt;w3/&gt;</ph>Or<ph x="4">&lt;w4/&gt;</ph>Employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set is made up of the elements of the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>employees<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>neighbors<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> sets that are not in both <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>employees<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> <bpt i="11" x="11">&lt;e11&gt;</bpt>and<ept i="11">&lt;/e11&gt;</ept> <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>neighbors<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>either<ph x="2">&lt;w2/&gt;</ph>Neighbors<ph x="3">&lt;w3/&gt;</ph>Or<ph x="4">&lt;w4/&gt;</ph>Employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>employees<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>と<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>neighbors<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>集合の要素で、<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>employees<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept><bpt i="11" x="11">&lt;e11&gt;</bpt>および<ept i="11">&lt;/e11&gt;</ept><bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>neighbors<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>の両方の中にはないものから作り上げられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set is disjoint with the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>visitors<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> set because no name appears in both sets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>visitors<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>集合と交わりを持ちません、両方に現れる名前がないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set is disjoint with the elements of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>visitors<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> array because no name appears in both.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>visitors<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>配列の要素と交わりを持ちません、両方に現れる名前がないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>non<ph x="2">&lt;w2/&gt;</ph>Neighbors<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set is made up of the elements of the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>employees<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> set that are not elements of <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>neighbors<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>non<ph x="2">&lt;w2/&gt;</ph>Neighbors<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>employees<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>集合の要素で<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>neighbors<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の要素でないものから作り上げられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>number<ph x="2">&lt;w2/&gt;</ph>To<ph x="3">&lt;w3/&gt;</ph>Match<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant is wrapped as an optional before comparing to the optional <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>number<ph x="6">&lt;w6/&gt;</ph>From<ph x="7">&lt;w7/&gt;</ph>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>続く例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>number<ph x="2">&lt;w2/&gt;</ph>To<ph x="3">&lt;w3/&gt;</ph>Match<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数は、オプショナル<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>number<ph x="6">&lt;w6/&gt;</ph>From<ph x="7">&lt;w7/&gt;</ph>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>との比較の前にオプショナル値としてラップされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>random(in:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> function uses <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>numeric<ph x="7">&lt;w7/&gt;</ph>Cast(_:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> twice to convert the argument and return value of the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>arc4random_uniform(_:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> function to the appropriate type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>random(in:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>関数は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>numeric<ph x="7">&lt;w7/&gt;</ph>Cast(_:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を二度使うことで、引数と<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>arc4random_uniform(_:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>関数の戻り値を適切な型へ変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the closure provides an ordering for an array of a custom enumeration that describes an HTTP response.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例では、そのクロージャは、あるHTTP応答を記述するあつらえ列挙の配列に対してある順序付けを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the constant <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is successfully created from a value of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>100<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, while the attempt to initialize the constant <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>y<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> from <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>1_000<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> fails because the <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Int8<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> type can represent <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>127<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> at maximum:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、定数<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>100<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の値から首尾よく作り上げられます、一方で定数<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>y<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>1_000<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>から初期化する試みは失敗します、なぜなら<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Int8<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>型は最大で<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>127<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>を表現可能だからです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the constant <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is successfully created from a value of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>21<ph x="8">&lt;w8/&gt;</ph>.0<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, while the attempt to initialize the constant <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>y<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> from <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>21<ph x="13">&lt;w13/&gt;</ph>.5<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> fails:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>続く例において、定数<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>21<ph x="8">&lt;w8/&gt;</ph>.0<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の値から首尾よく作成されます、一方で定数<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>y<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>を<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>21<ph x="13">&lt;w13/&gt;</ph>.5<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>から初期化する試みは失敗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the difference of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>10<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>21<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is less than zero, the minimum representable <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> value, so the result is the overflowed value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>10<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>21<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の差はゼロ、最小限表現可能な<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>値より少ないです、それで結果はオーバーフローした値です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the elements of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set that are also elements of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>neighbors<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> array are removed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合の要素でまた<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>neighbors<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>配列の要素でもあるものは削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the elements of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set that are also members of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>neighbors<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> are removed from <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>employees<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, while the elements of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>neighbors<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> that are not members of <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>employees<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> are added to <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>employees<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合の要素でまた<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>neighbors<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のメンバであるものは<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>employees<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>から削除されます、一方で<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>neighbors<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の要素で<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>employees<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>の要素でないものは<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>employees<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>に加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the elements of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set that are also members of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>neighbors<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> set are removed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合の要素でまた<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>neighbors<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>集合のメンバでもあるものは削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the elements of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set that are not also members of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>neighbors<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> set are removed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>employees<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合の要素でまた<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>neighbors<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>集合のメンバではないものは削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the elements of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>visitors<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set are added to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>attendees<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> set:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>visitors<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合の要素は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>attendees<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>集合に加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the key-value pair for the key <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"Aquamarine"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is removed from the dictionary by assigning <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to the key-based subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"Aquamarine"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対するキー値ペアは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>をキー基盤の添え字に割り当てることによって辞書から削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the predicate provides an ordering for an array of a custom <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>HTTPResponse<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例では、その述部はあつらえの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>HTTPResponse<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型の配列に対してある順序付けを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the product of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>10<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>50<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is greater than the maximum representable <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int8<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> value, so the result is the overflowed value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>10<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>50<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の積は、最大限表現可能な<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int8<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>値より大きいです、それで結果はオーバーフローした値です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the sum of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>100<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>121<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is greater than the maximum representable <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int8<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> value, so the result is the overflowed value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>100<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>121<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の和は、最大限表現可能な<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int8<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>値より大きいです、それで結果はオーバーフローした値です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, the value <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>127<ph x="2">&lt;w2/&gt;</ph>.75<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is rounded to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>127<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, which is representable by the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int8<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>続く例において、値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>127<ph x="2">&lt;w2/&gt;</ph>.75<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>127<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>へ丸められます、それは<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int8<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>型によって表現可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the next example, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>y<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has a value of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>21<ph x="4">&lt;w4/&gt;</ph>.5<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, which is encoded as <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>1<ph x="7">&lt;w7/&gt;</ph>.34375 * 2 ** 4<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>y<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>21<ph x="4">&lt;w4/&gt;</ph>.5<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の値を持ちます、それは<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>1<ph x="7">&lt;w7/&gt;</ph>.34375 * 2 ** 4<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>のようにエンコードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the next example, an integer literal is compared with the optional integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>number<ph x="2">&lt;w2/&gt;</ph>From<ph x="3">&lt;w3/&gt;</ph>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例では、整数リテラルがオプショナル整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>number<ph x="2">&lt;w2/&gt;</ph>From<ph x="3">&lt;w3/&gt;</ph>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the standard library, you can use the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Set<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type with elements of any hashable type, or you can easily create bit masks with <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Set<ph x="7">&lt;w7/&gt;</ph>Algebra<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> conformance using the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Option<ph x="10">&lt;w10/&gt;</ph>Set<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリにおいて、あなたは<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Set<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型を何らかのハッシュ型の要素で使うことができます、またはあなたは<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Set<ph x="7">&lt;w7/&gt;</ph>Algebra<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>準拠を持つビットマスクを<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Option<ph x="10">&lt;w10/&gt;</ph>Set<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロトコルを使って簡単に作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>number<ph x="2">&lt;w2/&gt;</ph>Of<ph x="3">&lt;w3/&gt;</ph>Cookies<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant has the default type for an integer literal, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Int<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, as designated by the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Integer<ph x="8">&lt;w8/&gt;</ph>Literal<ph x="9">&lt;w9/&gt;</ph>Type<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type alias.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合では、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>number<ph x="2">&lt;w2/&gt;</ph>Of<ph x="3">&lt;w3/&gt;</ph>Cookies<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数は整数リテラルに対する省略時型、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Int<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を持ちます、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Integer<ph x="8">&lt;w8/&gt;</ph>Literal<ph x="9">&lt;w9/&gt;</ph>Type<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型エイリアスによって設計されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, the newly created set drops the duplicate value (“Dave”) and doesn’t maintain the order of the array literal’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合において、新たに作成された集合は、重複した値（「Dave」）を落とします、そして配列リテラルのもつ要素の順番を維持しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, the values stored in the array are references to objects that live outside the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合、配列に格納される値らは、その配列の外側で生活しているオブジェクトらへの参照です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合、あるシーケンスが消耗可能になっているそして反復を再開することになるか、またはあるシーケンスがコレクションであるそして最初の要素から反復を再度着手することになるか、あなたはどちらか決めてかかることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, 100 bytes of raw memory are allocated for the pointer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bytes<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, and then the first four bytes are bound to the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Int8<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、100バイトの生のメモリがポインタ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bytes<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して割り当てられて、それから最初の４バイトが<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Int8<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型に束縛されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>filter(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is used to include only names shorter than five characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>filter(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は５つの文字より短い名前のみ含めるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>good<ph x="2">&lt;w2/&gt;</ph>Number<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is assigned a value of <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>100<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> because <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int("100")<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> succeeded in returning a non-<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>good<ph x="2">&lt;w2/&gt;</ph>Number<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>100<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の値を割り当てられます、なぜなら<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int("100")<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>が非<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>の結果を返すことに成功したからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>good<ph x="2">&lt;w2/&gt;</ph>Number<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is assigned a value of <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>100<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> because <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int("100")<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> succeeds in returning a non-<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>good<ph x="2">&lt;w2/&gt;</ph>Number<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>100<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の値を割り当てられます、なぜなら<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int("100")<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>が非<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>の結果を返すことに成功するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> tests whether <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>error<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is an empty string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>error<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が空の文字列かどうかテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> tests whether <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>measurements<ph x="4">&lt;w4/&gt;</ph>.count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is greater than zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>measurements<ph x="4">&lt;w4/&gt;</ph>.count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>がゼロより大きいかどうかテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is used first to convert the names in the array to lowercase strings and then to count their characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は最初に配列中の名前を小文字文字列に変換するために、それからそれらの文字を数えるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has a value of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>21<ph x="4">&lt;w4/&gt;</ph>.5<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, which is stored as <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>1<ph x="7">&lt;w7/&gt;</ph>.34375 * 2**4<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, where <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>**<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> is exponentiation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>21<ph x="4">&lt;w4/&gt;</ph>.5<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の値を持ちます、それは<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>1<ph x="7">&lt;w7/&gt;</ph>.34375 * 2**4<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>として格納されます、ここで<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>**<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>は冪です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is initialized as an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance by clamping <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>500<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> to the range <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>-128...127<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>y<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> is initialized as a <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>UInt<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> instance by clamping <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>-500<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> to the range <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>0...UInt<ph x="16">&lt;w16/&gt;</ph>.max<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスとして、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>500<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を範囲<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>-128...127<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に制限すること（クランピング）によって初期化されます、そして<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>y<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>は<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>UInt<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>インスタンスとして、<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>-500<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>を範囲<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>0...UInt<ph x="16">&lt;w16/&gt;</ph>.max<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>に制限することによって初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, a new element is inserted into <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>class<ph x="5">&lt;w5/&gt;</ph>Days<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, a set of days of the week.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、新しい要素が、一揃いの曜日<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>class<ph x="5">&lt;w5/&gt;</ph>Days<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>へ挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, accessing the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>text<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>smiley<ph x="4">&lt;w4/&gt;</ph>Type<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> metatype retrieves the overridden value from the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Emoji<ph x="7">&lt;w7/&gt;</ph>Smiley<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> subclass, instead of the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Smiley<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> class’s original definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>smiley<ph x="4">&lt;w4/&gt;</ph>Type<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メタタイプの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>text<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティにアクセスすることは、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Emoji<ph x="7">&lt;w7/&gt;</ph>Smiley<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>サブクラスからオーバーライドされた値を取って来ます、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Smiley<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>クラスのオリジナル定義ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、３つの範囲からなる配列は平坦化されます、それで各範囲の要素は順に反復されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, an existing element is inserted into <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>class<ph x="8">&lt;w8/&gt;</ph>Days<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, a set of days of the week.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、既存の要素が、一揃いの曜日<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>class<ph x="8">&lt;w8/&gt;</ph>Days<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>へ挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, both assignments to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>printed<ph x="2">&lt;w2/&gt;</ph>Message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> variable call this Boolean literal initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>printed<ph x="2">&lt;w2/&gt;</ph>Message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>変数への代入は両方ともこのブールリテラルイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, note the difference in the result of using <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>flat<ph x="4">&lt;w4/&gt;</ph>Map<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> with a transformation that returns an array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>flat<ph x="4">&lt;w4/&gt;</ph>Map<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>をある配列を返す変換とともに使うことの結果における違いに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, note the difference in the result of using <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>flat<ph x="4">&lt;w4/&gt;</ph>Map<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> with a transformation that returns an optional <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>flat<ph x="4">&lt;w4/&gt;</ph>Map<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>をあるオプショナル<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>値を返す変換とともに使うことの結果における違いに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>case 3<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> expression uses this pattern-matching operator to test whether <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>weekday<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is equal to the value <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>3<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>case 3<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>式はこのパターンマッチング演算子を使って<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>weekday<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が値<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>3<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と等しいかどうかテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>number<ph x="2">&lt;w2/&gt;</ph>To<ph x="3">&lt;w3/&gt;</ph>Match<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant is wrapped as an optional before comparing to the optional <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>number<ph x="6">&lt;w6/&gt;</ph>From<ph x="7">&lt;w7/&gt;</ph>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>number<ph x="2">&lt;w2/&gt;</ph>To<ph x="3">&lt;w3/&gt;</ph>Match<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数は、オプショナル<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>number<ph x="6">&lt;w6/&gt;</ph>From<ph x="7">&lt;w7/&gt;</ph>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>との比較の前にオプショナル値としてラップされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>colors<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> array can be bridged to <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>NSArray<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> because the <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>colors<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> array’s <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>String<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> elements bridge to <bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>NSString<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>colors<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>配列は<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>NSArray<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>にブリッジできます、なぜならそれの<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>colors<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>配列のもつ<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>String<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>要素が<bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>NSString<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>にブリッジするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the assignment to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> variable calls this initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数への代入は、このイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the assignment to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>letter<ph x="2">&lt;w2/&gt;</ph>K<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant is handled by this initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>letter<ph x="2">&lt;w2/&gt;</ph>K<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数への代入は、このイニシャライザによって舞台裏で取り扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the assignment to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>twas<ph x="2">&lt;w2/&gt;</ph>Brillig<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant calls this Boolean literal initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>twas<ph x="2">&lt;w2/&gt;</ph>Brillig<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数への代入は、このブールリテラルイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the assignment to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant calls this floating-point literal initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数への代入は、この浮動小数点リテラルイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the assignment to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant calls this initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数への代入は、このイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the assignment to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant calls this integer literal initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数への代入は、この整数リテラルイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the compiler infers the full type of each array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、コンパイラは各配列の完全な型を推論します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the expression <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>single<ph x="2">&lt;w2/&gt;</ph>Digits<ph x="3">&lt;w3/&gt;</ph>.drop<ph x="4">&lt;w4/&gt;</ph>First(5))<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equivalent to calling this initializer with <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>single<ph x="7">&lt;w7/&gt;</ph>Digits<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> and a range covering the last five items of <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>single<ph x="10">&lt;w10/&gt;</ph>Digits<ph x="11">&lt;w11/&gt;</ph>.indices<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、式<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>single<ph x="2">&lt;w2/&gt;</ph>Digits<ph x="3">&lt;w3/&gt;</ph>.drop<ph x="4">&lt;w4/&gt;</ph>First(5))<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、このイニシャライザを<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>single<ph x="7">&lt;w7/&gt;</ph>Digits<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>および<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>single<ph x="10">&lt;w10/&gt;</ph>Digits<ph x="11">&lt;w11/&gt;</ph>.indices<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>の終わり５項目を対象とする範囲とともに呼び出すことに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the resulting array is the same length as <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>words<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、結果の配列は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>words<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と同じ長さです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, three elements in the middle of an array of integers are replaced by the five elements of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Repeated&lt;Int&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、整数からなる配列の真ん中の３つの要素が、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Repeated&lt;Int&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの５つの要素によって置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this view, many individual characters—for example, “é”, “김”, and “🇮🇳”—can be made up of multiple Unicode code points.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>多くの単一の文字 — 例えば「é」、「김」、そして「🇮🇳」など — が、複数のユニコードコード点から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Including More Data in Errors</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらなるデータをエラーに含める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Indentation is stripped from each line of a multiline string literal to match the indentation of the closing delimiter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>字下げは、複数行文字列リテラルの各行から剥ぎ取られて、閉じ区切り記号の字下げに合わせられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Index and iterator types for other sequence and collection types in the standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリの中の他のシーケンスとコレクション型のためのインデックスとイテレータ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Indicates that a precondition was violated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは前提条件が破られたことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Indicates that an internal sanity check failed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはある内部的な正常性確認が失敗したことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Indices and Iterators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インデックスとイテレータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Indices for a subscripting a string are shared with the string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>characters<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の添え字用のインデックスは、その文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>characters<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Indices of a slice can be used interchangeably with indices of the base collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるスライスのインデックスは、基盤コレクションのインデックスと交換可能に使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Indices that are moved forward and backward in a bidirectional collection move by the same amount in each direction.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>二方向性のコレクションにおいて前方および後方に移動されるインデックス値は、各方向で同じ量だけ移動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Individual Unicode Scalar Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>個々のユニコードスカラー値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inequality is the inverse of equality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>不等性は、同等性の裏返しです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Infinite values with the same sign are equal to each other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じ符号を持つ無限大値は互いに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Infinity</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無限大</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Infinity compares greater than all finite numbers and equal to other infinite values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無限大は、すべての有限の数より大きい、そして他の無限大の値と等しいと比較されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Infix operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>中置演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Infrequently Used Functionality</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>滅多に使われない機能性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inherited By</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>継承される先</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inherits From</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>継承元</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initialization with Literals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リテラルを使った初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initialization, assignment, and deinitialization can be performed using <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Unsafe<ph x="9">&lt;w9/&gt;</ph>Mutable<ph x="10">&lt;w10/&gt;</ph>Pointer<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化、代入、そしてデイニシャライズは、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Unsafe<ph x="9">&lt;w9/&gt;</ph>Mutable<ph x="10">&lt;w10/&gt;</ph>Pointer<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>メソッドを使って実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initialize for the given <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initialized Memory</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化済みメモリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializes <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> from a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をある文字列から初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializes <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> from an integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をある整数から初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializes <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with the given container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を与えられたコンテナで初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializes <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with the given path of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Coding<ph x="4">&lt;w4/&gt;</ph>Key<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>s and a description of what went wrong.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>与えられたいくつかの<bpt i="3" x="3">&lt;s3&gt;</bpt>Coding<ph x="4">&lt;w4/&gt;</ph>Key<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のパスと何がうまくいかなかったかの記述とともに初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializes <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with the given raw value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を与えられた生の値で初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializes memory in the buffer with the elements of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリをバッファにおいて<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素らで初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializes the memory referenced by this pointer with the given value, binds the memory to the value’s type, and returns a typed pointer to the initialized memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタによって参照されるメモリを与えられた値で初期化して、そのメモリを値の型に束縛し、そして初期化されたメモリへの型付ポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializes the memory referenced by this pointer with the values starting at the given pointer, binds the memory to the values’ type, and returns a typed pointer to the initialized memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタによって参照されるメモリを与えられたポインタで始まる値で初期化して、そのメモリを値の型に束縛し、そして初期化されたメモリへの型付ポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializes the memory referenced by this pointer with the values starting at the given pointer, binds the memory to the values’ type, deinitializes the source memory, and returns a typed pointer to the newly initialized memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタによって参照されるメモリを与えられたポインタで始まる値で初期化して、そのメモリを値の型に束縛し、元となるメモリをデイニシャライズして、そして新しく初期化されたメモリへの型付ポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializes the memory referenced by this pointer with the values starting at the given pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタによって参照されるメモリを、与えられたポインタで始まるいくらかの値で初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializes this pointer’s memory with the specified number of consecutive copies of the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタのメモリを、指定された数の指定された値の連続コピーで初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Input and Output</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入力と出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inserting Characters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字の挿入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inserts a collection of characters at the specified position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列からなるコレクションを指定された位置で挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inserts a new character at the specified position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい文字を指定された位置で挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inserts a new element at the specified position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある新しい要素を指定された位置で挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inserts a new element into the collection at the specified position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある新しい要素をコレクションへ指定された位置で挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inserts the elements of a sequence into the collection at the specified position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンスに属する複数の要素をコレクションへ指定された位置で挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inserts the elements of another set into this option set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>別のセットの要素をこのオブションセットへと挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inserts the elements of the given sequence into the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたシーケンスの要素を集合に挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inserts the given element in the set if it is not already present.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが既に存在するのでないならば、与えられた要素を集合へと挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inserts the given element into the set unconditionally.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた要素を集合へと無条件に挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inserts the given element into the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた要素をセットへと挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inspecting a Boolean</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブールを調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inspecting a Buffer</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファを調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inspecting a Dictionary</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書を調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inspecting a Range</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲を調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inspecting a Set</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合を調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inspecting a String</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列を調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inspecting an Array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列を調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inspecting an Optional</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルを調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instance Casting</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスのキャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instance Method</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instance Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスメソッド </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instance Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>様々なインスタンスプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instance Property</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instances of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unfold<ph x="2">&lt;w2/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are created with the functions <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>sequence(first:<ph x="5">&lt;w5/&gt;</ph>next:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>sequence(state:<ph x="8">&lt;w8/&gt;</ph>next:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unfold<ph x="2">&lt;w2/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスは、関数<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>sequence(first:<ph x="5">&lt;w5/&gt;</ph>next:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>および<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>sequence(state:<ph x="8">&lt;w8/&gt;</ph>next:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>で作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instances of conforming types can be encoded, and appropriately passed, as elements of a C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>va_list<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>準拠する型のインスタンスは、符号化されること、そして適切に渡されることが、C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>va_list<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素として可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instances of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Static<ph x="2">&lt;w2/&gt;</ph>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type are immutable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Static<ph x="2">&lt;w2/&gt;</ph>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスは、不変です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instances of types that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Text<ph x="2">&lt;w2/&gt;</ph>Output<ph x="3">&lt;w3/&gt;</ph>Streamable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol can write their value to instances of any type that conforms to the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Text<ph x="6">&lt;w6/&gt;</ph>Output<ph x="7">&lt;w7/&gt;</ph>Stream<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Text<ph x="2">&lt;w2/&gt;</ph>Output<ph x="3">&lt;w3/&gt;</ph>Streamable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型のインスタンスは、それらの値を<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Text<ph x="6">&lt;w6/&gt;</ph>Output<ph x="7">&lt;w7/&gt;</ph>Stream<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルに準拠するあらゆる型のインスタンスへ書き出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instantiates an instance of the conforming type from a string representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>準拠する型のインスタンスを文字列表現から初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead of accessing this property directly, convert an instance of any type to a string by using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(describing:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティに直接にアクセスする代わりに、何らかの型のインスタンスを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(describing:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを使って文字列へと変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead of copying over the elements of a slice to new storage, an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Array<ph x="5">&lt;w5/&gt;</ph>Slice<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance presents a view onto the storage of a larger array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある断片部分（スライス）の要素をすっかり新しいストレージにコピーする代わりに、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Array<ph x="5">&lt;w5/&gt;</ph>Slice<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスはある大きな配列に関するある見方（ビュー）を提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead of having constant time when averaged over many calls, the function may decay to performance that is linear in <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>values<ph x="11">&lt;w11/&gt;</ph>.count<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>多くの呼出しの全体を平均したとき定数時を持つのではなく、<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>values<ph x="11">&lt;w11/&gt;</ph>.count<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>において線形である性能を関数が衰えさせるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead of returning an iterator with a type that encapsulates the implementation of the collection, the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>digits()<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> function first wraps the iterator in an <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Any<ph x="12">&lt;w12/&gt;</ph>Iterator<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションの実装をカプセル化するある型をもつイテレータを返すのではなく、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>digits()<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>関数はイテレータを<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Any<ph x="12">&lt;w12/&gt;</ph>Iterator<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>インスタンスの中にまずラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead of trapping on out-of-range values, using the failable <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>exact<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> initializer results in <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲外の値に関してトラップするのではなく、失敗できる<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>exact<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>イニシャライザは<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, create a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bool<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance by using one of the Boolean literals <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bool<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスをブールリテラルの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のうち１つを使って作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, create a new array by using an array literal as its value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、配列リテラルをその値として使うことで新しい配列を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, create a new set using an array literal as its value by enclosing a comma-separated list of values in square brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、新しい集合を配列リテラルをそれの値として、コンマ区切りの値のリストを角カッコで囲むことによって、作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, create a new value by using a literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、新しい値をリテラルを使うことによって作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, create a slice of a collection by using the collection’s range-based subscript or by using methods that return a subsequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、そのコレクションのもつ範囲に基づく添え字によって、または下位シーケンスを返すメソッドを使うことによって、コレクションのスライスを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, each presents a view onto the storage of the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>absences<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>absences<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>配列のストレージ上でのひとつのビューをそれぞれが提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, initialize a variable or constant using a floating-point literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、浮動小数点リテラルを使って変数や定数を初期化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, initialize a variable or constant using an integer literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、整数リテラルを使って変数や定数を初期化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, initialize a variable or constant using one of the Boolean literals <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、変数や定数をブールリテラル<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のうちの１つを使って初期化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use an initializing method, such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>initialize(to:<ph x="2">&lt;w2/&gt;</ph>count:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、初期化するメソッド、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>initialize(to:<ph x="2">&lt;w2/&gt;</ph>count:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>などを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use an initializing method, such as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>initialize(to:<ph x="4">&lt;w4/&gt;</ph>count:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、初期化するメソッド、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>initialize(to:<ph x="4">&lt;w4/&gt;</ph>count:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>などを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use only the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Buffer<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> argument to <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>body<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Buffer<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>引数だけを<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>body<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use only the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Raw<ph x="6">&lt;w6/&gt;</ph>Buffer<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> argument to <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>body<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Raw<ph x="6">&lt;w6/&gt;</ph>Buffer<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>引数だけを<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>body<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use string interpolation to create a new string by including values, literals, variables, or expressions enclosed in parentheses, prefixed by a backslash (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>\(<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>…<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、文字列補間を使って、バックスラッシュ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>\(<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>…<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を前に置いた丸括弧に囲まれた値、リテラル、変数、または式を含めることで、新しい文字列を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>body<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> closure’s pointer argument to access the values in memory as instances of type <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>T<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>body<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>クロージャのもつポインタ引数を使うことで、メモリの中の値に型<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>T<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>のインスタンスとしてアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use the Boolean literal <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to create a new <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Bool<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、ブールリテラル<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って新しい<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Bool<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use the closure’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Character<ph x="4">&lt;w4/&gt;</ph>View<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、クロージャのもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Character<ph x="4">&lt;w4/&gt;</ph>View<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>引数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use the nonmutable <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Slice<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> or define your own subsequence type that takes your index invalidation requirements into account.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、非可変<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Slice<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>を使うかまたはあなたのインデックス無効化要件を考慮に入れるあなた独自の下位シーケンス型を定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use the nonmutable <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Slice<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> or define your own subsequence type that takes your index invalidation requirements into account.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、非可変<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Slice<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>を使うかまたはあなたのインデックス無効化要件を考慮に入れるあなた独自の下位シーケンス型を定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use the nonmutable <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Slice<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> or define your own subsequence type that takes your index invalidation requirements into account.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、非可変<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Slice<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>を使うかまたはあなたのインデックス無効化要件を考慮に入れるあなた独自の下位シーケンス型を定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use the nonmutable <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>Slice<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> or define your own subsequence type that takes your index invalidation requirements into account.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、非可変<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>Slice<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>を使うかまたはあなたのインデックス無効化要件を考慮に入れるあなた独自の下位シーケンス型を定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use the nonmutable <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Slice<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> or define your own subsequence type that takes your index invalidation requirements into account.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、非可変<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Slice<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を使うかまたはあなたのインデックス無効化要件を考慮に入れるあなた独自の下位シーケンス型を定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use the value’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>is<ph x="4">&lt;w4/&gt;</ph>Na<ph x="5">&lt;w5/&gt;</ph>N<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、その値の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>is<ph x="4">&lt;w4/&gt;</ph>Na<ph x="5">&lt;w5/&gt;</ph>N<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, when you need an operation to have a specific numeric result, filter out any NaN values using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Na<ph x="3">&lt;w3/&gt;</ph>N<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうではなく、あなたがある特定の数値結果を持つ演算を必要とする場合、あらゆるNaN値を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Na<ph x="3">&lt;w3/&gt;</ph>N<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>特性を使って除去してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, you can perform set operations with another set, an array, or any other sequence type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それどころか、あなたは集合演算を他の集合、配列、またはあらゆる他のシーケンス型とで実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, you must know the type of value previously in memory and initialize or assign the memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、あなたは前もってメモリ中の値の型を知っていて、メモリを初期化またはアサインする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integer</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integer Index Ambiguity</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数インデックスのあいまいさ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integer Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integer Value Casting</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数値のキャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Interprets the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as a path in the file system and attempts to perform filename completion, returning a numeric value that indicates whether a match was possible, and by reference the longest path that matches the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をファイルシステムにおけるパスとして解釈してファイル名補完を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>にマッチする最も長いパスを参照渡しすることによって試みます、マッチが可能だったかどうかを指し示す数値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Invalid bytes are replaced by Unicode <bpt i="2" x="2">&lt;a2&gt;</bpt>replacement characters<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無効なバイトは、<bpt i="2" x="2">&lt;a2&gt;</bpt>ユニコード代替文字<ept i="2">&lt;/a2&gt;</ept>で置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Invalidates all indices with respect to the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この文字列に関する全てのインデックスを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Invokes the given closure with a C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>va_list<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> argument derived from the given array of arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくらかの引数からなる与えられた配列から引き出されるC <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>va_list<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>引数とともに、与えられたクロージャを発動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Invokes the given closure with a buffer containing the static string’s UTF-8 code unit sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>静的文字列のUTF-8コード単位シーケンスを含んでいるバッファとともに与えられたクロージャを発動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Invokes the given closure with a buffer pointer covering the raw bytes of the given argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクロージャを、与えられた引数の生のバイトを変換しているバッファポインタとともに発動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Invokes the given closure with a mutable buffer pointer covering the raw bytes of the given argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクロージャを、与えられた引数の生のバイトを変換している可変バッファポインタとともに発動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Invokes the given closure with a pointer to the given argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクロージャを、与えられた引数に対するポインタとともに発動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It acts as an iterator by using a collection’s indices to step over each value in the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、コレクションのインデックスを使ってコレクションの中の各値のすべてを渡っていくあるイテレータとしての役割を果たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It does not copy the elements from the collection into separate storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、要素をそのコレクションから別個のストレージへとコピーしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is better than an <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>unsafe<ph x="9">&lt;w9/&gt;</ph>Bit<ph x="10">&lt;w10/&gt;</ph>Cast<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> because it’s more restrictive, and because checking is still performed in debug builds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>unsafe<ph x="9">&lt;w9/&gt;</ph>Bit<ph x="10">&lt;w10/&gt;</ph>Cast<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>よりも良いです、なぜならそれはもっと制限的であるから、そして検査は依然としてデバッグビルドにおいて実行されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is called by the compiler to handle dictionary literals.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、辞書リテラルを取り扱うためにコンパイラによって呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is safe to use operations that put an upper limit on the number of elements they access, such as <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>prefix(_:)<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> or <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>drop<ph x="15">&lt;w15/&gt;</ph>First(_:)<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>, and operations that you can guarantee will terminate, such as passing a closure you know will eventually return <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>true<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> to <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>first(where:)<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>安全なのは、上側の限界をそれらがアクセスする要素数に置く演算、例えば<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>prefix(_:)<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>または<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>drop<ph x="15">&lt;w15/&gt;</ph>First(_:)<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>など、そしてあなたが終わらせることができる演算、例えばあなたが結局は<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>true<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>を<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>first(where:)<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>に返すと知っているクロージャを渡すことなどの使用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is safe to use operations that put an upper limit on the number of elements they access, such as <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>prefix(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> or <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>drop<ph x="10">&lt;w10/&gt;</ph>First(_:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>, and operations that you can guarantee will terminate, such as passing a closure you know will eventually return <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>true<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> to <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>first(where:)<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>安全なのは、上側の限界をそれらがアクセスする要素数に置く演算、例えば<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>prefix(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>または<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>drop<ph x="10">&lt;w10/&gt;</ph>First(_:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>など、そしてあなたが終わらせることができる演算、例えばあなたが結局は<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>true<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>を<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>first(where:)<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>に返すと知っているクロージャを渡すことなど、の使用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is suitable for programming operations that require stable results not depending on the current locale.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、現在のロケールに依存しない安定した結果を必要とするプログラミング操作に適しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is undefined behavior for the escapable closure to be stored, referenced, or executed after the function returns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数が返った後に格納、参照、または実行されることは、脱出可能クロージャにとって未定義挙動です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is unusual to need to call this method directly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドを直接呼び出す必要は通常ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is used by the compiler when interpreting string interpolations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは文字列補間を解釈する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is used by the compiler when you create a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance by using a floating-point literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたが新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを浮動小数点リテラルを使うことによって作成する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is used by the compiler when you create a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance by using an integer literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたが新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを整数リテラルを使うことによって作成する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is used by the compiler when you create a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float80<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance by using a floating-point literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたが新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float80<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを浮動小数点リテラルを使うことによって作成する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is used by the compiler when you create a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float80<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance by using an integer literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたが新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float80<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを整数リテラルを使うことによって作成する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is used by the compiler when you create a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance by using a floating-point literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたが新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを浮動小数点リテラルを使うことによって作成する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is used by the compiler when you create a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance by using an integer literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたが新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを整数リテラルを使うことによって作成する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is used by the compiler when you create a string using string interpolation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはあなたが文字列補間を使って文字列を作成する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is used by the compiler when you initialize a string using a string literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたが文字列リテラルを使って文字列を初期化する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is used by the compiler when you initialize an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance with a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>リテラルで初期化する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is used by the compiler when you use a Boolean literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたがブールリテラルを使う時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is used by the compiler when you use a string literal to initialize a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたが文字列リテラルを使って<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを初期化する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is used by the compiler when you use an array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたが配列リテラルを使う時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It may be used by the compiler when you initialize a static string using a string literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたが文字列リテラルを使って静的文字列を初期化する時にコンパイラによって使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It may be used by the compiler when you initialize a static string using an extended grapheme cluster.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたが拡張初期素クラスタを使って静的文字列を初期化する時にコンパイラによって使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It may be used by the compiler when you use a string literal to initialize a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたが文字列リテラルを使って<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを初期化する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It only works for APIs that have a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>va_list<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> variant, so for example, it isn’t much use if all you have is:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>va_list<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バリアントを持つAPIに対してのみ働きます、あなたが次のものしか持っていないならば、それはあまり使うことはありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Iterating Over an Array's Elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の要素すべてに反復する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Iterating Over the Contents of a Dictionary</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の内容すべてにわたって反復していく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Iterating over Keys and Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーと値のすべてに反復する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Iterating over a Set</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合のすべてに反復する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Iterating over a String's Characters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の持つ文字のすべてにわたって反復する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Iterating over a dictionary yields the key-value pairs as two-element tuples.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある辞書すべてを対象として反復することは、キー値ペアを２要素タプルとして生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコレクションの要素すべてにそれの位置によって反復していくことは、そのコレクションすべてにそれのイテレータを使って反復していくのと同じ要素を同じ順序で生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Its <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>deinit<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must destroy its stored <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Header<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and any constructed <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Element<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>deinit<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、それの格納された<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Header<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>とあらゆる構成された<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Element<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を破棄しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Joint Iteration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接合反復</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Key Paths</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Key-Path Expressions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパス式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>KeyedDecodingContainerProtocol Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>KeyedDecodingContainerProtocol 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>KeyedEncodingContainerProtocol Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>KeyedEncodingContainerProtocol 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Lastly, use the eponymous <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>replace<ph x="2">&lt;w2/&gt;</ph>Subrange(_:<ph x="3">&lt;w3/&gt;</ph>with:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to replace a subrange of elements with the contents of another collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後に、名前の元となった<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>replace<ph x="2">&lt;w2/&gt;</ph>Subrange(_:<ph x="3">&lt;w3/&gt;</ph>with:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、いくつかの要素からなる下位範囲を別のコレクションの内容で置き換えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Lazy Collections</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延コレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Lazy Wrappers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延ラッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Lazy sequences can be used to avoid needless storage allocation and computation, because they use an underlying sequence for storage and compute their elements on demand.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延シーケンスは、不必要なストレージの割り当てと計算を防止するために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>LazyCollectionProtocol Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>LazyCollectionProtocol 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>LazySequenceProtocol Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>LazySequenceProtocol 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Learn how the Swift standard library uses protocols and generics to express powerful constraints.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのようにSwift標準ライブラリがプロトコルや総称体を使ってパワフルな制約を表すかを学んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Left associative</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>左結合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Left bit shift and assign</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>左ビットシフトして代入する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Less than</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より小さい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Less than or equal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より小さいか、等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types can remove one or more elements using a single operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、１つ以上の要素をただ１つの演算を使うことによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, if <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>n &lt; 0<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, a limit that is greater than <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>i<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> has no effect.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>n &lt; 0<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ならば、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>i<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>より大きい限度は効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, if <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>n &lt; 0<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>limit<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> has no effect if it is greater than <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>i<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>n &lt; 0<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>limit<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>は、それが<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>i<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>より大きいならば効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, if you pass a zero-length collection as the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>new<ph x="2">&lt;w2/&gt;</ph>Elements<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter, this method removes the elements in the given subrange without replacement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、あなたがゼロ長コレクションを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>new<ph x="2">&lt;w2/&gt;</ph>Elements<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータとして渡すならば、このメソッドは与えられた下位範囲の中の要素を置き換えることなく削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Locale-independent case-insensitive operation, and other needs, can be achieved by calling <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>range<ph x="2">&lt;w2/&gt;</ph>Of<ph x="3">&lt;w3/&gt;</ph>String(_:<ph x="4">&lt;w4/&gt;</ph>options:<ph x="5">&lt;w5/&gt;</ph>_, range:<ph x="6">&lt;w6/&gt;</ph>_locale:<ph x="7">&lt;w7/&gt;</ph>_)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ロケール独立で大文字小文字を考慮しない演算、そして他の需要は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>range<ph x="2">&lt;w2/&gt;</ph>Of<ph x="3">&lt;w3/&gt;</ph>String(_:<ph x="4">&lt;w4/&gt;</ph>options:<ph x="5">&lt;w5/&gt;</ph>_, range:<ph x="6">&lt;w6/&gt;</ph>_locale:<ph x="7">&lt;w7/&gt;</ph>_)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出すことによって成し遂げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Logical AND</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理積</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Logical NOT</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理否定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Logical OR</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理和</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Logical Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Long-term storage of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ph x="2">&lt;w2/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances is discouraged.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ph x="2">&lt;w2/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの長期ストレージは推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Long-term storage of a slice may therefore prolong the lifetime of elements that are no longer otherwise accessible, which can appear to be memory and object leakage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるスライスの長期ストレージは、もはやそれ以外ではアクセス可能ではない要素の寿命を延長し、それはメモリとオブジェクトの漏洩であるように見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Long-term storage of a slice may therefore prolong the lifetime of elements that are no longer otherwise accessible, which can erroneously appear to be memory leakage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるスライスの長期ストレージは、もはやそれ以外ではアクセス可能ではない要素の寿命を延長し、それはメモリの漏洩であるように見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Make your data types encodable and decodable for compatibility with external representations such as JSON.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのデータ型のエンコーディングとデコーディングを外部表現、例えばJSONなどとの互換性のために行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Making your own custom types conform to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> enables many useful operations, like <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>for<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>-<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>in<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> looping and the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>contains<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> method, without much effort.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのあつらえの型を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠させることは、多くの有用な演算能力を与えます、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>for<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>-<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>in<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ループおよび<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>contains<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>メソッドのように、あまり苦労せずに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Manage the given <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>buffer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>buffer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Managed Buffers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファ管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Manipulating Indices</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インデックスを操る</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Manual Iteration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>手動反復</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Manual Memory Management</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>手動メモリ管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Many collection operations are performed by wrapping a collection in another type, instead of copying the collection's contents.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>多くのコレクション演算は、コレクションを別の型の中にラップすることによって実行されます、コレクションの内容をコピーするのではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Many individual characters, such as “é”, “김”, and “🇮🇳”, can be made up of multiple Unicode code points.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>多くの単一の文字、例えば「é」、「김」、そして「🇮🇳」などが、複数のユニコードコード点から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Many pointer operations must only be applied to pointers with memory in a specific state—you must keep track of the state of the memory you are working with and understand the changes to that state that different operations perform.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>多くのポインタ演算はある特定の状態のメモリを持つポインタに適用されるだけであるべきです — あなたは、あなたが作業しているメモリの状態を見失わないようにして、異なる演算が実行するその状態の変更を理解していなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Many sequence and collection operations return an array or a type-erasing collection wrapper instead of a set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>多くのシーケンスおよびコレクション演算は、集合ではなく、ある配列またはある型消去コレクションラッパーを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Many types in the standard library already conform to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリの多くの型はすでに<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Many types in the standard library conform to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Hashable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>: strings, integers, floating-point and Boolean values, and even sets provide a hash value by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリの中の多くの型が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Hashable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠します：文字列、整数、浮動小数点、およびブール値、そしてたとえ初期状態でハッシュ値を提供する集合でさえ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Many value types in Swift bridge to Objective-C counterparts, like <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>String<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftでの多くの値型は、Objective-Cの相当物へとブリッジします、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>String<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>や<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Masked Arithmetic</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>隠された算術</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>May also supply a “display style” property that suggests how this structure might be rendered.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>またどのようにこの構造体がレンダリングされることになるかを提案する「表示形式」プロパティを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Measuring the Length of a String</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の長さを計測する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Memory Access</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Memory Layout</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリレイアウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Memory can be untyped and uninitialized, bound to a type and uninitialized, or bound to a type and initialized to a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリは、型無しで未初期化、ある型に束縛されて未初期化、またはある型に束縛されてある値に初期化される可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Memory that has been bound to a type can be rebound to a different type only after it has been deinitialized or if the bound type is a <bpt i="0" x="0">&lt;e0&gt;</bpt>trivial type<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型に束縛されているメモリは、それがデイニシャライズされた後にまたは束縛型が<bpt i="0" x="0">&lt;e0&gt;</bpt>trivial type<ept i="0">&lt;/e0&gt;</ept>である場合にのみ、異なる型に再束縛が可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Memory that has been bound to a type, whether it is initialized or uninitialized, is typically accessed using typed pointers—instances of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型に束縛されているメモリは、それが初期化済みか未初期化かにかかわらず、一般的に型付ポインタを使ってアクセスされます — <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>ではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Memory that has just been allocated through a typed pointer or has been deinitialized is in an <bpt i="0" x="0">&lt;e0&gt;</bpt>uninitialized<ept i="0">&lt;/e0&gt;</ept> state.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付ポインタを通して今しがたアロケートされる、または<bpt i="0" x="0">&lt;e0&gt;</bpt>未初期化<ept i="0">&lt;/e0&gt;</ept>状態にデイニシャライズされるメモリ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Memory that you manually manage can be either <bpt i="0" x="0">&lt;e0&gt;</bpt>untyped<ept i="0">&lt;/e0&gt;</ept> or <bpt i="1" x="1">&lt;e1&gt;</bpt>bound<ept i="1">&lt;/e1&gt;</ept> to a specific type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが手動で管理するメモリは、特定の型に対して<bpt i="0" x="0">&lt;e0&gt;</bpt>型付けされない<ept i="0">&lt;/e0&gt;</ept>または<bpt i="1" x="1">&lt;e1&gt;</bpt>束縛される<ept i="1">&lt;/e1&gt;</ept>のいずれかが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Merges the key-value pairs in the given sequence into the dictionary, using a combining closure to determine the value for any duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたシーケンスの中のキー値ペアをこの辞書へと結合します、結び付けられているクロージャを使ってあらゆる重複キーに対する値を特定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mirrors are used by playgrounds and the debugger.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さまざまなMirrorがプレイグラウンドとデバッガによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Model data with numbers, Boolean values, and other fundamental types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数、ブール値、および他の基本的な型に関してデータをモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Modifying Copies of Arrays</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列のコピーを修正する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Modifying a copy of a string leaves the original unaffected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のコピーを修正しても、元のものはそのままで影響を受けません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Modifying and Comparing Strings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の修正と比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Moreover, a collection’s indices form a finite range of the positions of the collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その上、コレクションのインデックスは、コレクションの要素の位置からなる有限の範囲を形成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Moreover, inequality is the inverse of equality, so any custom implementation of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>!=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator must guarantee that <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>a != b<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> implies <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>!(a == b)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その上に、不等性は同等性の逆です、それで<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>!=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子のあらゆるあつらえの実装は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>a != b<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>!(a == b)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を意味することを保証しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Most basic types in the Swift standard library conform to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Equatable<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift標準ライブラリの基本的な型のほとんどは<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Equatable<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Most collections in the standard library use <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Indexing<ph x="5">&lt;w5/&gt;</ph>Iterator<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> as their iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリの中のほとんどのコレクションは、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Indexing<ph x="5">&lt;w5/&gt;</ph>Iterator<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>をそれらのイテレータとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Most operations with a NaN operand produce a NaN result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NaN演算数を使うほとんどの演算は、結果NaNを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Moves instances from initialized source memory into the uninitialized memory referenced by this pointer, leaving the source memory uninitialized and the memory referenced by this pointer initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくらかのインスタンスを初期化されたソースメモリからこのポインタによって参照される未初期化メモリに移動します、残っている未初期化ソースメモリは未初期化で、このポインタによって参照されたメモリは初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiline string literals are enclosed in three double quotes (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"""<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>), with each delimiter on its own line.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行文字列リテラルは、３つの二重引用符（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"""<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）に囲まれ、各区切り記号をそれの独自の行上に持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiple copies of an array share the same storage until you modify one of the copies.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある配列の複数のコピーは、あなたがコピーの１つを修正するまでは、同じストレージを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiplies two values and produces their product, rounding to a representable value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値を乗算してそれらの積を生成します、表現可能な値へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiplies two values and produces their product.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値を乗算してそれらの積を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiplies two values and stores the result in the left-hand-side variable, rounding to a representable value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値を乗算して、結果を左手側の変数に格納します、表現可能な値へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiplies two values and stores the result in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値を乗算して、結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiply</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>乗算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiply and assign</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>乗算して代入する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiply, ignoring overflow</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>乗算、オーバーフローを無視</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Must never be called, since this collection is always empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>決して呼ばないでください、このコレクションは常に空であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>MutableCollection Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>MutableCollection 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>NaN (“not a number”)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NaN（「非数」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>NaN is not equal to any value, including itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NaNは、それ自身を含めてあらゆる値と等しくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>NaN propagates through many arithmetic operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NaNは、いくつもの算術演算をずっと伝播していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>NaN values compare not equal to every value, including themselves.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NaNは、それら自身を含めてあらゆる値に対して等しくないと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Negation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>負にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Neither the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ph x="2">&lt;w2/&gt;</ph>Half<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> nor <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>second<ph x="5">&lt;w5/&gt;</ph>Half<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> slices allocate any new storage of their own.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ph x="2">&lt;w2/&gt;</ph>Half<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>second<ph x="5">&lt;w5/&gt;</ph>Half<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>スライスのどちらも、なんらそれら独自の新規ストレージを割り当てません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Next, create unique options as static properties of your custom type using unique powers of two (1, 2, 4, 8, 16, and so forth) for each individual property’s raw value so that each property can be represented by a single bit of the type’s raw value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次に、それぞれが特有なオプションをあなたのあつらえの型の静的プロパティとして作成してください、特有な２の冪（1、2、4、8、16、およびそれ以降）を各個別プロパティの生の値に対して使います、それで各プロパティはその型の持つ生の値からなるある単一ビットによって表されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Next, implement the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator function, the requirement inherited from the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次に、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子関数、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルから継承される要件を実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Next, the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>while<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> loop calls the iterator’s <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>next()<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> method repeatedly, binding each element that is returned to <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>animal<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> and exiting when the <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>next()<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> method returns <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>nil<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次に、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>while<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ループは、そのイテレータのもつ<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>next()<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>メソッドを繰り返し呼び出して、返される各要素を<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>animal<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>に束縛して、そして<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>next()<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>メソッドが<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>nil<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>を返すとき退出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Next, the bytes referenced by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>dest<ph x="2">&lt;w2/&gt;</ph>Bytes<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are copied into <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>byte<ph x="5">&lt;w5/&gt;</ph>Array<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, a new <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>[UInt]<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> array, and then the remainder of <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>some<ph x="10">&lt;w10/&gt;</ph>Bytes<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> is appended to <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>byte<ph x="13">&lt;w13/&gt;</ph>Array<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次に、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>dest<ph x="2">&lt;w2/&gt;</ph>Bytes<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によって参照されるバイトは<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>byte<ph x="5">&lt;w5/&gt;</ph>Array<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、新しい<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>[UInt]<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>配列へとコピーされます、そしてそれから<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>some<ph x="10">&lt;w10/&gt;</ph>Bytes<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>の残りは<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>byte<ph x="13">&lt;w13/&gt;</ph>Array<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>に加えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Next, the function calls the array’s <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>index(before:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method to return the correct position in the passed array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次に、関数は配列の<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>index(before:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドを呼び出すことで渡された配列での正しい位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Next, the observations in Celsius are converted to Fahrenheit:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次に、摂氏での観測は華氏に変換されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nil coalescing</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>nil合体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>No buffering storage is allocated and each traversal step invokes <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> on one or more underlying elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファするストレージが割り当てられること、そしてひとつひとつ見ていく各処理が１つまたはそれ以上の基盤となる要素上で<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出すことはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>No elements will be lost.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素が失われることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>No further bridging is required when accessing elements of the <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Array<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらなるブリッジは<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Array<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>インスタンスの要素にアクセスするとき全く必要とされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>No matter which way you call <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print<ph x="2">&lt;w2/&gt;</ph>Int(at<ph x="3">&lt;w3/&gt;</ph>Address:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, Swift’s type safety guarantees that you can only pass a pointer to the type required by the function—in this case, a pointer to an <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Int<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print<ph x="2">&lt;w2/&gt;</ph>Int(at<ph x="3">&lt;w3/&gt;</ph>Address:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出す方法は問題ではありません、Swiftの型安全は、あなたが関数によって要求される型へのポインタを渡すことだけが可能であるのを保証します — この場合、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Int<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>へのポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>None</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>なし</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Normally, you don’t need to be aware of the difference between concrete and existential metatypes, but calling <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>type(of:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> can yield unexpected results in a generic context with a type parameter bound to a protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>通常、あなたは具象と存在のメタタイプの間の違いを意識する必要はありません、しかし<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>type(of:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出すことは、あるプロトコルに束縛された型パラメータを伴うある総称体の文脈において予期しない結果を生み出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Not equal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>等しくない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Not identical</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同一でない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float80<ph x="2">&lt;w2/&gt;</ph>.significand<ph x="3">&lt;w3/&gt;</ph>Bit<ph x="4">&lt;w4/&gt;</ph>Count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is 63, even though 64 bits are used to store the significand in the memory representation of a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Float80<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> (unlike other floating-point types, <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Float80<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> explicitly stores the leading integral significand bit, but the <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Binary<ph x="11">&lt;w11/&gt;</ph>Floating<ph x="12">&lt;w12/&gt;</ph>Point<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> APIs provide an abstraction so that users don’t need to be aware of this detail).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float80<ph x="2">&lt;w2/&gt;</ph>.significand<ph x="3">&lt;w3/&gt;</ph>Bit<ph x="4">&lt;w4/&gt;</ph>Count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は63であることに注意してください、64ビットが使用されて仮数を<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Float80<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>メモリ表現に格納するとしてもです（他の浮動小数点型と違い、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Float80<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>は明示的に先頭整数仮数ビットを格納します、しかし<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Binary<ph x="11">&lt;w11/&gt;</ph>Floating<ph x="12">&lt;w12/&gt;</ph>Point<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>APIはある抽象化を提供します、それでユーザはこの詳細に通じている必要はありません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Finite<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>is<ph x="5">&lt;w5/&gt;</ph>Infinite<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> do not form a dichotomy, because they are not total: If <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Na<ph x="10">&lt;w10/&gt;</ph>N<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>, then both properties are <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>false<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Finite<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>is<ph x="5">&lt;w5/&gt;</ph>Infinite<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は二項対立を形作らないことに注意してください、なぜならそれらが全てではないからです：<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>x<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>が<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Na<ph x="10">&lt;w10/&gt;</ph>N<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>ならば、そのとき両方のプロパティとも<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>false<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that <bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>q<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept> is <bpt i="22" x="22">&lt;e22&gt;</bpt>not<ept i="22">&lt;/e22&gt;</ept> <bpt i="23" x="23">&lt;c23&gt;</bpt><bpt i="24" x="24">&lt;s24&gt;</bpt>x / y<ept i="24">&lt;/s24&gt;</ept><ept i="23">&lt;/c23&gt;</ept> computed in floating-point arithmetic, and that <bpt i="25" x="25">&lt;c25&gt;</bpt><bpt i="26" x="26">&lt;s26&gt;</bpt>q<ept i="26">&lt;/s26&gt;</ept><ept i="25">&lt;/c25&gt;</ept> may not be representable in any available integer type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>q<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept>が浮動小数点算術で計算される<bpt i="23" x="23">&lt;c23&gt;</bpt><bpt i="24" x="24">&lt;s24&gt;</bpt>x / y<ept i="24">&lt;/s24&gt;</ept><ept i="23">&lt;/c23&gt;</ept>では<bpt i="22" x="22">&lt;e22&gt;</bpt>ない<ept i="22">&lt;/e22&gt;</ept>こと、そして<bpt i="25" x="25">&lt;c25&gt;</bpt><bpt i="26" x="26">&lt;s26&gt;</bpt>q<ept i="26">&lt;/s26&gt;</ept><ept i="25">&lt;/c25&gt;</ept>は何らかの利用可能な整数型において表現可能でないかもしれないことに注意してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that in some cases the result may be <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>.Text(String(reflecting: subject))<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくらかの場合にはその結果は<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>.Text(String(reflecting: subject))<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>になるかもしれないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that in this example, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>image<ph x="2">&lt;w2/&gt;</ph>Paths<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is subscripted using a dictionary index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>image<ph x="2">&lt;w2/&gt;</ph>Paths<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が辞書インデックスを使って添え字をすることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that some elements in the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>temperature<ph x="2">&lt;w2/&gt;</ph>Data<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array are not valid numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>temperature<ph x="2">&lt;w2/&gt;</ph>Data<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列の幾つかの要素は有効な数字ではないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator provided by the standard library is used in this example, not the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&lt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> operator implemented above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリによって提供される<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子がこの例で使われることに注意してください、上で実装される<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&lt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>演算子ではなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array is suitably-aligned <bpt i="2" x="2">&lt;s2&gt;</bpt>raw memory<ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列は、<bpt i="2" x="2">&lt;s2&gt;</bpt>生のメモリ<ept i="2">&lt;/s2&gt;</ept>に適切に並べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the value may not be preserved, particularly when converting between signed to unsigned integer types or when the destination type has a smaller bit width than the source type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>注意すべきはその値が保たれないかもしれないことです、とりわけ符号付きから符号なし整数型への間の変換の場合、または行先の型が元の型より小さなビット幅を持つ場合には。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note: this property need not be implemented by conforming types, it has a default implementation in a protocol extension that just returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>注意：このプロパティは準拠する型で実装される必要はありません、それはプロトコル拡張において初期実装、単に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返すものを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now suppose you have an array of addresses that you need to check for a particular address.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>今あなたがいくらかの住所からなる配列、あなたがある特定の住所を確認する必要があるものを持つと仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now that <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Date<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, you can compare instances of the type with any of the relational operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>今や<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Date<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠します、あなたはこの型のインスタンスを関係演算子のどれででも比較できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now that <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Grid<ph x="2">&lt;w2/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Hashable<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol, you can create a set of previously tapped grid points.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Grid<ph x="2">&lt;w2/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Hashable<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルに準拠する今、あなたは以前にタップされた格子点の集合を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now that the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>shorter<ph x="2">&lt;w2/&gt;</ph>Indices<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array holds the indices of the shorter names in the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>names<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> set, you can use those indices to access elements in the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>現在、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>shorter<ph x="2">&lt;w2/&gt;</ph>Indices<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列は<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>names<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>集合の中のより短い名前のインデックスを保持します、あなたはそれらのインデックスを使ってこの集合の要素にアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Numbers and Basic Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数と基本的な値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Numeric Protocols</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数に関するプロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Numeric Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objects with a concrete type of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Object<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> maintain a specific dynamic type and can be cast to that type using one of the type-cast operators (<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>as<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>as?<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, or <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>as!<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>具象型として<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Object<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を持つオブジェクトは、特定の動的型を保守して、その型へと型キャスト演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>as<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>as?<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>。または<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>as!<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>）の１つを使ってキャストされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Obtain each separate iterator from separate calls to the sequence’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>make<ph x="2">&lt;w2/&gt;</ph>Iterator()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method rather than by copying.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのシーケンスのもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>make<ph x="2">&lt;w2/&gt;</ph>Iterator()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドへの独立した呼び出しから独立したイテレータを取得してください、コピーによってではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Often, the optimizer can eliminate bounds checks within an array algorithm, but when that fails, invoking the same algorithm on the buffer pointer passed into your closure lets you trade safety for speed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しばしば、最適化機能は配列アルゴリズム内部で境界検査を省くことができます、しかしそれが失敗する時、同じアルゴリズムをあなたのクロージャへ渡されるパッファポインタ上で発動することは、あなたに安全をスピードと交換させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On 32-bit platforms, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int64<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is the same size as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int6432<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, and on 64-bit platforms, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Int64<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is the same size as <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int6464<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>32ビットプラットホームでは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int64<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int6432<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と同じ大きさです、そして64ビットプラットホームでは、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Int64<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int6464<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>と同じ大きさです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On 32-bit platforms, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is the same size as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int32<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, and on 64-bit platforms, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Int<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is the same size as <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int64<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>32ビットプラットホーム上では、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int32<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と同じ大きさです、そして64ビットプラットホーム上では、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Int<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int64<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>と同じ大きさです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On 32-bit platforms, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt64<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is the same size as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>UInt6432<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, and on 64-bit platforms, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>UInt64<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is the same size as <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt6464<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>32ビットプラットホームでは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt64<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>UInt6432<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と同じ大きさです、そして64ビットプラットホームでは、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>UInt64<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt6464<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>と同じ大きさです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On 32-bit platforms, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is the same size as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>UInt32<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, and on 64-bit platforms, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>UInt<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is the same size as <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt64<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>32ビットプラットホーム上では、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>UInt32<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と同じ大きさです、そして64ビットプラットホーム上では、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>UInt<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt64<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>と同じ大きさです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On This Page</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この項には</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a big-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a big-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int16(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int16(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a big-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int32(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int32(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a big-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int64(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int64(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a big-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int8(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int8(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a big-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a big-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt16(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt16(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a big-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt32(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt32(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a big-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt64(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt64(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a big-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt8(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt8(big<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a big-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == x<ph x="4">&lt;w4/&gt;</ph>.big<ph x="5">&lt;w5/&gt;</ph>Endian<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == x<ph x="4">&lt;w4/&gt;</ph>.big<ph x="5">&lt;w5/&gt;</ph>Endian<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a little-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a little-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int16(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int16(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a little-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int32(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int32(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a little-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int64(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int64(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a little-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int8(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == Int8(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a little-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a little-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt16(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt16(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a little-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt32(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt32(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a little-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt64(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt64(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a little-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt8(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == UInt8(little<ph x="4">&lt;w4/&gt;</ph>Endian: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a little-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == x<ph x="4">&lt;w4/&gt;</ph>.little<ph x="5">&lt;w5/&gt;</ph>Endian<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リトルエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x == x<ph x="4">&lt;w4/&gt;</ph>.little<ph x="5">&lt;w5/&gt;</ph>Endian<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On removal, this method invalidates all indices with respect to the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>除去において、このメソッドはこの辞書に関するすべてのインデックスを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On the other hand, an emoji flag character is constructed from a pair of Unicode scalars values, like <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"\u{1F1F5}"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>"\u{1F1F7}"<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一方で、あるひとつのemoji国旗文字は一対のユニコードスカラー値から構築されます、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"\u{1F1F5}"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>"\u{1F1F7}"<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has been returned, all subsequent calls return <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一旦<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が返されるならば、すべての続いて起こる呼び出しは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>predicate<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> returns <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> it will not be called again.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いったん<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>predicate<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を返すならそれは再び呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once again, use pattern matching to conditionally catch errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>再び、パターンマッチを条件付きでエラーを捕まえるのに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once the predicate returns <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> it will not be called again.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いったん述部が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を返すならそれは再び呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One example is the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reduce1(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つの例は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reduce1(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One may assume <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rebased<ph x="2">&lt;w2/&gt;</ph>.start<ph x="3">&lt;w3/&gt;</ph>Index == 0<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rebased[0] == slice[n]<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>人は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rebased<ph x="2">&lt;w2/&gt;</ph>.start<ph x="3">&lt;w3/&gt;</ph>Index == 0<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> および <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rebased[0] == slice[n]<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> を当然と思うでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One of the values to multiply before adding to this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値に加えられる前に掛け合わされる値のうちの１つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Only the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Optional<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type conforms to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Expressible<ph x="6">&lt;w6/&gt;</ph>By<ph x="7">&lt;w7/&gt;</ph>Nil<ph x="8">&lt;w8/&gt;</ph>Literal<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Optional<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型だけが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Expressible<ph x="6">&lt;w6/&gt;</ph>By<ph x="7">&lt;w7/&gt;</ph>Nil<ph x="8">&lt;w8/&gt;</ph>Literal<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Only three types provided by Swift—<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bool<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Darwin<ph x="4">&lt;w4/&gt;</ph>Boolean<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Obj<ph x="7">&lt;w7/&gt;</ph>CBool<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>—are treated as Boolean values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftによって提供される３つの型—<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bool<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Darwin<ph x="4">&lt;w4/&gt;</ph>Boolean<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Obj<ph x="7">&lt;w7/&gt;</ph>CBool<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>—だけがブール値とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Only use this function to convert the instance passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to a layout-compatible type when the conversion is not possible through other means.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡されるインスタンスをレイアウト互換の型へと変換するのに、その変換が他の手段では可能でない場合にだけ使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Opaque pointers are used to represent C pointers to types that cannot be represented in Swift, such as incomplete struct types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>不透明ポインタは、Swiftでは表されることができない型、例えば不完全なstruct型などへのCポインタを表すために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operating on substrings is fast and efficient because a substring shares its storage with the original string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位文字列での演算は高速で効率的です、なぜなら下位文字列はそれのストレージを本来の文字列と共有するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operations on types conforming to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Floating<ph x="2">&lt;w2/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol should support this behavior, but they might also support other options.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Floating<ph x="2">&lt;w2/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型での演算はこの挙動をサポートします、しかしそれらはまた他の選択肢もサポートするかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operations with infinite values follow real arithmetic as much as possible: Adding or subtracting a finite value, or multiplying or dividing infinity by a nonzero finite value, results in infinity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無限大値を伴う演算は、実数算術にできうる限り従います：ある無限大値を加算や減算すること、または非ゼロの有限値によって無限に乗算や除算することは、無限大の結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operator Declarations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operator Functions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optimizations are sometimes applied that can reduce the amount of copying.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最適化は時折適用されて、コピー回数を減らすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Option Sets</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプションセット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Option set values have a one-to-one correspondence with their associated raw values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプションセット値それらは、それらの関連する生の値と一対一の対応を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Option sets all conform to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Raw<ph x="2">&lt;w2/&gt;</ph>Representable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> by inheritance using the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Option<ph x="5">&lt;w5/&gt;</ph>Set<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプションセットすべては、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Raw<ph x="2">&lt;w2/&gt;</ph>Representable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への準拠を<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Option<ph x="5">&lt;w5/&gt;</ph>Set<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルを使って継承することによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Option sets use bitwise operations on their associated raw values to implement their mathematical set operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプションセットは、ビット単位演算をそれらの関連する生の値上で使うことで、それらの数学的集合演算を実施します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>OptionSet Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>OptionSet 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional Binding</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル束縛</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional Chaining</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optionals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Order Dependent Operations on Dictionary</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書での順序依存演算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Order Dependent Operations on Set</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合での順序依存演算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other Initializers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他のイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other classes derived from such an ancestor are given a default mirror.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのような先祖から派生する別のクラスは、省略時のミラーを与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other than these signaling operations, a signaling NaN behaves in the same manner as a quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのシグナル演算の他は、シグナルNaNはクワイエットNaNと同じ流儀で振舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>ancestor<ph x="7">&lt;w7/&gt;</ph>Representation<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> determines whether ancestor classes will be represented and whether their <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>custom<ph x="10">&lt;w10/&gt;</ph>Mirror<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> implementations will be used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>ancestor<ph x="7">&lt;w7/&gt;</ph>Representation<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は先祖クラスらが表されるかどうかそしてそれらの<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>custom<ph x="10">&lt;w10/&gt;</ph>Mirror<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>実装が使われるかどうかを判断されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, a Unicode replacement character (<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"\u{FFFD}"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>) is inserted for each detected error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、ユニコード代用文字（<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"\u{FFFD}"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）が各検出エラーに対して挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, iteration will stop if an encoding error is detected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、反復はエンコーディングエラーが検出されるならば停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, returns a <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Playground<ph x="14">&lt;w14/&gt;</ph>Quick<ph x="15">&lt;w15/&gt;</ph>Look<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> synthesized for <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>subject<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> by the language.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Playground<ph x="14">&lt;w14/&gt;</ph>Quick<ph x="15">&lt;w15/&gt;</ph>Look<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>が言語によって<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>subject<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>のために合成されて返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, the result is generated by the language.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、結果は言語によって生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overview</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parameter: A metatype.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータ：あるメタタイプ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parameters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parameters args: An array of arguments to convert to a C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>va_list<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータ引数：引数の配列で、C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>va_list<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ポインタに変換されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parses the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as a text representation of a property list, returning an NSString, NSData, NSArray, or NSDictionary object, according to the topmost element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をプロパティリストのテキスト表現として構文解析します、１番上の要素に従って、NSString、NSData、NSArray、またはNSDictionaryオブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pass <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> If you do not need this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこの値を必要としないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pass <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if you do not need this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこの値を必要としないならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pass <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if you need the result to use only ASCII characters; otherwise, pass <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが結果にASCII文字のみ使うことを必要とするならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pass <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to create a new string, even when the data referenced by <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>c<ph x="4">&lt;w4/&gt;</ph>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> contains ill-formed sequences.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を渡すと、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>c<ph x="4">&lt;w4/&gt;</ph>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>によって参照されるデータが誤形式シーケンスを含む時であっても新しい文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pass <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to create a signaling NaN or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to create a quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シグナルNaNを作成するために<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、またはクワイエットNaNを作成するために<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pass <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to keep the existing capacity of the array after removing its elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を渡すと、この配列の既存の容量をそれの要素の削除後に保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pass <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to prevent the release of the string’s allocated storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を渡して文字列のもつ割り当てストレージの解放を防止してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pass <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to request that the collection avoid releasing its storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を渡して、コレクションがそのストレージを解放するのを回避するよう要求してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pass <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to stop translation when an encoding error is detected in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>input<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を渡すと、翻訳はエンコーディングエラーが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>input<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>において検出されるときに停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pass <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>false<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> to interrupt the creation of the new string if an ill-formed sequence is detected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>false<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>を渡すと新しい文字列の作成は、誤形式シーケンスが検出されるならば中断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pass a closure as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>combine<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> that selects which value to use in the returned dictionary, or to combine the values as the dictionary is initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>combine<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>クロージャを使って、どの値を返される辞書に使うか選択してください、またはそれら値を辞書が初期化されるときに結合してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pass a dictionary literal with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> keys as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>children<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使った辞書リテラルを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>children<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>として渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pass the greater-than operator (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>) operator as the predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より大きい（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）演算子を述部として渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Passing a NaN to an operation generally results in NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NaNをある演算に渡すことは、一般的にNaNという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Passing a sequence with no elements or an empty collection as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>possible<ph x="2">&lt;w2/&gt;</ph>Prefix<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> always results in <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>true<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つの要素もないシーケンスまたは空のコレクションを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>possible<ph x="2">&lt;w2/&gt;</ph>Prefix<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡すことは、常に<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>true<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Passing any other format or any additional characters as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>text<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> results in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何か他の形式または追加文字を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>text<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡すことは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Passing pointers to mutable arrays of ObjC class pointers is not directly supported.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ObjCクラスポインタの可変配列へポインタを渡すことは、直接にサポートされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Passing the collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> parameter results in an empty subsequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>パラメータとして渡すことは、空のシーケンスという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Passing the collection’s starting index as the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter results in an empty subsequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの開始インデックスを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータとして渡すことは、空のシーケンスという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Passing the same index as both <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>i<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>j<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> has no effect.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>i<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>j<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の両方と同じアンデックスを渡すことは、効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pattern Matching</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パターンマッチング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pattern match</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パターン・マッチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perform arithmetic and bitwise operations or compare values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>算術およびビット単位の演算を実行します、または値を比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perform casts between types or represent values of any type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型の間でキャストを実行したり、任意型の値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perform order-dependent operations common to all collections, as implemented for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべてのコレクションに共通の順序依存演算を、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して実装されたように実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perform order-dependent operations common to all collections, as implemented for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべてのコレクションに共通の順序依存演算を、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して実装されたように実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Perform string transliteration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列変換を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performance Optimizations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>性能最適化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performing Calculations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算の実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performing Calculations Without Bounds Checks</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>境界検査なしでの計算の実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performing Calculations with Overflow</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバーフローを伴う計算の実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performing Collection Operations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクション演算の実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performing Double-Width Calculations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２倍幅計算の実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performing Linguistic Tagging and Analysis</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>言語的タグ付けと分析を実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performing Typed Pointer Arithmetic</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付ポインタ算術を実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performing an invalid cast triggers a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>不正なキャストを行うことは実行時エラーの引き金になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performing truncating division with floating-point values results in a truncated integer quotient and a remainder.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>不動小数点値で切り捨て除算を実行することは、切り捨てられる整数指数と余りという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performs a logical AND operation on two Boolean values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理AND（積）演算を２つのブール値で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performs a logical NOT operation on a Boolean value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理否定演算をあるブール値上で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performs a logical OR operation on two Boolean values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理OR（和）演算を２つのブール値で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performs a nil-coalescing operation, returning the wrapped value of an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance or a default <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Optional<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>nil合体演算を実行します、ラップされた値の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスまたは省略時の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Optional<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performs a nil-coalescing operation, returning the wrapped value of an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance or a default value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>nil合体演算を実行します、ラップされた値の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスまたは省略時の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performs a traditional C-style assert with an optional message.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>随意のメッセージを持つ伝統的なC形式アサートを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performs an unbalanced autorelease of the object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクトのある不均衡なオートリリース（自動解放）を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performs an unbalanced release of the object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクトのある不均衡なリリース（解放）を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performs an unbalanced retain of the object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクトのある不均衡なリテイン（保持）を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performs linguistic analysis on the specified string by enumerating the specific range of the string, providing the Block with the located tags.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>言語学的分析を指定された文字列上で文字列の特定の範囲を列挙することによって実行します、位置決めタグを持つBlockを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Plain text.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレーンテキスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Playgrounds and the debugger will show a representation similar to the one used for instances of the kind indicated by the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Display<ph x="2">&lt;w2/&gt;</ph>Style<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> case name when the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Mirror<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is used for display.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレイグラウンドとデバッガは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Display<ph x="2">&lt;w2/&gt;</ph>Style<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ケース節名によって指し示される種類のインスタンスに対して使われるものに似た表現を<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Mirror<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が表示用に使われる時に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Please see <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Sequence<ph x="3">&lt;w3/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for background; <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Lazy<ph x="6">&lt;w6/&gt;</ph>Collection<ph x="7">&lt;w7/&gt;</ph>Protocol<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is an analogous component, but for collections.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>予備知識として<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Sequence<ph x="3">&lt;w3/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をぜひ見てください；<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Lazy<ph x="6">&lt;w6/&gt;</ph>Collection<ph x="7">&lt;w7/&gt;</ph>Protocol<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は、類似した、しかしコレクションのためのコンポーネントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pointer arithmetic with a typed pointer is counted in strides of the pointer’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付ポインタでのポインタ算術は、ポインタのもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のストライドで勘定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pointer arithmetic with raw pointers is performed at the byte level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生のポインタを使うポインタ算術は、バイト水準で実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pointers to Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値へのポインタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Positive infinity compares greater than every finite value and negative infinity, while negative infinity compares less than every finite value and positive infinity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正の無限大はすべての有限値と負の無限大より大きいと比較されます、一方負の無限大はすべての有限値と正の無限大より小さいと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Positive infinity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正の無限大</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Postcondition: The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>s at <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self[start<ph x="4">&lt;w4/&gt;</ph>Index..&lt;returned index]<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> are initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>事後条件：<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self[start<ph x="4">&lt;w4/&gt;</ph>Index..&lt;returned index]<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>での<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>らが初期化されること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Postfix operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後置演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precedence group</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>優先順位グループ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>!self<ph x="2">&lt;w2/&gt;</ph>.is<ph x="3">&lt;w3/&gt;</ph>Empty<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>!self<ph x="2">&lt;w2/&gt;</ph>.is<ph x="3">&lt;w3/&gt;</ph>Empty<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> do not alias each other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>a<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>b<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が互いのエイリアスでないこと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>buffer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is an instance of a non-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>@objc<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> class whose <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>deinit<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> destroys its stored <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Header<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> and any constructed <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Element<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>buffer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は非<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>@objc<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>クラスのインスタンスです、それの<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>deinit<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>はそれの格納された<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Header<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>とあらゆる構成された<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Element<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を破棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>minimum<ph x="2">&lt;w2/&gt;</ph>Capacity &gt;= 0<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, and the type indicated by <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>buffer<ph x="5">&lt;w5/&gt;</ph>Class<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is a non-<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>@objc<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> class with no declared stored properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>minimum<ph x="2">&lt;w2/&gt;</ph>Capacity &gt;= 0<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>buffer<ph x="5">&lt;w5/&gt;</ph>Class<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>によって示される型が非<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>@objc<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>クラスで宣言された保存プロパティを持たないこと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position == 0<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position == 0<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> indicates a valid position in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>position != end<ph x="6">&lt;w6/&gt;</ph>Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の中の有効な位置を指し示して<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>position != end<ph x="6">&lt;w6/&gt;</ph>Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>であること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is a valid position in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>position != end<ph x="6">&lt;w6/&gt;</ph>Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の中の有効な位置であり<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>position != end<ph x="6">&lt;w6/&gt;</ph>Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>であること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self != nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self != nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>v<ph x="2">&lt;w2/&gt;</ph>.value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> can be represented as ASCII (0..&lt;128).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>v<ph x="2">&lt;w2/&gt;</ph>.value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がASCII（0..&lt;128）として表現できること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x is T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x is T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: May not be called after a previous <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ph x="2">&lt;w2/&gt;</ph>.encode(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：前の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ph x="2">&lt;w2/&gt;</ph>.encode(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>呼び出しの後に呼び出されないこと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: May not be called after a prior <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ph x="2">&lt;w2/&gt;</ph>.container(keyed<ph x="3">&lt;w3/&gt;</ph>By:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：前の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ph x="2">&lt;w2/&gt;</ph>.container(keyed<ph x="3">&lt;w3/&gt;</ph>By:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>呼び出しの後に呼び出されないこと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: May not be called after a prior <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ph x="2">&lt;w2/&gt;</ph>.unkeyed<ph x="3">&lt;w3/&gt;</ph>Container()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：前の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ph x="2">&lt;w2/&gt;</ph>.unkeyed<ph x="3">&lt;w3/&gt;</ph>Container()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>呼び出しの後に呼び出されないこと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: May not be called after a value has been encoded through a previous <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ph x="2">&lt;w2/&gt;</ph>.single<ph x="3">&lt;w3/&gt;</ph>Value<ph x="4">&lt;w4/&gt;</ph>Container()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：前の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ph x="2">&lt;w2/&gt;</ph>.single<ph x="3">&lt;w3/&gt;</ph>Value<ph x="4">&lt;w4/&gt;</ph>Container()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>呼び出しを通してある値がエンコードされた後に呼び出されないこと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: The memory in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is uninitialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中のメモリが未初期化であること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: The next location exists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：次の場所が存在すること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: The next position is representable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：次の位置が表現可能であること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: The next position is valid.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：次の位置が有効であること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: The previous location exists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：前の場所が存在すること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: The previous position is valid.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：前の位置が有効であること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precondition: the pointee has been initialized with an instance of type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件：pointeeが型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスを使って初期化されていること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Prefix operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前置演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Prepares the collection to store the specified number of elements, when doing so is appropriate for the underlying type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数の要素を格納するようにコレクションを準備します、そうすることが基礎をなす型に対して適切である場合には。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Preserving an Array’s Geometric Growth Strategy</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の幾何数級的増大戦略を守る</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Print the result using the index found in step 2 on the original <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>absences<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>手順２で見つけたインデックスをオリジナル<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>absences<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列上で使って結果を出力してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Print the results using the indices found in steps 1 and 3 on the original <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>absences<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>手順１と手順３で見つけたインデックスをオリジナル<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>absences<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列上で使って結果を出力してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Print values to the console, read from and write to text streams, and use command line arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値をコンソールに出力し、テキストストリームから読み込みおよびそれへと書き出し、そしてコマンドライン引数を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Printing and Dumping</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プリントとダンプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Produces a string containing the bytes in a given C array, interpreted according to a given encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた符号化によって解釈される、与えられたC配列の中のバイトを含んでいる文字列を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Produces a string created by copying the data from a given C array of UTF8-encoded bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF8符号化されたバイトからなる与えられたC配列からコピーするデータによって作成される文字列を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Produces a string created by reading data from a given URL and returns by reference the encoding used to interpret the data.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>データを解釈するのに使われる符号化を参照渡しすることによって、与えられたURLからの読み込みデータによって作成される文字列を生成して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Produces a string created by reading data from a given URL interpreted using a given encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた符号化を使って解釈される、与えられたURLからの読み込みデータによって作成される文字列を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Produces a string created by reading data from the file at a given path and returns by reference the encoding used to interpret the file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ファイルを解釈するのに使われる符号化を参照渡しすることによって、与えられたパスからの読み込みデータによって作成される文字列を生成して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Produces a string created by reading data from the file at a given path interpreted using a given encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた符号化を使って解釈される、与えられたパスでのファイルからの読み込みデータによって作成される文字列を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Produces an initialized <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSString<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> object equivalent to the given <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>bytes<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> interpreted in the given <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>encoding<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>encoding<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>で解釈される与えられた<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>bytes<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に等しい、初期化された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSString<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>オブシェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Produces an initialized <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> object that contains a given number of bytes from a given buffer of bytes interpreted in a given encoding, and optionally frees the buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>オブシェクトを作成します、それは与えられた符号化での与えられたバイト解釈のバッファ由来の与えられた数のバイトを含んでいます、そして随意にそのバッファを解放します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Produces each element by passing the output of the <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Base<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Iterator<ph x="13">&lt;w13/&gt;</ph>Protocol<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> through a transform function returning <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Element<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各要素を生成するのを、<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Base<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Iterator<ph x="13">&lt;w13/&gt;</ph>Protocol<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>の出力を<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Element<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>を返す変換関数を通すことによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Programming Tasks</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プログラミング作業</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Proper alignment ensures that the result of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>distance(to:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> accurately measures the distance between the two pointers, counted in strides of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>適切なアライメントは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>distance(to:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の結果が正確に２つのポインタの間の隔たりを、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のストライドで数えて、測ることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Proper alignment ensures that the result of the subtraction operator (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>) accurately measures the distance between the two pointers, counted in strides of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>適切なアライメントは、減算演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）の結果が正確に２つのポインタの間の隔たりを、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のストライドで数えて、測ることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols, such as <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Collection<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> and <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Equatable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>, that describe common abstractions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル、たとえば<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Collection<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>そして<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Equatable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>など、それは共通の抽象化を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols, such as <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Custom<ph x="3">&lt;w3/&gt;</ph>Debug<ph x="4">&lt;w4/&gt;</ph>String<ph x="5">&lt;w5/&gt;</ph>Convertible<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> and <bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Custom<ph x="9">&lt;w9/&gt;</ph>Reflectable<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept>, that you use to customize operations that are available to all types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル、たとえば<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Custom<ph x="3">&lt;w3/&gt;</ph>Debug<ph x="4">&lt;w4/&gt;</ph>String<ph x="5">&lt;w5/&gt;</ph>Convertible<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>そして<bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Custom<ph x="9">&lt;w9/&gt;</ph>Reflectable<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept>など、あなたはそれを使って全ての型で利用可能である演算をカスタマイズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols, such as <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Option<ph x="3">&lt;w3/&gt;</ph>Set<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>, that you use to provide implementations that would otherwise require boilerplate code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル、たとえば<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Option<ph x="3">&lt;w3/&gt;</ph>Set<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>など、あなたはそれを使用してそうしなければ定型文コードを必要としただろう実装を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Provide a custom reflection for your types using these protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あつらえのリフレクションをあなたの型に対してこれらのプロトコルを使って提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Providing a Hash Value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ハッシュ値の提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Querying Descendants</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>子孫について問い合わせる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Querying Runtime Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実行時値の問い合わせ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Querying a Double</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Doubleに問い合わせる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Querying a Double's State</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Doubleの状態を問い合わせる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Querying a Float</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Floatに問い合わせる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Querying a Float's State</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Floatの状態を問い合わせる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Random-access collections can move indices any distance and measure the distance between indices in O(1) time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無作為アクセスのコレクションは、任意の隔たりのインデックスを移動できます、そしてインデックス間の隔たりの測定をO(1)時間で行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>RandomAccessCollection Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>RandomAccessCollection実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Range Expressions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Range-Checked Conversion</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲確認変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Range-replaceable collections provide operations that insert and remove elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲交換可能なコレクションは、いくつかの要素の挿入や削除を行う演算を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>RangeReplaceableCollection Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>RangeReplaceableCollection 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Ranges</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さまざまな範囲</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Raw Pointer Arithmetic</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生のポインタ算術</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Raw Pointers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生のポインタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Raw Representation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Raw memory that has just been allocated is in an <bpt i="0" x="0">&lt;e0&gt;</bpt>uninitialized, untyped<ept i="0">&lt;/e0&gt;</ept> state.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アロケートされてすぐの生のメモリは、<bpt i="0" x="0">&lt;e0&gt;</bpt>uninitialized, untyped<ept i="0">&lt;/e0&gt;</ept>状態にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Raw, Uninitialized Memory</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の、初期化されないメモリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reading from and writing to memory through a raw buffer are untyped operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある生のバッファを通してメモリから読み込むそしてそれへ書き込むことは、型無し演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reading from memory through a raw buffer is an untyped operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある生のバッファを通してメモリから読み込むことは、型無し演算のひとつです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reference Counting</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照カウント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reference Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reflect upon the given <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をリフレクションします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Related Array Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連した配列型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Related Documentation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連文書</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Related String Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連した文字列型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Related Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連する型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Relationships</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remainder</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>剰余</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remainder and assign</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>剰余と代入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes all elements from the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列からすべての要素を取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes all elements from the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全ての要素をコレクションから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes all elements of this option set that are not also present in the given set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このオプションセットに属し、また与えられたセットの中に含まれない、すべての要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes all key-value pairs from the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべてのキー値ペアを辞書から削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes all members from the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合からすべてのメンバを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes and returns the character at the specified position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された位置での文字を削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes and returns the element at the specified position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された位置での要素を削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes and returns the first element of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの最初の要素を削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes and returns the first element of the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合の最初の要素を削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes and returns the first key-value pair of the dictionary if the dictionary isn’t empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その辞書が空でないならば、辞書の中の最初のキー値ペアを削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes and returns the key-value pair at the specified index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー値ペアを指定されたインデックスで削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes and returns the last element of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の最後の要素を削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes and returns the last element of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの最後の要素を削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the characters in the given range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた範囲の中の文字を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the element at the given index of the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたインデックスでの集合の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the elements in the specified subrange from the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された下位範囲中のいくらかの要素をコレクションから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the elements of the given sequence from the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたシーケンスの要素を集合から削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the elements of the given set from this set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた集合の要素をこの集合から削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the elements of the set that are also in the given sequence and adds the members of the sequence that are not already in the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合の要素で与えられたシーケンスの中にもあるものを削除します、そしてシーケンスのメンバで集合の中にはまだないものを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the elements of the set that are also in the given set and adds the members of the given set that are not already in the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた集合の中にもあるこの集合の要素を削除します、そして与えられた集合のメンバでこの集合の中にはまだないものを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the elements of the set that aren’t also in the given sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたシーケンスの中にはない、この集合の要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the elements of this set that aren’t also in the given set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた集合の中にはない、この集合の要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the first element of the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合の最初の要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the given element and all elements subsumed by it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた要素とそれによって包括されるすべての要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the given element and any elements subsumed by the given element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた要素と、与えられた要素によって包括されるあらゆる要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the given key and its associated value from the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたキーと関連値を辞書から取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the given number of elements from the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた数の要素をコレクションの終わりから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the specified element from the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された要素を集合から削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the specified number of elements from the beginning of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数の要素をコレクションの始まりから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removes the specified number of elements from the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数の要素をコレクションの終わりから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removing Elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素の削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removing Keys and Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーと値の削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removing Substrings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位文字列の削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don’t match.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの要素を再配列します、例えば、与えられた述部にマッチする要素すべてが、合致しない要素すべての後になるなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Repeated Access</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>繰り返してアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Repeatedly calling this method returns all the elements of the underlying sequence in order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>繰り返しこのメソッドを呼び出すことは、基礎をなすシーケンスのすべての要素を順番に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Repeatedly calling this method returns, in order, all the elements of the underlying sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>繰り返しこのメソッドを呼び出すことは、基礎をなすシーケンスのすべての要素を、順番に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replace this set with the elements contained in this set or the given set, but not both.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合を、この集合または与えられた集合の中に含まれる、しかし両方にではない要素で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replaces a range of elements with the elements in the specified collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある範囲の要素を指定されたコレクションの要素で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replaces the characters within the specified bounds with the given characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された境界内のいくらかの文字を、与えられたいくらかの文字で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replaces the elements within the specified bounds with the given Unicode scalar values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された領域内の要素を与えられたユニコードスカラー値で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replaces the given index with its predecessor.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたインデックスをそれの前のものと取り替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replaces the memory referenced by this pointer with the values starting at the given pointer, leaving the source memory uninitialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタによって参照されるメモリを与えられたポインタで始まるいくらかの値と置き換えます、ソースメモリは未初期化のままです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replaces the specified subrange of elements with the given collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくらかの要素からなる指定された下位範囲を与えられたコレクションで置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replaces the text within the specified bounds with the given characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された領域内のテキストを与えられた幾らかの文字で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replaces this pointer’s initialized memory with the specified number of instances from the given pointer’s memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタのもつ初期化されたメモリを、指定されたポインタのもつメモリからの指定された数のインスタンスで置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replaces this set with a new set containing all elements contained in either this set or the given set, but not in both.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このセットを、このセットか与えられたセットのどちらかの中に、しかし両方ではなく、含まれるすべての要素を含んでいる新しいセットで置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replaces this string with the empty string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この文字列を空の文字列で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replaces this value with its additive inverse.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値をそれの加法の逆元で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replaces this value with its square root, rounded to a representable value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値をそれの平方根で置き換えます、表現可能な値に丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replaces this value with the remainder of itself divided by the given value using truncating division.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>切り捨て除算を使ってそれ自身を与えられた値で除算した余りでこの値を置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replaces this value with the remainder of itself divided by the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それ自身を与えられた値で除算した余りでこの値を置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Replacing Substrings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位文字列の置換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Represent <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with child values given by <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>unlabeled<ph x="4">&lt;w4/&gt;</ph>Children<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, using an optional <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>display<ph x="7">&lt;w7/&gt;</ph>Style<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>unlabeled<ph x="4">&lt;w4/&gt;</ph>Children<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>によって与えられる子で再表現します、オプショナルの<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>display<ph x="7">&lt;w7/&gt;</ph>Style<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Represent <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with labeled structure described by <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>children<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, using an optional <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>display<ph x="6">&lt;w6/&gt;</ph>Style<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>children<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によって記述されたラベル付き構造体を使って<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>subject<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を再表現します、オプショナルの<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>display<ph x="6">&lt;w6/&gt;</ph>Style<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Represent <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subject<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with structure described by <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>children<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, using an optional <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>display<ph x="6">&lt;w6/&gt;</ph>Style<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>children<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によって記述される構造体を使って<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>subject<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を再表現します、オプショナル<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>display<ph x="6">&lt;w6/&gt;</ph>Style<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Representation of ancestor classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>先祖クラスの表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Representation of the sub-structure and optional “display style” of any arbitrary subject instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位構造体の再表現、およびあらゆる随意の主題インスタンスのオプショナルの「表示形式」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Required Initializer</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>必須イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Required.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>必須。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reserves enough space in the character view’s underlying storage to store the specified number of ASCII characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数のASCII文字を格納するのに十分な空間を文字ビューのもつ基礎をなすストレージの中に確保します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reserves enough space in the string’s underlying storage to store the specified number of ASCII characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数のASCII文字を格納するのに十分な空間を文字列のもつ基礎をなすストレージの中に確保します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reserves enough space in the view’s underlying storage to store the specified number of ASCII characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数のASCII文字を格納するのに十分な空間をビューのもつ基礎をなすストレージの中に確保します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reserves enough space to store the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数の要素を格納するのに十分な空間を確保します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reserves enough space to store the specified number of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数のキー値ペアを格納するのに十分な空間を確保します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Retaining the collection’s storage can be a useful optimization when you’re planning to grow the collection again.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションのストレージを保持することは、あなたがコレクションをもう一度増大しようと計画している時に、ひとつの有益な最適化であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Retaining the storage can be a useful optimization when you’re planning to grow the string again.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ストレージを保持することは、あなたが文字列をもう一度増大しようと計画している時に、ひとつの有益な最適化であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Retrieve the localized description for this error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このエラーの現地語化された説明を取ってきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Retrieves and returns the referenced instance, returning the pointer’s memory to an uninitialized state.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照されたインスタンスを取ってきて返します、ポインタのメモリを初期化されない状態へ戻します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Return Value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>戻り値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Return a specific descendant of the reflected subject, or <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> Returns a specific descendant of the reflected subject, or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> if no such descendant exists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リフレクションされている主題の特定の子孫をまたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。リフレクションされている主題の特定の子孫を、またはそのような子孫が存在しないならば<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Return an iterator over the elements of this sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスの要素すべてに対するあるイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if this value is negative and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>1<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> if it’s positive; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>0<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値が負ならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>そしてそれが正ならば<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>1<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>；それ以外では<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>0<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> iff <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>t0<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is identical to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>t1<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>; i.e. if they are both <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> or they both represent the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>t0<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>t1<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と同一である場合に限り返します；すなわちそれらが両方とも<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>かまたはそれらが両方とも同じ型を表している場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the string was not found.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列が見つけられなかったならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, indicating that there are no more elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう要素は無いことを指し示す、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> contains <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>string<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, taking the current locale into account.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> contains <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>string<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を含んでいる場合にのみ返します、アカウントに対する現在のロケールをとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the arrays do not contain the same elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をそれらの配列がまったく同じ要素らを含むのでないならば返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if these arrays contain the same elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をそれらの配列がまったく同じ要素らを含むならば返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> iff <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is non-empty and contained within <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> by case-insensitive, non-literal search, taking into account the current locale.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が空でなく、大文字小文字を考慮しない、非リテラル検索によって<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に含まれる場合にのみ返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> iff <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is non-empty and contained within <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> by case-sensitive, non-literal search.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が空でなく、大文字小文字を考慮する、非リテラル検索によって<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に含まれる場合にのみ返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> iff <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> holds the only strong reference to its buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がそれのバッファへの強い参照を保持する場合に限り<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> iff <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>t0<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is identical to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>t1<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>; i.e. if they are both <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> or they both represent the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>t0<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>t1<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と同一である場合に限り返します；すなわちそれらが両方とも<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>かまたはそれらが両方とも同じ型を表している場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>CVa<ph x="2">&lt;w2/&gt;</ph>List<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that is backed by autoreleased storage, built from the given array of arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オートリリースされるストレージによって裏付けられる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>CVa<ph x="2">&lt;w2/&gt;</ph>List<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します、いくらかの引数からなる与えられた配列から組み立てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Data<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> containing a representation of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> encoded using a given encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Data<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します、与えられた符号化を使って符号化される<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の表現を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance for decoding <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>super<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> from the container associated with the default <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>super<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>super<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>をデコードするために、省略時<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>super<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>キーと結び付けられるコンテナから返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance for decoding <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>super<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> from the container associated with the given key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>super<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>をデコードするための<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを、指定のキーと結び付けられるコンテナから返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Map<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> over this <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を覆う<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Map<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Map<ph x="3">&lt;w3/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> over this <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Sequence<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Sequence<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を覆う<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Map<ph x="3">&lt;w3/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> such that <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self<ph x="6">&lt;w6/&gt;</ph>.distance(to: x)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> approximates <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>n<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返します、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self<ph x="6">&lt;w6/&gt;</ph>.distance(to: x)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>n<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>の近似となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initialized by converting given <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>data<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> into Unicode characters using a given <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>encoding<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します、それは与えられた<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>data<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>をユニコード文字へと、与えられた<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>encoding<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を使って変換することによって初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> object initialized by using a given format string as a template into which the remaining argument values are substituted according to given locale information.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた書式化文字列をテンプレートとして使って残りの引数値がそれに対する代用とされることによって初期化される<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>オブジェクトを返します、与えられたロケール情報に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> object initialized by using a given format string as a template into which the remaining argument values are substituted according to the user’s default locale.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた書式化文字列をテンプレートとして使ってユーザの省略時のロケールに従って残りの引数値がそれに対する代用とされることによって初期化される<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> object initialized by using a given format string as a template into which the remaining argument values are substituted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた書式化文字列をテンプレートとして使って残りの引数値がそれに対する代用とされることによって初期化される<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether a value is included in a range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値が範囲に含まれるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether any corresponding components of the two tuples are not equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのタプルの対応する構成要素いずれかが等しくないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the corresponding components of two tuples are equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのタプルの対応する構成要素らが等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the first argument represents a position before the second argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の引数が２番目の引数の前の位置を表すかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the first pointer references an earlier memory location than the second pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初のポインタが２番目のポインタより前のメモリ位置かどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the first tuple is ordered after or the same as the second in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>語彙筆記的順序において最初のタプルが２番目の後ろまたはそれと同じ順序かかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the first tuple is ordered after the second in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>語彙筆記的順序において最初のタプルが２番目の後ろの順序かかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the first tuple is ordered before or the same as the second in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>語彙筆記的順序において最初のタプルが２番目の前またはそれと同じ順序かかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the first tuple is ordered before the second in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>語彙筆記的順序において最初のタプルが２番目の前の順序かかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the given element is contained within the range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた要素がこの範囲内に含まれるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the given object is known to have a single strong reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるブール値を返して、与えられたオブジェクトが１つだけ強い参照を持つことを知られるかどうかを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの最初の要素らが別のシーケンスの中の要素らと同等かどうかを、与えられた述部を同等性テストとして使って指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの最初の要素らが別のシーケンスの中の要素らと同じかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された述部を満足させるある要素をシーケンスが含むかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the sequence contains the given element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された要素をシーケンスが含むかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスが別のシーケンスの前に来るかどうかをある語彙筆記的順序（辞書）順序において、与えられた述部を使って要素を比較して、指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to compare elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのシーケンスが別のシーケンスの前に来るかどうかを、ある語彙筆記的順序（辞書）順序において、より小さい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って要素を比較して、指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the specified code unit is a UTF-8 continuation byte.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたコード単位がUTF-8継続バイトかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the specified code unit is a high-surrogate code unit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたコード単位が上位サロゲートコード単位かどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the specified code unit is a low-surrogate code unit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたコード単位が下位サロゲートコード単位かどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the string begins with the specified prefix.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列が指定された接頭辞で始まるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the string ends with the specified suffix.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列が指定された接尾辞で終わるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the two arguments are equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの引数が等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the two arguments are not equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの引数が等しくないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the two given values are equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの与えられた値が等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the two given values are not equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの与えられた値が等しくないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の引数の値が２番目の引数のそれより大きいまたは等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の引数の値が２番目の引数のそれより大きいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の引数の値が２番目の引数のそれより少ないまたは等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether the value of the first argument is less than that of the second argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の引数の値が２番目の引数のそれより少ないかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether this instance is equal to the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスが与えられた値と等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether this instance is less than or equal to the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスが与えられた値より小さいまたは等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether this instance is less than the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスが与えられた値より小さいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether this instance should precede the given value in an ascending sort.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスがある昇順ソートにおいて与えられた値より前にくるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether this range and the given range contain an element in common.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この範囲と与えられた範囲がある要素を共通に含むかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements, using the given predicate as the equivalence test.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスともう一方のシーケンスが同等の要素を含むかどうかを、与えられた述部を同等テストとして使って指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスともう一方のシーケンスが同じ要素を同じ順序で含むかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether two arguments match by value equality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるブール値を返します、２つの引数が値等式によって一致するかどうかを指し示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether two indices wrap equal underlying indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのインデックスが等しい基礎をなすインデックスをラップするかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether two optional instances are equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのオプショナルインスタンスが等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether two optional instances are not equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのオプショナルインスタンスが等しくないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether two pointers are equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのポインタが等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether two ranges are equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの範囲が等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether two references point to different object instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの参照が異なるオブジェクトインスタンスを指しているかどうかを示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether two references point to the same object instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの参照が同じオブジェクトインスタンスを指しているかどうかを示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether two sets have equal elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの集合がまったく等しい要素らを持つかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether two type-erased hashable instances wrap the same type and value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの型消去ハッシュ化インスタンスが同じ型および値をラップするかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether two values are equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値が等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value indicating whether two values are not equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値が等しくないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether a given element is a member of the option set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた要素がオプションセットのメンバであるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> can be converted to a given encoding without loss of information.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が与えられた符号化に情報の損失なしに変換できるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether the given element exists in the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた要素が集合の中の存在するかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether the set has no members in common with the given sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合は与えられたシーケンスと共通のメンバを１つも持たないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether the set has no members in common with the given set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合が、与えられた集合と共通のメンバを１つも持たないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether the set is a strict subset of the given sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合は与えられたシーケンスの狭義の下位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether the set is a strict superset of the given sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合は与えられたシーケンスの狭義の上位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether the set is a subset of another set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合は別の集合の下位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether the set is a subset of the given sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合は与えられたシーケンスの下位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether the set is a superset of the given sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合は与えられたシーケンスの上位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether the set is a superset of the given set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合が、与えられた集合の上位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether this set has no members in common with the given set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合は与えられた集合と共通のメンバを１つも持たないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether this set is a strict subset of the given set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合は与えられた集合の狭義の下位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether this set is a strict superset of the given set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合は与えられた集合の狭義の上位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether this set is a subset of the given set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合は与えられた集合の下位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a Boolean value that indicates whether this set is a superset of the given set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合は与えられた集合の上位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a capitalized representation of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> using the specified locale.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の頭文字表現を指定されたロケールを使って返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a closed range that contains both of its bounds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの境界の両方を含む完結範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a collection representing a contiguous sub-range of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のもつ要素の隣接している下位範囲を表すコレクションを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a copy of this range clamped to the given limiting range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた限界範囲に締め金具で留められる（制限を課される）、この範囲のコピーを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a countable closed range that contains both of its bounds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの境界の両方を含む可付番完結範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a countable half-open range that contains its lower bound but not its upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの下側の境界は含むがそれの上側の境界はそうしない可付番半開範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a countable partial range extending upward from a lower bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある下側境界から上方へと拡張している可付番部分範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a dictionary object initialized with the keys and values found in the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>において見つけられるキーと値で初期化される辞書オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a half-open range that contains its lower bound but not its upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの下側の境界は含むがそれの上側の境界はそうしない半開範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a human-readable string giving the name of a given encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた符号化の名前を与えている、人間が読む文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a lazy collection of the initial consecutive elements that satisfy <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を満足させる、冒頭の隣接要素からなるある遅延コレクションを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a lazy collection that skips any initial elements that satisfy <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を満足させる、あらゆる冒頭の要素を省くある遅延コレクションを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a lazy sequence of the initial consecutive elements that satisfy <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を満足させる、冒頭の隣接要素からなるある遅延シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a lazy sequence that concatenates the elements of this sequence of sequences.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスに属する複数のシーケンスの要素を鎖状に連結する遅延シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a lazy sequence that skips any initial elements that satisfy <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を満足させる、あらゆる冒頭の要素を省くある遅延シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a lowercase version of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の小文字バージョンを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a mirror that reflects the UTF-16 view of a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のUTF-16ビューを反映するミラーを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a mirror that reflects the UTF-8 view of a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のUTF-8ビューを反映するミラーを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a mirror that reflects the Unicode scalars view of a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のユニコードスカラービューを反映するミラーを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オリジナルのコレクションの要素で与えられた述部を満たすものを、順序正しく、含んでいる同じ型の新しいコレクションを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new dictionary containing the key-value pairs of the dictionary that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この辞書のキー値ペアで与えられた述部を満たすものを含んでいる新しい辞書を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new dictionary containing the keys of this dictionary with the values transformed by the given closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクロージャによって変形された値とともに、この辞書のキーを含んでいる新しい辞書を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new dictionary created by merging the key-value pairs in the given sequence into the dictionary, using a combining closure to determine the value for any duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたシーケンスの中のキー値ペアをこの辞書へと結合することによって作成される新しい辞書を返します、結び付けられているクロージャを使ってあらゆる重複キーに対する値を特定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new instance of the given type, constructed from the raw memory at the specified offset.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた型の新しいインスタンスを返します、生のメモリから指定されたオフセットで構築されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new instance of the given type, read from the buffer pointer’s raw memory at the specified byte offset.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた型の新しいインスタンスを返します、バッファポインタの生のメモリから指定されたバイトオフセットで読み込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new option set of the elements contained in this set, in the given set, or in both.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このセットの中に、与えられたセットの中に、または両方の中に、含まれる要素からなる新しいオプションセットを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new option set with only the elements contained in both this set and the given set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このセットと与えられたセットの両方の中に含まれる要素だけを持つ新しいオプションセットを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new option set with the elements contained in this set or in the given set, but not in both.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このセットの中にまたは与えられたセットの中に、しかし両方の中にではなく、含まれる要素からなる新しいオプションセットを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new set containing the elements of the set that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合の要素で与えられた述部を満たすものを含んでいる新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new set containing the elements of this set that do not occur in the given sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたシーケンスの中の現れないこの集合の要素を含んでいる新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new set containing the elements of this set that do not occur in the given set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた集合の中の現れないこの集合の要素を含んでいる新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new set with the elements of both this and the given set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これと与えられた集合の両方の要素を持つ新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new set with the elements of both this set and the given sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合と与えられたシーケンスの両方の要素を持つ新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new set with the elements that are common to both this set and the given sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合と与えられたシーケンスの両方に共通である要素を持つ新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new set with the elements that are common to both this set and the given set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合と与えられた集合の両方に共通である要素を持つ新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new set with the elements that are either in this set or in the given sequence, but not in both.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合の中か与えられたシーケンスの中かどちらかの、しかし両方の中にではない要素を持つ新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new set with the elements that are either in this set or in the given set, but not in both.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合の中か与えられた集合の中かどちらかの、しかし両方の中にではない要素を持つ新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new string by concatenating the elements of the sequence, adding the given separator between each element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各要素の間に与えられたセパレータを加えて、シーケンスの要素を連結することによる新しい文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new string containing the characters of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> from the one at a given index to the end.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたインデックスでのものから終わりまでの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の文字を含んでいる新しい文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new string containing the characters of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> up to, but not including, the one at a given index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたインデックスでのものに至るまでの、しかしそれを含んでいない、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の文字を含んでいる新しい文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new string formed from the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> by either removing characters from the end, or by appending as many occurrences as necessary of a given pad string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>終わりから文字を削除することによって、または与えられた詰め物文字列を必要なだけ現れるよう加えることによって、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から書式化された新しい文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new string in which all occurrences of a target string in a specified range of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are replaced by another given string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい文字列を返します、そこにおいて指定された範囲の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中の目標文字列のすべての出現は、別の指定された文字列によって置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new string in which the characters in a specified range of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are replaced by a given string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい文字列を返します、そこにおいて指定された範囲の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中の文字は与えられた文字列によって置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new string made by appending a given string to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字列を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に追加することによって作られる新しい文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new string made by removing from both ends of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> characters contained in a given character set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字集合の中に含まれる文字を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の両端から削除することによって作られる新しい文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new string made by replacing in the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> all percent escapes with the matching characters as determined by a given encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>において全てのパーセントエスケープを、与えられた符号化によって決定されるとき、マッチする文字で置き換えることによって作られる新しい文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new string made from the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> by replacing all characters not in the specified set with percent encoded characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された集合の中にないすべての文字をパーセントエンコード文字で置き換えることによって、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から作成される新しい文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new string made from the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> by replacing all percent encoded sequences with the matching UTF-8 characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべてのパーセントエンコードシーケンスを合致するUTF-8文字で置き換えることによって、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から作成される新しい文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a new value advanced by the given distance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたインスタンスによって引き上げられる新しい値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a newly allocated buffer with the given size, in bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた大きさで新しくアロケートされたバッファを、バイトで返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a partial range extending upward from a lower bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下側の境界から上方に拡張している部分的な範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a partial range up to, and including, its upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの上側の境界までの、そしてそれを含む部分的な範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a partial range up to, but not including, its upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの上側の境界までの、しかしそれを含んでいない、部分的な範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a pointer offset from this pointer by the specified number of bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタから指定されたバイト数をオフセットしたポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a pointer offset from this pointer by the specified number of instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタから指定された数のインスタンスだけオフセットしたポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a pointer to the next consecutive instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の隣接インスタンスへのポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a pointer to the previous consecutive instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前の隣接インスタンスへのポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a representation of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as a C string using a given encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた符号化を使っているC文字列としての<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の表現を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a representation of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> using a given encoding to determine the percent escapes necessary to convert the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> into a legal URL string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のある表現を返します、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を合法なURL文字列へ変換するのに必要なパーセントエスケープを決定するのに与えられた符号化を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a sequence formed from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and repeated lazy applications of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>next<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>からそして繰り返し<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>next<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を遅延適用して形成されたシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a sequence formed from repeated lazy applications of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to a mutable <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>state<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>繰り返し<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を可変の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>state<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に遅延適用することから形成されたシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a sequence of pairs (<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>, <bpt i="1" x="1">&lt;e1&gt;</bpt>x<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> represents a consecutive integer starting at zero, and <bpt i="3" x="3">&lt;e3&gt;</bpt>x<ept i="3">&lt;/e3&gt;</ept> represents an element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ベア (<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>, <bpt i="1" x="1">&lt;e1&gt;</bpt>x<ept i="1">&lt;/e1&gt;</ept>) のシーケンスを返します、そこで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>はゼロで開始する連続した数を表します、そして<bpt i="3" x="3">&lt;e3&gt;</bpt>x<ept i="3">&lt;/e3&gt;</ept>はシーケンスの要素を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a stride <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> such that <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ph x="4">&lt;w4/&gt;</ph>.advanced(by: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> approximates <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>other<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>進み幅<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ph x="4">&lt;w4/&gt;</ph>.advanced(by: x)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>other<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の近似となります（otherはラベルtoで指定されるもの？）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a string containing characters the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and a given string have in common, starting from the beginning of each up to the first characters that aren’t equivalent.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と与えられた文字列が共通して持っている文字を、それぞれの開始点から始めて等しくない最初の文字に至るまで含んでいる文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a string created by using a given format string as a template into which the remaining argument values are substituted according to the user’s default locale.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた書式化文字列をテンプレートとして使ってユーザの省略時のロケールに従って残りの引数値がそれに対する代用とされることによって作成される文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a string made by appending to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> a string constructed from a given format string and the following arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に、ある与えられたフォーマット文字列と続く引数から構築される文字列を加えることで作られる文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a string made by normalizing the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>’s contents using Form C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のもつ内容を形式Cを使って正規化することによって作られる文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a string made by normalizing the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>’s contents using Form D.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のもつ内容を形式Dを使って正規化することによって作られる文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a string made by normalizing the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>’s contents using Form KC.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のもつ内容を形式KCを使って正規化することによって作られる文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a string made by normalizing the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>’s contents using Form KD.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のもつ内容を形式KDを使って正規化することによって作られる文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a string object containing the characters of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that lie within a given range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた範囲内に横たわる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の文字を含んでいる文字列オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a string read from standard input through the end of the current line or until EOF is reached.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準入力から現在の行の終わりまでまたはEOFが到達されるまで読み込んだ文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a string representation of the Unicode scalar.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードスカラーの文字列表現を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a string with the given character folding options applied.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字フォールディングオプションが適用された状態の文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence by skipping elements while <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> returns <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and returning the remaining elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返す間は要素を飛ばして残りの要素を返すことによって、ある下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence by skipping the initial, consecutive elements that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた述部を満たす、冒頭の、隣接する要素を飛ばすことによる下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence containing all but the first element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの最初の要素以外すべてを含んでいる下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence containing all but the given number of final elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた数の末尾要素以外すべてを含んでいる下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence containing all but the given number of initial elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数の冒頭要素以外すべてを含んでいる下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence containing all but the last element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの最後の要素以外すべてを含んでいる下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence containing all but the specified number of final elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された数の末尾要素以外すべてを含んでいる下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence containing the initial elements until <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> returns <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and skipping the remaining elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返すまで冒頭の要素を含んでいて残りの要素を飛ばしている、ある下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence containing the initial, consecutive elements that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた述部を満たす、冒頭の、隣接する要素を含んでいる下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence from the specified position to the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された位置からコレクションの終わりまでの下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence from the start of the collection through the specified position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの始まりから指定された位置までも含む下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence from the start of the collection up to, but not including, the specified position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの始まりから指定された位置まで、しかしそれは含めない下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence, up to the given maximum length, containing the final elements of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位シーケンスを、指定された最大長まで、コレクションの末尾の要素を含めて返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence, up to the given maximum length, containing the final elements of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位シーケンスを、指定された最大長まで、シーケンスの末尾の要素を含めて返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位シーケンスを、指定された最大長まで、コレクションの冒頭の要素を含めて返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a subsequence, up to the specified maximum length, containing the initial elements of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位シーケンスを、指定された最大長まで、シーケンスの冒頭の要素を含めて返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a tuple containing the quotient and remainder of dividing the first argument by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の引数を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>で除算した商と余りを含んでいるタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a typed pointer to the memory referenced by this pointer, assuming that the memory is already bound to the specified type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタによって参照されるメモリに対する型付ポインタを返します、メモリがすでに指定された型へ束縛されると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a value less than or equal to the number of elements in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;s2&gt;</bpt>nondestructively<ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素数より少ないか等しい値を返します、<bpt i="2" x="2">&lt;s2&gt;</bpt>非破壊的<ept i="2">&lt;/s2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a value less than or equal to the number of elements in the sequence, nondestructively.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの要素数より少ないか等しい値を返します、非破壊的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a version of the string with all letters converted to lowercase, taking into account the specified locale.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての文字が小文字に変換される、この文字列の変形版を返します、指定されたロケールを考慮に入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a version of the string with all letters converted to uppercase, taking into account the specified locale.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての文字が大文字に変換される、この文字列の変形版を返します、指定されたロケールを考慮に入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns a view presenting the elements of the collection in reverse order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの要素を逆順に表しているある見方を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an Array of the encodings string objects support in the application’s environment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アプリケーションの環境においてサポートされる符号化文字列オブジェクトの配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an array containing substrings from the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that have been divided by a given separator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>からの下位文字列のいくつかを含んでいる配列を返します、それは与えられた分離記号によって分割されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an array containing substrings from the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that have been divided by characters in a given set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>からの下位文字列のいくつかを含んでいる配列を返します、それは与えられた集合の中の文字によって分割されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an array containing the concatenated results of calling the given transformation with each element of this sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された変換をこのシーケンスの各要素で呼び出す結果を連結したものを含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an array containing the elements of this sequence in reverse order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスの要素を逆順に含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an array containing the non-<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> results of calling the given transformation with each element of this sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された変換をこのシーケンスの各要素で呼び出す結果で非-<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のものを含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an array containing the results of mapping the given closure over the sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの要素全体にわたって与えられたクロージャをマップする結果を含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された述部を満足させるものであるシーケンスの要素を、順序通りに、含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an array of linguistic tags for the specified range and requested tags within the receiving string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>受け取っている文字列内で指定された範囲と要求されたタグに対する言語学的タグからなる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an empty iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空のイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an encoding container appropriate for holding a single primitive value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単一プリミティブ値を保持するのに適切なエンコーディングコンテナを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an encoding container appropriate for holding multiple unkeyed values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数のキー付けされない値を保持するのに適切なエンコーディングコンテナを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an encoding container appropriate for holding multiple values keyed by the given key type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたキー型によってキー付けされる複数の値を保持するのに適切なエンコーディングコンテナを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたインデックスから指定された隔たりのインデックスを返します、その隔たりが与えられた限界インデックスを超えない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an index that is the specified distance from the given index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたインデックスから指定された隔たりのインデックスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an initialized <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> object that contains a given number of characters from a given array of UTF-16 Code Units</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>オブジェクトを返します、それは与えられた数の文字をユニコード文字からなる与えられた配列から含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an initialized <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> object that contains a given number of characters from a given array of Unicode characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>オブジェクトを返します、それは与えられた数の文字をユニコードスカラーからなる与えられた配列から含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an iterator over the Unicode scalars that make up this view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このビューから構成される幾らかのユニコードスカラーのすべてを対象とするイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an iterator over the bytes of this sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスのバイトすべてを対象としたあるイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an iterator over the dictionary’s key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書のキー値ペアすべてを対象とするイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an iterator over the elements of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの要素すべてを対象としたイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an iterator over the elements of this buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このパッファの要素すべてを対象としたイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an iterator over the elements of this collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションの要素すべてを対象としたイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an iterator over the elements of this sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスの要素すべてを対象としたあるイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an iterator over the members of the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合のメンバすべてを対象とするイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an iterator to any elements of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>source<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> that didn’t fit in the buffer, and an index to the point in the buffer one past the last element written (so <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>start<ph x="6">&lt;w6/&gt;</ph>Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> if no elements written, <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>end<ph x="9">&lt;w9/&gt;</ph>Index<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> if the buffer was completely filled).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>source<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の何らかの要素でバッファに収まらないものに対するイテレータ、および書き込まれた最後の要素を１つ過ぎた地点に対するインデックス（つまり書き込まれた要素がないならば<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>start<ph x="6">&lt;w6/&gt;</ph>Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、バッファが完全に満たされたならば<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>end<ph x="9">&lt;w9/&gt;</ph>Index<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>）を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns an uppercase version of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の大文字バージョンを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns by reference the beginning of the first line and the end of the last line touched by the given range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた範囲による最初の行の始まりと到達される最後の行の終わりを参照渡しによって返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns by reference the beginning of the first paragraph and the end of the last paragraph touched by the given range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた範囲による最初の段落の始まりと到達される最後の段落の終わりを参照渡しによって返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns nil if <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>from<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is nil.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>from<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がnilならばnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the C-string encoding assumed for any method accepting a C string as an argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C文字列を引数として受け入れる何らかのメソッドのために仮定されるC文字列符号化を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the absolute value of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の絶対値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the absolute value of the given number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた数の絶対値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the actual number of matching paths.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>マッチするパスの実数値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the additive inverse of the specified value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された値の加法の逆元を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the bits of the given instance, interpreted as having the specified type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたインスタンスのビットを返します、指定された型を持つと解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the concatenated elements of this sequence of sequences, inserting the given separator between each element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各要素の間に与えられたセパレータを挿入して、このシーケンスに属する複数のシーケンスの要素を鎖状に連結して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the concatenated results of mapping the given transformation over this collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた変換をこのコレクション全体にわたってマッピングする結果を鎖状に連結して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the concatenated results of mapping the given transformation over this sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた変換をこのシーケンス全体にわたってマッピングする結果を鎖状に連結して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the contiguous memory footprint of the given instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたインスタンスの隣接メモリフットプリントを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the data stored for the given key as represented in a container keyed by the given key type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたキーに対して格納されるデータを、与えられたキー型によってキー付けされるコンテナの中に表される通りに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the data stored for the given key as represented in an unkeyed container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたキーに対して格納されるデータを、キー無しコンテナにおいて表現される通りに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the data stored in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as represented in a container appropriate for holding a single primitive value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中に格納されるデータを、単一プリミティブ値を保持するのに適したコンテナの中に表現される通りに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the data stored in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as represented in a container appropriate for holding values with no keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中に格納されるデータを、キーなしで値を保持するのに適したコンテナの中に表現される通りに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the data stored in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as represented in a container keyed by the given key type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中に格納されるデータを、与えられたキー型によってキー付けされるコンテナの中に表現された通りに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the default memory alignment of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の省略時のメモリアライメントを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the difference of the two given values, discarding any overflow.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの与えられた値の差を、あらゆるオーバーフローを廃棄して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the difference of this value and the given value along with a flag indicating whether overflow occurred in the operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と与えられた値の差、それに加えてオーバーフローがその演算において起こったかどうかを示すフラグを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the difference of this value and the given value without checking for arithmetic overflow.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と与えられた値の差を、算術オーバーフローの検査なしに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the distance between two indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのインデックス間の隔たりを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the distance between two pointers, counted as instances of the pointers’ <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのポインタの間の隔たりを返します、ポインタのもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスで数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the distance from this pointer to the given pointer, counted as instances of the pointer’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタから与えられたポインタまでの隔たりを返します、ポインタのもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスとして数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the distance from this pointer to the given pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタから与えられたポインタまでの隔たりを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the distance from this value to the specified value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値から指定された値までの隔たりを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the dynamic type of a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値の動的型を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the elements of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that satisfy <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>is<ph x="4">&lt;w4/&gt;</ph>Included<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素で<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>is<ph x="4">&lt;w4/&gt;</ph>Included<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を満足させるものを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the elements of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that satisfy <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>predicate<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素で<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>predicate<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を満足させるものを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the elements of the collection in reverse order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの要素を逆順に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the elements of the collection, sorted using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの要素を返します、与えられた述部を要素間の比較として使ってソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the elements of the collection, sorted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの要素を、ソートして、返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた述部を要素間の比較として使ってソートされた、シーケンスの要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the elements of the sequence, sorted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの要素を、ソートして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the elements of this collection of collections, concatenated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションに属する複数のコレクションの要素を、鎖状に連結して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the elements of this sequence of sequences, concatenated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスに属する複数のシーケンスの要素を、鎖状に連結して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the fastest encoding to which the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> may be converted without loss of information.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が情報の損失無しに変換されるであろう最速の符号化を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the first element of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> if <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の最初の要素を、または<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が空ならば<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the first element of the sequence that satisfies the given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた述部を満たすこのシーケンスの最初の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the first index in which an element of the collection satisfies the given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初のインデックスで、それにおけるコレクションの要素が与えられた述部を満足させるものを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the first index where the specified value appears in the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された値がコレクションにおいて現れるところの最初のインデックスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the given integer as the equivalent value in a different integer type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた整数を同等値として異なる整数型において返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the greater of the two given values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの与えられた値の大きい方を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the greater of two comparable values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの比較可能な値のうちより大きいものを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the greatest argument passed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>渡された引数の最も大きいものを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the high-surrogate code unit of the surrogate pair representing the specified Unicode scalar.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたユニコードスカラーを表しているサロゲートペアの上位サロゲートコード単位を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the index for the given key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたキーに対するインデックスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the index of the given element in the set, or <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the element is not a member of the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた要素の集合の中のインデックス、またはその要素が集合のメンバでないならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the inverse of the bits set in the argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数におけるビットの逆順を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the least argument passed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>渡された引数の最も少ないものを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the lesser of the two given values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの与えられた値のより小さい方を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the lesser of two comparable values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの比較可能な値のうちより小さいものを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the longest possible subsequences of the collection, in order, around elements equal to the given element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた要素と等しい要素を避けるようにして、このコレクションの最も長くなりうる下位シーケンスを、順番に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the longest possible subsequences of the collection, in order, that don’t contain elements satisfying the given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた述部を満たす要素を含んでいない、このコレクションの最も長くなりうる下位シーケンスそれらを順序どおりに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the longest possible subsequences of the sequence, in order, around elements equal to the given element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた要素と等しい要素を避けるようにして、このシーケンスの最も長くなりうる下位シーケンスを、順番に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the longest possible subsequences of the sequence, in order, that don’t contain elements satisfying the given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた述部を満たす要素を含んでいない、このシーケンスの最も長くなりうる下位シーケンスそれらを順序どおりに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the low-surrogate code unit of the surrogate pair representing the specified Unicode scalar.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたユニコードスカラーを表しているサロゲートペアの下位サロゲートコード単位を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the maximum element in the sequence, using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの中の最大の要素を返します、与えられた述部を要素間の比較として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the maximum element in the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの中の最大の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the maximum number of bytes needed to store the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in a given encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を指定された符号化において格納するのに必要なバイト数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the minimum element in the sequence, using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの中の最小の要素を返します、与えられた述部を要素間の比較として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the minimum element in the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの中の最小の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the next consecutive location after <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の後の、以降に続く場所を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the next consecutive position after <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の後の、以降に続く位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the non-<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> results of mapping the given transformation over this collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた変換をこのコレクション全体にわたってマッピングする非<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the non-<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> results of mapping the given transformation over this sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた変換をこのシーケンス全体にわたってマッピングする非<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the number of UTF-16 code units required for the given code unit sequence when transcoded to UTF-16, and a Boolean value indicating whether the sequence was found to contain only ASCII characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-16にコード変換するときに指定されたコードユニットシーケンスに必要とされるUTF-16コードユニットの数を、およびそのシーケンスがASCII文字だけを含むことを発見されたかどうかを指し示すブール値を、返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the number of bytes from the start of one instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to the start of the next when stored in contiguous memory or in an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Array&lt;T&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の１つのインスタンスの始まりから次のものの始まりまでのバイト数を返します、隣接メモリの中にまたは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Array&lt;T&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の中に格納される場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the number of bytes required to store the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in a given encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を指定された符号化において格納するのに要求されるバイト数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the number of code units required to encode the given Unicode scalar.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたユニコードスカラーをエンコードするのに必要とされるコードユニットの数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the number of elements (if known) contained within this container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコンテナ内に含まれる要素の数を（既知ならば）返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the number of elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素の数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the object instance being used for storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ストレージのために使われているオブジェクトインスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the position immediately after the given index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたインデックスの直後の位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the position immediately before the given index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたインデックスの直前の位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the position in the given UTF-16 view that corresponds exactly to this index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたUTF-16ビューの中のある位置を返します、それは正確にこのインデックスに対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the position in the given UTF-8 view that corresponds exactly to this index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたUTF-8ビューの中のある位置を返します、それは正確にこのインデックスに対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the position in the given string that corresponds exactly to this index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字列の中のある位置を返します、それは正確にこのインデックスに対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the position in the given view of Unicode scalars that corresponds exactly to this index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたユニコードスカラーのビューの中のある位置を返します、それは正確にこのインデックスに対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the previous consecutive location before <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>前の、以前に続く場所を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the previous consecutive position before <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>前の、以前に続く位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the product of the two given values, discarding any overflow.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの与えられた値の積を、あらゆるオーバーフローを廃棄して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the product of this value and the given value along with a flag indicating whether overflow occurred in the operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と与えられた値の積、それに加えてオーバーフローがその演算において起こったかどうかを示すフラグを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the product of this value and the given value without checking for arithmetic overflow.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と与えられた値の積を、算術オーバーフローの検査なしに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the quotient and remainder of this value divided by the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値でこの値を除算した商と余りを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the quotient of dividing the first value by the second, rounded to a representable value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の値を２番目の値で除算した商を返します、表現可能な値に丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the quotient of dividing the first value by the second.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の値を２番目の値で除算した商を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the quotient of dividing this value by the given value along with a flag indicating whether overflow occurred in the operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値を与えられた値で除算した商、それに加えてオーバーフローがその演算において起こったかどうかを示すフラグを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the quotient of dividing this value by the given value without checking for arithmetic overflow.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値を与えられた値で除算した商を、算術オーバーフローの検査なしに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the range in the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> of the composed character sequence located at a given index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたインデックスで位置する合成文字シーケンスの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>での範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the range in the string of the composed character sequences for a given range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた範囲に対する合成文字シーケンスの文字列での範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the range of characters representing the line or lines containing a given range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた範囲を含んでいる行または複数行を表している文字の範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the range of characters representing the paragraph or paragraphs containing a given range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた範囲を含んでいる段落または複数段落を表している文字の範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the range of indices within the given collection described by this range expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この範囲式によって記述される与えられたコレクション内のインデックスの範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the remainder of dividing the first value by the second.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の値を２番目の値で除算した余りを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the remainder of dividing this value by the given value along with a flag indicating whether overflow occurred in the operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値を与えられた値で除算する余り、それに加えてオーバーフローがその演算において起こったかどうかを示すフラグを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the remainder of this value divided by the given value using truncating division.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>切り捨て除算を使って与えられた値で除算されたこの値の余りを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the remainder of this value divided by the given value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値で除算されたこの値の余りを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the result of adding the product of the two given values to this value, computed without intermediate rounding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの与えられた値の積をこの値に加える結果を返します、中間の丸めなしで計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the result of combining the elements of the sequence using the given closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの要素を与えられたクロージャを使って結合する結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the result of invoking <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>compare:<ph x="2">&lt;w2/&gt;</ph>options:<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>NSCase<ph x="5">&lt;w5/&gt;</ph>Insensitive<ph x="6">&lt;w6/&gt;</ph>Search<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> as the only option.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>compare:<ph x="2">&lt;w2/&gt;</ph>options:<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、唯一のオプションとしての<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>NSCase<ph x="5">&lt;w5/&gt;</ph>Insensitive<ph x="6">&lt;w6/&gt;</ph>Search<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>とともに発動する結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the result of performing a bitwise AND operation on the two given values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位AND演算を２つの与えられた値に関して実行する結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the result of performing a bitwise OR operation on the two given values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位OR演算を２つの与えられた値に関して実行する結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the result of performing a bitwise XOR operation on the two given values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位XOR演算を２つの与えられた値に関して実行する結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the left, masking the shift amount to the type’s bit width, and stores the result in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値のバイナリ表現を指定された桁数だけ左にシフトする結果を返します、シフト量をその型の持つビット幅にマスクしています、そして結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the left, masking the shift amount to the type’s bit width.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値のバイナリ表現を指定された桁数だけ左にシフトする結果を返します、シフト量をその型の持つビット幅にマスクしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the left.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値のバイナリ表現を指定された桁数だけ左にシフトする結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the right, masking the shift amount to the type’s bit width.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値のバイナリ表現を指定された桁数だけ右にシフトする結果を返します、シフト量をその型の持つビット幅にマスクしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the right.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値のバイナリ表現を指定された桁数だけ右にシフトする結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the sequence of values (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self + stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self + 2 * stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, … <bpt i="6" x="6">&lt;e6&gt;</bpt>last<ept i="6">&lt;/e6&gt;</ept>) where <bpt i="7" x="7">&lt;e7&gt;</bpt>last<ept i="7">&lt;/e7&gt;</ept> is the last value in the progression less than or equal to <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>end<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値のシーケンス (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self + stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self + 2 * stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, … <bpt i="6" x="6">&lt;e6&gt;</bpt>last<ept i="6">&lt;/e6&gt;</ept>) を返します、そこで<bpt i="7" x="7">&lt;e7&gt;</bpt>last<ept i="7">&lt;/e7&gt;</ept>はこの数列の中の最後の値で、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>end<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>より少ないかそれと等しいものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the sequence of values (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self + stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self + 2 * stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, … <bpt i="6" x="6">&lt;e6&gt;</bpt>last<ept i="6">&lt;/e6&gt;</ept>) where <bpt i="7" x="7">&lt;e7&gt;</bpt>last<ept i="7">&lt;/e7&gt;</ept> is the last value in the progression that is less than <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>end<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値のシーケンス（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self + stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>self + 2 * stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、… <bpt i="6" x="6">&lt;e6&gt;</bpt>last<ept i="6">&lt;/e6&gt;</ept>）を返します、そこで<bpt i="7" x="7">&lt;e7&gt;</bpt>last<ept i="7">&lt;/e7&gt;</ept>はこの数列の中の最後の値で、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>end<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>より少ないものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the smallest encoding to which the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> can be converted without loss of information.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が情報の損失無しに変換できる最小の符号化を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the square root of the value, rounded to a representable value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値の平方根を返します、表現可能な値に丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the sum of the two given values, discarding any overflow.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの与えられた値の合計を、あらゆるオーバーフローを廃棄して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the sum of this value and the given value along with a flag indicating whether overflow occurred in the operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と与えられた値の合計、それに加えてオーバーフローがその演算において起こったかどうかを示すフラグを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the sum of this value and the given value without checking for arithmetic overflow.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と与えられた値の合計を、算術オーバーフローの検査なしに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the value with greater magnitude.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より大きい規模を持つ値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns the value with lesser magnitude.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より小さい規模を持つ値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns this value rounded to an integral value using the specified rounding rule.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された丸め規則を使って整数値に丸められたこの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns this value rounded to an integral value using “schoolbook rounding.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「教科書丸め」を使って整数値に丸めたこの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns whether the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> contains a value associated with the given key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が与えられたキーと結び付けられる値を含むかどうかを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns whether the given keys are equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたキー同士が等しいかどうかを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Returns whether there are no more elements left to be decoded in the container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンテナの中にデコードされるための残っている要素がこれ以上ないかを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reverses the elements of the collection in place.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの要素をその場で逆順にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reversing a Set's Elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合の要素を逆順にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Right associative</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>右結合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Right bit shift and assign</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>右ビットシフトして代入する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Right shift operations on negative values “fill in” the high bits with ones instead of zeros.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>負値上での右シフト演算は、高ビットを１で「満たします」、ゼロではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Round to the closest allowed value that is greater than or equal to the source.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ソースより大きいか等しい最も近い許される値に丸めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Round to the closest allowed value that is less than or equal to the source.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ソースより小さいか等しい最も近い許される値に丸めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Round to the closest allowed value whose magnitude is greater than or equal to that of the source.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの規模がソースのそれより大きいか等しい最も近い許される値に丸めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Round to the closest allowed value whose magnitude is less than or equal to that of the source.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの規模がソースのそれより小さいか等しい最も近い許される値に丸めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Round to the closest allowed value; if two values are equally close, the even one is chosen.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最も近い許される値に丸めます；２つの値が同じくらい近いならば、偶数のものが選ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Round to the closest allowed value; if two values are equally close, the one with greater magnitude is chosen.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最も近い許される値に丸めます；２つの値が同じくらい近いならば、より大きい規模を持つものが選ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rounding</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>丸め</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rounds the value to an integral value using the specified rounding rule.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された丸め規則を使ってこの値を整数値に丸めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rounds this value to an integral value using “schoolbook rounding.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「教科書丸め」を使ってこの値を整数値に丸めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>S() == []</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>S() == [] （空の集合は空の配列リテラルと同等です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Saved indices may become invalid as a result of mutating operations; for more information about index invalidation in mutable collections, see the reference for the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Range<ph x="5">&lt;w5/&gt;</ph>Replaceable<ph x="6">&lt;w6/&gt;</ph>Collection<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocols, as well as for the specific type you’re using.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存されたインデックスは可変の演算の結果に無効となるかもしれません；可変コレクションにおけるインデックス無効化についてのさらなる情報は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Range<ph x="5">&lt;w5/&gt;</ph>Replaceable<ph x="6">&lt;w6/&gt;</ph>Collection<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルに対してのリファレンスを、あなたが使っている特定の型に対してだけでなく、見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Scalar values representing characters that are normally unprintable or that otherwise require escaping are escaped with a backslash.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>通常は出力できないまたはそうするにはエスケープする必要がある、スカラー値表現の文字は、バックスラッシュでエスケープされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Uniquely<ph x="3">&lt;w3/&gt;</ph>Referenced<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for details.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細のために<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Uniquely<ph x="3">&lt;w3/&gt;</ph>Referenced<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See Also</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Flatten<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次を参照してください：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Flatten<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Flatten<ph x="2">&lt;w2/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次を参照してください：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Flatten<ph x="2">&lt;w2/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Lazy<ph x="5">&lt;w5/&gt;</ph>Collection<ph x="6">&lt;w6/&gt;</ph>Protocol<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Lazy<ph x="9">&lt;w9/&gt;</ph>Collection<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Lazy<ph x="5">&lt;w5/&gt;</ph>Collection<ph x="6">&lt;w6/&gt;</ph>Protocol<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Lazy<ph x="9">&lt;w9/&gt;</ph>Collection<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Sequence<ph x="3">&lt;w3/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Sequence<ph x="3">&lt;w3/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Sequence<ph x="3">&lt;w3/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Lazy<ph x="6">&lt;w6/&gt;</ph>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Sequence<ph x="3">&lt;w3/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Lazy<ph x="6">&lt;w6/&gt;</ph>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Reversed<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Reversed<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Reversed<ph x="2">&lt;w2/&gt;</ph>Random<ph x="3">&lt;w3/&gt;</ph>Access<ph x="4">&lt;w4/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Reversed<ph x="2">&lt;w2/&gt;</ph>Random<ph x="3">&lt;w3/&gt;</ph>Access<ph x="4">&lt;w4/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>elements<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>elements<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See the failable initializers of <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>Any<ph x="18">&lt;w18/&gt;</ph>Bidirectional<ph x="19">&lt;w19/&gt;</ph>Collection<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> and <bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>Any<ph x="22">&lt;w22/&gt;</ph>Random<ph x="23">&lt;w23/&gt;</ph>Access<ph x="24">&lt;w24/&gt;</ph>Collection<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept> for details.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細として<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>Any<ph x="18">&lt;w18/&gt;</ph>Bidirectional<ph x="19">&lt;w19/&gt;</ph>Collection<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>と<bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>Any<ph x="22">&lt;w22/&gt;</ph>Random<ph x="23">&lt;w23/&gt;</ph>Access<ph x="24">&lt;w24/&gt;</ph>Collection<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept>の失敗できるイニシャライザを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See the failable initializers of <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Any<ph x="11">&lt;w11/&gt;</ph>Bidirectional<ph x="12">&lt;w12/&gt;</ph>Collection<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> and <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>Any<ph x="15">&lt;w15/&gt;</ph>Random<ph x="16">&lt;w16/&gt;</ph>Access<ph x="17">&lt;w17/&gt;</ph>Collection<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> for details.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細として<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Any<ph x="11">&lt;w11/&gt;</ph>Bidirectional<ph x="12">&lt;w12/&gt;</ph>Collection<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>と<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>Any<ph x="15">&lt;w15/&gt;</ph>Random<ph x="16">&lt;w16/&gt;</ph>Access<ph x="17">&lt;w17/&gt;</ph>Collection<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>の失敗できるイニシャライザを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See those types for more information.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらなる情報としてそれらの型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Selecting Elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素の選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sequence Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Sequence 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sequence and Collection Operations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスおよびコレクション演算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sequence and Collection Protocols</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスおよびコレクションプロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sequence operations taking closure arguments, such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>filter<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, are normally eager: they use the closure immediately and return a new array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャ引数を取るシーケンス操作、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>filter<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、普通は先行処理です：これらはクロージャを即座に使用します、そしてある新しい配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sequences provide access to their elements by creating an iterator, which keeps track of its iteration process and returns one element at a time as it advances through the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さまざまなシーケンスは、あるイテレータを作成することによってそれらの要素に対するアクセスを提供します、それはそれの反復処理を追跡し続けてそれがそのシーケンスを始めから終わりへと前進するごとに１度に１つ要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Serialize and deserialize instances of your types with implicit or customized encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの型のインスタンスを暗黙のまたはカスタマイズされたエンコーディングでシリアライズおよびデシリアライズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Set <bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept> is a strict subset of another set <bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept> if every member of <bpt i="2" x="2">&lt;e2&gt;</bpt>A<ept i="2">&lt;/e2&gt;</ept> is also a member of <bpt i="3" x="3">&lt;e3&gt;</bpt>B<ept i="3">&lt;/e3&gt;</ept> and <bpt i="4" x="4">&lt;e4&gt;</bpt>B<ept i="4">&lt;/e4&gt;</ept> contains at least one element that is not a member of <bpt i="5" x="5">&lt;e5&gt;</bpt>A<ept i="5">&lt;/e5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合<bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept>がもう１つの集合<bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept>の狭義の部分集合であるのは、<bpt i="2" x="2">&lt;e2&gt;</bpt>A<ept i="2">&lt;/e2&gt;</ept>のすべてのメンバがまた<bpt i="3" x="3">&lt;e3&gt;</bpt>B<ept i="3">&lt;/e3&gt;</ept>のメンバであり、<bpt i="4" x="4">&lt;e4&gt;</bpt>B<ept i="4">&lt;/e4&gt;</ept>が少なくとも１つの<bpt i="5" x="5">&lt;e5&gt;</bpt>A<ept i="5">&lt;/e5&gt;</ept>のメンバではない要素を含む場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Set <bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept> is a strict superset of another set <bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept> if every member of <bpt i="2" x="2">&lt;e2&gt;</bpt>B<ept i="2">&lt;/e2&gt;</ept> is also a member of <bpt i="3" x="3">&lt;e3&gt;</bpt>A<ept i="3">&lt;/e3&gt;</ept> and <bpt i="4" x="4">&lt;e4&gt;</bpt>A<ept i="4">&lt;/e4&gt;</ept> contains at least one element that is <bpt i="5" x="5">&lt;e5&gt;</bpt>not<ept i="5">&lt;/e5&gt;</ept> a member of <bpt i="6" x="6">&lt;e6&gt;</bpt>B<ept i="6">&lt;/e6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合<bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept>がもう１つの集合<bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept>の狭義の上位集合であるのは、<bpt i="2" x="2">&lt;e2&gt;</bpt>B<ept i="2">&lt;/e2&gt;</ept>のすべてのメンバがまた<bpt i="3" x="3">&lt;e3&gt;</bpt>A<ept i="3">&lt;/e3&gt;</ept>のメンバであり、<bpt i="4" x="4">&lt;e4&gt;</bpt>A<ept i="4">&lt;/e4&gt;</ept>が少なくとも１つの<bpt i="6" x="6">&lt;e6&gt;</bpt>B<ept i="6">&lt;/e6&gt;</ept>のメンバでは<bpt i="5" x="5">&lt;e5&gt;</bpt>ない<ept i="5">&lt;/e5&gt;</ept>要素を含む場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Set <bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept> is a subset of another set <bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept> if every member of <bpt i="2" x="2">&lt;e2&gt;</bpt>A<ept i="2">&lt;/e2&gt;</ept> is also a member of <bpt i="3" x="3">&lt;e3&gt;</bpt>B<ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合<bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept>がもう１つの集合<bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept>の狭義の部分集合であるのは、<bpt i="2" x="2">&lt;e2&gt;</bpt>A<ept i="2">&lt;/e2&gt;</ept>のすべてのメンバがまた<bpt i="3" x="3">&lt;e3&gt;</bpt>B<ept i="3">&lt;/e3&gt;</ept>のメンバである場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Set <bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept> is a superset of another set <bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept> if every member of <bpt i="2" x="2">&lt;e2&gt;</bpt>B<ept i="2">&lt;/e2&gt;</ept> is also a member of <bpt i="3" x="3">&lt;e3&gt;</bpt>A<ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合<bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept>がもう１つの集合<bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept>の狭義の上位集合であるのは、<bpt i="2" x="2">&lt;e2&gt;</bpt>B<ept i="2">&lt;/e2&gt;</ept>のすべてのメンバがまた<bpt i="3" x="3">&lt;e3&gt;</bpt>A<ept i="3">&lt;/e3&gt;</ept>のメンバである場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Set Operations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合演算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Set and dictionary performance depends on hash values that minimize collisions for their associated element and key types, respectively.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合と辞書の性能は、ハッシュ値、それらの関連要素やキーの型の食い違いをできるだけ少なくすること、に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Set operations are not limited to use with other sets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合演算は、他の集合との使用に制限されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>SetAlgebra Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>SetAlgebra 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sets</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sets and Dictionaries</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合と辞書</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sets provide a suite of mathematical set operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合は、数学的な集合演算のひとそろいを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sharing indices between collections and their subsequences is an important part of the design of Swift’s collection algorithms.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションとそれらの下位シーケンスとの間のインデックスの共有は、Swiftのコレクションアルゴリズム設計の重要な部分のひとつです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Shifts a pointer backward by a specified number of instances of the pointer’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるポインタを、そのポインタの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型の指定された数のインスタンスだけ後方へずらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Signaling NaNs typically raise the Invalid flag when used in general computing operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シグナルNaNは、一般的な計算操作に使われる時に通常は無効フラグをあげます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Signed Integers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号付き整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>SignedInteger Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>SignedInteger実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>SignedNumeric Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>SignedNumeric 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similar to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>reduce(_:<ph x="4">&lt;w4/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method defined in the standard library, which takes an initial value and a combining closure, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>reduce1(_:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> uses the first element of the sequence as the initial value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期値と結合クロージャをとる、標準ライブラリ定義の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>reduce(_:<ph x="4">&lt;w4/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドとよく似て、 <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>reduce1(_:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>はシーケンスの最初の要素を初期値として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Simply assign an array literal to a variable or constant with the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type specified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単にある配列リテラルを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型指定子を持つ変数または定数に代入してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Simply surround a comma-separated list of values, instances, or literals with square brackets to create an array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単にコンマ区切りの値、インスタンス、またはリテラルを角括弧で囲むことで、配列リテラルを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Since equality between instances of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types is an equivalence relation, any of your custom types that conform to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must satisfy three conditions, for any values <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>a<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>b<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>c<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンス間の同等性は等値関係であることから、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するあなたのあつらえの型は何であれ、任意の値<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>a<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>b<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>c<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>に対して、３つの条件を満たす必要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Slices</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Slices Are Views onto Arrays</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライスは配列に関する見方です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Slices Inherit Collection Semantics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライスはコレクションの意味論を継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Slices Inherit Semantics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライスは意味論を継承します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Slices Maintain Indices</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライスはインデックスを維持します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Slices Share Indices</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライスはインデックスを共有します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Slices maintain the same indices of the larger array for the same elements, so the starting index of a slice depends on how it was created, letting you perform index-based operations on either a full array or a slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライスはより大きな配列と同じインデックスを同じ要素に対して維持します、そのためスライスの開始インデックスはそれがどう作成されたかによって決まり、あなたにインデックスに基づく演算を完全な配列またはスライスのどちらでも実行させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Solve complex problems and write high-performance, readable code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複雑な問題を解決します、そして高性能の、読みやすいコードを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some algorithms, however, may call for direct iterator use.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>幾つかのアルゴリズムは、しかしながら、直にイテレータを使うために呼び出すかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some arithmetic operations on fixed-width integers return an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Arithmetic<ph x="2">&lt;w2/&gt;</ph>Overflow<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance to indicate whether an overflow has occurred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>固定長整数でのいくつかの算術計算は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Arithmetic<ph x="2">&lt;w2/&gt;</ph>Overflow<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返すことでオーバーフローが起こったかどうかを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some characters that are visible in a string are made up of more than one Unicode scalar value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の中に見られるいくつかの文字は、１つ以上のユニコードスカラー値で構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some common word delimiting punctuation isn’t considered, so this property may not generally produce the desired results for multiword strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>幾つかのよくある単語区切り約物は考慮されません、それでこのプロパティは２語以上からなる文字列に対して望ましい結果を大抵は生み出しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some operations that are efficient on a dictionary are slower when using <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書上で効率的ないくつかの演算は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使う場合より遅くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some sequence and collection operations can be used more simply when the elements conform to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかのシーケンスとコレクションの演算子は、要素が<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠する時はより簡単に使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some special cases apply:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの特別な場合が適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sometimes you may want different error states to include the same common data, such as the position in a file or some of your application’s state.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>時にはあなたは、いくらかの異なるエラー状態をこの同じ通常のデータに含めたいかもしれません、例えばあるファイル中の位置やあなたのアプリケーションの何らかの状態など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sorting a String's Characters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列のもつ文字をソートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sorting an Array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列のソート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sorts the collection in place, using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションをその場でソートします、与えられた述部を要素間の比較として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sorts the collection in place.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションをその場でソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Special-Use Collections</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特殊用途のコレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Special-Use Numeric Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特殊用途の数値型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Specifically, you use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type to hold elements of a single type, the array’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とりわけ、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型をある単一の型、その配列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型、の複数の要素を保持するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Splitting a String</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列を分割する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Splitting and Joining Elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素の分割と連結</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Standard input is interpreted as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF-8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準入力は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF-8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Starts or continues decoding a UTF-16 sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるUTF-16シーケンスのデコードを開始または継続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Starts or continues decoding a UTF-32 sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるUTF-32シーケンスのデコードを開始または継続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Starts or continues decoding a UTF-8 sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるUTF-8シーケンスのデコードを開始または継続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Starts or continues decoding a code unit sequence into Unicode scalar values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コード単位シーケンスをユニコードスカラー値へデコードすることを開始するまたは継続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Store and organize data using arrays, dictionaries, sets, and other data structures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列、辞書、集合、および他のデータ構造を使ってデータを格納および組織化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Store your custom types in sets or use them as dictionary keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いろいろなあなたのあつらえの型を集合に格納するまたはそれらを辞書キーとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stores a keyed encoding container for the given key and returns it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー付けされたエンコーディングコンテナを指定キーに対して供給して、それを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stores a new nested container for the default <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>super<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> key and returns a new <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Encoder<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance for encoding <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>super<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> into that container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい入れ子のコンテナを省略時<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>super<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>キーに対して供給します、そして<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>super<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>をエンコードするための<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Encoder<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスをそのコンテナに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stores a new nested container for the given key and returns a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Encoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance for encoding <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>super<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> into that container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい入れ子のコンテナを指定キーに対して供給します、そして<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>super<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>をエンコードするための新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Encoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスをそのコンテナに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stores a value’s bytes into the buffer pointer’s raw memory at the specified byte offset.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値のもつバイトをバッファポインタのもつ生のメモリに指定されたバイトオフセットで格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stores an unkeyed encoding container for the given key and returns it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー付けされないエンコーディングコンテナを指定キーに対して供給して、それを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stores the given value’s bytes into raw memory at the specified offset.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値のもつバイトを生のメモリへ指定されたオフセットで格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stores the result of performing a bitwise AND operation on the two given values in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位AND演算を２つの与えられた値に関して実行する結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stores the result of performing a bitwise OR operation on the two given values in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位OR演算を２つの与えられた値に関して実行する結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stores the result of performing a bitwise XOR operation on the two given values in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位XOR演算を２つの与えられた値に関して実行する結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Storing substrings may therefore prolong the lifetime of string data that is no longer otherwise accessible, which can appear to be memory leakage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位文字列の格納は、したがってそれ以外ではもはやアクセスできない文字列データのライフサイクルを延長するでしょう、それはメモリリークとして現れかねません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Streams</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ストリーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strides</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ストライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String Literals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String Representation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String buffers use an exponential growth strategy that makes appending to a string a constant time operation when averaged over many append operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列バッファは指数成長戦略を使います、それはある文字列へ追加することを、多くの追加演算を平均した時に定数時間演算にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String interpolation is a multiple-step initialization process.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列補間は、複数段階の初期化処理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String interpolations are an easy way to build a string from multiple pieces.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列補間は、多様な断片からある文字列を組み立てる簡単な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String interpolations are string literals that evaluate any included expressions and convert the results to string form.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列補間は文字列リテラルです、それは、何らかの含まれた式を評価して、その結果を文字列形式へ変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strings always have value semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列は常に値意味論を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strings and Characters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列と文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strings and Text</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列とテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strings are collections of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Character<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instances, so the number of visible characters is generally the most natural way to count the length of a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Character<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスのコレクションです、なので見ることのできる文字の数はたいてい文字列の長さを数える最も自然な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strings in Swift are Unicode correct, locale insensitive, and designed to be efficient.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftでの文字列は、ユニコードに正確です、ロケールに影響されません、そして効率的であるように設計されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strings in Swift conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, so the names are sorted in ascending order according to the less-than operator (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&lt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列はSwift では<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠します、それでこれらの名前はより小さい演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&lt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）によって昇順にソートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subclasses must not have any stored properties; any storage needed should be included in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Header<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブクラスは、どんな保存プロパティも持つ必要はありません；必要とされるあらゆるストレージは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Header<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中に含められるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subnormal numbers are often called <bpt i="0" x="0">&lt;e0&gt;</bpt>denormal<ept i="0">&lt;/e0&gt;</ept> or <bpt i="1" x="1">&lt;e1&gt;</bpt>denormalized<ept i="1">&lt;/e1&gt;</ept>—these are different names for the same concept.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブノーマル数は、しばしば<bpt i="0" x="0">&lt;e0&gt;</bpt>デノーマル<ept i="0">&lt;/e0&gt;</ept>または<bpt i="1" x="1">&lt;e1&gt;</bpt>デノーマライズされた<ept i="1">&lt;/e1&gt;</ept>と呼ばれます—それらは同じ概念に対する異なる名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subnormal values do not use the full precision available to values of a type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブノーマル値は、ある型の値に利用可能な完全な精度を使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripting a dictionary with a key returns an optional value, because a dictionary might not hold a value for the key that you use in the subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるキーで辞書に添え字を使うことは、オプショナル値を返します、なぜなら辞書はあなたが添え字に使ったキーに対して値を保持しないかもしれないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripting with a key takes the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーによる添え字は以下の形式をとります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripting with a key, yielding an optional value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーによる添え字、オプショナル値を生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripting with an index, yielding a key-value pair:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インデックスによる添え字、キー値ペアを生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripts</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Substrings present the same interface as strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位文字列は、文字列と同じインターフェイスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subtract</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>減算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subtract and assign</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>減算して代入する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subtract with overflow</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバーフロー減算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subtracts one value from another and produces their difference, rounded to a representable value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値をもう一方から減じて、それらの差を返します、表現可能な値へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subtracts one value from another and produces their difference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値をもう一方から減じて、それらの差を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subtracts the second value from the first and stores the difference in the left-hand-side variable, rounding to a representable value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２番目の値を最初のものから減じて、その差を左手側の変数の中に格納します、表現可能な値へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subtracts the second value from the first and stores the difference in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２番目の値を最初のものから減じて、その差を左手側の変数の中に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suggests a display style for the reflected subject.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リフレクションされる主題のための表示形式を提案します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Supporting Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>支援を行う型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suppose you are tasked with finding the first two days with absences in the session.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこの学期において欠席者のある最初の２つの日付を見つける任務を負うと考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suppose you need to store a list of the names of students that are signed up for a class you’re teaching.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが生徒の名前のリストをしまっておく必要があると仮定してみましょう、それはあなたが教えているクラスに受講届けを出されるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Suppress the representation of all ancestor classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全ての先祖クラスの表現を抑制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift Standard Library</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift標準ライブラリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift makes it as easy to create a new set as to create a new array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftは、新しい集合を作成することを新しい配列を作成するのと同じくらい簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift makes it easy to create arrays in your code using an array literal: simply surround a comma separated list of values with square brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftは、あなたのコードにおける配列の作成を配列リテラルを使うことで簡単にします：単にコンマ区切りの値のリストを角括弧で囲んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides a default debugging textual representation for any type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftは、省略時のデバッグ用テキスト表現をあらゆる型に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift streamlines interoperation with C string APIs by letting you pass a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance to a function as an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>UInt8<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftは、あなたに<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを関数へ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>UInt8<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ポインタとして渡させることによって、C文字列APIとの相互作用を能率化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift uses a sequence’s or collection’s iterator internally to enable the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>for<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>-<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>in<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> loop language construct.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftは、あるシーケンスのもつまたはコレクションのもつイテレータを内部的に使うことで、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>for<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>-<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>in<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>ループ言語構成体を可能にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift uses only simple Boolean values in conditional contexts to help avoid accidental programming errors and to help maintain the clarity of each control statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftは、単純なブール値だけを条件文脈において使用することによって、思いがけないプログラミングエラーを防ぐのを助けます、そして各制御文の明瞭性を保つのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>String<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> type conforms to <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Text<ph x="14">&lt;w14/&gt;</ph>Output<ph x="15">&lt;w15/&gt;</ph>Stream<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> already, so you can capture the output from <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>print(_:<ph x="18">&lt;w18/&gt;</ph>to:)<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> and <bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>dump(_:<ph x="21">&lt;w21/&gt;</ph>to:)<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept> in a string instead of logging it to standard output.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftの<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>String<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>型は、すでに<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Text<ph x="14">&lt;w14/&gt;</ph>Output<ph x="15">&lt;w15/&gt;</ph>Stream<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>に準拠します、なのであなたは<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>print(_:<ph x="18">&lt;w18/&gt;</ph>to:)<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>および<bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>dump(_:<ph x="21">&lt;w21/&gt;</ph>to:)<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept>からの出力を文字列の中に捕えることが、それを標準出力に記録する代わりに行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s enumerations are well suited to represent simple errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftの列挙は、単純なエラーを表すのによく適します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s type system usually shows the wrapped type’s name with a trailing question mark (<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>?<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>) instead of showing the full type name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftのもつ型システムは通常、ラップされた型の名前を後に続く疑問符（<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>?<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）で示します、完全な型の名前を示す代わりに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Table 1</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>表 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Table 2</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>表２</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Table 3</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>表 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Ternary conditional</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>三項条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Testing</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Testing for Inclusion</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>包含を試験する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Testing for Membership</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>帰属をテストする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Text Output</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>テキスト出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That default representation is used by the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(reflecting:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer and the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>debug<ph x="4">&lt;w4/&gt;</ph>Print(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> function for types that don’t provide their own.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の表現は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(reflecting:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザおよび<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>debug<ph x="4">&lt;w4/&gt;</ph>Print(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>関数によって、それらが自前で提供しない型に対して使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>bit<ph x="7">&lt;w7/&gt;</ph>Pattern % Memory<ph x="8">&lt;w8/&gt;</ph>Layout&lt;Pointee&gt;.alignment<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> must be <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>0<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>bit<ph x="7">&lt;w7/&gt;</ph>Pattern % Memory<ph x="8">&lt;w8/&gt;</ph>Layout&lt;Pointee&gt;.alignment<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は、<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>0<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, for a mutable collection instance <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>a<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, index <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>i<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, and value <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>x<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, the two sets of assignments in the following code sample must be equivalent:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、ある可変コレクションインスタンス<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>a<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、インデックス<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>i<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>、そして値<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>x<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に対して、以下のコード見本における２組の代入は同等なものでなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, for any elements <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>a<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>b<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>c<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, the following conditions must hold:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、何らかの要素<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>a<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>b<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、そして<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>c<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に対して、以下の条件が保持されなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, for any index <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> into a bidirectional collection <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>c<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、二方向性のコレクション<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>c<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対する何らかのインデックス<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, for two instances <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>a<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>b<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> of the same type, if <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>a == b<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> then <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>a<ph x="11">&lt;w11/&gt;</ph>.hash<ph x="12">&lt;w12/&gt;</ph>Value == b<ph x="13">&lt;w13/&gt;</ph>.hash<ph x="14">&lt;w14/&gt;</ph>Value<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、同じ型の２つのインスタンス<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>a<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>b<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に対して、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>a == b<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>ならばそのとき<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>a<ph x="11">&lt;w11/&gt;</ph>.hash<ph x="12">&lt;w12/&gt;</ph>Value == b<ph x="13">&lt;w13/&gt;</ph>.hash<ph x="14">&lt;w14/&gt;</ph>Value<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, if <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>source<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is negative, the result is padded with ones; otherwise, the result is padded with zeros.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>source<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が負ならば、結果は１で詰め物をされます；そうでなければ、結果はゼロで詰め物をされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, if a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bidirectional<ph x="2">&lt;w2/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is wrapped around a mutable collection that has value semantics, such as an array, mutating the original collection would trigger a copy of that collection, and not affect the base collection stored inside of the slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bidirectional<ph x="2">&lt;w2/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが値意味論を持つ可変コレクション、例えば配列などの周りにラップされる場合、オリジナルのコレクションを変化させることはそのコレクションのコピーを誘発します、それでスライス内部に格納される基盤コレクションには影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, if a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Bidirectional<ph x="3">&lt;w3/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is wrapped around a mutable collection that has value semantics, such as an array, mutating the original collection would trigger a copy of that collection, and not affect the base collection stored inside of the slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Bidirectional<ph x="3">&lt;w3/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが値意味論を持つ可変コレクション、例えば配列などの周りにラップされる場合、オリジナルのコレクションを変化させることはそのコレクションのコピーを誘発します、それでスライス内部に格納される基盤コレクションには影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, if a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Random<ph x="3">&lt;w3/&gt;</ph>Access<ph x="4">&lt;w4/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is wrapped around a mutable collection that has value semantics, such as an array, mutating the original collection would trigger a copy of that collection, and not affect the base collection stored inside of the slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Random<ph x="3">&lt;w3/&gt;</ph>Access<ph x="4">&lt;w4/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが値意味論を持つ可変コレクション、例えば配列などの周りにラップされる場合、オリジナルのコレクションを変化させることはそのコレクションのコピーを誘発します、それでスライス内部に格納される基盤コレクションには影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, if a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Replaceable<ph x="4">&lt;w4/&gt;</ph>Bidirectional<ph x="5">&lt;w5/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is wrapped around a mutable collection that has value semantics, such as an array, mutating the original collection would trigger a copy of that collection, and not affect the base collection stored inside of the slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Replaceable<ph x="4">&lt;w4/&gt;</ph>Bidirectional<ph x="5">&lt;w5/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが値意味論を持つ可変コレクション、例えば配列などの周りにラップされる場合、オリジナルのコレクションを変化させることはそのコレクションのコピーを誘発します、それでスライス内部に格納される基盤コレクションには影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, if a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Replaceable<ph x="4">&lt;w4/&gt;</ph>Random<ph x="5">&lt;w5/&gt;</ph>Access<ph x="6">&lt;w6/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is wrapped around a mutable collection that has value semantics, such as an array, mutating the original collection would trigger a copy of that collection, and not affect the base collection stored inside of the slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Replaceable<ph x="4">&lt;w4/&gt;</ph>Random<ph x="5">&lt;w5/&gt;</ph>Access<ph x="6">&lt;w6/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが値意味論を持つ可変コレクション、例えば配列などの周りにラップされる場合、オリジナルのコレクションを変化させることはそのコレクションのコピーを誘発します、それでスライス内部に格納される基盤コレクションには影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, if a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Replaceable<ph x="4">&lt;w4/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is wrapped around a mutable collection that has value semantics, such as an array, mutating the original collection would trigger a copy of that collection, and not affect the base collection stored inside of the slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Replaceable<ph x="4">&lt;w4/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが値意味論を持つ可変コレクション、例えば配列などの周りにラップされる場合、オリジナルのコレクションを変化させることはそのコレクションのコピーを誘発します、それでスライス内部に格納される基盤コレクションには影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, if a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is wrapped around a mutable collection that has value semantics, such as an array, mutating the original collection would trigger a copy of that collection, and not affect the base collection stored inside of the slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが値意味論を持つ可変コレクション、例えば配列などの周りにラップされる場合、オリジナルのコレクションを変化させることはそのコレクションのコピーを誘発します、それでスライス内部に格納される基盤コレクションには影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, if a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Random<ph x="2">&lt;w2/&gt;</ph>Access<ph x="3">&lt;w3/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is wrapped around a mutable collection that has value semantics, such as an array, mutating the original collection would trigger a copy of that collection, and not affect the base collection stored inside of the slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Random<ph x="2">&lt;w2/&gt;</ph>Access<ph x="3">&lt;w3/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが値意味論を持つ可変コレクション、例えば配列などの周りにラップされる場合、オリジナルのコレクションを変化させることはそのコレクションのコピーを誘発します、それでスライス内部に格納される基盤コレクションには影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, if a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Bidirectional<ph x="4">&lt;w4/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is wrapped around a mutable collection that has value semantics, such as an array, mutating the original collection would trigger a copy of that collection, and not affect the base collection stored inside of the slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Bidirectional<ph x="4">&lt;w4/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが値意味論を持つ可変コレクション、例えば配列などの周りにラップされる場合、オリジナルのコレクションを変化させることはそのコレクションのコピーを誘発します、それでスライス内部に格納される基盤コレクションには影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, if a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Random<ph x="4">&lt;w4/&gt;</ph>Access<ph x="5">&lt;w5/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is wrapped around a mutable collection that has value semantics, such as an array, mutating the original collection would trigger a copy of that collection, and not affect the base collection stored inside of the slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Random<ph x="4">&lt;w4/&gt;</ph>Access<ph x="5">&lt;w5/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが値意味論を持つ可変コレクション、例えば配列などの周りにラップされる場合、オリジナルのコレクションを変化させることはそのコレクションのコピーを誘発します、それでスライス内部に格納される基盤コレクションには影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, if a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is wrapped around a mutable collection that has value semantics, such as an array, mutating the original collection would trigger a copy of that collection, and not affect the base collection stored inside of the slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが値意味論を持つ可変コレクション、例えば配列などの周りにラップされる場合、オリジナルのコレクションを変化させることはそのコレクションのコピーを誘発します、それでスライス内部に格納される基盤コレクションには影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, if a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is wrapped around a mutable collection that has value semantics, such as an array, mutating the original collection would trigger a copy of that collection, and not affect the base collection stored inside of the slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが値意味論を持つ可変コレクション、例えば配列などの周りにラップされる場合、オリジナルのコレクションを変化させることはそのコレクションのコピーを誘発します、それでスライス内部に格納される基盤コレクションには影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection, and does not affect the contents of the slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、値意味論を持つ可変コレクション、例えば配列などのスライスを扱う場合、元のコレクションを変化させることはそのコレクションのコピーを誘発します、そしてスライスの内容に作用しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That requirement holds even for empty ranges.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その要件は空の範囲に対しても適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That same value is too large to represent as an <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int8<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instance, so the second conversion fails, triggering a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その同じ値は、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int8<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスとして表すには大きすぎます、それで２番目の変換は、実行時エラーを引き起こして失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That will ensure that <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>is<ph x="6">&lt;w6/&gt;</ph>Known<ph x="7">&lt;w7/&gt;</ph>Uniquely<ph x="8">&lt;w8/&gt;</ph>Referenced(_:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> only returns <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>true<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> when there is really one accessor, or when there is a race condition, which is already undefined behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>is<ph x="6">&lt;w6/&gt;</ph>Known<ph x="7">&lt;w7/&gt;</ph>Uniquely<ph x="8">&lt;w8/&gt;</ph>Referenced(_:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が本当に１つのアクセッサしかない時に、またはすでに未定義挙動であるところの競合状態の時に<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>true<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>を返すだけであるのを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;a0&gt;</bpt>IEEE 754 specification<ept i="0">&lt;/a0&gt;</ept> defines a <bpt i="1" x="1">&lt;e1&gt;</bpt>canonical<ept i="1">&lt;/e1&gt;</ept>, or preferred, encoding of a floating-point value’s representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>IEEE 754仕様<ept i="0">&lt;/a0&gt;</ept>は、ある<bpt i="1" x="1">&lt;e1&gt;</bpt>正準の<ept i="1">&lt;/e1&gt;</ept>、または推奨の、浮動小数点値の表現のエンコーディングを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;&lt;&lt;=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator performs a <bpt i="2" x="2">&lt;e2&gt;</bpt>masking shift<ept i="2">&lt;/e2&gt;</ept>, where the value used as <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>rhs<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is masked to produce a value in the range <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0..<ph x="7">&lt;lhs&lt;w7/&gt;</ph>.bit<ph x="8">&lt;w8/&gt;</ph>Width<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;&lt;&lt;=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子は、<bpt i="2" x="2">&lt;e2&gt;</bpt>マスクするシフト<ept i="2">&lt;/e2&gt;</ept>を実行します、そこにおいて<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>rhs<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>として使われる値はマスクされることで範囲<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0..<ph x="7">&lt;lhs&lt;w7/&gt;</ph>.bit<ph x="8">&lt;w8/&gt;</ph>Width<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の中の値を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;&gt;&gt;=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator performs a <bpt i="2" x="2">&lt;e2&gt;</bpt>masking shift<ept i="2">&lt;/e2&gt;</ept>, where the value passed as <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>rhs<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is masked to produce a value in the range <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0..<ph x="7">&lt;lhs&lt;w7/&gt;</ph>.bit<ph x="8">&lt;w8/&gt;</ph>Width<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;&gt;&gt;=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子は、<bpt i="2" x="2">&lt;e2&gt;</bpt>マスクするシフト<ept i="2">&lt;/e2&gt;</ept>を実行します、そこにおいて<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>rhs<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>として渡される値はマスクされることで範囲<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0..<ph x="7">&lt;lhs&lt;w7/&gt;</ph>.bit<ph x="8">&lt;w8/&gt;</ph>Width<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の中の値を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>*<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator implements the multiplication operation defined by the <bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754 specification<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>*<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子は、<bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754 仕様<ept i="2">&lt;/a2&gt;</ept>によって定義される乗算演算子を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator implements the addition operation defined by the <bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754 specification<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子は、<bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754 仕様<ept i="2">&lt;/a2&gt;</ept>によって定義される加算演算子を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator implements the subtraction operation defined by the <bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754 specification<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子は、<bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754 仕様<ept i="2">&lt;/a2&gt;</ept>によって定義される減算演算子を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>/<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator implements the division operation defined by the <bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754 specification<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>/<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子は、<bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754 仕様<ept i="2">&lt;/a2&gt;</ept>によって定義される除算演算子を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator performs a <bpt i="2" x="2">&lt;e2&gt;</bpt>smart shift<ept i="2">&lt;/e2&gt;</ept>, which defines a result for a shift of any value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子は、ある<bpt i="2" x="2">&lt;e2&gt;</bpt>賢いシフト<ept i="2">&lt;/e2&gt;</ept>を実行します、それは何らかの値のシフトに対する結果を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&gt;&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator performs a <bpt i="2" x="2">&lt;e2&gt;</bpt>smart shift<ept i="2">&lt;/e2&gt;</ept>, which defines a result for a shift of any value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&gt;&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子は、ある<bpt i="2" x="2">&lt;e2&gt;</bpt>賢いシフト<ept i="2">&lt;/e2&gt;</ept>を実行します、それは何らかの値のシフトに対する結果を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>??<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator also works with another <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Optional<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance on the right-hand side.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>??<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子はまた、別の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Optional<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスを右手側でも扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>ASCIILogger<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>write(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method processes its string input by escaping each Unicode scalar, with the exception of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"\n"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> line returns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>ASCIILogger<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>write(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドは、それの文字列入力を各ユニコードスカラーをエスケープすることによって処理します、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"\n"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>行復帰を除いては。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Hashable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type forwards equality comparisons and hashing operations to an underlying hashable value, hiding its specific underlying type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Hashable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、さまざまな同等性比較およびハッシュ演算をある基盤をなすハッシュ化値に転送して、それの特定の基礎をなす型を隠しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ph x="2">&lt;w2/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type makes it fast and efficient for you to perform operations on sections of a larger array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ph x="2">&lt;w2/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、ある大きな配列の各部分上で演算を実行することをあなたの代わりにより速くより効率的にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> (presumably non-lazy) sequence from which <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> was created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それから<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が作成された<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Base<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>（おそらく非遅延の）シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Floating<ph x="3">&lt;w3/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol extends the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Floating<ph x="6">&lt;w6/&gt;</ph>Point<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol with operations specific to floating-point binary types, as defined by the <bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754 specification<ept i="7">&lt;/a7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Floating<ph x="3">&lt;w3/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Floating<ph x="6">&lt;w6/&gt;</ph>Point<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルを、<bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754仕様<ept i="7">&lt;/a7&gt;</ept>で定義されるとおりに、浮動小数点バイナリ型に特有の演算で拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol is the basis for all the integer types provided by the standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、標準ライブラリによって提供される全ての整数型の土台です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type represents a character made up of one or more Unicode scalar values, grouped by a Unicode boundary algorithm.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、あるユニコード境界アルゴリズムによって一群にされる、ひとつ以上のユニコードスカラー値から成り立っている１つの文字を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ph x="2">&lt;w2/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> argument is valid only for the duration of the closure’s execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ph x="2">&lt;w2/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>引数は、ただクロージャの実行の間に対してのみ有効とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、多くの演算に対して省略時の実装を宣言および提供していて、それは要素がそれらの添え字によってアクセス可能になっているのを当てにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ph x="2">&lt;w2/&gt;</ph>Of<ph x="3">&lt;w3/&gt;</ph>Two<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> structure is a fixed-size collection that always holds two elements of a specific type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ph x="2">&lt;w2/&gt;</ph>Of<ph x="3">&lt;w3/&gt;</ph>Two<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>構造体は固定サイズのコレクションです、それは常にある決まった型の２つの要素を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ph x="2">&lt;w2/&gt;</ph>Of<ph x="3">&lt;w3/&gt;</ph>Two<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type uses the default iterator type, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Indexing<ph x="6">&lt;w6/&gt;</ph>Iterator<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, because it doesn’t define its own <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>make<ph x="9">&lt;w9/&gt;</ph>Iterator()<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> method or <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Iterator<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> associated type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ph x="2">&lt;w2/&gt;</ph>Of<ph x="3">&lt;w3/&gt;</ph>Two<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は省略時のイテレータ型、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Indexing<ph x="6">&lt;w6/&gt;</ph>Iterator<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を使います、なぜならそれはそれ独自の<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>make<ph x="9">&lt;w9/&gt;</ph>Iterator()<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>メソッドまたは<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Iterator<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>関連型を定義しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol is used for types that have an inherent order, such as numbers and strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、本来備わっている順番を持つ型、例えば数や文字列などで使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Contiguous<ph x="2">&lt;w2/&gt;</ph>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Array<ph x="5">&lt;w5/&gt;</ph>Slice<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> types are not bridged; instances of those types always have a contiguous block of memory as their storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Contiguous<ph x="2">&lt;w2/&gt;</ph>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Array<ph x="5">&lt;w5/&gt;</ph>Slice<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型はブリッジされません；それらの型のインスタンスは常に隣接するメモリブロックをそれらのストレージとして持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Contiguous<ph x="2">&lt;w2/&gt;</ph>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type is a specialized array that always stores its elements in a contiguous region of memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Contiguous<ph x="2">&lt;w2/&gt;</ph>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、それの要素がメモリの隣接領域に常に格納される特殊化された配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Fixed<ph x="2">&lt;w2/&gt;</ph>Width<ph x="3">&lt;w3/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol adds binary bitwise operations, bit shifts, and overflow handling to the operations supported by the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Binary<ph x="6">&lt;w6/&gt;</ph>Integer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Fixed<ph x="2">&lt;w2/&gt;</ph>Width<ph x="3">&lt;w3/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、バイナリビット単位演算子、ビットシフト、そしてオーバーフロー処理を、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Binary<ph x="6">&lt;w6/&gt;</ph>Integer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルによってサポートされる演算に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Floating<ph x="2">&lt;w2/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol declares common arithmetic operations, so you can write functions and algorithms that work on any floating-point type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Floating<ph x="2">&lt;w2/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは通常の算術演算子を宣言します、それであなたは何らかの浮動小数点型上で働く関数およびアルゴリズムを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Indexing<ph x="2">&lt;w2/&gt;</ph>Iterator<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type is the default iterator for any collection that doesn’t declare its own.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Indexing<ph x="2">&lt;w2/&gt;</ph>Iterator<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、それ独自のものを宣言しないあらゆるコレクションに対する省略時のイテレータです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Iterator<ph x="2">&lt;w2/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol is tightly linked with the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Sequence<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Iterator<ph x="2">&lt;w2/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Sequence<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルときつく結び付けられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Iterator<ph x="2">&lt;w2/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> used by <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Map<ph x="5">&lt;w5/&gt;</ph>Sequence<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Map<ph x="8">&lt;w8/&gt;</ph>Collection<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Iterator<ph x="2">&lt;w2/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Map<ph x="5">&lt;w5/&gt;</ph>Sequence<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Map<ph x="8">&lt;w8/&gt;</ph>Collection<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>によって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol allows changing the values of a collection’s elements but not the length of the collection itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、コレクションのもつ要素の値の変更を可能にします、しかしコレクション自体の長さはそうではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Numeric<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol provides a suitable basis for arithmetic on scalar values, such as integers and floating-point numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Numeric<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、スカラー値、例えば整数および浮動小数点数などに関する算術にふさわしい基礎を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type is an enumeration with two cases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、２つのケース節を持つ列挙です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Random<ph x="2">&lt;w2/&gt;</ph>Access<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol adds further constraints on the associated <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Indices<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Sub<ph x="8">&lt;w8/&gt;</ph>Sequence<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> types, but otherwise imposes no additional requirements over the <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Bidirectional<ph x="11">&lt;w11/&gt;</ph>Collection<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Random<ph x="2">&lt;w2/&gt;</ph>Access<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、一層の制約を関連<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Indices<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>および<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Sub<ph x="8">&lt;w8/&gt;</ph>Sequence<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型に加えます、しかしそれ以外では<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Bidirectional<ph x="11">&lt;w11/&gt;</ph>Collection<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>プロトコルを超える追加要件は課されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Raw<ph x="2">&lt;w2/&gt;</ph>Representable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol is seen mainly in two categories of types: enumerations with raw value types and option sets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Raw<ph x="2">&lt;w2/&gt;</ph>Representable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルが主に見られるのは、２つの部類の型：列挙で生の値型を持つものとオプションセットにおいてです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O(<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>) unless documented otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは要素アクセスについて他の要件を設けません、それでシーケンスを辿っていくおきまりの仕事はO(<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>)と考えるべきです、そうでないと文書化されるのでない限り。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、準拠する型に関して、それらが反復によって破壊的に消費されることになるかについて要件を設けません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、シーケンスのもつ値への順次的なアクセスを頼りにするような多くの一般的な演算に対して省略時の実装を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Array<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> types each handle array literals in their own way to create new instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Array<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型は、それぞれ配列リテラルをそれら独自の方法で取り扱って、新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Signed<ph x="2">&lt;w2/&gt;</ph>Numeric<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol extends the operations defined by the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Numeric<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol to include a value’s additive inverse.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Signed<ph x="2">&lt;w2/&gt;</ph>Numeric<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Numeric<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルによって定義される演算を拡張して、値の加法の逆元を含めるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Street<ph x="2">&lt;w2/&gt;</ph>Address<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type now conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Equatable<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Street<ph x="2">&lt;w2/&gt;</ph>Address<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、今や<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Equatable<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Static<ph x="4">&lt;w4/&gt;</ph>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> types conform to the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Expressible<ph x="7">&lt;w7/&gt;</ph>By<ph x="8">&lt;w8/&gt;</ph>String<ph x="9">&lt;w9/&gt;</ph>Literal<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Static<ph x="4">&lt;w4/&gt;</ph>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型は、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Expressible<ph x="7">&lt;w7/&gt;</ph>By<ph x="8">&lt;w8/&gt;</ph>String<ph x="9">&lt;w9/&gt;</ph>Literal<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Static<ph x="4">&lt;w4/&gt;</ph>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Character<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Unicode<ph x="9">&lt;w9/&gt;</ph>.Scalar<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> types all conform to the <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Expressible<ph x="12">&lt;w12/&gt;</ph>By<ph x="13">&lt;w13/&gt;</ph>Unicode<ph x="14">&lt;w14/&gt;</ph>Scalar<ph x="15">&lt;w15/&gt;</ph>Literal<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Static<ph x="4">&lt;w4/&gt;</ph>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Character<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>、そして<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Unicode<ph x="9">&lt;w9/&gt;</ph>.Scalar<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>型は、すべて<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Expressible<ph x="12">&lt;w12/&gt;</ph>By<ph x="13">&lt;w13/&gt;</ph>Unicode<ph x="14">&lt;w14/&gt;</ph>Scalar<ph x="15">&lt;w15/&gt;</ph>Literal<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>プロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Static<ph x="4">&lt;w4/&gt;</ph>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Character<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> types conform to the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Expressible<ph x="9">&lt;w9/&gt;</ph>By<ph x="10">&lt;w10/&gt;</ph>Extended<ph x="11">&lt;w11/&gt;</ph>Grapheme<ph x="12">&lt;w12/&gt;</ph>Cluster<ph x="13">&lt;w13/&gt;</ph>Literal<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Static<ph x="4">&lt;w4/&gt;</ph>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Character<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>型は、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Expressible<ph x="9">&lt;w9/&gt;</ph>By<ph x="10">&lt;w10/&gt;</ph>Extended<ph x="11">&lt;w11/&gt;</ph>Grapheme<ph x="12">&lt;w12/&gt;</ph>Cluster<ph x="13">&lt;w13/&gt;</ph>Literal<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>プロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF16View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in which to find the new position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それにおいて新しい位置を見つける<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF16View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF8View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in which to find the new position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それにおいて新しい位置を見つける<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UTF8View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type, representing a single Unicode scalar value, is the element type of a string’s <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>unicode<ph x="5">&lt;w5/&gt;</ph>Scalars<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単一のユニコードスカラー値を表している、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、ある文字列のもつ<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>unicode<ph x="5">&lt;w5/&gt;</ph>Scalars<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>コレクションの要素型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Codec<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol declares methods that decode code unit sequences into Unicode scalar values and encode Unicode scalar values into code unit sequences.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Codec<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、コード単位シーケンスをユニコードスカラー値へデコードする、ユニコードスカラー値をコード単位シーケンスへエンコードするメソッドを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in which to find the new position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それにおいて新しい位置を見つける<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type provides no automated memory management, no type safety, and no alignment guarantees.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、自動メモリ管理、型安全、そしてアライメント保証を提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type provides no automated memory management, no type safety, and no alignment guarantees.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、自動メモリ管理、型安全、そしてアライメント保証を提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>adjective<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant is created by calling this initializer with a slice of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>picnic<ph x="4">&lt;w4/&gt;</ph>Guest<ph x="5">&lt;w5/&gt;</ph>.unicode<ph x="6">&lt;w6/&gt;</ph>Scalars<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>adjective<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数は、このイニシャライザを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>picnic<ph x="4">&lt;w4/&gt;</ph>Guest<ph x="5">&lt;w5/&gt;</ph>.unicode<ph x="6">&lt;w6/&gt;</ph>Scalars<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューのスライスとともに呼び出すことによって作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>adjective<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant is created by calling this initializer with a slice of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>picnic<ph x="4">&lt;w4/&gt;</ph>Guest<ph x="5">&lt;w5/&gt;</ph>.utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>adjective<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数は、このイニシャライザを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>picnic<ph x="4">&lt;w4/&gt;</ph>Guest<ph x="5">&lt;w5/&gt;</ph>.utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューのスライスとともに呼び出すことによって作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>adjective<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant is created by calling this initializer with a slice of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>picnic<ph x="4">&lt;w4/&gt;</ph>Guest<ph x="5">&lt;w5/&gt;</ph>.utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>adjective<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数は、このイニシャライザを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>picnic<ph x="4">&lt;w4/&gt;</ph>Guest<ph x="5">&lt;w5/&gt;</ph>.utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューのスライスとともに呼び出すことによって作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property can be cast back to its original type using one of the casting operators (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>as?<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>as!<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, or <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>as<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、それの元の型へキャストされて戻されることがキャスト演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>as?<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>as!<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、または<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>as<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>）を使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>binary<ph x="2">&lt;w2/&gt;</ph>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implementation uses the static <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>bit<ph x="5">&lt;w5/&gt;</ph>Width<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> property and the right shift operator (<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>&lt;&lt;<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>), both of which are available to any type that conforms to the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Fixed<ph x="10">&lt;w10/&gt;</ph>Width<ph x="11">&lt;w11/&gt;</ph>Integer<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>binary<ph x="2">&lt;w2/&gt;</ph>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>実装は、静的<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>bit<ph x="5">&lt;w5/&gt;</ph>Width<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロパティと右シフト演算子（<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>&lt;&lt;<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>）を使います、それらの両方とも<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Fixed<ph x="10">&lt;w10/&gt;</ph>Width<ph x="11">&lt;w11/&gt;</ph>Integer<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロトコルに準拠するあらゆる型で使用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>cafe<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> string is a collection of the nine characters that are visible in the printed string above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>cafe<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>文字列は、９つの文字からなる１つのコレクションで、上でプリントされる文字列に見えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property of an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Buffer<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance is always identical to <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>count<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Buffer<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、常に<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>count<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>と同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property of an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Buffer<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance is always identical to <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>count<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Buffer<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、常に<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>count<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>と同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property of an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Raw<ph x="7">&lt;w7/&gt;</ph>Buffer<ph x="8">&lt;w8/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance is always identical to <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>count<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Raw<ph x="7">&lt;w7/&gt;</ph>Buffer<ph x="8">&lt;w8/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、常に<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>count<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>と同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property of an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Raw<ph x="6">&lt;w6/&gt;</ph>Buffer<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance is always identical to <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>count<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Raw<ph x="6">&lt;w6/&gt;</ph>Buffer<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、常に<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>count<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>と同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>exponent<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property has the following edge cases:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>exponent<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、次の境界事例を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ph x="2">&lt;w2/&gt;</ph>Name<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant is an instance of the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Substring<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type—a type that represents substrings of a string while sharing the original string’s storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ph x="2">&lt;w2/&gt;</ph>Name<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Substring<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型 — ある文字列の下位文字列をオリジナル文字列のもつストレージを共有している間に表す型のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ph x="2">&lt;w2/&gt;</ph>Space<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant is an index into the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>text<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> string—the position of the first space in the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ph x="2">&lt;w2/&gt;</ph>Space<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>text<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>文字列へのあるインデックス — その文字列の中の最初の空白の位置、です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>get<ph x="2">&lt;w2/&gt;</ph>Default<ph x="3">&lt;w3/&gt;</ph>Value(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function uses optional chaining to safely call the implicitly unwrapped class method on <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>c<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>get<ph x="2">&lt;w2/&gt;</ph>Default<ph x="3">&lt;w3/&gt;</ph>Value(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は、オプショナル連鎖を使って、暗黙的にアンラップされるクラスメソッドを<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>c<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>上で安全に呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>hash<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property in this example combines the hash value of a grid point’s <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>x<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> property with the hash value of its <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>y<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> property multiplied by a prime constant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>hash<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティはこの例において、格子点の<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>x<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロパティのハッシュ値と素数定数によって乗算したそれの<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>y<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロパティのハッシュ値を結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>high<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> component of the value carries the sign, if the type is signed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>high<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>構成部分は符号を運びます、その型が符号付きならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>invalid<ph x="2">&lt;w2/&gt;</ph>Input<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> case includes the invalid character as an associated value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>invalid<ph x="2">&lt;w2/&gt;</ph>Input<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ケース節は、無効な文字を関連値として含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Equal(to:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method implements the equality predicate defined by the <bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754 specification<ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Equal(to:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754仕様<ept i="3">&lt;/a3&gt;</ept>によって定義される同等性述部を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Known<ph x="3">&lt;w3/&gt;</ph>Uniquely<ph x="4">&lt;w4/&gt;</ph>Referenced(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function is useful for implementing the copy-on-write optimization for the deep storage of value types:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Known<ph x="3">&lt;w3/&gt;</ph>Uniquely<ph x="4">&lt;w4/&gt;</ph>Referenced(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は、値型の深い貯蔵に対してコピーオンライト最適化を実装するのに便利です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Less(than:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method implements the less-than predicate defined by the <bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754 specification<ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Less(than:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754仕様<ept i="3">&lt;/a3&gt;</ept>によって定義される「より少ない」述部を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Less<ph x="3">&lt;w3/&gt;</ph>Than<ph x="4">&lt;w4/&gt;</ph>Or<ph x="5">&lt;w5/&gt;</ph>Equal<ph x="6">&lt;w6/&gt;</ph>To(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method implements the less-than-or-equal predicate defined by the <bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754 specification<ept i="7">&lt;/a7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Less<ph x="3">&lt;w3/&gt;</ph>Than<ph x="4">&lt;w4/&gt;</ph>Or<ph x="5">&lt;w5/&gt;</ph>Equal<ph x="6">&lt;w6/&gt;</ph>To(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754仕様<ept i="7">&lt;/a7&gt;</ept>によって定義される「より少ないか等しい」述部を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Totally<ph x="3">&lt;w3/&gt;</ph>Ordered(below<ph x="4">&lt;w4/&gt;</ph>Or<ph x="5">&lt;w5/&gt;</ph>Equal<ph x="6">&lt;w6/&gt;</ph>To:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method implements the total order relation as defined by the <bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754 specification<ept i="7">&lt;/a7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Totally<ph x="3">&lt;w3/&gt;</ph>Ordered(below<ph x="4">&lt;w4/&gt;</ph>Or<ph x="5">&lt;w5/&gt;</ph>Equal<ph x="6">&lt;w6/&gt;</ph>To:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、全順序関係を<bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754仕様<ept i="7">&lt;/a7&gt;</ept>によって定義されるとおりに実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Zero<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property of a value <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>x<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>true<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> when <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>x<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> represents either <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>-0<ph x="11">&lt;w11/&gt;</ph>.0<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> or <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>+0<ph x="14">&lt;w14/&gt;</ph>.0<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>x<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Zero<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティが<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>true<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>であるのは、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>x<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>が<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>-0<ph x="11">&lt;w11/&gt;</ph>.0<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>または<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>+0<ph x="14">&lt;w14/&gt;</ph>.0<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>のどちらかを表す場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>joined<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method is always lazy, but does not implicitly confer laziness on algorithms applied to its result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>joined<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは常に遅延です、しかしそれの結果に適用されるアルゴリズム上に、遅延性を暗黙的に授けられません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>make<ph x="2">&lt;w2/&gt;</ph>Iterator()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method returns another custom type, an iterator named <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Countdown<ph x="5">&lt;w5/&gt;</ph>Iterator<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>make<ph x="2">&lt;w2/&gt;</ph>Iterator()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、別のあつらえの型、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Countdown<ph x="5">&lt;w5/&gt;</ph>Iterator<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と名前をつけられるイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>maximum<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method implements the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>max<ph x="4">&lt;w4/&gt;</ph>Num<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> operation defined by the <bpt i="5" x="5">&lt;a5&gt;</bpt>IEEE 754 specification<ept i="5">&lt;/a5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>maximum<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="5" x="5">&lt;a5&gt;</bpt>IEEE 754仕様<ept i="5">&lt;/a5&gt;</ept>によって定義される<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>max<ph x="4">&lt;w4/&gt;</ph>Num<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>maximum<ph x="2">&lt;w2/&gt;</ph>Magnitude<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method implements the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>max<ph x="5">&lt;w5/&gt;</ph>Num<ph x="6">&lt;w6/&gt;</ph>Mag<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> operation defined by the <bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754 specification<ept i="7">&lt;/a7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>maximum<ph x="2">&lt;w2/&gt;</ph>Magnitude<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754仕様<ept i="7">&lt;/a7&gt;</ept>によって定義される<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>max<ph x="5">&lt;w5/&gt;</ph>Num<ph x="6">&lt;w6/&gt;</ph>Mag<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>minimum<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method implements the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>min<ph x="4">&lt;w4/&gt;</ph>Num<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> operation defined by the <bpt i="5" x="5">&lt;a5&gt;</bpt>IEEE 754 specification<ept i="5">&lt;/a5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>minimum<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>min<ph x="4">&lt;w4/&gt;</ph>Num<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>演算を実装します、それは<bpt i="5" x="5">&lt;a5&gt;</bpt>IEEE 754仕様<ept i="5">&lt;/a5&gt;</ept>によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>minimum<ph x="2">&lt;w2/&gt;</ph>Magnitude<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method implements the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>min<ph x="5">&lt;w5/&gt;</ph>Num<ph x="6">&lt;w6/&gt;</ph>Mag<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> operation defined by the <bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754 specification<ept i="7">&lt;/a7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>minimum<ph x="2">&lt;w2/&gt;</ph>Magnitude<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754仕様<ept i="7">&lt;/a7&gt;</ept>によって定義される<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>min<ph x="5">&lt;w5/&gt;</ph>Num<ph x="6">&lt;w6/&gt;</ph>Mag<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ph x="2">&lt;w2/&gt;</ph>Partial<ph x="3">&lt;w3/&gt;</ph>Result<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure is called sequentially with an accumulating value initialized to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>initial<ph x="6">&lt;w6/&gt;</ph>Result<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and each element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ph x="2">&lt;w2/&gt;</ph>Partial<ph x="3">&lt;w3/&gt;</ph>Result<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャは、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>initial<ph x="6">&lt;w6/&gt;</ph>Result<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に初期化された蓄積値とシーケンスの各要素とともに連続して呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ph x="2">&lt;w2/&gt;</ph>Partial<ph x="3">&lt;w3/&gt;</ph>Result<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure is called with <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>initial<ph x="6">&lt;w6/&gt;</ph>Result<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>—<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>0<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> in this case—and the first element of <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>numbers<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>, returning the sum: <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>1<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ph x="2">&lt;w2/&gt;</ph>Partial<ph x="3">&lt;w3/&gt;</ph>Result<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャが、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>initial<ph x="6">&lt;w6/&gt;</ph>Result<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>—この場合では<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>0<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>と<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>numbers<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>の最初の要素とともに呼び出されて、その合計：<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>1<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array is now arranged in two partitions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列は今や２つの区画に整頓されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numeric<ph x="2">&lt;w2/&gt;</ph>Cast(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function traps on overflow in <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>-O<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>-Onone<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> builds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numeric<ph x="2">&lt;w2/&gt;</ph>Cast(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>-O<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>および<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>-Onone<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>ビルドにおいてオーパーフローでトラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>perform(_:<ph x="2">&lt;w2/&gt;</ph>simultaneously<ph x="3">&lt;w3/&gt;</ph>With:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function ends with a call to the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>sync(flags:<ph x="6">&lt;w6/&gt;</ph>execute:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method using the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>.barrier<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> flag, which forces the function to wait until both closures have completed running before returning.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>perform(_:<ph x="2">&lt;w2/&gt;</ph>simultaneously<ph x="3">&lt;w3/&gt;</ph>With:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>sync(flags:<ph x="6">&lt;w6/&gt;</ph>execute:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドへの <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>.barrier<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>フラグを使った呼び出しで終わります、それはその関数に返る前に両方のクロージャが実行を完了し終わるまで待つことを強要します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reduce1(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method makes certain kinds of sequence operations simpler.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reduce1(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、特定の種類のシーケンス演算をより簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>response<ph x="2">&lt;w2/&gt;</ph>Messages<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> variable is inferred to have type <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>[Int: String]<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>response<ph x="2">&lt;w2/&gt;</ph>Messages<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>変数は、型<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>[Int: String]<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を持つと推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reversed()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method is always lazy when applied to a collection with bidirectional indices, but does not implicitly confer laziness on algorithms applied to its result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x.reversed()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、双方向性のインデックスを持つコレクションに適用される時は常に遅延です、しかしそれの結果に適用されるアルゴリズムに暗黙的に遅延性を授けることはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>round()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method uses the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.to<ph x="4">&lt;w4/&gt;</ph>Nearest<ph x="5">&lt;w5/&gt;</ph>Or<ph x="6">&lt;w6/&gt;</ph>Away<ph x="7">&lt;w7/&gt;</ph>From<ph x="8">&lt;w8/&gt;</ph>Zero<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> rounding rule, where a value halfway between two integral values is rounded to the one with greater magnitude.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>round()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.to<ph x="4">&lt;w4/&gt;</ph>Nearest<ph x="5">&lt;w5/&gt;</ph>Or<ph x="6">&lt;w6/&gt;</ph>Away<ph x="7">&lt;w7/&gt;</ph>From<ph x="8">&lt;w8/&gt;</ph>Zero<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>丸め規則を使います、そこでは２つの整数値の間の中ほどの値はより大きい規模を持つものへと丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rounded()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method uses the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.to<ph x="4">&lt;w4/&gt;</ph>Nearest<ph x="5">&lt;w5/&gt;</ph>Or<ph x="6">&lt;w6/&gt;</ph>Away<ph x="7">&lt;w7/&gt;</ph>From<ph x="8">&lt;w8/&gt;</ph>Zero<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> rounding rule, where a value halfway between two integral values is rounded to the one with greater magnitude.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rounded()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.to<ph x="4">&lt;w4/&gt;</ph>Nearest<ph x="5">&lt;w5/&gt;</ph>Or<ph x="6">&lt;w6/&gt;</ph>Away<ph x="7">&lt;w7/&gt;</ph>From<ph x="8">&lt;w8/&gt;</ph>Zero<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>丸め規則を使います、そこでは２つの整数値の間の中ほどの値はより大きい規模を持つものへと丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sign<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.minus<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> if the value’s signbit is set, and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>.plus<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sign<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、値のsignbitがセットされるならば<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>.minus<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です、そしてそうでないなら<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>.plus<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>significand<ph x="2">&lt;w2/&gt;</ph>Bit<ph x="3">&lt;w3/&gt;</ph>Pattern<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property does not include the leading integral bit of the significand, even for types like <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Float80<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> that store it explicitly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>significand<ph x="2">&lt;w2/&gt;</ph>Bit<ph x="3">&lt;w3/&gt;</ph>Pattern<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、仮数の先頭整数ビットを含みません、それを明示的に格納する<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Float80<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のような型に対してさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sink<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure is called with each resulting UTF-32 code unit as the function iterates over its input.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sink<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャは、結果UTF-32コードユニットそれぞれで、それのinputに反復していく関数として呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property of an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Buffer<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance is always zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Buffer<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、常にゼロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property of an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Buffer<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance is always zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Buffer<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、常にゼロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sum()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method is now available on any sequence or collection with numeric values, whether it is an array of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Double<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> or a countable range of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Int<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sum()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、今では数値によるあらゆるシーケンスまたはコレクションで利用可能です、それが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Double<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の配列であろうと<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Int<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の可付番範囲であろうと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>ulp<ph x="2">&lt;w2/&gt;</ph>Of<ph x="3">&lt;w3/&gt;</ph>One<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant corresponds to the C macros <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>FLT_EPSILON<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>DBL_EPSILON<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, and others with a similar purpose.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>ulp<ph x="2">&lt;w2/&gt;</ph>Of<ph x="3">&lt;w3/&gt;</ph>One<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数は、Cマクロ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>FLT_EPSILON<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>DBL_EPSILON<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>、そして類似した目的を持つ他のものに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view’s elements comprise each Unicode scalar value in the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>cafe<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューのもつ各要素は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>cafe<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>文字列の中の各ユニコードスカラー値からなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unsafely<ph x="2">&lt;w2/&gt;</ph>Unwrapped<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property is recommended over calling the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>unsafe<ph x="5">&lt;w5/&gt;</ph>Bit<ph x="6">&lt;w6/&gt;</ph>Cast(_:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> function because the property is more restrictive and because accessing the property still performs checking in debug builds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unsafely<ph x="2">&lt;w2/&gt;</ph>Unwrapped<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>unsafe<ph x="5">&lt;w5/&gt;</ph>Bit<ph x="6">&lt;w6/&gt;</ph>Cast(_:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>関数呼び出し全般で推奨されます、なぜならこのプロパティはより制限的であるから、そしてこのプロパティにアクセスすることはデバッグビルドにおいて依然として確認を実行するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unsafely<ph x="2">&lt;w2/&gt;</ph>Unwrapped<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property provides the same value as the forced unwrap operator (postfix <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>!<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unsafely<ph x="2">&lt;w2/&gt;</ph>Unwrapped<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、強制アンラップ演算子（後置<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>!<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）と同じ値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>with<ph x="2">&lt;w2/&gt;</ph>Unsafe<ph x="3">&lt;w3/&gt;</ph>Mutable<ph x="4">&lt;w4/&gt;</ph>Pointer(to:<ph x="5">&lt;w5/&gt;</ph>_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function is useful for calling Objective-C APIs that take in/out parameters (and default-constructible out parameters) by pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>with<ph x="2">&lt;w2/&gt;</ph>Unsafe<ph x="3">&lt;w3/&gt;</ph>Mutable<ph x="4">&lt;w4/&gt;</ph>Pointer(to:<ph x="5">&lt;w5/&gt;</ph>_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は、ポインタによって「in/out」パラメータ（そして何もしなくとも構築可能な「out」パラメーター）を取るObjective-C APIを呼ぶのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>with<ph x="2">&lt;w2/&gt;</ph>Unsafe<ph x="3">&lt;w3/&gt;</ph>Pointer(to:<ph x="4">&lt;w4/&gt;</ph>_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function is useful for calling Objective-C APIs that take in/out parameters (and default-constructible out parameters) by pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>with<ph x="2">&lt;w2/&gt;</ph>Unsafe<ph x="3">&lt;w3/&gt;</ph>Pointer(to:<ph x="4">&lt;w4/&gt;</ph>_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は、ポインタによって「in/out」パラメータ（そして何もしなくとも構築可能な「out」パラメーター）を取るObjective-C APIを呼ぶのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>~=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator is used internally in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>case<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> statements for pattern matching.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>~=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子は内部的に<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>case<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>文内でパターンマッチングのために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>base<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> property of the slice is equal to <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>single<ph x="14">&lt;w14/&gt;</ph>Digits<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このスライスの<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>base<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>プロパティは、<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>single<ph x="14">&lt;w14/&gt;</ph>Digits<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>binade<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> property is a member of the same binade as this value, but with a unit significand.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>binade<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロパティは、この値と同じbinadeに属するあるメンバです、しかしある単位仮数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type bridges with the Objective-C class <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>NSString<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and offers interoperability with C functions that works with strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型は、Objective-Cクラス<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>NSString<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>とブリッジします、そしてC関数で文字列を扱うものと相互運用を提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Substring<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type presents the same interface as <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, so you can avoid or defer any copying of the string’s contents.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Substring<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と同じインターフェイスを提供します、それであなたは文字列の内容の何らかのコピーを避けるまたは延期できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>make<ph x="4">&lt;w4/&gt;</ph>Iterator()<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method is provided as a default implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>make<ph x="4">&lt;w4/&gt;</ph>Iterator()<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドは、省略時の実装として提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>move<ph x="4">&lt;w4/&gt;</ph>Initialize<ph x="5">&lt;w5/&gt;</ph>Memory(as:<ph x="6">&lt;w6/&gt;</ph>from:<ph x="7">&lt;w7/&gt;</ph>count:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method automatically performs a forward or backward copy of all instances from the source region to their destination.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>move<ph x="4">&lt;w4/&gt;</ph>Initialize<ph x="5">&lt;w5/&gt;</ph>Memory(as:<ph x="6">&lt;w6/&gt;</ph>from:<ph x="7">&lt;w7/&gt;</ph>count:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドは、すべてのインスタンスの前方および後方へのコピーをソース領域からそれらの行き先へ自動的に実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>strncmp<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> function takes two <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>const char*<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> pointers and an integer specifying the number of characters to compare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>strncmp<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>関数は、２つの<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>const char*<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ポインタと、比較する文字数を指定している整数を取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Array<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type’s <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>append(_:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>append(contents<ph x="9">&lt;w9/&gt;</ph>Of:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> methods take care of this detail for you, but <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>reserve<ph x="12">&lt;w12/&gt;</ph>Capacity(_:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> allocates only as much space as you tell it to (padded to a round value), and no more.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Array<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型の<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>append(_:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>と<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>append(contents<ph x="9">&lt;w9/&gt;</ph>Of:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>メソッドは、この詳細をあなたの代わりに面倒を見ます、しかし<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>reserve<ph x="12">&lt;w12/&gt;</ph>Capacity(_:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>はあなたがそれに伝える（ある丸め値に詰め込まれた）のと同じ程度の空間だけをアロケートして、それ以上は何もしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Binary<ph x="5">&lt;w5/&gt;</ph>Integer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol provides initializers for four different kinds of conversion.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Binary<ph x="5">&lt;w5/&gt;</ph>Integer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルは、イニシャライザを４つの異なる種類の変換に対して提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>raw<ph x="5">&lt;w5/&gt;</ph>Value<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> property must be of a type that conforms to the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Fixed<ph x="8">&lt;w8/&gt;</ph>Width<ph x="9">&lt;w9/&gt;</ph>Integer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> protocol, such as <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Int<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> or <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>UInt8<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>raw<ph x="5">&lt;w5/&gt;</ph>Value<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロパティは、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Fixed<ph x="8">&lt;w8/&gt;</ph>Width<ph x="9">&lt;w9/&gt;</ph>Integer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>プロトコルに準拠する型の１つでなければなりません、例えば<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Int<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>または<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>UInt8<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>remove<ph x="5">&lt;w5/&gt;</ph>Last()<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method must be used only on a nonempty collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>remove<ph x="5">&lt;w5/&gt;</ph>Last()<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドは、空でないコレクションでのみ使われるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Countdown<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> structure’s definition is short: It contains only the starting count and the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>make<ph x="8">&lt;w8/&gt;</ph>Iterator()<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> method required by the <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Sequence<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Countdown<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>構造体の定義は短いです：それはただ数え始めと<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Sequence<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>プロトコルによって要求される<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>make<ph x="8">&lt;w8/&gt;</ph>Iterator()<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>メソッドだけを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String(describing:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> initializer is the preferred way to convert an instance of <bpt i="6" x="6">&lt;e6&gt;</bpt>any<ept i="6">&lt;/e6&gt;</ept> type to a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String(describing:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>イニシャライザは、<bpt i="6" x="6">&lt;e6&gt;</bpt>あらゆる<ept i="6">&lt;/e6&gt;</ept>型のインスタンスをある文字列へ変換する好ましい方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>form<ph x="6">&lt;w6/&gt;</ph>Truncating<ph x="7">&lt;w7/&gt;</ph>Remainder(dividing<ph x="8">&lt;w8/&gt;</ph>By:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method is always exact.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>form<ph x="6">&lt;w6/&gt;</ph>Truncating<ph x="7">&lt;w7/&gt;</ph>Remainder(dividing<ph x="8">&lt;w8/&gt;</ph>By:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドは常に正確です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>remainder(dividing<ph x="6">&lt;w6/&gt;</ph>By:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method is always exact.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>remainder(dividing<ph x="6">&lt;w6/&gt;</ph>By:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドは常に厳密に正確です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>truncating<ph x="6">&lt;w6/&gt;</ph>Remainder(dividing<ph x="7">&lt;w7/&gt;</ph>By:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method is always exact.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>truncating<ph x="6">&lt;w6/&gt;</ph>Remainder(dividing<ph x="7">&lt;w7/&gt;</ph>By:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドは常に正確です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>..&lt;<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> operator creates a range that doesn’t include the upper bound, so it’s always safe to use with <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>end<ph x="9">&lt;w9/&gt;</ph>Index<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>..&lt;<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>演算子は上方の境界を含まないある範囲を作成します、それでそれは常に<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>end<ph x="9">&lt;w9/&gt;</ph>Index<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>と使うのに安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Hashable<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> protocol inherits from the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Equatable<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> protocol, so you must also add an equal-to operator (<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>==<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>) function for your custom type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Hashable<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロトコルは、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Equatable<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>プロトコルから継承します、それであなたはまた同等演算子（<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>==<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>）関数をあなたのあつらえの型に加える必要もまたあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Key<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> type of the dictionary is <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Int<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, and the <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Value<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> type of the dictionary is <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>String<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Key<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>型は<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Int<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>です、そして辞書の<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Value<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>型は<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>String<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>==<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> operator is a requirement of the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Equatable<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> protocol, which <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Comparable<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> extends—see that protocol’s documentation for more information about equality in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>==<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>演算子は、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Comparable<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>が拡張する<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Equatable<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>プロトコルの要件です — そのプロトコルの文書をSwiftにおける同等性についてのさらなる情報のために見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Countdown<ph x="8">&lt;w8/&gt;</ph>Iterator<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type keeps track of both the <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Countdown<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> sequence that it’s iterating and the number of times it has returned a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Countdown<ph x="8">&lt;w8/&gt;</ph>Iterator<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型は、それが反復している<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Countdown<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>シーケンスそしてそれが値を返した回数の両方の情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Dictionary<ph x="8">&lt;w8/&gt;</ph>Literal<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instance preserves the order of the elements as passed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Dictionary<ph x="8">&lt;w8/&gt;</ph>Literal<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスは、要素の順番を渡された通りに保全します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Set<ph x="10">&lt;w10/&gt;</ph>Algebra<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> protocol is specifically designed to accommodate both kinds of set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Set<ph x="10">&lt;w10/&gt;</ph>Algebra<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロトコルは、とりわけ両方の種類の集合に配慮するように設計されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>deinit<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> of <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>buffer<ph x="12">&lt;w12/&gt;</ph>Class<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> must destroy its stored <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>Header<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> and any constructed <bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>Element<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>buffer<ph x="12">&lt;w12/&gt;</ph>Class<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>の<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>deinit<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>は、それの保存した<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>Header<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>とあらゆる構成した<bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>Element<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>を破棄しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>exponent<ept i="0">&lt;/e0&gt;</ept> of a floating-point value is the integer part of the logarithm of the value’s magnitude.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点値の<bpt i="0" x="0">&lt;e0&gt;</bpt>指数<ept i="0">&lt;/e0&gt;</ept>は、値の規模の対数の整数部分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;e2&gt;</bpt>static type<ept i="2">&lt;/e2&gt;</ept> of a value is the known, compile-time type of the value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値の<bpt i="2" x="2">&lt;e2&gt;</bpt>static type<ept i="2">&lt;/e2&gt;</ept>は、既知の、コンパイル時のその値の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;e3&gt;</bpt>dynamic type<ept i="3">&lt;/e3&gt;</ept> of a value is the value’s actual type at run-time, which may be nested inside its concrete type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値の<bpt i="3" x="3">&lt;e3&gt;</bpt>動的<ept i="3">&lt;/e3&gt;</ept>は、その値の実行時での実際の型です、それはそれの具象型の内部に入れ子にされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;e4&gt;</bpt>exponent bias<ept i="4">&lt;/e4&gt;</ept> of a type <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>F<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> can be calculated as the following, where <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>**<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> is exponentiation:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>F<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の<bpt i="4" x="4">&lt;e4&gt;</bpt>指数バイアス<ept i="4">&lt;/e4&gt;</ept>は、以下のように計算されます、ここで<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>**<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>は冪です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The ASCII representation of a number in the radix passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>radix<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>radix<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡される基数におけるある数のASCII表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Boolean value to copy.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コピーされるブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Boolean value to negate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>否定するブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bool<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Boolean<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> types and the Objective-C <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>BOOL<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type are all bridged into Swift as <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Bool<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bool<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Boolean<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型とObjective-Cの<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>BOOL<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型は、すべてSwiftに<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Bool<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>としてブリッジされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C ‘_Bool’ and C++ ‘bool’ type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cの「_Bool」およびC++の「bool」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C ‘char’ type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cの「char」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C ‘double’ type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C「double」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C ‘float’ type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C「float」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C ‘int’ type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C「int」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C ‘short’ type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C「short」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C ‘signed char’ type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C「signed char」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C ‘unsigned char’ type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C「unsigned char」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C ‘unsigned int’ type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C「unsigned int」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C ‘unsigned long long’ type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C「unsigned long long」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C ‘unsigned long’ type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C「unsigned long」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C ‘unsigned short’ type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C「unsigned short」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C++ ‘wchar_t’ type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C++「wchar_t」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C++11 ‘char16_t’ type, which has UTF-16 encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C++11「char16_t」型、それはUTF-16エンコーディングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The C++11 ‘char32_t’ type, which has UTF-32 encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C++11「char32_t」型、それはUTF-32エンコーディングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The IEEE 754 floating-point classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>IEEE 754浮動小数点の様々な部類。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The NaN values in the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>temps<ph x="2">&lt;w2/&gt;</ph>Celsius<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array are propagated through the conversion and remain NaN in <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>temps<ph x="5">&lt;w5/&gt;</ph>Fahrenheit<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>temps<ph x="2">&lt;w2/&gt;</ph>Celsius<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列の中のNaN値は、変換を通して伝播されていき、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>temps<ph x="5">&lt;w5/&gt;</ph>Fahrenheit<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>においてNaNのままです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift standard library defines a base layer of functionality for writing Swift programs, including:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift標準ライブラリは、Swiftプログラムを記述するための機能性の基盤層を定義していて、以下を含んでいます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift standard library’s text-related types, <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>String<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Character<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>, and <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Unicode<ph x="14">&lt;w14/&gt;</ph>.Scalar<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>, all conform to <bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>Text<ph x="17">&lt;w17/&gt;</ph>Output<ph x="18">&lt;w18/&gt;</ph>Streamable<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift標準ライブラリのテキスト関連の型、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>String<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Character<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>、そして<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Unicode<ph x="14">&lt;w14/&gt;</ph>.Scalar<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>は、すべて<bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>Text<ph x="17">&lt;w17/&gt;</ph>Output<ph x="18">&lt;w18/&gt;</ph>Streamable<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The UTF-16 code units of a string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view match the elements accessed through indexed <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSString<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> APIs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューのUTF-16コード単位は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSString<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> APIでインデックスを使われることでアクセスされる要素と一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Unicode code point <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"\u{301}"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> modifies the preceding character to include an accent, so <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>"e\u{301}"<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> has the same canonical representation as the single Unicode code point <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"é"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードコード点<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"\u{301}"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、先行する文字を修飾してアクセントを含めます、それで<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>"e\u{301}"<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は単一のユニコード点<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"é"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と同じ正準表現を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Unicode code point to use for the scalar.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このスカラーのために使うユニコードコード点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Unicode encoding of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>input<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>input<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のユニコードエンコーディング。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Unicode encoding of the data referenced by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>c<ph x="2">&lt;w2/&gt;</ph>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によって参照されるデータのユニコードエンコーディング。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Unicode scalar value of <bpt i="1" x="1">&lt;e1&gt;</bpt>A<ept i="1">&lt;/e1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>65<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, which is small enough to fit in a single code unit in both UTF-16 and UTF-8.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;e1&gt;</bpt>A<ept i="1">&lt;/e1&gt;</ept>のユニコードスカラー値は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>65<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です、それはUTF-16およびUTF-8両方において単一のコード単位の中にぴったり収まるにの十分に小さいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Unicode scalar value to convert into a character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つの文字へ変換するユニコードスカラー値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Unicode scalar’s hash value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードスカラーのもつハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Unicode-safe comparison matches Unicode scalar values rather than the code points used to compose them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコード安全での比較は、ユニコードスカラー値を比べます、それらを組み立てるのに使われるコード点ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The absence of a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値の不在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The absolute value of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be representable in the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の絶対値は、同じ型において表現可能である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The absolute value of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の絶対値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The accessed slice uses the same indices for the same elements as the original collection uses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセスされるスライス（切り取り）は、同じ要素に対して元のコレクションが使うのと同じインデックスを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The accessed slice uses the same indices for the same elements as the original collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセスされるスライス（切り取り）は、同じ要素に対して元のコレクションと同じインデックスを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The actual capacity of the created dictionary is the smallest power of 2 that is greater than or equal to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>minimum<ph x="2">&lt;w2/&gt;</ph>Capacity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>作成された辞書の実際の容量は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>minimum<ph x="2">&lt;w2/&gt;</ph>Capacity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>より大きいか等しい最も小さい２の冪です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The actual capacity of the created set will be the smallest power of 2 that is greater than or equal to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>minimum<ph x="2">&lt;w2/&gt;</ph>Capacity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>作成された集合の実際の容量は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>minimum<ph x="2">&lt;w2/&gt;</ph>Capacity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>より大きいか等しい最も小さい２の冪です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The actual number of elements that can be stored in this object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このオブジェクトに格納できる要素の実際の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The addition operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) calculates the sum of its two arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、それの２つの引数の合計を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The additive inverse of this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値の加法の逆元。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The address of the memory that starts the buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリのアドレス、それはバッファを始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The address passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bit<ph x="2">&lt;w2/&gt;</ph>Pattern<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must have the correct alignment for the pointer’s <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Pointee<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bit<ph x="2">&lt;w2/&gt;</ph>Pattern<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡されるアドレスは、ポインタの持つ<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Pointee<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型に対して整合状態でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The alignment of the new region of allocated memory, in bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アロケートされたメモリの新しい領域のアラインメント、バイトで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The alignment of the region to be deallocated, in bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デアロケートされることになる領域のアライメント、バイトで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The allocated memory is not bound to any specific type and must be bound before performing any typed operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アロケートされたメモリは、何ら特定の型に束縛されません、そして何らかの型付き演算を実行する前に束縛されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The allowed formats for each of these representations is then as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの表現のそれぞれに対する許される形式はそれで以下になります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The alpha-2 code for The United States is “US”, so its flag character is made up of the Unicode code points <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"\u{1F1FA}"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> (REGIONAL INDICATOR SYMBOL LETTER U) and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>"\u{1F1F8}"<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> (REGIONAL INDICATOR SYMBOL LETTER S).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アメリカ合衆国に対するalpha-2コードは、「US」です、それでそれの国旗文字はユニコードコード点<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"\u{1F1FA}"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>（REGIONAL INDICATOR SYMBOL LETTER U）と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>"\u{1F1F8}"<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>（REGIONAL INDICATOR SYMBOL LETTER S）から作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The amount of memory to allocate, counted in instances of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アロケートするメモリの総量、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスで数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The amount of memory to bind to type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, counted as instances of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>へと束縛するメモリの量、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のインスタンスとして数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The amount of memory to deallocate, counted in instances of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デアロケートするメモリの総量、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスで数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The argument is valid only for the duration of the closure’s execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数は、ただクロージャの実行の間に対してのみ有効とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The array to append to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>追加先の配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The arrays in the “values” position of the new dictionary each contain at least one element, with the elements in the same order as the source sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい辞書の「values」位置での配列は、それぞれ少なくとも１つの要素を含み、元となるシーケンスと同じ順序で要素を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The array’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type must be a <bpt i="2" x="2">&lt;e2&gt;</bpt>trivial type<ept i="2">&lt;/e2&gt;</ept>, which can be copied with just a bit-for-bit copy without any indirection or reference-counting operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この配列の持つ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は<bpt i="2" x="2">&lt;e2&gt;</bpt>自明型<ept i="2">&lt;/e2&gt;</ept>でなければなりません、それは単にビット対ビットコピーでコピーされることが、何らかの間接参照または参照カウント操作なしで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The array’s “past the end” position—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The assignment to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>o<ph x="2">&lt;w2/&gt;</ph>Breve<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant calls this initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>o<ph x="2">&lt;w2/&gt;</ph>Breve<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数への代入は、このイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The associated <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type is both the element and index type of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Countable<ph x="4">&lt;w4/&gt;</ph>Range<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、要素およびインデックスの両方とも<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Countable<ph x="4">&lt;w4/&gt;</ph>Range<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The available number of fractional significand bits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>利用可能な小数の仮数ビットの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The base, precision, and exponent range are not fixed in any way by this protocol, but it enforces the basic requirements of any IEEE 754 floating-point type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基数、精度、そして指数範囲は、このプロトコルによって何らかの方法で固定されません、しかしそれはIEEE 754浮動小数点型どれかの基本要件を強要します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The behavior of accessing memory as a type unrelated to its bound type is undefined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリにそれの束縛型と関係ない型でアクセスすることの挙動は未定義です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The behavior of incrementing indefinitely is determined by the type of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無限に漸増する挙動は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bound<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の型によって決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The big-endian representation of this integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この整数のビッグエンディアン表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bit pattern matches the binary interchange format defined by the <bpt i="0" x="0">&lt;a0&gt;</bpt>IEEE 754 specification<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビットパターンは<bpt i="0" x="0">&lt;a0&gt;</bpt>IEEE 754仕様<ept i="0">&lt;/a0&gt;</ept>で定義されるバイナリ交換形式に一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bit pattern of the value’s encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値の持つエンコーディングのビットパターン。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bit pattern to use for the exponent field of the new value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい値の指数フィールドに使うためのビットパターン。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bit pattern to use for the significand field of the new value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい値の仮数フィールドに使うためのビットパターン。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bitwise NOT operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>~<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) is a prefix operator that returns a value in which all the bits of its argument are flipped: Bits that are <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>1<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> in the argument are <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>0<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> in the result, and bits that are <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>0<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> in the argument are <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>1<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> in the result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位のNOT演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>~<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は前置演算子で、それの引数のビットすべてがひっくり返されるある値を返します：引数において<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>1<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>であるビットは結果において<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>0<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>になります、そして引数において<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>0<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>であるビットは結果において<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>1<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bound type of the range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲の境界型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bounds of the range must be valid indices of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲の境界は、配列の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bounds of the range must be valid indices of the character view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この範囲の境界は、文字ビューの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bounds of the range must be valid indices of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この範囲の境界は、コレクションの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bounds of the range must be valid indices of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この範囲の境界は、文字列の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bounds of the range must be valid indices of the view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この範囲の境界は、ビューの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bounds of the result are always limited to the bounds of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>limits<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果の領域は、常に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>limits<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の領域に制限されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The buffer is the size of the instance passed as <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>arg<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and does not include any remote storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファは、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>arg<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>として渡されるインスタンスの大きさで、あらゆるリモートストレージを含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The buffer must contain sufficient uninitialized memory to accommodate <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>source<ph x="4">&lt;w4/&gt;</ph>.underestimated<ph x="5">&lt;w5/&gt;</ph>Count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>source<ph x="4">&lt;w4/&gt;</ph>.underestimated<ph x="5">&lt;w5/&gt;</ph>Count<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を収容するのに十分な未初期化メモリを含まなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The buffer pointer argument is valid only for the duration of the closure’s execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファポインタは、ただクロージャの実行の間に対してのみ有効とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The buffer pointer argument to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure provides a collection interface to the raw bytes of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>arg<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャへのバッファポインタ引数は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>arg<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の生のバイトへのコレクションインターフェイスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The buffer pointer plus <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>offset<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be properly aligned for accessing an instance of type <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>offset<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を加えたバッファポインタは、型<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のインスタンスにアクセスするために適切にアラインされる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The buffer to convert.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変換されることになるバッファ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The buffer’s type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a trivial type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファのもつ型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、自明型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bytes for <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>a<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> are copied from the first four bytes of <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>some<ph x="9">&lt;w9/&gt;</ph>Bytes<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, and the bytes for <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>b<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> are copied from the next four bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>a<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に対するバイトは、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>some<ph x="9">&lt;w9/&gt;</ph>Bytes<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>の最初の４バイトからコピーされます、そして<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>b<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>に対するバイトは次の４バイトからコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The call to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>animals<ph x="2">&lt;w2/&gt;</ph>.make<ph x="3">&lt;w3/&gt;</ph>Iterator()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> returns an instance of the array’s iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>animals<ph x="2">&lt;w2/&gt;</ph>.make<ph x="3">&lt;w3/&gt;</ph>Iterator()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への呼び出しは、配列のもつイテレータの１つのインスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The call to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> increases the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>values<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> array’s capacity by exactly 10 elements on each pass through <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>add<ph x="7">&lt;w7/&gt;</ph>Ten<ph x="8">&lt;w8/&gt;</ph>Quadratic()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, which is linear growth.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reserve<ph x="2">&lt;w2/&gt;</ph>Capacity(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出すことは、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>values<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>配列の容量を正確に10要素ずつ<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>add<ph x="7">&lt;w7/&gt;</ph>Ten<ph x="8">&lt;w8/&gt;</ph>Quadratic()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>が行われる各々で漸増します、それは線形成長です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The call to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>index(where:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> in the following example must traverse the whole collection to find the element that matches the predicate:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例における<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>index(where:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に対する呼び出しは、コレクション全体を辿っていって、述部に合致する要素を捜さなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The case-sensitive comparison will only match strings whose corresponding characters have the same case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>大文字小文字考慮での比較は、対応する文字の大文字小文字が同じである文字列同士のみが一致することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The character at that position is the composed <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>"é"<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その位置での文字は、合成済<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>"é"<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>文字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The character that was removed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>削除された文字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The character to append to the character view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字ビューに追加されることになる文字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The character to append to the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列に追加されることになる文字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The character to convert to a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列へと変換されることになる文字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The character’s hash value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その文字の持つハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The class of the object used for storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ストレージのために使われるオブジェクトのクラス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The classification of this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値の分類。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The closure is called again repeatedly with the previous call’s return value and each element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャは、前の呼び出しの戻り値とシーケンスの各要素とともに繰り返して再び呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The closure returns the desired value for the final dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このクロージャは、最終的な辞書に対して望む値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The closure’s pointer argument is valid only for the duration of the closure’s execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャのもつポインタ引数は、このクロージャの実行の間に対してだけ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code above stores the value <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>0x<ph x="2">&lt;w2/&gt;</ph>FFFF_FFFF<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> into the four newly allocated bytes, and then loads the first byte as a <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>UInt8<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance and the third and fourth bytes as a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>UInt16<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上のコードは値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>0x<ph x="2">&lt;w2/&gt;</ph>FFFF_FFFF<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を４つの新しいアロケート済みバイトに格納して、それから最初のバイトを<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>UInt8<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスとして、そして３番目と４番目のバイトを<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>UInt16<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスとしてロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code point to use for the scalar.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このスカラーのために使うコード点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code sample below declares a dictionary called <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>interesting<ph x="4">&lt;w4/&gt;</ph>Numbers<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> with string keys and values that are integer arrays, then sorts each array in-place in descending order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下のコード見本は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>interesting<ph x="4">&lt;w4/&gt;</ph>Numbers<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と呼ばれる辞書を文字列キーと整数配列である値で宣言します、それから各配列をその場で降順にソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code units of that buffer match the code units in the string’s <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>utf8<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このバッファのコード単位は、文字列のもつ<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>utf8<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>ビューでのコード単位と一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The collection being appended to allocates any additional necessary storage to hold the new elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションは追加されることによって、新しい要素を保有するために何らかの追加的に必要なストレージを割り当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The collection must not be empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションは空であってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The collection to create a view into.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それに対してビューが作成されることになるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The collection to evaluate this range expression in relation to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションに関して、この範囲式を評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The collection to wrap.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ラップされるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The collection’s “past the end” position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションの「終わりを過ぎた」位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The collection’s “past the end” position—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The comparison is both case sensitive and Unicode safe.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>比較は、大文字小文字考慮のみならずユニコード安全でもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The comparison returns <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>true<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> if both arguments are <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> or if the two arguments wrap values that are equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この比較が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>true<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を返すのは、両方の引数が<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>である場合か、２つの引数が同等な値らをラップする場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The comparison returns <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>true<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> if only one of the arguments is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> or if the two arguments wrap values that are not equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この比較が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>true<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を返すのは、引数のうちの１つだけが<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>である場合、または２つの引数が等しくない値をラップする場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The comparison returns <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>false<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> if both arguments are <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>nil<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> or if the two arguments wrap values that are equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この比較が<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>false<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を返すのは、両方の引数が<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>nil<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>である場合、または２つの引数が等しい値をラップする場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The compiler prevents bridging the <bpt i="17" x="17">&lt;c17&gt;</bpt><bpt i="18" x="18">&lt;s18&gt;</bpt>more<ph x="19">&lt;w19/&gt;</ph>Colors<ept i="18">&lt;/s18&gt;</ept><ept i="17">&lt;/c17&gt;</ept> array, on the other hand, because its <bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>Element<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept> type is <bpt i="22" x="22">&lt;c22&gt;</bpt><bpt i="23" x="23">&lt;s23&gt;</bpt>Optional&lt;String&gt;<ept i="23">&lt;/s23&gt;</ept><ept i="22">&lt;/c22&gt;</ept>, which does <bpt i="24" x="24">&lt;e24&gt;</bpt>not<ept i="24">&lt;/e24&gt;</ept> bridge to a Foundation type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラは、<bpt i="17" x="17">&lt;c17&gt;</bpt><bpt i="18" x="18">&lt;s18&gt;</bpt>more<ph x="19">&lt;w19/&gt;</ph>Colors<ept i="18">&lt;/s18&gt;</ept><ept i="17">&lt;/c17&gt;</ept>配列をブリッジすることを妨げます、言い換えれば、それの<bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>Element<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept>型が<bpt i="22" x="22">&lt;c22&gt;</bpt><bpt i="23" x="23">&lt;s23&gt;</bpt>Optional&lt;String&gt;<ept i="23">&lt;/s23&gt;</ept><ept i="22">&lt;/c22&gt;</ept>であるので、それはFoundation型にブリッジ<bpt i="24" x="24">&lt;e24&gt;</bpt>しません<ept i="24">&lt;/e24&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The condition to test.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>テストする条件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The container to hold.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>収容するためのコンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The context in which the error occurred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そこにおいてエラーが起こった前後関係。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The contiguous memory footprint of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, in bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の隣接メモリフットプリント、バイトで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The conversion of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to a string in the assignment to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>s<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> uses the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Point<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type’s <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>description<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>s<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>への代入における文字列への変換は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Point<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型の<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>description<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The correct approach in Swift is to compare the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value with zero in the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>while<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swiftにおける正しい取り組みは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>while<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>文において<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を0と比較することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The corresponding Swift type to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>va_list<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in imported C APIs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポートされたC APIの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>va_list<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対応するSwift型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The corresponding value of the raw type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この生の型の対応している値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The custom mirror for this instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスのためのあつらえのミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The decoder to read data from.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それからデータを読み出すデコーダ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default IEEE 754 behavior of operations involving a signaling NaN is to raise the Invalid flag in the floating-point environment and return a quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シグナルNaNを伴う演算の初期状態のIEEE 754挙動は、無効なフラグを浮動小数点環境において上げて、クワイエットNaNを返すことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default implementation of the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>!=<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> operator function satisfies this requirement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>!=<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>演算子関数の省略時の実装は、この要件を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is 10.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時は10。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時では<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>1<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>1<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>1<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>1<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is a newline (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"\n"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では改行（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"\n"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is a single space (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>" "<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、単一の空白（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>" "<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is an empty string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では空の文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is the file where <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>assert(_:<ph x="4">&lt;w4/&gt;</ph>_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>assert(_:<ph x="4">&lt;w4/&gt;</ph>_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が呼び出されるところのファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is the file where <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>assertion<ph x="4">&lt;w4/&gt;</ph>Failure(_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>assertion<ph x="4">&lt;w4/&gt;</ph>Failure(_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が呼び出されたところのファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is the file where <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>fatal<ph x="4">&lt;w4/&gt;</ph>Error(_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>fatal<ph x="4">&lt;w4/&gt;</ph>Error(_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が呼び出されたところのファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is the file where <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>precondition(_:<ph x="4">&lt;w4/&gt;</ph>_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>precondition(_:<ph x="4">&lt;w4/&gt;</ph>_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が呼び出されるところのファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is the file where <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>precondition<ph x="4">&lt;w4/&gt;</ph>Failure(_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>precondition<ph x="4">&lt;w4/&gt;</ph>Failure(_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が呼び出されたところのファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is the line number where <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>assert(_:<ph x="4">&lt;w4/&gt;</ph>_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>assert(_:<ph x="4">&lt;w4/&gt;</ph>_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が呼び出されるところの行番号です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is the line number where <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>assertion<ph x="4">&lt;w4/&gt;</ph>Failure(_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>assertion<ph x="4">&lt;w4/&gt;</ph>Failure(_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が呼び出されたところの行番号です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is the line number where <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>fatal<ph x="4">&lt;w4/&gt;</ph>Error(_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>fatal<ph x="4">&lt;w4/&gt;</ph>Error(_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が呼び出されたところの行番号です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is the line number where <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>precondition(_:<ph x="4">&lt;w4/&gt;</ph>_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>precondition(_:<ph x="4">&lt;w4/&gt;</ph>_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が呼び出されるところの行番号です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is the line number where <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>precondition<ph x="4">&lt;w4/&gt;</ph>Failure(_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>precondition<ph x="4">&lt;w4/&gt;</ph>Failure(_:<ph x="5">&lt;w5/&gt;</ph>file:<ph x="6">&lt;w6/&gt;</ph>line:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が呼び出されたところの行番号です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default is zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態はゼロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default memory alignment of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, in bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の省略時のメモリアライメント、バイトで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default memory alignment, in bytes, of the given value’s type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値の型の、バイトでの、省略時のメモリアライメント。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default separator is an empty string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時のセパレータは空の文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default type for an otherwise-unconstrained Boolean literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブールリテラルである他は別途制約されない省略時用の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default type for an otherwise-unconstrained Unicode extended grapheme cluster literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>別途制約されないユニコード拡張書記素クラスタリテラルのための省略時型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default type for an otherwise-unconstrained floating point literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>別途制約されない浮動小数点リテラルのための省略時型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default type for an otherwise-unconstrained integer literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>別途制約されない整数リテラルのための省略時型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default type for an otherwise-unconstrained string literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>別途制約されない文字列リテラルのための省略時型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default type for an otherwise-unconstrained unicode scalar literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>別途制約されないユニコードスカラーリテラルのための省略時型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default value is <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>true<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の値は、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>true<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default value is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>1<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の値は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>1<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default value is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の値は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default value is <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int<ph x="8">&lt;w8/&gt;</ph>.max<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の値は<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int<ph x="8">&lt;w8/&gt;</ph>.max<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default value is <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>true<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の値は、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>true<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The deinitialized memory can be reinitialized with values of the same type, bound to a new type, or deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライズされたメモリは、同じ型の値で再初期化する、新しい型に束縛する、またはデアロケートできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The description property of a conforming type must be a value-preserving representation of the original value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>準拠する型の説明プロパティは、元の値の値保全表現でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The destination Unicode encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行き先ユニコードエンコーディング。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The destination memory must be uninitialized or the pointer’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a trivial type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行き先のメモリは未初期化でなければなりません、またポインタのもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は自明型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The dictionary literal is made up of one or more key-value pairs, separated by commas and surrounded with square brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書リテラルは、コンマで区切られて角括弧で囲まれた１つ以上のキー値ペアで構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The dictionary’s “past the end” position—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The difference between these states can be distinguished by checking <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>is<ph x="4">&lt;w4/&gt;</ph>At<ph x="5">&lt;w5/&gt;</ph>End<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの状態の間の差は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>is<ph x="4">&lt;w4/&gt;</ph>At<ph x="5">&lt;w5/&gt;</ph>End<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The difference between these states can be distinguished with a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>contains(_:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの状態の相違は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>contains(_:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>呼び出しで見分けることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The difference of this value and <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の隔たり。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The distance between <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の隔たり。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The distance between this value and <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>との間の隔たり。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The distance between two indexes (always zero).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのインデックスの間の隔たり（常にゼロ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The distance from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, in strides of the pointer’s <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>までの隔たり、ポインタの<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型のストライドで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The distance from this pointer to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, in strides of the pointer’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタから<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>までの隔たり、ポインタのもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型のストライドで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The distance from this pointer to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, in bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタから<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>までの隔たり、バイトで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The distance to advance this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値を前進させる距離。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The distance to offset <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を補う間隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The division operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>/<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) calculates the quotient of the division if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is nonzero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>除算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>/<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が非ゼロならばその除算の商を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The dynamic type returned from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>type(of:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is a <bpt i="2" x="2">&lt;e2&gt;</bpt>concrete metatype<ept i="2">&lt;/e2&gt;</ept> (<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>T<ph x="5">&lt;w5/&gt;</ph>.Type<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>) for a class, structure, enumeration, or other non-protocol type <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>T<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, or an <bpt i="8" x="8">&lt;e8&gt;</bpt>existential metatype<ept i="8">&lt;/e8&gt;</ept> (<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>P<ph x="11">&lt;w11/&gt;</ph>.Type<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>) for a protocol or protocol composition <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>P<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>type(of:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から返される動的型は、クラス、構造体、列挙、または非プロトコル型<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>T<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に対する<bpt i="2" x="2">&lt;e2&gt;</bpt>具象メタタイプ<ept i="2">&lt;/e2&gt;</ept>（<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>T<ph x="5">&lt;w5/&gt;</ph>.Type<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）、もしくはプロトコルまたはプロトコル合成<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>P<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>に対する<bpt i="8" x="8">&lt;e8&gt;</bpt>存在メタタイプ<ept i="8">&lt;/e8&gt;</ept>（<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>P<ph x="11">&lt;w11/&gt;</ph>.Type<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The dynamic type, which is a value of metatype type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>動的型、それはメタタイプ型の値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element at the position created using <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Reversed<ph x="2">&lt;w2/&gt;</ph>Index<ph x="3">&lt;...&gt;(a&lt;w3/&gt;</ph>Index)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"r"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, the character before <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>"a"<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> in the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>name<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Reversed<ph x="2">&lt;w2/&gt;</ph>Index<ph x="3">&lt;...&gt;(a&lt;w3/&gt;</ph>Index)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って作成された位置での要素は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"r"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>name<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>文字列の中の<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>"a"<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の前の文字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element at the specified index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたインデックスでの要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element of the set to remove.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>削除されることになる集合の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element that should be split upon.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それで分離されることになる要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element that was removed from the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合から削除された要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element to append to the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列に追加されることになる要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element to append to the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この要素をコレクションへ追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element to check for containment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この要素が含まれるかを調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element to find in the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスにおいて見つける要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element to remove from the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合から削除されることになる要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element to repeat.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>繰り返される要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element type of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>: a tuple containing an individual key-value pair.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素型：個々のキー値ペアを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element type of a dictionary: a tuple containing an individual key-value pair.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の要素型：個々のキー値ペアを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element type of the option set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプションセットの要素型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The element type of the range; the same type as the range’s bounds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲の要素型；範囲の境界と同じ型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements at that index and later indices are shifted back to make room.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのインデックスおよび後のインデックスでの要素は、後ろに移って場所をあけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view are the code units for the string when encoded in UTF-16.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューの要素は、UTF-16で符号化される時の文字列に対するコード単位です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view are the code units for the string when encoded in UTF-8.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューの要素は、UTF-8で符号化される時の文字列に対するコード単位です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements of the range are the consecutive values from its lower bound up to, and including, its upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この範囲に属する要素は、それの下側の境界の値から上側の境界まで、そしてそれを含めての連続した値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements of the result are computed lazily, each time they are read, by calling <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>transform<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> function on a base element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果のそれぞれの要素は遅延に計算されます、毎回それらは、基盤となる要素上で<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>transform<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>関数を呼び出すことによって読み出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements of the result are computed on-demand, as the result is used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果の要素は、要求に応じて、結果が使われるときに計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements of the resulting array are ordered according to the given predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果の配列の要素は、与えられた述部にしたがって並べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements of the sequence are computed lazily and the sequence may potentially be infinite in length.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスに属する要素らは、遅延に計算されます、そしてこのシーケンスの長さは潜在的に無限大です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements of the sequence are obtained by invoking <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with a mutable state.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの要素は、 <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をある可変の状態とともに発動することによって入手されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements of this collection match those accessed through indexed <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSString<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> APIs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションの要素は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSString<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> APIでインデックスを使ってアクセスされるものと一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements of this view are a concatenation of the elements of each collection in the base.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この見方での要素たちは、その基盤の中の各コレクションの要素の連結です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements of this view are a concatenation of the elements of each sequence in the base.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この見方での要素たちは、その基盤の中の各シーケンスのもつ要素の連結です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements to append to the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列に追加する要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements to append to the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの要素をコレクションへ追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements to use as members of the new set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい集合の要素として使うための要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements traversed are the concatenation of those in each segment produced by the base iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辿っていかれる要素は、基盤イテレータによって生成される各セグメント（メモリ管理単位？）におけるそれらの連結です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The encoder to write data to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>データを書き込むエンコーダ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The encoding in which <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>code<ph x="2">&lt;w2/&gt;</ph>Units<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> should be interpreted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それで<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>code<ph x="2">&lt;w2/&gt;</ph>Units<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が解釈されるべきエンコーディング。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The encoding in which the code units should be interpreted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それでコード単位が解釈されるべきエンコーディング。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The encoding to use for the returned bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返されたバイトに対して使うためのエンコーディング。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The end index refers to the position one past the last element of a collection, so it doesn’t correspond with an element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>末尾インデックスは、あるコレクションの最後の要素を１つ過ぎた位置を参照します、それでそれはある要素に対応しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The escapable copy of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>closure<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> passed as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>body<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is only valid during the call to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>without<ph x="6">&lt;w6/&gt;</ph>Actually<ph x="7">&lt;w7/&gt;</ph>Escaping(_:<ph x="8">&lt;w8/&gt;</ph>do:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>closure<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の脱出可能なコピーで<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>body<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>として渡されるものは、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>without<ph x="6">&lt;w6/&gt;</ph>Actually<ph x="7">&lt;w7/&gt;</ph>Escaping(_:<ph x="8">&lt;w8/&gt;</ph>do:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>への呼び出しの間に有効なだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The exact list of search options applied may change over time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>適用される検索オプションの正確なリストは、時につれ変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below uses this subscript to access the characters up to, but not including, the first comma (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>","<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) in the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、この添え字を使って、文字列の中の最初のコンマ（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>","<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）に至るまで、しかしそれを含めない、いくらかの文字にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below uses this subscript to access the scalar values up to, but not including, the first comma (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>","<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) in the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、この添え字を使って、文字列の中の最初のコンマ（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>","<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）に至るまで、しかしそれを含めない、いくらかのスカラー値にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below uses two strings with different forms of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"é"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> character—the first uses the composed form and the second uses the decomposed form.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、異なる形式の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"é"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>文字を持つ２つの文字列を使います—最初は合成形式を使い、そして２番目は分解形式を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example given above is a reasonably good hash function for a simple type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上で与えられた例は、単純な型に対してかなり良いハッシュ関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The examples below demonstrate how to use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>without<ph x="2">&lt;w2/&gt;</ph>Actually<ph x="3">&lt;w3/&gt;</ph>Escaping(_:<ph x="4">&lt;w4/&gt;</ph>do:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in conjunction with two common APIs that use escaping closures: lazy collection views and asynchronous operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、脱出するクロージャを使う２つのよくあるAPIと連係して、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>without<ph x="2">&lt;w2/&gt;</ph>Actually<ph x="3">&lt;w3/&gt;</ph>Escaping(_:<ph x="4">&lt;w4/&gt;</ph>do:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使う方法を実演します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The explicit permission to implement further operations lazily applies only in contexts where the sequence is statically known to conform to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Sequence<ph x="3">&lt;w3/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もっと遅延に演算を実施する明示的な許可は、そこにおいてシーケンスは静的に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Sequence<ph x="3">&lt;w3/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠することを見分けられる文脈においてのみ適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The exponent of the floating-point value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点値の指数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The file name to print with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the assertion fails.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>表明（アサーション）がうまくいかないならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>とともに出力するファイル名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The file name to print with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the precondition fails.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件がうまくいかないならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>とともに出力するファイル名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The file name to print with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>とともに出力するファイル名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The final accumulated value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最終的に蓄積された値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The final example passes <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>omitting<ph x="4">&lt;w4/&gt;</ph>Empty<ph x="5">&lt;w5/&gt;</ph>Subsequences<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> parameter, so the returned array contains empty strings where spaces were repeated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後の例は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept>を<ept i="0">&lt;/c0&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>omitting<ph x="4">&lt;w4/&gt;</ph>Empty<ph x="5">&lt;w5/&gt;</ph>Subsequences<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>パラメータに渡します、なので返される配列は空白が繰り返されたところで空の文字列を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The final example passes <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>allow<ph x="4">&lt;w4/&gt;</ph>Empty<ph x="5">&lt;w5/&gt;</ph>Slices<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> parameter, so the returned array contains empty strings where spaces were repeated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後の例は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>allow<ph x="4">&lt;w4/&gt;</ph>Empty<ph x="5">&lt;w5/&gt;</ph>Slices<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>パラメータに渡します、なので返される配列は空白が繰り返されたところで空の文字列を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first element in the sequence is always <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, and each successive element is the result of invoking <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>next<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> with the previous element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスでの最初の要素は常に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です、そして続く要素それぞれは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>next<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を前の要素とともに発動することの結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first element of a nonempty array is always at index zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空でない配列の最初の要素は、常にインデックス０です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first element of the collection if the collection is not empty; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションが空でないならばコレクションの最初の要素；そうでなければ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first element of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの最初の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first element of the dictionary is not necessarily the first element added.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の最初の要素は、必ずしも追加された最初の要素ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first element of the sequence that satisfies <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> if there is no element that satisfies <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>predicate<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>満たすシーケンスの最初の要素、または<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>predicate<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を満たす要素が無いならば<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first element of the set is not necessarily the first element added to the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合の最初の要素は、必ずしも集合に追加された最初の要素ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first element of the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合の最初の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first element to be returned from the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスから返されることになる最初の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first index where <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is found.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が見つけられたところの最初のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first key-value pair of the dictionary if the dictionary is not empty; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書が空でないならばこの辞書の最初のキー値ペア；そうでなければ、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first optional value that isn’t <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> stops the chain and becomes the result of the whole expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>でない最初のオプショナル値は、連鎖を停止して、式全体の結果となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first partition, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>numbers[..&lt;p]<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, is made up of the elements that are not greater than 30.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の区画、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>numbers[..&lt;p]<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、30より大きくない要素から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first sequence or collection to zip.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>組み合わされる第１のシーケンスまたはコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first use of <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>split<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> returns each word that was originally separated by one or more spaces.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>split<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>の最初の利用は、各単語を返します、それはもともと１つ以上の空白で隔てられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first value to add.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加算する第１の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first value to multiply.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>掛け合わされる第１の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The flexible behavior of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Object<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol is similar to Objective-C’s <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>id<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Object<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルの柔軟な挙動は、Objective-Cのもつ<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>id<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The floating-point types in the standard library are <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Double<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Float80<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> where available.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリにおける浮動小数点型は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Double<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、そして利用可能なところでは<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Float80<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The floating-point value with the same sign and exponent as this value, but with a significand of 1.0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と同じ符号と指数を持つ浮動小数点値、しかし1.0の仮数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following code declares <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>values<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, an array of integers, and the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>add<ph x="4">&lt;w4/&gt;</ph>Ten<ph x="5">&lt;w5/&gt;</ph>Quadratic()<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> function, which adds ten more values to the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>values<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> array on each call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のコードは、整数の配列<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>values<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、そして呼び出し毎に10個さらに値を<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>values<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>配列に加える<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>add<ph x="4">&lt;w4/&gt;</ph>Ten<ph x="5">&lt;w5/&gt;</ph>Quadratic()<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>関数を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following code declares a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>perform(_:<ph x="2">&lt;w2/&gt;</ph>simultaneously<ph x="3">&lt;w3/&gt;</ph>With:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function that uses a dispatch queue to execute two closures concurrently.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のコードは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>perform(_:<ph x="2">&lt;w2/&gt;</ph>simultaneously<ph x="3">&lt;w3/&gt;</ph>With:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を宣言します、それはあるディスパッチキューを使って２つのクロージャを同時に実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following code declares an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>all<ph x="2">&lt;w2/&gt;</ph>Values(in:<ph x="3">&lt;w3/&gt;</ph>match:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function that checks whether all the elements in an array match a predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のコードは、配列のすべての要素がある述部に合致するかどうかを調べる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>all<ph x="2">&lt;w2/&gt;</ph>Values(in:<ph x="3">&lt;w3/&gt;</ph>match:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following code temporarily rebinds the memory that <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>uint8Pointer<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> references from <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>UInt8<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> to <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Int8<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> to call the imported C <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>strlen<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のコードは、一時的に<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>uint8Pointer<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>が参照するメモリを<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>UInt8<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>から<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Int8<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>へと再束縛することで、インポートされたC <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>strlen<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>関数を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example accesses an element of an array through its subscript to print its value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、配列のある要素にそれの添え字によってアクセスしてそれの値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example accesses the fourth code unit in both the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>flowers<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nsflowers<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> strings:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>flowers<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>と<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nsflowers<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>文字列の両方で４番目のコード単位にアクセスします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example adds a new number to an array of integers:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は、ある新しい要素を整数からなる配列へ加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example allocates enough new memory to store four <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances and then initializes that memory with the elements of a range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、新しいメモリを必要なだけアロケートすることで、４つの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを格納して、それからそのメモリをある範囲の要素で初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example allocates enough raw memory to hold four instances of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, and then uses the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>initialize<ph x="4">&lt;w4/&gt;</ph>Memory(as:<ph x="5">&lt;w5/&gt;</ph>at:<ph x="6">&lt;w6/&gt;</ph>count:<ph x="7">&lt;w7/&gt;</ph>to:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method to initialize the allocated memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、生のメモリを必要なだけアロケートすることで、４つの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを保持して、それから<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>initialize<ph x="4">&lt;w4/&gt;</ph>Memory(as:<ph x="5">&lt;w5/&gt;</ph>at:<ph x="6">&lt;w6/&gt;</ph>count:<ph x="7">&lt;w7/&gt;</ph>to:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドを使ってアロケートされたメモリを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example allocates enough raw memory to hold four instances of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, and then uses the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>initialize<ph x="4">&lt;w4/&gt;</ph>Memory(as:<ph x="5">&lt;w5/&gt;</ph>from:<ph x="6">&lt;w6/&gt;</ph>count:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method to initialize the allocated memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、生のメモリを必要なだけアロケートすることで、４つの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを保持して、それから<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>initialize<ph x="4">&lt;w4/&gt;</ph>Memory(as:<ph x="5">&lt;w5/&gt;</ph>from:<ph x="6">&lt;w6/&gt;</ph>count:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドを使ってアロケートされたメモリを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example allocates four bytes of memory and stores <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>0x<ph x="2">&lt;w2/&gt;</ph>FF<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in all four bytes:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、４バイトのメモリをアロケートして<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>0x<ph x="2">&lt;w2/&gt;</ph>FF<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を４バイトすべての中に格納します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example appends the elements of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance to an array of integers:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスからなるいくらかの要素を整数からなる配列に追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example binds the memory referenced by <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>uint8Pointer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> to one instance of the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt64<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>uint8Pointer<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>によって参照されるメモリを<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt64<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型のあるインスタンスに束縛します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example builds a customized greeting by using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>append(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例はあつらえの挨拶を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>append(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使うことによって作ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example calculates the remainder of dividing 8.625 by 0.75:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、8.625を0.75で割ることの余りを計算します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example calculates the truncating remainder of dividing 8.625 by 0.75:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、8.625を0.75で除算することの切り捨てられる余りを計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example calls this initializer with pointers to the contents of two different <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>CChar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> arrays—the first with well-formed UTF-8 code unit sequences and the second with an ill-formed sequence at the end.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、このイニシャライザを２つの異なる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>CChar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列の内容へのポインタとともに呼び出します—最初のものは正しい形式のUTF-8コード単位シーケンスをもち、そして２番目のものはある誤形式シーケンスを末尾に保ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example calls this method with pointers to the contents of two different <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>CChar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> arrays—the first with well-formed UTF-8 code unit sequences and the second with an ill-formed sequence at the end.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、このメソッドを２つの異なる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>CChar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列の内容へのポインタとともに呼び出します—最初のものは正しい形式のUTF-8コード単位シーケンスをもち、そして２番目のものはある誤形式シーケンスを末尾に保ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example checks to see if <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>image<ph x="6">&lt;w6/&gt;</ph>Paths<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> contains any paths in the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>"/glyphs"<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> directory:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>image<ph x="6">&lt;w6/&gt;</ph>Paths<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が何らかのパスを<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>"/glyphs"<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>ディレクトリの中に含むかどうかを調べるために検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example compares instances of the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Int<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>UInt8<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> types:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Int<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>UInt8<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>型のインスタンスを比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example compares the date of the first moon landing with the release of David Bowie’s song “Space Oddity”:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、最初の月面着陸の日付をデビッド・ボウイの歌「Space Oddity」のリリース日と比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example compares tuples made up of 2 components:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は２つの構成要素から作り上げられるタプルを比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example compares tuples made up of 3 components:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、３つの構成要素で構成されるタプルを比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example compares tuples made up of 4 components:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は４つの構成要素から作り上げられるタプルを比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example compares tuples made up of 5 components:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は５つの構成要素から作り上げられるタプルを比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example compares tuples made up of 6 components:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は６つの構成要素から作り上げられるタプルを比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example converts the position of the Unicode scalar <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"e"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> into its corresponding position in the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ユニコードスカラー<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"e"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の位置を文字列でのそれの対応位置に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example converts the position of the Unicode scalar <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"e"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> into its corresponding position in the string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ユニコードスカラー<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"e"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の位置を文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューでのそれの対応位置に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example converts the position of the teacup emoji (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"🍵"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) into its corresponding position in the string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>unicode<ph x="4">&lt;w4/&gt;</ph>Scalars<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ティーカップ絵文字（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"🍵"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の位置を文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>unicode<ph x="4">&lt;w4/&gt;</ph>Scalars<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューでのそれの対応位置に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example converts the position of the teacup emoji (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"🍵"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) into its corresponding position in the string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ティーカップ絵文字（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"🍵"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の位置を文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューでのそれの対応位置に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example copies bytes from the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>byte<ph x="2">&lt;w2/&gt;</ph>Values<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array into <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>numbers<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, an array of <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、バイトを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>byte<ph x="2">&lt;w2/&gt;</ph>Values<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列から、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の配列<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>numbers<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>へとコピーします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example copies the bytes of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array into a buffer of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>UInt8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列のバイトを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>UInt8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のバッファへとコピーします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example creates a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Repeated&lt;Int&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> collection containing five zeroes:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、５つのゼロを含んでいるある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Repeated&lt;Int&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>コレクションを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example creates a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ph x="2">&lt;w2/&gt;</ph>Word<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant by using the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>prefix(where:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method to get a slice of the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>text<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ph x="2">&lt;w2/&gt;</ph>Word<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数を<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>prefix(where:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドを使って<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>text<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>文字列のスライスを取得することによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example creates a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>greeting<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> string, and then finds the substring of the first sentence:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>greeting<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>文字列を作成して、それから第一文からなる下位文字列を見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example creates a collection containing the name “Humperdinck” repeated five times:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、５回繰り返した名前「Humperdinck」を含んでいるコレクションを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example creates a new <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Reversed<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> from the index of the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>"a"<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> character in a string’s character view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、新しい<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Reversed<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を、文字列の文字ビューの中の<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>"a"<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>文字のインデックスから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example creates a new character from the uppercase version of a string that only holds one character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、１つの文字を保持するだけのある文字列の大文字バージョンから、新しい文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example creates a new dictionary and prints the value of a key found in the dictionary (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"Coral"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) and a key not found in the dictionary (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>"Cerise"<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は新しい辞書を作成して、辞書に見つかるキー（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"Coral"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）と辞書に見つからないキー（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>"Cerise"<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）の値を出力します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example creates a new dictionary using an array of strings as the keys and the integers in a countable range as the values:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、文字列からなる配列をキーとしてそして可付番範囲の中の整数を値として、新しい辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example creates an array initialized with five strings containing the letter <bpt i="0" x="0">&lt;e0&gt;</bpt>Z<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、字<bpt i="0" x="0">&lt;e0&gt;</bpt>Z<ept i="0">&lt;/e0&gt;</ept>を含んでいる５つの文字列で初期化される配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example creates an array of integers from an array literal, then appends the elements of another collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、整数からなるある配列を配列リテラルから作成します、それから別のコレクションの要素を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example creates an example class <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>A<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and compares instances of the class using their object identifiers and the identical-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>===<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は、ある見本クラス<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>A<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を作成して、そのクラスのインスタンスをそれらのオブジェクト識別子と同一演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>===<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）を使って比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example creates an iterator that counts up from the initial value of an integer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to 15:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例はあるイテレータを作成します、それは初期値の整数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から15まで数え上げます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example creates two new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances from the memory referenced by the buffer pointer <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>some<ph x="4">&lt;w4/&gt;</ph>Bytes<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、２つの新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスをバッファポインタ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>some<ph x="4">&lt;w4/&gt;</ph>Bytes<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>によって参照されるメモリから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example creates two type-erased hashable values: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> wraps an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> with the value 42, while <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>y<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> wraps a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt8<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> with the same numeric value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は２つの型消去ハッシュ化値を作成します：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は値42を持つ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>をラップします、一方<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>y<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は同じ数値を持つ<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>UInt8<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>をラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example declares <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>single<ph x="4">&lt;w4/&gt;</ph>Digits<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, a range of single digit integers, and then drops the first element to create a slice of that range, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>single<ph x="7">&lt;w7/&gt;</ph>Non<ph x="8">&lt;w8/&gt;</ph>Zero<ph x="9">&lt;w9/&gt;</ph>Digits<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、１桁整数からなる範囲、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>single<ph x="4">&lt;w4/&gt;</ph>Digits<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を宣言します、それから最初の要素を落としてその範囲のあるスライス、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>single<ph x="7">&lt;w7/&gt;</ph>Non<ph x="8">&lt;w8/&gt;</ph>Zero<ph x="9">&lt;w9/&gt;</ph>Digits<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example declares a <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Point<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type with <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>y<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> coordinates and a Boolean <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>is<ph x="11">&lt;w11/&gt;</ph>Filled<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Point<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型を<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>および<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>y<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>座標、そしてブールの<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>is<ph x="11">&lt;w11/&gt;</ph>Filled<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>プロパティで宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example declares a function that calculates the length of the hypotenuse of a right triangle given its two perpendicular sides.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例はある関数を宣言します、それは、それの２つの直角側を与えられる直角三角形の斜辺の長さを計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example declares a function that returns the index of the last even number in the passed array, if one is found.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある関数を宣言します、それは渡された配列の中の最後の偶数のインデックスを返します、それが見つけられるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example declares a method that calculates the total of any sequence with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Numeric<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Numeric<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素による何らかのシーケンスの合計を計算するメソッドを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example declares an array of names, and then creates a dictionary from that array by grouping the names by their first letter:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、名前からなるある配列を宣言します、それから名前をそれらの最初の文字でグループ分けすることによって、その配列から辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as an instance of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>UInt8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, an 8-bit, unsigned integer type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>UInt8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のインスタンス、ある８ビットの、符号なし整数型として定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print<ph x="2">&lt;w2/&gt;</ph>Generic<ph x="3">&lt;w3/&gt;</ph>Info(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function that takes a generic parameter and declares the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type’s conformance to a new protocol <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>P<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print<ph x="2">&lt;w2/&gt;</ph>Generic<ph x="3">&lt;w3/&gt;</ph>Info(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を定義します、それは総称体パラメータを取り、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型の準拠を新しいプロトコル<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>P<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Integer<ph x="2">&lt;w2/&gt;</ph>Ref<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type, an integer type with reference semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Integer<ph x="2">&lt;w2/&gt;</ph>Ref<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型、参照意味論を持つ整数型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example drops the first element from an array of integers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、整数からなる配列から最初の要素を落とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example enumerates the elements of an array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある配列の要素を列挙します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example enumerates the elements of an array:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある配列の要素を列挙します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example finds the index of the first space in the string’s character view and then converts that to the same position in the UTF-8 view:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、最初の空白のインデックスを文字列のもつ文字ビューの中で見つけて、それからそれをUTF-8ビューでの同じ位置に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example finds the index of the solid heart pictograph in the string’s character view and then converts that to the same position in the Unicode scalars view:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、最初の塗りつぶしハート絵文字のインデックスをその文字列のもつ文字ビューの中で見つけて、それからそれをユニコードスカラービューでの同じ位置に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example finds the position of a space in a string and then converts that position to an index in the string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある空白の位置を文字列の中で見つけて、それからその位置を文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューの中のインデックスに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example finds the position of a space in a string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view and then converts that position to an index in the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある空白の位置を文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューの中で見つけて、それからその位置を文字列の中のインデックスに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example finds the position of a space in a string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view and then converts that position to an index in the string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>unicode<ph x="4">&lt;w4/&gt;</ph>Scalars<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある空白の位置を文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューの中で見つけて、それからその位置を文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>unicode<ph x="4">&lt;w4/&gt;</ph>Scalars<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューの中のインデックスに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example finds the position of a space in a string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view and then converts that position to an index in the string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある空白の位置を文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューの中で見つけて、それからその位置を文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューの中のインデックスに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example finds the position of a space in a string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view and then converts that position to an index in the string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある空白の位置を文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューの中で見つけて、それからその位置を文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューの中のインデックスに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、文字列の開始インデックスから４位置進んだインデックスを取得して、それからその位置の文字を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、配列の始まりから４位置進んだインデックスを入手して、それからその位置での要素を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example passes a pointer to the <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>value<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> variable by using inout syntax:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>value<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>変数へのポインタをinout構文を使って渡します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example prints a closed range of integers to a string:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>続く例は、整数の完結範囲をある文字列へ出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example prints a string, a closed range of integers, and a group of floating-point values to standard output:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある文字列、整数の完結範囲、グループの浮動小数点値を標準出力に出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example prints the debugging representation of a string, a closed range of integers, and a group of floating-point values to standard output:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある文字列、整数の完結範囲、グループの浮動小数点値のデバッグ表現を標準出力に出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example reverses the elements of an array of characters:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、文字列からなる配列の要素を逆順にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example rounds a value using four different rounding rules:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例はある値を４つの丸め規則を使って丸めます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example rounds several values using this default rule:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例はいくつかの値をこの初期設定での規則を使って丸めます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example searches a string’s Unicode scalars view for a capital letter and then prints the character and Unicode scalar value at the found index:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある文字列のもつユニコートスカラービューで大文字を捜して、それから見つかったインデックスでの文字とユニコードスカラー値を出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example searches a string’s character view for a capital letter and then prints the character at the found index:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある文字列のもつ文字ビューで大文字を捜して、それから見つかったインデックスでの文字を出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example searches for the index of the number <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>40<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in an array of integers, and then prints the suffix of the array starting at that index:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、整数からなる配列において数<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>40<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインデックスを捜して、それからそのインデックスで始まる配列の末尾を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example searches for the index of the number <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>40<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> in an array of integers, and then prints the prefix of the array up to, and including, that index:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、整数からなる配列において数<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>40<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>のインデックスを捜して、それからそのインデックスに至るまでの、そしてそれを含めて、配列の冒頭を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example searches for the index of the number <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>40<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> in an array of integers, and then prints the prefix of the array up to, but not including, that index:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、整数からなる配列において数<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>40<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>のインデックスを捜して、それからそのインデックスに至るまでの、しかしそれを含めずに、配列の冒頭を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ph x="2">&lt;w2/&gt;</ph>Parsing<ph x="3">&lt;w3/&gt;</ph>Error<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> enumeration that captures two different kinds of errors that can occur when parsing an integer from a string: overflow, where the value represented by the string is too large for the integer data type, and invalid input, where nonnumeric characters are found within the input.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ph x="2">&lt;w2/&gt;</ph>Parsing<ph x="3">&lt;w3/&gt;</ph>Error<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>列挙を示します、それが捕える（キャプチャ）のは、文字列から整数を構文解析（パース）する時に起こる可能性のある２つの異なる種類のエラー：文字列によって表される値が整数データ型に対して大きすぎるところのオーバーフロー、そして非数の文字が入力内に見つけられるところの無効な入力です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows how NaN values operate in different contexts.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、どのようにNaN値が異なる前後関係において作動するかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows how an array of strings can be joined to a single, comma-separated string:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、どのように文字列からなる配列が単一の、コンマ区切りの文字列へと連結できるかを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows how an iterator can be used explicitly to emulate a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は、イテレータが明示的に使われて<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ループの機能を真似る方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows how extending and truncating work for nonnegative integers:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後に続く例は、非負数整数に対する拡張および切り詰め作業の方法を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows how modifying the contents of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> argument to <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>body<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> alters the contents of the array:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>body<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>への<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>引数の内容の修正が、配列の内容を改めることを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows how the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>contains(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> method can be used with an array of strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>contains(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>メソッドが文字列からなる配列で使われるのを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows how to choose the first and last values for any duplicate keys:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、あらゆる重複キーに対して最初と最後の値を選択する方法を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows how you can bridge an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSArray<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to use the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>write(to:<ph x="6">&lt;w6/&gt;</ph>atomically:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、どのようにあなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSArray<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>へとブリッジして、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>write(to:<ph x="6">&lt;w6/&gt;</ph>atomically:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドを使うかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows how you can determine free shipping options based on a customer’s purchase price:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、どうやってあなたが顧客の購入品価格を基に無償出荷オプションを判定できるかを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows how you can iterate over the contents of the buffer pointer:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は、どのようにあなたがバッファポインタの内容にわたって反復できるかを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows the array literal initializer for a hypothetical <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Ordered<ph x="5">&lt;w5/&gt;</ph>Set<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type, which has setlike semantics but maintains the order of its elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、仮設的な<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Ordered<ph x="5">&lt;w5/&gt;</ph>Set<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型のための配列リテラルイニシャライザを示します、それは集合的な意味論を持つけれどもそれの要素の順番を維持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows the dictionary literal initializer for a hypothetical <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Counted<ph x="5">&lt;w5/&gt;</ph>Set<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type, which uses setlike semantics while keeping track of the count for duplicate elements:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、仮設的な<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Counted<ph x="5">&lt;w5/&gt;</ph>Set<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型のための辞書リテラルイニシャライザを示します、それは集合的な意味論を使う一方で重複する要素に対する総数を追跡し続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows the results of rounding numbers using this rule:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、この規則を使っての数の丸めの結果を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example temporarily rebinds the memory of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt64<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> pointer to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int64<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, then accesses a property on the signed integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、 一時的に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt64<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ポインタのメモリを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Int64<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に再束縛します、それから符号付き整数上のあるプロパティにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example transcodes the UTF-8 representation of the string <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"Fermata 𝄐"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> into UTF-32.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、文字列<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"Fermata 𝄐"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のUTF-8表現をUTF-32にコード変換（トランスコード）します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example transforms a string to uppercase letters:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある文字列を大文字の文字に変換します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example updates the value for the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>404<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> code to be simply “Not found” and removes the key-value pair for the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>500<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> code entirely.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>404<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>コードの値を単純に「Not found」に更新して、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>500<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>コードに対するキー値ペアをすっかり削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Totally<ph x="3">&lt;w3/&gt;</ph>Ordered(below:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to sort an array of floating-point values, including some that are NaN:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Totally<ph x="3">&lt;w3/&gt;</ph>Ordered(below:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って、NaNである何かを含んでいる、浮動小数点値の配列をソートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>some<ph x="2">&lt;w2/&gt;</ph>Bytes<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Raw<ph x="7">&lt;w7/&gt;</ph>Buffer<ph x="8">&lt;w8/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance, to demonstrate the difference between assigning a buffer pointer and using a buffer pointer as the source for another collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>some<ph x="2">&lt;w2/&gt;</ph>Bytes<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Raw<ph x="7">&lt;w7/&gt;</ph>Buffer<ph x="8">&lt;w8/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスを使って、バッファポインタの割り当することとバッファポインタを別のコレクションの要素のソースとして使うことの間の違いを実演します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>some<ph x="2">&lt;w2/&gt;</ph>Bytes<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Raw<ph x="6">&lt;w6/&gt;</ph>Buffer<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance, to demonstrate the difference between assigning a buffer pointer and using a buffer pointer as the source for another collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>some<ph x="2">&lt;w2/&gt;</ph>Bytes<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Raw<ph x="6">&lt;w6/&gt;</ph>Buffer<ph x="7">&lt;w7/&gt;</ph>Pointer<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスを使って、バッファポインタの割り当することとバッファポインタを別のコレクションの要素のソースとして使うことの間の違いを実演します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses a structure to represent an error when parsing an XML document, including the line and column numbers where the error occurred:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、構造体を使ってXML書類をパースする時にエラーを表して、行およびコラム番号をエラーが生じたときに含めます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses implicit bridging to pass a pointer to <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>value<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> when calling <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>print(address:<ph x="5">&lt;w5/&gt;</ph>as:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>print(address:<ph x="5">&lt;w5/&gt;</ph>as:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を呼び出すとき、暗黙的ブリッジを使ってポインタを<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>value<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>へと渡します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses indexed subscripting to update an array’s second element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は、インデックスでの添え字を使って、配列の２番目の要素を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses optional chaining to access the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>has<ph x="4">&lt;w4/&gt;</ph>Suffix(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method on a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>String?<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、オプショナル連鎖を使って、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>has<ph x="4">&lt;w4/&gt;</ph>Suffix(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドに<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>String?<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンス上でアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>drop(while:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to skip over the positive numbers at the beginning of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>numbers<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>drop(while:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、正の数を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>numbers<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>配列の始まりで省きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first(where:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to find the first negative number in an array of integers:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first(where:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、整数の配列において最初の負数を見つけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>negate()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to negate the value of an integer <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>negate()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、整数<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の値を負にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>prefix(while:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to find the positive numbers at the beginning of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>numbers<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>prefix(while:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、正の数を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>numbers<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>配列の始まりで見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>zip(_:<ph x="2">&lt;w2/&gt;</ph>_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function to iterate over an array of strings and a countable range at the same time:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>zip(_:<ph x="2">&lt;w2/&gt;</ph>_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を使って、同時に文字列からなる配列とある可付番範囲の全体にわたって反復します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>~=<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> operator to test whether an integer is included in a range of single-digit numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>~=<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>演算子を使って、ある整数が一桁の数からなる範囲に含まれるかどうか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>zip(_:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> function to iterate over an array of strings and a countable range at the same time:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>zip(_:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>関数を使って、同時に文字列からなる配列とある可付番範囲の全体にわたって反復します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses the C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>strncmp<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function to compare the beginning of two Swift strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>strncmp<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を使って２つのSwift文字列を比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses the buffer pointer’s subscript to access and modifying the elements of a mutable buffer pointing to the contiguous contents of an array:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、バッファポインタのもつ添え字を使うことで、配列の隣接内容を指している可変バッファの要素にアクセスして修正しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses the buffer pointer’s subscript to access every other element of the buffer:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、パッファポインタの添え字を使うことで、そのバッファのすべての他の要素にアクセスします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses the subscript to print the value of a string’s first UTF-16 code unit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、添え字を使って文字列のもつ最初のUTF-16コード単位の値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses the subscript to print the value of a string’s first UTF-8 code unit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、添え字を使って文字列のもつ最初のUTF-8コード単位の値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses this initializer to create a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance with the sign of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>a<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and the magnitude of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>b<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、このイニシャライザを使って新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>a<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の符号と<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>b<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の規模で作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses this initializer to create a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、このイニシャライザを使って新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following examples show the effects of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Splits<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>omitting<ph x="5">&lt;w5/&gt;</ph>Empty<ph x="6">&lt;w6/&gt;</ph>Subsequences<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> parameters when splitting a string at each space character (” “).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Splits<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>omitting<ph x="5">&lt;w5/&gt;</ph>Empty<ph x="6">&lt;w6/&gt;</ph>Subsequences<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>パラメータの効果を、各空白文字（” “）で文字列を分割する場合で示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following examples show the effects of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Splits<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>omitting<ph x="5">&lt;w5/&gt;</ph>Empty<ph x="6">&lt;w6/&gt;</ph>Subsequences<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> parameters when splitting a string using a closure that matches spaces.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Splits<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>omitting<ph x="5">&lt;w5/&gt;</ph>Empty<ph x="6">&lt;w6/&gt;</ph>Subsequences<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>パラメータの効果を、空白にマッチするクロージャを使って文字列を分割する場合で示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following examples use this dictionary of image names and file paths:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以降の例は、この画像名とファイルパスの辞書を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following special cases also apply:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の特別な場合もまた適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function uses <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>type(of:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> to find the dynamic type of <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>value<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>, which itself is an instance of the <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Smiley<ph x="14">&lt;w14/&gt;</ph>.Type<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> metatype.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>type(of:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を使って<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>value<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>の動的型を見つけます、それはそれ自身が<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Smiley<ph x="14">&lt;w14/&gt;</ph>.Type<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>メタタイプのインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function uses the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>multiplied<ph x="6">&lt;w6/&gt;</ph>Reporting<ph x="7">&lt;w7/&gt;</ph>Overflow(by:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method to multiply <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> by itself and check whether the result is too large to represent in the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>multiplied<ph x="6">&lt;w6/&gt;</ph>Reporting<ph x="7">&lt;w7/&gt;</ph>Overflow(by:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドを使って、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>x<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>をそれ自身で乗算して、結果が同じ型で表現するのに大きすぎないかどうか検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function won’t compile as written, because a lazy collection’s <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>filter(_:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method requires an escaping closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は書いた通りにコンパイルしないでしょう、なぜなら遅延コレクションのもつ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>filter(_:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドが脱出クロージャを要求するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The given string may begin with a plus or minus sign character (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた文字列は、プラスまたはマイナス符号文字（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）で始まっても構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The global <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>abs(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function provides more familiar syntax when you need to find an absolute value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>グローバル<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>abs(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は、あなたが絶対値を見つける必要がある時により馴染みのある構文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The greater of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, or whichever is a number if the other is NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のより大きい方、または他方がNaNならば数である方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The greater of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のうちより大きいもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The greatest finite number representable by this type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型によって表現可能な最も大きな有限数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The greatest of all the arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての引数のうち最も大きいもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The greatest representable value that compares less than this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>表現可能な最も大きい値で、この値と比較してより小さいもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The hash value for the Boolean value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブール値に対するハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The hash value for the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合に対するハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The hash value is not guaranteed to be stable across different invocations of the same program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ハッシュ値は、同じプログラムの異なる発動をまたいで変動のないことを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The hash value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The identical-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>===<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) returns <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> when comparing two references to different object instances, even if the two instances have the same value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同一性演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>===<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、２つのインスタンスを比較して異なるオブジェクトインスタンスであるとき<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返します、２つのインスタンスが同じ値を持つとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The identifier’s hash value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>識別子の持つハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The identity of a class instance is not part of an instance’s value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスインスタンスの同一性は、インスタンスの持つ値の部分のことではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The immutable pointer to convert.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変換されることになる不変ポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The immutable raw pointer to convert.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変換される不変の生のポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The implementation of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function returns the same value whether its two arguments are the same instance or are two different instances with the same integer stored in their <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>value<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数の実装は、それの２つの引数が同じインスタンスであろうと、それらの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>value<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロハティの中に格納される同じ整数を持つ２つの異なるインスタンスであろうと、同じ値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index at which to start the resulting subsequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それで結果の下位シーケンスが始まるインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>key<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and its associated value if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>key<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is in the dictionary; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>key<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>とそれの結び付けられた値のインデックス、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>key<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が辞書の中にあるならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index must be a valid index of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(unicode<ph x="2">&lt;w2/&gt;</ph>Scalars)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(unicode<ph x="2">&lt;w2/&gt;</ph>Scalars)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index must be a valid index of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(utf16).unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(utf16).unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index must be a valid index of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(utf16).utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(utf16).utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index must be a valid index of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(utf16)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(utf16)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index must be a valid index of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(utf8).unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(utf8).unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index must be a valid index of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(utf8).utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(utf8).utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index must be a valid index of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(utf8)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(utf8)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>member<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if it exists in the set; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それがこの集合に含まれるならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>member<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインデックス；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index of the first element for which <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> returns <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それに対して<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>predicate<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返す最初の要素のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index of the first element in a nonempty buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空でないバッファの中の最初の要素のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index of the first element in the reordered collection that matches <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>belongs<ph x="2">&lt;w2/&gt;</ph>In<ph x="3">&lt;w3/&gt;</ph>Second<ph x="4">&lt;w4/&gt;</ph>Partition<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>並べ直されたコレクションの中の最初の要素のインデックス、それは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>belongs<ph x="2">&lt;w2/&gt;</ph>In<ph x="3">&lt;w3/&gt;</ph>Second<ph x="4">&lt;w4/&gt;</ph>Partition<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に合致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index of the first value to swap.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>交換する１つ目の値のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index of the last element to include in the resulting subsequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果の下位シーケンスの中に含まれることになる最後の要素のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index of the lead surrogate is successfully converted to a position in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, but the index of the trailing surrogate is not.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>先頭サロゲートのインデックスはうまく<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>other<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>での位置に変換されます、しかし後続サロゲートのインデックスは違います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index of the lead surrogate is successfully converted to a position in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, but the index of the trailing surrogate is not.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>先頭サロゲートのインデックスはうまく<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>での位置に変換されます、しかし後続サロゲートのインデックスは違います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index of the member to remove.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>削除するメンバのインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index of the second value to swap.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>交換する２つ目の値のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index type for a string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューのためのインデックス型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index type for subscripting a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列で添え字を使うためのインデックス型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index type for subscripting a string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューでの添え字のためのインデックス型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index type for subscripting a string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューでの添え字のためのインデックス型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index value immediately after <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の直後のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The index value immediately before <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>i<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の直前のインデックス値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The indices that are valid for subscripting the collection, in ascending order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの添え字に使うのに有効である、昇順でのインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The indices that are valid for subscripting the range, in ascending order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>昇順で、範囲の添え字として有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The infix operators are grouped below by precedence group in decreasing order of precedence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>中置演算子は、以下に優先順位の高い方から優先順位グループによって分類されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The initial state that will be passed to the closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態、それはクロージャに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The initializer creates the string representation of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>instance<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in one of the following ways, depending on its protocol conformance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>instance<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の文字列表現をそれのプロトコル準拠に依存して以下の方法の１つで作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The initializer creates the string representation of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>instance<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> in one of the following ways, depending on its protocol conformance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>instance<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の文字列表現をそれのプロトコル準拠に依存して以下の方法の１つで作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The input string to convert to a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスへ変換することになる入力文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The input string to convert to a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float80<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float80<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスへ変換することになる入力文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The input string to convert to a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスへ変換することになる入力文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The input was entirely consumed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入力はすっかり消費された。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The instance passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> will leak if nothing eventually balances the retain.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡されるインスタンスは、リテインが結局は均衡を保つことがないならば漏洩します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The instance referenced by this pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタによって参照されるインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The instance to cast to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>にキャストすることになるインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The instance to copy into memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリにコピーすることになるインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The instance to initialize this pointer’s memory with.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタのメモリを使って初期化されるインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The instances in the region <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>source..&lt;(source + count)<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> are unaffected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>領域<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>source..&lt;(source + count)<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>の中のインスタンスは、影響を受けません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The instances of <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>NSDictionary<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> and <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>Dictionary<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> share buffer using the same copy-on-write optimization that is used when two instances of <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>Dictionary<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> share buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>NSDictionary<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>と<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>Dictionary<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>インスタンスは、<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>Dictionary<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>の２つのインスタンスがバッファを共有するとき使われるのと、同じコピーオンライト最適化を使ってバッファを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The instances of <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>NSSet<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> and <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>Set<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> share buffer using the same copy-on-write optimization that is used when two instances of <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>Set<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> share buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>NSSet<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>と<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>Set<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>のインスタンスは、<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>Set<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>の２つのインスタンスがバッファを共有するとき使われるのと、同じコピーオンライト最適化を使ってバッファを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The int to use in an indexed collection (e.g. an int-keyed dictionary).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>intをインデックス付きコレクションで使います（例えば、intキー付き辞書）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The integer encoding of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Double<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの整数符号化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The integer encoding of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの整数符号化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The integer to convert to a floating-point value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点値へ変換されることになる整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The integer to convert, and instance of type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変換する整数、そして型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The integer value of the desired key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>望むキーの整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The integer’s hash value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その整数のもつハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The integral value found by rounding using <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rule<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rule<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って丸められることによって見出される整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The iterator for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Enumerated<ph x="2">&lt;w2/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Enumerated<ph x="2">&lt;w2/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のためのイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The joined sequence of elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>つなぎ合わされたシーケンス要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key that the decoded value is associated with.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デコードされた値が関連付けられるキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key that the nested container is associated with.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされたコンテナが関連付けられるキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key to associate the object with.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクトと関連付けられるキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key to associate the value with.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値と関連付けられるキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key to associate with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と結び付けられるキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key to compare against.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このキーに対して比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key to compare with.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このキーと比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key to decode <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>super<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>super<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をデコードするためのキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key to encode <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>super<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>super<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をエンコードするためのキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key to encode the container for.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンテナをエンコードするためのキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key to find in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このキーが辞書において捜されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key to remove along with its associated value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの関連する値とともに削除されるキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key to search for.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このキーについて調査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key type of a dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書リテラルのキー型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key type to use for the container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンテナに対して使うためのキー型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key-value pair at position <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>位置<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>position<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>でのキー値ペア。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key-value pair that correspond to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対応するキー値ペア。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key-value pairs that will make up the new dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい辞書を作り上げるキー値ペア。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key’s hash value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのキーのもつハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key’s string value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーのもつ文字列値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The last element of the array if the array is not empty; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列が空でないならば配列の最後の要素；そうでなければ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The last element of the collection if the collection has one or more elements; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションが１つ以上の要素を持つならばコレクションの最後の要素；そうでなければ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The last element of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの最後の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The lazy collection isn’t persisted, so the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>predicate<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> closure won’t actually escape the body of the function, but even so it can’t be used in this way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延コレクションは持続させられません、それで<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>predicate<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>クロージャは実際には関数の本文を脱出することはありません、しかしそうであってもそれはこの方法では使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The least normal exponent for values of the type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>F<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>1 - bias<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, and the largest finite exponent is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>bias<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>F<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の最小正規化指数は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>1 - bias<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です、最大有限指数は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>bias<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The least of all the arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての引数のうち最も少ないもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The least positive normal number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最も小さい正のノーマル数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The least positive number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最も小さい正の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The least representable value that compares greater than this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>表現可能な最も小さい値で、この値と比較してより大きいもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The left-hand side of the operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子の左手側。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The length in bytes of the static string’s ASCII or UTF-8 representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>静的文字列のASCIIまたはUTF-8表現のバイトでの長さ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The lesser of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のうちより小さいもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The line number to print along with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the assertion fails.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>表明（アサーション）がうまくいかないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>とともに出力する行番号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The line number to print along with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>message<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に加えて出力される行番号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The literal <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>23<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is inferred as an <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instance and then wrapped as an optional before the comparison is performed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リテラル<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>23<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Int<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスと推論され、それから比較が実行される前にオプショナルとしてラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The little-endian representation of this integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この整数のリトルエンディアン表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The logical AND operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;&amp;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) combines two Boolean values and returns <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> if both of the values are <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>true<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理AND演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;&amp;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は２つのブール値を組み合わせて、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を両方の値が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>true<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ならば返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The logical NOT operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>!<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) inverts a Boolean value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理NOT演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>!<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、ブール値を逆にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The logical OR operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>||<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) combines two Boolean values and returns <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> if at least one of the values is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>true<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理OR演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>||<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、２つのブール値を組み合わせて、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を値の少なくとも１つが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>true<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ならば返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The longer scalar values may need two <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> values for storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より長いスカラー値は、２つの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>UInt16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値をストレージとして必要とするかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The lower bound for the range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲の下側の境界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The lower bound of a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Countable<ph x="7">&lt;w7/&gt;</ph>Range<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance is its start index, and the upper bound is its end index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Countable<ph x="7">&lt;w7/&gt;</ph>Range<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスの下側の境界はそれの始まりのインデックスです、そして上側の境界はそれの終わりのインデックスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The magnitude of a floating-point value <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> of type <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>F<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> can be calculated by using the following formula, where <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>**<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is exponentiation:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>F<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の浮動小数点値<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の規模は、以下の公式を使って計算されることができます、そこで<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>**<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は冪演算です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The magnitude of this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値の規模。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The masking addition operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) silently discards any overflow that occurs during the operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>掩蔽加算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、演算の間に起こるあらゆるオーバーフローを黙って廃棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The masking left shift operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;&lt;&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) performs a <bpt i="2" x="2">&lt;e2&gt;</bpt>masking shift<ept i="2">&lt;/e2&gt;</ept>, where the value used as <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>rhs<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is masked to produce a value in the range <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0..<ph x="7">&lt;lhs&lt;w7/&gt;</ph>.bit<ph x="8">&lt;w8/&gt;</ph>Width<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>マスク左シフト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;&lt;&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、<bpt i="2" x="2">&lt;e2&gt;</bpt>マスクするシフト<ept i="2">&lt;/e2&gt;</ept>を実行します、そこにおいて<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>rhs<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>として使われる値はマスクされることで範囲<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0..<ph x="7">&lt;lhs&lt;w7/&gt;</ph>.bit<ph x="8">&lt;w8/&gt;</ph>Width<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の中の値を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The masking multiplication operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;*<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) silently discards any overflow that occurs during the operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>掩蔽乗算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;*<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、演算の間に起こるあらゆるオーバーフローを黙って廃棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The masking right shift operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;&gt;&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) performs a <bpt i="2" x="2">&lt;e2&gt;</bpt>masking shift<ept i="2">&lt;/e2&gt;</ept>, where the value passed as <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>rhs<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is masked to produce a value in the range <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0..<ph x="7">&lt;lhs&lt;w7/&gt;</ph>.bit<ph x="8">&lt;w8/&gt;</ph>Width<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>マスク右シフト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;&gt;&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、<bpt i="2" x="2">&lt;e2&gt;</bpt>マスクするシフト<ept i="2">&lt;/e2&gt;</ept>を実行します、そこにおいて<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>rhs<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>として渡される値はマスクされることで範囲<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>0..<ph x="7">&lt;lhs&lt;w7/&gt;</ph>.bit<ph x="8">&lt;w8/&gt;</ph>Width<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の中の値を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The masking subtraction operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) silently discards any overflow that occurs during the operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>掩蔽減算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&amp;-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、演算の間に起こるあらゆるオーバーフローを黙って廃棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The mathematical constant pi.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数学の定数pi。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The maximum number of bytes to write to buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファに書き込む最大バイト数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The maximum number of elements to return.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返される要素の最大限の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The maximum number of times to split the collection, or one less than the number of subsequences to return.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションを分割する回数の最大限度、または返される下位シーケンスの数より１つ少ないもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The maximum number of times to split the sequence, or one less than the number of subsequences to return.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスを分割する回数の最大限度、または返される下位シーケンスの数より１つ少ないもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The maximum representable integer in this type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型における最大の表現可能な整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory at <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source..&lt;(source + count)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be initialized to a trivial type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source..&lt;(source + count)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>でのメモリは、自明型に初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory at this pointer plus <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>offset<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be properly aligned for accessing <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and initialized to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> or another type that is layout compatible with <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>T<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタに<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>offset<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を加えたところでのメモリは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>にアクセスするために厳密にアラインされ、そして<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>または<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>T<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>とレイアウト互換の別の型に初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory at this pointer plus <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>offset<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be properly aligned for accessing <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>offset<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を加えたこのポインタでのメモリは、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>にアクセスするために適切にアラインされる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory in the region <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source..&lt;(source + count)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> may overlap with the destination region.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>領域<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source..&lt;(source + count)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中のメモリは、行き先の領域と重なってはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory in the region <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source..&lt;(source + count)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be initialized to a trivial type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source..&lt;(source + count)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中のメモリは、自明型に初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory in the region <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source..&lt;(source + count)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be initialized to type <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and must not overlap the destination region.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>領域<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source..&lt;(source + count)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中のメモリは、型<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に初期化されなければなりません、そして行き先の領域と重なってはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory in the region <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source..&lt;(source + count)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be initialized to type <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>領域<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source..&lt;(source + count)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中のメモリは、型<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory in this region is bound to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, but has not been modified in any other way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この領域の中のメモリは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>へと束縛されます、しかし他のいかなる方法においても変更されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory is allocated, but not initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリはアロケートされます、しかし初期化されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory layout of a type, describing its size, stride, and alignment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型のメモリレイアウト、それはそれのサイズ、ストライド、およびアライメントを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory must also be uninitialized, initialized to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, or initialized to another trivial type that is layout compatible with <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリはまた、未初期化状態にされる、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に初期化される、または別の自明型で<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>とレイアウト互換なものに初期化される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory must also be uninitialized, initialized to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>T<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, or initialized to another trivial type that is layout compatible with <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>T<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリはまた、未初期化状態にされる、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>T<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に初期化される、または別の自明型で<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>T<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>とレイアウト互換なものに初期化される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory must be initialized to a value of a type that is layout compatible with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>とレイアウト互換である型の値に初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory must be uninitialized or initialized to a type that is layout compatible with <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>T<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリは、未初期化であるか<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>T<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>とレイアウト互換でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory must not be initialized or <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Pointee<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> must be a trivial type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリは初期化されてはなりません、また<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Pointee<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は自明型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory referenced by an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance can be in one of several states.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスによって参照されるメモリは、いくつかの状態の１つであることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory referenced by an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance can be in one of several states.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスによって参照されるメモリは、いくつかの状態の１つであることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory referenced by an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance can be in one of several states.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスによって参照されるメモリは、幾つかの状態のうち１つであるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory referenced by an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance can be in one of several states.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスによって参照されるメモリは、幾つかの状態のうち１つであるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory referenced by the new buffer is allocated, but not initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいバッファによって参照されるメモリは、アロケートされます、しかし初期化されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory referenced by the returned raw pointer is still bound to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返される生のボインタによって参照されるメモリは、依然として<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への境界です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory referenced by this pointer must be initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタによって参照されるメモリは、初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory referenced by this pointer must be uninitialized or initialized to a trivial type, and must be properly aligned for accessing <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタによって参照されるメモリは、未初期化状態にされるまたは自明型に初期化されなければなりません、そして<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>にアクセスするために適切にアラインされなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory region <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source..&lt;(source + count)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリ領域<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source..&lt;(source + count)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory region that is deallocated is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>capacity * Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;Pointee&gt;.stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> bytes in size.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デアロケートされるメモリ領域は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>capacity * Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;Pointee&gt;.stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バイトの大きさです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory regions referenced by <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>source<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and this pointer may overlap.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>source<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>によって参照されるメモリ領域とこのポインタは、重なり合うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory regions referenced by <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>source<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and this pointer must not overlap.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>source<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>によって参照されるメモリ領域とこのポインタは、重なり合わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory regions referenced by <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>source<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and this pointer may overlap.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>source<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>によって参照されるメモリ領域とこのポインタは、重なり合うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory starting at this pointer must be bound to the type <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>T<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタで始まるメモリは、型<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>T<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に束縛されていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory to be deallocated must be uninitialized or initialized to a trivial type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>割り当て解除されるメモリは、未初期化でなければなりません、または自明型に初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory to be deallocated must not be initialized or must be initialized to a trivial type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>割り当て解除されるメモリは初期化されてはなりません、または自明型に初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory to read for the new instance must not extend beyond the buffer pointer’s memory region—that is, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>offset + Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;T&gt;.size<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be less than or equal to the buffer pointer’s <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいインスタンスのために読み出すメモリは、バッファポインタのもつメモリ領域を越えて拡張されてはなりません — すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>offset + Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;T&gt;.size<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はバッファポインタのもつ<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>より少ないか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory written to must not extend beyond the buffer pointer’s memory region—that is, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>offset + Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;T&gt;.size<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be less than or equal to the buffer pointer’s <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>書き込まれることになるメモリは、バッファポインタのもつメモリ領域を越えて拡張されてはなりません — すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>offset + Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;T&gt;.size<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はバッファポインタのもつ<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>より少ないか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The minimum number of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>s that must be able to be stored in the new buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいバッファに格納されることが可能でなければならない<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の最小限の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The minimum number of ASCII character’s worth of storage to allocate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>割り当てる最小数のASCII文字相当のストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The minimum number of elements that the newly created set should be able to store without reallocating its buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しく作成された集合がそれのバッファを再割り当てすることなしに格納可能であるであろう要素の最小限の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The minimum number of key-value pairs to allocate buffer for in the new dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい辞書におけるキー値ペアの最小限の数、それに対してバッファが割り当てられることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The minimum of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, or whichever is a number if the other is NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の最小、または他方がNaNならば数である方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The minimum representable integer in this type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型における最小の表現可能な整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The most common way to access values in a dictionary is to use a key as a subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の中の値にアクセスする最も普通の方法は、キーを添え字として使うことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The most common way to iterate over the elements of a sequence is to use a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loop:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの要素のすべてにわたって反復するための最も一般的な方法は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ループを使うことです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The most familiar use of relational operators is to compare numbers, as in the following example:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最もよく知られている関係演算子の使用は、数の比較に対してです、以下の例でのように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The multiplication operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>*<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) calculates the product of its two arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>乗算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>*<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、それの２つの引数の積を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The mutable raw pointer to convert.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変換されることになる可変ポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The naming of those macros is slightly misleading, because <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>infinity<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is greater than this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのマクロの命名の仕方は少しばかり誤解させます、なぜなら<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>infinity<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>はこの値より大きいからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The naming of those macros is slightly misleading, because subnormals, zeros, and negative numbers are smaller than this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのマクロの命名の仕方は少しばかり誤解させます、なぜならサブノーマル、ゼロ、そして負の数はこの値より小さいからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The nearest integral value, or, if two integral values are equally close, the integral value with greater magnitude.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最も近い整数値、または、２つの整数値が同じくらい近いならば、より大きい規模を持つ整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The negation operator (prefix <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) returns the additive inverse of its argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>負にする演算子（前置<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、この引数の加法の逆元を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>students<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Letter<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> dictionary has three entries, with students’ names grouped by the keys <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"E"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>"K"<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>"A"<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>students<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Letter<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>辞書は、生徒の名前をキー<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>"E"<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>"K"<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>"A"<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>でグループ分けして、３つの登録項目を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new Unicode scalar values to add to the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列へ加える新しいユニコードスカラー値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new array, on the other hand, matches the order and number of elements provided.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一方、新しい配列は、提供された要素の順番と数に合致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new buffer will represent the same region of memory as the slice, but it’s indices will be rebased to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいバッファは、スライスと同じメモリ領域を表します、しかしそれのインデックスはゼロに再配置されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new character to insert into the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列へ挿入する新しい文字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new characters to add to the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列へ加える新しいいくらかの文字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new characters to add to the view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビューへ加える新しいいくらかの文字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new element is inserted before the element currently at the specified index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい要素は、指定されたインデックスでの現在の要素の前に挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new element to insert into the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列に挿入されることになる新しい要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new element to insert into the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションに挿入されることになる新しい要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new elements are inserted before the element currently at the specified index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいいくらかの要素が、指定されたインデックスでの現在の要素の前に挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new elements to add to the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列に加えられることになる新しい要素ら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new elements to add to the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションに加える新しいいくらかの要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new elements to insert into the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションへ挿入される新しいいくらかの要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new floating-point value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい浮動小数点値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new raw buffer will represent the same region of memory as the slice, but it’s indices will be rebased to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい生のバッファは、スライスと同じメモリ領域を表します、しかしそれのインデックスはゼロに再配置されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new storage is a multiple of the old storage’s size.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいストレージは古いストレージの大きさの倍数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new value represents the address of the pointer passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい値は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡されるポインタのアドレスを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new value to add to the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この辞書に加える新しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new value’s exponent.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい値の持つ指数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new value’s significand.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい値の持つ仮数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>n<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> bytes of the memory that <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>some<ph x="10">&lt;w10/&gt;</ph>Bytes<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> references are copied in this code:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>some<ph x="10">&lt;w10/&gt;</ph>Bytes<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>が参照する次の<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>n<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>バイトのメモリは、このコードでコピーされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next code sample shows a possible extension to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type that parses the integer value of a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance, throwing an error when there is a problem during parsing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次のコード例が示すのは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型に対する１つの可能な拡張で、それは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスの整数値をパースして、パースの間に問題がある時はエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next element in the underlying sequence if a next element exists; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の要素が存在するならば基礎をなすシーケンス中の次の要素；そうでなければ、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next element in the underlying sequence, if a next element exists; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の要素が存在するならば、基礎をなすシーケンス中の次の要素；そうでなければ、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next example attempts to convert the indices of the two UTF-16 code points that represent the teacup emoji (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"🍵"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は、ティーカップ絵文字（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"🍵"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を表す２つのUTF-16コード点のインデックスの変換を試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next example attempts to retrieve an index six positions from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>s<ph x="2">&lt;w2/&gt;</ph>.start<ph x="3">&lt;w3/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> but fails, because that distance is beyond the index passed as <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>limit<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>s<ph x="2">&lt;w2/&gt;</ph>.start<ph x="3">&lt;w3/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から６位置のインデックスをとりだすことを試みます、しかし失敗します、なぜならその間隔は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>limit<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>として渡されるインデックスを越えるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next example attempts to retrieve an index ten positions from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ph x="2">&lt;w2/&gt;</ph>.start<ph x="3">&lt;w3/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, but fails, because that distance is beyond the index passed as <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>limit<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ph x="2">&lt;w2/&gt;</ph>.start<ph x="3">&lt;w3/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から10位置のインデックスをとりだすことを試みます、しかし失敗します、なぜならその間隔は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>limit<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>として渡されるインデックスを越えるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next example declares the generic <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>squared<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function, which accepts an instance <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> of any fixed-width integer type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は、総称体<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>squared<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を宣言します、それはあらゆる型の固定長整数型の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next example tries to find the correct text for a greeting in two separate dictionaries before falling back to a static default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は、挨拶として正しいテキストを２つの独立した辞書から見つけることをある静的な省略時のものに落ち着く前に試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next example uses key-based subscripting of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>response<ph x="2">&lt;w2/&gt;</ph>Messages<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> dictionary with two keys that exist in the dictionary and one that does not.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は、キーに基づく添え字を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>response<ph x="2">&lt;w2/&gt;</ph>Messages<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>辞書に使います、ですが２つのキーは辞書に存在し１つはそうでありません。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The non-optional value is wrapped as an optional before the comparison is made.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非オプショナル値は、比較がなされる前にオプショナル値としてラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bits equal to 1 in this value’s binary representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値のバイナリ表現の中の１に等しいビットの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bits in the current binary representation of this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値の現在のバイナリ表現でのビット数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bits required to represent the value’s significand.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値の仮数を表すのに必要とされるビットの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bits to shift <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to the left.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このビット数を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から左へとシフトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bits to shift <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to the right.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このビット数を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から右へとシフトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bits used for the underlying binary representation of values of this type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型の値の基礎をなすバイナリ表現に対して使われるビットの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bits used to represent the type’s exponent.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値の指数を表すのに使われるビットの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bytes from the start of one instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to the start of the next when stored in contiguous memory or in an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Array&lt;T&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の１つのインスタンスの始まりから次のものの始まりまでのバイト数、隣接メモリの中にまたは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Array&lt;T&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の中に格納される場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bytes in the buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファの中のバイト数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bytes in this region is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>count * Memory<ph x="4">&lt;w4/&gt;</ph>Layout&lt;T&gt;.stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この領域の中のバイト数は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>count * Memory<ph x="4">&lt;w4/&gt;</ph>Layout&lt;T&gt;.stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bytes to allocate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アロケートすることになるバイト数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bytes to copy.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コピーされることになるバイト数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bytes to deallocate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デアロケートされるバイト数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bytes to include in the buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このバッファの中に含むことになるバイト数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bytes to offset this pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタにオフセットするバイト数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of bytes used from buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファから使われるバイト数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of consecutive copies of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>new<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to initialize.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化する<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>new<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の連続コピーの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of copies of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to copy into memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリにコピーすることになる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のコピー数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of elements (always one).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素の数を返します（常に１つ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of elements (always zero).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素の数を返します（常にゼロ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of elements in the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その配列中の要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of elements in the buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このバッファの中の要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの要素の数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of elements in the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合中の要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of elements in this collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションの要素の数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of elements to drop from the beginning of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの始まりから省く要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of elements to drop from the beginning of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスの始まりから落とす要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of elements to drop off the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの終わりで省く要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of elements to drop off the end of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの末尾から取り除く要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of elements to remove from the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションから削除される要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of elements to remove.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>削除する要素の数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of instances in the buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファの中のインスタンスの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of instances of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to bind to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>type<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>type<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に束縛されることになる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of instances to copy from the memory referenced by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to this pointer’s memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によって参照されるメモリからこのポインタのもつメモリまでコピーされるインスタンスの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of instances to deinitialize.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライズするインスタンスの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of instances to move from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to this pointer’s memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>からこのポインタのもつメモリまで移動することになるインスタンスの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of key-value pairs in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の中のキー値ペアの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of leading zeros in this value’s binary representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値のバイナリ表現における先頭のゼロの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of new elements need not match the number of elements being removed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい要素の数は、削除される要素の数と一致する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of strides of the pointer’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type to offset <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインタの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のストライドの数、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に補われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of strides of the pointer’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type to offset <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインタの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のストライドの数、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に補われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of strides of the pointer’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type to offset this pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインタの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のストライドの数、このポインタに補われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of times to repeat <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を繰り返す回数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of times to repeat <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>repeated<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in the resulting string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>repeated<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を結果文字列の中で繰り返す回数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of times to repeat the value passed in the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>repeating<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>repeating<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータで渡された値を繰り返す回数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of trailing zeros in this value’s binary representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値のバイナリ表現において後に続くゼロの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of values contained in the range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この範囲に含まれる値の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of values in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の中の値の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number of words used for the current binary representation of this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値の現在のバイナリ表現に対して使われる単語の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The number’s hash value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その数の持つハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The object referenced by this <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unmanaged<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unmanaged<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスによって参照されるオブジェクト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The object to encode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エンコードするオブジェクト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The offset from this pointer at which to access an instance, measured in strides of the pointer’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタからのオフセット、それでインスタンスにアクセスします、ポインタの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のストライドにおいて測られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The offset from this pointer to the region of memory to be initialized with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, in the stride of type <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタから<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>で初期化されることになるメモリの領域へのオフセット、型<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>T<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のストライドで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The offset from this pointer, in bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタからのオフセット、バイトで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The offset in bytes into the buffer pointer’s memory to begin reading data for the new instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいインスタンスのためにデータの読み出しを開始するための、バッファポインタのもつメモリに対するバイトでのオフセット。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The offset of the byte to access.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセスすることになるバイトのオフセット。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The offset, in bytes, into the buffer pointer’s memory at which to begin reading data for the new instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファポインタのもつメモリに対する、バイトでの、オフセット、それで新しいインスタンスに対してデータ読み出しを始めることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The opaque pointer to convert to a typed pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付ポインタに変換されることになる不透明ポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The opaque pointer to convert.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変換されることになる不透明ポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The operation doesn’t require going beyond the limiting <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ph x="2">&lt;w2/&gt;</ph>.end<ph x="3">&lt;w3/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value, so it succeeds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この操作は、限度である<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ph x="2">&lt;w2/&gt;</ph>.end<ph x="3">&lt;w3/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を越えることを要求しません、それでそれは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The operation doesn’t require going beyond the limiting <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>s<ph x="2">&lt;w2/&gt;</ph>.end<ph x="3">&lt;w3/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value, so it succeeds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算は、限界である<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>s<ph x="2">&lt;w2/&gt;</ph>.end<ph x="3">&lt;w3/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を超えていく必要はありません、それでそれは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The optional <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>label<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> may be used when appropriate, e.g. to represent the name of a stored property or of an active <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>enum<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> case, and will be used for lookup when <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>s are passed to the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>descendant<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのオプショナル<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>label<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は適切な時に、例えば、保存プロパティのまたはアクティブな<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>enum<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ケース節の名前を再表現するのに使用できます、そして<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>descendant<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>メソッドに渡される時に検索用に使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The order of key-value pairs in a dictionary is stable between mutations but is otherwise unpredictable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書中のキー値ペアの順番は各変化間は安定しています、しかしそれ以外では予測できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The order of the key-value pairs is kept intact in the resulting <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー値ペアの順序は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスにおいて損なわれず保たれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The other value to multiply.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>掛け合わされることになるもう一方の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The output from each call to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>debug<ph x="2">&lt;w2/&gt;</ph>Print(_:<ph x="3">&lt;w3/&gt;</ph>separator:<ph x="4">&lt;w4/&gt;</ph>terminator:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> includes a newline by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>debug<ph x="2">&lt;w2/&gt;</ph>Print(_:<ph x="3">&lt;w3/&gt;</ph>separator:<ph x="4">&lt;w4/&gt;</ph>terminator:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への各呼び出しからの出力は、初期状態では改行を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The output from each call to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>debug<ph x="2">&lt;w2/&gt;</ph>Print(_:<ph x="3">&lt;w3/&gt;</ph>separator:<ph x="4">&lt;w4/&gt;</ph>terminator:<ph x="5">&lt;w5/&gt;</ph>to:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> includes a newline by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>debug<ph x="2">&lt;w2/&gt;</ph>Print(_:<ph x="3">&lt;w3/&gt;</ph>separator:<ph x="4">&lt;w4/&gt;</ph>terminator:<ph x="5">&lt;w5/&gt;</ph>to:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への各呼び出しからの出力は、初期状態では改行を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The output from each call to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(_:<ph x="2">&lt;w2/&gt;</ph>separator:<ph x="3">&lt;w3/&gt;</ph>terminator:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> includes a newline by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(_:<ph x="2">&lt;w2/&gt;</ph>separator:<ph x="3">&lt;w3/&gt;</ph>terminator:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への各呼び出しからの出力は、初期状態では改行を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The output from each call to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(_:<ph x="2">&lt;w2/&gt;</ph>separator:<ph x="3">&lt;w3/&gt;</ph>terminator:<ph x="4">&lt;w4/&gt;</ph>to:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> includes a newline by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(_:<ph x="2">&lt;w2/&gt;</ph>separator:<ph x="3">&lt;w3/&gt;</ph>terminator:<ph x="4">&lt;w4/&gt;</ph>to:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への各呼び出しからの出力は、初期状態では改行を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The path of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Coding<ph x="2">&lt;w2/&gt;</ph>Key<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>s taken to get to the point of the failing decode call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗しているデコード呼び出しの地点に行くために取られる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Coding<ph x="2">&lt;w2/&gt;</ph>Key<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The path of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Coding<ph x="2">&lt;w2/&gt;</ph>Key<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>s taken to get to the point of the failing encode call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗しているエンコード呼び出しの地点に行くために取られる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Coding<ph x="2">&lt;w2/&gt;</ph>Key<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The path of coding keys taken to get to this point in decoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デコーディングのこの時点を得るために取られるコーディングキーのパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The path of coding keys taken to get to this point in encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エンコーディングのこの時点を得るために取られるコーディングキーのパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pattern-matching operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>~=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) is used internally in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>case<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> statements for pattern matching.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パターンマッチング演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>~=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、内部的に<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>case<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>文の中でパターンマッチングのために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pattern-matching operator is primarily intended to enable <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>case<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> statement pattern matching.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パターンマッチング演算子は、元来<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>case<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>文パターンマッチングをできるようにすることを意図されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The payload consists of a sequence of decimal digits, or the characters <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>0X<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>0x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> followed by a sequence of hexadecimal digits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ペイロードは、一連の10進の桁、または文字<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>0X<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>か<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>0x<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に続く一連の16進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The payload to use for the new NaN value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいNaN値のために使うためのペイロード。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The performance of accessing <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>last<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, any methods that depend on <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>end<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, or moving an index depends on how many elements satisfy the predicate at the start of the collection, and may not offer the usual performance given by the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Collection<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>last<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、またはあらゆる<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>end<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>依存メソッドでのアクセスにおける性能は、どのくらい多くの要素が述部をコレクションの始まりで満たすかに依存します、そして<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Collection<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロトコルによって与えられる通常の性能を呈さないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The performance of accessing <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>first<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, any methods that depend on <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>start<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, or of advancing a <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Flatten<ph x="10">&lt;w10/&gt;</ph>Bidirectional<ph x="11">&lt;w11/&gt;</ph>Collection<ph x="12">&lt;w12/&gt;</ph>Index<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> depends on how many empty subcollections are found in the base collection, and may not offer the usual performance given by <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>Collection<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> or <bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>Bidirectional<ph x="17">&lt;w17/&gt;</ph>Index<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>first<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、あらゆる<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>start<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>依存のメソッドでのアクセスにおける、または<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Flatten<ph x="10">&lt;w10/&gt;</ph>Bidirectional<ph x="11">&lt;w11/&gt;</ph>Collection<ph x="12">&lt;w12/&gt;</ph>Index<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>での進んでいくことにおける性能は、どのくらい多くの空の下位コレクションが基盤コレクションにおいて見つけられるかに依存します、そして<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>Collection<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>または<bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>Bidirectional<ph x="17">&lt;w17/&gt;</ph>Index<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>によって与えられる通常の性能を呈さないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The performance of accessing <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>first<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, any methods that depend on <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>start<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, or of advancing a <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Flatten<ph x="10">&lt;w10/&gt;</ph>Collection<ph x="11">&lt;w11/&gt;</ph>Index<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> depends on how many empty subcollections are found in the base collection, and may not offer the usual performance given by <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Collection<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> or <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Forward<ph x="16">&lt;w16/&gt;</ph>Index<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>first<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、あらゆる<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>start<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>依存のメソッドでのアクセスにおける、または<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Flatten<ph x="10">&lt;w10/&gt;</ph>Collection<ph x="11">&lt;w11/&gt;</ph>Index<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>での進んでいくことにおける性能は、どのくらい多くの空の下位コレクションが基盤コレクションにおいて見つけられるかに依存します、そして<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Collection<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>または<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Forward<ph x="16">&lt;w16/&gt;</ph>Index<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>によって与えられる通常の性能を呈さないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The performance of accessing <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>first<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, any methods that depend on <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>start<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, or of advancing an index depends on how sparsely the filtering predicate is satisfied, and may not offer the usual performance given by <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Collection<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>first<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、あらゆる<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>start<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>依存のメソッドでのアクセスにおける、またはあるインデックスを進んでいくことにおける性能は、どのくらいフィルタ述部が満たされるのがまばらかに依存します、そして<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Collection<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>によって与えられる通常の性能を呈さないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The performance of accessing <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>first<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, or any methods that depend on <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>start<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> depends on how many elements satisfy the predicate at the start of the collection, and may not offer the usual performance given by the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Collection<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>first<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、またはあらゆる<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>start<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>依存メソッドでのアクセスにおける性能は、どのくらい多くの要素が述部をコレクションの始まりで満たすかに依存します、そして<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Collection<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロトコルによって与えられる通常の性能を呈さないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The performance of some collection operations depends on the type of index that the collection provides.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかのコレクション演算の性能は、コレクションの提供するインデックスの型に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer argument is valid only for the duration of the function’s execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ボインタ引数は、関数の実行の継続期間に対してだけ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer argument is valid only for the duration of the method’s execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインタ引数は、ただメソッドの実行の間に対してのみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer argument to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is valid only during the execution of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Pointer(to:<ph x="7">&lt;w7/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>へのポインタ引数は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Pointer(to:<ph x="7">&lt;w7/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の実行の間のみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer argument to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is valid only during the execution of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Pointer(to:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>へのポインタ引数は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Pointer(to:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の実行の間のみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer created through implicit bridging of an instance or of an array’s elements is only valid during the execution of the called function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスのまたは配列の要素の暗黙的ブリッジを通して作成されるポインタは、呼び出された関数の実行の間に有効であるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer passed as <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>start<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> must be aligned to <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>Memory<ph x="18">&lt;w18/&gt;</ph>Layout&lt;Element&gt;.alignment<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>start<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>として渡されるボインタは、<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>Memory<ph x="18">&lt;w18/&gt;</ph>Layout&lt;Element&gt;.alignment<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>にアラインされなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer passed as an argument to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is valid only during the execution of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>CString(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数として<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡されるポインタは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>CString(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の実行の間のみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer passed as an argument to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is valid only during the execution of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>CString(encoded<ph x="5">&lt;w5/&gt;</ph>As:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数として<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡されるポインタは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>CString(encoded<ph x="5">&lt;w5/&gt;</ph>As:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の実行の間のみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer passed as an argument to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is valid only during the execution of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Buffer<ph x="6">&lt;w6/&gt;</ph>Pointer(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数として<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡されるボインタは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Buffer<ph x="6">&lt;w6/&gt;</ph>Pointer(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の実行の間のみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer passed as an argument to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is valid only during the execution of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Buffer<ph x="7">&lt;w7/&gt;</ph>Pointer(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数として<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡されるボインタは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Buffer<ph x="7">&lt;w7/&gt;</ph>Pointer(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の実行の間のみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer passed as an argument to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is valid only during the execution of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Va<ph x="5">&lt;w5/&gt;</ph>List(_:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数として<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡されるポインタは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>with<ph x="4">&lt;w4/&gt;</ph>Va<ph x="5">&lt;w5/&gt;</ph>List(_:<ph x="6">&lt;w6/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の実行の間のみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer passed as an argument to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is valid only for the lifetime of the closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数として<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡されるポインタは、このクロージャの生涯に対してのみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer to calculate the distance to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それへの隔たりを計算されるポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer to convert.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変換されることになるポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer to use as the source for the new integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい整数のためのソースとして使う値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer’s hash value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのポインタの持つハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position after the element to create an index for.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それに対するインデックスを作成する要素の後の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position after this position in the underlying collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基盤コレクションでのこの位置の後の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position at which to insert the new element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そこで新しい要素が挿入されることになる位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position at which to insert the new elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そこで新しいいくらかの要素が挿入されるところの位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position corresponding to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in the underlying collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基盤コレクションの中の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に一致している位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>characters<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that corresponds exactly to this index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスに正確に対応する<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>characters<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that corresponds exactly to this index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスに正確に対応する<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that corresponds exactly to this index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスに正確に対応する<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that corresponds exactly to this index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスに正確に対応する<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the character to remove.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>削除する文字の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the element to access.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセスする要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the element to remove.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>削除する要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the first Unicode scalar value if the string is nonempty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列が空でないならば、最初のユニコードスカラー値の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the first character in a nonempty character view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空でない文字ビューの中の最初の文字の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the first character in a nonempty string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空でない文字列の中の最初の文字の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the first code unit if the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is nonempty; identical to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が空で無いならば最初のコードユニットの位置；そうでないならば<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the first code unit if the UTF-8 view is nonempty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-8ビューが空でないならば、最初のコードユニットの位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the first code unit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初のコード単位の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the first element in a non-empty collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空でないコレクションにおける最初の要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the first element in a nonempty array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空でない集合の中の最初の要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the first element in a nonempty collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空でないコレクションの中の最初の要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the first element in a nonempty dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空でない辞書の中の最初の要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the first element in the range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲の中の最初の要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the first element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the key-value pair to access.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この位置のキー値ペアにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The position of the key-value pair to remove.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>削除されるキー値ペアの位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The positive difference between 1.0 and the next greater representable number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>1.0と次により大きい表現可能な数との間の正の差異。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The predicate must be a <bpt i="0" x="0">&lt;e0&gt;</bpt>equivalence relation<ept i="0">&lt;/e0&gt;</ept> over the elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>述部は要素に対して<bpt i="0" x="0">&lt;e0&gt;</bpt>同値関係<ept i="0">&lt;/e0&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The predicate must be a <bpt i="0" x="0">&lt;e0&gt;</bpt>strict weak ordering<ept i="0">&lt;/e0&gt;</ept> over the elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>述部は、それら要素に対して<bpt i="0" x="0">&lt;e0&gt;</bpt>厳密弱順序<ept i="0">&lt;/e0&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The predicate orders errors before successes and sorts the error responses by their error code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この述部はエラーを成功の前に並べて、そしてそれらエラー応答をそのエラーコードによってソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The presence of a value, stored as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Wrapped<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値の存在、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Wrapped<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The product of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, added to this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値に加えられることになる、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の積。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The protocol to which all class types implicitly conform.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全てのクラスが暗黙的に準拠するプロトコル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The protocol to which all classes implicitly conform.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それに対して全てのクラスが暗黙的に準拠するプロトコル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The quotient of dividing this value by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>で除算した余り。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The radix, or base of exponentiation, for a floating-point type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある浮動小数点型の基数、または冪演算の底。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The radix, or base of exponentiation, for this floating-point type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この浮動小数点型に対しての基数、または冪での底。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The radix, or base, to use for converting <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>text<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to an integer value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>text<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を整数値に変換するのに使うための基数、または底。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The range of byte offsets to access.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセスすることになるバイトオフセットの範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The range of characters in the receiver to get.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>取得することになるレシーバにおける文字の範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The range of characters to replace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>置き換える文字範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The range of elements to replace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>置き換えることになる要素範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The range of indices to allow access to in the new slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいスライスにおいて、アクセスするのが許されるインデックスの範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The range of text to replace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>置き換えるテキスト範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The range of the collection to be removed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>削除されることになるコレクションの範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The range of the elements to remove.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>削除する要素の範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The range to clamp the bounds of this range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この範囲に制限を課すための範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The range’s lower bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その範囲の下方の境界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The range’s upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その範囲の上方の境界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The range’s “past the end” position—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲の「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The raw encoding of the value’s exponent field.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値の指数フィールドの生のエンコーディング。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The raw encoding of the value’s significand field.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値の仮数フィールドの生のエンコーディング。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The raw type that can be used to represent all values of the conforming type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>準拠している型のすべての値を表すために使われる生の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The raw value must therefore be of a type that conforms to the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Fixed<ph x="8">&lt;w8/&gt;</ph>Width<ph x="9">&lt;w9/&gt;</ph>Integer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> protocol, such as <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>UInt8<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> or <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Int<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の値はしたがって、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Fixed<ph x="8">&lt;w8/&gt;</ph>Width<ph x="9">&lt;w9/&gt;</ph>Integer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>プロトコルに準拠する型、例えば<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>UInt8<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>または<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Int<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>などのものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The raw value of the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>allowed<ph x="4">&lt;w4/&gt;</ph>Moves<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance is the result of the bitwise OR of its three members’ raw values:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>allowed<ph x="4">&lt;w4/&gt;</ph>Moves<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスの生の値は、それの３つのメンバの持つ生の値のビット単位ORの結果です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The raw value of the option set to create.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>作成されるオプションセットの生の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The raw value to use for the new instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいインスタンスのために使う生の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The region of memory starting at this pointer and covering <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances of the pointer’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type must be initialized or <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> must be a trivial type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタで始まりそしてポインタの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>個のインスタンスを対象とするメモリ領域は初期化されなければならず、また<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は自明型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The region of memory starting at this pointer and covering <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances of the pointer’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type must be initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタで始まりそしてポインタのもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>個のインスタンスを対象とするメモリ領域は、初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The region of memory starting at this pointer and covering <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances of the pointer’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type must be uninitialized or <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> must be a trivial type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタで始まりそしてポインタの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>個のインスタンスを対象とするメモリ領域は未初期化でなければなりません、また<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は自明型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The remainder of the allocated region is unbound raw memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>割り当てられた領域の残りは、生のメモリに束縛されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The remainder of the relational operator functions are implemented by the standard library for any type that conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>残りの関係演算子関数は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するあらゆる型に対して標準ライブラリによって実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The remainder of this value divided by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> using truncating division.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>切り捨て除算を使って<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>で除算されたこの値の余りを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The remainder of this value divided by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>で除算されたこの値の余りを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The remaining range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>残っている範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The removed element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>削除された要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The requested number of elements to store.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>依頼された格納される要素数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The requested number of key-value pairs to store.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要請された数のキー値ペアを格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The required methods that are suffixed with <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Reporting<ph x="6">&lt;w6/&gt;</ph>Overflow<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> serve as the customization points for arithmetic operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>必須メソッドで<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Reporting<ph x="6">&lt;w6/&gt;</ph>Overflow<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を末尾に付けられるものは、算術演算に対するカスタマイズポイントとして供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result begins with the first element of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>numbers<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> that does not satisfy <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>predicate<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果は、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>predicate<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を満たさない、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>numbers<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の最初の要素で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result can be negative only if the collection conforms to the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Bidirectional<ph x="6">&lt;w6/&gt;</ph>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果は、そのコレクションが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Bidirectional<ph x="6">&lt;w6/&gt;</ph>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルに準拠する場合に限り、負であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result does not include any dynamically allocated or out of line storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果は、あらゆる動的にアロケートされるおよび慣行に合わないストレージを含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result has the same sign as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and is less than <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ph x="4">&lt;w4/&gt;</ph>.magnitude<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と同じ符号を持ち、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ph x="4">&lt;w4/&gt;</ph>.magnitude<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>より小さいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>from<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です、もし<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>from<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result is always exact.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果は常に厳密に正確です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result is always positive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果は常に正です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result of attempting to parse a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> from some input.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>なんらかの入力からの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を構文解析を試みることの結果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result of evaluating <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>rhs<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> is the result of the <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>||<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>rhs<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を評価することの結果は、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>||<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>演算の結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result of evaluating <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>rhs<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> is the result of the <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>&amp;&amp;<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>rhs<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>を評価することの結果は、<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>&amp;&amp;<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>演算の結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result of one Unicode decoding step.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつのユニコード復号化処理の結果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result of the given closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたクロージャの結果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result of the initializer has the same magnitude as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>magnitude<ph x="2">&lt;w2/&gt;</ph>Of<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザの結果は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>magnitude<ph x="2">&lt;w2/&gt;</ph>Ofgn<ph x="3">&lt;w3/&gt;</ph>Of<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と同じ規模を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result of the initializer has the same sign as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sign<ph x="2">&lt;w2/&gt;</ph>Of<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザの結果は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sign<ph x="2">&lt;w2/&gt;</ph>Of<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と同じ符号を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result of the modulo operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>%<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) has the same sign as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and is less than <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ph x="6">&lt;w6/&gt;</ph>.magnitude<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>モジュロ演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>%<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の結果は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と同じ符号を持ち、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>rhs<ph x="6">&lt;w6/&gt;</ph>.magnitude<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>より小さいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result of the operation is <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>false<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算の結果は、<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>false<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result of the operation is <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>true<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算の結果は、<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>true<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result of this operation will be the same type as its arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算の結果は、それの引数と同じ型になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result of this operation will have the nonoptional type of the left-hand side’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Wrapped<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算の結果は、左手側のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Wrapped<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型の非オプショナル型を持つことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mirror<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>children<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> may be upgraded to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Any<ph x="6">&lt;w6/&gt;</ph>Random<ph x="7">&lt;w7/&gt;</ph>Access<ph x="8">&lt;w8/&gt;</ph>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> later.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として生じる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mirror<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>children<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、後で<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Any<ph x="6">&lt;w6/&gt;</ph>Random<ph x="7">&lt;w7/&gt;</ph>Access<ph x="8">&lt;w8/&gt;</ph>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>にアップグレードされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mirror<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>superclass<ph x="4">&lt;w4/&gt;</ph>Mirror<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mirror<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の持つ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>superclass<ph x="4">&lt;w4/&gt;</ph>Mirror<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の結果は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>nil<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting array consists of at most <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Splits + 1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> subsequences.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果の配列は、多くとも<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Splits + 1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の下位シーケンスから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting collection has the type of argument on the right-hand side.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果となるコレクションは、右手側の引数の型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting collection has the type of the argument on the left-hand side.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果となるコレクションは、左手側の引数の型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting flattened array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として生じる平たくされた配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting pointer must be within the bounds of the same allocation as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果のポインタは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と同じアロケーションの境界内でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting pointer must be within the bounds of the same allocation as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果のポインタは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と同じアロケーションの境界内でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting pointer must be within the bounds of the same allocation as this pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果のポインタは、このポインタと同じアロケーションの範囲内でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting pointer references a region of memory that is bound to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and is <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>count * Memory<ph x="4">&lt;w4/&gt;</ph>Layout&lt;Pointee&gt;.stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> bytes in size.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果のポインタはあるメモリ領域を参照します、それは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に束縛されます、そして<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>count * Memory<ph x="4">&lt;w4/&gt;</ph>Layout&lt;Pointee&gt;.stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>バイトの大きさです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting quotient must be representable within the bounds of the type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果の商は、この型の境界の内に表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting subsequence <bpt i="0" x="0">&lt;e0&gt;</bpt>does not include<ept i="0">&lt;/e0&gt;</ept> the element at the position <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>end<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果となるシーケンスは、位置<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>end<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>での要素を<bpt i="0" x="0">&lt;e0&gt;</bpt>含みません<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting subsequence <bpt i="0" x="0">&lt;e0&gt;</bpt>includes<ept i="0">&lt;/e0&gt;</ept> the element at the position <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>end<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果となるシーケンスは、位置<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>end<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>での要素を<bpt i="0" x="0">&lt;e0&gt;</bpt>含みます<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting value must be representable in the same type as the argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果の値は、引数と同じ型で表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The results of those calls are passed to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(string<ph x="2">&lt;w2/&gt;</ph>Interpolation:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer in the order in which they appear in the string literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの呼び出しの結果は、文字列リテラルにおいてそれらが現れる順番で<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(string<ph x="2">&lt;w2/&gt;</ph>Interpolation:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result’s child labels will all be <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>nil<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果の持つ子のラベルはすべて<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>nil<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The retrieved slice of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>text<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equivalent in each of these cases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>取って来た<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>text<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のスライスは、それらの場合それぞれにで同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return type of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sequence(first:<ph x="2">&lt;w2/&gt;</ph>next:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>sequence(first:<ph x="2">&lt;w2/&gt;</ph>next:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の戻り型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return type of functions that do not return normally; a type with no values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>普通に戻らない関数の戻り型；値なしでの型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return type of functions that don’t explicitly specify a return type; an empty tuple (i.e., <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>戻り型を明示的に指定されない関数の戻り型；空のタプル（すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return value of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, if any.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の戻り値、もしあれば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return value of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure parameter, if any.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャパラメータの戻り値、もしあれば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return value of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure, if any, is the return value of this method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャの戻り値が、もしあれば、このメソッドの戻り値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return value of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure, if any.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャの戻り値、もしあれば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The returned <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ph x="2">&lt;w2/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance uses the same indices for the same elements as the original array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ph x="2">&lt;w2/&gt;</ph>Slice<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、同じ要素に対して元のコレクションと同じインデックスを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The returned bytes are not NUL-terminated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返される値はヌル終端ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The returned instance is memory-managed and unassociated with the value in the memory referenced by this pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返されるインスタンスは、メモリ管理されて、このポインタによって参照されるメモリの中の値と無関係です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The returned range is <bpt i="2" x="2">&lt;e2&gt;</bpt>not<ept i="2">&lt;/e2&gt;</ept> guaranteed to be inside the bounds of <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>collection<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返される範囲は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>collection<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の境界内であると保証され<bpt i="2" x="2">&lt;e2&gt;</bpt>ません<ept i="2">&lt;/e2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The reverse is not true: Two instances with equal hash values are not necessarily equal to each other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>逆は真ではありません：同じハッシュ値を持つ２つのインスタンスは必ず互いに等しいわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The right-hand side of the operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子の右手側。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The rounding rule to use.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この丸め規則を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The same state is passed to all invocations of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>next<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, so subsequent calls will see any mutations made by previous calls.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その同じ状態は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>next<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のすべてに呼び出しに対して渡されます、なので続いて起こる呼び出しは前の呼び出しによって為される何らかの変化を見ることになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The search is locale-aware, case and diacritic insensitive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この検索は、ロケール対応で、大文字小文字と発音記号は無視します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second example passes <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>max<ph x="4">&lt;w4/&gt;</ph>Splits<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> parameter, so the original string is split just once, into two new strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２番目の例は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>1<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>max<ph x="4">&lt;w4/&gt;</ph>Splits<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>パラメータに渡します、それで元の文字列は一度だけ分割されて、２つの新しい文字列になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second partition, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>numbers[p...]<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, is made up of the elements that <bpt i="6" x="6">&lt;e6&gt;</bpt>are<ept i="6">&lt;/e6&gt;</ept> greater than 30.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２番目の区画、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>numbers[p...]<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は、30より大きなもの<bpt i="6" x="6">&lt;e6&gt;</bpt>である<ept i="6">&lt;/e6&gt;</ept>要素から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second sequence or collection to zip.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>組み合わされる第２のシーケンスまたはコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second value to add.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加算する第２の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second value to multiply.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>掛け合わされる第２の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second version of <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>all<ph x="12">&lt;w12/&gt;</ph>Values(in:<ph x="13">&lt;w13/&gt;</ph>match:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> compiles without error, with the compiler guaranteeing that the <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>escapable<ph x="16">&lt;w16/&gt;</ph>Predicate<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> closure doesn’t last beyond the call to <bpt i="17" x="17">&lt;c17&gt;</bpt><bpt i="18" x="18">&lt;s18&gt;</bpt>without<ph x="19">&lt;w19/&gt;</ph>Actually<ph x="20">&lt;w20/&gt;</ph>Escaping(_:<ph x="21">&lt;w21/&gt;</ph>do:)<ept i="18">&lt;/s18&gt;</ept><ept i="17">&lt;/c17&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２番目のバージョンの<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>all<ph x="12">&lt;w12/&gt;</ph>Values(in:<ph x="13">&lt;w13/&gt;</ph>match:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>は、<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>escapable<ph x="16">&lt;w16/&gt;</ph>Predicate<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>クロージャが<bpt i="17" x="17">&lt;c17&gt;</bpt><bpt i="18" x="18">&lt;s18&gt;</bpt>without<ph x="19">&lt;w19/&gt;</ph>Actually<ph x="20">&lt;w20/&gt;</ph>Escaping(_:<ph x="21">&lt;w21/&gt;</ph>do:)<ept i="18">&lt;/s18&gt;</ept><ept i="17">&lt;/c17&gt;</ept>の呼び出しを越えて持ちこたえないことをコンパイラが保証して、エラーなしでコンパイルします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sequence ends when <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>next<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> returns <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシーケンスは、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>next<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>nil<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を返す時に終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sequence must be finite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスは有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sequence of elements for the new collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいコレクションのための要素からなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sequence of elements to turn into an array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列になることになる、いくらかの要素からなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sequences whose contents to encode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの内容をエンコードするシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sequence’s iterator is used directly to retrieve the initial value before looping over the rest of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスのもつイテレータが直に使われて、残りのシーケンスにループする前に初期値をとってきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sequence’s maximum element if the sequence is not empty; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスが空でないならばシーケンスの最大の要素；そうでなければ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sequence’s maximum element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの最大の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sequence’s minimum element, according to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>are<ph x="2">&lt;w2/&gt;</ph>In<ph x="3">&lt;w3/&gt;</ph>Increasing<ph x="4">&lt;w4/&gt;</ph>Order<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの最小の要素、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>are<ph x="2">&lt;w2/&gt;</ph>In<ph x="3">&lt;w3/&gt;</ph>Increasing<ph x="4">&lt;w4/&gt;</ph>Order<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>による。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sequence’s minimum element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスの最小の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The set must not be empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合は空であってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The shift is performed using this masked value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シフトは、このマスクされた値を使って実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The shortened form is preferred for ease of reading and writing code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この短縮された形式は、コードの読み書きの容易さのためにより好ましいものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sign for a negative value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>負の値に対する符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sign for a positive value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正の値に対する符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sign of a floating-point value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある浮動小数点値の符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sign of the floating-point value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点値の符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sign of the new value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい値の符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sign of this number, expressed as an integer of the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この数の符号、同じ型の整数として表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sign to use for the new value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい値に対して使うための符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The significand is frequently also called the <bpt i="0" x="0">&lt;e0&gt;</bpt>mantissa<ept i="0">&lt;/e0&gt;</ept>, but significand is the preferred terminology in the <bpt i="1" x="1">&lt;a1&gt;</bpt>IEEE 754 specification<ept i="1">&lt;/a1&gt;</ept>, to allay confusion with the use of mantissa for the fractional part of a logarithm.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>仮数（significand）はしばしば<bpt i="0" x="0">&lt;e0&gt;</bpt>mantissa<ept i="0">&lt;/e0&gt;</ept>とも呼ばれます、しかし仮数が<bpt i="1" x="1">&lt;a1&gt;</bpt>IEEE 754仕様<ept i="1">&lt;/a1&gt;</ept>において推奨される用語です、対数の小数部分に対する仮数（mantissa）の使用との混同を静めるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The significand may include a decimal point.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>仮数は、小数点を含んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The significand of <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>y<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> is therefore 1.34375.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>y<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>の仮数はしたがって1.34375です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The significand of the floating-point value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点値の仮数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The single <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Bool<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> type in Swift guarantees that functions, methods, and properties imported from C and Objective-C have a consistent type interface.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift保証の単一<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Bool<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>型で、関数、メソッド、そしてプロパティがCおよびObjective-Cからインポートしたものは、首尾一貫した型インターフェイスを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The single-character string to convert to a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Character<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスへと変換される単一文字文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The size, in bytes, of the given value’s type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値の持つ型の、バイトでの、大きさ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The size, stride, and alignment of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type are accessible as static properties of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Memory<ph x="4">&lt;w4/&gt;</ph>Layout&lt;Point&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のサイズ、ストライド、そしてアライメントは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Memory<ph x="4">&lt;w4/&gt;</ph>Layout&lt;Point&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の静的プロパティとしてアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sorting algorithm is not stable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このソートアルゴリズムは、安定ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The square root of the value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値の平方根。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The standard library floating-point types—<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Double<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Float80<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> where available—all conform to the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Expressible<ph x="8">&lt;w8/&gt;</ph>By<ph x="9">&lt;w9/&gt;</ph>Float<ph x="10">&lt;w10/&gt;</ph>Literal<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリ浮動小数点型—<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Double<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、そして利用可能なところでは<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Float80<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>—は、すべて<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Expressible<ph x="8">&lt;w8/&gt;</ph>By<ph x="9">&lt;w9/&gt;</ph>Float<ph x="10">&lt;w10/&gt;</ph>Literal<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>プロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The standard library implements codecs for the UTF-8, UTF-16, and UTF-32 encoding schemes as the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>UTF8<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>UTF16<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>UTF32<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> types, respectively.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリは、UTF-8、UTF-16、そしてUTF-32エンコードスキームに対するコーデックを<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>UTF8<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>UTF16<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>、そして<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>UTF32<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>型としてそれぞれ実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The standard library integer and floating-point types are all valid types for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Integer<ph x="2">&lt;w2/&gt;</ph>Literal<ph x="3">&lt;w3/&gt;</ph>Type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリの整数および浮動小数点型は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Integer<ph x="2">&lt;w2/&gt;</ph>Literal<ph x="3">&lt;w3/&gt;</ph>Type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対する有効な型のすべてです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The standard library integer and floating-point types, such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Double<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, conform to the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Expressible<ph x="6">&lt;w6/&gt;</ph>By<ph x="7">&lt;w7/&gt;</ph>Integer<ph x="8">&lt;w8/&gt;</ph>Literal<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリの整数および浮動小数点型、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Double<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Expressible<ph x="6">&lt;w6/&gt;</ph>By<ph x="7">&lt;w7/&gt;</ph>Integer<ph x="8">&lt;w8/&gt;</ph>Literal<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The standard library provides an implementation for the not-equal-to operator (<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>!=<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>) for any <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Equatable<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type, which calls the custom <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>==<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> function and negates its result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリは、不等演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>!=<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）のある実装をあらゆる<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Equatable<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型に対して実装します、それはあつらえの<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>==<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>関数を呼び出してそれの結果の逆を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The start and end of a subrange must be valid indices of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位範囲の始まりと終わりは、配列の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The starting position for iterating members of the set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合のメンバを反復するための開始位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The static members <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>next<ph x="13">&lt;w13/&gt;</ph>Day<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>, <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>second<ph x="16">&lt;w16/&gt;</ph>Day<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>, <bpt i="17" x="17">&lt;c17&gt;</bpt><bpt i="18" x="18">&lt;s18&gt;</bpt>priority<ept i="18">&lt;/s18&gt;</ept><ept i="17">&lt;/c17&gt;</ept>, and <bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>standard<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept> are unique, individual options.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>静的メンバ<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>next<ph x="13">&lt;w13/&gt;</ph>Day<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>, <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>second<ph x="16">&lt;w16/&gt;</ph>Day<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>、<bpt i="17" x="17">&lt;c17&gt;</bpt><bpt i="18" x="18">&lt;s18&gt;</bpt>priority<ept i="18">&lt;/s18&gt;</ept><ept i="17">&lt;/c17&gt;</ept>、そして<bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>standard<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept>は特有で、別個のオプションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The static string must store a pointer to either ASCII or UTF-8 code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この静的文字列は、ASCIIまたはUTF-8コード単位どちらかへのポインタを格納しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The static string must store a single Unicode scalar value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この静的文字列は、単一のユニコードスカラー値を格納しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The static type of the subject being reflected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リフレクションされている主題の静的型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The stored <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Header<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>格納された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Header<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The stored Unicode scalar value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>格納されるユニコードスカラー値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The stride, in bytes, of the given value’s type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた値の持つ型の、バイトでの、ストライド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string is case insensitive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この文字列は、大文字小文字に影響されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string literal is broken into pieces.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列リテラルは断片へと分解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string of characters read from standard input.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準入力から読み込まれた一続きの文字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>text<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> can represent a real number in decimal or hexadecimal format or special floating-point values for infinity and NaN (“not a number”).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>text<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡される文字列は、10進または16進数形式における実数、または無限大とNaN（「非数」）に対する特別な浮動小数点値を表せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>text<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> may begin with a plus or minus sign character (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>+<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>-<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>), followed by one or more numeric digits (<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>0-9<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>) or letters (<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>a-z<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> or <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>A-Z<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>text<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡される文字列は、プラスまたはマイナス符号文字（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>+<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>-<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）で始まり、１つ以上の数値のアラビア数字（<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>0-9<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>）または文字（<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>a-z<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> or <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>A-Z<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>）が続くことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string referenced by both <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and the resulting index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と結果インデックスの両方によって参照される文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string referenced by both <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and the resulting index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と結果インデックスの両方によって参照される文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string referenced by both <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and the resulting index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と結果インデックスの両方によって参照される文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string to print after all items have been printed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての項目が出力された後に出力する文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string to print.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>出力するメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string to repeat.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>繰り返すことになる文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string to use for the index conversion.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インデックス変換に使う文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string to use in a named collection (e.g. a string-keyed dictionary).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列を名前付きコレクションで使います（例えば、名前キー付き辞書）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string value of the desired key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>望むキーの文字列値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string’s hash value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その文字列の持つハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string’s value represented as a collection of Unicode scalar values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードスカラー値のコレクションとして表される、文字列のもつ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The subrange of the array to replace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>置き換えられることになる配列の下位範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The subrange of the collection to replace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>置き換えることになるコレクションの下位範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The subscript notation is preferred over <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>prefix(through:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字表記法は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>prefix(through:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>よりも好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The subscript notation is preferred over <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>suffix(from:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字表記法は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>suffix(from:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>よりも好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The subscript notation is preferred over <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>prefix(up<ph x="5">&lt;w5/&gt;</ph>To:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字表記法は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>prefix(up<ph x="5">&lt;w5/&gt;</ph>To:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>よりも好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The subtraction operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) calculates the difference of its two arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>減算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、それの２つの引数の差を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sum of this value and <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の合計。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sum of types that can be used as a Quick Look representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「クイックルック」表現として使われることのできる型の総和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The tables below list the operators declared in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の表は、Swiftにおいて宣言される演算子を一覧にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The textual representation for each item is the same as that obtained by calling <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String(item)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各項目のテキスト表現は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String(item)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を呼び出すことで得られるものと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The textual representation for each item is the same as that obtained by calling <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>String(item)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各項目のテキスト表現は、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>String(item)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を呼び出すことで得られるものと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The textual representation for each item is the same as that obtained by calling <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>String(reflecting: item)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各項目のテキスト表現は、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>String(reflecting: item)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を呼び出すことで得られるものと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The textual representation for each item is the same as that obtained by calling <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>String(reflecting: item)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各項目のテキスト表現は、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>String(reflecting: item)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を呼び出すことで得られるものと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The the resulting instance may not have the same numeric value as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bit<ph x="2">&lt;w2/&gt;</ph>Pattern<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>—it is only guaranteed to use the same pattern of bits in its binary representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果のインスタンスは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bit<ph x="2">&lt;w2/&gt;</ph>Pattern<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と同じ数値を持たないでしょう — それは、同じパターンのビットをそれのバイナリ表現において使うことを保証されるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The total number of elements that the array can contain without allocating new storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その配列が新しいストレージを割り当てることなく含むことができる要素の総数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The total number of elements that the set can contain without allocating new storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その集合が新しいストレージを割り当てることなく含むことができる要素の総数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The total number of key-value pairs that the dictionary can contain without allocating new storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その辞書が新しいストレージをアロケートすることなく含むことが可能なキー値ペアの総数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The traversal protocol modeled by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>children<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>’s indices (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Forward<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Bidirectional<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, or <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Random<ph x="10">&lt;w10/&gt;</ph>Access<ph x="11">&lt;w11/&gt;</ph>Index<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>) is captured so that the resulting <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Mirror<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>’s <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>children<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> may be upgraded later.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>children<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインデックス（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Forward<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Bidirectional<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>、または<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Random<ph x="10">&lt;w10/&gt;</ph>Access<ph x="11">&lt;w11/&gt;</ph>Index<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>）によってモデルにされるトラバーサルプロトコルは、結果として生じる<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Mirror<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>の<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>children<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>が後でアップグレードできるようにキャプチャされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The two arguments must have the same <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの引数は、同じ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The two loops in the following example produce the same output:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例における２つのループは、同じ出力を生み出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be the same size and be layout compatible with the pointer’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型 <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、ポインタのもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型と同じサイズで、互換性のあるレイアウトでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that the memory has already been bound to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリがすでに束縛されているところの型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to be stored must be a trivial type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>格納されることになる型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、自明型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to bind the memory to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>へとメモリを束縛することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type aliased by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Boolean<ph x="2">&lt;w2/&gt;</ph>Literal<ph x="3">&lt;w3/&gt;</ph>Type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must conform to the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Expressible<ph x="6">&lt;w6/&gt;</ph>By<ph x="7">&lt;w7/&gt;</ph>Boolean<ph x="8">&lt;w8/&gt;</ph>Literal<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Boolean<ph x="2">&lt;w2/&gt;</ph>Literal<ph x="3">&lt;w3/&gt;</ph>Type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によってエイリアス（別名）を付けられる型は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Expressible<ph x="6">&lt;w6/&gt;</ph>By<ph x="7">&lt;w7/&gt;</ph>Boolean<ph x="8">&lt;w8/&gt;</ph>Literal<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of data that a pointer can access is the pointer’s <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Pointee<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインタがアクセス可能なデータの型は、ポインタのもつ<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Pointee<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of data that a pointer can access is the pointer’s <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインタがアクセス可能なデータの型は、ポインタのもつ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of element returned by <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によって返される要素のもつ型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of element traversed by the iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイテレータによって辿っていかれる要素の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of the elements of an array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列リテラルの要素の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of the instance to create.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>作成されることになるインスタンスの型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of the underlying collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基礎をなすコレクションの型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of value to decode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型の値にデコードする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type to bind this memory to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメモリに束縛することになる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type to cast <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をこれにキャストすることになる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type to decode as.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型としてデコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type to temporarily bind the memory referenced by this pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタによって参照されるメモリを一時的に束縛する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type to use for the newly constructed instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新規に構築されるインスタンスのために使うことになる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type used to represent sub-structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位構造体を再表現するために使われる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The typed buffer to convert to a raw buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいバッファへと変換されることになる型付バッファ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The typed pointer to convert.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変換されることになる型付ポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The types of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>short<ph x="2">&lt;w2/&gt;</ph>Form<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>long<ph x="5">&lt;w5/&gt;</ph>Form<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> in the following code sample are the same:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のコード例における<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>short<ph x="2">&lt;w2/&gt;</ph>Form<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>long<ph x="5">&lt;w5/&gt;</ph>Form<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の型は、同じです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The types of the two underlying indices must be identical.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの基礎をなすインデックスの型は同一でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The unary minus operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単項マイナス演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The unary minus operator (prefix <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) calculates the negation of its operand.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単項マイナス演算子（前置<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）は、それの演算数の否定を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The underlying collection of the slice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このスライスの基礎をなすコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The underlying collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基礎をなすコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The underlying iterator whose elements are being filtered.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基礎をなすイテレータ、それの要素がフィルタされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The underlying sequence whose elements are being filtered</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基盤となるシーケンス、それの要素がフィルタされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The unit in the last place of 1.0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>1.0の最終桁単位。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The unit in the last place of this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値のの最終桁単位。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The upper and lower bounds of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bounds<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be valid indices of the string and not equal to the string’s end index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bounds<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>範囲の上方および下方の境界はこの文字列の有効なインデックスでなければなりません、そしてこの文字列の持つ末尾インデックスと等しくてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The upper and lower bounds of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bounds<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be valid indices of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bounds<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の上方および下方の境界は、文字列の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The upper and lower bounds of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bounds<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> range must be valid indices of the collection and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>bounds<ph x="4">&lt;w4/&gt;</ph>.upper<ph x="5">&lt;w5/&gt;</ph>Bound<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be less than the collection’s end index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bounds<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>範囲の上方および下方の境界はこのコレクションの有効なインデックスでなければなりません、そして<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>bounds<ph x="4">&lt;w4/&gt;</ph>.upper<ph x="5">&lt;w5/&gt;</ph>Bound<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>はこのコレクションの末尾インデックスより少なくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The upper and lower bounds of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bounds<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> range must be valid indices of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bounds<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>範囲の上方および下方の境界は、このコレクションの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The upper and lower bounds of the range must be in the range <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>0...count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この範囲の上方および下方の境界は、範囲<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>0...count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The upper bound for the range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲の上側の境界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>32<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is the UTF-16 encoded value of a space character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>32<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、空白文字のUTF-16エンコード値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value associated with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>key<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>key<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is in the dictionary; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>key<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と結び付けられた値、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>key<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が辞書の中にあるならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value associated with the given key may be a null value as appropriate for the data format.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたキーと結び付けられる値は、そのデータ形式に適切であるnull値であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Length<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max<ph x="2">&lt;w2/&gt;</ph>Length<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の値は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is represented exactly by the new instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の値は、新しいインスタンスによって正確に表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is rounded to a representable value, if necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の値は、必要ならば、表現可能な値へと丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> converted to type <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>U<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>U<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に変換された<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>significand<ph x="10">&lt;w10/&gt;</ph>Width<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> is always -1 or between zero and <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>significand<ph x="13">&lt;w13/&gt;</ph>Bit<ph x="14">&lt;w14/&gt;</ph>Count<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>significand<ph x="10">&lt;w10/&gt;</ph>Width<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>の値は、常に-1、もしくはゼロと<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>significand<ph x="13">&lt;w13/&gt;</ph>Bit<ph x="14">&lt;w14/&gt;</ph>Count<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>の間です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of every element in this collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコレクションのすべての要素の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>member<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter if it was a member of the set; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>member<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータの値、それが集合のメンバであったならば；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>nil<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of the key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーの値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of the new instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいインスタンスのための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bit<ph x="2">&lt;w2/&gt;</ph>Pattern<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is interpreted in the binary interchange format defined by the <bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754 specification<ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bit<ph x="2">&lt;w2/&gt;</ph>Pattern<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡される値は、<bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754仕様<ept i="3">&lt;/a3&gt;</ept>で定義されるバイナリ交換フォーマットにおいて解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must not offset <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> beyond the bounds of the collection, unless the index passed as <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>limit<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> prevents offsetting beyond those bounds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡される値は、このコレクションの境界を越えて<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を補ってはなりません、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>limit<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>として渡されるインデックスがそれらの境界を越えて補うのを防止するのでない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must not offset <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> beyond the bounds of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>n<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡される値は、このコレクションの境界を越えて<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>i<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を補ってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value that was removed, or <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the key was not present in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>削除された値、またはキーがこの辞書の中に存在しなかったならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value that was replaced, or <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if a new key-value pair was added.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>取って代わられた値、または新しいキー値ペアが加えられたならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to add to this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値に加える値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to compare with this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と比較するための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to create.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>作成されることになる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to divide <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> by.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値で<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を除算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to divide this value by.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値を除算するための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to divide.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>除算することになる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to encode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エンコードする値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to find the dynamic type of.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値の動的型を見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to multiply by this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値と掛け合わせられることになる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to negate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>負にする値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to shift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シフトする値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to store as raw bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生のメモリとして格納されることになる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to subtract from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から減じる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to subtract from this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値から減じる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to use as the initial accumulating value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初めから蓄積される値として使われる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to use for the new instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいインスタンスのために使う値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value to use when dividing this value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値を除算するときに使うための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value type of a dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書リテラルの値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value wrapped by this instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスによってラップされる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The values passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>exponent<ph x="2">&lt;w2/&gt;</ph>Bit<ph x="3">&lt;w3/&gt;</ph>Pattern<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>significand<ph x="6">&lt;w6/&gt;</ph>Bit<ph x="7">&lt;w7/&gt;</ph>Pattern<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> are interpreted in the binary interchange format defined by the <bpt i="8" x="8">&lt;a8&gt;</bpt>IEEE 754 specification<ept i="8">&lt;/a8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>exponent<ph x="2">&lt;w2/&gt;</ph>Bit<ph x="3">&lt;w3/&gt;</ph>Pattern<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>significand<ph x="6">&lt;w6/&gt;</ph>Bit<ph x="7">&lt;w7/&gt;</ph>Pattern<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に渡される値は、<bpt i="8" x="8">&lt;a8&gt;</bpt>IEEE 754 specification<ept i="8">&lt;/a8&gt;</ept>で定義されるバイナリ交換フォーマットにおいて解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The view to use for the index conversion.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インデックス変換に使うビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The way these code points are grouped is defined by a canonical, localized, or otherwise tailored Unicode segmentation algorithm.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのコード点が一群にされる方法は、ある正準の、ローカライズされた、ないしは別の方法で仕立てられたユニコード分節アルゴリズムによって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The wrapped value of this instance, unwrapped without checking whether the instance is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスのラップされた値、そのインスタンスが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>かどうか確認せずにアンラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The “past the end” index of the resulting subsequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果のシーケンスの「終わりを過ぎた」インデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The “past the end” position for the set—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合に対する「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The “past the end” position—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are some edge cases to be aware of:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>知られているいくつかの境界事例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is no guarantee that <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is an element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がこのシーケンスの要素であることは保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is no notion of identity for structs, enums, functions, or tuples.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体、列挙、関数、またはタプルに対して識別の観念はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There may be smaller positive numbers, but they are <bpt i="0" x="0">&lt;e0&gt;</bpt>subnormal<ept i="0">&lt;/e0&gt;</ept>, meaning that they are represented with less precision than normal numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より小さい正の数があるでしょう、しかしそれらは<bpt i="0" x="0">&lt;e0&gt;</bpt>サブノーマル<ept i="0">&lt;/e0&gt;</ept>であり、それらがノーマル数よりより少ない精密さで表現されることを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>x<ph x="12">&lt;w12/&gt;</ph>.binade<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> is equal to <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>1<ph x="15">&lt;w15/&gt;</ph>.0 * 2**4<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>, or <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>16<ph x="18">&lt;w18/&gt;</ph>.0<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それゆえに、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>x<ph x="12">&lt;w12/&gt;</ph>.binade<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>は<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>1<ph x="15">&lt;w15/&gt;</ph>.0 * 2**4<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>、または<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>16<ph x="18">&lt;w18/&gt;</ph>.0<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Closed<ph x="3">&lt;w3/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance cannot represent an empty range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それゆえに、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Closed<ph x="3">&lt;w3/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは空の範囲として表すことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, the first in any sequence of mutating operations may cost O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>) time and space.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それゆえに、何らかの一連の変化を伴う演算において最初に、O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)時間と空間を要するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, the fundamental difference between random-access and bidirectional collections is that operations that depend on index movement or distance measurement offer significantly improved efficiency.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それゆえに、無作為アクセスと二方向性のコレクションの根本的な違いは、インデックス移動や間隔測定に依存する演算が、著しく改善される効率を提示することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, you must only call this function from mutating methods with appropriate thread synchronization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、あなたはこの関数を可変メソッドから適切なスレッド同期で呼ぶだけにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These code points are combined by Unicode’s boundary algorithms into <bpt i="0" x="0">&lt;e0&gt;</bpt>extended grapheme clusters<ept i="0">&lt;/e0&gt;</ept>, represented by the <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Character<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのコード点は、ユニコード境界アルゴリズムによって<bpt i="0" x="0">&lt;e0&gt;</bpt>拡張書記素クラスタ<ept i="0">&lt;/e0&gt;</ept>へと、<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Character<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>型によって表されるものへと、組み合わされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These code points are combined by Unicode’s boundary algorithms into extended grapheme clusters, represented by Swift’s <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Character<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのコード点は、ユニコード境界アルゴリズムによって拡張書記素クラスタへと、Swiftのもつ<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>Character<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>型によって表されるものへと、組み合わされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These code points are combined by Unicode’s boundary algorithms into extended grapheme clusters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのコード点は、ユニコードの境界アルゴリズムによって拡張書記素クラスタへと組み合わされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These collections can store zero, one, or many of the same element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのコレクションは、ゼロ、１つ、または多くの同じ要素を格納できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These counters can only be used as indices in instances of zero-based, integer-indexed collections, such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Contiguous<ph x="4">&lt;w4/&gt;</ph>Array<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのカウンタはインデックスとして使われることが、ゼロ基盤の、整数インデックスのコレクション、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>そして<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Contiguous<ph x="4">&lt;w4/&gt;</ph>Array<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>などのインスタンスにおいてのみ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These elements are computed lazily, each time they’re read, by calling the transform function on a base element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの要素は、それらが読み出されるたびに、基盤要素上で変換関数を呼び出すことによって遅延計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These initializers create an integer with the bit pattern of the memory address of a pointer or class instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのイニシャライザは、あるポインタまたはクラスインスタンスのメモリアドレスのビットパターンで整数を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These initializers result in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the value passed can't be represented without any loss of precision.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのイニシャライザは、渡された値が何ら精度の損失なしに表現できないならば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These methods all return typed pointers for further typed access to the memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのメソッドは、この後で型付アクセスをこのメモリにするために型付ポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These methods perform arithmetic operations without performing bounds checks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのメソッドは、算術演算を境界検査を行うことなく実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These methods return the result of an operation, and a flag indicating whether the operation overflowed the bounds of the type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのメソッドは演算の結果、そしてその演算がその型の境界をオーバーフローしたかどうかを示すフラグを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These pointers are valid only for the duration of the call to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのポインタは、ただ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への呼び出しの間にのみ有効とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These two operations impose a strict total order on the values of a type, in which exactly one of the following must be true for any two values <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>a<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>b<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これら２つの演算子は、ある型の値に全順序を課します、そこにおいて任意の２つの値<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>a<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>b<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に対して、厳密に以下のうちの１つが真でなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This <bpt i="0" x="0">&lt;e0&gt;</bpt>key-based<ept i="0">&lt;/e0&gt;</ept> subscript returns the value for the given key if the key is found in the dictionary, or <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>nil<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> if the key is not found.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;e0&gt;</bpt>キー基盤<ept i="0">&lt;/e0&gt;</ept>の添え字は、そのキーが辞書において見つけられるならば指定されたキーに対する値を、またはキーが見つからないならば<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>nil<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This assignment to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ph x="2">&lt;w2/&gt;</ph>Stop<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant calls this string literal initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next<ph x="2">&lt;w2/&gt;</ph>Stop<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数への代入はこの文字列リテラルイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This associated type appears as a requirement in the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, but it is restated here with stricter constraints.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関連型は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルの中のある要件として現れます、しかしここでより厳格な制約で言い直されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This avoids over-allocation, but can result in insertion not having amortized constant-time performance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは過度のアロケーションを防ぎます、しかし挿入においてならし定数時間性能を持たない結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This buffer can then be shared by different copies of a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このバッファは、それからある文字列の異なるコピーによって共有されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This capability can be especially important when the order of elements in the literal is significant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この能力は、そのリテラル中の要素の順序が意味を持つ場合に特に重要となりえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This contrasts with <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Array<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, which can store its elements in either a contiguous region of memory or an <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>NSArray<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance if its <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Element<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> type is a class or <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>@objc<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Array<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>とは対照的です、それはそれの要素をメモリの隣接領域かもしくは、それの<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Element<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>型がクラスまたは<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>@objc<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>プロトコルならば<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>NSArray<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>インスタンスのどちらかに格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This documentation contains preliminary information about an API or technology in development.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This ensures that string comparisons and other operations always have a single, stable result, allowing strings to be used as keys in <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances and for other purposes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは文字列比較および他の演算が常にある単一の、安定した結果を持つことを保証して、文字列が<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスにおけるキーとしておよび他の目的のために使われることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example allocates untyped, uninitialized memory with space for four instances of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Point<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、型無しの、未初期化メモリを<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Point<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の４つのインスタンス用の空間でアロケートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example appends the elements of a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance to an array of integers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスに属する複数要素を整数からなるある配列に追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example appends the elements of a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Range&lt;Int&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance to an array of integers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはある<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Range&lt;Int&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスに属する複数要素を整数からなる配列に追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example below uses the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>with<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Characters(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to truncate the string <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>str<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> at the first space and to return the remainder of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>with<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Characters(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って最初の空白で文字列<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>str<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を切り取って、残りの文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example checks to see whether a favorite actor is in an array storing a movie’s cast.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、お気に入りの俳優が映画出演者を格納する配列の中にいるかどうか見るために調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example checks to see whether a particular insect is in an array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある特定の昆虫が配列の中にあるかどうか見るために調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example creates a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Closed<ph x="6">&lt;w6/&gt;</ph>Range&lt;Character&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> from “a” up to, and including, “z”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、「a」から「z」までの、そしてそれを含む<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Closed<ph x="6">&lt;w6/&gt;</ph>Range&lt;Character&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example creates a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Partial<ph x="6">&lt;w6/&gt;</ph>Range<ph x="7">&lt;w7/&gt;</ph>From&lt;Double&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance that includes any value greater than or equal to <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>5<ph x="10">&lt;w10/&gt;</ph>.0<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Partial<ph x="6">&lt;w6/&gt;</ph>Range<ph x="7">&lt;w7/&gt;</ph>From&lt;Double&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスで<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>5<ph x="10">&lt;w10/&gt;</ph>.0<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>より大きいか等しい何らかの値を含むものを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example creates a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Partial<ph x="6">&lt;w6/&gt;</ph>Range<ph x="7">&lt;w7/&gt;</ph>Through&lt;Double&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance that includes any value less than or equal to <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>5<ph x="10">&lt;w10/&gt;</ph>.0<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Partial<ph x="6">&lt;w6/&gt;</ph>Range<ph x="7">&lt;w7/&gt;</ph>Through&lt;Double&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスで<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>5<ph x="10">&lt;w10/&gt;</ph>.0<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>より少ないか等しい何らかの値を含むものを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example creates a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Partial<ph x="6">&lt;w6/&gt;</ph>Range<ph x="7">&lt;w7/&gt;</ph>Up<ph x="8">&lt;w8/&gt;</ph>To&lt;Double&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance that includes any value less than <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>5<ph x="11">&lt;w11/&gt;</ph>.0<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Partial<ph x="6">&lt;w6/&gt;</ph>Range<ph x="7">&lt;w7/&gt;</ph>Up<ph x="8">&lt;w8/&gt;</ph>To&lt;Double&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスで<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>5<ph x="11">&lt;w11/&gt;</ph>.0<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>より少ない何らかの値を含むものを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example creates a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Range&lt;Double&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> from zero up to, but not including, 5.0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ゼロから5.0までの、しかしそれを含めない<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Range&lt;Double&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example creates a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Countable<ph x="8">&lt;w8/&gt;</ph>Closed<ph x="9">&lt;w9/&gt;</ph>Range&lt;Int&gt;<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> from zero up to, and including, nine.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ゼロから９までの、そしてそれを含む<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Countable<ph x="8">&lt;w8/&gt;</ph>Closed<ph x="9">&lt;w9/&gt;</ph>Range&lt;Int&gt;<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example creates a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Countable<ph x="8">&lt;w8/&gt;</ph>Partial<ph x="9">&lt;w9/&gt;</ph>Range<ph x="10">&lt;w10/&gt;</ph>From&lt;Int&gt;<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instance that includes any value greater than or equal to <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>5<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Countable<ph x="8">&lt;w8/&gt;</ph>Partial<ph x="9">&lt;w9/&gt;</ph>Range<ph x="10">&lt;w10/&gt;</ph>From&lt;Int&gt;<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスで、<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>5<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>より大きいか等しい何らかの値を含むものを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example creates a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Countable<ph x="8">&lt;w8/&gt;</ph>Range&lt;Int&gt;<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> from zero up to, but not including, 5.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ゼロから5.0までの、しかしそれを含めない<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Countable<ph x="8">&lt;w8/&gt;</ph>Range&lt;Int&gt;<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example creates an instance of <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Shipping<ph x="5">&lt;w5/&gt;</ph>Options<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> with a raw value beyond the highest element, with a bit mask that effectively contains all the declared static members.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Shipping<ph x="5">&lt;w5/&gt;</ph>Options<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>のインスタンスを最も高い要素を越える生の値で、全ての宣言済み静的メンバを実質的に含むあるビットマスクで、作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example declares a constant with three currently allowed moves.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は３つの現在許される動きを持つある定数を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example declares the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>number<ph x="2">&lt;w2/&gt;</ph>Of<ph x="3">&lt;w3/&gt;</ph>Cookies<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant, using an integer literal to express its value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>number<ph x="2">&lt;w2/&gt;</ph>Of<ph x="3">&lt;w3/&gt;</ph>Cookies<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数を宣言します、整数リテラルをそれの値を表すために使っています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>raw<ph x="2">&lt;w2/&gt;</ph>Data<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> string with some unstructured data, and then uses the string’s <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>prefix(while:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method to create a substring of the numeric prefix:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>raw<ph x="2">&lt;w2/&gt;</ph>Data<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>文字列を何らかの構造化されていないデータで定義します、それからその文字列のもつ<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>prefix(while:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドを使うことで数字接頭辞からなる下位文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Integer<ph x="2">&lt;w2/&gt;</ph>Ref<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type with an <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>@objc<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method named <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>get<ph x="7">&lt;w7/&gt;</ph>Integer<ph x="8">&lt;w8/&gt;</ph>Value()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Integer<ph x="2">&lt;w2/&gt;</ph>Ref<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型を、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>@objc<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドで<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>get<ph x="7">&lt;w7/&gt;</ph>Integer<ph x="8">&lt;w8/&gt;</ph>Value()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>と名付けられるものと共に定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は文字列からなる配列のあるスライスの取得を実演します、スライスの中の文字列の１つのインデックスを見つけて、それからそのインデックスを元の配列において使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example demonstrates that the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>characters<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある文字列の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>characters<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューが、そのビューのインデックスであろうとビューそれ自体が反復されていようと同じ文字を同じ順序で返すのを実演します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example enumerates the characters of the string “Swift” and prints each character along with its place in the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は文字列「Swift」の文字を列挙します、そして各文字をその文字列でのそれの場所とともに出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example finds the largest value in an array of height measurements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、身長計測の配列の中で最も大きな値を見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example finds the smallest value in an array of height measurements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、身長計測の配列の中で最も小さな値を見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example first finds the position of a space (UTF-16 code point <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) in a string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view and then uses this method find the same position in the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある空白（UTF-16コード点<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の位置を文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューの中で見つけて、それからこのメソッドを使って文字列における同じ位置を探します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example first finds the position of a space (UTF-16 code point <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) in a string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view and then uses this method to find the same position in the string’s <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>unicode<ph x="6">&lt;w6/&gt;</ph>Scalars<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある空白（UTF-16コード点<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の位置を文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューの中で見つけて、それからこのメソッドを使って文字列のもつ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>unicode<ph x="6">&lt;w6/&gt;</ph>Scalars<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ビューにおける同じ位置を捜します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example first finds the position of a space (UTF-16 code point <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) in a string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view and then uses this method to find the same position in the string’s <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>utf8<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある空白（UTF-16コード点<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の位置を文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューの中で見つけて、それからこのメソッドを使って文字列のもつ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>utf8<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ビューにおける同じ位置を捜します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example first finds the position of a space (UTF-8 code point <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) in a string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view and then uses this method find the same position in the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある空白（UTF-8コード点<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の位置を文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューの中で見つけて、それからこのメソッドを使って文字列における同じ位置を捜します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example first finds the position of a space (UTF-8 code point <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) in a string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view and then uses this method to find the same position in the string’s <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>unicode<ph x="6">&lt;w6/&gt;</ph>Scalars<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある空白（UTF-8コード点<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の位置を文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューの中で見つけて、それからこのメソッドを使って文字列のもつ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>unicode<ph x="6">&lt;w6/&gt;</ph>Scalars<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ビューにおける同じ位置を捜します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example first finds the position of a space (UTF-8 code point <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) in a string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view and then uses this method to find the same position in the string’s <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>utf16<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある空白（UTF-8コード点<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>32<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の位置を文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューの中で見つけて、それからこのメソッドを使って文字列のもつ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>utf16<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>ビューにおける同じ位置を捜します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example first finds the position of the character <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"é"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and then uses this method find the same position in the string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>unicode<ph x="4">&lt;w4/&gt;</ph>Scalars<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、最初に文字<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"é"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の位置を見つけて、それからこのメソッドを使って文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>unicode<ph x="4">&lt;w4/&gt;</ph>Scalars<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューにおける同じ位置を捜します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example first finds the position of the character <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"é"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and then uses this method find the same position in the string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、最初に文字<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"é"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の位置を見つけて、それからこのメソッドを使って文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf16<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューにおける同じ位置を捜します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example first finds the position of the character <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"é"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and then uses this method find the same position in the string’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、最初に文字<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"é"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の位置を見つけて、それからこのメソッドを使って文字列のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>utf8<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ビューにおける同じ位置を捜します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example iterates over the indices and elements of a set, building a list of indices of names with five or fewer letters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある集合のインデックスと要素のすべてにわたって反復します、５つまたはより少ない文字を持つ名前のインデックスのリストを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example passes <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>int<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, a pointer to an <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Int<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> value, to <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>print(address:)<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>int<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Int<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>値へのポインタを<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>print(address:)<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>に渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example passes <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>raw<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> as the initial parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>raw<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>を最初のパラメータとして渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example passes <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>int<ph x="10">&lt;w10/&gt;</ph>Pointer<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>, a mutable pointer to an <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Int<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> value, to <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>print(address:)<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>int<ph x="10">&lt;w10/&gt;</ph>Pointer<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>、<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Int<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>値への可変ポインタを<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>print(address:)<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>に渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example passes <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>raw<ph x="10">&lt;w10/&gt;</ph>Pointer<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> as the initial parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>raw<ph x="10">&lt;w10/&gt;</ph>Pointer<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を最初のパラメータとして渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example performs an arithmetic operation on an optional integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、算術演算をあるオプショナル整数上で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example performs an arithmetic operation with an optional result on an optional integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、オプショナル結果をもつ算術演算をあるオプショナル整数上で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example prints the characters of a string in reverse order:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある文字列に属する文字を逆順で出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example prints the elements of an array in reverse order:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある配列に属する要素を逆順で出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example removes the element <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"sugar"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> from a set of ingredients.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、要素<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>"sugar"<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を一揃いの材料から削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example removes the hyphen from the middle of a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある文字列の真ん中からハイフンを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example removes the middle element from an array of measurements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、測定結果からなる配列から真ん中の要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example removes two elements from the middle of an array of measurements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、測定結果からなる配列の真ん中から２つの要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example shows how a <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Collection<ph x="14">&lt;w14/&gt;</ph>Of<ph x="15">&lt;w15/&gt;</ph>Two<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> instance can be created holding the values of a point, and then iterated over using a <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>for<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>-<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>in<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、どのように<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Collection<ph x="14">&lt;w14/&gt;</ph>Of<ph x="15">&lt;w15/&gt;</ph>Two<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>インスタンスがある地点の値を保持して作成されるか、そしてそれから<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>for<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>-<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>in<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>ループを使って全体にわたって繰り返されるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example shows how an array of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>[Int]<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances can be joined, using another <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>[Int]<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance as the separator:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、どのようにいくつかのの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>[Int]<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスからなる配列が別の<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>[Int]<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスをセパレータとしてつなぎ合わされるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example shows how an iterator can be used explicitly to emulate a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、イテレータが明示的に使われて<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ループの機能を真似る方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example shows how to choose the current or new values for any duplicate keys:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、あらゆる重複キーに対して現在および新規の値を選択する方法を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example shows how to find the sum of an array of numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、どのように数からなる配列の合計を見出すかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example shows how to use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max(by:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method on a dictionary to find the key-value pair with the highest value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max(by:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを辞書上で使って、最も高い値を持つキー値ペアを見つける方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example shows how to use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>min(by:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method on a dictionary to find the key-value pair with the lowest value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>min(by:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを辞書上で使って、最も低い値を持つキー値ペアを見つける方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example shows how you can check an array for an expense greater than $100.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、どのようにあなたが$100より大きい出費についてある配列を調べるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example shows how you can modify one of the names in an array of students.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例が示すのは、どうやってあなたが学生らの配列の中の名前の１つを修正できるかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example shows several extending conversions of a negative value—note that negative values are sign-extended even when converting to an unsigned type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある負の値のいくつかの拡張変換を示します — 符号なし型へ変換する時でさえ、負の値が符号拡張されることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example shows two overlapping ranges:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は２つの重なった範囲を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example tests whether one countable range begins with the elements of another countable range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある可付番範囲が別の可付番範囲の要素で始まるかどうかテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example tests whether one countable range shares the same elements as another countable range and an array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある可付番範囲が同じ要素を別の可付番範囲とそしてある配列と共有するかどうかをテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example uses implicit bridging to pass a pointer to the elements of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> when calling <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>print(address:<ph x="4">&lt;w4/&gt;</ph>as:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>print(address:<ph x="4">&lt;w4/&gt;</ph>as:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を呼び出すとき、暗黙的ブリッジを使ってポインタを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素へと渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example uses implicit bridging to pass a pointer to the elements of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> when calling <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>print<ph x="4">&lt;w4/&gt;</ph>Int(at<ph x="5">&lt;w5/&gt;</ph>Address:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、暗黙的ブリッジを使ってポインタを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素へと、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>print<ph x="4">&lt;w4/&gt;</ph>Int(at<ph x="5">&lt;w5/&gt;</ph>Address:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を呼び出す時に渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>contains(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to test whether an integer is a member of a set of prime numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>contains(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使ってある整数がある一揃いの素数のメンバであるかどうかをテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lexicographically<ph x="2">&lt;w2/&gt;</ph>Precedes<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to test which array of integers comes first in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lexicographically<ph x="2">&lt;w2/&gt;</ph>Precedes<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、どの整数配列がある語彙筆記的順序において最初に来るかをテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>negate()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to negate the value of the variable <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>negate()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、変数<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>x<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の値を負にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example uses the conditional downcast operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>as?<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to conditionally cast the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>s<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> constant declared above to an instance of Swift’s <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、条件ダウンキャスト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>as?<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って、上で定義される<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>s<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>定数をSwiftの<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型へ条件付きでキャストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This exponential growth strategy means that appending an element happens in constant time, averaging the performance of many append operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この指数成長戦略は、ある要素を加えることは、多くの追加操作の遂行を平均すると、定数時間に起こることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function can be used to replace many cases that were previously handled using C-style <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> loops.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、C形式の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ループを使用して前もって取り扱われたケースの多くを置き換えるのに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function can be used to replace many instances of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Iterator<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that wrap a closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、クロージャをラップする<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Iterator<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の多くのインスタンスを置き換えるのに使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function does <bpt i="0" x="0">&lt;e0&gt;</bpt>not<ept i="0">&lt;/e0&gt;</ept> modify <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>object<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>; the use of <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>inout<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is an implementation artifact.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>object<ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を修正<bpt i="0" x="0">&lt;e0&gt;</bpt>しません<ept i="0">&lt;/e0&gt;</ept>；<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>inout<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の使用は、技巧上の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function is the only requirement of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルのただ１つの要件です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function throws an error if any values are invalid for the given encoder’s format.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、何らかの値が与えられたエンコーダの形式に対して無効であるならばエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function uses the least specific nonmatching property of the date to determine the result of the comparison.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、比較の結果を判定するのに、最小量となる特定の不一致日付プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function’s effects vary depending on the build flag used:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数の効果は使用されるビルドフラグに依存して多様に異なります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This guarantees the safety of operations that depend on a sequence being finite, such as checking to see whether a collection contains an element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、有限であるシーケンスに基づいた演算の安全性を保証します、例えばコレクションがある要素を含むかどうか見るために検査するなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This index must be a valid index of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(unicode<ph x="2">&lt;w2/&gt;</ph>Scalars).utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(unicode<ph x="2">&lt;w2/&gt;</ph>Scalars).utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This index must be a valid index of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(unicode<ph x="2">&lt;w2/&gt;</ph>Scalars).utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String(unicode<ph x="2">&lt;w2/&gt;</ph>Scalars).utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This index must be a valid index of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>characters<ph x="2">&lt;w2/&gt;</ph>.unicode<ph x="3">&lt;w3/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>characters<ph x="2">&lt;w2/&gt;</ph>.unicode<ph x="3">&lt;w3/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This index must be a valid index of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>characters<ph x="2">&lt;w2/&gt;</ph>.utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインデックスは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>characters<ph x="2">&lt;w2/&gt;</ph>.utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer always succeeds, even if the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>raw<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> exceeds the static properties declared as part of the option set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは常に成功します、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>raw<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡される値がオプションセットの部分として宣言される静的プロパティを上回るとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer can also be used to restore set methods after performing sequence operations such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>filter(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>map(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> on a set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザはまた、シーケンス演算、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>filter(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>map(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>などをある集合上で実行した後で集合に戻す手法として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer creates a new pointer to the same address as <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>other<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> and performs no allocation or copying.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、新しいポインタを<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>other<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>と同じアドレスに作成して、割り当てやコピーを実行することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer creates a new pointer to the same address as <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>other<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> and performs no allocation or copying.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、新しいポインタを<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>other<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>と同じアドレスに作成して、割り当てやコピーを実行することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer does not perform any range or overflow checking.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、全く範囲またはオーバーフロー検査を実行しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer does not try to repair ill-formed UTF-8 code unit sequences.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、誤形式UTF-8コード単位シーケンスの修復を試みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer implements the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>scale<ph x="2">&lt;w2/&gt;</ph>B<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operation defined by the <bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754 specification<ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、<bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754仕様<ept i="3">&lt;/a3&gt;</ept>で定義される<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>scale<ph x="2">&lt;w2/&gt;</ph>B<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer implements the IEEE 754 <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>copysign<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、IEEE 754 <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>copysign<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer is case sensitive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、大文字小文字を区別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer is equivalent to initializing with an empty array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは空の配列リテラルで初期化するのと等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer is equivalent to the following calculation, where <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>**<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is exponentiation, computed as if by a single, correctly rounded, floating-point operation:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは次の計算に相当し、そこで<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>**<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は乗算で、まるで単精度の、正しく丸められた、浮動小数点演算のように計算されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer is especially useful for the mirrors of collections, e.g.:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、特にコレクションのミラーに対して有用です、例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer is failable because although every case of the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Counter<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> type has a corresponding <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Int<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> value, there are many <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Int<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> values that <bpt i="14" x="14">&lt;e14&gt;</bpt>don’t<ept i="14">&lt;/e14&gt;</ept> correspond to a case of <bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>Counter<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは失敗可能です、なぜならすべての<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Counter<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>型のケース節は対応する<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Int<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>値を持つけれども、<bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>Counter<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>のケース節に対応<bpt i="14" x="14">&lt;e14&gt;</bpt>しない<ept i="14">&lt;/e14&gt;</ept>多くの<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Int<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>値が存在するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、デコーダからの読み出しが失敗するならば、または読み込んだデータが不正またはそうでなくとも無効ならば、エラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is almost certainly not what you want.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはほとんど疑いなくあなたが望むことではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is an unexpected result for those accustomed to zero-based collection indices, who might expect the result to be <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>-99<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはゼロベースのコレクションに慣れている人たちにとって思いもよらない結果です、彼らは<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>-99<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>になる結果を予想するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is equivalent to initializing with an empty array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは空の配列リテラルで初期化するのに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is equivalent to the inverse of a set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはある集合の逆と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is identical to init(cString: UnsafePointer&lt;CChar&gt; but operates on an unsigned sequence of bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、init(cString: UnsafePointer&lt;CChar&gt;と同一です、しかし符号なしバイトシーケンス上で作動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is inherently unsafe; UnsafeMutablePointer assumes the referenced memory has +1 strong ownership semantics, whereas AutoreleasingUnsafeMutablePointer implies +0 semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、本質的に安全ではありません；UnsafeMutablePointerは参照されるメモリが+1の強力な所有権意味論を持つことを仮定します、そういうわけでAutoreleasingUnsafeMutablePointerは必然的に+0意味論です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Iterator<ph x="2">&lt;w2/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> used by <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Flatten<ph x="5">&lt;w5/&gt;</ph>Sequence<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Flatten<ph x="8">&lt;w8/&gt;</ph>Collection<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, and <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Bidirectional<ph x="11">&lt;w11/&gt;</ph>Flatten<ph x="12">&lt;w12/&gt;</ph>Collection<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Flatten<ph x="5">&lt;w5/&gt;</ph>Sequence<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Flatten<ph x="8">&lt;w8/&gt;</ph>Collection<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Bidirectional<ph x="11">&lt;w11/&gt;</ph>Flatten<ph x="12">&lt;w12/&gt;</ph>Collection<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>によって使われる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Iterator<ph x="2">&lt;w2/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the associated <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Iterator<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Lazy<ph x="4">&lt;w4/&gt;</ph>Filter<ph x="5">&lt;w5/&gt;</ph>Sequence<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Lazy<ph x="8">&lt;w8/&gt;</ph>Filter<ph x="9">&lt;w9/&gt;</ph>Collection<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Lazy<ph x="4">&lt;w4/&gt;</ph>Filter<ph x="5">&lt;w5/&gt;</ph>Sequence<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Lazy<ph x="8">&lt;w8/&gt;</ph>Filter<ph x="9">&lt;w9/&gt;</ph>Collection<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に関連する<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Iterator<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the associated iterator for the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Drop<ph x="3">&lt;w3/&gt;</ph>While<ph x="4">&lt;w4/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Lazy<ph x="7">&lt;w7/&gt;</ph>Drop<ph x="8">&lt;w8/&gt;</ph>While<ph x="9">&lt;w9/&gt;</ph>Collection<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, and <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Lazy<ph x="12">&lt;w12/&gt;</ph>Drop<ph x="13">&lt;w13/&gt;</ph>While<ph x="14">&lt;w14/&gt;</ph>Bidirectional<ph x="15">&lt;w15/&gt;</ph>Collection<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Drop<ph x="3">&lt;w3/&gt;</ph>While<ph x="4">&lt;w4/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Lazy<ph x="7">&lt;w7/&gt;</ph>Drop<ph x="8">&lt;w8/&gt;</ph>While<ph x="9">&lt;w9/&gt;</ph>Collection<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>、そして<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Lazy<ph x="12">&lt;w12/&gt;</ph>Drop<ph x="13">&lt;w13/&gt;</ph>While<ph x="14">&lt;w14/&gt;</ph>Bidirectional<ph x="15">&lt;w15/&gt;</ph>Collection<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>型に対する関連イテレータです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the associated iterator for the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Prefix<ph x="3">&lt;w3/&gt;</ph>While<ph x="4">&lt;w4/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Lazy<ph x="7">&lt;w7/&gt;</ph>Prefix<ph x="8">&lt;w8/&gt;</ph>While<ph x="9">&lt;w9/&gt;</ph>Collection<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, and <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Lazy<ph x="12">&lt;w12/&gt;</ph>Prefix<ph x="13">&lt;w13/&gt;</ph>While<ph x="14">&lt;w14/&gt;</ph>Bidirectional<ph x="15">&lt;w15/&gt;</ph>Collection<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Prefix<ph x="3">&lt;w3/&gt;</ph>While<ph x="4">&lt;w4/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Lazy<ph x="7">&lt;w7/&gt;</ph>Prefix<ph x="8">&lt;w8/&gt;</ph>While<ph x="9">&lt;w9/&gt;</ph>Collection<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>、そして<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Lazy<ph x="12">&lt;w12/&gt;</ph>Prefix<ph x="13">&lt;w13/&gt;</ph>While<ph x="14">&lt;w14/&gt;</ph>Bidirectional<ph x="15">&lt;w15/&gt;</ph>Collection<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>型に対する関連イテレータです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the default implementation of the greater-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) for any type that conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するあらゆる型に対してのより大きい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の初期状態の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the default implementation of the greater-than-or-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&gt;=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) for any type that conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するあらゆる型に対して、より大きいか等しい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&gt;=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の初期状態の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the default implementation of the less-than-or-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) for any type that conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するあらゆる型に対しての、より少ないか等しい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の初期状態の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the default implementation of the not-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>!=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) for any type that conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは不等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>!=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するあらゆる型に対する初期状態の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the most appropriate method for doing user-level string searches, similar to how searches are done generally in the system.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、システムにおいて一般に行われる検索方法と似た、ユーザレベル文字列検索に最もふさわしいメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the same as the number of bytes moved when an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer&lt;T&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is incremented.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer&lt;T&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が増大させられる時に動かされるバイト数と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the unit of the least significant digit in this value’s significand.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはこの値の仮数の中の最下位数の単位です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is useful when a function returns an unmanaged reference and you know that you’re not responsible for releasing the result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、ある関数が管理されない参照を返す、そしてあなたがその結果を解放することに責任を持たなくてよいことをあなたが知っているときにときに有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is useful when a function returns an unmanaged reference and you know that you’re responsible for releasing the result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、ある関数が管理されない参照を返す、そしてあなたがその結果を解放することに責任を持つことをあなたが知っているときにときに有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is useful when passing a reference to an API which Swift does not know the ownership rules for, but you know that the API expects you to pass the object at +0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、Swiftがそれについての所有権規則を知らないAPIにある参照を渡す、しかしそのAPIはあなたがオブジェクトを+0で渡すことを予期するのをあなたが知っているときに有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is useful when passing an object to an API which Swift does not know the ownership rules for, but you know that the API expects you to pass the object at +1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、Swiftがそれについての所有権規則を知らないAPIにあるオブジェクトを渡す、しかしそのAPIはあなたがオブジェクトを+1で渡すことを予期するのをあなたが知っているときに有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This iterator forwards its <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to an arbitrary underlying iterator having the same <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type, hiding the specifics of the underlying <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Iterator<ph x="6">&lt;w6/&gt;</ph>Protocol<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイテレータは、それの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを同じ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Element<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型を持っている随意の基盤をなすイテレータに転送して、特定の基盤をなす<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Iterator<ph x="6">&lt;w6/&gt;</ph>Protocol<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を隠しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This magnitude calculation takes the following form for a floating-point value <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> of type <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>F<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, where <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>**<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> is exponentiation:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この規模計算は、型<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>F<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>の浮動小数点値<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に対して以下の形式をとります、そこで<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>**<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>は冪演算です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that different representations of a string compare as being equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これが意味するのは、ある文字列の異なる表現が等しいと比較されることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that if an array is sharing storage with other copies, the first mutating operation on that array incurs the cost of copying the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これが意味するのは、ある配列がストレージを他のコピーと共有するならば、その配列上での最初の変更操作は、配列をコピーするコストを招くということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method can take throwing closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、スローを行うクロージャをとることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method ensures that the array has unique, mutable, contiguous storage, with space allocated for at least the requested number of elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、配列が、少なくとも要請された数の要素に割り当てられた空間とともに、固有な、可変の、隣接するストレージを持つことを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method ensures that the dictionary has unique, mutable, contiguous storage, with space allocated for at least the requested number of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、辞書が、少なくとも要請された数のキー値ペアに割り当てられた空間とともに、固有な、可変の、隣接するストレージを持つことを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method ensures that the set has unique, mutable, contiguous storage, with space allocated for at least the requested number of elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、集合が、少なくとも要請された数の要素に割り当てられた空間とともに、固有な、可変の、隣接するストレージを持つことを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method has the effect of removing the specified range of elements from the array and inserting the new elements at the same location.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、指定された範囲の要素を配列から取り除き、そして新しい要素を同じ場所に挿入する効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、指定された範囲の要素をコレクションから取り除き、そして新しい要素を同じ場所に挿入する効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、語彙筆記的順序の数学的概念を実装します、それはユニコードに関係はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method implements the remainder operation defined by the <bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754 specification<ept i="7">&lt;/a7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、<bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754仕様<ept i="7">&lt;/a7&gt;</ept>によって定義される剰余演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method is equivalent to the C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>fma<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function and implements the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>fused<ph x="4">&lt;w4/&gt;</ph>Multiply<ph x="5">&lt;w5/&gt;</ph>Add<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> operation defined by the <bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754 specification<ept i="6">&lt;/a6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>fma<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数の等価物です、そして<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>fused<ph x="4">&lt;w4/&gt;</ph>Multiply<ph x="5">&lt;w5/&gt;</ph>Add<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>演算を実装し、それは<bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754仕様<ept i="6">&lt;/a6&gt;</ept>によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the container does not have a value associated with <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>key<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, or if the value is null.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、そのコンテナが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>key<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と関連付けられる値を持たないならば、またはその値がnullならば、返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method returns <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the container has no elements left to decode, or if the value is null.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します、もしコンテナがデコードするのに残る要素を持たないならば、またはもし値がnullならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method returns a typed pointer for further typed access to the memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、この後で型付アクセスをこのメモリにするために型付ポインタを返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method returns the maximum of two values, preserving order and eliminating NaN when possible.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、２つの値のうち最大を返します、可能な場合は桁数の保全およびNaNの排除をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method returns the minimum of two values, preserving order and eliminating NaN when possible.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、２つの値のうち最小を返します、可能な場合は桁数の保全およびNaNの排除をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method returns the value with greater magnitude of the two given values, preserving order and eliminating NaN when possible.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、２つの与えられた値のうちより大きい規模を持つ値を返します、可能な場合は桁数の保全およびNaNの排除をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method returns the value with lesser magnitude of the two given values, preserving order and eliminating NaN when possible.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、２つの与えられた値のうちより小さい規模を持つ値を返します、可能な場合は桁数の保全およびNaNの排除をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method serves as the basis for the equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) for floating-point values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、浮動小数点値のための同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の基盤としての機能を果たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method serves as the basis for the less-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) for floating-point values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、浮動小数点値のためのより少ない演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の基盤としての機能を果たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method serves as the basis for the less-than-or-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) for floating-point values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、浮動小数点値のためのより少ないか等しい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の基盤としての機能を果たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method works regardless of whether the static string stores a pointer or a single Unicode scalar value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、静的文字列がポインタまたは単一ユニコードスカラー値のどちらを格納するかに関係なく働きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This operation does not change reference counts.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この操作は参照カウントを変更しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This operator tests whether two instances have different identities, not different values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算子は、２つのインスタンスが異なる正体を持つ（異なる同一性を持つ）かどうかをテストします、異なる値をではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This operator tests whether two instances have the same identity, not the same value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算子は、２つのインスタンスが同じ正体を持つ（同一性を持つ）かどうかをテストします、同じ値をではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This operator uses short-circuit evaluation: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is checked first, and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>default<ph x="4">&lt;w4/&gt;</ph>Value<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is evaluated only if <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>optional<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算子は、短絡評価を使います：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が最初に調べられます、そして<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>default<ph x="4">&lt;w4/&gt;</ph>Value<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>optional<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>である場合にのみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This operator uses short-circuit evaluation: The left-hand side (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) is evaluated first, and the right-hand side (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>) is evaluated only if <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>lhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> evaluates to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算子は、短絡評価を使います：左手側（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）が最初に評価されます、そして右手側（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>lhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>false<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に評価する場合にのみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This operator uses short-circuit evaluation: The left-hand side (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) is evaluated first, and the right-hand side (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>) is evaluated only if <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>lhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> evaluates to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>true<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算子は、短絡評価を使います：左手側（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）が最初に評価されます、そして右手側（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>rhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>lhs<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>true<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に評価する場合にのみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This pointer is valid only for the duration of the call to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このポインタは、ただ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>body<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への呼び出しの間にのみ有効とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This property implements the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>log<ph x="2">&lt;w2/&gt;</ph>B<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operation defined by the <bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754 specification<ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティは、<bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754仕様<ept i="3">&lt;/a3&gt;</ept>で定義される<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>log<ph x="2">&lt;w2/&gt;</ph>B<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This property is <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for both quiet and signaling NaNs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティは、クワイエットおよびシグナルNaNの両方に対して<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This property is a constant for instances of fixed-width integer types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティは、固定長整数型のインスタンスのための定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This property is always <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for unsigned integer types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティは、符号なし整数型に対して常に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>false<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This property is always <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for signed integer types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティは、符号付き整数型に対して常に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This property performs the canonical (non-localized) mapping.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティは、正準（非現地語）マッピングを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This property trades safety for performance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティは性能と安全を交換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This protocol is an implementation detail of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; do not use it directly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロトコルは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の実装詳細です；それを直接に使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This protocol is useful in presenting C “varargs” APIs natively in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロトコルは、SwiftにおいてC「varargs」APIをネイティブに表すのに有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This quantity, or a related quantity, is sometimes called <bpt i="0" x="0">&lt;e0&gt;</bpt>epsilon<ept i="0">&lt;/e0&gt;</ept> or <bpt i="1" x="1">&lt;e1&gt;</bpt>machine epsilon<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この量、または関連する量は、時々<bpt i="0" x="0">&lt;e0&gt;</bpt>イプシロン<ept i="0">&lt;/e0&gt;</ept>または<bpt i="1" x="1">&lt;e1&gt;</bpt>機械イプシロン<ept i="1">&lt;/e1&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This relation is a refinement of the less-than-or-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) that provides a total order on all values of the type, including noncanonical encodings, signed zeros, and NaNs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関係は、より少ないか等しい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）の改良版です、それは、非正準化エンコーディング、符号付きゼロ、そしてNaNを含む、その型のすべての値に関する全順序を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This representation matches the one used when <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instances are passed to C APIs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この表現は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスがC APIに渡される時に使われるものと一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This rounding rule is also known as “bankers rounding,” and is the default IEEE 754 rounding mode for arithmetic.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この丸め規則はまた「銀行家の丸め」としても知られます、そして算術に対する省略時のIEEE 754丸め方式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This rounding rule is also known as “schoolbook rounding.” The following example shows the results of rounding numbers using this rule:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この丸め規則はまた「教科書丸め」としても知られます。以下の例は、この規則を使っての数の丸めの結果を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This rule implements the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>round<ph x="2">&lt;w2/&gt;</ph>To<ph x="3">&lt;w3/&gt;</ph>Integral<ph x="4">&lt;w4/&gt;</ph>Ties<ph x="5">&lt;w5/&gt;</ph>To<ph x="6">&lt;w6/&gt;</ph>Even<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operation defined by the <bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754 specification<ept i="7">&lt;/a7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この規則は、<bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754仕様<ept i="7">&lt;/a7&gt;</ept>で定義される<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>round<ph x="2">&lt;w2/&gt;</ph>To<ph x="3">&lt;w3/&gt;</ph>Integral<ph x="4">&lt;w4/&gt;</ph>Ties<ph x="5">&lt;w5/&gt;</ph>To<ph x="6">&lt;w6/&gt;</ph>Even<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This rule is equivalent to the C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>ceil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function and implements the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>round<ph x="4">&lt;w4/&gt;</ph>To<ph x="5">&lt;w5/&gt;</ph>Integral<ph x="6">&lt;w6/&gt;</ph>Toward<ph x="7">&lt;w7/&gt;</ph>Positive<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> operation defined by the <bpt i="8" x="8">&lt;a8&gt;</bpt>IEEE 754 specification<ept i="8">&lt;/a8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この規則は、C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>ceil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数の等価物です、そして<bpt i="8" x="8">&lt;a8&gt;</bpt>IEEE 754仕様<ept i="8">&lt;/a8&gt;</ept>によって定義される<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>round<ph x="4">&lt;w4/&gt;</ph>To<ph x="5">&lt;w5/&gt;</ph>Integral<ph x="6">&lt;w6/&gt;</ph>Toward<ph x="7">&lt;w7/&gt;</ph>Positive<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This rule is equivalent to the C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>floor<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function and implements the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>round<ph x="4">&lt;w4/&gt;</ph>To<ph x="5">&lt;w5/&gt;</ph>Integral<ph x="6">&lt;w6/&gt;</ph>Toward<ph x="7">&lt;w7/&gt;</ph>Negative<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> operation defined by the <bpt i="8" x="8">&lt;a8&gt;</bpt>IEEE 754 specification<ept i="8">&lt;/a8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この規則は、C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>floor<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数の等価物です、そして<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>round<ph x="4">&lt;w4/&gt;</ph>To<ph x="5">&lt;w5/&gt;</ph>Integral<ph x="6">&lt;w6/&gt;</ph>Toward<ph x="7">&lt;w7/&gt;</ph>Negative<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>演算を実装し、それは<bpt i="8" x="8">&lt;a8&gt;</bpt>IEEE 754仕様<ept i="8">&lt;/a8&gt;</ept>によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This rule is equivalent to the C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>round<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function and implements the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>round<ph x="4">&lt;w4/&gt;</ph>To<ph x="5">&lt;w5/&gt;</ph>Integral<ph x="6">&lt;w6/&gt;</ph>Ties<ph x="7">&lt;w7/&gt;</ph>To<ph x="8">&lt;w8/&gt;</ph>Away<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> operation defined by the <bpt i="9" x="9">&lt;a9&gt;</bpt>IEEE 754 specification<ept i="9">&lt;/a9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この規則は、C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>round<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数の等価物です、そして<bpt i="9" x="9">&lt;a9&gt;</bpt>IEEE 754仕様<ept i="9">&lt;/a9&gt;</ept>によって定義される<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>round<ph x="4">&lt;w4/&gt;</ph>To<ph x="5">&lt;w5/&gt;</ph>Integral<ph x="6">&lt;w6/&gt;</ph>Ties<ph x="7">&lt;w7/&gt;</ph>To<ph x="8">&lt;w8/&gt;</ph>Away<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This rule is equivalent to the C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>trunc<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function and implements the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>round<ph x="4">&lt;w4/&gt;</ph>To<ph x="5">&lt;w5/&gt;</ph>Integral<ph x="6">&lt;w6/&gt;</ph>Toward<ph x="7">&lt;w7/&gt;</ph>Zero<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> operation defined by the <bpt i="8" x="8">&lt;a8&gt;</bpt>IEEE 754 specification<ept i="8">&lt;/a8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この規則は、C <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>trunc<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数の等価物です、そして<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>round<ph x="4">&lt;w4/&gt;</ph>To<ph x="5">&lt;w5/&gt;</ph>Integral<ph x="6">&lt;w6/&gt;</ph>Toward<ph x="7">&lt;w7/&gt;</ph>Zero<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>演算を実装し、それは<bpt i="8" x="8">&lt;a8&gt;</bpt>IEEE 754仕様<ept i="8">&lt;/a8&gt;</ept>によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This setting has no effect on mirrors reflecting value type instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この設定は、値型インスタンスをリフレクションするミラー上では効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This should report all keys present which are convertible to the requested type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、要請された型に変換可能である、存在する全てのキーを報告するべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This subscript takes an index into the dictionary, instead of a key, and returns the corresponding key-value pair as a tuple.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この添え字は辞書に対してのインデックスをとります、キーではなく、そして該当するキー値ペアをタプルとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This type does not carry an owner pointer unlike the other C*Pointer types because it only needs to reference the results of inout conversions, which already have writeback-scoped lifetime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型は、他のC*Pointer型と違って所有ポインタを持ち運びません、なぜならそれはただインアウト変換の結果を参照する必要があるだけだからです、そしてそれは既にライトバックスコープの寿命を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This type has implicit conversions to allow passing any of the following to a C or ObjC API:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型は暗黙的な変換を持ち、それによって以下のことをCまたはObjC APIへ渡すことを可能にされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This type is the result of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.reversed()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> where <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>x<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is a collection having bidirectional indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.reversed()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の結果です、ここで<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>x<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は双方向性のインデックスを持つコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This type is the result of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.reversed()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> where <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>x<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is a collection having random access indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ph x="2">&lt;w2/&gt;</ph>.reversed()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の結果です、そこで<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>x<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>はランダムアクセスのインデックスを持つコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This type may differ from the subject’s dynamic type when <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>superclass<ph x="4">&lt;w4/&gt;</ph>Mirror<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> of another mirror.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>self<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が別のミラーの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>superclass<ph x="4">&lt;w4/&gt;</ph>Mirror<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>である時は、この主題のもつ動的型と異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This unexpected result occurs because the call to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>type(of: value)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> inside <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>print<ph x="4">&lt;w4/&gt;</ph>Generic<ph x="5">&lt;w5/&gt;</ph>Info(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must return a metatype that is an instance of <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>T<ph x="8">&lt;w8/&gt;</ph>.Type<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, but <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>String<ph x="11">&lt;w11/&gt;</ph>.self<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> (the expected dynamic type) is not an instance of <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>P<ph x="14">&lt;w14/&gt;</ph>.Type<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> (the concrete metatype of <bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>value<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この予期しない結果は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>type(of: value)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への呼び出しが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>print<ph x="4">&lt;w4/&gt;</ph>Generic<ph x="5">&lt;w5/&gt;</ph>Info(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>内部において、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>T<ph x="8">&lt;w8/&gt;</ph>.Type<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>のインスタンスであるメタタイプを返さなければならない、しかし<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>String<ph x="11">&lt;w11/&gt;</ph>.self<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>（期待された動的型）は<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>P<ph x="14">&lt;w14/&gt;</ph>.Type<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>（<bpt i="15" x="15">&lt;c15&gt;</bpt><bpt i="16" x="16">&lt;s16&gt;</bpt>value<ept i="16">&lt;/s16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>の具象メタタイプ）のインスタンスでないことから起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This value compares greater than or equal to all finite numbers, but less than <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>infinity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値は、すべての有限数、しかし<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>無限大<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>より少ないものに対してより大きいか等しいと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This value compares less than or equal to all positive normal numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値は、すべての正のノーマル数に対してより少ないか等しいと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This value compares less than or equal to all positive numbers, but greater than zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値は、すべての正の数、しかしゼロより大きいものに対してより少ないか等しいと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This value corresponds to type-specific C macros such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>FLT_MAX<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>DBL_MAX<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値は、型固有のCマクロ、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>FLT_MAX<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>DBL_MAX<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This value corresponds to type-specific C macros such as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>FLT_MIN<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>DBL_MIN<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値は、型固有のCマクロ、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>FLT_MIN<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>DBL_MIN<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This value is always positive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この結果は常に正です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This value is unadjusted by the type’s exponent bias.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、この型の持つ指数バイアスによって未調整のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This value may be nontrivial to compute; it is usually a good idea to store this information in the “header” area when an instance is created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値を計算するのは、些細なことではありません；通常良い考えであるのは、この情報をインスタンスが作成されるときに「ヘッダ」領域に格納することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This value should be rounded toward zero to keep user computations with angles from inadvertently ending up in the wrong quadrant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値は、角度を伴うユーザ計算が不注意に間違った象限に終わらないようにゼロへと丸められるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This will be the same as either <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>CSigned<ph x="2">&lt;w2/&gt;</ph>Char<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> (in the common case) or <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>CUnsigned<ph x="5">&lt;w5/&gt;</ph>Char<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, depending on the platform.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、プラットホーム次第で、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>CSigned<ph x="2">&lt;w2/&gt;</ph>Char<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>（一般的な場合）または<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>CUnsigned<ph x="5">&lt;w5/&gt;</ph>Char<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>のどちらかに同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Those “pairs” of code units are called <bpt i="2" x="2">&lt;e2&gt;</bpt>surrogate pairs<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それら「ペア」のコード単位は、<bpt i="2" x="2">&lt;e2&gt;</bpt>サロゲートペア<ept i="2">&lt;/e2&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Thus, creating a slice has O(1) complexity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、ある切り取り（スライス）の作成はO(1)の計算量を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Thus, side-effects such as the accumulation of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>result<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> below are never unexpectedly dropped or deferred:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、副作用、例えば下の<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>result<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の集積などは、決して突然に投下されたり延期されたりしません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To access the stride, use <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Memory<ph x="4">&lt;w4/&gt;</ph>Layout&lt;Pointee&gt;.stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ストライドにアクセスするには、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Memory<ph x="4">&lt;w4/&gt;</ph>Layout&lt;Pointee&gt;.stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To access the stride, use <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Memory<ph x="6">&lt;w6/&gt;</ph>Layout&lt;Pointee&gt;.stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ストライドにアクセスするには、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Memory<ph x="6">&lt;w6/&gt;</ph>Layout&lt;Pointee&gt;.stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To access the stride, use <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Memory<ph x="8">&lt;w8/&gt;</ph>Layout&lt;Pointee&gt;.stride<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ストライドにアクセスするには、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Memory<ph x="8">&lt;w8/&gt;</ph>Layout&lt;Pointee&gt;.stride<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To access the underlying memory through typed operations, the memory must be bound to a trivial type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付演算を通して基礎をなすメモリにアクセスするには、メモリは自明型に束縛されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To access the underlying memory, invoke <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>with<ph x="2">&lt;w2/&gt;</ph>Unsafe<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> on the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基礎をなすメモリにアクセスするには、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>with<ph x="2">&lt;w2/&gt;</ph>Unsafe<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を配列上で発動してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bidirectional<ph x="2">&lt;w2/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom types, implement the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>index(before:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method in addition to the requirements of the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Collection<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bidirectional<ph x="2">&lt;w2/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>index(before:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドを、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Collection<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロトコルの要件に加えて実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Date<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, first declare conformance to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Comparable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and implement the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>&lt;<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> operator function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Date<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に加えるには、最初に<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Comparable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>への準拠を宣言して、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>&lt;<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>演算子関数を実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom types, define the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&lt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>==<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> operators as static methods of your types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&lt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>および<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>==<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>演算子をあなたの型の静的メソッドとして定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Boolean<ph x="4">&lt;w4/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom type, implement the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>init(boolean<ph x="7">&lt;w7/&gt;</ph>Literal:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> initializer that creates an instance of your type with the given Boolean value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Boolean<ph x="4">&lt;w4/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>init(boolean<ph x="7">&lt;w7/&gt;</ph>Literal:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>イニシャライザを加えてください、それはあなたの型のインスタンスを、与えられたブール値とともに作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Extended<ph x="4">&lt;w4/&gt;</ph>Grapheme<ph x="5">&lt;w5/&gt;</ph>Cluster<ph x="6">&lt;w6/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom type, implement the required initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Extended<ph x="4">&lt;w4/&gt;</ph>Grapheme<ph x="5">&lt;w5/&gt;</ph>Cluster<ph x="6">&lt;w6/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、必須イニシャライザを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Float<ph x="4">&lt;w4/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom type, implement the required initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Float<ph x="4">&lt;w4/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、必須イニシャライザを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Integer<ph x="4">&lt;w4/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom type, implement the required initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Integer<ph x="4">&lt;w4/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、必須イニシャライザを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>String<ph x="4">&lt;w4/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom type, implement the required initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>String<ph x="4">&lt;w4/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、必須イニシャライザを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Unicode<ph x="4">&lt;w4/&gt;</ph>Scalar<ph x="5">&lt;w5/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom type, implement the required initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Unicode<ph x="4">&lt;w4/&gt;</ph>Scalar<ph x="5">&lt;w5/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、必須イニシャライザを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Numeric<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol conformance to your own custom type, implement the required mutating methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Numeric<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコル準拠をあなた独自のあつらえの型に加えるには、必須可変メソッドを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom collection, add an empty initializer and the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>replace<ph x="6">&lt;w6/&gt;</ph>Subrange(_:<ph x="7">&lt;w7/&gt;</ph>with:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method to your custom type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ph x="2">&lt;w2/&gt;</ph>Replaceable<ph x="3">&lt;w3/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえのコレクションに加えるには、ひとつの空のイニシャライザおよび<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>replace<ph x="6">&lt;w6/&gt;</ph>Subrange(_:<ph x="7">&lt;w7/&gt;</ph>with:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドをあなたのあつらえの型に加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Text<ph x="2">&lt;w2/&gt;</ph>Output<ph x="3">&lt;w3/&gt;</ph>Streamable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to a custom type, implement the required <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>write(to:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Text<ph x="2">&lt;w2/&gt;</ph>Output<ph x="3">&lt;w3/&gt;</ph>Streamable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあつらえの型に加えるには、必須<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>write(to:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Collection<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> conformance to your type, you must declare at least the four following requirements:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Collection<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>準拠をあなたの型に加えるには、あなたは少なくとも４つの以下の要件を宣言しなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Hashable<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> conformance, provide an <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>==<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> operator function and a <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>hash<ph x="11">&lt;w11/&gt;</ph>Value<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Hashable<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>準拠を加えるには、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>==<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>演算子関数と<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>hash<ph x="11">&lt;w11/&gt;</ph>Value<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>プロパティを加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Sequence<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> conformance to your own custom type, add a <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>make<ph x="12">&lt;w12/&gt;</ph>Iterator()<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> method that returns an iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Sequence<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>準拠をあなた独自のあつらえの型に加えるには、あるイテレータを返す<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>make<ph x="12">&lt;w12/&gt;</ph>Iterator()<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>メソッドを加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add a new key-value pair, assign a value to a key that isn’t yet a part of the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいキー値ペアを加えるには、ある値を、まだ辞書の一部ではないキーに対して割り当ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add conformance to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol to your own custom collection, upgrade your type’s subscript to support both read and write access.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mutable<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルへの準拠をあなた独自のあつらえのコレクションに加えるには、あなたの型の持つ添え字を更新して読み書きアクセス両方をサポートするようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add new lazy collection operations, extend this protocol with methods that return lazy wrappers that are themselves <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Collection<ph x="3">&lt;w3/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい遅延コレクション操作を加えるために、このプロトコルを、それら自身が<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Collection<ph x="3">&lt;w3/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>である遅延ラッパーを返すメソッドで拡張してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add new lazy sequence operations, extend this protocol with methods that return lazy wrappers that are themselves <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Sequence<ph x="3">&lt;w3/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい遅延シーケンス操作を加えるために、このプロトコルを、それら自身が<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Lazy<ph x="2">&lt;w2/&gt;</ph>Sequence<ph x="3">&lt;w3/&gt;</ph>Protocol<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>である遅延ラッパーを返すメソッドらで拡張してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add single elements to the end of an array, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>append(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単一の要素を配列に加えるには、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>append(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add the capability to be initialized with a dictionary literal to your own custom types, declare an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(dictionary<ph x="2">&lt;w2/&gt;</ph>Literal:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書リテラルで初期化される能力をあなた独自のあつらえの型に加えるには、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(dictionary<ph x="2">&lt;w2/&gt;</ph>Literal:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add values of different types, convert one of the values to the other value’s type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>異なる型の値を加算するには、それらの値の一方を、他方の値の型へと変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To adopt the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, implement the equal-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>==<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>) as a static method of your type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルを採用するには、同等演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>==<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）をあなたの型の静的メソッドとして実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To avoid the unexpected copy, use the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>index(after:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method starting with <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>start<ph x="6">&lt;w6/&gt;</ph>Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> to produce indices instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>予期されないコピーを避けるために、代わりに<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>index(after:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドを使って<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>start<ph x="6">&lt;w6/&gt;</ph>Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>で始めることで、インデックスを生成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To bind memory to <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>T<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, use <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>bind<ph x="9">&lt;w9/&gt;</ph>Memory(to:<ph x="10">&lt;w10/&gt;</ph>capacity:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> instead of this method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリを<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>T<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に束縛するには、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>bind<ph x="9">&lt;w9/&gt;</ph>Memory(to:<ph x="10">&lt;w10/&gt;</ph>capacity:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>をこのメソッドの代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To bind uninitialized memory to a type without initializing it, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bind<ph x="2">&lt;w2/&gt;</ph>Memory(to:<ph x="3">&lt;w3/&gt;</ph>count:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>未初期化メモリをそれを初期化することなくある型に束縛するには、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bind<ph x="2">&lt;w2/&gt;</ph>Memory(to:<ph x="3">&lt;w3/&gt;</ph>count:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To bind uninitialized memory to a type without initializing it, use the <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>bind<ph x="12">&lt;w12/&gt;</ph>Memory(to:<ph x="13">&lt;w13/&gt;</ph>count:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>未初期化メモリをそれを初期化することなくある型に束縛するには、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>bind<ph x="12">&lt;w12/&gt;</ph>Memory(to:<ph x="13">&lt;w13/&gt;</ph>count:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>メソッドを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To check for invalid usage in Release builds, see <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>precondition(_:<ph x="2">&lt;w2/&gt;</ph>_:<ph x="3">&lt;w3/&gt;</ph>file:<ph x="4">&lt;w4/&gt;</ph>line:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「リリース」ビルドにおける無効な使用法を調べるには、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>precondition(_:<ph x="2">&lt;w2/&gt;</ph>_:<ph x="3">&lt;w3/&gt;</ph>file:<ph x="4">&lt;w4/&gt;</ph>line:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To check whether a collection is empty, use its <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Empty<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property instead of comparing <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコレクションが空かどうか調べるには、それの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Empty<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使ってください、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>をゼロと比較するのでなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To check whether a string is empty, use its <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Empty<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property instead of comparing the length of one of the views to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>0<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列が空かどうか調べるには、それの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Empty<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使ってください、ビューの内の１つの長さを<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>0<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と比較するのでなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To check whether the collection is empty, use its <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Empty<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property instead of comparing <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションが空かどうか調べるには、それの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Empty<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使ってください、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>をゼロと比較するのでなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To conditionally bind the wrapped value of an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance to a new variable, use one of the optional binding control structures, including <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>if let<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>guard let<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>switch<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスのラップされた値を新しい変数へ条件付きの束縛を行うには、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>if let<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>guard let<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、そして<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>switch<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を含む、オプショナル束縛制御構造の１つを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To convert a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ph x="2">&lt;w2/&gt;</ph>.UTF16View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance back into a string, use the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>String<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type’s <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>init(_:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ph x="2">&lt;w2/&gt;</ph>.UTF16View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを逆に文字列へと変換するには、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>String<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型のもつ<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>init(_:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>イニシャライザを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To convert an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSRange<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance to a range of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String<ph x="6">&lt;w6/&gt;</ph>.UTF16View<ph x="7">&lt;w7/&gt;</ph>.Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, follow these steps:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSRange<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスを<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String<ph x="6">&lt;w6/&gt;</ph>.UTF16View<ph x="7">&lt;w7/&gt;</ph>.Index<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の範囲へ変換するには、これらの手順に従ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To convert an integer value from one type to another, use an initializer or the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numeric<ph x="2">&lt;w2/&gt;</ph>Cast(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数値をある型から別のものに変換するには、イニシャライザまたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numeric<ph x="2">&lt;w2/&gt;</ph>Cast(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To convert between a pointer and an integer value with that bit pattern, or vice versa, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(bit<ph x="2">&lt;w2/&gt;</ph>Pattern:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer for the destination type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるポインタとそのビットパターンを持つ整数値の間の変換をする、またはその逆では、行き先の型の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(bit<ph x="2">&lt;w2/&gt;</ph>Pattern:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To create a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Zip2Sequence<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance, use the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>zip(_:<ph x="8">&lt;w8/&gt;</ph>_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Zip2Sequence<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスを作成するには、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>zip(_:<ph x="8">&lt;w8/&gt;</ph>_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>関数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To create a dictionary with no key-value pairs, use an empty dictionary literal (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>[:]<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー値ペアを持たない辞書を作成するには、空の辞書リテラル（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>[:]<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To create an empty instance, assign an empty array literal to your variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空のインスタンスを作成するには、空の配列リテラルをあなたの変数に割り当ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To create an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Enumerated<ph x="2">&lt;w2/&gt;</ph>Iterator<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, call <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>enumerated().make<ph x="5">&lt;w5/&gt;</ph>Iterator()<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> on a sequence or collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Enumerated<ph x="2">&lt;w2/&gt;</ph>Iterator<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスを作成するには、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>enumerated().make<ph x="5">&lt;w5/&gt;</ph>Iterator()<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>をシーケンスまたはコレクション上で呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To create an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Enumerated<ph x="2">&lt;w2/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, call <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>enumerated()<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> on a sequence or collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Enumerated<ph x="2">&lt;w2/&gt;</ph>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスを作成するには、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>enumerated()<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>をシーケンスまたはコレクション上で呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To customize that representation, make your type conform to the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Custom<ph x="7">&lt;w7/&gt;</ph>Debug<ph x="8">&lt;w8/&gt;</ph>String<ph x="9">&lt;w9/&gt;</ph>Convertible<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この表現をカスタマイズするには、あなたの型を<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Custom<ph x="7">&lt;w7/&gt;</ph>Debug<ph x="8">&lt;w8/&gt;</ph>String<ph x="9">&lt;w9/&gt;</ph>Convertible<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロトコルに準拠させてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To customize your type’s implementation, provide your own mutating <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>negate()<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの型の実装をカスタマイズするには、あなた自身の可変の<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>negate()<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドを提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To declare a dictionary, assign a dictionary literal to a variable or constant:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書を宣言するには、辞書リテラルを変数または定数に割り当ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To demonstrate the different views available for every string, the following examples use this <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆる文字列で利用可能な異なるビューを実際に示すために、以降の例はこの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To do so, start by creating two slices of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>absences<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それをするには、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>absences<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列の２つのスライスを作成することで始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To do this, enclose a comma-separated list of values in square brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これをするには、コンマ区切りの値のリストを角括弧で囲んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To establish that a type you’ve created supports nondestructive iteration, add conformance to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが作成した型が非破壊反復をサポートすることを確立するには、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに対する準拠を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To find individual elements of a string, use the appropriate view for your task.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列の個々の要素を手に入れるには、あなたの作業に適切なビューを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To find the distance in bytes between two pointers, convert them to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Unsafe<ph x="8">&lt;w8/&gt;</ph>Raw<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instances before calling <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>distance(to:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのポインタの間の隔たりをバイトで知るには、それらを<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Unsafe<ph x="8">&lt;w8/&gt;</ph>Raw<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスに、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>distance(to:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>を呼ぶ前に変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To find the distance in bytes between two pointers, convert them to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Unsafe<ph x="8">&lt;w8/&gt;</ph>Raw<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instances before subtracting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのポインタの間の隔たりをバイトで知るには、それらを<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Unsafe<ph x="8">&lt;w8/&gt;</ph>Raw<ph x="9">&lt;w9/&gt;</ph>Pointer<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスに、減算前に変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To find the index of the day in question, follow these setps:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>当該の日付のインデックスを見つけるには、これらの手順を踏んでください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To find the index of the day in question, follow these steps:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>質問の日付のインデックスを見つけるには、これらの手順に従ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To find the indices of the two days in question, follow these steps:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>当該の２つの日付のインデックスを見つけるには、これらの手順を踏んでください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To find the position that corresponds with this index in the original, underlying collection, use that collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index(before:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method with the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>base<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オリジナル、基盤コレクションでのこのインデックスに相当する位置を見つけるには、そのコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index(before:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>base<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティとともに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To get the dynamic type inside <bpt i="17" x="17">&lt;c17&gt;</bpt><bpt i="18" x="18">&lt;s18&gt;</bpt>value<ept i="18">&lt;/s18&gt;</ept><ept i="17">&lt;/c17&gt;</ept> in this generic context, cast the parameter to <bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>Any<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept> when calling <bpt i="21" x="21">&lt;c21&gt;</bpt><bpt i="22" x="22">&lt;s22&gt;</bpt>type(of:)<ept i="22">&lt;/s22&gt;</ept><ept i="21">&lt;/c21&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="17" x="17">&lt;c17&gt;</bpt><bpt i="18" x="18">&lt;s18&gt;</bpt>value<ept i="18">&lt;/s18&gt;</ept><ept i="17">&lt;/c17&gt;</ept>内部の動的型をこの総称体の文脈において得るには、このパラメータを<bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>Any<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept>へと<bpt i="21" x="21">&lt;c21&gt;</bpt><bpt i="22" x="22">&lt;s22&gt;</bpt>type(of:)<ept i="22">&lt;/s22&gt;</ept><ept i="21">&lt;/c21&gt;</ept>を呼び出す時にキャストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To inherit all the default implementations from the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Option<ph x="2">&lt;w2/&gt;</ph>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Element<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type must be <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Self<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, the default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Option<ph x="2">&lt;w2/&gt;</ph>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコル由来のすべての省略時実装を継承するには、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Element<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型は初期状態で<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Self<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To iterate over the elements of a collection with its indices, use the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>zip(_:<ph x="7">&lt;w7/&gt;</ph>_:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコレクションの要素すべてにわたってそれのインデックスで反復するには、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>zip(_:<ph x="7">&lt;w7/&gt;</ph>_:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>関数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To learn which half had more absences, use the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>reduce(_:<ph x="4">&lt;w4/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method to calculate each sum.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前半後半のどちらがより多くの欠席者がいるか突き止めるには、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>reduce(_:<ph x="4">&lt;w4/&gt;</ph>_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドを使ってそれぞれ総計を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To maintain substitutability, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator should take into account all visible aspects of an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代替可能性を維持するために、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子はある<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型の全ての目に見える面を考慮しなければならないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make your custom type conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Text<ph x="2">&lt;w2/&gt;</ph>Output<ph x="3">&lt;w3/&gt;</ph>Stream<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, implement the required <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>write(_:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのあつらえのクラスを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Text<ph x="2">&lt;w2/&gt;</ph>Output<ph x="3">&lt;w3/&gt;</ph>Stream<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠させるには、必須<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>write(_:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make your own custom type conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Fixed<ph x="2">&lt;w2/&gt;</ph>Width<ph x="3">&lt;w3/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, declare the required initializers, properties, and methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなた独自のあつらえの型を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Fixed<ph x="2">&lt;w2/&gt;</ph>Width<ph x="3">&lt;w3/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠させるには、必須イニシャライザ、プロパティ、そしてメソッドを宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To multiply values of different types, convert one of the values to the other value’s type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>異なる型の値を乗算するには、それらの値の一方を、他方の値の型へと変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To perform a bitwise conversion of an integer value to a different type, use an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(bit<ph x="2">&lt;w2/&gt;</ph>Pattern:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>init(truncating<ph x="5">&lt;w5/&gt;</ph>Bit<ph x="6">&lt;w6/&gt;</ph>Pattern:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>異なる型へと整数値のビット単位変換を実行するには、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(bit<ph x="2">&lt;w2/&gt;</ph>Pattern:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>init(truncating<ph x="5">&lt;w5/&gt;</ph>Bit<ph x="6">&lt;w6/&gt;</ph>Pattern:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>イニシャライザを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To perform a reference cast, use the casting operators (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>as<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>as!<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, or <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>as?<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>) or the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>unsafe<ph x="8">&lt;w8/&gt;</ph>Downcast(_:<ph x="9">&lt;w9/&gt;</ph>to:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照キャストを実行するには、キャスト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>as<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>as!<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、または<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>as?<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）または<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>unsafe<ph x="8">&lt;w8/&gt;</ph>Downcast(_:<ph x="9">&lt;w9/&gt;</ph>to:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>関数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To prevent bypassing customized ancestors, <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>custom<ph x="16">&lt;w16/&gt;</ph>Mirror<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> overrides should initialize the <bpt i="17" x="17">&lt;c17&gt;</bpt><bpt i="18" x="18">&lt;s18&gt;</bpt>Mirror<ept i="18">&lt;/s18&gt;</ept><ept i="17">&lt;/c17&gt;</ept> with:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>カスタマイズされた先祖の迂回を防ぐには、<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>custom<ph x="16">&lt;w16/&gt;</ph>Mirror<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>オーバーライドは、以下を使って<bpt i="17" x="17">&lt;c17&gt;</bpt><bpt i="18" x="18">&lt;s18&gt;</bpt>Mirror<ept i="18">&lt;/s18&gt;</ept><ept i="17">&lt;/c17&gt;</ept>を初期化するべきです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To prevent this confusion, in a context where <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Bound<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> is known to be an integer type, subscripting directly is a compile-time error:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この混乱を防ぐために、<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Bound<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>が整数型であると知られている文脈では、添え字を使うことは直ちにコンパイルエラーになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To print the items separated by something other than a space, pass a string as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>separator<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空白以外の何かによって区切られる項目を出力するには、ある文字列を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>separator<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To print the items without a trailing newline, pass an empty string as <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>terminator<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後に続く改行なしで項目を出力するには、空の文字列を<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>terminator<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>として渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To print the items without a trailing newline, pass an empty string as <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>terminator<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後に続く改行なしで項目を出力するには、空の文字列を<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>terminator<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>として渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To print the items without a trailing newline, pass an empty string as <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>terminator<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後に続く改行なしで項目を出力するには、空の文字列を<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>terminator<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>として渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To protect code from invalid usage in Release builds, see <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>precondition<ph x="6">&lt;w6/&gt;</ph>Failure(_:<ph x="7">&lt;w7/&gt;</ph>file:<ph x="8">&lt;w8/&gt;</ph>line:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「リリース」ビルドにおける無効な使用法を調べるには、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>precondition<ph x="6">&lt;w6/&gt;</ph>Failure(_:<ph x="7">&lt;w7/&gt;</ph>file:<ph x="8">&lt;w8/&gt;</ph>line:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To remove elements from an array, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>remove(at:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>remove<ph x="4">&lt;w4/&gt;</ph>Subrange(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>remove<ph x="7">&lt;w7/&gt;</ph>Last()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列から要素を取り除くには、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>remove(at:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>remove<ph x="4">&lt;w4/&gt;</ph>Subrange(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>remove<ph x="7">&lt;w7/&gt;</ph>Last()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To remove the last element of a collection that might be empty, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>pop<ph x="2">&lt;w2/&gt;</ph>Last()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空であるかもしれないあるコレクションの最後の要素を削除するには、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>pop<ph x="2">&lt;w2/&gt;</ph>Last()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To represent those scalar values using 8-bit integers, more than one UTF-8 code unit is often required.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのスカラー値を8ビット整数で表すには、１つ以上のUTF-8コード単位がしばしば必要とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To resolve this, you can use <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>without<ph x="15">&lt;w15/&gt;</ph>Actually<ph x="16">&lt;w16/&gt;</ph>Escaping(_:<ph x="17">&lt;w17/&gt;</ph>do:)<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> to get copies of <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>f<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> and <bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>g<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept> that can be passed to <bpt i="22" x="22">&lt;c22&gt;</bpt><bpt i="23" x="23">&lt;s23&gt;</bpt>async(execute:)<ept i="23">&lt;/s23&gt;</ept><ept i="22">&lt;/c22&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを解決するために、あなたは<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>without<ph x="15">&lt;w15/&gt;</ph>Actually<ph x="16">&lt;w16/&gt;</ph>Escaping(_:<ph x="17">&lt;w17/&gt;</ph>do:)<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>を使って、<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>f<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>と<bpt i="20" x="20">&lt;c20&gt;</bpt><bpt i="21" x="21">&lt;s21&gt;</bpt>g<ept i="21">&lt;/s21&gt;</ept><ept i="20">&lt;/c20&gt;</ept>のコピーを取得します、それは<bpt i="22" x="22">&lt;c22&gt;</bpt><bpt i="23" x="23">&lt;s23&gt;</bpt>async(execute:)<ept i="23">&lt;/s23&gt;</ept><ept i="22">&lt;/c22&gt;</ept>に渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To restore efficient set operations, create a new set from the result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>能率的な集合演算を取り戻すには、新しい集合を結果から作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To round a value using the default “schoolbook rounding”, you can use the shorter <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>round()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> method instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の「教科書丸め」を使って値を丸めるには、あなたはより短い<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>round()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>メソッドを代わりに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To round a value using the default “schoolbook rounding”, you can use the shorter <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>rounded()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> method instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の「教科書丸め」を使って値を丸めるには、あなたはより短い<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>rounded()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>メソッドを代わりに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To safely access the properties and methods of a wrapped instance, use the postfix optional chaining operator (postfix <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>?<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ラップされたインスタンスの持つプロパティおよびメソッドに安全にアクセスするには、後置オプショナル連鎖演算子（後置<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>?<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To safely reference the starting and ending indices of a slice, always use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> properties instead of specific values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるスライスの最初と最後のインデックスを安全に参照するために、常に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロパティを特定の値の代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To sort the elements of your collection in descending order, pass the greater-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>sort(by:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコレクションの要素を降順にソートするには、より大きい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>sort(by:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To sort the elements of your collection in descending order, pass the greater-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>sorted(by:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコレクションの要素を降順にソートするには、より大きい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>sorted(by:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To sort the elements of your sequence in descending order, pass the greater-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>sorted(by:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのシーケンスの要素を降順にソートするには、より大きい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>sorted(by:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To sort your collection in descending order, pass the greater-than operator (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>) as the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>are<ph x="6">&lt;w6/&gt;</ph>In<ph x="7">&lt;w7/&gt;</ph>Increasing<ph x="8">&lt;w8/&gt;</ph>Order<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコレクションを降順にソートするには、より大きい演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）を<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>are<ph x="6">&lt;w6/&gt;</ph>In<ph x="7">&lt;w7/&gt;</ph>Increasing<ph x="8">&lt;w8/&gt;</ph>Order<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>パラメータとして渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To sort your sequence in descending order, pass the greater-than operator (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>) as the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>are<ph x="6">&lt;w6/&gt;</ph>In<ph x="7">&lt;w7/&gt;</ph>Increasing<ph x="8">&lt;w8/&gt;</ph>Order<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのシーケンスを降順にソートするには、より大きい演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>&gt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）を<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>are<ph x="6">&lt;w6/&gt;</ph>In<ph x="7">&lt;w7/&gt;</ph>Increasing<ph x="8">&lt;w8/&gt;</ph>Order<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>パラメータとして渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To specify an alternative rule for rounding, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>round(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>丸めのための代替の規則を指定するには、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>round(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To specify an alternative rule for rounding, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rounded(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>丸めのための代替の規則を指定するには、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rounded(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To subtract values of different types, convert one of the values to the other value’s type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>異なる型の値を減算するには、それらの値の一方を、他方の値の型へと変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To use a dictionary literal as the initial value of a dictionary, enclose a comma-separated list of key-value pairs in square brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書リテラルをある辞書の初期値として使うには、キー値ペアのコンマ区切りリストを角括弧で囲んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To use string interpolation to initialize instances of your custom type, implement the required initializers for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>String<ph x="4">&lt;w4/&gt;</ph>Interpolation<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列補間を使ってあなたのあつらえの型のインスタンスを初期化するには、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>String<ph x="4">&lt;w4/&gt;</ph>Interpolation<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠に対する必須イニシャライザを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>contains(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method without including a closure in each call, extend the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Street<ph x="4">&lt;w4/&gt;</ph>Address<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type to conform to <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Equatable<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>contains(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを各呼び出しにクロージャを含めることなく使うには、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Street<ph x="4">&lt;w4/&gt;</ph>Address<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型を<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Equatable<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠するように拡張してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To use your own custom type in a set or as the key type of a dictionary, add <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Hashable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your type by providing a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>hash<ph x="4">&lt;w4/&gt;</ph>Value<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなた独自のあつらえの型を集合においてまたは辞書のキー型として使うには、あなたの型に<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Hashable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>hash<ph x="4">&lt;w4/&gt;</ph>Value<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティを加えることによって加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tools for Your Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの型のためのツール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Topics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>話題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Trades safety for performance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>安全性と性能の交換をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Transforming a Boolean</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブールを変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Transforming a Dictionary</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の変形</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Transforming a Dictionary's Elements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の要素の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Transforming a Set</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合を変形する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Transforming a String</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列を変形する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Transforming a String's Characters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列のもつ文字を変形します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Transforming an Array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の変形</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Transforming an Optional Value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル値の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Translates the given input from one Unicode encoding to another by calling the given closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された入力をあるユニコード符号化から別のものへと指定されたクロージャを呼び出すことによって翻訳します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Translation Between Unicode Encodings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードエンコーディング間の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Traversing a Collection</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションを辿っていく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Truncating the fractional part of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equivalent to rounding toward zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>source<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の小数部分の切り詰めは、ゼロへの丸めに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tuple Comparison</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプル比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Two <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Date<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances are equal if each of their corresponding properties is equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Date<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、それらの対応するプロパティの各々が等しいならば等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Two elements are <bpt i="0" x="0">&lt;e0&gt;</bpt>incomparable<ept i="0">&lt;/e0&gt;</ept> if neither is ordered before the other according to the predicate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの要素は、述部によるとどちらもが他の前に並べられるならば<bpt i="0" x="0">&lt;e0&gt;</bpt>比較できない<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Two instances of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Hashable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> compare as equal if and only if the underlying types have the same conformance to the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Equatable<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol and the underlying values compare as equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Hashable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の２つのインスタンスは、基礎をなす型が同じ準拠を<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Equatable<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルに対して持ちそしてそれら基礎をなす型が等しいと比較される場合にのみ等しいと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Two ranges are equal when they have the same lower and upper bounds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの範囲は、それらが同じ下方および上方境界を持つとき等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Two sets that are equal will always have equal hash values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの等しい集合は、常に等しいハッシュ値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Two values that are equal always have equal hash values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの等しい値は、常に等しいハッシュ値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Aliases</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型エイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Casting and Existential Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型キャストと存在型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Inference of Array Literals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列リテラルの型推論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Method</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型プロパティ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Property</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type aliases representing the concrete type that a literal takes when no other type information is provided.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>具体的な型を表している型エイリアスで、それをリテラルが取るのは他の型情報が提供されない時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type cast</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型キャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type check</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型チェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type-Erasing Wrappers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型消去ラッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typed Memory</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付メモリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typed Pointers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付ポインタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typed pointers are required to be properly aligned for their <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付ポインタは、適切にそれらの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型にアラインされることを要求されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types that are not able to guarantee that expected performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>期待される性能を保証することが可能でない型は、その逸脱を文書化されなければなりません、なぜなら多くのコレクション演算はそれら自身の性能保証としてO(1)添え字操作性能に依存するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types that conform to <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are expected to provide the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>start<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>end<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> properties and subscript access to elements as O(1) operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠する型は、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>start<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>および<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>end<ph x="7">&lt;w7/&gt;</ph>Index<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロパティと要素への添え字アクセスをO(1)演算として提供することを期待されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Custom<ph x="2">&lt;w2/&gt;</ph>String<ph x="3">&lt;w3/&gt;</ph>Convertible<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol can provide their own representation to be used when converting an instance to a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Custom<ph x="2">&lt;w2/&gt;</ph>String<ph x="3">&lt;w3/&gt;</ph>Convertible<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型は、それら独自の表現を提供して、インスタンスが文字列に変換されるときに使われるようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol can be compared for equality using the equal-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>==<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>) or inequality using the not-equal-to operator (<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>!=<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型は、同等性を同等演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>==<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）を使って、または不等性を不等演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>!=<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）を使って比較されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Floating<ph x="2">&lt;w2/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol provide most basic (clause 5) operations of the <bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754 specification<ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Floating<ph x="2">&lt;w2/&gt;</ph>Point<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型は、<bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754仕様<ept i="3">&lt;/a3&gt;</ept>の最も基本的な演算（５項）を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types that implement alternative behaviors for a signaling NaN must document the departure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シグナルNaNに対する代替の挙動を実装する型は、その逸脱を文書化しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types with Comparable conformance implement the less-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) and the equal-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>==<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Comparable準拠を持つ型は、より少ない演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）と同等演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>==<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typical usage stores a count and capacity in <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Header<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> and destroys any live elements in the <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>deinit<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> of a subclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>典型的なやり方は、総数と容量を<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Header<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に格納して、サブクラスの<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>deinit<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>の中のあらゆる生きている要素を破壊します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typically written using the nil literal, <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>概してnilリテラル、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>UTF-16 View</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-16ビュー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>UTF-8 View</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-8ビュー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>UTF16View Elements Match NSString Characters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF16View要素はNSString文字に一致します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>UTF8View Elements Match Encoded C Strings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF8View要素は符号化C文字列と一致します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unary minus</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単項マイナス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unary plus</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単項プラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unconditional Unwrapping</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無条件にアンラップする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unconditionally prints a given message and stops execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無条件に与えられたメッセージを出力して実行を停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unconditionally unwrapping a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance with <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>!<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> triggers a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>nil<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>!<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>で無条件にアンラップすることは、実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Understanding a Pointer’s Memory State</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるポインタのメモリ状態を理解する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unicode Codecs</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードコーデック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unicode Scalar View</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードスカラービュー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unicode scalar values are the 21-bit codes that are the basic unit of Unicode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードスカラー値は21ビットコードです、それはユニコードの基本的な単位です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unicode scalar values that make up a string’s contents can be up to 21 bits long.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列のもつ内容を構成するユニコードスカラー値は、21ビット長に至るまで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Uninitialized Memory</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>未初期化メモリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Uninitialized memory must be initialized before it can be accessed for reading.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>未初期化メモリは、それが読み出しのためアクセスされる前に初期化される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Uninitialized memory must be initialized with values of a type before it can be used with any typed operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>未初期化メモリは、それが何らかの型付き演算で使用される前にある型の値で初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Uniqueness Checking</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特有性の検査</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>UnkeyedDecodingContainer Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UnkeyedDecodingContainer 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>UnkeyedEncodingContainer Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UnkeyedEncodingContainer 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unless the collection conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bidirectional<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> must be less than or equal to <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>end<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Bidirectional<ph x="2">&lt;w2/&gt;</ph>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない場合は、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>start<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>end<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>より少ないか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unless the collection guarantees random-access performance, calculating <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>count<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> can be an O(<bpt i="7" x="7">&lt;e7&gt;</bpt>n<ept i="7">&lt;/e7&gt;</ept>) operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのコレクションが無作為アクセス性能を保証しない限り、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>count<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の算出は、O(<bpt i="7" x="7">&lt;e7&gt;</bpt>n<ept i="7">&lt;/e7&gt;</ept>)演算であるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Contiguous<ph x="4">&lt;w4/&gt;</ph>Array<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the starting index for an <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Array<ph x="7">&lt;w7/&gt;</ph>Slice<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance isn’t always zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Array<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Contiguous<ph x="4">&lt;w4/&gt;</ph>Array<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>とは違い、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Array<ph x="7">&lt;w7/&gt;</ph>Slice<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスのインデックスの始まりは必ずしもゼロではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSString<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, however, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ph x="4">&lt;w4/&gt;</ph>.UTF16View<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> does not use integer indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSString<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>とは違い、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ph x="4">&lt;w4/&gt;</ph>.UTF16View<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は整数インデックスを使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, instances of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Closed<ph x="4">&lt;w4/&gt;</ph>Range<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> cannot represent an empty interval.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>とは違って、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Closed<ph x="4">&lt;w4/&gt;</ph>Range<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のインスタンスは空の間隔を表すことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer&lt;Pointee&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Autoreleasing<ph x="6">&lt;w6/&gt;</ph>Unsafe<ph x="7">&lt;w7/&gt;</ph>Mutable<ph x="8">&lt;w8/&gt;</ph>Pointer&lt;Pointee&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> must reference storage that does not own a reference count to the referenced value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer&lt;Pointee&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>とは違い、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Autoreleasing<ph x="6">&lt;w6/&gt;</ph>Unsafe<ph x="7">&lt;w7/&gt;</ph>Mutable<ph x="8">&lt;w8/&gt;</ph>Pointer&lt;Pointee&gt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は、参照される値への参照カウントを保有しないストレージを参照しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>is<ph x="7">&lt;w7/&gt;</ph>Empty<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, calculating a view’s <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>count<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> property requires iterating through the elements of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>is<ph x="7">&lt;w7/&gt;</ph>Empty<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>とは違って、あるビューの<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>count<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロパティを計算することはその文字列の要素を始めから終わりまで反復していく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike enumerations, option sets provide a nonfailable <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(raw<ph x="2">&lt;w2/&gt;</ph>Value:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer to convert from a raw value, because option sets don’t have an enumerated list of all possible cases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙と異なり、オプションセットは生の値から変換するために失敗できない<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(raw<ph x="2">&lt;w2/&gt;</ph>Value:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを提供します、なぜならオプションセットは可能な場合全てを列挙したリストを持たないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike in other programming languages, in Swift, integers and strings cannot be used where a Boolean value is required.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他のプログラミング言語とは違い、Swiftではブール値が必要とされるところで整数と文字列は使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike key-value pairs in a true dictionary, neither the key nor the value of a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Dictionary<ph x="7">&lt;w7/&gt;</ph>Literal<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance must conform to the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Hashable<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>本当の辞書におけるキー値ペアとは違い、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Dictionary<ph x="7">&lt;w7/&gt;</ph>Literal<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスのキーも値も<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Hashable<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロトコルに準拠する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike ordinary set types, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type of an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Option<ph x="4">&lt;w4/&gt;</ph>Set<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is identical to the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Option<ph x="7">&lt;w7/&gt;</ph>Set<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> type itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>普通の集合型とは違い、ある<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Option<ph x="4">&lt;w4/&gt;</ph>Set<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Option<ph x="7">&lt;w7/&gt;</ph>Set<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>型自体と全く同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike other floating-point types, the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Float80<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> type explicitly stores the leading integral significand bit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の浮動小数点型と違い、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Float80<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>型は明示的に先頭整数仮数ビットを格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike the key-based subscript, the index-based subscript returns the corresponding key-value pair as a non-optional tuple.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー基盤の添え字と違い、インデックス基盤の添え字は該当するキー値ペアを非オプショナルのタプルとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>UnsafeBufferPointer Semantics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UnsafeBufferPointer意味論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>UnsafeMutableBufferPointer Semantics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UnsafeMutableBufferPointer意味論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>UnsafeMutablePointer’s operations, by contrast, assume that the referenced storage owns values loaded from or stored to it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UnsafeMutablePointerの行う操作は、対照的に、参照されるストレージがそれからロードされたりそれへと格納される値を所有すると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>UnsafeMutableRawBufferPointer Semantics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UnsafeMutableRawBufferPointer意味論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unsafely converts an unmanaged class reference to a pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>管理されないクラス参照をポインタへと安全でない変換をする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unsafely turns an opaque C pointer into an unmanaged class reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>不透明Cポインタの管理されないクラス参照への安全でない転換。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unsigned Integers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号なし整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>UnsignedInteger Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UnsignedInteger実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Update an existing value by assigning a new value to a key that already exists in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すでに辞書に存在するキーに新しい値を割り当てることで、既存の値を更新してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updates the value stored in the dictionary for the given key, or adds a new key-value pair if the key does not exist.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書に格納される値を指定されたキーに対して更新します、またはそのキーが存在しないならば新しいキー値ペアを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Never<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as the return type when declaring a closure, function, or method that unconditionally throws an error, traps, or otherwise does not terminate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無条件にエラーをスローする、トラップする、またはそうする以外終了しない、クロージャ、関数、またはメソッドを定義するときに、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Never<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を戻り型として使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Void<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or an empty tuple as the return type when declaring a closure, function, or method that doesn’t return a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値を返さないクロージャ、関数、またはメソッドを定義する場合は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Void<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または空のタプルを戻り型として使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unsafe<ph x="2">&lt;w2/&gt;</ph>Downcast<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> only when <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>x as! T<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> has proven to be a performance problem and you are confident that, always, <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x is T<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unsafe<ph x="2">&lt;w2/&gt;</ph>Downcast<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>x as! T<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>には性能問題があると立証される、そしてあなたが、常に、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>x is T<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>であると確信している時のみ使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unsafely<ph x="2">&lt;w2/&gt;</ph>Unwrapped<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> only when you are confident that this instance will never be equal to <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>nil<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and only after you’ve tried using the postfix <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>!<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unsafely<ph x="2">&lt;w2/&gt;</ph>Unwrapped<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、あなたがこのインスタンスは決して<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>nil<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と等しくないことを確信している場合にのみ、そしてあなたが前置<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>!<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>演算子を使うことを試みた後にのみ使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance when you need an ordered collection of key-value pairs and don’t require the fast key lookup that the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Dictionary<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type provides.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスをあなたがキー値ペアの順序付けられたコレクション必要とするそして<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Dictionary<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が提供する高速な検索を要求しない場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use a type’s alignment when allocating memory using an unsafe pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型のアライメントを使うのは、安全でないポインタを使うメモリアロケートの場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use a variable or constant with an existential type to hold an instance of any type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数または定数を存在型とともに使って、何らかの型のインスタンスを保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use bridged reference types when you need reference semantics or Foundation-specific behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブリッジされた参照型を、あなたが参照意味論またはFoundation特有の挙動を必要とする場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use imported C types or call C variadic functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポートされたC型を使ったり、C可変長引数関数を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use inout syntax to implicitly create a pointer to an instance of any type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インアウト構文を使って、任意の型のインスタンスへのポインタを暗黙的に作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use key-path expressions to access properties dynamically.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパス式を使ってプロパティに動的にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use raw pointers and buffers to access memory for loading and storing as raw bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生のポインタとバッファを使って、ロードおよび格納のためにメモリに生のバイトとしてアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use set-related operations to check for membership and to add or remove members from an instance of your custom option set type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>セット関連演算を使って、帰属を確認したり、あなたのあつらえのオプションセット型のインスタンス由来のメンバの追加や削除を行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use slices only for transient computation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スライスを一時的な計算のためだけに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use string interpolation to include one or more expressions in a string literal, wrapped in a set of parentheses and prefixed by a backslash.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列補間を使って文字列リテラルの中に１つ以上の式を、一組の丸括弧に包んでひとつのパックスラッシュを前に置いて、含めてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Fixed<ph x="2">&lt;w2/&gt;</ph>Width<ph x="3">&lt;w3/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol as a constraint or extension point when writing operations that depend on bit shifting, performing bitwise operations, catching overflows, or having access to the maximum or minimum representable value of a type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビットシフト、ビット単位演算の実行、オーバーフローのキャッチ、またはある型の最大限または最小限表現可能な値へのアクセスに依存する演算を記述する場合に、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Fixed<ph x="2">&lt;w2/&gt;</ph>Width<ph x="3">&lt;w3/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルを制約または拡張ポイントとして使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSRange<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type’s <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>to<ph x="4">&lt;w4/&gt;</ph>Range<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method to convert the instance to an optional range of <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSRange<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>to<ph x="4">&lt;w4/&gt;</ph>Range<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドを使って、そのインスタンスをオプショナルの<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Int<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>値範囲へ変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>alignment<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property for a type when allocating memory using an unsafe pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型に対して<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>alignment<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使うのは、安全でないポインタを使うメモリアロケートの場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bind<ph x="2">&lt;w2/&gt;</ph>Memory(to:<ph x="3">&lt;w3/&gt;</ph>capacity:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to bind the memory referenced by this pointer to the type <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bind<ph x="2">&lt;w2/&gt;</ph>Memory(to:<ph x="3">&lt;w3/&gt;</ph>capacity:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使用して、このポインタによって参照されるメモリを型<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>T<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>へと束縛してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>combine<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure to select which value to use in the returned dictionary, or to combine existing and new values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>combine<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャを使って、どの値を返される辞書に使うか選択してください、または既存および新規の値を結合してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>combine<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure to select which value to use in the updated dictionary, or to combine existing and new values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>combine<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャを使って、どの値を更新される辞書に使うか選択してください、または既存および新規の値を結合してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>contains(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to test whether a set contains a specific element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>contains(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、ある集合が特定の要素を含むかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>last<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> properties for safe access to the value of the array’s first and last elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の最初と最後の要素の値に対する安全なアクセスのために<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>first<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>last<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>flat<ph x="2">&lt;w2/&gt;</ph>Map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method with a closure that returns an optional value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>flat<ph x="2">&lt;w2/&gt;</ph>Map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドをオプショナル値を返すクロージャとともに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(clamping:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer to create a new instance of a binary integer type where out-of-range values are clamped to the representable range of the type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(clamping:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを使って、バイナリ整数型の新しいインスタンスを作成してください、そこにおいて範囲外の値はその型の表現可能な範囲に固定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(extending<ph x="2">&lt;w2/&gt;</ph>Or<ph x="3">&lt;w3/&gt;</ph>Truncating:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer to create a new instance with the same bit pattern as the passed value, extending or truncating the value’s representation as necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(extending<ph x="2">&lt;w2/&gt;</ph>Or<ph x="3">&lt;w3/&gt;</ph>Truncating:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを使って、渡された値と同じビットパターンを持つ新しいインスタンスを、必要ならばその値の表現を拡張または切り詰めて作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init?(exactly:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer to create a new instance after checking whether the passed value is representable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init?(exactly:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを使うことで、その渡された値が表現可能であるかどうか調べた後に新しいインスタンスを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>intersection(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to create a new set with only the elements common to a set and another set or sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>intersection(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、ある集合と別の集合またはシーケンスに共通の要素だけで新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Disjoint(with:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to test whether a set has any elements in common with another set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Disjoint(with:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、ある集合が別の集合と共通の何らかの要素を持つかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Empty<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property to check quickly whether an array has any elements, or use the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> property to find the number of elements in the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Empty<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使って、ある配列が要素を持つかどうか素早く確認してください、または<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を使うことで配列中の要素の数を調べてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Strict<ph x="3">&lt;w3/&gt;</ph>Subset(of:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>is<ph x="6">&lt;w6/&gt;</ph>Strict<ph x="7">&lt;w7/&gt;</ph>Superset(of:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> methods to test whether a set is a subset or superset of, but not equal to, another set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Strict<ph x="3">&lt;w3/&gt;</ph>Subset(of:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>is<ph x="6">&lt;w6/&gt;</ph>Strict<ph x="7">&lt;w7/&gt;</ph>Superset(of:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドを使って、ある集合が別の集合の下位集合または上位集合である、しかし等しくはないものであるかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Subset(of:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to test whether a set contains all the elements of another set or sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Subset(of:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、ある集合が別の集合またはシーケンスに属する要素すべてを含むかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Superset(of:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to test whether all elements of a set are contained in another set or sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Superset(of:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、ある集合のすべての要素が別の集合またはシーケンスの中に含まれるかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lazy<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property when chaining operations to prevent intermediate operations from allocating storage, or when you only need a part of the final collection to avoid unnecessary computation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算を連鎖することで中間演算がストレージを割り当てるのを防ぐときに、またはあなたが最終的コレクションの一部を必要とするだけであって不必要な計算を避けたい場合に、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>lazy<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method with a closure that returns a nonoptional value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを非オプショナル値を返すクロージャとともに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max(by:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to determine the index of the day with the most absences.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>max(by:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って最も欠席者の多い日付のインデックスを判定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reduce(_:<ph x="2">&lt;w2/&gt;</ph>_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to produce a single value from the elements of an entire sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reduce(_:<ph x="2">&lt;w2/&gt;</ph>_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、あるシーケンス全体の中の要素から単一の値を生成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subtracting(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to create a new set with the elements of a set that are not also in another set or sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>subtracting(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、別の集合またはシーケンスにはないある集合の要素で新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>symmetric<ph x="2">&lt;w2/&gt;</ph>Difference(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to create a new set with the elements that are in either a set or another set or sequence, but not in both.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>symmetric<ph x="2">&lt;w2/&gt;</ph>Difference(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、ある集合または別の集合かシーケンスのどちらかにある、しかし両方にではない要素で新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>union(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to create a new set with the elements of a set and another set or sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>union(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、ある集合と別の集合またはシーケンスに属する要素で新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>capacity<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>count<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> properties to determine how many more elements the array can store without allocating larger storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>capacity<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>や<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>count<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロパティを使って、より大きなストレージに割り当てることなく更にどのくらいの要素をその配列が格納できるか判定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Unicode<ph x="11">&lt;w11/&gt;</ph>.Scalar<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> type to work with decoded Unicode scalar values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Unicode<ph x="11">&lt;w11/&gt;</ph>.Scalar<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>型を使ってデコードされたユニコードスカラー値を扱ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the array’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>capacity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property to determine the size of the new storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>capacity<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使って新しいストレージの大きさを特定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the closed range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>...<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to create a closed range of any type that conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>完結範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>...<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使うことで<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠する何らかの型の配列を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the closed range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>...<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to create a closed range of any type that conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Strideable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol with an associated signed integer <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type, such as any of the standard library’s integer types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>完結範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>...<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Strideable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠して、何らかの標準ライブラリのもつ整数型といった、整数<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>関連値型を持つ、何らかの型の配列を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the half-open range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>..&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to create a range of any type that conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>半開範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>..&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠する何らかの型の範囲を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the half-open range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>..&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to create a range of any type that conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Strideable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol with an associated integer <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type, such as any of the standard library’s integer types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>半開範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>..&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Strideable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠して、何らかの標準ライブラリのもつ整数型といった、整数<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>関連値型を持つ、何らかの型の配列を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the nearest ancestor’s implementation of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>custom<ph x="2">&lt;w2/&gt;</ph>Mirror<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to create a mirror for that ancestor.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最も近い先祖の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>custom<ph x="2">&lt;w2/&gt;</ph>Mirror<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の実装を使って、その先祖に対するミラーを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the nil-coalescing operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>??<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to supply a default value in case the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Optional<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance is <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>nil合体演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>??<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って、省略時の値を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Optional<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>nil<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の場合に提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the postfix range operator (postfix <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>...<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to create a partial range of any type that conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後置完結範囲演算子（後置<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>...<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使うことで何らかの型の部分的な範囲で<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠するものを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the postfix range operator (postfix <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>...<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to create a partial range of any type that conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Strideable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol with an associated integer <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type, such as any of the standard library’s integer types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後置範囲演算子（後置<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>...<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Strideable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに関連整数<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Stride<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型、例えば標準ライブラリの整数型などと共に準拠する、何らかの型の部分範囲を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the prefix closed range operator (prefix <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>...<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to create a partial range of any type that conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前置完結範囲演算子（前置<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>...<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使うことで何らかの型の部分的な範囲で<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠するものを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the prefix half-open range operator (prefix <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>..&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to create a partial range of any type that conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前置半開範囲演算子（前置<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>..&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使うことで何らかの型の部分的な範囲で<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Comparable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠するものを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the “equal to” operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to test whether two sets contain the same elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「同等」演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って、２つの集合が同じ要素らを含むかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use these functions with numeric values and other comparable types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの関数を数値および他の比較可能な型で使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use these lazy wrappers to defer any filtering or transformation of collection elements until elements are accessed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの遅延ラッパーを使うことで、コレクション要素の何らかの変換またはフィルタを要素がアクセスされるまで延期してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use these methods only when you are sure the operation won't overflow.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのメソッドをあなたがその演算がオーバーフローすることはないと確信する場合にのみ使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to compare any two optional instances of a type that conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>==<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠するある型の何らかの２つのオプショナルインスタンスを比較してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this function for internal sanity checks that are active during testing but do not impact performance of shipping code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数を本質的な正常性確認のために使ってください、それはテストの間は活動的ですが出荷コードの性能に影響はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this function only to avoid the cost of overflow checking when you are sure that the operation won’t overflow.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数を、あなたがその演算がオーバーフローしないと確信する場合にオーバーフロー検査のコストを避けるためにのみ使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this function to detect conditions that must prevent the program from proceeding, even in shipping code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数を使って、続行することからプログラムを妨げなければならない条件を突き止めてください、出荷コードにおいてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this function to stop the program when control flow can only reach the call if your API was improperly used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのAPIが誤って使われた場合にその呼び出しに制御の流れが届く時にだけこの関数を使ってプログラムを停止してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this function to stop the program, without impacting the performance of shipping code, when control flow is not expected to reach the call—for example, in the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>default<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> case of a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>switch<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> where you have knowledge that one of the other cases must be satisfied.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数を使って、制御の流れが呼び出しに届くと予想されない場合に、出荷コードの性能に影響を与えることなく、プログラムを停止してください—例えば、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>switch<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>default<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ケース節において、そこにおいてあなたはそれ以前のケース節の１つが満たされなければならないことがわかっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this initializer around a range instead of typing all those numbers in an array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの数をすべて配列リテラルの中にタイプするの代わりに、ある範囲を取り囲むようにこのイニシャライザを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this initializer to avoid intermediate reallocations when you know how many key-value pairs you are adding to a dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのくらい多くのキー値ペアをあなたが辞書に加えることになるかあなたが知っている場合は、このイニシャライザを使って幾度もの中間的な再割り当てを回避してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this initializer to avoid repeated reallocations of a set’s buffer if you know you’ll be adding elements to the set after creation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>作成後にあなたが集合にどのくらい多くの要素を加えることになるか知っているならば、このイニシャライザを使って集合のバッファの繰り返される再割り当てを回避してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this initializer to convert an instance of any type to its custom debugging representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザを使って、何らかの型のインスタンスをそれのあつらえのデバッグ表現に変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this initializer to convert an instance of any type to its preferred representation as a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザを使って、何らかの型のインスタンスをそれのより好まれる表現である<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this initializer to create a new set from an existing sequence, for example, an array or a range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザを使って、新しい集合を既存のシーケンス、例えば、配列またはある範囲から作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this initializer to create a new set from an existing sequence, like an array or a range:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザを使って、新しい集合を既存のシーケンス、配列またはある範囲などから作成してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this initializer to explicitly convert <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Raw<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザを使って、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Raw<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスに明示的に変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this initializer to explicitly convert <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Raw<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザを使って、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Raw<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスに明示的に変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this initializer to recover a string after performing a collection slicing operation on a string’s character view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザを使って、文字列の文字ビュー上でコレクションスライス操作を実行後に文字列を回復してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this method instead of key-based subscripting when you need to know whether the new value supplants the value of an existing key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい値が既存のキーの値に取って代わるかどうかをあなたが知る必要がある場合は、キーに基づく添え字を使うのではなくこのメソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this method to append a single element to the end of a mutable array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドを使ってある単一の要素を可変の配列の終わりに加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this method to append the elements of a sequence to the end of this array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドを使うことで、あるシーケンスの要素をこの配列の終わりに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this method to calculate the quotient and remainder of a division at the same time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドを使って、除算の商と余りを同時に計算してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this method to receive a collection of nonoptional values when your transformation produces an optional value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの変換がオプショナル値を生成する場合に、このメソッドを使って非オプショナル値からなるコレクションを受け取ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this method to receive a sequence of nonoptional values when your transformation produces an optional value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの変換がオプショナル値を生成する場合に、このメソッドを使って非オプショナル値からなるシーケンスを受け取ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this method to receive a single-level collection when your transformation produces a collection for each element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの変換が各要素に対してひとつのコレクションを生成する場合に、このメソッドを使って単一水準コレクションを受け取ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this method to receive a single-level collection when your transformation produces a sequence or collection for each element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの変換が各要素に対してひとつのシーケンスまたはコレクションを生成する場合に、このメソッドを使って単一水準コレクションを受け取ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this method to receive a single-level sequence when your transformation produces a sequence or collection for each element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの変換が各要素に対してひとつのシーケンスまたはコレクションを生成する場合に、このメソッドを使って単一水準シーケンスを受け取ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this method to receive an array of nonoptional values when your transformation produces an optional value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの変換がオプショナル値を生成する場合に、このメソッドを使って非オプショナル値からなる配列を受け取ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this method when you have a pointer to memory bound to one type and you need to access that memory as instances of another type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドを、あなたがある型に束縛されたメモリへのポインタを持つ、そしてあなたがそのメモリに別の型のインスタンスとしてアクセスする必要がある場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this method when you have a raw pointer to memory that has <bpt i="0" x="0">&lt;e0&gt;</bpt>already<ept i="0">&lt;/e0&gt;</ept> been bound to the specified type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;e0&gt;</bpt>すでに<ept i="0">&lt;/e0&gt;</ept>指定された型へ束縛されているメモリに対する生のポインタを持つ場合に、このメソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this not-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>!=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to compare any two optional instances of a type that conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この不等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>!=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Equatable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠するある型の何らかの２つのオプショナルインスタンスを比較してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this operator to append the elements of a sequence to the end of range-replaceable collection with same <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算子を使って、あるシーケンスに属するいくらかの要素を同じ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型を持つ範囲置換可能なコレクションの終わりに加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this property in conjunction with <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>has<ph x="2">&lt;w2/&gt;</ph>Pointer<ph x="3">&lt;w3/&gt;</ph>Representation<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to determine whether a static string with pointer representation stores an ASCII or UTF-8 code unit sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>has<ph x="2">&lt;w2/&gt;</ph>Pointer<ph x="3">&lt;w3/&gt;</ph>Representation<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と連携して使って、ポインタ表現をもつある静的文字列がASCIIまたはUTF-8コード単位シーケンスを格納するかを判定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use typed pointers and buffers to access memory as instances of a specific type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付きのポインタとバッファを使って、メモリに特定の型のインスタンスとしてアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use wrappers, indices, and iterators in operations like slicing, flattening, and reversing a collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ラッパー、インデックス、そしてイテレータを、コレクションのスライス（切出し）、平坦化、反転のような演算で使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use your custom types in operations that depend on testing for equality or order and as members of sets and dictionaries.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのあつらえの型を、同等性や順番を調べることに基づく演算の中で、そして集合および辞書のメンバとして使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use your string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view’s index manipulation methods to convert the integer bounds to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ph x="4">&lt;w4/&gt;</ph>.UTF16View<ph x="5">&lt;w5/&gt;</ph>.Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューのもつインデックス操作メソッドを使って、整数境界を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ph x="4">&lt;w4/&gt;</ph>.UTF16View<ph x="5">&lt;w5/&gt;</ph>.Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>値へ変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Used to access the key-value pairs in an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary&lt;Key, Value&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary&lt;Key, Value&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンス中のキー値ペアにアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Used to access the members in an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set&lt;Element&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set&lt;Element&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスのメンバーにアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Useful mostly to recover the ability to use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>…<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, given just an iterator <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>i<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>主として有用なのは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>…<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使う能力を、ただイテレータ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>i<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を与えるだけで獲得することです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using Enumerations as Errors</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙をエラーとして使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using Imported Boolean values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポートされたブール値を使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using Iterators Directly</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イテレータを直に使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using Multiple Iterators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数のイテレータを使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using a Partial Range as a Sequence</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>部分範囲をシーケンスとして使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using a negative number or an index equal to or greater than <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> triggers a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>負数をまたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と等しいかより大きいインデックスを使うことは、実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using a negative value as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is the same as performing a left shift using <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>abs(rhs)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として負の値を使うことは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>abs(rhs)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使って左シフトを実行するのと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using a negative value as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is the same as performing a right shift with <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>abs(rhs)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>負の値を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として使うことは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>abs(rhs)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使って右シフトを実行するのと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using a negative value for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> performs a left shift using <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>abs(rhs)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に負の値を使うことは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>abs(rhs)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使って左シフトを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using a negative value for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> performs a right shift using <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>abs(rhs)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に負の値を使うことは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>abs(rhs)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使って右シフトを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using a sequence’s iterator directly gives you access to the same elements in the same order as iterating over that sequence using a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるシーケンスのもつイテレータを直に使うことは、あなたに<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ループを使ってそのシーケンスに反復するのと同じ要素に同じ順序でアクセスすることを与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using a value for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that is greater than or equal to the bit width of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is an <bpt i="4" x="4">&lt;e4&gt;</bpt>overshift<ept i="4">&lt;/e4&gt;</ept>, resulting in zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のビット幅より大きいか等しい値を使うことは、<bpt i="4" x="4">&lt;e4&gt;</bpt>オーバーシフト<ept i="4">&lt;/e4&gt;</ept>、ゼロという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using a value for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that is greater than or equal to the bit width of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is an <bpt i="4" x="4">&lt;e4&gt;</bpt>overshift<ept i="4">&lt;/e4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のビット幅より大きいか等しい値を使うことは、<bpt i="4" x="4">&lt;e4&gt;</bpt>オーバーシフト<ept i="4">&lt;/e4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using an Option Set Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプションセット型を使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using any other value for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> performs a left shift on <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> by that amount.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に何か他の値を使うことは、左シフトを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>上でその量だけ行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using any other value for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> performs a right shift on <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> by that amount.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>rhs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に何か他の値を使うことは、右シフトを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>上でその量だけ行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ph x="2">&lt;w2/&gt;</ph>Each<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method is distinct from a <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>for<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>-<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>in<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> loop in two important ways:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ph x="2">&lt;w2/&gt;</ph>Each<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使うことは、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>for<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>-<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>in<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>ループとは２つの重要なやり方においてまったく異なります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>prefix(through:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method is equivalent to using a partial closed range as the collection’s subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>prefix(through:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使うことは、部分的な完結範囲をコレクションのもつ添え字として使うことと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>prefix(up<ph x="2">&lt;w2/&gt;</ph>To:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method is equivalent to using a partial half-open range as the collection’s subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>prefix(up<ph x="2">&lt;w2/&gt;</ph>To:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使うことは、部分的な半開範囲をコレクションのもつ添え字として使うことと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>return<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> statement in the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>body<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> closure will exit only from the current call to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>body<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, not from any outer scope, and won’t skip subsequent calls.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>return<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>文を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>body<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>クロージャにおいて使うことは、ただ現在の<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>body<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>への呼び出しから抜け出すだけです、全く外側のスコープからではなくて、そして続いて起こる呼び出しを飛ばしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>suffix(from:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method is equivalent to using a partial range from the index as the collection’s subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>suffix(from:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使うことは、インデックスからの部分的範囲をコレクションのもつ添え字として使うことと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>lazy<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> property gives the standard library explicit permission to store the closure and the sequence in the result, and defer computation until it is needed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>lazy<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロパティを使うことは、標準ライブラリにクロージャと結果のシーケンスを保管する明示的な許可を与えます、そして計算をそれが必要とされるまで遅らせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the Nil-Coalescing Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>nil合体演算子を使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the closed range operator (<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>...<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>) to form <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Closed<ph x="8">&lt;w8/&gt;</ph>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instances is preferred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>完結範囲演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>...<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）を使って<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Closed<ph x="8">&lt;w8/&gt;</ph>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスを形成することが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the closed range operator (<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>...<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>) to form <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Countable<ph x="8">&lt;w8/&gt;</ph>Closed<ph x="9">&lt;w9/&gt;</ph>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instances is preferred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>完結範囲演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>...<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）を使って<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Countable<ph x="8">&lt;w8/&gt;</ph>Closed<ph x="9">&lt;w9/&gt;</ph>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスを形作ることが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the half-open range operator (<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>..&lt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>) to form <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Countable<ph x="8">&lt;w8/&gt;</ph>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instances is preferred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>半開範囲演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>...<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）を使って<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Countable<ph x="8">&lt;w8/&gt;</ph>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスを形作ることが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the half-open range operator (<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>..&lt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>) to form <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instances is preferred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>半開範囲演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>..&lt;<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）を使って<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Range<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスを形成することが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the raw value of a conforming type streamlines interoperation with Objective-C and legacy APIs and simplifies conformance to other protocols, such as <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Equatable<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Comparable<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>, and <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>Hashable<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>準拠する型の生の値を使うことは、Objective-CおよびレガシーAPIとの相互運用を能率的にします、そして他のプロトコル、例えば<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>Equatable<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>、<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Comparable<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>、および<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>Hashable<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>などへの準拠を簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Valid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>有効なインデックスは、各要素の位置、および添え字として使うのに有効でない“終わりを過ぎた”位置から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Valid types for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Extended<ph x="2">&lt;w2/&gt;</ph>Grapheme<ph x="3">&lt;w3/&gt;</ph>Cluster<ph x="4">&lt;w4/&gt;</ph>Literal<ph x="5">&lt;w5/&gt;</ph>Type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Character<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>String<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>, and <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Static<ph x="12">&lt;w12/&gt;</ph>String<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Extended<ph x="2">&lt;w2/&gt;</ph>Grapheme<ph x="3">&lt;w3/&gt;</ph>Cluster<ph x="4">&lt;w4/&gt;</ph>Literal<ph x="5">&lt;w5/&gt;</ph>Type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して有効な型は、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Character<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>String<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>、そして<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>Static<ph x="12">&lt;w12/&gt;</ph>String<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Valid types for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ph x="2">&lt;w2/&gt;</ph>Literal<ph x="3">&lt;w3/&gt;</ph>Type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Float<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Double<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Float80<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> where available.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Float<ph x="2">&lt;w2/&gt;</ph>Literal<ph x="3">&lt;w3/&gt;</ph>Type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して有効な型は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Float<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Double<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>、そして利用可能なところでは<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Float80<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Valid types for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ph x="2">&lt;w2/&gt;</ph>Literal<ph x="3">&lt;w3/&gt;</ph>Type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Static<ph x="8">&lt;w8/&gt;</ph>String<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ph x="2">&lt;w2/&gt;</ph>Literal<ph x="3">&lt;w3/&gt;</ph>Type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対する有効な型は、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Static<ph x="8">&lt;w8/&gt;</ph>String<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Valid types for <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>Literal<ph x="4">&lt;w4/&gt;</ph>Type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Unicode<ph x="7">&lt;w7/&gt;</ph>.Scalar<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Character<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>String<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>, and <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Static<ph x="14">&lt;w14/&gt;</ph>String<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>Scalar<ph x="3">&lt;w3/&gt;</ph>Literal<ph x="4">&lt;w4/&gt;</ph>Type<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対する有効な型は、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Unicode<ph x="7">&lt;w7/&gt;</ph>.Scalar<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>Character<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>、<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>String<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>、そして<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>Static<ph x="14">&lt;w14/&gt;</ph>String<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Value Literals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Values and Collections</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値とコレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Viewed from the perspective of the <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>reversed<ph x="12">&lt;w12/&gt;</ph>Characters<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> collection, of course, <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>"r"<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> is the element <bpt i="15" x="15">&lt;e15&gt;</bpt>after<ept i="15">&lt;/e15&gt;</ept> <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>"a"<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>reversed<ph x="12">&lt;w12/&gt;</ph>Characters<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>コレクションの観点から眺めれば、もちろん、<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>"r"<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>は<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>"a"<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>の<bpt i="15" x="15">&lt;e15&gt;</bpt>後<ept i="15">&lt;/e15&gt;</ept>の要素です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Void Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>void型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>WARNING: this initializer is not memory-safe!</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>警告：このイニシャライザはメモリ安全ではありません！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Warning</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>警告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>What’s more, when implemented using specific criteria, adoption of this protocol requires no extra work on your part.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>おまけに、特定の基準を使って実装される時、このプロトコルの採用はあなたの方での余分な作業を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>error<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is an empty string, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> evaluates to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>true<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>rhs<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is not evaluated, skipping the call to <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>major<ph x="10">&lt;w10/&gt;</ph>Errors<ph x="11">&lt;w11/&gt;</ph>.contains(_:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>error<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が空の文字列である時、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>true<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に評価して、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>rhs<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は評価されず、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>major<ph x="10">&lt;w10/&gt;</ph>Errors<ph x="11">&lt;w11/&gt;</ph>.contains(_:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>への呼び出しを省きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>error<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is not an empty string, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> evaluates to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>rhs<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is evaluated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>error<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が空の文字列ではない時、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>lhs<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>false<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に評価して、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>rhs<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>measurements<ph x="2">&lt;w2/&gt;</ph>.count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to zero, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>lhs<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> evaluates to <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>false<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>rhs<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> is not evaluated, preventing a divide-by-zero error in the expression <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>sum / Double(measurements<ph x="11">&lt;w11/&gt;</ph>.count)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>measurements<ph x="2">&lt;w2/&gt;</ph>.count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がゼロに等しい時、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>lhs<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>false<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に評価して、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>rhs<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>は評価されず、式<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>sum / Double(measurements<ph x="11">&lt;w11/&gt;</ph>.count)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>でのゼロによる除算を防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>measurements<ph x="2">&lt;w2/&gt;</ph>.count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is greater than zero, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>lhs<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> evaluates to <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>true<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>rhs<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> is evaluated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>measurements<ph x="2">&lt;w2/&gt;</ph>.count<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がゼロより大きい時、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>lhs<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>true<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に評価して、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>rhs<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>は評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ph x="2">&lt;w2/&gt;</ph>.reduce(_:<ph x="3">&lt;w3/&gt;</ph>_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is called, the following steps occur:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numbers<ph x="2">&lt;w2/&gt;</ph>.reduce(_:<ph x="3">&lt;w3/&gt;</ph>_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が呼び出される時、以下の段階が生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is used as the left side of an assignment, the instance must be initialized or this pointer’s <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type must be a trivial type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>pointee<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が引数の左側として使われる場合、インスタンスは初期化されなければなりません、またポインタのもつ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型は自明型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>count<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is passed to the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>print<ph x="8">&lt;w8/&gt;</ph>Info(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> function, however, the <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>value<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> parameter has a static type of <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Any<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>, the type declared for the parameter, and a dynamic type of <bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>Int<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>count<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>print<ph x="8">&lt;w8/&gt;</ph>Info(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>関数に渡される場合は、しかしながら、<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>value<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>パラメータは<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Any<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>の静的型、このパラメータに対して宣言された型、そして<bpt i="13" x="13">&lt;c13&gt;</bpt><bpt i="14" x="14">&lt;s14&gt;</bpt>Int<ept i="14">&lt;/s14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>の動的型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>print<ph x="10">&lt;w10/&gt;</ph>Generic<ph x="11">&lt;w11/&gt;</ph>Info(_:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> is called with a string that has <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>P<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> as its static type, the call to <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>type(of:)<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> returns <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>P<ph x="18">&lt;w18/&gt;</ph>.self<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> instead of the dynamic type inside the parameter, <bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>String<ph x="21">&lt;w21/&gt;</ph>.self<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>print<ph x="10">&lt;w10/&gt;</ph>Generic<ph x="11">&lt;w11/&gt;</ph>Info(_:)<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>が<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>P<ept i="13">&lt;/s13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>をそれの静的型として持つ文字列とともに呼ばれる時、<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>type(of:)<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>への呼び出しは<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>P<ph x="18">&lt;w18/&gt;</ph>.self<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>を返します、パラメータの内部の動的型、<bpt i="19" x="19">&lt;c19&gt;</bpt><bpt i="20" x="20">&lt;s20&gt;</bpt>String<ph x="21">&lt;w21/&gt;</ph>.self<ept i="20">&lt;/s20&gt;</ept><ept i="19">&lt;/c19&gt;</ept>ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>not<ph x="11">&lt;w11/&gt;</ph>So<ph x="12">&lt;w12/&gt;</ph>Good<ph x="13">&lt;w13/&gt;</ph>Number<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> is initialized, <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Int("invalid-input")<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> fails and returns <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>nil<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>, and so <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>Int("42")<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> is called to supply a default value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>not<ph x="11">&lt;w11/&gt;</ph>So<ph x="12">&lt;w12/&gt;</ph>Good<ph x="13">&lt;w13/&gt;</ph>Number<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>が初期化されるとき、<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Int("invalid-input")<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>は失敗して<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>nil<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>を返します、そうすると<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>Int("42")<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>が呼び出されて省略時の値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>not<ph x="11">&lt;w11/&gt;</ph>So<ph x="12">&lt;w12/&gt;</ph>Good<ph x="13">&lt;w13/&gt;</ph>Number<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> is initialized, <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Int("invalid-input")<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> fails and returns <bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>nil<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>, and so the <bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>get<ph x="20">&lt;w20/&gt;</ph>Default()<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept> method is called to supply a default value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>not<ph x="11">&lt;w11/&gt;</ph>So<ph x="12">&lt;w12/&gt;</ph>Good<ph x="13">&lt;w13/&gt;</ph>Number<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>が初期化されるとき、<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>Int("invalid-input")<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>は失敗して<bpt i="16" x="16">&lt;c16&gt;</bpt><bpt i="17" x="17">&lt;s17&gt;</bpt>nil<ept i="17">&lt;/s17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>を返します、そうすると<bpt i="18" x="18">&lt;c18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>get<ph x="20">&lt;w20/&gt;</ph>Default()<ept i="19">&lt;/s19&gt;</ept><ept i="18">&lt;/c18&gt;</ept>メソッドが呼び出されて省略時の値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a dictionary outgrows its buffer, existing indices may be invalidated without any notification.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書がそれのバッファより大きくなる時、既存のインデックスは何の通知もなしに無効にされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a literal expression is written with no type information, Swift uses these type aliases to determine what type to use for the expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リテラル表現が型情報なしで記述される時、Swiftはこれらの型エイリアスを使ってどの型をその式に使うか決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a string’s contiguous storage fills up, a new buffer must be allocated and data must be moved to the new storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列の隣接ストレージがいっぱいになるとき、新しいストレージが割り当てられる必要があり、データは新しいストレージに移動される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When allocating memory for multiple instances of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> using an unsafe pointer, use a multiple of the type’s stride instead of its size.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の複数のインスタンスに対して安全でないポインタを使ってメモリをアロケートする場合、それの大きさではなく、その型の持つストライドの倍数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When an array has additional capacity and is not sharing its storage with another instance, appending an element is O(1).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列がさらなる容量を持っていてそれのストレージを別のインスタンスと共有していない場合、ある要素を追加することはO(1)です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When an array needs to reallocate storage before appending or its storage is shared with another copy, appending is O(<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>), where <bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept> is the length of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列が追加の前にストレージの際割り当てを必要とするかそれのストレージを別のコピーと共有する場合、追加作業はO(<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>)です、そこで<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>は配列の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When an existing element is inserted, the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>class<ph x="8">&lt;w8/&gt;</ph>Days<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> set does not change.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>既存の要素が挿入される時、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>class<ph x="8">&lt;w8/&gt;</ph>Days<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>集合は変化しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When calling a function or method with an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter, you can pass an instance of that specific pointer type or use Swift’s implicit bridging to pass a compatible pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数やメソッドを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータとともに呼び出すとき、あなたはその特定のポインタ型のインスタンスを渡すか、またはSwiftの暗黙的ブリッジを使って互換ポインタを渡すことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When calling a function or method with an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter, you can pass an instance of that specific pointer type, pass an instance of a compatible pointer type, or use Swift’s implicit bridging to pass a compatible pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数やメソッドを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータとともに呼び出すとき、あなたはその特定のポインタ型のインスタンスを渡す、互換ポインタ型のインスタンスを渡す、またはSwiftの暗黙的ブリッジを使って互換ポインタを渡すことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When calling a function or method with an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter, you can pass an instance of that specific pointer type, pass an instance of a compatible pointer type, or use Swift’s implicit bridging to pass a compatible pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数やメソッドを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータとともに呼び出すとき、あなたはその特定のポインタ型のインスタンスを渡す、互換ポインタ型のインスタンスを渡す、またはSwiftの暗黙的ブリッジを使って互換ポインタを渡すことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When calling a function or method with an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter, you can pass an instance of that specific pointer type, pass an instance of a compatible pointer type, or use Swift’s implicit bridging to pass a compatible pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数やメソッドを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータとともに呼び出すとき、あなたはその特定のポインタ型のインスタンスを渡す、互換ポインタ型のインスタンスを渡す、またはSwiftの暗黙的ブリッジを使って互換ポインタを渡すことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When calling a function with a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter, you can pass a Swift dictionary literal without causing a <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Dictionary<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> to be created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータを使って呼び出す場合、あなたはSwift辞書リテラルを渡すことが<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Dictionary<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の作成なしに行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When calling the new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer within a <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>do<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> statement, you can use pattern matching to match specific cases of your custom error type and access their associated values, as in the example below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>do<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>文内部で呼び出すとき、あなたはパターンマッチを使ってあなたのあつらえのエラー型のそれぞれ詳述なケース節と照合して、それらの関連値にアクセスします、下の例でのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When comparing two values with this method, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-0<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is equal to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>+0<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの値をこのメソッドで比較する場合、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>-0<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>+0<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When converting floating-point values, the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init?(exact:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer checks both that the passed value has no fractional part and that the value is representable in the resulting type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点値を変換するとき、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init?(exact:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザは、渡された値が小数部を持たないこと、そしてその値が結果となる型の中に表現可能であることの両方を検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When creating a custom collection type, add the minimal requirements of the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Collection<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> protocol: starting and ending indices and a subscript for accessing elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あつらえのコレクション型を作成する場合、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Collection<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>プロトコルの最小限の要件：始まりと終わりのインデックスおよび要素にアクセスするための添え字、を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When creating an option set, include a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>raw<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property in your type declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるオプションセットを作成する場合は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>raw<ph x="2">&lt;w2/&gt;</ph>Value<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティをあなたの型宣言に加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When creating your own option set, implement this initializer with a fixed-width integer, like <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, as the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Raw<ph x="4">&lt;w4/&gt;</ph>Value<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなた独自のオプションセットを作成する時、このイニシャライザを固定長整数、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>などを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Raw<ph x="4">&lt;w4/&gt;</ph>Value<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型として使って実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When declaring a function or method, you don’t need to specify a return type if no value will be returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数またはメソッドを宣言するとき、値が返されることがないならばあなたは戻り型を指定する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When defining your own custom enumeration, you give it a raw type by specifying the raw type as the first item in the enumeration’s type inheritance list.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなた独自のあつらえの列挙を定義している場合、あなたはそれに生の型を与えることを、その生の型を列挙の型継承リストの最初の項目として指定することによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When enumerating a collection, the integer part of each pair is a counter for the enumeration, not necessarily the index of the paired value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコレクションを列挙するとき、各ペアの整数部分は列挙に対するあるカウンタです、必ずしもペアにされた値のインデックスではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When implementing a custom type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ph x="2">&lt;w2/&gt;</ph>Algebra<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, you must implement the required initializers and methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ph x="2">&lt;w2/&gt;</ph>Algebra<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するあつらえの型を実装する場合、あなたは必須イニシャライザとメソッドを実装する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When implementing lazy operations, wrapping <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>elements<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instead of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> can prevent result types from growing an extra <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Lazy<ph x="6">&lt;w6/&gt;</ph>Sequence<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> layer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延に演算を実装するとき、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>elements<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>self<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の代わりにラップすることは、結果の型を余分の<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Lazy<ph x="6">&lt;w6/&gt;</ph>Sequence<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>レイヤが増大することを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When iterated over, keys appear in this collection in the same order as they occur in the dictionary’s key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべてにわたって反復した場合、それらが辞書のキー値ペアにおいて現れるのと同じ順序で、キーはこのコレクションにおいて現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When iterated over, values appear in this collection in the same order as they occur in the dictionary’s key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべてにわたって反復した場合、それらが辞書のキー値ペアにおいて現れるのと同じ順序で、値はこのコレクションにおいて現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When negative integers are extended, the result is padded with ones.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>負整数が拡張される時、結果は１で詰め物をされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When nonnegative integers are extended, the result is padded with zeroes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非負整数が拡張される時、結果はゼロで詰め物をされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When performing collection-based operations that return an index into a dictionary, use this subscript with the resulting value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある辞書に対してのコレクション基盤インデックスを返す演算を実行する時、この添え字を結果の値とともに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When placed next to each other in a Swift string literal, these two code points are combined into a single grapheme cluster, represented by a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Character<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるSwift文字列リテラルにおいて互いに隣り合わせに置かれる時、これら２つのコード点は、Swiftでは１つの<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Character<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスによって表される、単一の書記素クラスタへと一体化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When reading from  memory as raw bytes when that memory is bound to a type, you must ensure that you satisfy any alignment requirements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリから読みだしをそのメモリがある型に束縛される時に生のバイトとして行う場合、あなたがあらゆるアライメント要件を満たすことを確実にしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When reading from or writing to  memory as raw bytes when that memory is bound to a type, you must ensure that you satisfy any alignment requirements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリから読みだしや書き込みをそのメモリがある型に束縛される時に生のバイトとして行う場合、あなたがあらゆるアライメント要件を満たすことを確実にしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When reading from the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property, the instance referenced by this pointer must already be initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>pointee<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティから読み出している時、このポインタによって参照されるインスタンスは既に初期化されていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When that happens, the array being modified replaces its storage with a uniquely owned copy of itself, which is then modified in place.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが起こる場合、修正されている配列はそれのストレージを独自な自分だけの自身のコピーと置き換え、それはそれからそこで修正されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>force<ph x="2">&lt;w2/&gt;</ph>ASCII<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter is <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>true<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, a <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Unicode<ph x="7">&lt;w7/&gt;</ph>.Scalar<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance with a value greater than 127 is represented using an escaped numeric value; otherwise, non-ASCII characters are represented using their typical string value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>force<ph x="2">&lt;w2/&gt;</ph>ASCII<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータが<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>true<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>である場合、127より大きい値をもつ<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Unicode<ph x="7">&lt;w7/&gt;</ph>.Scalar<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスはエスケープされた数的な値を使って表されます、そうでなければ、非ASCIIはそれらの典型的な文字列値を使って表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the bit width of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> (the type of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>source<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>) is equal to or greater than this type’s bit width, the result is the truncated least-significant bits of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>source<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>source<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の型）のビット幅がこのかたのビット幅と等しいかより大きいならば、結果は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>source<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の先端を切った最下位ビットです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the bit width of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is less than this type’s bit width, the result is <bpt i="2" x="2">&lt;e2&gt;</bpt>sign-extended<ept i="2">&lt;/e2&gt;</ept> to fill the remaining bits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>T<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のビット幅がこの型のビット幅より小さいならば、結果は残りのビットを満たすように<bpt i="2" x="2">&lt;e2&gt;</bpt>符号拡張<ept i="2">&lt;/e2&gt;</ept>されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the context provides enough type information, you can use a special form of the dictionary literal, square brackets surrounding a single colon, to initialize an empty dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文脈が十分な型情報を提供する場合、あなたは特別な形式の辞書リテラル、ただ１つのコロンを囲んでいる角括弧、を使って空の辞書を初期化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the destination array’s element type is a class or an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>@objc<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, bridging from <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSArray<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Array<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> first calls the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>copy(with:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> (<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>- copy<ph x="10">&lt;w10/&gt;</ph>With<ph x="11">&lt;w11/&gt;</ph>Zone:<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> in Objective-C) method on the array to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行き先配列の持つ要素型があるクラスまたはある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>@objc<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルである場合、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSArray<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>から<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Array<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>へのブリッジはまず<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>copy(with:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>（Objective-Cでの<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>- copy<ph x="10">&lt;w10/&gt;</ph>With<ph x="11">&lt;w11/&gt;</ph>Zone:<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>）メソッドをその配列上で呼び出すことである不変のコピーを取得します、そしてそれから追加のSwift簿記作業を実行します、それはO(1)時間をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the destination array’s element type is a nonclass type that bridges to a Foundation type, bridging from <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSArray<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Array<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> performs a bridging copy of the elements to contiguous storage in O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>) time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行き先配列の持つ要素型が非クラス型でFoundation型にブリッジする場合、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSArray<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Array<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>へのブリッジはそれら要素のコピーを隣接ストレージにブリッジすることをO(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>)時間で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the dictionary’s <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Key<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Value<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> types are neither classes nor <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>@objc<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> protocols, any required bridging of elements occurs at the first access of each element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Key<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Value<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型がクラスでも<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>@objc<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロトコルでもない場合、それら要素のブリッジに必要とされるあらゆることが各要素の最初のアクセスで起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the original <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>numbers<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> array is modified, it makes a unique copy of its storage before making the modification.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オリジナルの<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>numbers<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>配列が修正されるとき、それはそれのストレージの特有なコピーをその修正がなされる前に行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the sequence has been exhausted, the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>next()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> method returns <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのシーケンスが使い尽くされたならば、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>next()<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>メソッドは<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the sequence is exhausted, the last value returned from the closure is returned to the caller.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シーケンスが使い尽くされる時、クロージャから返される最後の値が呼び出し側へ帰されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the set’s <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Element<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type is neither a class nor an <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>@objc<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> protocol, any required bridging of elements occurs at the first access of each element, so the first operation that uses the contents of the set (for example, a membership test) can take O(<bpt i="8" x="8">&lt;e8&gt;</bpt>n<ept i="8">&lt;/e8&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合の持つ<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Element<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型がクラスでも<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>@objc<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>プロトコルでもない場合、要素のブリッジに必要なあらゆることが要素それぞれの最初のアクセスで起こります、それで集合の内容を使う最初の演算（例えば、帰属テスト）は、O(<bpt i="8" x="8">&lt;e8&gt;</bpt>n<ept i="8">&lt;/e8&gt;</ept>)をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the static type of the value passed to <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>type(of:)<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> is constrained to a class or protocol, you can use that metatype to access initializers or other static members of the class or protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>type(of:)<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>に渡される値の静的型があるクラスまたはプロトコルに制約される場合、あなたはそのメタタイプを使うことでイニシャライザやそのクラスまたはプロトコルの他の静的メンバーにアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the subscript is used as the left side of an assignment, the memory at <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>p + i<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> must be uninitialized or the pointer’s <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Pointee<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type must be a trivial type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字が引数の左側で使われる場合、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>p + i<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>でのメモリは初期化されない状態にされなければなりません、またポインタのもつ<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Pointee<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型は自明型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When these invalid strings are parsed by the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Double<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> failable initializer, the example uses the nil-coalescing operator (<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>??<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>) to provide NaN as a fallback value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それら無効な文字列が<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Double<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の失敗できるイニシャライザによって解析される場合のため、この例はnil合体演算子（<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>??<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>）を使ってNaNをフォールバック（頼みの綱の、予備の）値として提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When using an empty array literal, specify the type of the variable or constant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の配列リテラルを使う時は、変数または定数の型を指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you access memory through an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance, the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type must be consistent with the bound type of the memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがメモリに<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを通してアクセスする時、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Pointee<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型はそのメモリの束縛される型と一致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you access memory through an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance, the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Pointee<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type must be consistent with the bound type of the memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがメモリに<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを通してアクセスする時、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Pointee<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> 型はそのメモリの束縛される型と一致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you add elements to an array and that array begins to exceed its reserved capacity, the array allocates a larger region of memory and copies its elements into the new storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがいくらかの要素を配列に加えてその配列がそれの確保した容量を超え始める時、配列はより大きなメモリ領域を割り当てて、それの要素をその新しいストレージ（貯蔵場所）にコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you add to or subtract from a raw pointer, the result is a new raw pointer offset by that number of bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが生のポインタに加算または減算する時、結果はそのバイト数をオフセットした（補った、埋め合わせた）新しい生のポインタです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you add to or subtract from an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance, the result is a new pointer of the same type, offset by that number of instances of the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Pointee<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスに加えたりそれから引いたりする場合、結果は同じ型の新しいポインタです、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Pointee<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型のインスタンスの数によってオフセットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you add to or subtract from an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance, the result is a new pointer of the same type, offset by that number of instances of the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Pointee<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスに加えたりそれから引いたりする場合、結果は同じ型の新しいポインタです、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Pointee<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>型のインスタンスの数によってオフセットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you allocate memory, always remember to deallocate once you’re finished.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがメモリをアロケートする場合、あなたがやり終えるやいなやデアロケートするのを常に忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you are operating on many values, this behavior is valuable because operations on NaN simply forward the value and don’t cause runtime errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが沢山の値に演算を行っている時、この挙動は有益です、なぜならNaNに関する演算は単にその値を次に伝えて実行時エラーを起こさないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you assign a value for a key and that key already exists, the dictionary overwrites the existing value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある値をあるキーに割り当てるそしてそのキーが既に存在する場合、辞書は既存の値を上書きします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you call a C function using a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>String<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, Swift automatically creates a buffer of UTF-8 code units and passes a pointer to that buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがC関数を<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>String<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を使って呼び出すとき、Swiftは自動的にUTF-8コード単位のバッファを作成してポインタをそのバッファへ渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you call a function that does not fully specify its parameters’ types, use the type-cast operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>as<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to specify the type of an array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが完全にそれのパラメータの型を指定しない関数を呼び出す場合は、型キャスト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>as<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って配列リテラルの型を指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you create a binary integer from a floating-point value using the default initializer, the value is rounded toward zero before the range is checked.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがバイナリ整数をある浮動小数点力省略時のイニシャライザを使って作成するとき、その値は範囲が検査される前にゼロへの丸めをされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you create a constant or variable using one of the Boolean literals <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the resulting type is determined by the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Boolean<ph x="6">&lt;w6/&gt;</ph>Literal<ph x="7">&lt;w7/&gt;</ph>Type<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> alias.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが定数や変数をブールリテラル<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>false<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使って作成するとき、結果の型は<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Boolean<ph x="6">&lt;w6/&gt;</ph>Literal<ph x="7">&lt;w7/&gt;</ph>Type<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>エイリアスによって決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you create a slice of a string, a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Substring<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is the result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある文字列のスライスを作成している場合、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Substring<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you create an index into a reversed collection using <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, an index from the underlying collection, the resulting index is the position of the element <bpt i="2" x="2">&lt;e2&gt;</bpt>before<ept i="2">&lt;/e2&gt;</ept> the element referenced by <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>base<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが逆にされたコレクションへのインデックスを、基礎をなすコレクションからのインデックス<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って作成する時、結果のインデックスは<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>base<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>によって参照される要素の<bpt i="2" x="2">&lt;e2&gt;</bpt>前<ept i="2">&lt;/e2&gt;</ept>の要素の位置です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you create an index into a reversed collection using the index passed as <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, an index from the underlying collection, the resulting index is the position of the element <bpt i="2" x="2">&lt;e2&gt;</bpt>before<ept i="2">&lt;/e2&gt;</ept> the element referenced by <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>base<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが逆にされたコレクションへのインデックスを、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡されたインデックス、基礎をなすコレクションからのインデックスを使って作成する時、結果のインデックスは<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>base<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>によって参照される要素の<bpt i="2" x="2">&lt;e2&gt;</bpt>前<ept i="2">&lt;/e2&gt;</ept>の要素の位置です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you define an enumeration without associated values, it gains <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Hashable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> conformance automatically, and you can add <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Hashable<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> conformance to your other custom types by adding a single <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>hash<ph x="10">&lt;w10/&gt;</ph>Value<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが列挙を関連値なしで定義するとき、それは<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Hashable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>準拠を自動的に手に入れます、そしてあなたは<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Hashable<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>準拠をあなたのあつらえの型に加えることがただ１つだけ<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>hash<ph x="10">&lt;w10/&gt;</ph>Value<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロパティを加えることによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you do, all known <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>@objc<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> class methods and properties are available as implicitly unwrapped optional methods and properties, respectively.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがそうする場合、全ての既知の<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>@objc<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>クラスのメソッドおよびプロパティは、暗黙的にアンラップされるオプショナルのメソッドおよびプロパティとしてそれぞれが利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you do, use a structure to represent errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがそうする場合は、構造体を使ってエラーを表してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you have a type instead of an instance, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;T&gt;.size<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> static property instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがインスタンスではなくある型を持つ場合、代わりに<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;T&gt;.size<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>静的プロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you have a type instead of an instance, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;T&gt;.stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> static property instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがインスタンスではなくある型を持つ場合、代わりに<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Memory<ph x="2">&lt;w2/&gt;</ph>Layout&lt;T&gt;.stride<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>静的プロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you know how many new values you’re adding to a dictionary, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(minimum<ph x="2">&lt;w2/&gt;</ph>Capacity:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer to allocate the correct amount of buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのくらい多くの新しい値をあなたが辞書に加えることになるかあなたが知っている場合は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(minimum<ph x="2">&lt;w2/&gt;</ph>Capacity:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを使って正確な量のバッファを割り当ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you match against a range in a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>case<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> statement, this operator is called behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>case<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>文内である範囲に対してマッチを行う場合、この演算子が舞台裏で呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you match against an <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Equatable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> value in a <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>case<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> statement, this operator is called behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Equatable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>値に対して<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>case<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>文でマッチを行うとき、この演算子が舞台裏で呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you need a range that includes the last element of an array, use the half-open range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>..&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) with <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが配列の最後の要素を含む範囲を必要とするならば、半開範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>..&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>end<ph x="4">&lt;w4/&gt;</ph>Index<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>とともに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you need to access APIs that require data in an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSArray<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance instead of <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Array<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, use the type-cast operator (<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>as<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>) to bridge your instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>NSArray<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスでのデータを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Array<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の代わりに期待するAPIにあなたがアクセスする必要がある場合、型キャスト演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>as<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）を使ってあなたのインスタンスをブリッジしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you need to check whether your collection is empty, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Empty<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property instead of checking that the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> property is equal to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコレクションが空かどうか確認する必要がある場合、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>is<ph x="2">&lt;w2/&gt;</ph>Empty<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>count<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロパティがゼロかどうか調べる代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you need to create an instance of an option set, assign one of the type’s static members to your variable or constant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあるオプションセットのインスタンスを作成する必要がある場合は、その型のもつ静的メンバの１つをあなたの変数または定数に割り当ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you need to know the length of a string, you must first consider what you’ll use the length for.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある文字列の長さを知る必要がある場合、あなたが最初に考えなければならないのは、あなたが使う長さは何に対するものかということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you need to perform an operation on all of an array’s elements, use a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loop to iterate through the array’s contents.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある配列の要素のすべてである演算を実行することを必要とするならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使って配列の内容の始めから終わりまで反復適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you need to permanently rebind memory to a different type, first obtain a raw pointer to the memory and then call the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bind<ph x="2">&lt;w2/&gt;</ph>Memory(to:<ph x="3">&lt;w3/&gt;</ph>capacity:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method on the raw pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが永続的にメモリを異なる型へ再束縛する必要があるならば、まずメモリに対する生のポインタを取得して、それから<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>bind<ph x="2">&lt;w2/&gt;</ph>Memory(to:<ph x="3">&lt;w3/&gt;</ph>capacity:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを生のポインタ上で呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you need to store a substring or pass it to a function that requires a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance, convert it using the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ph x="4">&lt;w4/&gt;</ph>.init(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが下位文字列を格納するまたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを要求する関数にそれを渡す必要がある場合、それを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>String<ph x="4">&lt;w4/&gt;</ph>.init(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>イニシャライザを使って変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you only need to temporarily access a pointer’s memory as a different type, use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>with<ph x="2">&lt;w2/&gt;</ph>Memory<ph x="3">&lt;w3/&gt;</ph>Rebound(to:<ph x="4">&lt;w4/&gt;</ph>capacity:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがポインタのもつメモリに異なる型として一時的にアクセスする必要があるだけならば、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>with<ph x="2">&lt;w2/&gt;</ph>Memory<ph x="3">&lt;w3/&gt;</ph>Rebound(to:<ph x="4">&lt;w4/&gt;</ph>capacity:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you pass <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>is<ph x="4">&lt;w4/&gt;</ph>Repairing<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, this method replaces ill-formed sequences with the Unicode replacement character (<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>"\u{FFFD}"<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>); otherwise, an ill-formed sequence causes this method to stop decoding and return <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>true<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>is<ph x="4">&lt;w4/&gt;</ph>Repairing<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>として渡すとき、このメソッドは誤形式シーケンスをユニコード代替文字（<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>"\u{FFFD}"<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>）で置き換えます；そうでなければ、ある誤形式シーケンスはこのメソッドがエンコードを停止して<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>nil<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>を返すことを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you provide just those methods, the standard library provides default implementations for all other arithmetic methods and operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが単にそれらのメソッドだけを提供する場合、標準ライブラリが省略時の実装をすべての他の算術演算メソッドと演算子に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Object<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as a concrete type, you have at your disposal every <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>@objc<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method and property—that is, methods and properties imported from Objective-C or marked with the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>@objc<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Object<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を具体的な型として使うとき、すべての<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>@objc<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドやプロパティ — すなわち、Objective-Cからインポートされるか、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>@objc<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>属性で印されるメソッドとプロパティ — があなたの自由になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you use arrays, dictionaries, views of a string’s contents and other types, you benefit from the operations that the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol declares and implements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが配列、辞書、文字列の内容のビュー、および他の型を使うとき、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Collection<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルが宣言および実装する演算からの恩恵を受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you use string interpolation, the following steps occur:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが文字列補間を使うとき、以下の段階が発生します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you use this type, you become partially responsible for keeping the object alive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこの型を使う場合、あなたはオブジェクト存続を保っていることに対して部分的に責任を負うようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you want to sort a collection of elements that doesn’t conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, pass a closure to this method that returns <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> when the first element passed should be ordered before the second.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない要素からなるコレクションをソートしたい場合、あるクロージャをこのメソッドに渡してください、それは渡された最初の要素が２番目の前に並べられるべき場合は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you want to sort a collection of elements that don’t conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, pass a predicate to this method that returns <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> when the first element passed should be ordered before the second.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない要素からなるコレクションをソートしたい場合、渡された最初の要素が２番目の前に並べられるべき場合は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返す述部をこのメソッドに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you want to sort a sequence of elements that don’t conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, pass a predicate to this method that returns <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> when the first element passed should be ordered before the second.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない要素からなるシーケンスをソートしたい場合、渡された最初の要素が２番目の前に並べられるべき場合は<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>true<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を返す述部をこのメソッドに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you’re certain that an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> contains a value, you can unconditionally unwrap the value by using the forced unwrap operator (postfix <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>!<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスが値を含むことを確信している場合、あなたはその値を無条件にアンラップすることが強制アンラップ演算子（後置<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>!<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you’re ready to create a new <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ph x="2">&lt;w2/&gt;</ph>Pairs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance, use a dictionary literal as the parameter to the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Int<ph x="5">&lt;w5/&gt;</ph>Pairs<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが新しい<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Int<ph x="2">&lt;w2/&gt;</ph>Pairs<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを作成する準備ができたら、辞書リテラルをパラメータとして<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Int<ph x="5">&lt;w5/&gt;</ph>Pairs<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>イニシャライザに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever possible, Swift’s compiler infers the full intended type of your array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可能な時はいつでも、Swiftのコンパイラはあなたの配列リテラルの完全な意図される型を推論します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever you use a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loop with an array, set, or any other collection or sequence, you’re using that type’s iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ループを配列、集合、または何らかの他のコレクションやシーケンスとともに使うときはいつでも、あなたはこの型のイテレータを使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever you use multiple iterators (or <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loops) over a single sequence, be sure you know that the specific sequence supports repeated iteration, either because you know its concrete type or because the sequence is also constrained to the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが複数のイテレータ（または<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ループ）をある単一のシーケンスに対して使うときはいつでも、その特定のシーケンスが繰り返される反復をサポートすると確実にあなたが知っているようにしてください、あなたがそれの具体的な型を知っているからかもしくはそのシーケンスもまた<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Collection<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルに制約されるからかのどちらかで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Where in some languages you might pass a starting index into an <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>index<ph x="4">&lt;w4/&gt;</ph>Of<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method to find the second day, in Swift you perform the same operation on a slice of the original array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>なんらかの言語であなたがある開始インデックスを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>index<ph x="4">&lt;w4/&gt;</ph>Of<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドに渡して２つ目の日付を見つけるであろうところで、Swiftではあなたは同じ演算をオリジナル配列のスライス上で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whether the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has an entry for the given key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Decoder<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が与えられたキーに対して登録項目を持つかどうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whether the dictionary should keep its underlying buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書がそれの基礎をなすバッファを保つべきかどうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whether the encountered value was null.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>出くわした値がnullだったかどうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whether using an option set or creating your own, you use the raw value of an option set instance to store the instance’s bitfield.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるオプションセットを使用するかあなた自身で作成する場合、あなたはオプションセットインスタンスの生の値を使って、そのインスタンスの持つビットフィールドを格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whichever of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> has greater magnitude, or whichever is a number if the other is NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のどちらがより大きい規模を持つか、または他方がNaNならば数である方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whichever of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> has lesser magnitude, or whichever is a number if the other is NaN.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>x<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>y<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のどちらがより小さい規模を持つか、または他方がNaNならば数である方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>外見上は単純である一方、この能力はあなたにたくさんの演算へのアクセスを与え、それはあなたがあらゆるシーケンス上で実行可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Raw<ph x="2">&lt;w2/&gt;</ph>Representable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type, you can switch back and forth between a custom type and an associated <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Raw<ph x="5">&lt;w5/&gt;</ph>Value<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type without losing the value of the original <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Raw<ph x="8">&lt;w8/&gt;</ph>Representable<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Raw<ph x="2">&lt;w2/&gt;</ph>Representable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型で、あなたはあつらえの型と関連<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Raw<ph x="5">&lt;w5/&gt;</ph>Value<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型との間を行ったり戻ったり切り替えることが元の<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Raw<ph x="8">&lt;w8/&gt;</ph>Representable<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>型の値の損失なしに可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With pointer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and distance <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>n<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>p<ph x="6">&lt;w6/&gt;</ph>.advanced(by: n)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is equivalent to <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>p + n<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインタ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と隔たり<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>n<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>では、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>p<ph x="6">&lt;w6/&gt;</ph>.advanced(by: n)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の結果は<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>p + n<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>と同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With pointers <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>q<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the result of <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>p<ph x="6">&lt;w6/&gt;</ph>.distance(to: q)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is equivalent to <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>q - p<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインタ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>p<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>q<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>では、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>p<ph x="6">&lt;w6/&gt;</ph>.distance(to: q)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の結果は<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>q - p<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>と同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With those elements defined, the inherited <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>make<ph x="10">&lt;w10/&gt;</ph>Iterator()<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> method satisfies the requirements of the <bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Sequence<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定義されるそれらの要素とともに、継承される<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>make<ph x="10">&lt;w10/&gt;</ph>Iterator()<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>メソッドが<bpt i="11" x="11">&lt;c11&gt;</bpt><bpt i="12" x="12">&lt;s12&gt;</bpt>Sequence<ept i="12">&lt;/s12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>プロトコルの要件を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Without any other information, Swift creates an array that includes the specified values, automatically inferring the array’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの他の情報なしでは、Swiftは指定された値を含んでいる配列を、自動的にその配列の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型を推論して作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Work with fixed-width numeric types of different sizes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>異なるサイズの固定長数値型を扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Work with prefix, postfix, and infix operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前置、後置、および中置演算子を扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Work with text using Unicode-safe strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコード安全な文字列を使ってテキストを扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working with Binary Representation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バイナリ表現を扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working with Byte Order</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バイト順を扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working with Encodings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エンコーディングを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working with Foundation Ranges</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Foundation Rangeを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working with Memory Addresses</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリアドレスを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working with Paths</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パスを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working with Property Lists</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティリストを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working with String Views</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列ビューを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working with URLs</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>URLを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working with a Character's Unicode Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字のユニコード値を扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Wrap each expression in a string interpolation in parentheses, prefixed by a backslash.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列補間の中の式それぞれを丸括弧で包んで、バックスラッシュを前においてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Wrappers for Algorithms</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アルゴリズムに対するラッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writable Key Paths</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>書き込み可能なキーパス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write generic code that works with any collection, or build your own collection types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかのコレクションを使って作業する総括的なコードを記載します、またはあなた独自のコレクション型を組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write generic code that works with any numeric type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの数値型を使って作業する総括的なコードを記載します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writes a textual representation of this instance into the given output stream.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスのテキスト表現を与えられた出力ストリームへ書き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writes the character into the given output stream.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その文字を与えられた出力ストリームへと書き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writes the contents of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to a file at a given path using a given encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の内容を指定されたパスによって指定されたファイルに指定された符号化を使って書き込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writes the contents of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to the URL specified by url using the specified encoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の内容をurlによって指定されたURLへ指定された符号化を使って書き込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writes the given <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> of characters into <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>buffer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> in a given <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>encoding<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, without any allocations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の文字を<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>buffer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>へと与えられた<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>encoding<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>で書き込みます、なんらアロケーションなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writes the string into the given output stream.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた出力ストリームへ文字列を書き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writes the textual representation of the Unicode scalar into the given output stream.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコードスカラーのテキスト表現を与えられた出力ストリームに書き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writes the textual representations of the given items into the given output stream.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた要素のテキスト表現を与えられた出力ストリームに書き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writes the textual representations of the given items into the standard output.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた項目のテキスト表現を標準出力に書き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writes the textual representations of the given items most suitable for debugging into the given output stream.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた項目の、デバッグに最も適するテキスト表現を、与えられた出力ストリームに書き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writes the textual representations of the given items most suitable for debugging into the standard output.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた項目の、デバッグに最も適するテキスト表現を、標準出力に書き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writing is O(1) unless the array’s storage is shared with another array, in which case writing is O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>書き込みはO(1)です、配列のストレージが他の配列と共有されない限りは、その場合には書き込みはO(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)です、そこで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は配列の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writing to a File or URL</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ファイルまたはURLに書き込む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writing to a Text Stream</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>テキストストリームを書き出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writing to typed memory as raw bytes must only be performed when the bound type is a trivial type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付メモリに生のバイトとして書き込むことは、その束縛型が自明型である場合にのみ実行されるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You also use this method to sort elements that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol in descending order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、このメソッドを使って<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する要素を降順でソートすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You are expected to construct and—if necessary—destroy objects there yourself, using the APIs on <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Pointer&lt;Element&gt;<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、オブジェクトの組み立てと—必要ならば—破壊をそこであなた自身で、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>Unsafe<ph x="5">&lt;w5/&gt;</ph>Mutable<ph x="6">&lt;w6/&gt;</ph>Pointer&lt;Element&gt;<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>上でAPIを使って行うことを当然期待されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You are in charge of managing the allocated memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、アロケートされたメモリの管理を任されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You are responsible for handling the life cycle of any memory you work with through unsafe pointers to avoid leaks or undefined behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはリークや未定義挙動を避けるために、あなたが安全でないポインタを通して扱うあらゆるメモリの生涯の処理に責任があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You are responsible for handling the life cycle of any memory you work with through unsafe pointers, to avoid leaks or undefined behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、リークや未定義挙動を避けるために、あなたが安全でないポインタを通して扱うあらゆるメモリの生涯の処理に責任があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can access a slice of a collection through its ranged subscript or by calling methods like <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>prefix(while:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>suffix(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるコレクションのあるスライスにそれの範囲指定された添え字を通して、または<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>prefix(while:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>suffix(_:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のようなメソッドを呼び出すことによってアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can access a string’s view of UTF-16 code units by using its <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは文字列の持つビューのUTF-16コード単位にアクセスすることが、それの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使うことで行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can access a string’s view of UTF-8 code units by using its <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、文字列のもつUTF-8コード単位ビューにそれの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使うことによってアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can access a string’s view of Unicode scalar values by using its <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは文字列の持つビューのユニコードスカラー値にアクセスすることが、それの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使うことで行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can access an element of a collection through its subscript with any valid index except the collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property, a “past the end” index that does not correspond with any element of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはコレクションの要素にアクセスすることがそれの添え字を通して行えます、それにはあらゆる有効なインデックスを含みますが、コレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>end<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは除きます、それはコレクションのどの要素にも対応しない「終わりを過ぎた」インデックスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can access individual array elements through a subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは個々の配列要素に添え字を通してアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can add new elements in the middle of an array by using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>insert(_:<ph x="2">&lt;w2/&gt;</ph>at:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method for single elements and by using <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>insert(contents<ph x="5">&lt;w5/&gt;</ph>Of:<ph x="6">&lt;w6/&gt;</ph>at:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> to insert multiple elements from another collection or array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、新しい要素を配列の中ほどに追加することが、単一の項目には<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>insert(_:<ph x="2">&lt;w2/&gt;</ph>at:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、そして別のコレクションや配列リテラルから複数の項目を挿入するには<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>insert(contents<ph x="5">&lt;w5/&gt;</ph>Of:<ph x="6">&lt;w6/&gt;</ph>at:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also combine, exclude, or subtract the elements of two sets:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、結合、排他、または差引を行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also create Unicode scalar values directly from their numeric representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、ユニコードスカラー値を直接にそれらの数値表現から作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also iterate over this type of partial range using a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loop, or call any sequence method that doesn’t require that the sequence is finite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、この型の部分範囲の全体にわたって<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ループを使って反復適用すること、または何らかのシーケンスメソッドでそのシーケンスが有限であることを要求しないものを呼び出すことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also perform unconditional optional chaining by using the postfix <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>!<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、無条件のオプショナル連鎖を実行することが、後置<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>!<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算子を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also update, modify, or remove keys and values from a dictionary using the key-based subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、辞書のキーと値の更新、修正、または削除をキー基盤の添え字を使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use inout syntax to pass a mutable pointer to the elements of an array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、インアウト構文を使って、可変ポインタを配列の要素へ渡せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use literals to specify values for one or more cases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、リテラルを使うことで値を１つ以上のケース節に指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use subscript notation to access the value in memory at a specific offset.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、添え字表記法を使ってメモリ中の値に特定のオフセットでアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use this initializer to convert a complex sequence or collection type back to an array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまたこのイニシャライザを使って、逆に複雑なシーケンスまたはコレクション型を配列へと変換することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use this operator to compare a non-optional value to an optional that wraps the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、この演算子を使って非オプショナル値を、同じ型をラップするオプショナル値と比較することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can assign a dictionary literal to a variable or constant or pass it to a function that expects a dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、辞書リテラルを変数や定数に代入したり、それを辞書を予期する関数に渡したりできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can bridge between <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSDictionary<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> using the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>as<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSDictionary<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の間をブリッジすることが<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>as<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>演算子を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can bridge between <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSSet<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> using the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>as<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>NSSet<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の間を<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>as<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>演算子を使ってブリッジできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can call any method on the slices that you might have called on the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>absences<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはどんなメソッドでもそれらスライス上で呼び出すことができます、それはあなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>absences<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列上で呼び出すであろうものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can check the equality of instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the equal-to operator (<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>==<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスの同等性を同等演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>==<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）使って確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can check the inequality of instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the not-equal-to operator (<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>!=<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスの不等性を不等演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>!=<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）使って確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can compare instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the greater-than operator (<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>&gt;<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>), even if the two instances are of different types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスをより大きい演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>&gt;<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）を使って比較できます、２つのインスタンスが異なる型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can compare instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the greater-than-or-equal-to operator (<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>&gt;=<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>), even if the two instances are of different types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスをより大きいか等しい演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>&gt;=<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）使って比較できます、２つのインスタンスが異なる型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can compare instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the less-than operator (<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>&lt;<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>), even if the two instances are of different types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスをより小さい演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>&lt;<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）を使って比較できます、２つのインスタンスが異なる型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can compare instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the less-than-or-equal-to operator (<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>&lt;=<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>), even if the two instances are of different types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスをより小さいか等しい演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>&lt;=<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）使って比較できます、２つのインスタンスが異なる型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can convert a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ph x="2">&lt;w2/&gt;</ph>.Character<ph x="3">&lt;w3/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance back into a string using the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type’s <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>init(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ph x="2">&lt;w2/&gt;</ph>.Character<ph x="3">&lt;w3/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを逆にひとつの文字列へと変換することが、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>String<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型の<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>init(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>イニシャライザを使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can convert a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ph x="2">&lt;w2/&gt;</ph>.Unicode<ph x="3">&lt;w3/&gt;</ph>Scalar<ph x="4">&lt;w4/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance back into a string using the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>String<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> type’s <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>init(_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>String<ph x="2">&lt;w2/&gt;</ph>.Unicode<ph x="3">&lt;w3/&gt;</ph>Scalar<ph x="4">&lt;w4/&gt;</ph>View<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを逆にひとつの文字列へと変換することが、<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>String<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>型の<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>init(_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>イニシャライザを使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can convert an index into one of a string’s views to an index into another view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある文字列の持つビューの１つへのインデックスを別のビューへのインデックスに変換することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can convert between indices of the different string views by using conversion initializers and the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>same<ph x="2">&lt;w2/&gt;</ph>Position(in:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method overloads.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは異なる文字列ビューのインデックス間で変換することが、変換イニシャライザおよび<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>same<ph x="2">&lt;w2/&gt;</ph>Position(in:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> メソッドオーバーロードを使うことで行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Counter<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance from an integer value between 1 and 5 by using the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>init?(raw<ph x="4">&lt;w4/&gt;</ph>Value:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> initializer declared in the <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Raw<ph x="7">&lt;w7/&gt;</ph>Representable<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Counter<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを１と５の間の整数値から作成することが、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Raw<ph x="4">&lt;w4/&gt;</ph>Representable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルにおいて宣言される<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>init?(raw<ph x="7">&lt;w7/&gt;</ph>Value:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>イニシャライザを使うことによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance by using a string literal that contains a single character representing exactly one Unicode scalar value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unicode<ph x="2">&lt;w2/&gt;</ph>.Scalar<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを、厳密に１つのユニコードスカラー値を表している単一の文字を含んでいる文字列リテラルを使うことによって作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create a countable partial range over any type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Strideable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol and uses an integer as its associated <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、可付番部分範囲を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Strideable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する何らかの型に対して作成して、整数をそれの関連<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create a countable range over any type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Strideable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol and uses an integer as its associated <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、可付番範囲を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Strideable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する何らかの型に対して作成して、整数をそれの関連<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Stride<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create a mirror for any type using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mirror(reflect:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer, but if you are not satisfied with the mirror supplied for your type by default, you can make it conform to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>Reflectable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and return a custom <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Mirror<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはミラーを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Mirror(reflect:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを使ってあらゆる型に対して作成できます、しかしあなたが初期状態であなたの型に提供されるミラーに満足していないならば、あなたはそれを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Custom<ph x="4">&lt;w4/&gt;</ph>Reflectable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するようにしてあつらえの<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>Mirror<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスを返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create a set with any element type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Hashable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Hashable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するあらゆる要素型を使って集合を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create an empty array by specifying the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type of your array in the declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは空の配列を、あなたの配列の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Element<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型をその宣言において指定することで作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create new instances of a type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol from a floating-point number or another binary integer of any type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある型の新しいインスタンスで<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Binary<ph x="2">&lt;w2/&gt;</ph>Integer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するものを、浮動小数点数またはどんな型であれ別のバイナリ整数から作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create new strings using string literals or string interpolations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは新しい文字列を、文字列リテラルまたは文字列補間を使って作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can decompose the tuple in a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loop, which calls <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>make<ph x="6">&lt;w6/&gt;</ph>Iterator()<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> behind the scenes, or when calling the iterator’s <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>next()<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> method directly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこのタプルを分解することが、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>make<ph x="6">&lt;w6/&gt;</ph>Iterator()<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を各場面の裏側で呼ぶ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> ループにおいて、またはイテレータの持つ<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>next()<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>メソッドを直に呼び出すときに行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can find a complete set of a collection’s valid indices by starting with the collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property and finding every successor up to, and including, the <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはコレクションの有効なインデックスの完全な一揃いを見つけることが、そのコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティで開始して、すべての後に続くものを<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロパティまで、それを含めて、見つけ出すことによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can initialize a variable of any of these types using a string literal that holds a single Unicode scalar.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、これらのいずれかの型の変数を初期化することが、単一のユニコードスカラーを保持する文字列リテラルを使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can initialize a variable or constant of any of these types by assigning a floating-point literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、これらの型どれかの変数または定数を、浮動小数点リテラルを割り当てることによって初期化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can initialize a variable or constant of any of these types by assigning an integer literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、それらの型のどれかの変数や定数を初期化することが、整数リテラルを割り当てることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can initialize a variable or constant of any of these types using a string literal that holds a single character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、これらの型のどれかの変数または定数を、単一の文字を保持する文字列リテラルを使って初期化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can initialize a variable or constant of either of these types using a string literal of any length.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、それらの型のいずれかの変数や定数を初期化することが随意の長さの文字列リテラルを使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can initialize the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Countdown<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> sequence with a starting integer and then iterate over the count down to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Countdown<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>シーケンスをある開始点整数で初期化してそれからカウントダウンをゼロまでずっと反復することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can iterate over a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>From<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance using a <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>for<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>-<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>in<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> loop, or call any sequence method that doesn’t require that the sequence is finite.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>From<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンス全体にわたって<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>for<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>-<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>in<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>ループを使って反復適用していくこと、または何らかのシーケンスメソッドでシーケンスが有限であることを要求しないものを呼び出すことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can iterate over a dictionary using a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loop, decomposing each key-value pair into the elements of a tuple.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは辞書全体にわたって反復適用していくことが、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ループを使うことで、各キー値ペアをタプルの要素へと分解しながら可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can iterate through a set’s unordered elements with a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、集合の持つ順序付けられない要素を始めから終わりまで反復することが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>で可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can modify a set in place by using these methods’ mutating counterparts: <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>form<ph x="2">&lt;w2/&gt;</ph>Union(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>form<ph x="5">&lt;w5/&gt;</ph>Intersection(_:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>form<ph x="8">&lt;w8/&gt;</ph>Symmetric<ph x="9">&lt;w9/&gt;</ph>Difference(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, and <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>subtract(_:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはある集合をその場で修正することがこれらのメソッドの可変の相当物：<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>form<ph x="2">&lt;w2/&gt;</ph>Union(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>form<ph x="5">&lt;w5/&gt;</ph>Intersection(_:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>form<ph x="8">&lt;w8/&gt;</ph>Symmetric<ph x="9">&lt;w9/&gt;</ph>Difference(_:)<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>subtract(_:)<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>を使うことで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can override any of the protocol’s required methods to provide your own custom implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、何らかのこのプロトコルの持つ必須メソッドをオーバーライドして、あなた独自のあつらえの実装を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can pass only valid indices to collection operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは有効なインデックスだけをコレクション演算子に渡せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can pass zero or more items to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>debug<ph x="2">&lt;w2/&gt;</ph>Print(_:<ph x="3">&lt;w3/&gt;</ph>separator:<ph x="4">&lt;w4/&gt;</ph>terminator:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ゼロ個以上の項目を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>debug<ph x="2">&lt;w2/&gt;</ph>Print(_:<ph x="3">&lt;w3/&gt;</ph>separator:<ph x="4">&lt;w4/&gt;</ph>terminator:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数に渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can pass zero or more items to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>debug<ph x="2">&lt;w2/&gt;</ph>Print(_:<ph x="3">&lt;w3/&gt;</ph>separator:<ph x="4">&lt;w4/&gt;</ph>terminator:<ph x="5">&lt;w5/&gt;</ph>to:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ゼロ個以上の項目を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>debug<ph x="2">&lt;w2/&gt;</ph>Print(_:<ph x="3">&lt;w3/&gt;</ph>separator:<ph x="4">&lt;w4/&gt;</ph>terminator:<ph x="5">&lt;w5/&gt;</ph>to:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数に渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can pass zero or more items to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(_:<ph x="2">&lt;w2/&gt;</ph>separator:<ph x="3">&lt;w3/&gt;</ph>terminator:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ゼロ個以上の項目を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(_:<ph x="2">&lt;w2/&gt;</ph>separator:<ph x="3">&lt;w3/&gt;</ph>terminator:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数に渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can pass zero or more items to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(_:<ph x="2">&lt;w2/&gt;</ph>separator:<ph x="3">&lt;w3/&gt;</ph>terminator:<ph x="4">&lt;w4/&gt;</ph>to:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ゼロ個以上の項目を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(_:<ph x="2">&lt;w2/&gt;</ph>separator:<ph x="3">&lt;w3/&gt;</ph>terminator:<ph x="4">&lt;w4/&gt;</ph>to:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数に渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can perform many string operations on a substring.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、多くの文字列演算を買い文字列上で行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can replace an existing element with a new value by assigning the new value to the subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、既存の要素を新しい値で置き換えることが、新しい値をその添え字に代入することで行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can retrieve the same slice using the string’s ranged subscript, which takes a range expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、同じスライスを文字列の範囲指定された添え字を使って取って来ることができます、それは範囲式をとっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can reverse a collection without allocating new space for its elements by calling this <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reversed()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるコレクションを逆順にすることがそれの要素に対して新しい空間を割り当てることなく<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>reversed()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can search a dictionary’s contents for a particular value using the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>contains(where:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>index(where:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> methods supplied by default implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある特定の値を求めて辞書の持つ内容を捜すことが、省略時の実装で提供される<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>contains(where:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>index(where:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドを使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can send the output of the standard library’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(_:<ph x="2">&lt;w2/&gt;</ph>to:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>dump(_:<ph x="5">&lt;w5/&gt;</ph>to:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> functions to an instance of a type that conforms to the <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Text<ph x="8">&lt;w8/&gt;</ph>Output<ph x="9">&lt;w9/&gt;</ph>Stream<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> protocol instead of to standard output.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、標準ライブラリの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>print(_:<ph x="2">&lt;w2/&gt;</ph>to:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>dump(_:<ph x="5">&lt;w5/&gt;</ph>to:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>関数の出力を<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Text<ph x="8">&lt;w8/&gt;</ph>Output<ph x="9">&lt;w9/&gt;</ph>Stream<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>プロトコルに準拠する型のインスタンスに送ることが、標準出力に送る代わりに行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can sort any collection of elements that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol by calling this method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する要素からなるあらゆる配列をこのメソッドを呼び出すことによってソートできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can sort any mutable collection of elements that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol by calling this method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する要素からなるあらゆる可変の配列をこのメソッドを呼び出すことによってソートできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can sort any sequence of elements that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol by calling this method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはいくらかの要素からなる何らかのシーケンスで<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するものをこのメソッドを呼び出すことによってソートする（並び替える）ことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこのようなインデックスを変数に格納して、それらを幾つかあるコレクションアルゴリズムに渡すことや、相当する要素にアクセスするためにそれらを後で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can store mixed-type keys in dictionaries and other collections that require <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Hashable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance by wrapping mixed-type keys in <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Any<ph x="4">&lt;w4/&gt;</ph>Hashable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instances:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは混成型のキーを様々な辞書や他のコレクションに格納できます、それらは混成型キーを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Any<ph x="4">&lt;w4/&gt;</ph>Hashable<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスの中へのラップする<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Hashable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠を必要とします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can subscript a collection with any valid index other than the collection’s end index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、そのコレクションの末尾インデックスの以外のあらゆる有効なインデックスで、コレクションに対して添え字を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can subscript an array with any integer from zero up to, but not including, the count of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ゼロから配列の総数まで、しかしそれを含めず、任意の整数で添え字を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Iterator<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to hide the type signature of a more complex iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Iterator<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って、あるより複雑なイテレータの型シグネチャを隠すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Memory<ph x="2">&lt;w2/&gt;</ph>Layout<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as a source of information about a type when allocating or binding memory using unsafe pointers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Memory<ph x="2">&lt;w2/&gt;</ph>Layout<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をある型についての情報源として使うことが、安全でないポインタを使ってメモリをアロケートまたはバインドする時に可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numeric<ph x="2">&lt;w2/&gt;</ph>Cast(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to convert a value when the destination type can be inferred from the context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>numeric<ph x="2">&lt;w2/&gt;</ph>Cast(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使うことで、行き先の型が前後関係から推論される場合にはある値を変換できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>pop<ph x="2">&lt;w2/&gt;</ph>Last()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to remove the last element of a collection that might be empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>pop<ph x="2">&lt;w2/&gt;</ph>Last()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って、空であるかもしれないコレクションの最後の要素を削除できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>==<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> to check for equality between any two instances or call the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Equatable<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>-constrained <bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>contains(_:)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>==<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を使って何でも２つのインスタンス間の同等性を調べたり、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>Equatable<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>制約の<bpt i="9" x="9">&lt;c9&gt;</bpt><bpt i="10" x="10">&lt;s10&gt;</bpt>contains(_:)<ept i="10">&lt;/s10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>メソッドを呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Closed<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance to quickly check if a value is contained in a particular range of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Closed<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを使うことで、ある値が特定の範囲に属するいくつかの値の中に含まれているかどうか素早く調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>From<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるコレクションのもつインデックスからなる<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>From<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを使うことで、その部分的な範囲の下側の境界からそのコレクションの終わりまでの範囲を表せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>From<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance to quickly check if a value is contained in a particular range of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>From<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを使うことで、ある値が特定の範囲に属するいくつかの値の中に含まれているかどうか素早く調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Through<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるコレクションのインデックスからなる、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Through<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを使うことで、コレクションの始まりからこの部分範囲の上側の境界までの、そしてそれを含んでいる範囲を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Through<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance to quickly check if a value is contained in a particular range of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Through<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを使うことで、ある値が特定の範囲に属するいくつかの値の中に含まれているかどうか素早く調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Up<ph x="4">&lt;w4/&gt;</ph>To<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるコレクションのインデックスからなる、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Up<ph x="4">&lt;w4/&gt;</ph>To<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを使うことで、コレクションの始まりからこの部分範囲の上側の境界までの、そしてそれを含んでいる範囲を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Up<ph x="4">&lt;w4/&gt;</ph>To<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance to quickly check if a value is contained in a particular range of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Up<ph x="4">&lt;w4/&gt;</ph>To<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを使うことで、ある値が特定の範囲に属するいくつかの値の中に含まれているかどうか素早く調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance to quickly check if a value is contained in a particular range of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを使うことで、ある値が特定の範囲に属するいくつかの値の中に含まれているかどうか素早く調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loop or any sequence or collection method with a countable range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ループまたは何らかのシーケンスもしくはコレクションメソッドを可付番範囲とともに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a slice’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property to access its base collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはスライスのもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>base<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使って、それの基盤コレクションにアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Buffer<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance in low level operations to eliminate uniqueness checks and, in release mode, bounds checks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Buffer<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを低レベル演算において使うことで、特有性検査をそして、リリースモードでは、境界検査を省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance in low level operations to eliminate uniqueness checks and, in release mode, bounds checks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを低レベル演算において使うことで、特有性検査をそして、リリースモードでは、境界検査を省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Buffer<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance in low-level operations to eliminate uniqueness checks and release mode bounds checks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Raw<ph x="4">&lt;w4/&gt;</ph>Buffer<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを低水準演算において使用することで、固有性検査とリリースモード境界検査を省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance in low-level operations to eliminate uniqueness checks and release mode bounds checks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Raw<ph x="3">&lt;w3/&gt;</ph>Buffer<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを低水準演算において使用することで、固有性検査とリリースモード境界検査を省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use an array literal anywhere a set is expected by the type context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、型コンテキストによって集合が予期される何処ででも配列リテラルを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use an array literal anywhere an instance of an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Array<ph x="4">&lt;w4/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type is expected: as a value assigned to a variable or constant, as a parameter to a method or initializer, or even as the subject of a nonmutating operation like <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>map(_:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> or <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>filter(_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは配列リテラルを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Expressible<ph x="2">&lt;w2/&gt;</ph>By<ph x="3">&lt;w3/&gt;</ph>Array<ph x="4">&lt;w4/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型が予期されるところはどこででも使うことができます：変数や定数に割り当てられる値として、メソッドやイニシャライザへのパラメータとして、または<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>map(_:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>や<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>filter(_:)<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>のような可変でないの操作のサブジェクトとしてさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use any type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Hashable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol in a set or as a dictionary key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Hashable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するあらゆる型を集合においてまたは辞書キーとして使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use methods like <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>initialize(to:<ph x="2">&lt;w2/&gt;</ph>count:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>initialize(from:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>move<ph x="7">&lt;w7/&gt;</ph>Initialize(from:<ph x="8">&lt;w8/&gt;</ph>count:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> to initialize the memory referenced by a pointer with a value or series of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>initialize(to:<ph x="2">&lt;w2/&gt;</ph>count:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>initialize(from:)<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、そして<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>move<ph x="7">&lt;w7/&gt;</ph>Initialize(from:<ph x="8">&lt;w8/&gt;</ph>count:)<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>のようなメソッドを使うことで、ポインタによって参照されるメモリをある値または一連の値で初期化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use methods like <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>initialize<ph x="2">&lt;w2/&gt;</ph>Memory(as:<ph x="3">&lt;w3/&gt;</ph>from:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>move<ph x="6">&lt;w6/&gt;</ph>Initialize<ph x="7">&lt;w7/&gt;</ph>Memory(as:<ph x="8">&lt;w8/&gt;</ph>from:<ph x="9">&lt;w9/&gt;</ph>count:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> to bind raw memory to a type and initialize it with a value or series of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>initialize<ph x="2">&lt;w2/&gt;</ph>Memory(as:<ph x="3">&lt;w3/&gt;</ph>from:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>move<ph x="6">&lt;w6/&gt;</ph>Initialize<ph x="7">&lt;w7/&gt;</ph>Memory(as:<ph x="8">&lt;w8/&gt;</ph>from:<ph x="9">&lt;w9/&gt;</ph>count:)<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のようなメソッドを使うことで、生のメモリをある型に束縛して、それをある値または一連の値で初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use optional chaining to call the <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>@objc<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> method <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>get<ph x="12">&lt;w12/&gt;</ph>Integer<ph x="13">&lt;w13/&gt;</ph>Value()<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> on <bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>obj<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> safely.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、オプショナル連鎖を使って、<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;s9&gt;</bpt>@objc<ept i="9">&lt;/s9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>メソッド<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;s11&gt;</bpt>get<ph x="12">&lt;w12/&gt;</ph>Integer<ph x="13">&lt;w13/&gt;</ph>Value()<ept i="11">&lt;/s11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>を<bpt i="14" x="14">&lt;c14&gt;</bpt><bpt i="15" x="15">&lt;s15&gt;</bpt>obj<ept i="15">&lt;/s15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>上で安全に呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use relational operators, such as the less-than and equal-to operators (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>==<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>), to compare instances of different binary integer types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、関係演算子、例えばより小さいそして同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>&lt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>そして<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>==<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）などを使って、異なるバイナリ整数型のインスタンス同士を比較できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use sequence or collection methods on the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>single<ph x="2">&lt;w2/&gt;</ph>Digits<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、シーケンスまたはコレクションのメソッドを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>single<ph x="2">&lt;w2/&gt;</ph>Digits<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>可付番範囲で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use sequence or collection methods on the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>up<ph x="2">&lt;w2/&gt;</ph>To<ph x="3">&lt;w3/&gt;</ph>Five<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> countable range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、シーケンスまたはコレクションのメソッドを<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>up<ph x="2">&lt;w2/&gt;</ph>To<ph x="3">&lt;w3/&gt;</ph>Five<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>可付番範囲で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use special versions of some sequence and collection operations when working with a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、特別版のなんらかのシーケンスやコレクション演算をある<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Comparable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型を扱うときに使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Class<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol as the concrete type for an instance of any class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Class<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルをあらゆるクラスのインスタンスに対して具象型として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>type(of:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function to find the dynamic type of a value, particularly when the dynamic type is different from the static type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>type(of:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使うことである値の動的型を見つけることができます、とりわけ動的型が静的型と異なる場合に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>magnitude<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> property in operations that are simpler to implement in terms of unsigned values, such as printing the value of an integer, which is just printing a ‘-’ character in front of an absolute value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="7" x="7">&lt;c7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>magnitude<ept i="8">&lt;/s8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>プロパティを、ずっと単純に符号なしの値に関して実装する演算において使用できます、例えば整数の値を印字することなど、それはちょっと「-」文字を絶対値の前に印字しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the predicate to check for an element of a type that doesn’t conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, such as the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>HTTPResponse<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> enumeration in this example.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは述部を使って、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない型、例えばこの例での<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>HTTPResponse<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>列挙などの要素に対して調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the predicate to find an element of a type that doesn’t conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol or to find an element that matches particular criteria.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは述部を使って、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Equatable<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない型の要素を見つける、または特定の基準に合致する要素を見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this function to call an API that takes an escaping closure in a way that doesn’t allow the closure to escape in practice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこの関数を使うことで、クロージャが脱出するのを実際には許可されないある方法において脱出するクロージャをとるAPIを呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this initializer to create a new string from a slice of another string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、このイニシャライザを使って新しい文字列を別の文字列のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>unicode<ph x="2">&lt;w2/&gt;</ph>Scalars<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューのスライスから作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this initializer to create a new string from a slice of another string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、このイニシャライザを使って新しい文字列を別の文字列の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf16<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューのスライスから作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this initializer to create a new string from a slice of another string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、このイニシャライザを使って新しい文字列を別の文字列の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>utf8<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビューのスライスから作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this initializer to create a new string from the result of one or more operations on a string’s <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>characters<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> view.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、このイニシャライザを使って新しい文字列を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>characters<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ビュー上での１つ以上の演算の結果から作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this initializer to create an array from any other type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこのイニシャライザを使って、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Sequence<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する何か他の型から配列を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this method to create new values from the buffer pointer’s underlying bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、このメソッドを使って新しい値をパッファポインタのもつ基盤バイトから作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this pattern matching operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>~=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to test whether a value is included in a range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、このパターンマッチング演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>~=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使うことで、ある値がある範囲に含まれるかどうか検査できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるコレクションのインデックスからなる、この型の部分的範囲を使うことで、その部分的な範囲の下側の境界からそのコレクションの終わりまでの範囲を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるコレクションのインデックスからなる、この型の部分的範囲を使うことで、コレクションの始まりからその部分的な範囲の上側の境界までの、そしてそれを含んでいる範囲を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるコレクションのインデックスからなる、この型の部分的範囲を使うことで、コレクションの始まりからその部分的な範囲の上側の境界までの、しかしそれを含んでいない範囲を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use your own custom types as dictionary keys by making them conform to the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Hashable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなた独自のあつらえの型を辞書のキーとして使うことがそれらを<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>Hashable<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルに準拠させることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can write generic methods that operate on any numeric type in the standard library by using the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Numeric<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol as a generic constraint.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Numeric<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルを総称体制約として使うことで、標準ライブラリのあらゆる数値型上で作用する総称体メソッドを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You cannot use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>*<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with arguments of different types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>*<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をそれぞれが異なる型である引数で使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You cannot use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with arguments of different types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をそれぞれが異なる型である引数で使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You cannot use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with arguments of different types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をそれぞれが異なる型である引数で使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You cannot use a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>break<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>continue<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> statement to exit the current call of the <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>body<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> closure or skip subsequent calls.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>break<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>continue<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>文を使って、<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>body<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>クロージャの現在の呼び出しを抜け出したり、または続いて起こる呼び出しを飛ばしたりできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t initialize a type that conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Expressible<ph x="4">&lt;w4/&gt;</ph>By<ph x="5">&lt;w5/&gt;</ph>Array<ph x="6">&lt;w6/&gt;</ph>Literal<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> simply by assigning an existing array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、既存の配列を割り当てることで<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Expressible<ph x="4">&lt;w4/&gt;</ph>By<ph x="5">&lt;w5/&gt;</ph>Array<ph x="6">&lt;w6/&gt;</ph>Literal<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠する型を初期化することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t initialize a type that conforms to <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Expressible<ph x="8">&lt;w8/&gt;</ph>By<ph x="9">&lt;w9/&gt;</ph>Dictionary<ph x="10">&lt;w10/&gt;</ph>Literal<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> simply by assigning an instance of one of these types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;s7&gt;</bpt>Expressible<ph x="8">&lt;w8/&gt;</ph>By<ph x="9">&lt;w9/&gt;</ph>Dictionary<ph x="10">&lt;w10/&gt;</ph>Literal<ept i="7">&lt;/s7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に準拠する型を、単純にこれらの型のうちの１つのインスタンスを割り当てることによって初期化できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You create <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>From<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances by using the postfix range operator (postfix <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>...<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>From<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを後置範囲演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>...<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You create <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Through<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances by using the prefix closed range operator (prefix <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>...<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Through<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを後置範囲演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>...<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You create <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Up<ph x="4">&lt;w4/&gt;</ph>To<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances by using the prefix half-open range operator (prefix <bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>..&lt;<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Partial<ph x="2">&lt;w2/&gt;</ph>Range<ph x="3">&lt;w3/&gt;</ph>Up<ph x="4">&lt;w4/&gt;</ph>To<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを後置範囲演算子（<bpt i="5" x="5">&lt;c5&gt;</bpt><bpt i="6" x="6">&lt;s6&gt;</bpt>..&lt;<ept i="6">&lt;/s6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>）を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You create <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances by using the half-open range operator (<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>..&lt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを半開範囲演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>..&lt;<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You create a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Closed<ph x="3">&lt;w3/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance by using the closed range operator (<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>...<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Closed<ph x="3">&lt;w3/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを完結範囲演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>...<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You create a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance by using the half-open range operator (<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>..&lt;<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Countable<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを半開範囲演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>..&lt;<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You create an instance of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Repeated<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> collection by calling the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>repeat<ph x="4">&lt;w4/&gt;</ph>Element(_:<ph x="5">&lt;w5/&gt;</ph>count:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Repeated<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>コレクションのインスタンスを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>repeat<ph x="4">&lt;w4/&gt;</ph>Element(_:<ph x="5">&lt;w5/&gt;</ph>count:)<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>関数を呼び出すことによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You create instances of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Closed<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> by using the closed range operator (<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>...<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Closed<ph x="2">&lt;w2/&gt;</ph>Range<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスを完結範囲演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>...<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）を使うことによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You initialize a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance using a Swift dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Dictionary<ph x="2">&lt;w2/&gt;</ph>Literal<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスをSwift辞書リテラルを使って初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You must eventually deallocate the memory referenced by the returned pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、返されるポインタによって参照されるメモリを最後にはデアロケートしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You must not call this method if any other copy of this iterator has been advanced with a call to its <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、このイテレータの何か他のコピーがそれの<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>next()<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを呼び出すことで前に進められるならば、このメソッドを呼び出す必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You must unwrap the value of an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance before you can use it in many contexts.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなたがそれを多くの文脈において使う前に、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの値をアンラップしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You rarely need to use iterators directly, because a <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> loop is the more idiomatic approach to traversing a sequence in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは滅多にイテレータを直に使う必要はありません、なぜなら<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>for<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>in<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ループはSwiftにおいてシーケンスを辿っていくずっと慣用語法にかなった取り組みだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You should prefer <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>with<ph x="2">&lt;w2/&gt;</ph>Va<ph x="3">&lt;w3/&gt;</ph>List(_:<ph x="4">&lt;w4/&gt;</ph>_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instead of this function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこの関数よりも<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>with<ph x="2">&lt;w2/&gt;</ph>Va<ph x="3">&lt;w3/&gt;</ph>List(_:<ph x="4">&lt;w4/&gt;</ph>_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を選ぶべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Object<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> when you need the flexibility of an untyped object or when you use bridged Objective-C methods and properties that return an untyped result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが型付けされないオブジェクトの柔軟性を必要とするとき、または型付けされない結果を返すブリッジされたObjective-Cメソッドやプロパティを使用するとき、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Any<ph x="2">&lt;w2/&gt;</ph>Object<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use a set instead of an array when you need to test efficiently for membership and you aren’t concerned with the order of the elements in the collection, or when you need to ensure that each element appears only once in a collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが集合を配列の代わりに使うのは、あなたが帰属について能率的にテストする必要がありそしてあなたがコレクションの要素の順番に関心がない場合、または各要素がただ一度だけコレクション中に現れることをあなたが確実にする必要がある場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use arrays to organize your app’s data.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは配列を使ってあなたのアプリのデータを整理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use instances of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type to access data of a specific type in memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスを使うことで、メモリにおいて特定の型のデータにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use instances of the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type to access data of a specific type in memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Pointer<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスを使うことで、メモリにおいて特定の型のデータにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use that key to retrieve the corresponding value, which can be any object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこのキーを使ってその対応している値を取り出すことができ、その値はあらゆるオブジェクトであることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Option<ph x="2">&lt;w2/&gt;</ph>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol to represent bitset types, where individual bits represent members of a set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Option<ph x="2">&lt;w2/&gt;</ph>Set<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルを使ってビットセット型を表すことができます、そこにおいて個々のビットはセットのメンバを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type whenever you use optional values, even if you never type the word <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Optional<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Optional<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型を、あなたがオプショナル値を使う時はいつでも使います、たとえあなたが単語<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Optional<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を決してタイプしないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type to access and manage memory that has been bound to a specific type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型を使うことで、特定の型に束縛されているメモリへのアクセスおよび管理を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Raw<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type to access and manage raw bytes in memory, whether or not that memory has been bound to a specific type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Mutable<ph x="5">&lt;w5/&gt;</ph>Raw<ph x="6">&lt;w6/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型を使ってメモリ中の生のバイトにアクセスおよび管理を、そのメモリが特定の型に束縛されているかどうかにかかわらず行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type to access and manage memory that has been bound to a specific type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型を使うことで、特定の型に束縛されているメモリへのアクセスおよび管理を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Raw<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type to access and manage raw bytes in memory, whether or not that memory has been bound to a specific type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>Unsafe<ph x="4">&lt;w4/&gt;</ph>Raw<ph x="5">&lt;w5/&gt;</ph>Pointer<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型を使ってメモリ中の生のバイトにアクセスおよび管理を、そのメモリが特定の型に束縛されているかどうかにかかわらず行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the addition assignment operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to advance a pointer by a number of contiguous instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、加算代入演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って、あるポインタをある連接インスタンスの数だけ進めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the addition operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to advance a pointer by a number of contiguous instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、加算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>+<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って、あるポインタをある連接インスタンスの数だけ進めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the default <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer to create a new instance when you’re sure that the value passed is representable in the new type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、省略時の<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>init(_:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを使って新しいインスタンスを作成するのは、渡される値が新しい型において表現可能であるとあなたが確信する場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the subtraction assignment operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to shift a pointer backward by a number of contiguous instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、減算代入演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-=<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って、あるポインタをある連接インスタンスの数だけ後方へズラすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the subtraction operator (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to shift a pointer backward by a number of contiguous instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、減算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>-<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）を使って、あるポインタをある連接インスタンスの数だけ後方へズラすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use this initializer to create a dictionary when you have a sequence of key-value tuples that might have duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、重複キーを持つかもしれないキー値タプルのシーケンスをあなたが持つ場合、このイニシャライザを使って辞書を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use this initializer to create a dictionary when you have a sequence of key-value tuples with unique keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、特有なキーをもつキー値タプルのシーケンスをあなたが持つ場合、このイニシャライザを使って辞書を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use types that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ph x="2">&lt;w2/&gt;</ph>Algebra<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol when you need efficient membership tests or mathematical set operations such as intersection, union, and subtraction.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Set<ph x="2">&lt;w2/&gt;</ph>Algebra<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型を使うのは、あなたが帰属について能率的にテストするか、数学的集合演算たとえば交叉、合併、そして差分を必要とする場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You want to compare the absences in the first half of the session with those in the second half.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、前学期の欠席者を後半のそれと比較したいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write each key-value pair with a colon (<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>:<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) separating the key and the value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、各キー値ペアをコロン（<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>:<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）で区切るキーと値で書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Your own custom types can be hashable as well.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなた独自のあつらえの型も同様にハッシュ化されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You’d like to create a set of the grid points where a user has already tapped.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ユーザがすでにタップしたところの格子点ひとそろいを作成したいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You’re tasked with finding the day with the most absences in the second half of the session.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこの学期の後半において最も多く欠席者がいる日付を見つける任務を負います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Zero is neither a normal nor a subnormal number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゼロは、ノーマルでもサブノーマル数でもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Zero or more additional values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゼロ以上の追加の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Zero or more items to print.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>出力するゼロ個以上の項目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>[We don’t recommend that you use <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> this way, because it creates and discards an array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>［私たちは、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>map<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をこのやり方で使うのを推奨しません、なぜならそれは１つの配列を作成し破棄するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>a subscript that provides at least read-only access to your type’s elements, and</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>少なくとも読み込み専用のアクセスをあなたの型の要素に提供する添え字、そして</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>an <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer&lt;Pointee&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, which is passed as-is.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>Unsafe<ph x="2">&lt;w2/&gt;</ph>Mutable<ph x="3">&lt;w3/&gt;</ph>Pointer&lt;Pointee&gt;<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、それは現品で渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>an inout argument of the referenced type, which gets passed as a pointer to a writeback temporary with autoreleasing ownership semantics,</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照される型のインアウト引数、それはオートリリース所有権意味論を持つライトバックテンポラリへのポインタとして渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>and finally, we can give all lazy sequences a lazy <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>scan<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そして最終的に、私たちは全ての遅延シーケンスを遅延<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>scan<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドに渡すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>if this set and <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> contain elements that are equal but distinguishable (e.g. via <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>===<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>), which of these elements is present in the result is unspecified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この集合と<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>other<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が等しいけれども区別可能な要素を含むならば（たとえば<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>===<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>によって）、それらの要素のどれが結果の存在するのかは不特定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>is a sequence containing { <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>2<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>4<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>6<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> }.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、{ <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>2<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;s3&gt;</bpt>4<ept i="3">&lt;/s3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;s5&gt;</bpt>6<ept i="5">&lt;/s5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> }を含んでいるシーケンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>is equivalent to:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは次と同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index(after:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method for advancing an index into your collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコレクションにおいてあるインデックスを前に進めるための<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>index(after:)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> properties,</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>start<ph x="2">&lt;w2/&gt;</ph>Index<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt><bpt i="4" x="4">&lt;s4&gt;</bpt>end<ph x="5">&lt;w5/&gt;</ph>Index<ept i="4">&lt;/s4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロパティ、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>the buffer slice to rebase.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>再配置されることになるバッファスライス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>the raw buffer slice to rebase.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>再配置されることになる生のバッファスライス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>we can build a sequence that lazily computes the elements in the result of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>scan<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>私たちは、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>scan<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の結果の中の要素を遅延に計算するシーケンスを組み立てることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>will get a maximum of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>min(buffer<ph x="2">&lt;w2/&gt;</ph>.count, max<ph x="3">&lt;w3/&gt;</ph>Length)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最大で<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>min(buffer<ph x="2">&lt;w2/&gt;</ph>.count, max<ph x="3">&lt;w3/&gt;</ph>Length)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バイトを取得するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>will store a maximum of <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>min(buffer<ph x="2">&lt;w2/&gt;</ph>.count, max<ph x="3">&lt;w3/&gt;</ph>Length)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> bytes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最大で<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;s1&gt;</bpt>min(buffer<ph x="2">&lt;w2/&gt;</ph>.count, max<ph x="3">&lt;w3/&gt;</ph>Length)<ept i="1">&lt;/s1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バイトを格納するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>you can write:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは次を書くことができます：</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
