<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.1.1_0_9688" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(A generic version of these functions is defined below.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これらの関数の総称体版は、下で定義されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(A literal value is a value that appears directly in your source code, such as <bpt i="2" x="2">&lt;c2&gt;</bpt>42<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>3.14159<ept i="3">&lt;/c3&gt;</ept> in the examples below.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（リテラル値「文字通りの値」は、直接あなたのソース・コードで見かける値です、例えば下の例での<bpt i="2" x="2">&lt;c2&gt;</bpt>42<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>3.14159<ept i="3">&lt;/c3&gt;</ept>）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(For more information about capturing values in a closure, see <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Capturing Values<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（クロージャにおいて値を捕獲することに関する詳細は、<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>値を捕獲する<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>を見てください。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(In the <bpt i="4" x="4">&lt;c4&gt;</bpt>swapTwoValues(_:_:)<ept i="4">&lt;/c4&gt;</ept> example above, <bpt i="5" x="5">&lt;c5&gt;</bpt>T<ept i="5">&lt;/c5&gt;</ept> was replaced with <bpt i="6" x="6">&lt;c6&gt;</bpt>Int<ept i="6">&lt;/c6&gt;</ept> the first time the function was called, and was replaced with <bpt i="7" x="7">&lt;c7&gt;</bpt>String<ept i="7">&lt;/c7&gt;</ept> the second time it was called.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（上の<bpt i="4" x="4">&lt;c4&gt;</bpt>swapTwoValues(_:_:)<ept i="4">&lt;/c4&gt;</ept>の例では、<bpt i="5" x="5">&lt;c5&gt;</bpt>T<ept i="5">&lt;/c5&gt;</ept>は関数が呼ばれた最初の時に<bpt i="6" x="6">&lt;c6&gt;</bpt>Int<ept i="6">&lt;/c6&gt;</ept>と取り替えられて、それが呼ばれた２番目の時に<bpt i="7" x="7">&lt;c7&gt;</bpt>String<ept i="7">&lt;/c7&gt;</ept>と取り替えられました）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(It can’t contain anything else, such as a <bpt i="9" x="9">&lt;c9&gt;</bpt>Bool<ept i="9">&lt;/c9&gt;</ept> value or a <bpt i="10" x="10">&lt;c10&gt;</bpt>String<ept i="10">&lt;/c10&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg> （それは、他の何か、例えば<bpt i="9" x="9">&lt;c9&gt;</bpt>Bool<ept i="9">&lt;/c9&gt;</ept>値または<bpt i="10" x="10">&lt;c10&gt;</bpt>String<ept i="10">&lt;/c10&gt;</ept>値などを含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(It is assumed that all media items, including all movies and songs, will have a name.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（全ての映画と歌を含む、全てのメディア項目が名前を持つと仮定されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Neither stylistic technique is strictly necessary, but they lead to neater code.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（文体上の技巧は絶対に必要な訳ではありません、しかしそれはすっきりしたコードにつながります。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Nested tuples are allowed.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（入れ子にされたタプルは、認められます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Note that these type methods can access the <bpt i="6" x="6">&lt;c6&gt;</bpt>highestUnlockedLevel<ept i="6">&lt;/c6&gt;</ept> type property without your needing to write it as <bpt i="7" x="7">&lt;c7&gt;</bpt>LevelTracker.highestUnlockedLevel<ept i="7">&lt;/c7&gt;</ept>.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これらの型メソッドは、あなたがそれを<bpt i="7" x="7">&lt;c7&gt;</bpt>LevelTracker.highestUnlockedLevel<ept i="7">&lt;/c7&gt;</ept>と書かなくても、<bpt i="6" x="6">&lt;c6&gt;</bpt>highestUnlockedLevel<ept i="6">&lt;/c6&gt;</ept>型プロパティにアクセスできる点に注意してください）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Strings have a similar optimization, but if two strings share memory, they are equal.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（文字列は同様な最適化を待ちます、しかし２つの文字列がメモリを共有するならば、それらは等しいです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Swift reports an error at compile-time if a protocol requirement is not fulfilled.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（プロトコル要件が満たされないならば、スウィフトは実行時にエラーを報告します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The <bpt i="2" x="2">&lt;c2&gt;</bpt>name<ept i="2">&lt;/c2&gt;</ept> property is an optional <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> property, and so it automatically receives a default value of <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>, even though this value is not written in the code.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（<bpt i="2" x="2">&lt;c2&gt;</bpt>name<ept i="2">&lt;/c2&gt;</ept>プロパティはオプショナルの<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>プロパティです、なのでそれは自動的に省略時の値の<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>を受け取ります、たとえこの値がそのコードに書かれないとしてもです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The <bpt i="4" x="4">&lt;c4&gt;</bpt>dice<ept i="4">&lt;/c4&gt;</ept> property is declared as a constant property because it doesn’t need to change after initialization, and the protocol only requires that it must be gettable.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（<bpt i="4" x="4">&lt;c4&gt;</bpt>dice<ept i="4">&lt;/c4&gt;</ept>プロパティは定数プロパティとして宣言されます、なぜなら、それが初期化の後に変化する必要がなく、そして、プロトコルはそれが取得可能なことを必要とするだけであるからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The Boolean return value of <bpt i="3" x="3">&lt;c3&gt;</bpt>advance(to:)<ept i="3">&lt;/c3&gt;</ept> is ignored, because the level is known to have been unlocked by the call to <bpt i="4" x="4">&lt;c4&gt;</bpt>LevelTracker.unlock(_:)<ept i="4">&lt;/c4&gt;</ept> on the previous line.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（<bpt i="3" x="3">&lt;c3&gt;</bpt>advance(to:)<ept i="3">&lt;/c3&gt;</ept>のブールの戻り値は無視されます、なぜなら、このレベルは前の行で<bpt i="4" x="4">&lt;c4&gt;</bpt>LevelTracker.unlock(_:)<ept i="4">&lt;/c4&gt;</ept>呼び出しによってすでに錠を開けられていると分かるからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The examples below are based on 8-bit signed integers for simplicity, but the same principles apply for signed integers of any size.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（下の例は、単純さのために8ビット符号つき整数に基づきます、しかし同じ原理はあらゆるサイズの符号つき整数に当てはまります）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The examples of modifying an inherited property’s default value in a subclass initializer have been moved to the <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Initialization<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept> chapter.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（サブクラスのイニシャライザの継承されたプロパティの省略時の値を修正する例は章<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>初期化<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>に移動されました。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The expression <bpt i="3" x="3">&lt;c3&gt;</bpt>number % 10<ept i="3">&lt;/c3&gt;</ept> gives a value of <bpt i="4" x="4">&lt;c4&gt;</bpt>6<ept i="4">&lt;/c4&gt;</ept> for <bpt i="5" x="5">&lt;c5&gt;</bpt>16<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>8<ept i="6">&lt;/c6&gt;</ept> for <bpt i="7" x="7">&lt;c7&gt;</bpt>58<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>0<ept i="8">&lt;/c8&gt;</ept> for <bpt i="9" x="9">&lt;c9&gt;</bpt>510<ept i="9">&lt;/c9&gt;</ept>.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（式数<bpt i="3" x="3">&lt;c3&gt;</bpt>number % 10<ept i="3">&lt;/c3&gt;</ept>は、<bpt i="5" x="5">&lt;c5&gt;</bpt>16<ept i="5">&lt;/c5&gt;</ept>のために<bpt i="4" x="4">&lt;c4&gt;</bpt>6<ept i="4">&lt;/c4&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>58<ept i="7">&lt;/c7&gt;</ept>のために<bpt i="6" x="6">&lt;c6&gt;</bpt>8<ept i="6">&lt;/c6&gt;</ept>、<bpt i="9" x="9">&lt;c9&gt;</bpt>510<ept i="9">&lt;/c9&gt;</ept>のために<bpt i="8" x="8">&lt;c8&gt;</bpt>0<ept i="8">&lt;/c8&gt;</ept>の値を与えます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The parameters to functions and closures are always constants.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（関数およびクロージャに対するパラメータは常に定数です。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(The same is not true for structures and enumerations, because they are always copied when they are assigned to a constant or variable, or passed to a function.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（同じことは構造体と列挙にあてはまりません、なぜなら、それらが値型であって、それらが定数または変数に代入されるか関数に渡される時に、常にコピーされるからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(This raw <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> value is not used for the Jack, Queen, King, and Ace cards.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（この生の<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>値は、ジャック、クイーン、キング、そしてエース・カードには使われません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(This subscript is available on all Swift types.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（この添え字は、すべてのスウィフト型で利用可能です。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(Unlike Objective-C categories, Swift extensions do not have names.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（Objective-Cカテゴリーとは異なり、スウィフト拡張には、名前がありません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// "Apple International" is not the real airport for APL, so delete it</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「アップル・インターナショナル」は、APLのための本当の空港ではないので、それを削除します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// "Imagination is more important than knowledge" - Einstein</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「想像は知識より重要です」 - アインシュタイン）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// "Maple Syrup" is now the first item in the list</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「メープルシロップ」が、現在はリストの最初の項目です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// "Voulez-vous un café?" using LATIN SMALL LETTER E WITH ACUTE</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「Voulez-vous un café?」は揚音付きラテン小文字eを使用している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// "Voulez-vous un café?" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「Voulez-vous un café?」はラテン小文字eと揚音アクセント結合を使用している）&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// "required" from SomeProtocol conformance; "override" from SomeSuperClass</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（SomeProtocol準拠からの「required」；SomeSuperClasからの「override」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// 1 times 5 is 5</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（１かける５は、５です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// 2 times 5 is 10</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（２かける５は、10です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// 3 times 5 is 15</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（３かける５は、15です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// 4 times 5 is 20</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（４かける５は、20です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// 5 times 5 is 25</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（５かける５は、25です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// A 12-sided dice</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（ひとつの12面のさいころ遊び）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// A game of Snakes and Ladders with 25 squares</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（25ますのヘビとはしごのゲーム）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// A game of Snakes and Ladders with 25 squares:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（25ますのヘビとはしごのゲーム：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// A hamster named Simon</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（サイモンという名前のハムスター）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// APL has now been removed from the dictionary</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（APLは、現在この辞書から削除されました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// About to set totalSteps to 200</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（totalStepsを200に設定している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// About to set totalSteps to 360</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（totalStepsを360に設定している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// About to set totalSteps to 896</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（totalStepsを896に設定している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Added 160 steps</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（160の歩数が加えられた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Added 200 steps</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（200の歩数が加えられた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Added 536 steps</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（536の歩数が加えられた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// All items match, so return true.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（全ての項目が合致、なのでtrueを返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Apply f to create an array of Number instances with integer values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（fを適用して整数値を持つNumberインスタンスからなる配列を作成する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Area is 12.5663708</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（面積は、12.5663708です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Area is 243610.0</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（面積は、243610.0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// AutomaticCar: traveling at 35.0 miles per hour in gear 4</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（AutomaticCar: 時速35.0マイル、４速ギアで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Baking Powder</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（膨らし粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Bananas</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（バナナ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Bicycle: 2 wheel(s)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（自転車: ２輪）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Bicycle: traveling at 15.0 miles per hour</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（自転車：時速15マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Bind x and y to the elements of point.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（xとyをpointの要素へ束縛します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// BlackjackCard properties and methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（BlackjackCardのプロパティとメソッド）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Car: traveling at 25.0 miles per hour in gear 3</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（Car: ３速ギアで時速25.0マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Check each pair of items to see if they're equivalent.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（各項目の対をそれらが等しいかどうか見るため調べる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Check that both containers contain the same number of items.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（両方のコンテナが同じ数の項目を含むことを確認する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Convert the result to a String for long-term storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（結果を長期保管のためのStringへ変換する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Counting to zero:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「ゼロまで数えます：」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Do something three times.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（３回何かをします。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Fall back to earlier iOS and macOS APIs</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（以前のiOSとmacOS APIに後退する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// First release</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（最初のリリース）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Flour</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（小麦粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Hello, Alex!</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（よろしく、アレックス！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Hello, Anna!</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（よろしく、アンナ！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Hello, Brian!</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（よろしく、ブライアン！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Hello, Jack!</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（よろしく、ジャック！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Hello, Michael</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（こんにちは、マイケル）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Here's how you call this function with a trailing closure instead:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（あなたが代わりに後付クロージャでどのようにこの関数を呼ぶのかがここにあります：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Here's how you call this function without using a trailing closure:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（あなたが後付クロージャを使うことなくどのようにこの関数を呼ぶのかがここにあります：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// If you omit the second argument when calling this function, then</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（あなたが２番目の引数をこの関数を呼び出すときに省略したならば、その時）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// In the function body, firstParameterName and secondParameterName</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（関数本文において、firstParameterNameとsecondParameterNameは、）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// In the function body, parameterName refers to the argument value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（関数本文において、parameterNameは）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// In the implementation of a subscript...</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（ある添え字の実装において...）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Int8 cannot store a number larger than its maximum value,</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（Int8はその最大の値より大きい数を保存することができません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Item 1: Six eggs</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（項目１：６つの卵）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Item 2: Milk</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（項目２：牛乳）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Item 3: Flour</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（項目３：小麦粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Item 4: Baking Powder</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（項目４：膨らし粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Item 5: Bananas</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（項目５：バナナ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Make a local copy and manually copy it back.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（ローカルコピーを作って手動でそれを元へコピーする）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Match only non-nil values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（nilでない値にのみマッチする）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Match using an enumeration case pattern.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（列挙ケース節パターンを使っているマッチ。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Match using an optional pattern.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（オプショナルパターンを使っているマッチ。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Milk</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（牛乳）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Movie: Casablanca, dir. Michael Curtiz</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（映画：『カサブランカ』（監）マイケル・カーティス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Movie: Citizen Kane, dir. Orson Welles</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（映画：『市民ケーン』（監）オーソン・ウェルズ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Now t is (20, 20, 30)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（tは、現在 (20, 20, 30)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Operate on localX asynchronously, then wait before returning.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（非同期にlocalXを処理を施す、それから返すまえに待機する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Overload the ~= operator to match a string with an integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（~=演算子をオーバーロードして文字列を整数と照合するようにする。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Person 1 is called Anna</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（人物は１、アンナと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Person 2 is called Alex</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（人物２は、アレックスと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Person 3 is called Brian</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（人物３は、ブライアンと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Person 4 is called Jack</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（人物４は、ジャックと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints ""123" has an integer value of 123"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「"123" has an integer value of 123」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "(1, -1) is on the line x == -y"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「(1, -1)は、x == -yの線上にある」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "(1, 1) is inside the box"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「(1, 1）は、この四角の中にあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "(1, 2) is near the origin."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「（1, 2）は原点に近いです。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "10"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「10」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "27"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「27」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "3 to the power of 10 is 59049"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「３の10乗は、59049です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "6 mansion scenes; 2 cell scenes"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「６つの邸宅場面；２つの僧房場面」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "6"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「6」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "7"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「７」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "<bpt i="1" x="1">&lt;h1&gt;</bpt>some default text<ept i="1">&lt;/h1&gt;</ept>"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「<bpt i="1" x="1">&lt;h1&gt;</bpt>some default text<ept i="1">&lt;/h1&gt;</ept>」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "&lt;p&gt;hello, world&lt;/p&gt;"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「&lt;p&gt;よろしく、世界&lt;/p&gt;」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "A 12-sided dice"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「ひとつの12面さいころ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "A game of Snakes and Ladders with 25 squares"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「25ますのヘビとはしごのゲーム」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "A hamster named Simon"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「サイモンという名前のハムスター」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "A marathon is 42195.0 meters long"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「マラソンは、42195.0メートルの長さです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "A new player has joined the game with 100 coins"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「新しいプレーヤーが、100のコインを持ってゲームに参加しました」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "ACCESS DENIED"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「アクセス拒否」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "All items match."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「全ての項目が一致する」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "An animal was initialized with a species of Giraffe"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「一匹の動物がキリンの種族で初期化された」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "An implicitly unwrapped optional string."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「暗黙的にアンラップされるオプショナルの文字列。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "And another one: 0.729023776863283"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「さらにもう一つ：0.729023776863283」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "And here's a random Boolean: true"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「そしてここに任意のブール: trueがあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Another value."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「別の値。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Apartment 4A is being deinitialized"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「アパート4Aは、デイニシャライズされた」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Bonjour!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「Bonjour!」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Canada's capital city is called Ottawa"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「カナダの首都はオタワです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Card #1234567890123456 is being deinitialized"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「カード#1234567890123456は、デイニシャライズされた」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Choo Choo"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「シュッシュッ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Collected 2 closures."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「２つのクロージャが集められた。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Do you like cheese?"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「あなたはチーズが好きですか？」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Eww, turnips are horrible."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「うー、カブ怖い。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Happy birthday, Malcolm, you're 21!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「誕生日おめでとうマルコム、あなたは21です！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Hello Jane!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「こんにちはジェーン！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Hello John!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「こんにちはジョン！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Hello again, Anna!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「またあったね、アンナ！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Hello again, Tim!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「またあったね、ティム！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Hello, Anna!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「こんにちは、アンナ！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Hello, Brian!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「こんにちは、ブライアン！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Here's a random number: 0.37464991998171"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「ここに任意の数: 0.37464991998171があります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "How about beets?"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「赤かぶはどう？」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "I have 3 favorite music genres."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「私には大好きな音楽ジャンルが３つあります。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "I have particular music preferences."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「私には特定の音楽の好みがあります。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "I hope the weather is nice in Cupertino."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「クパチーノの天気がいいことを望むよ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "I hope the weather is nice near you."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「あなたの近くの天気がいいといいね」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Insufficient funds. Please insert an additional 2 coins."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「金額が不足しています。さらに２コイン入れてください。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "It was not possible to print the number of rooms."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「部屋の数を出力することは、可能ではありませんでした。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "It was not possible to set the address."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「住所を設定することは、可能ではありませんでした。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "It's not that cold. Wear a t-shirt."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「そんなに寒くありません。Tシャツを着てください。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "It's really warm. Don't forget to wear sunscreen."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「非常に暖かいです。日焼け止めを塗るのを忘れないでください。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "It's too funky in here."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「そりゃここじゃfunkyすぎる。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "It's very cold. Consider wearing a scarf."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「非常に寒いです。スカーフを巻くことを考えてください。 」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Item: sock, quantity: 2"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「項目：靴下、数量：２」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "John Appleseed is being deinitialized"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「John Appleseedは、デイニシャライズされた」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "John Appleseed is being initialized"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「John Appleseedは、初期化された」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "John's building identifier begins with "The"."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「ジョンの建物名は「月」で始まります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "John's building identifier is The Larches."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「ジョンの建物名は月桂樹です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "John's residence has 1 room(s)."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「ジョンの邸宅には１部屋ある」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "John's street name is Laurel Street."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「ジョンの街路名は月桂樹通りです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Media library contains 2 movies and 3 songs"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「情報媒体書庫は、２つの映画と３つの歌を含みます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Mostly harmless"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「おおむね無害」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Nothing to see here"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「ここで見るものは何も無し」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Now serving Alex!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（今アレックスに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Now serving Barry!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（今バリーに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Now serving Daniella!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（今ダニエラに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Now serving Ewa!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（今エヴァに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "On an axis, 9 from the origin"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「ある軸上で、原点から９」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "One inch is 0.0254 meters"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「１インチは、0.0254メートルです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "PlayerOne has left the game"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「PlayerOneは、ゲームを離れました」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "PlayerOne won 2000 coins &amp; now has 2100 coins"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「PlayerOneは2000のコインを獲得＆現在2100のコインを持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "QR code: ABCDEFGHIJKLMNOP."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「QRコード：ABCDEFGHIJKLMNOP。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Result: 5"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「結果：５」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Result: 6"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「結果：６」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Result: 8"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「結果：８」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Rock? I'm over it."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「Rock？ もう済んだことさ（曲名？）。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Some value."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「ある値。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "SomeSubClass"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「 SomeSubClass 」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The airports dictionary contains 2 items."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「airports辞書は２項目を含む。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The airports dictionary is not empty."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「airports辞書は空ではない。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The anonymous creature could not be initialized"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「不明な生き物は初期化されることができませんでした」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The bank now has 10000 coins"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「胴元には現在10000コインがあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The bank now only has 7900 coins left"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「胴元には現在7900個のコインだけが残っています」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The current value of friendlyWelcome is Bonjour!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「The current value of friendlyWelcome is Bonjour!」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The default temperature is 32.0° Fahrenheit"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「省略時の温度は華氏32.0°です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The first number is 10."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「最初の数は、10です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The first room name is Living Room."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「最初の部屋名は、居間です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The frameRate property of tenEighty is now 30.0"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「tenEightyのframeRateプロパティは、現在は30.0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The index of llama is 2"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「ラマのインデックスは、２です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The integer value of 三 is 3."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「三の整数値は３です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The name of the airport is Dublin Airport."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「空港名は「ダブリン空港です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The number 5 is a prime number, and also an integer."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「数５は素数で、そのうえ整数です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The number of edits is 3"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「編集数は、３です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The old value for DUB was Dublin."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「DUBの古い値は「ダブリンでした。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The point is at (1, 2)."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「pointは（1, 2）です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The point is at (3, 2)."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「pointは（3, 2）です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The point is now at (3.0, 4.0)"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「ポイントは現在は(3.0, 4.0)です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The remembered direction is still .west"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「記憶されている方位は、依然として.westです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The removed airport's name is Dublin Airport."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「削除された空港の名前はダブリンです。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The second number is 42."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（２番目の数は、42です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The shopping list contains 2 items."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「買い物リストは２つの項目を含みます。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The shopping list is not empty."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「買い物リストは空ではありません。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The status code is 200"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「状態コードは200です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The status code is 404"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「状態コードは404です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The status message is Not Found"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「状態メッセージが見つかりません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The status message is OK"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「状態メッセージはOKです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The top item on the stack is tres."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「このスタックの一番上の項目はtresです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The width of someResolution is 0"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「someResolutionの幅は0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The width of someVideoMode is 0"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「someVideoModeの幅は0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "The width of someVideoMode is now 1280"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「someVideoModeの幅は、現在は1280です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "There are 5 scenes in Act 1"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「５つの場面が一幕にあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "There are dozens of moons orbiting Saturn."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「土星の軌道を回るたくさんの月がある。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "There are now 9900 coins left in the bank"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「現在9900個のコインが胴元に残されます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "There isn't a planet at position 11"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「位置11に惑星は存在しない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "These two characters are not equivalent."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「これら２つの文字列は等しくない。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "These two strings are considered equal"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「これら２つの文字列は等しいと考えられる」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "These two vectors are equivalent."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「これらの２つのベクトルは等しいです。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "This is a defined temperature unit, so initialization succeeded."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「これは定義済み温度単位です、なので初期化は成功しました。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "This is not a defined temperature unit, so initialization failed."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「これは定義済み温度単位ではありません、なので初期化は失敗しました。」を出力します」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "This point is to the right of the line where x == 1.0"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「この点は線x == 1.0の右にある」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Three feet is 0.914399970739201 meters"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「３フィートは、0.914399970739201メートルです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Unable to initialize one unnamed product"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「１個の名前のない製品を初期化できません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Unable to initialize zero shirts"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「０個のシャツを初期化できません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Unable to retrieve the address."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「住所を取り出すことができない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Unable to retrieve the first room name."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「最初の部屋名を取り戻すことができない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Unable to retrieve the number of rooms."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「部屋の数を取り出すことができない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Watch out for penguins"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「ペンギンに気をつけろ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "Welcome!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「歓迎します！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「[マーレイという名のハムスター, モーガンという名のハムスター, モーリスという名のハムスター]」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "cinema is now 2048 pixels wide"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「cinemaは、現在2048のピクセルの幅です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "convertedNumber contains some integer value."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「convertedNumberは、何らかの整数値を持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "convertedNumber has an integer value of 123."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「convertedNumberは、整数値123を持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "data.txt"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「data.txt」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "e is a vowel"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「eは、母音です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "false"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「false」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "hd is still 1920 pixels wide"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「hdは、依然として1920のピクセルの幅です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "hello, world"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「よろしく、世界」を出力ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "hello, world", because name is indeed equal to "world".</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「hello, world」を出力します、nameが確かに「world」と等しいので。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "highest unlocked level is now 2"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「最も高い鍵の開いたレベルは現在２です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "letters is of type Set&lt;Character&gt; with 0 items."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「lettersは型Set&lt;Character&gt;で０項目を持ちます。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "level 6 has not yet been unlocked"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「レベル６はまだ開錠されていません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "min is -6 and max is 109"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「最小は-6で、最大は109です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "on the x-axis with an x value of 2"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「２のxの値でx-軸の上」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "p is being deinitialized"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「pは、デイニシャライズされている」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "six times three is 18"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「６かける３は18です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "someInt is now 107, and anotherInt is now 3"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「someIntは今は107、anotherIntは今は３です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "someInts is of type [Int] with 0 items."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「someIntsは型[Int]で0項目を持ちます。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "square.origin is now at (10.0, 10.0)"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「square.originは、現在(10.0, 10.0)です」を出力します））</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "tenEighty and alsoTenEighty refer to the same VideoMode instance."</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「tenEightyとalsoTenEightyは、同じVideoModeインスタンスに言及します。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "the number of characters in cafe is 4"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「cafeの文字数は4です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "the number of characters in café is 4"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「caféの文字数は4です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "the volume of fourByFiveByTwo is 40.0"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「fourByFiveByTwoのボリュームは、40.0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "theAceOfSpades: suit is ♠, value is 1 or 11"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「theAceOfSpades: 組み札は♠、値は１または11です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "true"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「true」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Prints "unusualMenagerie has 40 characters"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「unusualMenagerieは、40の文字を持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Random dice roll is 3</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（無作為にさいころを転がして、３です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Random dice roll is 4</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（無作為にさいころを転がして、４です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Random dice roll is 5</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（無作為にさいころを転がして、５です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Reimplement the Swift standard library's optional type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（スウィフト標準ライブラリのオプショナル型の再実装）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Return the appropriate value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（適切な値を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Rolled a 3</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（３を出した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Rolled a 4</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（４を出した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Rolled a 5</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（５を出した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Six eggs</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（卵６つ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Something that doesn't have an area</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（面積を持たない何か）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Song: Blue Suede Shoes, by Elvis Presley</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（歌：『青い裏革靴』、エルヴィス・プレスリー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Song: Never Gonna Give You Up, by Rick Astley</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（歌：『諦めないで』、リック・アストリー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Song: The One And Only, by Chesney Hawkes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（歌：『唯一無二の』、チェズニー・ホークス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Started a new game of Snakes and Ladders</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（ヘビとはしごの新しいゲームを始める）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Subsequent release renames MyProtocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（続くリリースでMyProtocolに改名する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Tandem: traveling at 22.0 miles per hour</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（２人乗り：時速22.0マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// The compile-time type of someInstance is SomeBaseClass,</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（someInstanceのコンパイル時での型は、SomeBaseClassです、）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// The following dictionaries have the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（以下の宣言は同じ型を持ちます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// The game is using a 6-sided dice</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（ゲームは、６面のさいころを使っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// The game lasted for 4 turns</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（ゲームは、４回続きました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// This assertion fails because -3 is not &gt;= 0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（この表明は失敗する、なぜなら-3 は &gt;= 0 ではないから。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// This code isn't valid.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（このコードは有効ではありません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// This is a comment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>//（これはコメントです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// This is a compile-time error: languageName cannot be changed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これはコンパイル時エラーです：anguageNameは変わることができません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// This is not valid, because x = y does not return a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これは有効ではありません、x = yが値を返さないので。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// This syntax is preferred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（この構文はより好まれます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// This syntax produces a warning.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（この構文は警告を生成します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// This will report a compile-time error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これは、コンパイル時エラーを報告します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Type annotation is required because String has multiple initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（型注釈は必須です、なぜならStringは複数のイニシャライザを持つからです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// UInt8 cannot store negative numbers, and so this will report an error</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（UInt8は負の数を保存することができません、それでこれはエラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（iOS 10 APIをiOSで、macOS 10.12 APIをmacOSで使う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Vehicle: 0 wheel(s)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（乗り物: ０輪）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Vehicle: traveling at 0.0 miles per hour</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（Vehicle: 時速0.0マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Weak capture of "self.parent" as "parent"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「parent」としての弱いキャプチャ「self.parent」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Work with the file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（ファイル処理。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// a is "test", b is 12, c is 3, and 9.45 is ignored</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（aは「test」です、bは12です、cは３です、そして9.45は無視されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// a is now equal to 10</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（aは今は10と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// a is now equal to 3</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（aは現在、３と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// a movie called Ghostbusters, dir. Ivan Reitman</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（『ゴーストバスターズ』と呼ばれる映画、監督アイヴァン・ライトマン）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// a positive double value of 3.14159</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（正の浮動小数点の値の3.14159）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// a string value of "hello"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（文字列値の「よろしく」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// afterDoubling also has values of (2.0, 8.0)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（afterDoublingも(2.0, 8.0)の値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// alsoPositive is a Vector2D instance with values of (3.0, 4.0)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（alsoPositiveは、値(-3.0, -4.0)をもつVector2Dインスタンです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// an (x, y) point at 3.0, 5.0</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（3.0、5.0の(x, y)座標点）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// an error was thrown</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（エラーがスローされた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// an integer value of 42</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（整数値の42）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// and so this will also report an error</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（それでこれも同様にエラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// and the runtime type of someInstance is SomeSubClass</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（そしてsomeInstanceの実行時での型は、SomeSubClassです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// anonymousCreature is of type Animal?, not Animal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（anonymousCreatureは、型Animal?です、Animalではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（anotherMathFunctionは、型(Int, Int) -&gt; Intであると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// anotherPi is also inferred to be of type Double</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（anotherPiもまたDouble型であると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（anotherThreeDoublesは、型[Double]で、[2.5, 2.5, 2.5]に等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// ants have 6 legs</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（蟻は、６本の足を持っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（centerRectの原点は(0.0, 0.0)、そのサイズは(0.0, 0.0)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// beginning is "Hello"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（beginningは "Hello" です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// boilingPointOfWater.temperatureInCelsius is 100.0</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（boilingPointOfWater.temperatureInCelsiusは、100.0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// cap the new audio level to the threshold level</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（新しい音声レベルを限界レベルに制限する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// cats have 4 legs</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（猫は、４本の足を持っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（centerRectの原点は(2.5, 2.5)、そのサイズは(3.0, 3.0)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// class definition goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（クラス定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// class-only protocol definition goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（クラス専用プロトコル定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// close(file) is called here, at the end of the scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（close(file)がここで呼ばれます、このスコープの終わりで。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// closure body goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（クロージャ本文が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// closure's body goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（クロージャの本文がここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// combinedVector is a Vector2D instance with values of (5.0, 5.0)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（combinedVectorは(5.0, 5.0)の値をもつVector2Dインスタンスです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// conformance to the Container protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（Containerプロトコルに準拠）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// convertedNumber is inferred to be of type "Int?", or "optional Int"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（convertedNumberは、型「Int?」または「オプショナルのInt」であると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// create a default value for someProperty inside this closure</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（このクロージャの内側でsomePropertyのための省略時の値をつくる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（customersInLine（並んでいる顧客）は、["Alex", "Ewa", "Barry", "Daniella"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// customersInLine is ["Barry", "Daniella"]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（customersInLine（並んでいる顧客）は、["Barry", "Daniella"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// customersInLine is ["Ewa", "Barry", "Daniella"]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（customersInLine（並んでいる顧客）は、["Ewa", "Barry", "Daniella"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// diceRoll will move us beyond the final square, so roll again</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（diceRollは私たちを最後の正方形を越えて動かします、それで再度転がします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// diceRoll will move us to the final square, so the game is over</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（diceRollは私たちを最後の正方形に動かします、なのでゲームは終わりです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// discard 'self' and return 'nil'</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「self」を廃棄して「nil」を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// do nothing - an arbitrary vehicle doesn't necessarily make a noise</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（何もしない - ある任意の乗り物が必ず音を出すわけではない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// do something with the instance of 'SomeStruct'</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「SomeStruct」のインスタンスで何か行う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// doubleIndex is an optional Int with no value, because 9.3 isn't in the array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（9.3がこの配列の中にははないので、doubleIndexは値のないオプショナルのIntです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// eAcute is é, combinedEAcute is é</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（eAcuteはéです、combinedEAcuteはéです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// earthsOrder is 3</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（earthsOrderは、３です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// enumeration definition goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（列挙定義がここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// f is a function of type (Int) -&gt; Number</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（fは型(Int) -&gt; Numberの関数です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// favoriteGenres has been initialized with three initial items</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（favoriteGenresは３つの初期項目で初期化されています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// favoriteGenres now contains 4 items</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（favoriteGenresは現在４項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// firstItem is equal to "Eggs"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（firstItemは、「Eggs」と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// firstItem is now equal to "Six eggs"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（firstItemは、現在「６つの卵」と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// for that parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（そのパラメータのための引数値に言及することができます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// freezingPointOfWater.temperatureInCelsius is 0.0</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（freezingPointOfWater.temperatureInCelsiusは、0.0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// friendlyWelcome is now "Bonjour!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（friendlyWelcomeは、現在「Bonjour!」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// fromTheTop is equal to "cuatro", and the stack now contains 3 strings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（fromTheTopは「cuatro」と等しいです、そしてスタックは現在は３つの文字列を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// function body goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（関数本文が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// function implementation goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（関数実装が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// http404Error is of type (Int, String), and equals (404, "Not Found")</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（http404Errorは、型が(Int, String)です、そして(404, "Not Found")と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// if we're still on the board, move up or down for a snake or a ladder</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（私達がまだ盤上ならば、ヘビまたははしごに対して上／下に移動する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// implementation of protocol requirements goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（プロトコル要件の実装が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// initialization of 'SomeStruct' failed and the initializer returned 'nil'</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「SomeStruct」の初期化は失敗したのでイニシャライザは「nil」を返した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// initializer implementation goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（イニシャライザ実装がここに来ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// instruction now equals "look over there"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（instructionは、現在「あそこを見て」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// integerPi equals 3, and is inferred to be of type Int</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（integerPiは、３に等しく、型Intであると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// its value is ["OneSix", "FiveEight", "FiveOneZero"]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（その値は["OneSix", "FiveEight", "FiveOneZero"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// john.fullName is "John Appleseed"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（john.fullNameは、「John Appleseed」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// letters is now an empty set, but is still of type Set&lt;Character&gt;</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（lettersは現在空の集合です、しかし依然として型Set&lt;Character&gt;です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// letters now contains 1 value of type Character</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（lettersは型Characterの値を１つ持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// lightSwitch is now equal to .on</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（lightSwitchは、現在.onと等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// maxAmplitudeFound is now 0</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（maxAmplitudeFoundは、現在0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// meaningOfLife is inferred to be of type Int</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（meaningOfLifeはInt型であると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// message is "3 times 2.5 is 7.5"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（messageは、「３かける2.５は7.５」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// move by the rolled amount</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（振られた量だけ移動）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// move up or down for a snake or ladder</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（ヘビまたははしごのための上下移動）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// moveNearerToZero now refers to the nested stepForward() function</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（moveNearerToZeroは、現在は入れ子にされたstepForward()関数に言及します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// moveNearerToZero now refers to the stepBackward() function</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（moveNearerToZeroは、現在はstepBackward()関数に言及します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// mysteryMeat's name is "[Unnamed]"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（nameMeatの名前は「[Unnamed]」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// namedMeat's name is "Bacon"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（nameMeatの名前は「ベーコン」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// namesOfIntegers is an empty [Int: String] dictionary</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（namesOfIntegersは、空の[Int: String]の辞書です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// namesOfIntegers is once again an empty dictionary of type [Int: String]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（namesOfIntegersは、またもとのように型[Int: String]の空の辞書です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// namesOfIntegers now contains 1 key-value pair</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（namesOfIntegersは、現在は１つの「キーと値」の対を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// ncc1701.fullName is "USS Enterprise"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（ncc1701.fullNameは、USSエンタープライズです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// negative is a Vector2D instance with values of (-3.0, -4.0)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（negativeは、値(-3.0, -4.0)をもつVector2Dインスタンです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// nested Rank enumeration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（入れ子にされたRank列挙）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// nested Suit enumeration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（入れ子にされたSuit列挙）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// new functionality to add to SomeType goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（SomeTypeに加える新しい機能性が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// no error was thrown</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（エラーはスローされなかった）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（centerRectの原点は (2.0, 2.0)、そのサイズは(5.0, 5.0)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// original IntStack implementation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（元々のIntStack実施）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// original Stack&lt;Element&gt; implementation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（元々のStack&lt;Element&gt;実装）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// original now has values of (4.0, 6.0)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（originalは、現在(4.0, 6.0)の値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// ovenLight is now equal to .high</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（ovenLightは現在.hightと等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// ovenLight is now equal to .off</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（ovenLightは現在.lowと等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// perform a suitable setting action here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（ふさわしい設定動作をここで行う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// perform some initialization here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（ここで何らかの初期化を行う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// perform the deinitialization</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（デイニシャライズを実行する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// pi equals 3.14159, and is inferred to be of type Double</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（piは、3.14159に等しく、型Doubleであると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// pi is inferred to be of type Double</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（パイはDouble型であると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（plusMinusVectorはVector2Dインスタンスで(4.0, -2.0)の値をもちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// possiblePlanet is of type Planet? and equals Planet.uranus</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（possiblePlanetは、型Planet?で、Planet.uranusに等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// potentialOverflow equals 32767, which is the maximum value an Int16 can hold</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（potentialOverflowは32767と等しく、それはInt16が持つことができる最大限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// precomposed is 한, decomposed is 한</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（合成済は「한」, 分解したものは「한」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// print(protocolValue.anotherProperty)  // Uncomment to see the error</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>// print(protocolValue.anotherProperty)  // コメントを外すとエラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// prints "hello, world" and returns a value of 12</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「よろしく、世界」を出力して値12を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// prints "hello, world" but does not return a value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「よろしく、世界」を出力しますが値を返しません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// produces an optional instance of 'SomeStruct'</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「SomeStruct」のオプショナルインスタンスを生成します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// protocol definition</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（プロトコル定義）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// protocol definition goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（プロトコル定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// refer to the argument values for the first and second parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（最初と２番目のパラメーターに対する引き数の値を参照します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// render the tick mark each minute (60 times)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（各分に目盛りを描画する（60回））</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// render the tick mark every 3 hours (3, 6, 9, 12)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（３時間ごとに目盛りを描画する（3, 6, 9, 12））</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// render the tick mark every 5 minutes (0, 5, 10, 15 ... 45, 50, 55)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（５分毎に目盛りを描画する（0, 5, 10, 15 ... 45, 50, 55））</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// return an appropriate subscript value here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（適切な添え字値をここで返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// returns 0, as if you had requested:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（まるであなたが次のように要請したかのように、0を返します：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// returns 10.0, which is the arithmetic mean of these three numbers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（10.0を返します、それはこれら３つの数の算術平均です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// returns 2</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（2を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// returns 3.0, which is the arithmetic mean of these five numbers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（3.0を返します、それはこれら５つの数の算術平均です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// returns 5</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（5を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// returns 7</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（7を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// returns 9</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（9を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// returns a value of 10</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（値10を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// returns a value of 20</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（値20を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// returns a value of 30</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（値30を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// returns a value of 40</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（値40を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// returns a value of 50</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（値50を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// returns a value of 7</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（値7を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（reversedNamesは["Ewa", "Daniella", "Chris", "Barry", "Alex"]に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// roll the dice</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（さいころを振る）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// rowHeight is equal to 90</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（rowHeightは、90と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// serverResponseCode contains an actual Int value of 404</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（serverResponseCodeは、実際にあるInt値404を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// serverResponseCode now contains no value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（serverResponseCodeは、現在は値を含みません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// shoppingList has been initialized with two initial items</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（shoppingListが、２つの最初の項目で初期化された）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// shoppingList now contains 3 items, and someone is making pancakes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（shoppingListは現在３つの項目を含みます、そして誰かはパンケーキを作っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// shoppingList now contains 4 items</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（shoppingListは、現在４つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// shoppingList now contains 5 items, and no apples</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（shoppingListは現在は５つの項目を含みます、そして「リンゴ」は含みません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// shoppingList now contains 6 items</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（shoppingListは、現在６つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// shoppingList now contains 6 items, and no Maple Syrup</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（shoppingListは、現在６つの項目、メープルシロップ以外を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// shoppingList now contains 7 items</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（shoppingListは、現在７つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// signedOverflow equals -128, which is the minimum value an Int8 can hold</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（signedOverflowは-128と等しく、それはInt8が持つことができる最小限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// signedOverflow is now equal to 127</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（signedOverflowは、現在127と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（sixDoublesは、[Double]と推論され、 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]に等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// someCreature is of type Animal?, not Animal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（someCreatureは、型Animal?です、Animalではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// someDictionary is now ["b": [10, 20], "a": [100, 2, 3]]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（someDictionaryは、現在["b": [10, 20], "a": [100, 2, 3]]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// someDictionary is now ["b": [10, 20], "a": [42, 2, 3]]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（someDictionaryは、現在["b": [10, 20], "a": [42, 2, 3]]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// someDictionary is still ["b": [10, 20], "a": [1, 2, 3]]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（someDictionaryは、依然として["b": [10, 20], "a": [1, 2, 3]]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// someFunction takes an integer and a closure as its arguments</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（someFunctionは、その引数として整数とクロージャをとります）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// someFunctionWithSideEffects is evaluated and returns 42</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（someFunctionWithSideEffectsは、評価されて42を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// someFunctionWithSideEffects is not evaluated</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（someFunctionWithSideEffectsは、評価されません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// someInt is now 107, and anotherInt is now 3</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（someIntは今は107、anotherIntは今は３です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// someInt is now 9</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（someIntは、現在９です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// someInts is now an empty array, but is still of type [Int]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（someIntsは、現在は空の配列です、しかし依然として型[Int]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// someInts now contains 1 value of type Int</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（someIntsは、現在は型Intの値ひとつを含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// someString is now "world", and anotherString is now "hello"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（someStringは今は「world」、anotherStringは今は「hello」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// someValue must be of the same type as SomeType</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（someValueは、SomeTypeと同じ型でなければなりません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// spiders have 8 legs</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（蜘蛛は、８本の足を持っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// store this as the new overall maximum input level</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これを新しい全体で最大の入力レベルとして保存する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// stringIndex is an optional Int containing a value of 2</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（stringIndexは、オプショナルのIntで値２を含んでいます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// strings is inferred to be of type [String]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（stringsは型[String]と推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// structure definition goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（構造体定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// subclass definition goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（サブクラス定義がここに来ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// subclass implementation of the required initializer goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（必須イニシャライザのサブクラス実装がここに来ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// subclass initialization goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（サブクラスの初期化が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// sunsetDirection is "west"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（sunsetDirectionは、「west」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// surveyAnswer is automatically set to nil</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（surveyAnswerは、自動的にnilに設定されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the "Dave" array is now [91, 82, 84] and the "Bev" array is now [80, 94, 81]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「Dave」配列は現在[91, 82, 84]です、そして「Bev」配列は現在[80, 94, 81]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the DataImporter class would provide data importing functionality here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（DataImporterクラスは、データをインポートする機能性をここで提供します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the DataImporter instance for the importer property has not yet been created</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（importerプロパティのためのDataImporterインスタンスは、まだ作成されていません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the DataImporter instance for the importer property has now been created</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（importerプロパティのためのDataImporterインスタンスが、今つくられました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the DataManager class would provide data management functionality here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（DataManagerクラスは、データ管理の機能性をここで提供します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the airports dictionary now contains 3 items</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（airports辞書は、現在３つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the apples constant is now equal to the removed "Apples" string</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（apples定数は、現在は削除された文字列「リンゴ」と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the counter's value is now 0</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（counterの値は、いま0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the counter's value is now 1</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（counterの値は、いま１です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the counter's value is now 6</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（counterの値は、いま６です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the first item in the list is now equal to "Six eggs" rather than "Eggs"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（リストの中の最初の項目は、現在「６つの卵」と等しいです、「卵」ではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the initial counter value is 0</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（counterの最初の値は、0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the item that was at index 0 has just been removed</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（インデックス0であった項目が、ちょうど今取り除かれました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the last item in the array has just been removed</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（配列での最後の項目が、ちょうど今取り除かれました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the mapleSyrup constant is now equal to the removed "Maple Syrup" string</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（定数mapleSyrupは、現在は削除された「メープルシロップ」文字列と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the range now represents integer values 6, 7, and 8</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（範囲は、現在は整数値６、７、そして８を表します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the range represents integer values 0, 1, and 2</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（範囲は、整数値０、１、そして２を表します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the stack now contains 4 strings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（スタックは、現在４つの文字列を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the type of "library" is inferred to be [MediaItem]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「library」の型は、[MediaItem]であると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the value for "LHR" has been changed to "London Heathrow"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（「LHR」に対する値は、「ロンドン・ヒースロー」に変えられました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// the value of parameterWithDefault is 12 inside the function body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（parameterWithDefaultの値はこの関数本文の内部で12です。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// these two strings are both empty, and are equivalent to each other</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これらの２つの文字列は両方とも空で、お互いに等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this causes an error</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これは、エラーを引き起こします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this equals 17</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これは17に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this example will compile successfully</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（この例は、うまくコンパイルします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this example will not compile, and will report an error</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（この例はコンパイルせず、エラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this function may or may not throw an error</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（この関数はエラーをスローするかもしれないししないかもしれない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this initializer creates a document with a nil name value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（このイニシャライザはnilのname値を使って書類を作成します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this initializer creates a document with a nonempty name value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（このイニシャライザは空でないname値を使って書類を作成します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this is a valid move, so find out its effect</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これは有効な動きです、それでその効果を調べます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this range represents integer values 0, 1, 2, and 3</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（この範囲構造体、整数値０、１、２、そして３を表します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this reports a compile-time error - a constant string cannot be modified</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これはコンパイル時エラー - 定数文字列は修正できません、を報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this reports a compile-time error - argument labels are required</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これはコンパイル時エラーを報告します - 引数ラベルが必要とされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this triggers a runtime error</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これは、実行時エラーの引き金となります）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this triggers an assert, because [2, 2] is outside of the matrix bounds</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これはある表明の引き金となります、なぜなら [2, 2]はマトリックス境界の外であるからです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this will report an error</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これは、エラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// this will report an error, even though firstValue is a variable property</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これはエラーを報告します、たとえfirstValueが変数プロパティであるとしてもです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（threeDoublesは、型[Double]で、 [0.0, 0.0, 0.0]に等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// toBeDoubled now has values of (2.0, 8.0)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（toBeDoubledは、現在(2.0, 8.0)の値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// trailing closure's body goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（後付クロージャの本文がここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// type method implementation goes here</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（型メソッドの実施が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// unsignedOverflow equals 0, which is the minimum value a UInt8 can hold</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（unsignedOverflowは0と等しく、それはUInt8が持つことができる最小限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// unsignedOverflow equals 255, which is the maximum value a UInt8 can hold</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（unsignedOverflowは255に等しく、それはUInt８が持つことができる最大限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// unsignedOverflow is now equal to 0</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（unsignedOverflowは、現在0と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// unsignedOverflow is now equal to 255</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（unsignedOverflowは、現在255と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// userDefinedColorName is nil, so colorNameToUse is set to the default of "red"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（userDefinedColorNameはnilです、なのでcolorNameToUseは省略時の「赤」に設定されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// userDefinedColorName is not nil, so colorNameToUse is set to "green"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これはnilではありません、それでcolorNameToUseは「緑」に設定されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// variableString is now "Horse and carriage"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（variableStringは、現在「馬と馬車」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// welcome now equals "hello there!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（welcomeは、現在「やあ！、こんにちは」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// welcome now equals "hello there"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（welcomeは、現在「やあ、こんにちは」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// welcome now equals "hello!"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（welcomeは、現在「こんにちは！」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// welcome now equals "hello"</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（welcomeは、現在「こんにちは」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// x is 10, and 20 is ignored</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（xは10です、そして20は無視されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// x is equal to 1, and y is equal to 2</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（xは１と等しい、そしてyは２と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// zero as a Double</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（浮動小数点のゼロ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// zero as an Int</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（整数のゼロ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>(3 % 4)<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>3<ept i="1">&lt;/c1&gt;</ept>, so this is equivalent to:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>(3 % 4)<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>3<ept i="1">&lt;/c1&gt;</ept>なので、これは以下に等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>(3 * 5)<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>15<ept i="1">&lt;/c1&gt;</ept>, so this is equivalent to:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>(3 * 5)<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>15<ept i="1">&lt;/c1&gt;</ept>なので、これは以下に等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>0xFp-2<ept i="0">&lt;/c0&gt;</ept> means 15 x 2<bpt i="1" x="1">&lt;s1&gt;</bpt>-2<ept i="1">&lt;/s1&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt>3.75<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>0xFp-2<ept i="0">&lt;/c0&gt;</ept>は、15 × 2<bpt i="1" x="1">&lt;s1&gt;</bpt>-2<ept i="1">&lt;/s1&gt;</ept>、または<bpt i="2" x="2">&lt;c2&gt;</bpt>3.75<ept i="2">&lt;/c2&gt;</ept>を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>0xFp2<ept i="0">&lt;/c0&gt;</ept> means 15 x 2<bpt i="1" x="1">&lt;s1&gt;</bpt>2<ept i="1">&lt;/s1&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt>60.0<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>0xFp2<ept i="0">&lt;/c0&gt;</ept>は、15 × 2<bpt i="1" x="1">&lt;s1&gt;</bpt>2<ept i="1">&lt;/s1&gt;</ept>、または<bpt i="2" x="2">&lt;c2&gt;</bpt>60.0<ept i="2">&lt;/c2&gt;</ept>を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>1.25e-2<ept i="0">&lt;/c0&gt;</ept> means 1.25 x 10<bpt i="1" x="1">&lt;s1&gt;</bpt>-2<ept i="1">&lt;/s1&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt>0.0125<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>1.25e-2<ept i="0">&lt;/c0&gt;</ept>は、1.25 × 10<bpt i="1" x="1">&lt;s1&gt;</bpt>-2<ept i="1">&lt;/s1&gt;</ept>、または<bpt i="2" x="2">&lt;c2&gt;</bpt>0.0125<ept i="2">&lt;/c2&gt;</ept>を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>1.25e2<ept i="0">&lt;/c0&gt;</ept> means 1.25 x 10<bpt i="1" x="1">&lt;s1&gt;</bpt>2<ept i="1">&lt;/s1&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt>125.0<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>1.25e2<ept i="0">&lt;/c0&gt;</ept>は、1.25 × 10<bpt i="1" x="1">&lt;s1&gt;</bpt>2<ept i="1">&lt;/s1&gt;</ept>、または<bpt i="2" x="2">&lt;c2&gt;</bpt>125.0<ept i="2">&lt;/c2&gt;</ept>を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>123456789[0]<ept i="0">&lt;/c0&gt;</ept> returns <bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>123456789[0]<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept>を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>123456789[1]<ept i="0">&lt;/c0&gt;</ept> returns <bpt i="1" x="1">&lt;c1&gt;</bpt>8<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>123456789[1]<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>8<ept i="1">&lt;/c1&gt;</ept>を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept> times <bpt i="1" x="1">&lt;c1&gt;</bpt>5<ept i="1">&lt;/c1&gt;</ept> equals <bpt i="2" x="2">&lt;c2&gt;</bpt>5<ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>掛ける<bpt i="1" x="1">&lt;c1&gt;</bpt>5<ept i="1">&lt;/c1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>5<ept i="2">&lt;/c2&gt;</ept>に等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>2<ept i="0">&lt;/c0&gt;</ept> plus <bpt i="1" x="1">&lt;c1&gt;</bpt>3<ept i="1">&lt;/c1&gt;</ept> equals <bpt i="2" x="2">&lt;c2&gt;</bpt>5<ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>2<ept i="0">&lt;/c0&gt;</ept>足す<bpt i="1" x="1">&lt;c1&gt;</bpt>3<ept i="1">&lt;/c1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>5<ept i="2">&lt;/c2&gt;</ept>に等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>5<ept i="0">&lt;/c0&gt;</ept> remainder <bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept> equals <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>5<ept i="0">&lt;/c0&gt;</ept>割る<bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept>の余りは<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>に等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;=<ept i="0">&lt;/c0&gt;</ept> followed by a version number</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;=<ept i="0">&lt;/c0&gt;</ept>にバージョン番号が続きます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@autoclosure<ept i="0">&lt;/c0&gt;</ept> is now an attribute of the parameter declaration, not its type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@autoclosure<ept i="0">&lt;/c0&gt;</ept>は今ではパラメーター宣言の属性です、それの型ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept> can represent an instance of any type at all, including function types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept>は、関数型を含めて、ともかくどんな型のインスタンスでも表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept> can represent an instance of any class type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept>は、どんなクラス型のインスタンスでも表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bank<ept i="0">&lt;/c0&gt;</ept> keeps track of the current number of coins it holds with its <bpt i="1" x="1">&lt;c1&gt;</bpt>coinsInBank<ept i="1">&lt;/c1&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bank<ept i="0">&lt;/c0&gt;</ept>は、それがその<bpt i="1" x="1">&lt;c1&gt;</bpt>coinsInBank<ept i="1">&lt;/c1&gt;</ept>プロパティで保持するコインの現在の数の情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>C1<ept i="0">&lt;/c0&gt;</ept> must conform to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept> protocol (written as <bpt i="2" x="2">&lt;c2&gt;</bpt>C1: Container<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>C1<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠しなければなりません（<bpt i="2" x="2">&lt;c2&gt;</bpt>C1: Container<ept i="2">&lt;/c2&gt;</ept>のように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>C2<ept i="0">&lt;/c0&gt;</ept> must also conform to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept> protocol (written as <bpt i="2" x="2">&lt;c2&gt;</bpt>C2: Container<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>C2<ept i="0">&lt;/c0&gt;</ept>もまた、<bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠しなければなりません（<bpt i="2" x="2">&lt;c2&gt;</bpt>C2: Container<ept i="2">&lt;/c2&gt;</ept>のように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Color<ept i="0">&lt;/c0&gt;</ept> provides an initializer with three appropriately named parameters of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept> for its red, green, and blue components.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Color<ept i="0">&lt;/c0&gt;</ept>は、３つの適切に命名された型<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>のパラメータを、それの赤、緑、および青の構成要素のために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Dice<ept i="0">&lt;/c0&gt;</ept> also has an initializer, to set up its initial state.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Dice<ept i="0">&lt;/c0&gt;</ept>はまた、その最初の状態を設定するために、イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Dice<ept i="0">&lt;/c0&gt;</ept> provides one instance method, <bpt i="1" x="1">&lt;c1&gt;</bpt>roll<ept i="1">&lt;/c1&gt;</ept>, which returns an integer value between 1 and the number of sides on the dice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Dice<ept i="0">&lt;/c0&gt;</ept>は１つのインスタンスメソッド、<bpt i="1" x="1">&lt;c1&gt;</bpt>roll<ept i="1">&lt;/c1&gt;</ept>を提供します、それは、１とさいころ上の面の数との間の整数値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>DiceGameDelegate<ept i="0">&lt;/c0&gt;</ept> provides three methods for tracking the progress of a game.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>DiceGameDelegate<ept i="0">&lt;/c0&gt;</ept>は、３つのメソッドをゲームの進捗を追うために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>DiceGameTracker<ept i="0">&lt;/c0&gt;</ept> implements all three methods required by <bpt i="1" x="1">&lt;c1&gt;</bpt>DiceGameDelegate<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>DiceGameTracker<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>DiceGameDelegate<ept i="1">&lt;/c1&gt;</ept>によって要求される３つのメソッド全てを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> has a precision of at least 15 decimal digits, whereas the precision of <bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept> can be as little as 6 decimal digits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>は少なくとも10進数で15桁の精度を持ちます、一方で<bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>の精度は10進数で６桁ほどです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> represents a 64-bit floating-point number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>は、64ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> defines a placeholder name for a type to be provided later.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>は、プレースホルダ名を、後で提供されることになるある型に対して定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept> represents a 32-bit floating-point number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>は、32ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>LevelTracker<ept i="0">&lt;/c0&gt;</ept> also defines two type functions to work with the <bpt i="1" x="1">&lt;c1&gt;</bpt>highestUnlockedLevel<ept i="1">&lt;/c1&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>LevelTracker<ept i="0">&lt;/c0&gt;</ept>はまた、２つの型関数を定義して<bpt i="1" x="1">&lt;c1&gt;</bpt>highestUnlockedLevel<ept i="1">&lt;/c1&gt;</ept>プロパティを取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Matrix<ept i="0">&lt;/c0&gt;</ept> provides an initializer that takes two parameters called <bpt i="1" x="1">&lt;c1&gt;</bpt>rows<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>columns<ept i="2">&lt;/c2&gt;</ept>, and creates an array that is large enough to store <bpt i="3" x="3">&lt;c3&gt;</bpt>rows * columns<ept i="3">&lt;/c3&gt;</ept> values of type <bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Matrix<ept i="0">&lt;/c0&gt;</ept>はひとつのイニシャライザを提供します、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>rows<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>columns<ept i="2">&lt;/c2&gt;</ept>と呼ばれる２つのパラメータをとり、型<bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept>で個数<bpt i="3" x="3">&lt;c3&gt;</bpt>rows * columns<ept i="3">&lt;/c3&gt;</ept>の値を格納するのに十分大きい配列をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Point<ept i="0">&lt;/c0&gt;</ept> encapsulates the x- and y-coordinate of a point.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Point<ept i="0">&lt;/c0&gt;</ept>は、ある地点のxおよひy座標をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Rank<ept i="0">&lt;/c0&gt;</ept> also defines a computed property, <bpt i="1" x="1">&lt;c1&gt;</bpt>values<ept i="1">&lt;/c1&gt;</ept>, which returns an instance of the <bpt i="2" x="2">&lt;c2&gt;</bpt>Values<ept i="2">&lt;/c2&gt;</ept> structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Rank<ept i="0">&lt;/c0&gt;</ept>はまた、ある計算プロパティ、<bpt i="1" x="1">&lt;c1&gt;</bpt>values<ept i="1">&lt;/c1&gt;</ept>を定義します、それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Values<ept i="2">&lt;/c2&gt;</ept>構造体のインスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>RecipeIngredient<ept i="0">&lt;/c0&gt;</ept> also defines a convenience initializer, <bpt i="1" x="1">&lt;c1&gt;</bpt>init(name: String)<ept i="1">&lt;/c1&gt;</ept>, which is used to create a <bpt i="2" x="2">&lt;c2&gt;</bpt>RecipeIngredient<ept i="2">&lt;/c2&gt;</ept> instance by name alone.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>RecipeIngredient<ept i="0">&lt;/c0&gt;</ept>はまた、便宜イニシャライザ、<bpt i="1" x="1">&lt;c1&gt;</bpt>init(name: String)<ept i="1">&lt;/c1&gt;</ept>を定義します、それは、名前だけで<bpt i="2" x="2">&lt;c2&gt;</bpt>RecipeIngredient<ept i="2">&lt;/c2&gt;</ept>インスタンスを作成するのに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept> defines a rectangle by an origin point and a size.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept>は、原点と大きさによって長方形を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Residence<ept i="0">&lt;/c0&gt;</ept> instances have a single <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> property called <bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfRooms<ept i="2">&lt;/c2&gt;</ept>, with a default value of <bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Residence<ept i="0">&lt;/c0&gt;</ept>インスタンスは、<bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfRooms<ept i="2">&lt;/c2&gt;</ept>と呼ばれる省略時の値<bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>を持つ<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>プロパティただひとつを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ShoppingListItem<ept i="0">&lt;/c0&gt;</ept> does not define an initializer to provide an initial value for <bpt i="1" x="1">&lt;c1&gt;</bpt>purchased<ept i="1">&lt;/c1&gt;</ept>, because items in a shopping list (as modeled here) always start out unpurchased.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ShoppingListItem<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>purchased<ept i="1">&lt;/c1&gt;</ept>に初期値を用意するイニシャライザを定義しません、なぜなら、購入品目リストの項目が（ここでモデル化されるように）常に未購入で始められるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Size<ept i="0">&lt;/c0&gt;</ept> encapsulates a <bpt i="1" x="1">&lt;c1&gt;</bpt>width<ept i="1">&lt;/c1&gt;</ept> and a <bpt i="2" x="2">&lt;c2&gt;</bpt>height<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Size<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>width<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>height<ept i="2">&lt;/c2&gt;</ept>をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>SomeType(ofInitialValue)<ept i="0">&lt;/c0&gt;</ept> is the default way to call the initializer of a Swift type and pass in an initial value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>SomeType(ofInitialValue)<ept i="0">&lt;/c0&gt;</ept>は、あるスウィフト型のイニシャライザを呼んで、初期値を渡すために通常使う方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> values can be added together (or <bpt i="1" x="1">&lt;e1&gt;</bpt>concatenated<ept i="1">&lt;/e1&gt;</ept>) with the addition operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>+<ept i="2">&lt;/c2&gt;</ept>) to create a new <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>値は、新しい<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>値をつくるために加算演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>+<ept i="2">&lt;/c2&gt;</ept>）を使って１つに足し合わされる（または<bpt i="1" x="1">&lt;e1&gt;</bpt>連結される<ept i="1">&lt;/e1&gt;</ept>）ことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> values can be constructed by passing an array of <bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept> values as an argument to its initializer:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>値は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept>値の配列をそれのイニシャライザへの引数として渡すことによって組み立てられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Tandem<ept i="0">&lt;/c0&gt;</ept> inherits all of the properties and methods from <bpt i="1" x="1">&lt;c1&gt;</bpt>Bicycle<ept i="1">&lt;/c1&gt;</ept>, which in turn inherits all of the properties and methods from <bpt i="2" x="2">&lt;c2&gt;</bpt>Vehicle<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Tandem<ept i="0">&lt;/c0&gt;</ept>は、すべてのプロパティとメソッドを<bpt i="1" x="1">&lt;c1&gt;</bpt>Bicycle<ept i="1">&lt;/c1&gt;</ept>から継承します、そして今度はそれがすべてのプロパティとメソッドを<bpt i="2" x="2">&lt;c2&gt;</bpt>Vehicle<ept i="2">&lt;/c2&gt;</ept>から継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>UInt8<ept i="0">&lt;/c0&gt;</ept> integers have eight bits and can store any value between <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>255<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>UInt8<ept i="0">&lt;/c0&gt;</ept>整数は、８ビットを持ち、<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>255<ept i="2">&lt;/c2&gt;</ept>の間でのどんな値でも保存することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a == a<ept i="0">&lt;/c0&gt;</ept> (Reflexivity)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a == a<ept i="0">&lt;/c0&gt;</ept>（反射性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a == b &amp;&amp; b == c<ept i="0">&lt;/c0&gt;</ept> implies <bpt i="1" x="1">&lt;c1&gt;</bpt>a == c<ept i="1">&lt;/c1&gt;</ept> (Transitivity)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a == b &amp;&amp; b == c<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>a == c<ept i="1">&lt;/c1&gt;</ept>を意味する（推移性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a == b<ept i="0">&lt;/c0&gt;</ept> implies <bpt i="1" x="1">&lt;c1&gt;</bpt>b == a<ept i="1">&lt;/c1&gt;</ept> (Symmetry)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a == b<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>b == a<ept i="1">&lt;/c1&gt;</ept>を意味する（対称性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> = (<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept> x <bpt i="2" x="2">&lt;c2&gt;</bpt>some multiplier<ept i="2">&lt;/c2&gt;</ept>) + <bpt i="3" x="3">&lt;c3&gt;</bpt>remainder<ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> = (<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept> × <bpt i="2" x="2">&lt;c2&gt;</bpt>いくらかの乗数<ept i="2">&lt;/c2&gt;</ept>) + <bpt i="3" x="3">&lt;c3&gt;</bpt>余り<ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>anotherContainer<ept i="0">&lt;/c0&gt;</ept> is a container of type <bpt i="1" x="1">&lt;c1&gt;</bpt>C2<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>anotherContainer<ept i="0">&lt;/c0&gt;</ept>は、型<bpt i="1" x="1">&lt;c1&gt;</bpt>C2<ept i="1">&lt;/c1&gt;</ept>のコンテナです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>board[0]<ept i="0">&lt;/c0&gt;</ept> always equals <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept> and has no effect.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>board[0]<ept i="0">&lt;/c0&gt;</ept>は、常に<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>に等しくて、効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>didSet<ept i="0">&lt;/c0&gt;</ept> is called immediately after the new value is stored.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>didSet<ept i="0">&lt;/c0&gt;</ept>は、新しい値が保存された直後に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>first<ept i="0">&lt;/c0&gt;</ept>, of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>first<ept i="0">&lt;/c0&gt;</ept>、型<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>のもの</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>increment()<ept i="0">&lt;/c0&gt;</ept> increments the counter by <bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>increment()<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>だけカウンターを増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>increment(by: Int)<ept i="0">&lt;/c0&gt;</ept> increments the counter by a specified integer amount.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>increment(by: Int)<ept i="0">&lt;/c0&gt;</ept>は、指定された量の整数でカウンターを増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>item is Movie<ept i="0">&lt;/c0&gt;</ept> returns <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> if the current <bpt i="2" x="2">&lt;c2&gt;</bpt>MediaItem<ept i="2">&lt;/c2&gt;</ept> is a <bpt i="3" x="3">&lt;c3&gt;</bpt>Movie<ept i="3">&lt;/c3&gt;</ept> instance and <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept> if it is not.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>item is Movie<ept i="0">&lt;/c0&gt;</ept>は、現在の<bpt i="2" x="2">&lt;c2&gt;</bpt>MediaItem<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Movie<ept i="3">&lt;/c3&gt;</ept>インスタンスであるならば<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を、そうでないならば<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>john.residence<ept i="0">&lt;/c0&gt;</ept> now contains an actual <bpt i="1" x="1">&lt;c1&gt;</bpt>Residence<ept i="1">&lt;/c1&gt;</ept> instance, rather than <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>john.residence<ept i="0">&lt;/c0&gt;</ept>は、今では実際の<bpt i="1" x="1">&lt;c1&gt;</bpt>Residence<ept i="1">&lt;/c1&gt;</ept>インスタンスを含みます、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> and the Booleans <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept> are now <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Literals<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>とブールの<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>は現在<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>リテラル<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>number.kind<ept i="0">&lt;/c0&gt;</ept> is already known to be of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Int.Kind<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>number.kind<ept i="0">&lt;/c0&gt;</ept>は、既に型<bpt i="1" x="1">&lt;c1&gt;</bpt>Int.Kind<ept i="1">&lt;/c1&gt;</ept>であると知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>repeat<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept> evaluates its condition at the end of each pass through the loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>repeat<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept>は、その条件を、ループを通り抜けるそれぞれの終わりで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>reset()<ept i="0">&lt;/c0&gt;</ept> resets the counter to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>reset()<ept i="0">&lt;/c0&gt;</ept>は、カウンターをゼロに再設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>second<ept i="0">&lt;/c0&gt;</ept>, of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Int?<ept i="1">&lt;/c1&gt;</ept>, or “optional <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>second<ept i="0">&lt;/c0&gt;</ept>、型<bpt i="1" x="1">&lt;c1&gt;</bpt>Int?<ept i="1">&lt;/c1&gt;</ept>、つまり「オプショナルの<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>someContainer<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>anotherContainer<ept i="1">&lt;/c1&gt;</ept> contain the same type of items.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>someContainer<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>anotherContainer<ept i="1">&lt;/c1&gt;</ept>は、同じ型の項目を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>someContainer<ept i="0">&lt;/c0&gt;</ept> is a container of type <bpt i="1" x="1">&lt;c1&gt;</bpt>C1<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>someContainer<ept i="0">&lt;/c0&gt;</ept>は、型<bpt i="1" x="1">&lt;c1&gt;</bpt>C1<ept i="1">&lt;/c1&gt;</ept>のコンテナです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> evaluates its condition at the start of each pass through the loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>は、その条件を、ループを通り抜けるそれぞれの始まりで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept> is called just before the value is stored.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept>は、値が保存される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>currentValue<ept i="1">&lt;/c1&gt;</ept> has an initial value of <bpt i="2" x="2">&lt;c2&gt;</bpt>3<ept i="2">&lt;/c2&gt;</ept>, which means that <bpt i="3" x="3">&lt;c3&gt;</bpt>currentValue &gt; 0<ept i="3">&lt;/c3&gt;</ept> returns <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>, causing <bpt i="5" x="5">&lt;c5&gt;</bpt>chooseStepFunction(backward:)<ept i="5">&lt;/c5&gt;</ept> to return the <bpt i="6" x="6">&lt;c6&gt;</bpt>stepBackward(_:)<ept i="6">&lt;/c6&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>currentValue<ept i="1">&lt;/c1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>3<ept i="2">&lt;/c2&gt;</ept>の初期値を持ちます、そしてそれは、<bpt i="3" x="3">&lt;c3&gt;</bpt>currentValue &gt; 0<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>を返して、<bpt i="5" x="5">&lt;c5&gt;</bpt>chooseStepFunction(backward:)<ept i="5">&lt;/c5&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt>stepBackward(_:)<ept i="6">&lt;/c6&gt;</ept>関数を返すことを引き起こすのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept> values are described in <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Strings and Characters<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept>値は<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>文字列と文字<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Color<ept i="2">&lt;/c2&gt;</ept> also provides a second initializer with a single <bpt i="3" x="3">&lt;c3&gt;</bpt>white<ept i="3">&lt;/c3&gt;</ept> parameter, which is used to provide the same value for all three color components.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Color<ept i="2">&lt;/c2&gt;</ept>はまた、ただ１つの<bpt i="3" x="3">&lt;c3&gt;</bpt>white<ept i="3">&lt;/c3&gt;</ept>パラメータを持つ第２のイニシャライザを提供します、それは３つの色構成要素すべてに同じ値を提供するのに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Dice<ept i="2">&lt;/c2&gt;</ept> instances have an integer property called <bpt i="3" x="3">&lt;c3&gt;</bpt>sides<ept i="3">&lt;/c3&gt;</ept>, which represents how many sides they have, and a property called <bpt i="4" x="4">&lt;c4&gt;</bpt>generator<ept i="4">&lt;/c4&gt;</ept>, which provides a random number generator from which to create dice roll values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Dice<ept i="2">&lt;/c2&gt;</ept>インスタンスは、それがどれくらいの面を持つのかを表す<bpt i="3" x="3">&lt;c3&gt;</bpt>sides<ept i="3">&lt;/c3&gt;</ept>と呼ばれる整数プロパティ、そしてそこからさいころを振った値を作成する乱数生成器を提供する<bpt i="4" x="4">&lt;c4&gt;</bpt>generator<ept i="4">&lt;/c4&gt;</ept>と呼ばれるプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Stack<ept i="2">&lt;/c2&gt;</ept> provides two methods, <bpt i="3" x="3">&lt;c3&gt;</bpt>push<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>pop<ept i="4">&lt;/c4&gt;</ept>, to push and pop values on and off the stack.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Stack<ept i="2">&lt;/c2&gt;</ept>は２つのメソッド、<bpt i="3" x="3">&lt;c3&gt;</bpt>push<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>pop<ept i="4">&lt;/c4&gt;</ept>を提供します、それでスタック上に値を押し込んだり飛び出させたりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>CartItem<ept i="3">&lt;/c3&gt;</ept> introduces a stored constant property called <bpt i="4" x="4">&lt;c4&gt;</bpt>quantity<ept i="4">&lt;/c4&gt;</ept> and ensures that this property always has a value of at least <bpt i="5" x="5">&lt;c5&gt;</bpt>1<ept i="5">&lt;/c5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>CartItem<ept i="3">&lt;/c3&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>quantity<ept i="4">&lt;/c4&gt;</ept>と呼ばれる保存定数プロパティを導入します、そしてこのプロパティが常に少なくとも<bpt i="5" x="5">&lt;c5&gt;</bpt>1<ept i="5">&lt;/c5&gt;</ept>の値を持つことを確実にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>ShoppingListItem<ept i="3">&lt;/c3&gt;</ept> also adds a computed <bpt i="4" x="4">&lt;c4&gt;</bpt>description<ept i="4">&lt;/c4&gt;</ept> property, which provides a textual description of a <bpt i="5" x="5">&lt;c5&gt;</bpt>ShoppingListItem<ept i="5">&lt;/c5&gt;</ept> instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>ShoppingListItem<ept i="3">&lt;/c3&gt;</ept>はまた、計算される<bpt i="4" x="4">&lt;c4&gt;</bpt>description<ept i="4">&lt;/c4&gt;</ept>プロパティを加えます、それは、<bpt i="5" x="5">&lt;c5&gt;</bpt>ShoppingListItem<ept i="5">&lt;/c5&gt;</ept>インスタンスのテキストでの解説を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>if<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>while<ept i="4">&lt;/c4&gt;</ept> statements are described in more detail in <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Control Flow<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>if<ept i="3">&lt;/c3&gt;</ept>および<bpt i="4" x="4">&lt;c4&gt;</bpt>while<ept i="4">&lt;/c4&gt;</ept>文は更に詳細に<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>「制御の流れ」<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Dictionary<ept i="4">&lt;/c4&gt;</ept> needs its keys to be hashable so that it can check whether it already contains a value for a particular key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Dictionary<ept i="4">&lt;/c4&gt;</ept>は、それが特定のキーのためにすでに値を含むかどうか確認できるように、そのキーにハッシュ化できることを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Person<ept i="4">&lt;/c4&gt;</ept> instances have an optional <bpt i="5" x="5">&lt;c5&gt;</bpt>residence<ept i="5">&lt;/c5&gt;</ept> property of type <bpt i="6" x="6">&lt;c6&gt;</bpt>Residence?<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Person<ept i="4">&lt;/c4&gt;</ept>インスタンスは、型<bpt i="6" x="6">&lt;c6&gt;</bpt>Residence?<ept i="6">&lt;/c6&gt;</ept>のオプショナル<bpt i="5" x="5">&lt;c5&gt;</bpt>residence<ept i="5">&lt;/c5&gt;</ept>プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>HTMLElement<ept i="5">&lt;/c5&gt;</ept> also defines an optional <bpt i="6" x="6">&lt;c6&gt;</bpt>text<ept i="6">&lt;/c6&gt;</ept> property, which you can set to a string that represents the text to be rendered within that HTML element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>HTMLElement<ept i="5">&lt;/c5&gt;</ept>はまた、オプショナルの<bpt i="6" x="6">&lt;c6&gt;</bpt>text<ept i="6">&lt;/c6&gt;</ept>プロパティを定義します、それは、あなたはそれをテキストがそのHTML要素の範囲内で提出されると述べる文字列に設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt>tenEighty<ept i="7">&lt;/c7&gt;</ept> and <bpt i="8" x="8">&lt;c8&gt;</bpt>alsoTenEighty<ept i="8">&lt;/c8&gt;</ept> themselves do not “store” the <bpt i="9" x="9">&lt;c9&gt;</bpt>VideoMode<ept i="9">&lt;/c9&gt;</ept> instance—instead, they both <bpt i="10" x="10">&lt;e10&gt;</bpt>refer<ept i="10">&lt;/e10&gt;</ept> to a <bpt i="11" x="11">&lt;c11&gt;</bpt>VideoMode<ept i="11">&lt;/c11&gt;</ept> instance behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt>tenEighty<ept i="7">&lt;/c7&gt;</ept>および<bpt i="8" x="8">&lt;c8&gt;</bpt>alsoTenEighty<ept i="8">&lt;/c8&gt;</ept>それら自身は<bpt i="9" x="9">&lt;c9&gt;</bpt>VideoMode<ept i="9">&lt;/c9&gt;</ept>インスタンスを格納しません ― そうではなく、それらは両方とも舞台裏である<bpt i="11" x="11">&lt;c11&gt;</bpt>VideoMode<ept i="11">&lt;/c11&gt;</ept>インスタンスに<bpt i="10" x="10">&lt;e10&gt;</bpt>言及します<ept i="10">&lt;/e10&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Access control<ept i="0">&lt;/e0&gt;</ept> restricts access to parts of your code from code in other source files and modules.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>アクセス制御<ept i="0">&lt;/e0&gt;</ept>は、他のソースファイルとモジュールの中のコードからのアクセスをあなたのコードの一部分に制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Assertions<ept i="0">&lt;/e0&gt;</ept> and <bpt i="1" x="1">&lt;e1&gt;</bpt>preconditions<ept i="1">&lt;/e1&gt;</ept> are checks that happen at runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>表明<ept i="0">&lt;/e0&gt;</ept>と<bpt i="1" x="1">&lt;e1&gt;</bpt>前提条件<ept i="1">&lt;/e1&gt;</ept>は、起こることを実行時で調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Attributes<ept i="0">&lt;/e0&gt;</ept> provide more information about a declaration or type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>属性<ept i="0">&lt;/e0&gt;</ept>は、宣言または型に関するより多くの情報を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Binary expressions<ept i="0">&lt;/e0&gt;</ept> combine an infix binary operator with the expression that it takes as its left-hand and right-hand arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>二項式<ept i="0">&lt;/e0&gt;</ept>は、接中辞二進数演算子を、それがその左手側と右手側の引数としてとる式と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Binary<ept i="0">&lt;/e0&gt;</ept> operators operate on two targets (such as <bpt i="1" x="1">&lt;c1&gt;</bpt>2 + 3<ept i="1">&lt;/c1&gt;</ept>) and are <bpt i="2" x="2">&lt;e2&gt;</bpt>infix<ept i="2">&lt;/e2&gt;</ept> because they appear in between their two targets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>二項<ept i="0">&lt;/e0&gt;</ept>演算子は、２つの目標に作用します（例えば<bpt i="1" x="1">&lt;c1&gt;</bpt>2 + 3<ept i="1">&lt;/c1&gt;</ept>のように）、そしてそれがそれら２つの目標の間に現れるので<bpt i="2" x="2">&lt;e2&gt;</bpt>接中辞<ept i="2">&lt;/e2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Bitwise operators<ept i="0">&lt;/e0&gt;</ept> enable you to manipulate the individual raw data bits within a data structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ビット単位演算子<ept i="0">&lt;/e0&gt;</ept>は、あなたにあるデータ構造内の個々の生のデータ・ビットを操作することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Classes<ept i="0">&lt;/e0&gt;</ept> and <bpt i="1" x="1">&lt;e1&gt;</bpt>structures<ept i="1">&lt;/e1&gt;</ept> are general-purpose, flexible constructs that become the building blocks of your program’s code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>クラス<ept i="0">&lt;/e0&gt;</ept>および<bpt i="1" x="1">&lt;e1&gt;</bpt>構造体<ept i="1">&lt;/e1&gt;</ept>は、あなたのプログラムのコードの建築ブロックになる、万能で、柔軟な構造物です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Closure expressions<ept i="0">&lt;/e0&gt;</ept> are a way to write inline closures in a brief, focused syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>クロージャ式<ept i="0">&lt;/e0&gt;</ept>は、簡潔な、焦点のあった構文で、処理の流れに組み込まれた（行内の、インラインの）クロージャを書く方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Closures<ept i="0">&lt;/e0&gt;</ept> are self-contained blocks of functionality that can be passed around and used in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>クロージャ<ept i="0">&lt;/e0&gt;</ept>は、機能性の完全独立のブロック、かたまりです、それは、あなたのコードにおいてあちこちに渡され使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Compound assignment operators<ept i="0">&lt;/e0&gt;</ept> combine assignment (<bpt i="1" x="1">&lt;c1&gt;</bpt>=<ept i="1">&lt;/c1&gt;</ept>) with another operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>複合代入演算子<ept i="0">&lt;/e0&gt;</ept>は、代入（<bpt i="1" x="1">&lt;c1&gt;</bpt>=<ept i="1">&lt;/c1&gt;</ept>）を別の操作と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Control transfer statements<ept i="0">&lt;/e0&gt;</ept> change the order in which your code is executed, by transferring control from one piece of code to another.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>制御移動文<ept i="0">&lt;/e0&gt;</ept>は、制御をコードのひとつの部分から別のものまで移すことによって、あなたのコードが実行される順番を変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Convenience initializers<ept i="0">&lt;/e0&gt;</ept> are secondary, supporting initializers for a class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>便宜イニシャライザ<ept i="0">&lt;/e0&gt;</ept>は副次的なもので、あるクラスのためのイニシャライザを支援します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Declaration modifiers<ept i="0">&lt;/e0&gt;</ept> are keywords or context-sensitive keywords that modify the behavior or meaning of a declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>宣言修飾子<ept i="0">&lt;/e0&gt;</ept>は、キーワードまたは文脈依存キーワードです、それは宣言のふるまいや意味することを修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Delegation<ept i="0">&lt;/e0&gt;</ept> is a design pattern that enables a class or structure to hand off (or <bpt i="1" x="1">&lt;e1&gt;</bpt>delegate<ept i="1">&lt;/e1&gt;</ept>) some of its responsibilities to an instance of another type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>委任<ept i="0">&lt;/e0&gt;</ept>は、クラスまたは構造体にそれのもつ責務の一部を別の型のインスタンスへと手渡す（または<bpt i="1" x="1">&lt;e1&gt;</bpt>委任する<ept i="1">&lt;/e1&gt;</ept>）ことを可能にするデザイン・パターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Designated initializers<ept i="0">&lt;/e0&gt;</ept> are the primary initializers for a class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>指定イニシャライザ<ept i="0">&lt;/e0&gt;</ept>は、あるクラスのための主要なイニシャライザです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Error handling<ept i="0">&lt;/e0&gt;</ept> is the process of responding to and recovering from error conditions in your program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>エラー処理<ept i="0">&lt;/e0&gt;</ept>は、あなたのプログラムにおいてエラー状態へ応答してそこから復旧する過程です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Extensions<ept i="0">&lt;/e0&gt;</ept> add new functionality to an existing class, structure, enumeration, or protocol type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>拡張<ept i="0">&lt;/e0&gt;</ept>は、新しい機能性を既存のクラス、構造体、列挙、またはプロトコル型に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>File-private access<ept i="0">&lt;/e0&gt;</ept> restricts the use of an entity to its own defining source file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ファイル外非公開アクセス（ファイル私用）<ept i="0">&lt;/e0&gt;</ept>は、ある実在の使用をそれ自身の定義ソースファイルに制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Floating-point literals<ept i="0">&lt;/e0&gt;</ept> represent floating-point values of unspecified precision.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>浮動小数点リテラル<ept i="0">&lt;/e0&gt;</ept>は、不特定精度の浮動小数点値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Floating-point numbers<ept i="0">&lt;/e0&gt;</ept> are numbers with a fractional component, such as <bpt i="1" x="1">&lt;c1&gt;</bpt>3.14159<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>0.1<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>-273.15<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>浮動小数点数<ept i="0">&lt;/e0&gt;</ept>は小数部を持つ数です、例えば<bpt i="1" x="1">&lt;c1&gt;</bpt>3.14159<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>0.1<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>-273.15<ept i="3">&lt;/c3&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Functions<ept i="0">&lt;/e0&gt;</ept> are self-contained chunks of code that perform a specific task.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>関数<ept i="0">&lt;/e0&gt;</ept>は、特定の作業を実行する完全独立の大きな塊のコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Generic code<ept i="0">&lt;/e0&gt;</ept> enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>総称体コード<ept i="0">&lt;/e0&gt;</ept>は、あなたに柔軟な、再使用できる関数と型を書くことを可能にします、それは、あなたが定義する要件を満たした場合に限り、あらゆる型を扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Generic functions<ept i="0">&lt;/e0&gt;</ept> can work with any type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>総称体関数<ept i="0">&lt;/e0&gt;</ept>は、どんな型でも扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Identifiers<ept i="0">&lt;/e0&gt;</ept> begin with an uppercase or lowercase letter A through Z, an underscore (<bpt i="1" x="1">&lt;c1&gt;</bpt>_<ept i="1">&lt;/c1&gt;</ept>), a noncombining alphanumeric Unicode character in the Basic Multilingual Plane, or a character outside the Basic Multilingual Plane that isn’t in a Private Use Area.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>識別子<ept i="0">&lt;/e0&gt;</ept>は、大文字または小文字のAからZ、アンダースコア（<bpt i="1" x="1">&lt;c1&gt;</bpt>_<ept i="1">&lt;/c1&gt;</ept>）、基本多言語面の非合成英数字のUnicode文字、または基本他言語面の外側ての使用領域の中でない文字で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Initialization<ept i="0">&lt;/e0&gt;</ept> is the process of preparing an instance of a class, structure, or enumeration for use.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>初期化<ept i="0">&lt;/e0&gt;</ept>は、クラス、構造体、または列挙のインスタンスを使用するために前準備する処理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Initializers<ept i="0">&lt;/e0&gt;</ept> are called to create a new instance of a particular type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>イニシャライザ<ept i="0">&lt;/e0&gt;</ept>は、特定の型の新しいインスタンスをつくるために呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Instance methods<ept i="0">&lt;/e0&gt;</ept> are functions that belong to instances of a particular class, structure, or enumeration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>インスタンスメソッド<ept i="0">&lt;/e0&gt;</ept>は、特定のクラス、構造体、または列挙のインスタンスに属している機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Integer literals<ept i="0">&lt;/e0&gt;</ept> represent integer values of unspecified precision.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>整数リテラル<ept i="0">&lt;/e0&gt;</ept>は、無限精度の整数値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Integers<ept i="0">&lt;/e0&gt;</ept> are whole numbers with no fractional component, such as <bpt i="1" x="1">&lt;c1&gt;</bpt>42<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>-23<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>整数<ept i="0">&lt;/e0&gt;</ept>は、小数部分のない数すべてです、例えば<bpt i="1" x="1">&lt;c1&gt;</bpt>42<ept i="1">&lt;/c1&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt>-23<ept i="2">&lt;/c2&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Internal access<ept i="0">&lt;/e0&gt;</ept> enables entities to be used within any source file from their defining module, but not in any source file outside of that module.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>内部アクセス（内部用）<ept i="0">&lt;/e0&gt;</ept>は、実在たちが、それらの定義モジュールからのあらゆるソースファイル内で使われることを可能にします、しかし、そのモジュールの外側のいかなるソースファイルの中も除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Logical operators<ept i="0">&lt;/e0&gt;</ept> modify or combine the Boolean logic values <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>論理演算子<ept i="0">&lt;/e0&gt;</ept>は、ブールの論理値<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>を修正または結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Methods<ept i="0">&lt;/e0&gt;</ept> are functions that are associated with a particular type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>メソッド<ept i="0">&lt;/e0&gt;</ept>は、特定の型と結び付けられる関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Open access<ept i="0">&lt;/e0&gt;</ept> and <bpt i="1" x="1">&lt;e1&gt;</bpt>public access<ept i="1">&lt;/e1&gt;</ept> enable entities to be used within any source file from their defining module, and also in a source file from another module that imports the defining module.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>開放アクセス<ept i="0">&lt;/e0&gt;</ept>と<bpt i="1" x="1">&lt;e1&gt;</bpt>公開アクセス（公開用）<ept i="1">&lt;/e1&gt;</ept>は、実在たちが、それらの定義モジュールからのあらゆるソースファイル内で、そのうえに、定義モジュールをインポートする別のモジュールからのソースファイルの中で、使われることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Optional chaining<ept i="0">&lt;/e0&gt;</ept> is a process for querying and calling properties, methods, and subscripts on an optional that might currently be <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>オプショナル連鎖<ept i="0">&lt;/e0&gt;</ept>は、現時点で<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>であるかもしれないオプショナル上での、プロパティ、メソッド、および添え字への問い合わせや呼び出しのための処理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Postfix expressions<ept i="0">&lt;/e0&gt;</ept> are formed by applying a postfix operator or other postfix syntax to an expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>接尾辞式<ept i="0">&lt;/e0&gt;</ept>は、接尾辞演算子または他の接尾辞構文を式に適用することによって作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Prefix expressions<ept i="0">&lt;/e0&gt;</ept> combine an optional prefix operator with an expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>接頭辞式<ept i="0">&lt;/e0&gt;</ept>では、ある任意の接頭辞演算子をひとつの式と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Primary expressions<ept i="0">&lt;/e0&gt;</ept> are the most basic kind of expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>基本式<ept i="0">&lt;/e0&gt;</ept>は、最も基本的な種類の式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Private access<ept i="0">&lt;/e0&gt;</ept> restricts the use of an entity to the enclosing declaration, and to extensions of that declaration that are in the same file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>非公開アクセス（私用）<ept i="0">&lt;/e0&gt;</ept>は、ある実在の使用をそれを囲んでいる宣言に、そしてその宣言の拡張で同じファイル中のものに制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Properties<ept i="0">&lt;/e0&gt;</ept> associate values with a particular class, structure, or enumeration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>プロパティ<ept i="0">&lt;/e0&gt;</ept>は、いくつかの値を特定のクラス、構造体、または列挙と結びつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>String interpolation<ept i="0">&lt;/e0&gt;</ept> is a way to construct a new <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> value from a mix of constants, variables, literals, and expressions by including their values inside a string literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>文字列補間<ept i="0">&lt;/e0&gt;</ept>は、定数、変数、リテラル、および式の混合から、それらの値をひとつのリテラル文字列に含めることで、新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値を造る方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Subclassing<ept i="0">&lt;/e0&gt;</ept> is the act of basing a new class on an existing class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>サブクラスをつくる<ept i="0">&lt;/e0&gt;</ept>ことは、既存のクラスをもとに新しいクラスを構築する行為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Ternary<ept i="0">&lt;/e0&gt;</ept> operators operate on three targets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>三項<ept i="0">&lt;/e0&gt;</ept>演算子は、３つの目標に作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Tuples<ept i="0">&lt;/e0&gt;</ept> group multiple values into a single compound value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>タプル<ept i="0">&lt;/e0&gt;</ept>は、複数の値を一つの複合値にまとめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Type aliases<ept i="0">&lt;/e0&gt;</ept> define an alternative name for an existing type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>型エイリアス<ept i="0">&lt;/e0&gt;</ept>は、既存の型の代替の名前を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Type casting<ept i="0">&lt;/e0&gt;</ept> is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>型キャスト<ept i="0">&lt;/e0&gt;</ept>は、あるインスタンスの型を調べるための、またはそのインスタンスを、それ自身のクラス階層中のどこか他の別のスーパークラスやサブクラスとして扱うための方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Unary<ept i="0">&lt;/e0&gt;</ept> operators operate on a single target (such as <bpt i="1" x="1">&lt;c1&gt;</bpt>-a<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>単項<ept i="0">&lt;/e0&gt;</ept>演算子は、一つだけの目標に作用します（例えば<bpt i="1" x="1">&lt;c1&gt;</bpt>-a<ept i="1">&lt;/c1&gt;</ept>など）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Unicode<ept i="0">&lt;/e0&gt;</ept> is an international standard for encoding, representing, and processing text in different writing systems.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ユニコード<ept i="0">&lt;/e0&gt;</ept>は、異なる表記体系のテキストを符号化、表現、そして処理するための国際的な基準です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Advanced Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> covers Swift’s advanced operators, and describes how to define your own custom operators and implement the standard operators for your own custom types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>先進の演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>では、スウィフトの先進の演算子を取り扱い、加えてあなた独自のあつらえの演算子を定義する方法、そしてあなた独自のあつらえの型のために標準の演算子を実装する方法を解説します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Array Type Shorthand Syntax<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> is now written as <bpt i="2" x="2">&lt;c2&gt;</bpt>[SomeType]<ept i="2">&lt;/c2&gt;</ept> rather than <bpt i="3" x="3">&lt;c3&gt;</bpt>SomeType[]<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>配列型の短縮形構文<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>は、現在は<bpt i="2" x="2">&lt;c2&gt;</bpt>[SomeType]<ept i="2">&lt;/c2&gt;</ept>のように書かれます、<bpt i="3" x="3">&lt;c3&gt;</bpt>SomeType[]<ept i="3">&lt;/c3&gt;</ept>ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Assertions and Preconditions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> can now use string interpolation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>表明と前提条件<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>は今では文字列補間を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Optionals<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> no longer implicitly evaluate to <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept> when they have a value and <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept> when they do not, to avoid confusion when working with optional <bpt i="4" x="4">&lt;c4&gt;</bpt>Bool<ept i="4">&lt;/c4&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オプショナル<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>はもはや暗黙的に、それが値を持つとき<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>に、そしてそれがそうしないとき<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>に評価されません、それによってオプショナル<bpt i="4" x="4">&lt;c4&gt;</bpt>Bool<ept i="4">&lt;/c4&gt;</ept>を扱うときの混乱を防ぐためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt>// Boolean literal<ept i="1">&lt;/s1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt>（ブールのリテラル）<ept i="1">&lt;/s1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt>// Floating-point literal<ept i="1">&lt;/s1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt>（リテラル浮動小数点）<ept i="1">&lt;/s1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt>// Integer literal<ept i="1">&lt;/s1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt>（リテラル整数）<ept i="1">&lt;/s1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt>// String literal<ept i="1">&lt;/s1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt>（リテラル文字列）<ept i="1">&lt;/s1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt>// Valid, uses default value<ept i="1">&lt;/s1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt>（有効、省略時の値を使う）<ept i="1">&lt;/s1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// COMBINING ACUTE ACCENT, U+0301<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（アキュート・アクセント、U+0301を追加する）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// Error<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（エラー）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// Invalid, alwaysThrows() isn't a throwing parameter<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（無効、alwaysThrows()はスローパラメータではありません）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// Invalid, missing argument label<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（無効、引数ラベルが欠けている）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// Invalid, the case has an empty body<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（無効、このケース節は空の本文を持ちます）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// No actual side effects.<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（実際の副作用なし）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// equals "hello, world"<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（「こんにちは、世界よ」に等しい）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// equals -1<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（-１に等しい）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// equals 1<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（１に等しい）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// equals 2<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（２に等しい<ept i="2">&lt;/s2&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// equals 3<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（３に等しい）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// equals 4.0<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（4.0に等しい）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// equals 6<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（６に等しい）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// false because 2 is not less than or equal to 1<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（２が１以下でないので偽）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// implicitly file-private class member<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（暗黙的にファイル外非公開のクラス・メンバー）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// implicitly internal class<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（暗黙的に内部のクラス）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// implicitly internal<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（暗黙的に内部です）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// implicitly private class member<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（暗黙のうちに非公開のクラス・メンバー）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// true because 1 is equal to 1<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（１が1と同等なので真）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// true because 1 is greater than or equal to 1<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（１が１以上なので真）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// true because 1 is less than 2<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（１が２より小さいので真）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// true because 2 is greater than 1<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（２が１より大きいので真）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>// true because 2 is not equal to 1<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>（２が１と同等でないので真）<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>A decimal integer greater than zero<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>０より大きい10進法整数<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>Any Unicode scalar value except <bpt i="3" x="3">&lt;c3&gt;</bpt>"­<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>\­<ept i="4">&lt;/c4&gt;</ept>, U+000A, or U+000D<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>何らかのユニコードスカラー値、しかし<bpt i="3" x="3">&lt;c3&gt;</bpt>"<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>\<ept i="4">&lt;/c4&gt;</ept>、U+000A、またはU+000Dを除く<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>Any Unicode scalar value except <bpt i="3" x="3">&lt;c3&gt;</bpt>/*­<ept i="3">&lt;/c3&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt>*/­<ept i="4">&lt;/c4&gt;</ept><ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>任意のユニコードスカラー値、 しかし<bpt i="3" x="3">&lt;c3&gt;</bpt>/*­<ept i="3">&lt;/c3&gt;</ept> または <bpt i="4" x="4">&lt;c4&gt;</bpt>*/­<ept i="4">&lt;/c4&gt;</ept> を除く<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>Any Unicode scalar value except <bpt i="3" x="3">&lt;c3&gt;</bpt>\­<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>任意のユニコードスカラー値、しかし<bpt i="3" x="3">&lt;c3&gt;</bpt>\­<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を除く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>Any Unicode scalar value except U+000A or U+000D<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>任意のユニコードスカラー値、 しかし U+000A または U+000D を除く<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>Any identifier, keyword, literal, or operator<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>任意の識別子、キーワード、リテラル、または演算子<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>Any punctuation except <bpt i="3" x="3">&lt;c3&gt;</bpt>(­<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>)­<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>[­<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>]­<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>{­<ept i="7">&lt;/c7&gt;</ept>, or <bpt i="8" x="8">&lt;c8&gt;</bpt>}­<ept i="8">&lt;/c8&gt;</ept><ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>任意の句読点、しかし<bpt i="3" x="3">&lt;c3&gt;</bpt>(<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>)<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>[<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>]<ept i="6">&lt;/c6&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>{<ept i="7">&lt;/c7&gt;</ept>、または<bpt i="8" x="8">&lt;c8&gt;</bpt>}<ept i="8">&lt;/c8&gt;</ept>を除く<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>Between one and eight hexadecimal digits<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>１から８桁の16進数<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>Digit 0 or 1<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>アラビア数字の0または1<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>Digit 0 through 7<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>アラビア数字の0から7<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>Digit 0 through 9, a through f, or A through F<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>アラビア数字の0から9、aからf、またはAからF<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>Digit 0 through 9<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>アラビア数字の0から9<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>U+000D followed by U+000A<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>U+000D に続けて U+000A<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>Upper- or lowercase letter A through Z<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt>大文字または小文字のAからZ<ept i="2">&lt;/s2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// 17 in binary notation<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（２進法での17）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// 17 in hexadecimal notation<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（16進法での17）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// 17 in octal notation<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（８進法での17）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// OK: names are inferred<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（OK: 名前は推論されます）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// T is inferred to be Double<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（TはDoubleであると推論されます）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// T is inferred to be Int<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（Tは、Intであると推論されます）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// The type of e is inferred to be Double.<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（eの型は、Doubleであると推測されます。<ept i="3">&lt;/s3&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// Valid, uses the value provided<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（有効、提供された値を使う）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// Warning<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（警告）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// alsoMinusSix equals -6<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（alsoMinusSixは、-6に等しい）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// empty string literal<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（空の文字列リテラル）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// explicitly file-private class member<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（明示的にファイル外非公開のクラス・メンバー）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// explicitly file-private class<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（明示的にファイル外非公開のクラス）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// explicitly private class member<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（明示的に非公開のクラス・メンバー）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// explicitly private class<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（明示的に非公開のクラス）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// explicitly public class<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（明示的に公開のクラス）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// implicitly internal class member<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（暗黙的に内部のクラス・メンバー）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// implicitly internal<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（暗黙的に内部です）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// initializer syntax<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（イニシャライザ構文）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// minusThree equals -3<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（minusThreeは、-3に等しい）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>// plusThree equals 3, or "minus minus three"<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt>（plusThreeは、3に、または「マイナス マイナス three」に等しい）<ept i="3">&lt;/s3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>//  count is labeled, greeting is not<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>（countはラベルを付けられます、greetingは違います）<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>// Ambiguous<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>（あいまい）<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>// Error: try applies only to the first function call<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>（エラー：tryは、最初の関数呼び出しだけに適用されます）<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>// explicitly public class member<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>（明示的に公開のクラス・メンバー）<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>// maxValue is equal to 255, and is of type UInt8<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>（maxValuesは255に等しく、そしてUInt8型です）<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>// minValue is equal to 0, and is of type UInt8<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>（minValuesは0に等しく、そしてUInt8型です）<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>// strong capture<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>（強いキャプチャ）<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>// true because 1 is less than 2; "zebra" and "apple" are not compared<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>// １は２より少ないので真；「zebra」と「apple」は比較されません<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>// true because 3 is equal to 3, and "apple" is less than "bird"<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>（３は３と等しく、「apple」は「bird」より少ないので真）<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>// true because 4 is equal to 4, and "dog" is equal to "dog"<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>（４は４と等しく、「dog」は「dog」と等しいので真）<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>// try applies to both function calls<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;s4&gt;</bpt>（tryは、両方の関数呼び出しに適用されます）<ept i="4">&lt;/s4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="5" x="5">&lt;s5&gt;</bpt>// Error: names don't match<ept i="5">&lt;/s5&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;s5&gt;</bpt>（エラー: 名前が一致しない）<ept i="5">&lt;/s5&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="5" x="5">&lt;s5&gt;</bpt>// Invalid, in-out arguments alias each other<ept i="5">&lt;/s5&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;s5&gt;</bpt>（無効、これらのin-out引数はお互い同士に別名をつけます）<ept i="5">&lt;/s5&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="5" x="5">&lt;s5&gt;</bpt>// No warning<ept i="5">&lt;/s5&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;s5&gt;</bpt>（警告なし）<ept i="5">&lt;/s5&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="5" x="5">&lt;s5&gt;</bpt>// OK: names match<ept i="5">&lt;/s5&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;s5&gt;</bpt>（OK: 名前が一致）<ept i="5">&lt;/s5&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="5" x="5">&lt;s5&gt;</bpt>// both x and y are labeled<ept i="5">&lt;/s5&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;s5&gt;</bpt>（xとyの両方ともラベルをつけられます）<ept i="5">&lt;/s5&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="6" x="6">&lt;s6&gt;</bpt>// Still ambiguous<ept i="6">&lt;/s6&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;s6&gt;</bpt>（依然あいまい）<ept i="6">&lt;/s6&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="6" x="6">&lt;s6&gt;</bpt>// Unambiguous<ept i="6">&lt;/s6&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;s6&gt;</bpt>（あいまいさ無し）<ept i="6">&lt;/s6&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="6" x="6">&lt;s6&gt;</bpt>// someTuple is of type (top: Int, bottom: Int)<ept i="6">&lt;/s6&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;s6&gt;</bpt>（someTupleは型 (top: Int, bottom: Int) です）<ept i="6">&lt;/s6&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="7" x="7">&lt;s7&gt;</bpt>// unowned capture<ept i="7">&lt;/s7&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;s7&gt;</bpt>（非所有者キャプチャ）<ept i="7">&lt;/s7&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="7" x="7">&lt;s7&gt;</bpt>// weak capture<ept i="7">&lt;/s7&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;s7&gt;</bpt>（弱いキャプチャ）<ept i="7">&lt;/s7&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept> statement ends program execution of a loop, an <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept> statement, or a <bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>文は、ループ、<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>文、または<bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept>文のプログラム実行を終えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>continue<ept i="0">&lt;/c0&gt;</ept> statement ends program execution of the current iteration of a loop statement but does not stop execution of the loop statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>continue<ept i="0">&lt;/c0&gt;</ept>文は、ループ文の現在の繰り返しのプログラム実行を終了しますが、ループ文の実行は止めません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept> statement defers execution until the current scope is exited.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept>文は、現在のスコープが終了されるまで実行を延期します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept> statement has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept>文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept> statement is used for executing code just before transferring program control outside of the scope that the <bpt i="1" x="1">&lt;c1&gt;</bpt>defer<ept i="1">&lt;/c1&gt;</ept> statement appears in.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept>文は、<bpt i="1" x="1">&lt;c1&gt;</bpt>defer<ept i="1">&lt;/c1&gt;</ept>文が現れるスコープの外側にプログラムの制御を移す直前でのコード実行のために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept> statement creates a new containing scope, which allows errors to be propagated to one or more <bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> clauses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>文はひとつの新しく取り囲んでいるスコープを作成します、それはエラーに１つ以上の<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>節に伝えられることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept> statement has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept> statement in Swift is similar to curly braces (<bpt i="1" x="1">&lt;c1&gt;</bpt>{}<ept i="1">&lt;/c1&gt;</ept>) in C used to delimit a code block, and does not incur a performance cost at runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>文は、Cにおいてひとつのコードのブロックの境界を定めるために使われる波括弧（<bpt i="1" x="1">&lt;c1&gt;</bpt>{}<ept i="1">&lt;/c1&gt;</ept>）に似ていて、実行時に性能上の損失を被りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>fallthrough<ept i="0">&lt;/c0&gt;</ept> statement can appear anywhere inside a <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement, not just as the last statement of a case block, but it can’t be used in the final case block.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>fallthrough<ept i="0">&lt;/c0&gt;</ept>文は、<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文のどこにでも現れることができます、あるケース節ブロックの最後の文としてだけではなく、しかしそれは最後のケース節ブロックにおいては使われることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>fallthrough<ept i="0">&lt;/c0&gt;</ept> statement consists of the <bpt i="1" x="1">&lt;c1&gt;</bpt>fallthrough<ept i="1">&lt;/c1&gt;</ept> keyword and occurs only in a case block of a <bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>fallthrough<ept i="0">&lt;/c0&gt;</ept>文は、<bpt i="1" x="1">&lt;c1&gt;</bpt>fallthrough<ept i="1">&lt;/c1&gt;</ept>キーワードから成って、<bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept>文のケース節ブロックだけに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> statement allows a block of code to be executed once for each item in a collection (or any type) that conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Sequence<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>文は、コードの１ブロックを<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Sequence<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠するあるコレクション（または何らかの型）の中のそれぞれの項目に対して一度だけ実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> statement has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept> statement has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept>文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept> statement is used to transfer program control out of a scope if one or more conditions aren’t met.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept>文は、１つ以上の条件が満たされないならば、プログラムの制御をあるスコープの外に転移させるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept> statement, like an <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept> statement, executes statements depending on the Boolean value of an expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept>文は、<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>文と同じく、ある式のブール値に基づいて他の文を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>repeat<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept> statement allows a block of code to be executed one or more times, as long as a condition remains true.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>repeat<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept>文は、ある条件が真のままである限り、ひとかたまりのコードを一回以上実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>repeat<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept> statement has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>repeat<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept>文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>repeat<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept> statement is executed as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>repeat<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept>文は、次のように実行されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>return<ept i="0">&lt;/c0&gt;</ept> statement can consist of only the <bpt i="1" x="1">&lt;c1&gt;</bpt>return<ept i="1">&lt;/c1&gt;</ept> keyword, or it can consist of the <bpt i="2" x="2">&lt;c2&gt;</bpt>return<ept i="2">&lt;/c2&gt;</ept> keyword followed by an expression, as shown below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>return<ept i="0">&lt;/c0&gt;</ept>文はキーワード<bpt i="1" x="1">&lt;c1&gt;</bpt>return<ept i="1">&lt;/c1&gt;</ept>だけから成ることができます、あるいはそれは、以下に示すように、キーワード<bpt i="2" x="2">&lt;c2&gt;</bpt>return<ept i="2">&lt;/c2&gt;</ept>とそれに続く式から成ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>return<ept i="0">&lt;/c0&gt;</ept> statement occurs in the body of a function or method definition and causes program execution to return to the calling function or method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>return<ept i="0">&lt;/c0&gt;</ept>文は、関数またはメソッド定義の本文に現れて、プログラム実行を関数またはメソッド呼んでいるところに戻るようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> case can name the value or values it matches to temporary constants or variables, for use in the body of the case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>ケース節は、それがマッチする値または複数の値に名前を付けて一時的な定数や変数に束縛することが、そのケース節の本文で使うために行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> case can optionally contain a <bpt i="1" x="1">&lt;c1&gt;</bpt>where<ept i="1">&lt;/c1&gt;</ept> clause after each pattern.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>ケース節は、各パターンの後に随意に<bpt i="1" x="1">&lt;c1&gt;</bpt>where<ept i="1">&lt;/c1&gt;</ept>節を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> case can use a <bpt i="1" x="1">&lt;c1&gt;</bpt>where<ept i="1">&lt;/c1&gt;</ept> clause to check for additional conditions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>ケース節は、<bpt i="1" x="1">&lt;c1&gt;</bpt>where<ept i="1">&lt;/c1&gt;</ept>節を、追加の条件で調べるために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> case that contains only a comment is reported as a compile-time error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つのコメントだけを含む<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>ケース節は、コンパイル時エラーとして報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement allows certain blocks of code to be executed depending on the value of a control expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文は、コードの特定のブロックをある制御式の値に従って実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement can also include a default case, introduced by the <bpt i="1" x="1">&lt;c1&gt;</bpt>default<ept i="1">&lt;/c1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文はまた、キーワード<bpt i="1" x="1">&lt;c1&gt;</bpt>default<ept i="1">&lt;/c1&gt;</ept>によって導入される、省略時のケース節を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement considers a value and compares it against several possible matching patterns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文は、ある値について考察して、それをいくつかの候補のマッチングパターンと比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept> statement causes a program to end execution of the current scope and begin error propagation to its enclosing scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept>文は、プログラムに現在のスコープの実行を終了させます、そしてそれを囲んでいるスコープにエラーの伝達を始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept> statement consists of the <bpt i="1" x="1">&lt;c1&gt;</bpt>throw<ept i="1">&lt;/c1&gt;</ept> keyword followed by an expression, as shown below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept>文は、以下のように、<bpt i="1" x="1">&lt;c1&gt;</bpt>throw<ept i="1">&lt;/c1&gt;</ept>キーワードとそれに続くひとつの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept> statement occurs in the body of a throwing function or method, or in the body of a closure expression whose type is marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>throws<ept i="1">&lt;/c1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept>文はスロー関数やメソッドの本文中に、または<bpt i="1" x="1">&lt;c1&gt;</bpt>throws<ept i="1">&lt;/c1&gt;</ept>キーワードで印される型のクロージャ式の中に現れます、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>try<ept i="0">&lt;/c0&gt;</ept> expression can’t appear on the right-hand side of a binary operator, unless the binary operator is the assignment operator or the <bpt i="1" x="1">&lt;c1&gt;</bpt>try<ept i="1">&lt;/c1&gt;</ept> expression is enclosed in parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>try<ept i="0">&lt;/c0&gt;</ept>式が二項演算子の右手側に現れることは、その二項演算子が代入演算子であるか<bpt i="1" x="1">&lt;c1&gt;</bpt>try<ept i="1">&lt;/c1&gt;</ept>式が丸括弧の中に入れられるかしない限りはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> loop is appropriate in this case, because the length of the game is not clear at the start of the <bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>ループはこの場合に適切なものです、なぜならゲームの長さは<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept>ループの開始時点ではっきりしないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> loop performs a set of statements until a condition becomes <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>ループは、ひとまとめにした文を、ある条件が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>になるまで実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> loop starts by evaluating a single condition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>ループは、一つだけ条件を評価することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> statement allows a block of code to be executed repeatedly, as long as a condition remains true.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>文は、条件が真のままである限り、コードの１ブロックを繰り返して実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> statement has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> statement is executed as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>文は、次のように実行されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept> observer is called just before the value of the variable or property is set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept>オブザーバーは、変数またはプロパティの値が設定される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="1" x="1">&lt;c1&gt;</bpt>continue<ept i="1">&lt;/c1&gt;</ept> statement can consist of only the <bpt i="2" x="2">&lt;c2&gt;</bpt>continue<ept i="2">&lt;/c2&gt;</ept> keyword, or it can consist of the <bpt i="3" x="3">&lt;c3&gt;</bpt>continue<ept i="3">&lt;/c3&gt;</ept> keyword followed by the name of a statement label, as shown below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>continue<ept i="1">&lt;/c1&gt;</ept>文は、以下に示すように、キーワード<bpt i="2" x="2">&lt;c2&gt;</bpt>continue<ept i="2">&lt;/c2&gt;</ept>だけから成ることができます、また、それはキーワード<bpt i="3" x="3">&lt;c3&gt;</bpt>continue<ept i="3">&lt;/c3&gt;</ept>とそれに続く文ラベルから成ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement provides an alternative to the <bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept> statement for responding to multiple potential states.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文は、複数の起こりうる状況に応答するために<bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept>文に代わるものを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept> statement can include only one default case, which must appear at the end of the <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept>文は１つの省略時のケース節だけを含むことができます、それは、<bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>文の終わりに現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="3" x="3">&lt;c3&gt;</bpt>break<ept i="3">&lt;/c3&gt;</ept> statement can consist of only the <bpt i="4" x="4">&lt;c4&gt;</bpt>break<ept i="4">&lt;/c4&gt;</ept> keyword, or it can consist of the <bpt i="5" x="5">&lt;c5&gt;</bpt>break<ept i="5">&lt;/c5&gt;</ept> keyword followed by the name of a statement label, as shown below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>break<ept i="3">&lt;/c3&gt;</ept>文はキーワード<bpt i="4" x="4">&lt;c4&gt;</bpt>break<ept i="4">&lt;/c4&gt;</ept>だけから成ることができます、あるいは、それは、以下に示すように、キーワード<bpt i="5" x="5">&lt;c5&gt;</bpt>break<ept i="5">&lt;/c5&gt;</ept>とそれに続く文ラベルの名前から成ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="3" x="3">&lt;c3&gt;</bpt>fallthrough<ept i="3">&lt;/c3&gt;</ept> statement causes program execution to continue from one case in a <bpt i="4" x="4">&lt;c4&gt;</bpt>switch<ept i="4">&lt;/c4&gt;</ept> statement to the next case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>fallthrough<ept i="3">&lt;/c3&gt;</ept>文によって、プログラム実行が<bpt i="4" x="4">&lt;c4&gt;</bpt>switch<ept i="4">&lt;/c4&gt;</ept>文の１つのケース節から次のケース節に続くようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="5" x="5">&lt;c5&gt;</bpt>CreditCard<ept i="5">&lt;/c5&gt;</ept> instance never outlives the <bpt i="6" x="6">&lt;c6&gt;</bpt>Customer<ept i="6">&lt;/c6&gt;</ept> that it refers to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>CreditCard<ept i="5">&lt;/c5&gt;</ept>インスタンスは、それが参照する<bpt i="6" x="6">&lt;c6&gt;</bpt>Customer<ept i="6">&lt;/c6&gt;</ept>より決して長生きしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>binary<ept i="0">&lt;/e0&gt;</ept> number, with a <bpt i="1" x="1">&lt;c1&gt;</bpt>0b<ept i="1">&lt;/c1&gt;</ept> prefix</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>２進<ept i="0">&lt;/e0&gt;</ept>数は、接頭辞<bpt i="1" x="1">&lt;c1&gt;</bpt>0b<ept i="1">&lt;/c1&gt;</ept>つきで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>class declaration<ept i="0">&lt;/e0&gt;</ept> introduces a named class type into your program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>クラス宣言<ept i="0">&lt;/e0&gt;</ept>は、名前をつけられたクラス型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>closure expression<ept i="0">&lt;/e0&gt;</ept> creates a closure, also known as a <bpt i="1" x="1">&lt;e1&gt;</bpt>lambda<ept i="1">&lt;/e1&gt;</ept> or an <bpt i="2" x="2">&lt;e2&gt;</bpt>anonymous function<ept i="2">&lt;/e2&gt;</ept> in other programming languages.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>クロージャ式<ept i="0">&lt;/e0&gt;</ept>はクロージャ、他のプログラミング言語ではまた<bpt i="1" x="1">&lt;e1&gt;</bpt>lambda<ept i="1">&lt;/e1&gt;</ept>または<bpt i="2" x="2">&lt;e2&gt;</bpt>匿名関数<ept i="2">&lt;/e2&gt;</ept>として知られるものをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>code block<ept i="0">&lt;/e0&gt;</ept> is used by a variety of declarations and control structures to group statements together.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>コード・ブロック<ept i="0">&lt;/e0&gt;</ept>は、いくつかの文をまとめるために、いろいろな宣言や制御構造で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>compound type<ept i="0">&lt;/e0&gt;</ept> is a type without a name, defined in the Swift language itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>複合の型<ept i="0">&lt;/e0&gt;</ept>は名前のない型です、そしてスウィフト言語自身によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>constant declaration<ept i="0">&lt;/e0&gt;</ept> introduces a constant named value into your program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>定数宣言<ept i="0">&lt;/e0&gt;</ept>は、名前をつけられた一定不変の値をあなたのプログラムにもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>decimal<ept i="0">&lt;/e0&gt;</ept> number, with no prefix</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>10進<ept i="0">&lt;/e0&gt;</ept>数は、接頭辞なしで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>declaration<ept i="0">&lt;/e0&gt;</ept> introduces a new name or construct into your program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>宣言<ept i="0">&lt;/e0&gt;</ept>は、新しい名前または構造物をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>deinitializer declaration<ept i="0">&lt;/e0&gt;</ept> declares a deinitializer for a class type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>デイニシャライザ宣言<ept i="0">&lt;/e0&gt;</ept>は、クラス型のためにデイニシャライザを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>deinitializer<ept i="0">&lt;/e0&gt;</ept> is called immediately before a class instance is deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>デイニシャライザ<ept i="0">&lt;/e0&gt;</ept>は、クラスインスタンスが割り当て解除される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>dictionary literal<ept i="0">&lt;/e0&gt;</ept> is an unordered collection of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>辞書リテラル<ept i="0">&lt;/e0&gt;</ept>は、「キーと値」の対の順序付けされないコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>dictionary<ept i="0">&lt;/e0&gt;</ept> stores associations between keys of the same type and values of the same type in a collection with no defined ordering.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>辞書は<ept i="0">&lt;/e0&gt;</ept>、同じ型のキーと同じ型の値との間の関連性をあるコレクションの中に順序を定義しないでしまっておきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>failable initializer<ept i="0">&lt;/e0&gt;</ept> is a type of initializer that produces an optional instance or an implicitly unwrapped optional instance of the type the initializer is declared on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>失敗できるイニシャライザ<ept i="0">&lt;/e0&gt;</ept>は、イニシャライザの一種で、そのイニシャライザが宣言されている型の、オプショナルのインスタンスまたは暗黙的にアンラップされるオプショナルのインスタンスを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>forced-try expression<ept i="0">&lt;/e0&gt;</ept> consists of the <bpt i="1" x="1">&lt;c1&gt;</bpt>try!<ept i="1">&lt;/c1&gt;</ept> operator followed by an expression that can throw an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>強制try式<ept i="0">&lt;/e0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>try!<ept i="1">&lt;/c1&gt;</ept>演算子と後につづくエラーをスローできる１つの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>forced-value expression<ept i="0">&lt;/e0&gt;</ept> unwraps an optional value that you are certain is not <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>強制された値式<ept i="0">&lt;/e0&gt;</ept>は、あなたが<bpt i="1" x="1">&lt;c1&gt;</bpt>nilで<ept i="1">&lt;/c1&gt;</ept>ないことを確信しているオプショナルの値をアンラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>function call expression<ept i="0">&lt;/e0&gt;</ept> consists of a function name followed by a comma-separated list of the function’s arguments in parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>関数呼び出し式<ept i="0">&lt;/e0&gt;</ept>は、関数名の後にその関数の引数のコンマ区切りのリストを丸括弧の中に続けることから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>function declaration<ept i="0">&lt;/e0&gt;</ept> introduces a function or method into your program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>関数宣言<ept i="0">&lt;/e0&gt;</ept>は、あなたのプログラムに関数またはメソッドをもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>generic argument clause<ept i="0">&lt;/e0&gt;</ept> specifies the type arguments of a generic type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>総称体引数節<ept i="0">&lt;/e0&gt;</ept>は、総称体型の型引数を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>generic parameter clause<ept i="0">&lt;/e0&gt;</ept> specifies the type parameters of a generic type or function, along with any associated constraints and requirements on those parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>総称体パラメータ節<ept i="0">&lt;/e0&gt;</ept>は、総称体の型や関数の型パラメータを、それらのパラメータに関するあらゆる付随する制約と要件と一緒に指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>hexadecimal<ept i="0">&lt;/e0&gt;</ept> number, with a <bpt i="1" x="1">&lt;c1&gt;</bpt>0x<ept i="1">&lt;/c1&gt;</ept> prefix</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>16進<ept i="0">&lt;/e0&gt;</ept>数は、接頭辞<bpt i="1" x="1">&lt;c1&gt;</bpt>0x<ept i="1">&lt;/c1&gt;</ept>つきで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>key-value pair<ept i="0">&lt;/e0&gt;</ept> is a combination of a key and a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>「キーと値」<ept i="0">&lt;/e0&gt;</ept>の対は、ひとつのキーとひとつの値の組合せです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>lazy stored property<ept i="0">&lt;/e0&gt;</ept> is a property whose initial value is not calculated until the first time it is used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>遅延保存プロパティ<ept i="0">&lt;/e0&gt;</ept>は、初めてそれが使われるまで、初期値が計算されないプロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>literal expression<ept i="0">&lt;/e0&gt;</ept> consists of either an ordinary literal (such as a string or a number), an array or dictionary literal, a playground literal, or one of the following special literals:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>リテラル式<ept i="0">&lt;/e0&gt;</ept>は、普通のリテラル（例えば、ある文字列または数）、配列または辞書リテラル、プレイグラウンドリテラル、または以下の特別なリテラルのうちの１つから成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>literal<ept i="0">&lt;/e0&gt;</ept> is the source code representation of a value of a type, such as a number or string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>リテラル<ept i="0">&lt;/e0&gt;</ept>は、ある型のある値をソースコードに表わしたものです、例えばある数や文字列など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>module<ept i="0">&lt;/e0&gt;</ept> is a single unit of code distribution—a framework or application that is built and shipped as a single unit and that can be imported by another module with Swift’s <bpt i="1" x="1">&lt;c1&gt;</bpt>import<ept i="1">&lt;/c1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>モジュール<ept i="0">&lt;/e0&gt;</ept>は、コード分類の１つの単位 ― フレームワークまたはアプリケーションです、それは、単一の構成単位として構築され出荷されて、スウィフトの<bpt i="1" x="1">&lt;c1&gt;</bpt>import<ept i="1">&lt;/c1&gt;</ept>キーワードを使って別のモジュールによってインポートされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>named type<ept i="0">&lt;/e0&gt;</ept> is a type that can be given a particular name when it’s defined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>名前付きの型<ept i="0">&lt;/e0&gt;</ept>は、それが定義される時に特定の名前を与えられることができる型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>parenthesized expression<ept i="0">&lt;/e0&gt;</ept> consists of an expression surrounded by parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>括弧に入れられた式<ept i="0">&lt;/e0&gt;</ept>は、丸括弧で囲まれたある式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>pattern<ept i="0">&lt;/e0&gt;</ept> represents the structure of a single value or a composite value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="0" x="0">&lt;e0&gt;</bpt>パターン<ept i="0">&lt;/e0&gt;</ept>は、ある単一の値または複合の値の構造を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>playground literal<ept i="0">&lt;/e0&gt;</ept> is used by Xcode to create an interactive representation of a color, file, or image within the program editor.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>プレイグラウンドリテラル<ept i="0">&lt;/e0&gt;</ept>は、Xcodeによって使われて、プログラムエディタ内でいろ、ファイル、または画像の双方向の表現を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>postfix operator<ept i="0">&lt;/e0&gt;</ept> is a unary operator that is written immediately after its operand, such as the postfix forced-unwrap operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>) in the expression <bpt i="2" x="2">&lt;c2&gt;</bpt>a!<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>接尾辞演算子<ept i="0">&lt;/e0&gt;</ept>は単項演算子です、それはその演算数の直後に書かれます、例えば式<bpt i="2" x="2">&lt;c2&gt;</bpt>a!<ept i="2">&lt;/c2&gt;</ept>での論理否定演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>precedence group declaration<ept i="0">&lt;/e0&gt;</ept> introduces a new grouping for infix operator precedence into your program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>優先順位グループ<ept i="0">&lt;/e0&gt;</ept>は、接中辞演算子優先順位に対する新しいグループをあなたのプログラムへ導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>prefix operator<ept i="0">&lt;/e0&gt;</ept> is a unary operator that is written immediately before its operand, such as the prefix logical NOT operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>) in the expression <bpt i="2" x="2">&lt;c2&gt;</bpt>!a<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>接頭辞演算子<ept i="0">&lt;/e0&gt;</ept>は単項演算子です、それはその演算数の直前に書かれます、例えば式<bpt i="2" x="2">&lt;c2&gt;</bpt>!a<ept i="2">&lt;/c2&gt;</ept>での論理否定演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>protocol declaration<ept i="0">&lt;/e0&gt;</ept> introduces a named protocol type into your program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>プロトコル宣言<ept i="0">&lt;/e0&gt;</ept>は、名前をつけられたプロトコル型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>protocol<ept i="0">&lt;/e0&gt;</ept> defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="0" x="0">&lt;e0&gt;</bpt>プロトコル<ept i="0">&lt;/e0&gt;</ept>（規約）は、メソッド、プロパティ、そして他の要件からなるひとつの青写真を定義します、それは、ある特定の作業またはある機能性断片にふさわしくするものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>recursive enumeration<ept i="0">&lt;/e0&gt;</ept> is an enumeration that has another instance of the enumeration as the associated value for one or more of the enumeration cases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>再帰列挙<ept i="0">&lt;/e0&gt;</ept>は、１つ以上の列挙ケース節のための関連値としてその列挙の別のインスタンスを持つ列挙です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>set<ept i="0">&lt;/e0&gt;</ept> stores distinct values of the same type in a collection with no defined ordering.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>集合<ept i="0">&lt;/e0&gt;</ept>は、同じ型の異なった値をひとつのコレクションの中に決まった順序なしで格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>source file<ept i="0">&lt;/e0&gt;</ept> is a single Swift source code file within a module (in effect, a single file within an app or framework).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ソースファイル<ept i="0">&lt;/e0&gt;</ept>は、あるモジュール内の単一のスウィフトソースコード・ファイルです（実質的には、アプリまたはフレームワーク内の単一のファイル）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>string<ept i="0">&lt;/e0&gt;</ept> is a series of characters, such as <bpt i="1" x="1">&lt;c1&gt;</bpt>"hello, world"<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>"albatross"<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつの<bpt i="0" x="0">&lt;e0&gt;</bpt>文字列<ept i="0">&lt;/e0&gt;</ept>は、一連なりの文字です、例えば<bpt i="1" x="1">&lt;c1&gt;</bpt>"hello, world"<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>"albatross"<ept i="2">&lt;/c2&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>structure declaration<ept i="0">&lt;/e0&gt;</ept> introduces a named structure type into your program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>構造体宣言<ept i="0">&lt;/e0&gt;</ept>は、名前をつけられた構造体型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>subscript expression<ept i="0">&lt;/e0&gt;</ept> provides subscript access using the getter and setter of the corresponding subscript declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>添え字式<ept i="0">&lt;/e0&gt;</ept>は、対応する添え字宣言のゲッターとセッターを使用して、添え字アクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>subscript<ept i="0">&lt;/e0&gt;</ept> declaration allows you to add subscripting support for objects of a particular type and are typically used to provide a convenient syntax for accessing the elements in a collection, list, or sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>添え字宣言<ept i="0">&lt;/e0&gt;</ept>は、特定の型のオブジェクトに対する添え字サポートを付け加えることをあなたに可能にして、コレクション、リスト、またはシーケンスの中の要素にアクセスするための便利な構文を提供するために概して使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>superclass expression<ept i="0">&lt;/e0&gt;</ept> lets a class interact with its superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>スーパークラス式<ept i="0">&lt;/e0&gt;</ept>は、あるクラスをそのスーパークラスと相互に作用させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>try expression<ept i="0">&lt;/e0&gt;</ept> consists of the <bpt i="1" x="1">&lt;c1&gt;</bpt>try<ept i="1">&lt;/c1&gt;</ept> operator followed by an expression that can throw an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>try式<ept i="0">&lt;/e0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>try<ept i="1">&lt;/c1&gt;</ept>演算子と後につづくエラーをスローできる１つの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>tuple expression<ept i="0">&lt;/e0&gt;</ept> consists of a comma-separated list of expressions surrounded by parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>タプル式<ept i="0">&lt;/e0&gt;</ept>は、丸括弧に囲まれているコンマ区切りの式のリストから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>tuple pattern<ept i="0">&lt;/e0&gt;</ept> is a comma-separated list of zero or more patterns, enclosed in parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>タプルパターン<ept i="0">&lt;/e0&gt;</ept>は、丸括弧で囲まれた、０個以上のパターンのコンマ区切りのリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>type alias declaration<ept i="0">&lt;/e0&gt;</ept> introduces a named alias of an existing type into your program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>型エイリアス宣言<ept i="0">&lt;/e0&gt;</ept>は、あなたのプログラムに既存の型の名前をつけられたエイリアスを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>type annotation<ept i="0">&lt;/e0&gt;</ept> explicitly specifies the type of a variable or expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="0" x="0">&lt;e0&gt;</bpt>型注釈<ept i="0">&lt;/e0&gt;</ept>は、明確に変数または式の型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>value type<ept i="0">&lt;/e0&gt;</ept> is a type whose value is <bpt i="1" x="1">&lt;e1&gt;</bpt>copied<ept i="1">&lt;/e1&gt;</ept> when it is assigned to a variable or constant, or when it is passed to a function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>値型<ept i="0">&lt;/e0&gt;</ept>は、それが変数または定数に代入される時に、あるいは、それが関数に渡されるときに、値が<bpt i="1" x="1">&lt;e1&gt;</bpt>コピー<ept i="1">&lt;/e1&gt;</ept>される型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>value-binding pattern<ept i="0">&lt;/e0&gt;</ept> binds matched values to variable or constant names.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>値束縛パターン<ept i="0">&lt;/e0&gt;</ept>は、マッチした値を変数または定数の名前に縛り付けてひとつに束ねます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>variable declaration<ept i="0">&lt;/e0&gt;</ept> introduces a variable named value into your program and is declared using the <bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>変数宣言<ept i="0">&lt;/e0&gt;</ept>は、名前をつけられた変えられる値をあなたのプログラムにもたらします、そしてキーワード<bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept>を使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>variadic parameter<ept i="0">&lt;/e0&gt;</ept> accepts zero or more values of a specified type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>可変長パラメータ<ept i="0">&lt;/e0&gt;</ept>は、指定された型の０個以上の値を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>weak reference<ept i="0">&lt;/e0&gt;</ept> is a reference that does not keep a strong hold on the instance it refers to, and so does not stop ARC from disposing of the referenced instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>弱い参照<ept i="0">&lt;/e0&gt;</ept>は、それが言及するインスタンスに対する強い支配力を保たない参照です、なのでARCは参照をつけられたインスタンスを処分するのを止めません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>wildcard expression<ept i="0">&lt;/e0&gt;</ept> is used to explicitly ignore a value during an assignment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ワイルドカード式<ept i="0">&lt;/e0&gt;</ept>は、代入の間に明示的に値を無視するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>wildcard pattern<ept i="0">&lt;/e0&gt;</ept> matches and ignores any value and consists of an underscore (<bpt i="1" x="1">&lt;c1&gt;</bpt>_<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ワイルドカード・パターン<ept i="0">&lt;/e0&gt;</ept>は、どんな値にでもマッチして無視します、そしてアンダースコア（<bpt i="1" x="1">&lt;c1&gt;</bpt>_<ept i="1">&lt;/c1&gt;</ept>）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="1" x="1">&lt;e1&gt;</bpt>type argument<ept i="1">&lt;/e1&gt;</ept> is the name of an actual concrete type that replaces a corresponding type parameter in the generic parameter clause of a generic type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;e1&gt;</bpt>型引数<ept i="1">&lt;/e1&gt;</ept>は実際の具体的な型の名前です、それは、ある総称体型のもつ総称体パラメータ節の中の対応する型パラメータを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="2" x="2">&lt;e2&gt;</bpt>type parameter<ept i="2">&lt;/e2&gt;</ept> is simply the name of a placeholder type (for instance, <bpt i="3" x="3">&lt;c3&gt;</bpt>T<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>U<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>V<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>Key<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>Value<ept i="7">&lt;/c7&gt;</ept>, and so on).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;e2&gt;</bpt>型パラメータ<ept i="2">&lt;/e2&gt;</ept>は、単にプレースホルダ型の名前です（たとえば<bpt i="3" x="3">&lt;c3&gt;</bpt>T<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>U<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>V<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>Key<ept i="6">&lt;/c6&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>Value<ept i="7">&lt;/c7&gt;</ept>など）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="2" x="2">&lt;e2&gt;</bpt>where clause<ept i="2">&lt;/e2&gt;</ept> is introduced by the <bpt i="3" x="3">&lt;c3&gt;</bpt>where<ept i="3">&lt;/c3&gt;</ept> keyword followed by an expression, and is used to provide an additional condition before a pattern in a case is considered matched to the <bpt i="4" x="4">&lt;e4&gt;</bpt>control expression<ept i="4">&lt;/e4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;e2&gt;</bpt>where節<ept i="2">&lt;/e2&gt;</ept>は、キーワード<bpt i="3" x="3">&lt;c3&gt;</bpt>where<ept i="3">&lt;/c3&gt;</ept>のあとにひとつの式を続けることによって導入されます、そしてケース節の中のあるパターンがその<bpt i="4" x="4">&lt;e4&gt;</bpt>制御式<ept i="4">&lt;/e4&gt;</ept>にマッチしたと考えられるより前に更なる条件を与えるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Swift Tour</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトツアー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Swift constant or variable that refers to an instance of some reference type is similar to a pointer in C, but is not a direct pointer to an address in memory, and does not require you to write an asterisk (<bpt i="1" x="1">&lt;c1&gt;</bpt>*<ept i="1">&lt;/c1&gt;</ept>) to indicate that you are creating a reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある参照型のインスタンスに言及するスウィフト定数または変数はCの中のポインターに似ています、しかしメモリ中のアドレスへの直接のポインターでなくて、あなたに参照をつくっていることを示すために星印（<bpt i="1" x="1">&lt;c1&gt;</bpt>*<ept i="1">&lt;/c1&gt;</ept>）を書くことを要求しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Swift property does not have a corresponding instance variable, and the backing store for a property is not accessed directly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのプロパティには対応するインスタンス変数がありません、そしてプロパティのための支援外部記憶は直接にアクセスされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Unicode scalar is a unique 21-bit number for a character or modifier, such as <bpt i="2" x="2">&lt;c2&gt;</bpt>U+0061<ept i="2">&lt;/c2&gt;</ept> for <bpt i="3" x="3">&lt;c3&gt;</bpt>LATIN SMALL LETTER A<ept i="3">&lt;/c3&gt;</ept> (<bpt i="4" x="4">&lt;c4&gt;</bpt>"a"<ept i="4">&lt;/c4&gt;</ept>), or <bpt i="5" x="5">&lt;c5&gt;</bpt>U+1F425<ept i="5">&lt;/c5&gt;</ept> for <bpt i="6" x="6">&lt;c6&gt;</bpt>FRONT-FACING BABY CHICK<ept i="6">&lt;/c6&gt;</ept> (<bpt i="7" x="7">&lt;c7&gt;</bpt>"🐥"<ept i="7">&lt;/c7&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるユニコード・スカラーは、ある文字または修飾子のための固有な21ビットの数字です、例えば<bpt i="3" x="3">&lt;c3&gt;</bpt>LATIN SMALL LETTER A<ept i="3">&lt;/c3&gt;</ept>（<bpt i="4" x="4">&lt;c4&gt;</bpt>"a"<ept i="4">&lt;/c4&gt;</ept>）に対する<bpt i="2" x="2">&lt;c2&gt;</bpt>U+0061<ept i="2">&lt;/c2&gt;</ept>、または<bpt i="6" x="6">&lt;c6&gt;</bpt>FRONT-FACING BABY CHICK<ept i="6">&lt;/c6&gt;</ept>（<bpt i="7" x="7">&lt;c7&gt;</bpt>"🐥"<ept i="7">&lt;/c7&gt;</ept>）に対する<bpt i="5" x="5">&lt;c5&gt;</bpt>U+1F425<ept i="5">&lt;/c5&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Unicode scalar is any Unicode <bpt i="0" x="0">&lt;e0&gt;</bpt>code point<ept i="0">&lt;/e0&gt;</ept> in the range <bpt i="1" x="1">&lt;c1&gt;</bpt>U+0000<ept i="1">&lt;/c1&gt;</ept> to <bpt i="2" x="2">&lt;c2&gt;</bpt>U+D7FF<ept i="2">&lt;/c2&gt;</ept> inclusive or <bpt i="3" x="3">&lt;c3&gt;</bpt>U+E000<ept i="3">&lt;/c3&gt;</ept> to <bpt i="4" x="4">&lt;c4&gt;</bpt>U+10FFFF<ept i="4">&lt;/c4&gt;</ept> inclusive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるユニコード・スカラーは、<bpt i="1" x="1">&lt;c1&gt;</bpt>U+0000<ept i="1">&lt;/c1&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt>U+D7FF<ept i="2">&lt;/c2&gt;</ept>を含めてまで、または<bpt i="3" x="3">&lt;c3&gt;</bpt>U+E000<ept i="3">&lt;/c3&gt;</ept>から<bpt i="4" x="4">&lt;c4&gt;</bpt>U+10FFFF<ept i="4">&lt;/c4&gt;</ept>を含めてまでの範囲のユニコード・<bpt i="0" x="0">&lt;e0&gt;</bpt>コードポイント<ept i="0">&lt;/e0&gt;</ept>のどれかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A capture list defines the rules to use when capturing one or more reference types within the closure’s body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>捕獲リストは、クロージャの本文内で一つ以上の参照型を捕獲するとき使用する規則を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A capture list is written as a comma-separated list of expressions surrounded by square brackets, before the list of parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キャプチャリストは、いくらかの式の角括弧に囲まれてた「コンマ区切り」のリストとして、パラメータのリストの前に書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A class can <bpt i="0" x="0">&lt;e0&gt;</bpt>inherit<ept i="0">&lt;/e0&gt;</ept> methods, properties, and other characteristics from another class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスは、メソッド、プロパティ、および他の特徴を別のクラスから<bpt i="0" x="0">&lt;e0&gt;</bpt>継承<ept i="0">&lt;/e0&gt;</ept>することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A class can override properties, methods, subscripts, and initializers of its superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスは、それのスーパークラスのプロパティ、メソッド、添え字、そしてイニシャライザをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A class or structure can provide as many subscript implementations as it needs, and the appropriate subscript to be used will be inferred based on the types of the value or values that are contained within the subscript brackets at the point that the subscript is used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスや構造体はそれが必要とする多くの添え字実装を提供することが可能です、そして使用されるのに適切な添え字が、添え字が使われる時点でその添え字角括弧内に含まれる値または複数の値の型に基づいて、推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A class type can inherit from only one parent class, its <bpt i="0" x="0">&lt;e0&gt;</bpt>superclass<ept i="0">&lt;/e0&gt;</ept>, but can adopt any number of protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス型は、ただ１つの親クラス、それの<bpt i="0" x="0">&lt;e0&gt;</bpt>スーパークラス<ept i="0">&lt;/e0&gt;</ept>から継承することだけが許されます、しかし随意の数のプロトコルに準拠することはできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure can <bpt i="0" x="0">&lt;e0&gt;</bpt>capture<ept i="0">&lt;/e0&gt;</ept> constants and variables from the surrounding context in which it is defined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャは、それが定義される周囲の前後関係から、定数と変数を<bpt i="0" x="0">&lt;e0&gt;</bpt>捕獲（キャプチャ）<ept i="0">&lt;/e0&gt;</ept>できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure can omit the types of its parameters, its return type, or both.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャは、そのパラメータの型、その戻り型、または両方を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure is said to <bpt i="0" x="0">&lt;e0&gt;</bpt>escape<ept i="0">&lt;/e0&gt;</ept> a function when the closure is passed as an argument to the function, but is called after the function returns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャが引数として関数に渡される、しかしその関数が戻った後に呼び出されるとき、クロージャは関数を<bpt i="0" x="0">&lt;e0&gt;</bpt>脱出する<ept i="0">&lt;/e0&gt;</ept>と言われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure may omit names for its parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャは、そのパラメータの名前を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure or nested function that captures an in-out parameter must be nonescaping.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>in-outパラメータをキャプチャするクロージャまたは入れ子にされた関数は、非脱出でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure passed as the last argument to a function can appear immediately after the parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後の引数として関数に渡されるクロージャは、丸括弧の直後に現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A closure that consists of only a single expression is understood to return the value of that expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一つの式だけから成るクロージャは、その式の値を返すと理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection of 21-bit Unicode scalar values, equivalent to the string’s UTF-32 encoding form (accessed with the string’s <bpt i="0" x="0">&lt;c0&gt;</bpt>unicodeScalars<ept i="0">&lt;/c0&gt;</ept> property)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>21ビットのUnicodeスカラー値の集まり、その文字列のUTF-32符号化方式と等しい（文字列の<bpt i="0" x="0">&lt;c0&gt;</bpt>unicodeScalars<ept i="0">&lt;/c0&gt;</ept>プロパティでアクセスされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection of UTF-16 code units (accessed with the string’s <bpt i="0" x="0">&lt;c0&gt;</bpt>utf16<ept i="0">&lt;/c0&gt;</ept> property)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-16符号単位の集まり（文字列の<bpt i="0" x="0">&lt;c0&gt;</bpt>utf16<ept i="0">&lt;/c0&gt;</ept>プロパティでアクセスされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A collection of UTF-8 code units (accessed with the string’s <bpt i="0" x="0">&lt;c0&gt;</bpt>utf8<ept i="0">&lt;/c0&gt;</ept> property)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-８符号単位の集まり（文字列の<bpt i="0" x="0">&lt;c0&gt;</bpt>utf8<ept i="0">&lt;/c0&gt;</ept>プロパティでアクセスされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A comma is allowed after the last element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつのコンマが最後の要素のあとに許容されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A compound type may contain named types and other compound types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつの複合の型は、名前付きの型や他の複合の型を含むかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A computed property with a getter but no setter is known as a <bpt i="0" x="0">&lt;e0&gt;</bpt>read-only computed property<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゲッターを持つ、しかしセッターはない計算プロパティは、<bpt i="0" x="0">&lt;e0&gt;</bpt>読み出し専用の計算プロパティ<ept i="0">&lt;/e0&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A conditional compilation block allows code to be conditionally compiled depending on the value of one or more compilation conditions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>条件コンパイルブロックは、１つ以上のコンパイル条件の値に依存してコードが条件付きでコンパイルされるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A conforming type can provide additional functionality, as long as it satisfies these three requirements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それに準拠している型は、それがこれらの３つの要件を満たす限り、追加の機能性を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A conforming type can satisfy a failable protocol initializer requirement by implementing any kind of initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある準拠している型は、失敗できるプロトコルイニシャライザ要件を満たすことが、どんな種類のイニシャライザを実装することによっても可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A conforming type can satisfy a nonfailable protocol initializer requirement by implementing a nonfailable initializer or an <bpt i="0" x="0">&lt;c0&gt;</bpt>init!<ept i="0">&lt;/c0&gt;</ept> failable initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある準拠している型は、失敗できないプロトコルイニシャライザ要件を満たすことが、失敗できないイニシャライザまたは<bpt i="0" x="0">&lt;c0&gt;</bpt>init!<ept i="0">&lt;/c0&gt;</ept>失敗できるイニシャライザを実装することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A consistent use of <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> for integer values aids code interoperability, avoids the need to convert between different number types, and matches integer type inference, as described in <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Type Safety and Type Inference<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数値のための<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>の一貫した使用は、コードの相互運用性を支援して、異なる数の型の間で変換する必要を避けて、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>「型安全と型推論」<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>で記述されるように、整数型推論に合致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A constant declaration defines an immutable binding between the <bpt i="0" x="0">&lt;e0&gt;</bpt>constant name<ept i="0">&lt;/e0&gt;</ept> and the value of the initializer <bpt i="1" x="1">&lt;e1&gt;</bpt>expression<ept i="1">&lt;/e1&gt;</ept>; after the value of a constant is set, it cannot be changed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数宣言は、<bpt i="0" x="0">&lt;e0&gt;</bpt>定数名<ept i="0">&lt;/e0&gt;</ept>とイニシャライザ<bpt i="1" x="1">&lt;e1&gt;</bpt>式<ept i="1">&lt;/e1&gt;</ept>の値の間の不変の束縛を定義します；定数の値が設定されたあと、それは変わることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A constant or variable must have the same type as the value you want to assign to it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数または変数は、あなたがそれに代入したい値と同じ型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A constant or variable of a certain class type may actually refer to an instance of a subclass behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特定のクラス型の定数または変数は、舞台裏で実際にはあるサブクラスのインスタンスを参照するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A constant, variable, or property can’t be more public than its type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数、変数、またはプロパティは、その型よりもより公開であることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A convenience initializer must call another initializer from the <bpt i="0" x="0">&lt;e0&gt;</bpt>same<ept i="0">&lt;/e0&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>便宜イニシャライザは、別のイニシャライザを<bpt i="0" x="0">&lt;e0&gt;</bpt>同じ<ept i="0">&lt;/e0&gt;</ept>クラスから呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A convenience initializer must delegate to another initializer before assigning a value to <bpt i="0" x="0">&lt;e0&gt;</bpt>any<ept i="0">&lt;/e0&gt;</ept> property (including properties defined by the same class).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>便宜イニシャライザは、値を<bpt i="0" x="0">&lt;e0&gt;</bpt>何らかの<ept i="0">&lt;/e0&gt;</ept>プロパティ（同じクラスによって定義されるプロパティを含む）に代入する前に、別のイニシャライザに委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A convenience initializer must ultimately call a designated initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>便宜イニシャライザは、最終的に指定イニシャライザを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A custom infix operator that is not explicitly placed into a precedence group is given a default precedence group with a precedence immediately higher than the precedence of the ternary conditional operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある優先順位グループの中に明示的に置かれないあつらえの接中辞演算子は、三項条件演算子の優先順位のすぐ上の優先順位を持つ省略時の優先順位グループを与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A default initializer has the same access level as the type it initializes, unless that type is defined as <bpt i="0" x="0">&lt;c0&gt;</bpt>public<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時のイニシャライザは、それが初期化する型と同じアクセス水準を持ちます、その型が<bpt i="0" x="0">&lt;c0&gt;</bpt>public<ept i="0">&lt;/c0&gt;</ept>として宣言される場合を除いて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A default parameter called <bpt i="2" x="2">&lt;c2&gt;</bpt>newValue<ept i="2">&lt;/c2&gt;</ept> is provided to your setter if you do not provide one yourself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが独自のものを提供しないならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>newValue<ept i="2">&lt;/c2&gt;</ept>と呼ばれる省略時のパラメータがあなたのセッターに提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A deinitializer can be declared only in the body of a class declaration—but not in an extension of a class—and each class can have at most one.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライザは、クラス宣言の本文においてのみ ― しかしクラスの拡張においてではなく ― 宣言されることができます、そして各クラスが多くとも１つしか持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A deinitializer is called automatically when there are no longer any references to a class object, just before the class object is deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライザは、あるクラスオブジェクトに対するいかなる参照ももはやない時、そのクラスオブジェクトが割り当て解除される直前に、自動的に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A designated initializer for that class confirms that all stored properties introduced by that class have a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのクラスのための指定イニシャライザは、そのクラスによって導入される全ての保存プロパティが値を持つことを確かめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定イニシャライザは、そのクラスによって導入される全てのプロパティを完全に初期化して、適切なスーパークラスのイニシャライザを呼んで初期化プロセスを続けていきスーパークラス連鎖を上っていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A designated initializer must call a designated initializer from its immediate superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定イニシャライザは、その直接のスーパークラスから指定イニシャライザを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定イニシャライザは、継承されたプロパティに代入する前にスーパークラスのイニシャライザへ委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A designated initializer must ensure that all of the properties introduced by its class are initialized before it delegates up to a superclass initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定イニシャライザは、それがスーパークラスのイニシャライザへと委任する前に、そのクラスによって導入されるプロパティの全てが初期化されることを確実にしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A designated initializer of a class initializes all of the class’s properties directly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラスの指定イニシャライザは、直接そのクラスのプロパティの全てを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A designated or convenience initializer is called on a class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定または便宜イニシャライザが、あるクラスで呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A dictionary <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept> type must conform to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> protocol, like a set’s value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある辞書の<bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept>型は、集合の持つ値型のように、<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A dictionary literal is a shorthand way to write one or more key-value pairs as a <bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept> collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書リテラルは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept>コレクションとして一つ以上の「キーと値」の対を書く簡便な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A different function with the same matching type can be assigned to the same variable, in the same way as for nonfunction types:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じ適合型を持つ異なる関数は、同じ変数に代入されることが可能です、それは非関数型に対するのと同じ方法で行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A failable designated initializer can be overridden in a subclass by any kind of designated initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できる指定イニシャライザは、サブクラスにおいて任意の種類の指定イニシャライザでオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A failable initializer can also delegate to a nonfailable initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できるイニシャライザは、また、失敗できないイニシャライザへと委任することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A failable initializer can delegate to any kind of initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できるイニシャライザは、あらゆる種類のイニシャライザへ委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A failable initializer can return <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> at any point in the implementation of the initializer’s body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できるイニシャライザは、そのイニシャライザの本文の中の任意の地点で<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A failable initializer creates an <bpt i="0" x="0">&lt;e0&gt;</bpt>optional<ept i="0">&lt;/e0&gt;</ept> value of the type it initializes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できるイニシャライザは、そのイニシャライザの型の<bpt i="0" x="0">&lt;e0&gt;</bpt>オプショナル<ept i="0">&lt;/e0&gt;</ept>の値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A failable initializer is used to find an appropriate enumeration case for a <bpt i="4" x="4">&lt;c4&gt;</bpt>Character<ept i="4">&lt;/c4&gt;</ept> value representing a temperature symbol:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できるイニシャライザは、ある温度記号で表されている<bpt i="4" x="4">&lt;c4&gt;</bpt>Character<ept i="4">&lt;/c4&gt;</ept>値に対して適切な列挙ケース節を見つけるために使用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A failable initializer of a class, structure, or enumeration can delegate across to another failable initializer from the same class, structure, or enumeration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス、構造体、または列挙のための失敗できるイニシャライザは、同じクラス、構造体、または列挙からの別の失敗できるイニシャライザに横つながりに委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A failable initializer requirement can be satisfied by a failable or nonfailable initializer on a conforming type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できるイニシャライザ要件は、準拠している型上の失敗できるもしくは失敗できないイニシャライザによって満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A fourth value is pushed onto the top of the stack.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第４の値がスタックのてっぺんに押し込まれ（プッシュされ）ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function call expression can include a trailing closure in the form of a closure expression immediately after the closing parenthesis.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数呼び出し式は、終わりの括弧の直後にクロージャ式の形で後付クロージャを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function can have at most one variadic parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は最大で１つの可変長パラメータしか持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function can take another function as one of its arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある関数は、その引数の１つとして別の関数をとることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function can’t have a higher access level than its parameter types and return type, because the function could be used in situations where its constituent types are unavailable to the surrounding code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は、そのパラメータ型および戻り型より高いアクセス水準を持つことができません、なぜなら、その関数は、それの組成の型が周囲のコードに利用できない状況において使われることができるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function declared in the context of class, structure, enumeration, or protocol is referred to as a <bpt i="1" x="1">&lt;e1&gt;</bpt>method<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス、構造体、列挙、またはプロトコルの文脈において宣言される関数は、<bpt i="1" x="1">&lt;e1&gt;</bpt>メソッド<ept i="1">&lt;/e1&gt;</ept>として言及されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function definition can appear inside another function declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数定義は、別の関数宣言の内部に現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function indicates that it can throw an error by including the <bpt i="0" x="0">&lt;c0&gt;</bpt>throws<ept i="0">&lt;/c0&gt;</ept> keyword in its declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある関数は、それがエラーをスローできることを<bpt i="0" x="0">&lt;c0&gt;</bpt>throws<ept i="0">&lt;/c0&gt;</ept>キーワードをそれの宣言に含めることによって示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function marked with <bpt i="1" x="1">&lt;c1&gt;</bpt>throws<ept i="1">&lt;/c1&gt;</ept> is called a <bpt i="2" x="2">&lt;e2&gt;</bpt>throwing function<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>throws<ept i="1">&lt;/c1&gt;</ept>で印された関数は、<bpt i="2" x="2">&lt;e2&gt;</bpt>スロー関数<ept i="2">&lt;/e2&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function may have at most one variadic parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は、最大で１つの可変長パラメータしか持つことが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function or method can be declared with the <bpt i="0" x="0">&lt;c0&gt;</bpt>rethrows<ept i="0">&lt;/c0&gt;</ept> keyword to indicate that it throws an error only if one of its function parameters throws an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数またはメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>rethrows<ept i="0">&lt;/c0&gt;</ept>キーワードとともに宣言されて、それの関数パラメータの１つがエラーをスローする場合にのみそれがエラーをスローすることを指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function that tries to retrieve a web page might return the <bpt i="0" x="0">&lt;c0&gt;</bpt>(Int, String)<ept i="0">&lt;/c0&gt;</ept> tuple type to describe the success or failure of the page retrieval.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ウェブ・ページを探してくるある関数は、ページ検索の成功または失敗を記述するために<bpt i="0" x="0">&lt;c0&gt;</bpt>(Int, String)<ept i="0">&lt;/c0&gt;</ept>のタプル型を返すかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function type can have a variadic parameter in its <bpt i="0" x="0">&lt;e0&gt;</bpt>parameter type<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数型は、その<bpt i="0" x="0">&lt;e0&gt;</bpt>パラメータ型<ept i="0">&lt;/e0&gt;</ept>において可変長パラメータを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function type represents the type of a function, method, or closure and consists of a parameter and return type separated by an arrow (<bpt i="0" x="0">&lt;c0&gt;</bpt>-&gt;<ept i="0">&lt;/c0&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数型は、ある関数、メソッド、またはクロージャの型を表して、矢印（<bpt i="0" x="0">&lt;c0&gt;</bpt>-&gt;<ept i="0">&lt;/c0&gt;</ept>）で区切られるパラメータと戻り型から成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function with C function calling conventions can be used as a function with Objective-C block calling conventions, and a function with Objective-C block calling conventions can be used as a function with Swift function calling conventions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C関数呼出規約を持つ関数は、Objective-Cブロック呼出規約を持つ関数として使用されることができます、そしてOblective-Cブロック呼出規約を持つ関数は、スウィフト関数呼出規約を持つ関数として使用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function with a defined return type cannot allow control to fall out of the bottom of the function without returning a value, and attempting to do so will result in a compile-time error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある定義された戻り型を持つ関数は、値を返すことなく関数の底を抜け落ちるように制御されることができません、そしてそうしようとすることはコンパイル時エラーに終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A function’s arguments must always be provided in the same order as the function’s parameter list.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数の引数は、常にその関数のパラメータ一覧と同じ順序で提供されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A generic <bpt i="1" x="1">&lt;c1&gt;</bpt>where<ept i="1">&lt;/c1&gt;</ept> clause consists of the <bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept> keyword, followed by a comma-separated list of one or more <bpt i="3" x="3">&lt;e3&gt;</bpt>requirements<ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体<bpt i="1" x="1">&lt;c1&gt;</bpt>where<ept i="1">&lt;/c1&gt;</ept>節は、<bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept>キーワード、それに続けてコンマ区切りのリストのひとつ以上の<bpt i="3" x="3">&lt;e3&gt;</bpt>要件（requirements）<ept i="3">&lt;/e3&gt;</ept>から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A generic <bpt i="1" x="1">&lt;c1&gt;</bpt>where<ept i="1">&lt;/c1&gt;</ept> clause enables you to require that an associated type must conform to a certain protocol, or that certain type parameters and associated types must be the same.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体<bpt i="1" x="1">&lt;c1&gt;</bpt>where<ept i="1">&lt;/c1&gt;</ept>節は、ある関連型が特定のプロトコルに準拠しなければならないこと、または特定の型パラメータおよび関連型が同じでなければならないことをあなたが要求できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A generic <bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept> clause starts with the <bpt i="3" x="3">&lt;c3&gt;</bpt>where<ept i="3">&lt;/c3&gt;</ept> keyword, followed by constraints for associated types or equality relationships between types and associated types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体<bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept>節は、<bpt i="3" x="3">&lt;c3&gt;</bpt>where<ept i="3">&lt;/c3&gt;</ept>キーワードで始まり、関連型に対する制約がいくつか、または型と関連型の間の同等関係性がいくつか続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A generic argument clause is enclosed in angle brackets (&lt;&gt;) and has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体引数節は、山形括弧（&lt;&gt;）に囲まれて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A generic parameter clause is enclosed in angle brackets (&lt;&gt;) and has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体パラメータ節は、山形括弧（&lt;&gt;）において囲まれて、以下の書式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A generic parameter consists of a <bpt i="0" x="0">&lt;e0&gt;</bpt>type parameter<ept i="0">&lt;/e0&gt;</ept> followed by an optional <bpt i="1" x="1">&lt;e1&gt;</bpt>constraint<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体パラメータは、<bpt i="0" x="0">&lt;e0&gt;</bpt>型パラメータ<ept i="0">&lt;/e0&gt;</ept>とそれに続く任意の<bpt i="1" x="1">&lt;e1&gt;</bpt>制約<ept i="1">&lt;/e1&gt;</ept>から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A hash value is an <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> value that is the same for all objects that compare equally, such that if <bpt i="3" x="3">&lt;c3&gt;</bpt>a == b<ept i="3">&lt;/c3&gt;</ept>, it follows that <bpt i="4" x="4">&lt;c4&gt;</bpt>a.hashValue == b.hashValue<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるハッシュ値はあるひとつの<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>値です、それは同等とみなされるすべてのオブジェクトに対して同じものです、たとえば<bpt i="3" x="3">&lt;c3&gt;</bpt>a == b<ept i="3">&lt;/c3&gt;</ept>のように、それは<bpt i="4" x="4">&lt;c4&gt;</bpt>a.hashValue == b.hashValue<ept i="4">&lt;/c4&gt;</ept>で導き出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A key-path expression lets you refer to a property for use in key-value coding and key-value observing APIs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパス式は、キー値コーディングとキー値監視APIにおいて使うためにあなたにプロパティを参照させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A key-path string expression lets you access the string used to refer to a property in Objective-C, for use in key-value coding and key-value observing APIs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパス文字列式は、あなたにObjective-Cでのプロパティを参照するために使われる文字列にアクセスさせます、キー値コーディングとキー値監視APIで使用するために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A labeled statement is indicated by placing a label on the same line as the statement’s introducer keyword, followed by a colon.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ラベルをつけられた文は、あるラベルをその文の導入子キーワードとして、コロンをその後に続けて同じ行に置くことによって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A line control statement has the following forms:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行制御文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A line control statement is used to specify a line number and filename that can be different from the line number and filename of the source code being compiled.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行制御文は、行番号とファイル名を指定するために使われます、それはコンパイルされているソースコードの行番号とファイル名とは異なっていることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A literal doesn’t have a type on its own.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リテラルはそれ独自の型を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A metatype type refers to the type of any type, including class types, structure types, enumeration types, and protocol types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるメタタイプ型は、いろいろなクラス型、構造体型、列挙型、そしていろいろなプロトコル型の内で、ある何らかの型のその型に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A method marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>nonobjc<ept i="0">&lt;/c0&gt;</ept> attribute can’t override a method marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>nonobjc<ept i="0">&lt;/c0&gt;</ept>属性で印されるメソッドは、<bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept>属性で印されるメソッドをオーバーライドできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A multiline string can be indented to match the surrounding code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行文字列は、字下げされることによって、囲んでいるコードに調和します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A multiline string literal can be indented using any combination of spaces and tabs; this indentation is not included in the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行文字列リテラルは、空白とタブの任意の組み合わせを使って字下げできます；この字下げはその文字列に含まれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A multiline string literal includes all of the lines between its opening and closing quotes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行文字列リテラルは、それの開始および終了引用符の間のすべての行を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A multiline string literal is surrounded by three double quotes and has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行の文字列リテラルは、３つの二重引用符によって囲まれて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A name before the parameter name gives the parameter an explicit argument label, which can be different from the parameter name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータ名の前の名前は、そのパラメータに明示的な引数ラベルを与えます、それはパラメーター名と異なるものにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A nested function can capture any of its outer function’s arguments and can also capture any constants and variables defined within the outer function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされた関数は、その外側の関数の持つ引数の何でも捕獲することができ、また外側の関数の範囲内で定義されるどんな定数や変数でも捕獲することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A new <bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept> instance is created, with a request for 100 coins if they are available.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept>インスタンスが、それが可能ならば100のコインを要請して作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A nonfailable designated initializer can be overridden in a subclass by a nonfailable designated initializer only.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できない指定イニシャライザは、サブクラスにおいて失敗できない指定イニシャライザでのみオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A nonfailable initializer can delegate to an <bpt i="1" x="1">&lt;c1&gt;</bpt>init?<ept i="1">&lt;/c1&gt;</ept> failable initializer by force-unwrapping the result of the superclass’s initializer—for example, by writing <bpt i="2" x="2">&lt;c2&gt;</bpt>super.init()!<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できないイニシャライザは、<bpt i="1" x="1">&lt;c1&gt;</bpt>init?<ept i="1">&lt;/c1&gt;</ept>失敗できるイニシャライザに委任することが、スーパークラスのイニシャライザの結果を強制アンラップすることによって可能です ― 例えば、<bpt i="2" x="2">&lt;c2&gt;</bpt>super.init()!<ept i="2">&lt;/c2&gt;</ept>と書くことによって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A nonfailable initializer can delegate to another nonfailable initializer or to an <bpt i="0" x="0">&lt;c0&gt;</bpt>init!<ept i="0">&lt;/c0&gt;</ept> failable initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できないイニシャライザは、別の失敗できないイニシャライザへ、または失敗できるイニシャライザ<bpt i="0" x="0">&lt;c0&gt;</bpt>init!<ept i="0">&lt;/c0&gt;</ept>へ委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A nonfailable initializer requirement can be satisfied by a nonfailable initializer or an implicitly unwrapped failable initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できないイニシャライザ要件は、失敗できないイニシャライザまたは暗黙的にアンラップされる失敗できるイニシャライザによって満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A nonreturning function or method can be called to conclude the <bpt i="0" x="0">&lt;c0&gt;</bpt>else<ept i="0">&lt;/c0&gt;</ept> clause of a guard statement, as discussed in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Guard Statement<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非復帰関数およびメソッドは、guard文の<bpt i="0" x="0">&lt;c0&gt;</bpt>else<ept i="0">&lt;/c0&gt;</ept>節で終わるために呼び出されることができます、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>guard文<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A number that won’t fit into a constant or variable of a sized integer type is reported as an error when your code is compiled:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコードがコンパイルされるとき、ある大きさを設定された整数型の定数または変数に収まらない数はエラーとして報告されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A pair of parentheses still wrap the entire argument for the method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一対の丸括弧は、依然としてこのメソッドに対する引数をすべて包みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A parameter has a name, which is used within the function body, as well as an argument label, which is used when calling the function or method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータは名前を持ちます、それは関数本文内部で使われます、それだけでなく引数ラベルも、それは関数やメソッドが呼ばれる時に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A parameter of the function type <bpt i="0" x="0">&lt;c0&gt;</bpt>() -&gt; T<ept i="0">&lt;/c0&gt;</ept> (where <bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept> is any type) can apply the <bpt i="2" x="2">&lt;c2&gt;</bpt>autoclosure<ept i="2">&lt;/c2&gt;</ept> attribute to implicitly create a closure at its call sites.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数型<bpt i="0" x="0">&lt;c0&gt;</bpt>() -&gt; T<ept i="0">&lt;/c0&gt;</ept>（ここで<bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>はどんな型でも）のあるパラメータは、<bpt i="2" x="2">&lt;c2&gt;</bpt>autoclosure<ept i="2">&lt;/c2&gt;</ept>属性を適用することによって、あるクロージャを暗黙的にそれの呼び出し領域で作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A parameter with a base type name followed immediately by three dots (<bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>) is understood as a variadic parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基本の型の名前に直ちに３つの点（<bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>）が続くパラメータは、可変長パラメータとして理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A parameter with an equals sign (<bpt i="0" x="0">&lt;c0&gt;</bpt>=<ept i="0">&lt;/c0&gt;</ept>) and an expression after its type is understood to have a default value of the given expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その型の後に等号（<bpt i="0" x="0">&lt;c0&gt;</bpt>=<ept i="0">&lt;/c0&gt;</ept>）と式をもつパラメータは、与えられた式からなる省略時の値を持つと理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A point in a 3D coordinate system, perhaps encapsulating <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>z<ept i="2">&lt;/c2&gt;</ept> properties, each of type <bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>3D座標系でのポイント、おそらくは<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>z<ept i="2">&lt;/c2&gt;</ept>プロパティ（各々<bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept>型）をカプセル化する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A postfix <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> expression consists of an expression or the name of a type, immediately followed by <bpt i="1" x="1">&lt;c1&gt;</bpt>.self<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接尾辞<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>式は、ある式または型の名前と、それに直ちに続く<bpt i="1" x="1">&lt;c1&gt;</bpt>.self<ept i="1">&lt;/c1&gt;</ept>から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A precedence group declaration has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>優先順位グループ定義は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A precedence group specifies an operator’s precedence relative to other infix operators, as well as the operator’s associativity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>優先順位グループは、他の接中辞演算子と相対的にある演算子の優先順位を、それだけでなく演算子の結合性も指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A property declaration in a class is written the same way as a constant or variable declaration, except that it is in the context of a class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスの中のプロパティ宣言は、定数または変数の宣言と同じ方法で書かれます、ただしそれはクラスの前後関係の中にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A property that normally returns an <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> will return an <bpt i="1" x="1">&lt;c1&gt;</bpt>Int?<ept i="1">&lt;/c1&gt;</ept> when accessed through optional chaining.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>通常は<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>を返すプロパティは、オプショナル連鎖を通してアクセスされるとき<bpt i="1" x="1">&lt;c1&gt;</bpt>Int?<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A protocol can <bpt i="0" x="0">&lt;e0&gt;</bpt>inherit<ept i="0">&lt;/e0&gt;</ept> one or more other protocols and can add further requirements on top of the requirements it inherits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは、一つ以上の他のプロトコルを<bpt i="0" x="0">&lt;e0&gt;</bpt>継承する<ept i="0">&lt;/e0&gt;</ept>ことができて、それが継承する要件の上に、更なる要件を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A protocol can be used as the type to be stored in a collection such as an array or a dictionary, as mentioned in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocols as Types<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>型としてのプロトコル<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で言及されるように、プロトコルは型として使われることで、コレクション、例えば配列や辞書などに保管されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A protocol can require any conforming type to provide an instance property or type property with a particular name and type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコルは、あらゆる準拠型に、特定の名前と型をもつインスタンスプロパティまたは型プロパティを提供するように要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A protocol composition type allows you to specify a value whose type conforms to the requirements of multiple protocols without explicitly defining a new, named protocol that inherits from each protocol you want the type to conform to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル合成型は、あなたにそれの型が複数のプロトコルに属する要件に準拠するある値を、あなたがその型に準拠して欲しいプロトコル各々から継承する名前をつけられたある新しいプロトコルを明示的に定義する必要なしに指定させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A protocol composition type defines a type that conforms to each protocol in a list of specified protocols, or a type that is a subclass of a given class and conforms to each protocol in a list of specified protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル合成型が定義するのは、指定されたプロトコルのリストの各プロトコルに準拠する型、または指定されたクラスのサブクラスでそして指定されたプロトコルのリストの各プロトコルに準拠する型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A public type defaults to having internal members, not public members.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>公開の型は特に何もしない状態では内部のメンバーを持ちます、公開のメンバーではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A public variable can’t be defined as having an internal, file-private, or private type, because the type might not be available everywhere that the public variable is used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>公開の変数は、内部、ファイル外非公開、または非公開の型のものを持つように定義されることができません、なぜなら、その型は公開の変数が使われるあらゆる所で利用可能ではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A read-only computed property always returns a value, and can be accessed through dot syntax, but cannot be set to a different value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>読み出し専用の計算プロパティは常にある値を返します、そしてドット構文を通してアクセスされることができますが、異なる値に設定されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A recursive function is a straightforward way to work with data that has a recursive structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>再帰関数は、率直な方法で再帰構造を持つデータを扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A reference to the returned function is stored in a constant called <bpt i="7" x="7">&lt;c7&gt;</bpt>moveNearerToZero<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返された関数への参照は、<bpt i="7" x="7">&lt;c7&gt;</bpt>moveNearerToZero<ept i="7">&lt;/c7&gt;</ept>と呼ばれる定数に保存されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A required initializer must have the same access level as the class it belongs to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>必須イニシャライザは、それが属しているクラスと同じアクセス水準を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A rethrowing function or method can contain a <bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept> statement only inside a <bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> clause.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>再度スローする関数やメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept>文を<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>節の内部にのみ含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A selector expression lets you access the selector used to refer to a method or to a property’s getter or setter in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>セレクタ式は、あなたに、Objective-Cにおけるあるメソッドをまたはあるプロパティの持つゲッターやセッターを参照するために使われるセレクタにアクセスをさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A semicolon (<bpt i="0" x="0">&lt;c0&gt;</bpt>;<ept i="0">&lt;/c0&gt;</ept>) can optionally appear after any statement and is used to separate multiple statements if they appear on the same line.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>セミコロン（<bpt i="0" x="0">&lt;c0&gt;</bpt>;<ept i="0">&lt;/c0&gt;</ept>）はあらゆる文の後に任意に現れることができて、複数の文をそれらが同じ行に現れる場合に別々に分けるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A set type cannot be inferred from an array literal alone, so the type <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept> must be explicitly declared.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合の型は配列リテラルのみでは推論されることができません、それで型<bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>が明示的に宣言されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A sign bit of <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept> means positive, and a sign bit of <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept> means negative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>の符号ビットは正を意味します、そして、<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>の符号ビットは負であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A similar principle is used to check for <bpt i="3" x="3">&lt;c3&gt;</bpt>Song<ept i="3">&lt;/c3&gt;</ept> instances, and to print an appropriate description (including <bpt i="4" x="4">&lt;c4&gt;</bpt>artist<ept i="4">&lt;/c4&gt;</ept> name) whenever a <bpt i="5" x="5">&lt;c5&gt;</bpt>Song<ept i="5">&lt;/c5&gt;</ept> is found in the library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>類似した原則が使用されて、<bpt i="3" x="3">&lt;c3&gt;</bpt>Song<ept i="3">&lt;/c3&gt;</ept>インスタンスか確認して、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>Song<ept i="5">&lt;/c5&gt;</ept>がlibraryで見つけられるときはいつでも、適切な説明（<bpt i="4" x="4">&lt;c4&gt;</bpt>artist<ept i="4">&lt;/c4&gt;</ept>名を含む）を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A simple conditional compilation block has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単純な条件コンパイルブロックは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A simple way to remember this is:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを覚えている単純な方法は、以下の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A single expression inside parentheses is a parenthesized expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>丸括弧で囲まれたただ１つだけの式は、括弧で囲まれた式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A single-line string literal is surrounded by double quotes and has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単一行の文字列リテラルは、二重引用符によって囲まれて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A speed of <bpt i="7" x="7">&lt;c7&gt;</bpt>35.0<ept i="7">&lt;/c7&gt;</ept> produces a gear of <bpt i="8" x="8">&lt;c8&gt;</bpt>4<ept i="8">&lt;/c8&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>速度<bpt i="7" x="7">&lt;c7&gt;</bpt>35.0<ept i="7">&lt;/c7&gt;</ept>はギア<bpt i="8" x="8">&lt;c8&gt;</bpt>4<ept i="8">&lt;/c8&gt;</ept>を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A stack is a useful collection model whenever you need a strict “last in, first out” approach to managing a collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スタックは、厳格に「最後に入れたものが、最初に取り出される」取り組みをコレクションを管理するために必要とするときはいつでも、役に立つコレクション・モデルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A stack is an ordered set of values, similar to an array, but with a more restricted set of operations than Swift’s <bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スタックは、順序付けられたいくつかの値の集合であり、配列に似ています、しかしスウィフトの<bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept>型より制限された操作具合を持つものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A stack, however, allows new items to be appended only to the end of the collection (known as <bpt i="2" x="2">&lt;e2&gt;</bpt>pushing<ept i="2">&lt;/e2&gt;</ept> a new value on to the stack).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スタックは、しかし、新しい項目をコレクション終わりにのみ追加されることが許されます（新しい値をスタックに<bpt i="2" x="2">&lt;e2&gt;</bpt>プッシュ<ept i="2">&lt;/e2&gt;</ept>するとして知られます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A status code of <bpt i="2" x="2">&lt;c2&gt;</bpt>404 Not Found<ept i="2">&lt;/c2&gt;</ept> is returned if you request a webpage that doesn’t exist.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>状態コード<bpt i="2" x="2">&lt;c2&gt;</bpt>404 Not Found<ept i="2">&lt;/c2&gt;</ept>は、あなたが存在しないウェブ・ページを要請するならば返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A stored variable or property declared with observers has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブザーバーとともに宣言される保存変数やプロパティは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string literal is a sequence of characters surrounded by double quotes (<bpt i="2" x="2">&lt;c2&gt;</bpt>"<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列リテラルは、二重引用符（<bpt i="2" x="2">&lt;c2&gt;</bpt>"<ept i="2">&lt;/c2&gt;</ept>）によって囲まれた一連の文字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A string literal is a sequence of characters surrounded by quotes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列リテラルは、引用符によって囲まれた一連の文字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>強い参照循環はまた、あなたがあるクロージャをクラスインスタンスのプロパティに代入して、そのクロージャの本文がそのインスタンスを捕獲するならば、起こることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A strong reference cycle is created between the two.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>強い参照循環は、２つ作られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subclass can implement a superclass designated initializer as a subclass convenience initializer as part of satisfying rule 2.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブクラスは、規則２を満たすことの一部として、スーパークラスの指定イニシャライザをサブクラスの便宜イニシャライザとして実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subclass can provide its own custom implementation of an instance method, type method, instance property, type property, or subscript that it would otherwise inherit from a superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブクラスは、それ独自のあつらえの実装のインスタンスメソッド、型メソッド、インスタンスプロパティ、型プロパティ、または添え字を提供することができます、それらはそれがそうしなければスーパークラスから継承するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subclass can’t have a higher access level than its superclass—for example, you can’t write a public subclass of an internal superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブクラスには、そのスーパークラスより高いアクセス水準があることができません ― 例えば、あなたは内部のスーパークラスに属する公開のサブクラスを書くことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subclass inherits its superclass’s deinitializer, which is implicitly called just before the subclass object is deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブクラスはそのスーパークラスのデイニシャライザを継承します、それは、サブクラスオブジェクトが割り当て解除される直前に、暗黙のうちに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A subclass’s implementation of that initializer must also be marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>required<ept i="1">&lt;/c1&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのイニシャライザのサブクラスでの実装は、また、<bpt i="1" x="1">&lt;c1&gt;</bpt>required<ept i="1">&lt;/c1&gt;</ept>宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A target written in Swift 4 can depend on a target that’s written in Swift 3, and vice versa.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 4で書かれたあるターゲットは、Swift 3で書かれたターゲットを当てにでき、そして逆も同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A throwing function propagates errors that are thrown inside of it to the scope from which it’s called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スロー関数は、それの内部でスローされるエラーを、そこからそれが呼び出されるスコープへと伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A throwing method can’t override a nonthrowing method, and a throwing method can’t satisfy a protocol requirement for a nonthrowing method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スローメソッドは、非スローメソッドをオーバーライドすることができません、そしてスローメソッドは、非スローメソッド用のプロトコル要件を満たすことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A throwing method can’t override a rethrowing method, and a throwing method can’t satisfy a protocol requirement for a rethrowing method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スローメソッドは、再スローメソッドをオーバーライドできません、そしてスローメソッドは再スローメソッド用のプロトコル要件を満たすことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A token consists of an identifier, keyword, punctuation, literal, or operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるトークンは１つの識別子、キーワード、句読点、リテラル、または演算子からなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A trailing closure is written after the function call’s parentheses, even though it is still an argument to the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後付クロージャは、関数呼び出しの丸括弧の後に書かれます、それでもそれはまだその関数に対する引数であるけれども。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A tuple expression can contain zero expressions, or it can contain two or more expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプル式はゼロ個の式を含むことができます、またはそれは２つまたはそれ以上の式を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A tuple type is a comma-separated list of types, enclosed in parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプル型は、丸括弧で囲まれた、コンマ区切りのいくらかの型のリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A tuple type’s access level is deduced automatically when the tuple type is used, and can’t be specified explicitly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるタプル型のアクセス水準は、そのタプル型が使われるときに自動的に演繹されます、したがって明示的に指定されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type alias can have an access level less than or equal to the access level of the type it aliases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型エイリアスは、それがエイリアスする型のアクセス水準と同等またはそれより下のアクセス水準を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type alias declaration can use generic parameters to give a name to an existing generic type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型エイリアス宣言は、総称体パラメータを使ってある名前を既存の総称体型に与えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type alias whose underlying type is a protocol composition type, a protocol, or a class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの基礎をなす型がプロトコル合成型、プロトコル、またはクラスである型エイリアス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type can conform to a protocol with a lower access level than the type itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型は、その型自体よりも低いアクセス水準を持つプロトコルに準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type identifier refers to either a named type or a type alias of a named or compound type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型識別子は、名前付きの型か、名前付きまたは複合の型の型エイリアスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type inheritance clause begins with a colon (<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>), followed by a list of type identifiers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型継承節はコロン（<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>）で始まり、型識別子のリストが続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type inheritance clause in an enumeration definition can be either a list of protocols, or in the case of an enumeration that assigns raw values to its cases, a single, named type that specifies the type of those raw values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙定義における型継承節は、プロトコルのリスト、または生の値をそれのケース節に割り当てる列挙のケース節においては、それらの生の値を指定する単一の名前付き型、このどちらかであることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type inheritance clause is used to specify which class a named type inherits from and which protocols a named type conforms to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型継承節は、ある名前付きの型が継承するのはどのクラスからか、およびある名前付きの型が準拠するのはどのプロトコルに対してかを指定するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type method can call another type method with the other method’s name, without needing to prefix it with the type name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型メソッドは、別の型メソッドを他のメソッドの名前を使って呼ぶことができます、その型名をそれの前に置く必要なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type must be <bpt i="0" x="0">&lt;e0&gt;</bpt>hashable<ept i="0">&lt;/e0&gt;</ept> in order to be stored in a set—that is, the type must provide a way to compute a <bpt i="1" x="1">&lt;e1&gt;</bpt>hash value<ept i="1">&lt;/e1&gt;</ept> for itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型は、集合のキー型として使われるために<bpt i="0" x="0">&lt;e0&gt;</bpt>ハッシュ化される<ept i="0">&lt;/e0&gt;</ept>必要があります ― すなわち、その型はそれ自身で<bpt i="1" x="1">&lt;e1&gt;</bpt>ハッシュ値<ept i="1">&lt;/e1&gt;</ept>を計算するためのある方法を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A type safe language encourages you to be clear about the types of values your code can work with.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型安全な言語は、あなたのコードが扱うことができる値の型について、あなたが確信を持つように促します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A value of <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept> in the array represents a black square and a value of <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept> represents a white square.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この配列の中の<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>の値は黒の正方形を表します、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>の値は白い正方形を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A variadic parameter is treated as an array that contains elements of the base type name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変長パラメータは、基本の型の名前の要素たちが入っている配列とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A way to refer to ranges within a series, perhaps encapsulating a <bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept> property and a <bpt i="1" x="1">&lt;c1&gt;</bpt>length<ept i="1">&lt;/c1&gt;</ept> property, both of type <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある連続の中に納まるいくつかの範囲を参照する一つの方法、おそらくは<bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept>プロパティと<bpt i="1" x="1">&lt;c1&gt;</bpt>length<ept i="1">&lt;/c1&gt;</ept>プロパティ（両方とも型<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>）をカプセル化する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>ARC automatically frees up the memory used by class instances when those instances are no longer needed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ARCはクラスインスタンスによって使われるメモリを、それらのインスタンスがもはや必要でないとき、自動的に自由にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>ARC does not deallocate the <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> instance until the third and final strong reference is broken, at which point it’s clear that you are no longer using the <bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept> instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ARCは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>インスタンスの割り当て解除を３番目で最後に残ったの強い参照が壊れるまで行いません、その時点では、あなたがもはや<bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept>インスタンスを使っていないことは明白です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>ARC in Action</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ARCの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>ARC will not deallocate an instance as long as at least one active reference to that instance still exists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ARCは、そのインスタンスへの少なくとも１つの活発な参照がまだ存在する限り、インスタンスの割り当て解除をしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>About Swift</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトについて</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>About the Language Reference</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>言語リファレンスについて</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Abstract concepts like <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> characterize types in terms of their conceptual characteristics, rather than their concrete type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>のような抽象的な概念たちは、それらの概念上の特徴の観点から型を特徴づけます、その具体的な型そのものではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access Control</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセス制御</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access Control Levels</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセス制御水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access Control Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセス制御構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access Levels</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access Levels for Frameworks</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>フレームワークのためのアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access Levels for Single-Target Apps</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単一ターゲットアプリのためのアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access Levels for Unit Test Targets</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニットテストターゲットのためのアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access control is discussed in detail in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Access Control<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセス制御は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>アクセス制御<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で詳細に議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access levels in Swift follow an overall guiding principle: <bpt i="0" x="0">&lt;e0&gt;</bpt>No entity can be defined in terms of another entity that has a lower (more restrictive) access level.<ept i="0">&lt;/e0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの中のアクセス水準は、以下の全体的な原理指針に従います：<bpt i="0" x="0">&lt;e0&gt;</bpt>実在は、より低い（制限のより多い）アクセス水準をもつ別の実在の観点から定義されることができない。<ept i="0">&lt;/e0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access properties of a class instance with dot (<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>) syntax, as described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Accessing Properties<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスインスタンスのプロパティにドット（<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>）構文でアクセスしてください、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>プロパティにアクセスする<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Access to that member is never inlined or devirtualized by the compiler.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのメンパーに対するアクセスは、決してコンパイラによってインラインまたはデバーチャライズされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Enumeration Cases</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙ケース節にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Properties Through Optional Chaining</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖を通してプロパティにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Subscripts Through Optional Chaining</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖を通して添え字にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Subscripts of Optional Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル型の添え字にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Superclass Methods, Properties, and Subscripts</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラスメソッド、プロパティ、そして添え字へのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing and Modifying a Dictionary</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書へのアクセスと変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing and Modifying a Set</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合へのアクセスと変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing and Modifying a String</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列へのアクセスと修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing and Modifying an Array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列へのアクセスと変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add a <bpt i="0" x="0">&lt;c0&gt;</bpt>color()<ept i="0">&lt;/c0&gt;</ept> method to <bpt i="1" x="1">&lt;c1&gt;</bpt>Suit<ept i="1">&lt;/c1&gt;</ept> that returns “black” for spades and clubs, and returns “red” for hearts and diamonds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>color()<ept i="0">&lt;/c0&gt;</ept>メソッドを<bpt i="1" x="1">&lt;c1&gt;</bpt>Suit<ept i="1">&lt;/c1&gt;</ept>に加えてください、それはスペードとクラブのために「黒」を、そしてハートとダイヤのために「赤」を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add a constant property with <bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept>, and add another method that takes an argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数プロパティを<bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept>を使って１つ加えてください、そして１つの引数をとる別のメソッドを加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add a method to <bpt i="0" x="0">&lt;c0&gt;</bpt>Card<ept i="0">&lt;/c0&gt;</ept> that creates a full deck of cards, with one card of each combination of rank and suit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Card<ept i="0">&lt;/c0&gt;</ept>にひとつのメソッドを加えてください、それはランク（順位）とスート（記号）の各組合せのカード１枚をもつ、カードの完全なデック（一組）をつくるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add a parameter to include today’s lunch special in the greeting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>今日のスペシャル・ランチをこの挨拶に含めるために、パラメータをひとつ加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add a third case to <bpt i="0" x="0">&lt;c0&gt;</bpt>ServerResponse<ept i="0">&lt;/c0&gt;</ept> and to the switch.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第３の場合を<bpt i="0" x="0">&lt;c0&gt;</bpt>ServerResponse<ept i="0">&lt;/c0&gt;</ept>に、そしてスイッチに加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add an <bpt i="2" x="2">&lt;c2&gt;</bpt>else<ept i="2">&lt;/c2&gt;</ept> clause that sets a different greeting if <bpt i="3" x="3">&lt;c3&gt;</bpt>optionalName<ept i="3">&lt;/c3&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>optionalName<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>ならば異なる挨拶を設定する<bpt i="2" x="2">&lt;c2&gt;</bpt>else<ept i="2">&lt;/c2&gt;</ept>節を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add another variable to keep track of which kind of number was the largest, as well as what that largest number was.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最も大きい数が何であったかだけでなく、どの種類の数が最も大きいものであったかについて情報を把握するために、もう一つの変数を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add code to throw an error inside the <bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept> block.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コードを加えてエラーを<bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>ブロック内部でスローしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add computed instance properties and computed type properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算インスタンスプロパティと計算型プロパティを加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a description of <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Failable Initializer Requirements<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> for protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティのための<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>失敗できるイニシャライザ要件<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の説明を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a full guide to <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Failable Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>完全なガイドを<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>失敗できるイニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a new chapter about <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Access Control<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい章を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>アクセス制御<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>について加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a new guide section about <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>String Indices<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>文字列インデックス<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>についての新しいガイド節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a new reference section about <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Failable Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, which can trigger initialization failure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいリファレンス節を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>失敗できるイニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>について加えました、それは初期化失敗を起こすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a new section about <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Accessing Subscripts of Optional Type<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> through optional chaining.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖を通して<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オプショナル型の添え字にアクセスする<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>ことについての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a new section about <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Class-Only Protocols<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>クラス専用プロトコル<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a new section about <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Dictionary Type Shorthand Syntax<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, which is written as <bpt i="2" x="2">&lt;c2&gt;</bpt>[KeyType: ValueType]<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>辞書型の略記構文<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>についての新しい節を加えました、それは<bpt i="2" x="2">&lt;c2&gt;</bpt>[KeyType: ValueType]<ept i="2">&lt;/c2&gt;</ept>のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a new section about <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Hash Values for Set Types<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Set型のためのハッシュ値<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a new section about <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Initializer Parameters Without Argument Labels<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>引数ラベルなしのイニシャライザ・パラメーター<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a new section about <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Initializer Requirements<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> in protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルに<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>イニシャライザ要件<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a new section about <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Optional Tuple Return Types<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オプショナルタプルの戻り型<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a new section about <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Required Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>必須イニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a note about the order in which <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Prefix and Postfix Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> are applied when both a prefix and a postfix operator are applied to the same operand.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>接頭辞および接尾辞演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の両方が同じ演算数に適用される時に、接頭辞および接尾辞演算子が適用される順番についての注記を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a note that the start value <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> for the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Range Operators<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> <bpt i="3" x="3">&lt;c3&gt;</bpt>a...b<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>a..&lt;b<ept i="4">&lt;/c4&gt;</ept> must not be greater than the end value <bpt i="5" x="5">&lt;c5&gt;</bpt>b<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>範囲演算子<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>a...b<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>a..&lt;b<ept i="4">&lt;/c4&gt;</ept>のための開始値<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>が終了値<bpt i="5" x="5">&lt;c5&gt;</bpt>b<ept i="5">&lt;/c5&gt;</ept>より大きくてはならないことの注意を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a note to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Access Levels<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about the scope of <bpt i="2" x="2">&lt;c2&gt;</bpt>private<ept i="2">&lt;/c2&gt;</ept> access.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>アクセス水準<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>に<bpt i="2" x="2">&lt;c2&gt;</bpt>private<ept i="2">&lt;/c2&gt;</ept>アクセスのスコープについての情報の注意書きを加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a note to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Debugging with Assertions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section about when user-defined assertions are disabled.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>表明を使ってデバッグする<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に、ユーザ定義の表明が使用不能にされた時についての注を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a note to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Handling Errors<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section about the performance of executing a <bpt i="2" x="2">&lt;c2&gt;</bpt>throw<ept i="2">&lt;/c2&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>エラーを処理する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に<bpt i="2" x="2">&lt;c2&gt;</bpt>throw<ept i="2">&lt;/c2&gt;</ept>文の実行性能について注意を追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a note to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Metatype Type<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section about constructing class instances from metatype values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メタタイプ値からクラスインスタンスを構成することについての注を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>メタタイプ型<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a note to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Property Observers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section about property observers being called when you pass a property as an in-out parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある注意を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロパティオブザーバー<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えました、あなたがあるプロパティをin-outパラメータとして渡すとき呼び出されているプロパティオブザーバーについて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a note to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Rethrowing Functions and Methods<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section that rethrowing functions can’t directly throw errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある注意を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>再スローを行う関数とメソッド<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えた、それは再スロー関数が直接にエラーをスローできないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a note to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Type Casting for Any and AnyObject<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section about using an optional value when a value of type <bpt i="2" x="2">&lt;c2&gt;</bpt>Any<ept i="2">&lt;/c2&gt;</ept> is expected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつの注を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>AnyおよびAnyObjectに対する型キャスト<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節へ型<bpt i="2" x="2">&lt;c2&gt;</bpt>Any<ept i="2">&lt;/c2&gt;</ept>の値が期待される時にオプショナル値を使うことについて加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a note to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Weak References<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section about the differences in weak references between garbage collected systems and ARC.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>弱い参照<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>にガベージコレクトシステムとARCとの間の弱い参照における違いについての情報の注意書きを加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a note to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Weak References<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section about weak references being unsuitable for caching.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キャッシュするのにふさわしくない弱い参照についての注を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>弱い参照<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a section about error handling to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>A Swift Tour<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラー処理についての節を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>スウィフトツアー<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added an example of <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Extending a Generic Type<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>総称体型を拡張する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の例を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added an example of failable numeric conversions to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Failable Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できる数値変換の例を、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>失敗できるイニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added an example of using multiple optional bindings with a <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clause to the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Optional Binding<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数のオプショナル束縛を<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節とともに使う例を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>オプショナルの束縛<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added an example that uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>??<ept i="0">&lt;/c0&gt;</ept> operator to the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>A Swift Tour<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>??<ept i="0">&lt;/c0&gt;</ept>演算子を使う例を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>スウィフトツアー<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added examples of iterating over a range to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>For-In Loops<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある範囲のすべてにわたって反復する例を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>for-inループ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about API availability checking to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Checking API Availability<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section of the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Control Flow<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter and the <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Availability Condition<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> section of the <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Statements<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>API有効性確認についての情報を章<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>制御の流れ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>API有効性の確認<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>および章<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>文<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>の節<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>有効性条件<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about access control for unit testing to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Access Levels for Unit Test Targets<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section of the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Access Control<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニットテストのためのアクセス制御についての情報を章<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>アクセス制御<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ユニットテストターゲットのためのアクセス水準<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about accessing the selector of an Objective-C property’s getter or setter to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Selector Expression<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cプロパティのゲッターやセッターのセレクタにアクセスすることについての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>セレクタ式<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about build configuration and line control statements to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Compiler Control Statements<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビルド設定および行制御文についての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>コンパイラ制御文<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about comparing tuples to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Comparison Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプルの比較についての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>比較演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about error handling to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Error Handling<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter, the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Do Statement<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> section, the <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Throw Statement<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> section, the <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Defer Statement<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept> section, and the <bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>Try Operator<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラー処理についての情報を章<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>エラー処理<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>、節<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>do文<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>、節<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>throw文<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>、節<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>defer文<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>、そして節<bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>try演算子<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about escaping line breaks in multiline string literals to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Multiline String Literals<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行リテラルにおいてラインブレークをエスケープすることについての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>複数行文字列リテラル<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about explicitly referencing an initializer to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Initializer Expression<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>明示的にあるイニシャライザを参照することについての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>イニシャライザ式<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about how to conditionally compile code depending on the version of Swift being used to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Conditional Compilation Block<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>使われているスウィフトのバージョンに基づいて条件付きでコードをコンパイルする方法についての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>条件コンパイルプロック<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about how to distinguish between methods or initializers whose names differ only by the names of their arguments to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Explicit Member Expression<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの名前がそれらの引数の名前でだけ異なるところのメソッド間またはイニシャライザ間で区別をする方法についての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>明示的メンバー式<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about how type inference works with <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Literals<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型推論が<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>リテラル<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で働く方法についての情報を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about multiline string literals to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>String Literals<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section of the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Strings and Characters<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter, and to the <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>String Literals<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> section of the <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Lexical Structure<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行文字列リテラルについての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>String Literals<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節へ<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>文字列と文字<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章、そして<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>文字列リテラル<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>の節へ<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>語彙の構造<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>の章で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about operator precedence groups to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Precedence for Custom Infix Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section of the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Advanced Operators<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter, and to the <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Precedence Group Declaration<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> section of the <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Declarations<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子優先順位グループについての情報を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>先進の演算子<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章の<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>あつらえの演算子に対する優先順位<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節に、そして<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>宣言<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>の章の<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>優先順位グループ定義<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about playground literals to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Literal Expression<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレイグラウンドリテラルについての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>リテラル式<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about preconditions and fatal errors to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Assertions and Preconditions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件と致命的なエラーについての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>表明と前提条件<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about protocol extensions to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocol Extensions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section of the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Protocols<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル拡張についての情報を章<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>プロトコル<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコル拡張<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about recursive enumerations to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Recursive Enumerations<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section of the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Enumerations<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter and the <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Enumerations with Cases of Any Type<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> section of the <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Declarations<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>再帰列挙についての情報を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>列挙<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>章の<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>再帰列挙節<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>および<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>宣言<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>章の<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>随意の型のケース節をもつ列挙<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about switch cases that have multiple patterns to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Switch<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section of the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Control Flow<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter and the <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Switch Statement<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> section of the <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Statements<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数のパターンを持つスイッチケース節についての情報を、章<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>制御の流れ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>スイッチ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>と章<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>文<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>の節<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>スイッチ文<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>に加えた</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the <bpt i="0" x="0">&lt;c0&gt;</bpt>#selector<ept i="0">&lt;/c0&gt;</ept> syntax for Objective-C selectors to the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Selector Expression<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cセレクタのための<bpt i="0" x="0">&lt;c0&gt;</bpt>#selector<ept i="0">&lt;/c0&gt;</ept>構文についての情報を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>セレクタ式<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the <bpt i="0" x="0">&lt;c0&gt;</bpt>@GKInspectable<ept i="0">&lt;/c0&gt;</ept> attribute to the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Declaration Attributes<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@GKInspectable<ept i="0">&lt;/c0&gt;</ept>属性についての情報を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>宣言属性<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the <bpt i="0" x="0">&lt;c0&gt;</bpt>@autoclosure<ept i="0">&lt;/c0&gt;</ept> attribute—including its <bpt i="1" x="1">&lt;c1&gt;</bpt>@autoclosure(escaping)<ept i="1">&lt;/c1&gt;</ept> form—to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Autoclosures<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@autoclosure<ept i="0">&lt;/c0&gt;</ept>属性についての情報を ― それの<bpt i="1" x="1">&lt;c1&gt;</bpt>@autoclosure(escaping)<ept i="1">&lt;/c1&gt;</ept>形式を含めて ― <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>自動クロージャ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the <bpt i="0" x="0">&lt;c0&gt;</bpt>availability<ept i="0">&lt;/c0&gt;</ept> attribute to the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Declaration Attributes<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>availability<ept i="0">&lt;/c0&gt;</ept>属性についての情報を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>宣言属性<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the <bpt i="0" x="0">&lt;c0&gt;</bpt>dynamic<ept i="0">&lt;/c0&gt;</ept> declaration modifier in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Declaration Modifiers<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>宣言修飾子<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>において<bpt i="0" x="0">&lt;c0&gt;</bpt>dynamic<ept i="0">&lt;/c0&gt;</ept>宣言修飾子についての情報を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the <bpt i="0" x="0">&lt;c0&gt;</bpt>open<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>fileprivate<ept i="1">&lt;/c1&gt;</ept> access-level modifiers to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Access Control<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>open<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>fileprivate<ept i="1">&lt;/c1&gt;</ept>アクセス水準修飾子についての情報を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>アクセス制御<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the <bpt i="0" x="0">&lt;c0&gt;</bpt>unowned<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>unowned(safe)<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>unowned(unsafe)<ept i="2">&lt;/c2&gt;</ept> declaration modifiers in the <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Declaration Modifiers<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>unowned<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>unowned(safe)<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>unowned(unsafe)<ept i="2">&lt;/c2&gt;</ept>宣言修飾子についての情報を<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>宣言修飾子<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the behavior of enumeration cases with <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> raw values to the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Implicitly Assigned Raw Values<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section of the <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Enumerations<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> chapter and the <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Enumerations with Cases of a Raw-Value Type<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept> section of the <bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>Declarations<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>の生の値を持つ列挙ケース節の挙動についての情報を<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>列挙<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>章の<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>暗黙的に割り当てられる生の値<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節および<bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>宣言<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>章の<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>「生の値」型のケース節を持つ列挙<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>節に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the behavior of in-out parameters to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>In-Out Parameters<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>in-outパラメータの挙動についての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>in-outパラメータ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the new <bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept> statement to the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Early Exit<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section of the <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Control Flow<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> chapter and the <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Guard Statement<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept> section of the <bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>Statements<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept>文についての情報を章<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>制御の流れ<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>の節<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>早期退出<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>および章<bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>文<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>の節<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>guard文<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the new <bpt i="0" x="0">&lt;c0&gt;</bpt>try?<ept i="0">&lt;/c0&gt;</ept> keyword to the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Converting Errors to Optional Values<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>try?<ept i="0">&lt;/c0&gt;</ept>キーワードについての情報を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>エラーをオプショナルの値に変換する<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the new Swift standard library <bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:separator:terminator)<ept i="0">&lt;/c0&gt;</ept> function to the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Printing Constants and Variables<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいスウィフト標準ライブラリ<bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:separator:terminator)<ept i="0">&lt;/c0&gt;</ept>関数についての情報を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>定数と変数を出力する<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the new optional pattern to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Optional Pattern<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section of the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Patterns<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいオプショナルパターンについての情報を章<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>パターン<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オプショナルパターン<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about throwing an error inside the catch block of a rethrowing function to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Rethrowing Functions and Methods<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>再スロー関数のcatchプロック内部でエラーをスローすることについての情報を、節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>再スローを行う関数とメソッド<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about using enumeration cases as functions to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Enumerations with Cases of Any Type<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙ケース節を関数として使うことについての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>随意の型のケース節をもつ列挙<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about using keywords as external parameter names to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Keywords and Punctuation<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーワードを外部パラメータ名として使うことについての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>キーワードと句読点<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Capture Lists<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section about how values specified in closure capture lists are captured.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのようにクロージャキャプチャリストにおいて指定された値がキャプチャされるかについて情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>キャプチャリスト<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Declaration Attributes<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section about using the <bpt i="2" x="2">&lt;c2&gt;</bpt>available<ept i="2">&lt;/c2&gt;</ept> attribute with a Swift language version.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>宣言属性<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に、スウィフト言語版での<bpt i="2" x="2">&lt;c2&gt;</bpt>available<ept i="2">&lt;/c2&gt;</ept>属性を使うことについて情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Metatype Type<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section about comparing metatype values and using them to construct instances with initializer expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>メタタイプ型<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に、メタタイプ値の比較と、それらをインスタンスを作り上げるためにイニシャライザ式とともに使う事についての情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Overriding a Failable Initializer<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section about how a nonfailable initializer can delegate up to a failable initializer by force-unwrapping the result of the superclass’s initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>失敗できるイニシャライザのオーバーライド<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に失敗できないイニシャライザが失敗できるイニシャライザにまで委任することを、スーパークラスのイニシャライザの結果を強制アンラップすることでできる方法についての情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>String Literals<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section about how concatenating string literals using the <bpt i="2" x="2">&lt;c2&gt;</bpt>+<ept i="2">&lt;/c2&gt;</ept> operator happens at compile time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>文字列リテラル<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に、どのように<bpt i="2" x="2">&lt;c2&gt;</bpt>+<ept i="2">&lt;/c2&gt;</ept>演算子を使った文字列リテラルの連結がコンパイル時に起こるかについての情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Type Alias Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section about generic type aliases and using type aliases inside of protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>型エイリアス宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節に加えた、プロトコルの内部での総称体型エイリアスと型エイリアス利用について。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added more information about curried functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>カリー化関数についての更なる情報を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added similar information about the <bpt i="3" x="3">&lt;c3&gt;</bpt>do<ept i="3">&lt;/c3&gt;</ept> statement in the <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Do Statement<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>do<ept i="3">&lt;/c3&gt;</ept>文について同様の情報を<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>do文<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>の節において追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Associated Types with a Generic Where Clause<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section, now that you can use generic <bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept> clauses to constrain associated types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>総称体where節を持つ関連型<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を加えた、今ではあなたは総称体<bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept>節を使って関連型を制約できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Escaping Closures<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about the <bpt i="2" x="2">&lt;c2&gt;</bpt>@noescape<ept i="2">&lt;/c2&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>脱出クロージャ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;c2&gt;</bpt>@noescape<ept i="2">&lt;/c2&gt;</ept>属性についての情報とともに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Extensions with a Generic Where Clause<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about extensions that include requirements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ひとつの総称体where節を持つ拡張<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を、要件を含む拡張についての情報とともに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Generic Subscripts<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section, now that subscripts can be generic.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>総称体添え字<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を追加した、今では添え字は総称体にできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adding Constraints to Protocol Extensions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル拡張に制約を加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adding Protocol Conformance with an Extension</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張を使ってプロトコル準拠を加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adding protocol conformance in this way is described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Adding Protocol Conformance with an Extension<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この方法でプロトコル準拠を加えることは<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>拡張を使ってプロトコル準拠を加える<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Addition (<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加算（<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Additionally, although operators can contain an exclamation mark (<bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>), postfix operators can’t begin with either a question mark or an exclamation mark.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それに加えて、演算子は感嘆符（<bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>）を含むことができますが、接尾辞演算子は、疑問符または感嘆符のどちらかで始まることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Additionally, when an instance is no longer needed, ARC frees up the memory used by that instance so that the memory can be used for other purposes instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その上に、インスタンスがもはや必要でないとき、ARCはそのインスタンスによって使われるメモリを開放します、それでメモリが代わりに他の目的のために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Advanced Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>先進の演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After a type alias is declared, the aliased <bpt i="0" x="0">&lt;e0&gt;</bpt>name<ept i="0">&lt;/e0&gt;</ept> can be used instead of the <bpt i="1" x="1">&lt;e1&gt;</bpt>existing type<ept i="1">&lt;/e1&gt;</ept> everywhere in your program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型エイリアスが宣言されたあと、エイリアス（別名）にされた<bpt i="0" x="0">&lt;e0&gt;</bpt>名前<ept i="0">&lt;/e0&gt;</ept>は、あなたのプログラムの至る所で<bpt i="1" x="1">&lt;e1&gt;</bpt>既存の型<ept i="1">&lt;/e1&gt;</ept>の代わりに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After applying the provided closure to each array element, the <bpt i="0" x="0">&lt;c0&gt;</bpt>map(_:)<ept i="0">&lt;/c0&gt;</ept> method returns a new array containing all of the new mapped values, in the same order as their corresponding values in the original array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>提供されたクロージャを各配列要素に適用した後に、<bpt i="0" x="0">&lt;c0&gt;</bpt>map(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドは、新しい対応付けられる値の全てを、もとの配列のそれらの対応する値と同じ順序で含んでいる新しい配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After calling <bpt i="0" x="0">&lt;c0&gt;</bpt>increment(forCount:)<ept i="0">&lt;/c0&gt;</ept>, the optional <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> that it returns is unwrapped into a constant called <bpt i="2" x="2">&lt;c2&gt;</bpt>amount<ept i="2">&lt;/c2&gt;</ept>, using optional binding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>increment(forCount:)<ept i="0">&lt;/c0&gt;</ept>呼び出しの後、それが返すオプショナルの<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>は、オプショナル束縛を使って、<bpt i="2" x="2">&lt;c2&gt;</bpt>amount<ept i="2">&lt;/c2&gt;</ept>と呼ばれる定数へとアンラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After calling <bpt i="8" x="8">&lt;c8&gt;</bpt>super.init()<ept i="8">&lt;/c8&gt;</ept>, the original value of <bpt i="9" x="9">&lt;c9&gt;</bpt>numberOfWheels<ept i="9">&lt;/c9&gt;</ept> is replaced with a new value of <bpt i="10" x="10">&lt;c10&gt;</bpt>2<ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt>super.init()<ept i="8">&lt;/c8&gt;</ept>の呼び出しの後、<bpt i="9" x="9">&lt;c9&gt;</bpt>numberOfWheels<ept i="9">&lt;/c9&gt;</ept>のもとの値は新しい値の<bpt i="10" x="10">&lt;c10&gt;</bpt>2<ept i="10">&lt;/c10&gt;</ept>で置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After capturing these values, <bpt i="5" x="5">&lt;c5&gt;</bpt>incrementer<ept i="5">&lt;/c5&gt;</ept> is returned by <bpt i="6" x="6">&lt;c6&gt;</bpt>makeIncrementer<ept i="6">&lt;/c6&gt;</ept> as a closure that increments <bpt i="7" x="7">&lt;c7&gt;</bpt>runningTotal<ept i="7">&lt;/c7&gt;</ept> by <bpt i="8" x="8">&lt;c8&gt;</bpt>amount<ept i="8">&lt;/c8&gt;</ept> each time it is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの値を捕獲した後に、<bpt i="5" x="5">&lt;c5&gt;</bpt>incrementer<ept i="5">&lt;/c5&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt>makeIncrementer<ept i="6">&lt;/c6&gt;</ept>によって、それが呼ばれるたびに<bpt i="7" x="7">&lt;c7&gt;</bpt>runningTotal<ept i="7">&lt;/c7&gt;</ept>を<bpt i="8" x="8">&lt;c8&gt;</bpt>amount<ept i="8">&lt;/c8&gt;</ept>によって増加させるクロージャとして返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After creating the dictionary, this example uses subscript assignment to add a <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> key of <bpt i="4" x="4">&lt;c4&gt;</bpt>"bird"<ept i="4">&lt;/c4&gt;</ept> and an <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept> value of <bpt i="6" x="6">&lt;c6&gt;</bpt>2<ept i="6">&lt;/c6&gt;</ept> to the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書を作成した後に、この例は、辞書に<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>キーの<bpt i="4" x="4">&lt;c4&gt;</bpt>"bird"<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>値の<bpt i="6" x="6">&lt;c6&gt;</bpt>2<ept i="6">&lt;/c6&gt;</ept>を加えるために添え字代入を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After declaring a new operator, you implement it by declaring a static method that has the same name as the operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある新しい演算子を宣言した後に、あなたはその演算子と同じ名前を持つ静的メソッドを宣言することによってそれを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After defining this extension, you can call the <bpt i="0" x="0">&lt;c0&gt;</bpt>repetitions(task:)<ept i="0">&lt;/c0&gt;</ept> method on any integer to perform a task that many number of times:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この拡張を定義した後、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>repetitions(task:)<ept i="0">&lt;/c0&gt;</ept>メソッドをあらゆる整数上で呼び出して、ある作業をそれだけ多くの回数実行できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After defining this extension, you can use any <bpt i="3" x="3">&lt;c3&gt;</bpt>Array<ept i="3">&lt;/c3&gt;</ept> as a <bpt i="4" x="4">&lt;c4&gt;</bpt>Container<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この拡張を定義した後に、あなたはどんな<bpt i="3" x="3">&lt;c3&gt;</bpt>Array<ept i="3">&lt;/c3&gt;</ept>でも<bpt i="4" x="4">&lt;c4&gt;</bpt>Container<ept i="4">&lt;/c4&gt;</ept>として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After doing so, the initializer delegates up to the <bpt i="6" x="6">&lt;c6&gt;</bpt>init(name: String)<ept i="6">&lt;/c6&gt;</ept> initializer of the <bpt i="7" x="7">&lt;c7&gt;</bpt>Food<ept i="7">&lt;/c7&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうした後に、イニシャライザは上って<bpt i="7" x="7">&lt;c7&gt;</bpt>Food<ept i="7">&lt;/c7&gt;</ept>クラスの<bpt i="6" x="6">&lt;c6&gt;</bpt>init(name: String)<ept i="6">&lt;/c6&gt;</ept>イニシャライザに委任します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After executing the code inside the switch case that matched, the program exits from the switch statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>合致したスイッチのケース節（case）の内部のコードを実行した後に、プログラムはスイッチ文から出ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After making this check, the function iterates over all of the items in <bpt i="0" x="0">&lt;c0&gt;</bpt>someContainer<ept i="0">&lt;/c0&gt;</ept> with a <bpt i="1" x="1">&lt;c1&gt;</bpt>for<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>in<ept i="2">&lt;/c2&gt;</ept> loop and the half-open range operator (<bpt i="3" x="3">&lt;c3&gt;</bpt>..&lt;<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この確認の後、関数は<bpt i="0" x="0">&lt;c0&gt;</bpt>someContainer<ept i="0">&lt;/c0&gt;</ept>の項目の全てに渡って<bpt i="1" x="1">&lt;c1&gt;</bpt>for<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>in<ept i="2">&lt;/c2&gt;</ept>ループと半開範囲演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt>..&lt;<ept i="3">&lt;/c3&gt;</ept>）を使って繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After popping a value, the stack once again holds three values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値をポップした後では、スタックは再び３つの値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After rolling the dice, the player moves forward by <bpt i="0" x="0">&lt;c0&gt;</bpt>diceRoll<ept i="0">&lt;/c0&gt;</ept> squares.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さいころを転がした後、プレーヤーは正方形を<bpt i="0" x="0">&lt;c0&gt;</bpt>diceRoll<ept i="0">&lt;/c0&gt;</ept>分だけ前進します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After the <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement completes its execution, the example uses optional binding to determine whether a value was found.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文がその実行を完了したあと、この例は値が見つけられたかどうか決定するためにオプショナル束縛を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After the <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement has finished executing, the number’s description is printed using the <bpt i="1" x="1">&lt;c1&gt;</bpt>print(_:separator:terminator:)<ept i="1">&lt;/c1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文が実行を終えたあと、その数の解説は<bpt i="1" x="1">&lt;c1&gt;</bpt>print(_:separator:terminator:)<ept i="1">&lt;/c1&gt;</ept>関数を使用して出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After the array is created, the name of the <bpt i="3" x="3">&lt;c3&gt;</bpt>ShoppingListItem<ept i="3">&lt;/c3&gt;</ept> at the start of the array is changed from <bpt i="4" x="4">&lt;c4&gt;</bpt>"[Unnamed]"<ept i="4">&lt;/c4&gt;</ept> to <bpt i="5" x="5">&lt;c5&gt;</bpt>"Orange juice"<ept i="5">&lt;/c5&gt;</ept> and it is marked as having been purchased.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列がつくられたあと、配列の始めの<bpt i="3" x="3">&lt;c3&gt;</bpt>ShoppingListItem<ept i="3">&lt;/c3&gt;</ept>の名前は、<bpt i="4" x="4">&lt;c4&gt;</bpt>"[Unnamed]"<ept i="4">&lt;/c4&gt;</ept>から<bpt i="5" x="5">&lt;c5&gt;</bpt>"Orange juice"<ept i="5">&lt;/c5&gt;</ept>へ変えられます、そしてそれは購入済みとして印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After the code checks for snakes and ladders, the dice is rolled and the player is moved forward by <bpt i="0" x="0">&lt;c0&gt;</bpt>diceRoll<ept i="0">&lt;/c0&gt;</ept> squares.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コードがヘビとはしごについて調べた後、さいころが振られてプレーヤーは<bpt i="0" x="0">&lt;c0&gt;</bpt>diceRoll<ept i="0">&lt;/c0&gt;</ept>だけの正方形を前進させられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After the code within a matched case has finished executing, the program exits from the <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>マッチされたケース節内のコードが実行を終えたあと、プログラムは<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文から出ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After the first character, combining Unicode characters are also allowed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の文字の後は、合成ユニコード文字もまた許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After the first character, digits and combining Unicode characters are also allowed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の文字の後は、桁および合成Unicode文字もまた、許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After the statement is executed, the value of <bpt i="6" x="6">&lt;c6&gt;</bpt>index<ept i="6">&lt;/c6&gt;</ept> is updated to contain the second value in the range (<bpt i="7" x="7">&lt;c7&gt;</bpt>2<ept i="7">&lt;/c7&gt;</ept>), and the <bpt i="8" x="8">&lt;c8&gt;</bpt>print(_:separator:terminator:)<ept i="8">&lt;/c8&gt;</ept> function is called again.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文が実行されたあと、<bpt i="6" x="6">&lt;c6&gt;</bpt>index<ept i="6">&lt;/c6&gt;</ept>の値は範囲の２番目の値（<bpt i="7" x="7">&lt;c7&gt;</bpt>2<ept i="7">&lt;/c7&gt;</ept>）を含むように更新されます、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>print(_:separator:terminator:)<ept i="8">&lt;/c8&gt;</ept>関数が再び呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After the temporary constants are declared, they can be used within the case’s code block.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一時的な定数が宣言された後、それらはケース節のもつコードのかたまり内で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After this happens, there are no more strong references to the <bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept> instance, and it too is deallocated:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これが起こったあと、<bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept>インスタンスへの強い参照はもうありません、そして、それも割り当て解除されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Again, the first three <bpt i="0" x="0">&lt;c0&gt;</bpt>codeUnit<ept i="0">&lt;/c0&gt;</ept> values (<bpt i="1" x="1">&lt;c1&gt;</bpt>68<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>111<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>103<ept i="3">&lt;/c3&gt;</ept>) represent the characters <bpt i="4" x="4">&lt;c4&gt;</bpt>D<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>o<ept i="5">&lt;/c5&gt;</ept>, and <bpt i="6" x="6">&lt;c6&gt;</bpt>g<ept i="6">&lt;/c6&gt;</ept>, whose UTF-16 code units have the same values as in the string’s UTF-8 representation (because these Unicode scalars represent ASCII characters).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>再び、最初の３つの<bpt i="0" x="0">&lt;c0&gt;</bpt>codeUnit<ept i="0">&lt;/c0&gt;</ept>値（<bpt i="1" x="1">&lt;c1&gt;</bpt>68<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>111<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>103<ept i="3">&lt;/c3&gt;</ept>）は文字<bpt i="4" x="4">&lt;c4&gt;</bpt>D<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>o<ept i="5">&lt;/c5&gt;</ept>、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>g<ept i="6">&lt;/c6&gt;</ept>を表します、これらのUTF-16符号単位はこの文字列のUTF-８叙述の場合と同じ値を持ちます（なぜなら、これらのユニコード・スカラーがASCII文字を表わすからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All addition and subtraction for signed integers is performed in bitwise fashion, with the sign bit included as part of the numbers being added or subtracted, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Bitwise Left and Right Shift Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号つき整数に対する全ての加算と減算は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ビット単位の左および右シフト演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、加算または減算される数の一部として含めらる符号ビットとともに、ビット単位流儀で実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All entities in your code (with a few specific exceptions, as described later in this chapter) have a default access level of internal if you don’t specify an explicit access level yourself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコードの中の全ての実在は（この章の後刻に記述されるように、２、３の特定の例外を除いて）、あなたが明示的に独自にアクセス水準を指定しないならば、省略時のアクセス水準である内部を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All game logic is moved into the protocol’s <bpt i="2" x="2">&lt;c2&gt;</bpt>play<ept i="2">&lt;/c2&gt;</ept> method, which uses the protocol’s required <bpt i="3" x="3">&lt;c3&gt;</bpt>dice<ept i="3">&lt;/c3&gt;</ept> property to provide its dice roll values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全てのゲーム論理は、プロトコルの<bpt i="2" x="2">&lt;c2&gt;</bpt>play<ept i="2">&lt;/c2&gt;</ept>メソッドに引っ越します、それは、プロトコルの要求する<bpt i="3" x="3">&lt;c3&gt;</bpt>dice<ept i="3">&lt;/c3&gt;</ept>プロパティを使ってそれのさいころ振りの値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All information about the property—including its name, type, and memory management characteristics—is defined in a single location as part of the type’s definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティに関する全ての情報は ― その名前、型、そしてメモリ管理などの特徴を含めて ― その型の定義の一部として一つの場所で定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All is not lost, however.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、道がないわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of Swift’s basic types (such as <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept>) are hashable by default, and can be used as set value types or dictionary key types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの基本の型の全て（<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept>など）は、特に何もしなくてもハッシュ化されます、そして集合の値型または辞書のキー型として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of Swift’s basic types (such as <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>Bool<ept i="5">&lt;/c5&gt;</ept>) are hashable by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの基本の型（例えば<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept>、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>Bool<ept i="5">&lt;/c5&gt;</ept>）の全ては、初期状態でハッシュ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of Swift’s standard types automatically support the <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの標準の型の全ては、自動的に<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>プロトコルをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of a class’s stored properties—including any properties the class inherits from its superclass—<bpt i="0" x="0">&lt;e0&gt;</bpt>must<ept i="0">&lt;/e0&gt;</ept> be assigned an initial value during initialization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラスの全ての保存プロパティは ― そのクラスがそれのスーパークラスから継承するあらゆるプロパティを含めて ― 初期化の間に初期値を代入される<bpt i="0" x="0">&lt;e0&gt;</bpt>必要があります<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of the functions you have encountered so far in this chapter have been examples of <bpt i="0" x="0">&lt;e0&gt;</bpt>global functions<ept i="0">&lt;/e0&gt;</ept>, which are defined at a global scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこの章においてこれまで遭遇した関数の全ては<bpt i="0" x="0">&lt;e0&gt;</bpt>グローバルな関数<ept i="0">&lt;/e0&gt;</ept>の例でした、そしてそれは、グローバルなスコープで定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of the game’s levels (apart from level one) are locked when the game is first played.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゲームが最初にプレイされるとき、ゲームのレベルの全ては鍵をかけられます（レベル１は別として）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of the other bits in <bpt i="4" x="4">&lt;c4&gt;</bpt>firstBits<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>otherBits<ept i="5">&lt;/c5&gt;</ept> match and are set to <bpt i="6" x="6">&lt;c6&gt;</bpt>0<ept i="6">&lt;/c6&gt;</ept> in the output value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>firstBits<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>otherBits<ept i="5">&lt;/c5&gt;</ept>での他の全てのビットは一致していて、出力値において<bpt i="6" x="6">&lt;c6&gt;</bpt>0<ept i="6">&lt;/c6&gt;</ept>に設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of the patterns of a compound case have to include the same set of value bindings, and each binding has to get a value of the same type from all of the patterns in the compound case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある複合ケース節のパターンのすべては、同じひとそろいの値束縛を含まなければなりません、そしてそれぞれの束縛は同じ型の値をその複合ケース節のパターンのすべてから得なければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of these floating-point literals have a decimal value of <bpt i="0" x="0">&lt;c0&gt;</bpt>12.1875<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の浮動小数点リテラルの全ては、10進の値で<bpt i="0" x="0">&lt;c0&gt;</bpt>12.1875<ept i="0">&lt;/c0&gt;</ept>を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of these integer literals have a decimal value of <bpt i="0" x="0">&lt;c0&gt;</bpt>17<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の整数リテラルの全ては、10進の値で<bpt i="0" x="0">&lt;c0&gt;</bpt>17<ept i="0">&lt;/c0&gt;</ept>を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of these overflow operators begin with an ampersand (<bpt i="1" x="1">&lt;c1&gt;</bpt>&amp;<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのオーバフロー演算子の全ては、アンパサンド（<bpt i="1" x="1">&lt;c1&gt;</bpt>&amp;<ept i="1">&lt;/c1&gt;</ept>）から始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of this information is rolled up into the function’s <bpt i="0" x="0">&lt;e0&gt;</bpt>definition<ept i="0">&lt;/e0&gt;</ept>, which is prefixed with the <bpt i="1" x="1">&lt;c1&gt;</bpt>func<ept i="1">&lt;/c1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この情報の全ては、<bpt i="1" x="1">&lt;c1&gt;</bpt>func<ept i="1">&lt;/c1&gt;</ept>キーワードを前に置かれる、関数の<bpt i="0" x="0">&lt;e0&gt;</bpt>定義<ept i="0">&lt;/e0&gt;</ept>にまとめ上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of this means that you can create the <bpt i="0" x="0">&lt;c0&gt;</bpt>Country<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>City<ept i="1">&lt;/c1&gt;</ept> instances in a single statement, without creating a strong reference cycle, and the <bpt i="2" x="2">&lt;c2&gt;</bpt>capitalCity<ept i="2">&lt;/c2&gt;</ept> property can be accessed directly, without needing to use an exclamation mark to unwrap its optional value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これの全ては、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Country<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>City<ept i="1">&lt;/c1&gt;</ept>インスタンスを１つの文において、強い参照循環をつくることなく作成できることを意味します、そして、<bpt i="2" x="2">&lt;c2&gt;</bpt>capitalCity<ept i="2">&lt;/c2&gt;</ept>プロパティはそのオプショナルの値をアンラップするために感嘆符を使う必要なしに直接にアクセスされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All options you can use with string interpolation are described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>String Interpolation<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが文字列補間で使うことができるオプション全ては、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>「文字列補間」<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All parameters must have unique names.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべてのパラメーターは、特有な名前を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All structures and enumerations are value types in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全ての構造体と列挙は、スウィフトでは値型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All structures have an automatically-generated <bpt i="0" x="0">&lt;e0&gt;</bpt>memberwise initializer<ept i="0">&lt;/e0&gt;</ept>, which you can use to initialize the member properties of new structure instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全ての構造体は自動的に生成される<bpt i="0" x="0">&lt;e0&gt;</bpt>メンバー関連イニシャライザ<ept i="0">&lt;/e0&gt;</ept>を持ちます、それはあなたが新しい構造体インスタンスのメンバープロパティを初期化するために使うことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All three of these initializers can be used to create new <bpt i="0" x="0">&lt;c0&gt;</bpt>RecipeIngredient<ept i="0">&lt;/c0&gt;</ept> instances:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのイニシャライザの３つ全てが、新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>RecipeIngredient<ept i="0">&lt;/c0&gt;</ept>インスタンスを作るために使用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All tuple types contain two or more types, except for <bpt i="0" x="0">&lt;c0&gt;</bpt>Void<ept i="0">&lt;/c0&gt;</ept> which is a type alias for the empty tuple type, <bpt i="1" x="1">&lt;c1&gt;</bpt>()<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべてのタプル型は２つまたはそれ以上の型を含みます、しかし空のタプル型、<bpt i="1" x="1">&lt;c1&gt;</bpt>()<ept i="1">&lt;/c1&gt;</ept>に対する型エイリアスである<bpt i="0" x="0">&lt;c0&gt;</bpt>Void<ept i="0">&lt;/c0&gt;</ept>を除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Also clarified the <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Assignment and Copy Behavior for Strings, Arrays, and Dictionaries<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>また<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>文字列、配列、および辞書のための代入およびコピーの挙動<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>がわかりやすくされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternative grammar productions are separated by vertical bars (|).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代替の文法導出は、垂直バー（|）で区別されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, access a <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> value in one of three other Unicode-compliant representations:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるいは代わりに、３つの他のUnicode対応の表現の１つで<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>値にアクセスしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, access the individual element values in a tuple using index numbers starting at zero:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるいは、ゼロから始まっているインデックス番号を使ってタプルの個々の要素の値にアクセスしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, all items in a set can be removed with its <bpt i="2" x="2">&lt;c2&gt;</bpt>removeAll()<ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるいはまた、集合の全ての項目は<bpt i="2" x="2">&lt;c2&gt;</bpt>removeAll()<ept i="2">&lt;/c2&gt;</ept>メソッドを使って取り除かれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, append an array of one or more compatible items with the addition assignment operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>+=<ept i="0">&lt;/c0&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるいはまた、互換性を持つ１つ以上の項目からなる配列を、追加代入演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>+=<ept i="0">&lt;/c0&gt;</ept>）を使って加えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, enumeration cases can specify associated values of <bpt i="0" x="0">&lt;e0&gt;</bpt>any<ept i="0">&lt;/e0&gt;</ept> type to be stored along with each different case value, much as unions or variants do in other languages.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、列挙ケース節は、ほとんど他の言語における共用体型やバリアント型がするように、それぞれ異なるケース節の値と一緒に格納されるために、<bpt i="0" x="0">&lt;e0&gt;</bpt>あらゆる<ept i="0">&lt;/e0&gt;</ept>型の関連値を指定することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, if the context already provides type information, such as a function argument or an already typed variable or constant, you can create an empty array with an empty array literal, which is written as <bpt i="0" x="0">&lt;c0&gt;</bpt>[]<ept i="0">&lt;/c0&gt;</ept> (an empty pair of square brackets):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、前後関係がすでに型の情報を、例えば関数の引数またはすでに型指定された変数や定数などを提供するならば、あなたは空の配列を空の配列リテラル、<bpt i="0" x="0">&lt;c0&gt;</bpt>[]<ept i="0">&lt;/c0&gt;</ept>（１対の空の角括弧）のように書かれるものでつくることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, if the context already provides type information, such as a function argument or an already typed variable or constant, you can create an empty set with an empty array literal:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるいはまた、関数の引数や既に型付けされた変数や定数のように、文脈がすでに型情報を提供するならば、あなたは空の集合を空の配列リテラルで作成することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, remove a key-value pair from a dictionary with the <bpt i="0" x="0">&lt;c0&gt;</bpt>removeValue(forKey:)<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるいは代わりに、<bpt i="0" x="0">&lt;c0&gt;</bpt>removeValue(forKey:)<ept i="0">&lt;/c0&gt;</ept>メソッドで辞書から「キーと値」の対を削除してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, specify a <bpt i="0" x="0">&lt;e0&gt;</bpt>default property value<ept i="0">&lt;/e0&gt;</ept> as part of the property’s declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりの方法として、<bpt i="0" x="0">&lt;e0&gt;</bpt>省略時のプロパティ値<ept i="0">&lt;/e0&gt;</ept>をそのプロパティの宣言の一部として指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, use the underscore character (<bpt i="1" x="1">&lt;c1&gt;</bpt>_<ept i="1">&lt;/c1&gt;</ept>), also known as the wildcard pattern, to match any possible value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるいはまた、起こりうるどんな値にもマッチするにはアンダースコア文字（<bpt i="1" x="1">&lt;c1&gt;</bpt>_<ept i="1">&lt;/c1&gt;</ept>）、またワイルドカードパターンとして知られるもの、を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, you can create a stand-alone <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> constant or variable from a single-character string literal by providing a <bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept> type annotation:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるいは、あなたは１文字だけの文字列リテラルから単独の<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>定数または変数を作成することが、<bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept>型注釈を提供することによって可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, you can define a failable initializer that creates an implicitly unwrapped optional instance of the appropriate type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>またはその代わりに、あなたは適切な型の暗黙的にアンラップされるオプショナルのインスタンスを作成する失敗できるイニシャライザを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, you can mark an extension with an explicit access-level modifier (for example, <bpt i="0" x="0">&lt;c0&gt;</bpt>private extension<ept i="0">&lt;/c0&gt;</ept>) to set a new default access level for all members defined within the extension.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、あなたは拡張に明確なアクセス水準修飾子（例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>private extension<ept i="0">&lt;/c0&gt;</ept>）で印して、新しい省略時のアクセス水準をその拡張内で定義される全てのメンバーに設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, you can override a superclass failable initializer with a subclass <bpt i="0" x="0">&lt;e0&gt;</bpt>nonfailable<ept i="0">&lt;/e0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>または代わりに、あなたはスーパークラスの失敗できるイニシャライザをサブクラスの<bpt i="0" x="0">&lt;e0&gt;</bpt>失敗できない<ept i="0">&lt;/e0&gt;</ept>イニシャライザでオーバーライドできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept> is not required in Swift, you can use a <bpt i="1" x="1">&lt;c1&gt;</bpt>break<ept i="1">&lt;/c1&gt;</ept> statement to match and ignore a particular case or to break out of a matched case before that case has completed its execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>はスウィフトでは必要とされないけれども、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>break<ept i="1">&lt;/c1&gt;</ept>文を特定のケース節を適合してから無視するために、または適合したケース節をそのケース節がそれの実行を完了してしまう前に抜け出すために使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although both functions have names that begin with <bpt i="6" x="6">&lt;c6&gt;</bpt>greet<ept i="6">&lt;/c6&gt;</ept>, the <bpt i="7" x="7">&lt;c7&gt;</bpt>greet(person:alreadyGreeted:)<ept i="7">&lt;/c7&gt;</ept> function takes two arguments but the <bpt i="8" x="8">&lt;c8&gt;</bpt>greet(person:)<ept i="8">&lt;/c8&gt;</ept> function takes only one.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方の関数が<bpt i="6" x="6">&lt;c6&gt;</bpt>greet<ept i="6">&lt;/c6&gt;</ept>で始まる名前を持つとはいえ、<bpt i="7" x="7">&lt;c7&gt;</bpt>greet(person:alreadyGreeted:)<ept i="7">&lt;/c7&gt;</ept>関数は２つの引数を取りますが<bpt i="8" x="8">&lt;c8&gt;</bpt>greet(person:)<ept i="8">&lt;/c8&gt;</ept>関数はただ１つだけ取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although conforming types don’t have to provide their own implementation of either, requirements with default implementations can be called without optional chaining.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どちらにおいても準拠する型がそれ自身の実装を提供しなくても良いけれども、省略時の実装を持つ要件はオプショナル連鎖なしに呼ばれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although it’s common to define individual types in separate source files, a single source file can contain definitions for multiple types, functions, and so on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>通常は個々の型を別々のソースファイルに定義しますが、単一のソースファイルは、複数の型、関数、その他の定義を含むことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although it’s not specified as part of the protocol, it’s assumed that this value will be a number from <bpt i="3" x="3">&lt;c3&gt;</bpt>0.0<ept i="3">&lt;/c3&gt;</ept> up to (but not including) <bpt i="4" x="4">&lt;c4&gt;</bpt>1.0<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはプロトコルの一部として指定されないけれども、この値は<bpt i="3" x="3">&lt;c3&gt;</bpt>0.0<ept i="3">&lt;/c3&gt;</ept>から<bpt i="4" x="4">&lt;c4&gt;</bpt>1.0<ept i="4">&lt;/c4&gt;</ept>まで（しかし含めてではない）のある数であるのを仮定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although it’s possible for multiple parameters to have the same argument label, unique argument labels help make your code more readable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数のパラメータが同じ引数ラベルを持つことは可能であるとは言え、特有な引数ラベルはあなたのコードをより読みやすくする助けとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although properties and methods declared in the <bpt i="0" x="0">&lt;e0&gt;</bpt>superclass<ept i="0">&lt;/e0&gt;</ept> are inherited by the current class, designated initializers declared in the <bpt i="1" x="1">&lt;e1&gt;</bpt>superclass<ept i="1">&lt;/e1&gt;</ept> are only inherited when the subclass meets the conditions described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Automatic Initializer Inheritance<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>スーパークラス<ept i="0">&lt;/e0&gt;</ept>の中で宣言されるプロパティやメソッドは現在のクラスによって継承されるけれども、<bpt i="1" x="1">&lt;e1&gt;</bpt>スーパークラス<ept i="1">&lt;/e1&gt;</ept>の中で宣言される指定イニシャライザはただサブクラスが<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>自動的なイニシャライザ継承<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述される条件と出会う場合に継承されるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although technically allowed, this wouldn’t make for a very good data source.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>技術的には可能であるけれども、これはあまり良いデータ・ソースにつながりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although the <bpt i="0" x="0">&lt;e0&gt;</bpt>method name<ept i="0">&lt;/e0&gt;</ept> and the <bpt i="1" x="1">&lt;e1&gt;</bpt>property name<ept i="1">&lt;/e1&gt;</ept> are expressions, they’re never evaluated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>method name（メソッド名）<ept i="0">&lt;/e0&gt;</ept>と<bpt i="1" x="1">&lt;e1&gt;</bpt>property name（プロパティ名）<ept i="1">&lt;/e1&gt;</ept>は式であるけれども、それらは決して評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although the <bpt i="0" x="0">&lt;e0&gt;</bpt>property name<ept i="0">&lt;/e0&gt;</ept> is an expression, it is never evaluated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>property name（プロパティ名）<ept i="0">&lt;/e0&gt;</ept>は式であるけれども、それは決して評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although the actual execution order of pattern-matching operations, and in particular the evaluation order of patterns in cases, is unspecified, pattern matching in a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement behaves as if the evaluation is performed in source order—that is, the order in which they appear in source code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>けれどもパターンマッチ操作の実際の実行順序、とりわけケース節の中のパターンの評価順序は指定されません、<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文のパターンマッチングはまるでその評価がソース順 ― すなわち、それらがソース・コードにおいて現れる順番、で実行されるかのようにふるまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although the generic <bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept> clause provides syntactic sugar for expressing simple constraints on type parameters (for instance, <bpt i="3" x="3">&lt;c3&gt;</bpt>&lt;T: Comparable&gt;<ept i="3">&lt;/c3&gt;</ept> is equivalent to <bpt i="4" x="4">&lt;c4&gt;</bpt>&lt;T&gt; where T: Comparable<ept i="4">&lt;/c4&gt;</ept> and so on), you can use it to provide more complex constraints on type parameters and their associated types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体<bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept>節は、型パラメータ上で単純な制約を表すために構文糖衣を提供しますが（例えば、<bpt i="3" x="3">&lt;c3&gt;</bpt>&lt;T: Comparable&gt;<ept i="3">&lt;/c3&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>&lt;T&gt; where T: Comparable<ept i="4">&lt;/c4&gt;</ept>に等しいなどなど）、あなたはそれを使ってより複雑な制約を型パラメータとそれの関連型に提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although the indexes used to access the elements can be of any type, each parameter must include a type annotation to specify the type of each index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素にアクセスするために使用されるインデックスは、どんな型でも可能であるけれども、各パラメータは型注釈を含んで、各インデックスの型を指定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although the rest of its functionality is not shown, the purpose of this <bpt i="3" x="3">&lt;c3&gt;</bpt>DataManager<ept i="3">&lt;/c3&gt;</ept> class is to manage and provide access to this array of <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept> data.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その機能性の残りの部分は示されないけれども、この<bpt i="3" x="3">&lt;c3&gt;</bpt>DataManager<ept i="3">&lt;/c3&gt;</ept>クラスの目的はこの<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>データの配列を管理して、アクセス提供することになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although the two forms are functionally equivalent, the shorthand form is preferred whenever possible.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの書式は機能的に等しいですが、可能であればいつでも略記書式が好ましいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of a dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの書式は機能的に同一であるけれども、短縮形がむしろ好まれ、このガイドを通して辞書の型に言及するときに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of an array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの書式は機能的に同一であるけれども、短縮形がむしろ好まれ、このガイドを通して配列の型に言及するとき使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although the unary plus operator doesn’t actually do anything, you can use it to provide symmetry in your code for positive numbers when also using the unary minus operator for negative numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単項プラス演算子は実際に何もしないけれども、あなたは、負の数に単項マイナス演算子を使うときに、正の数に対してもまたあなたのコードで釣り合いを取るためにそれを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although these types, functions, and operators are not part of the Swift language itself, they are used extensively in the discussions and code examples in this part of the book.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの型、関数、そして演算子は、スウィフト言語自身の一部ではないけれども、それらは本のこの部分の議論とコード例で広く使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although they are implemented as computed properties, the names of these properties can be appended to a floating-point literal value with dot syntax, as a way to use that literal value to perform distance conversions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは計算プロパティとして実装されるけれども、これらのプロパティの名前はある浮動小数点リテラル値に、そのリテラル値を距離変換を実行するために使う方法として、ドット構文で追加されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although you can define custom operators that contain a question mark (<bpt i="0" x="0">&lt;c0&gt;</bpt>?<ept i="0">&lt;/c0&gt;</ept>), they can’t consist of a single question mark character only.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは疑問符（<bpt i="0" x="0">&lt;c0&gt;</bpt>?<ept i="0">&lt;/c0&gt;</ept>）を含むあつらえの演算子を定義できるけれども、それは単一の疑問符文字だけから構成されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although you can query the current value of the <bpt i="0" x="0">&lt;c0&gt;</bpt>numberOfEdits<ept i="0">&lt;/c0&gt;</ept> property from within another source file, you can’t <bpt i="1" x="1">&lt;e1&gt;</bpt>modify<ept i="1">&lt;/e1&gt;</ept> the property from another source file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは別のソースファイル内から<bpt i="0" x="0">&lt;c0&gt;</bpt>numberOfEdits<ept i="0">&lt;/c0&gt;</ept>プロパティの現在の値についてたずねることができるけれども、あなたは別のソースファイルからこのプロパティを<bpt i="1" x="1">&lt;e1&gt;</bpt>修正<ept i="1">&lt;/e1&gt;</ept>できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although you write <bpt i="1" x="1">&lt;c1&gt;</bpt>return nil<ept i="1">&lt;/c1&gt;</ept> to trigger an initialization failure, you do not use the <bpt i="2" x="2">&lt;c2&gt;</bpt>return<ept i="2">&lt;/c2&gt;</ept> keyword to indicate initialization success.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>return nil<ept i="1">&lt;/c1&gt;</ept>を書くことで初期化失敗を引き起こすけれども、あなたは<bpt i="2" x="2">&lt;c2&gt;</bpt>return<ept i="2">&lt;/c2&gt;</ept>キーワードを初期化成功を指し示すためには使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always give type parameters upper camel case names (such as <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>MyTypeParameter<ept i="1">&lt;/c1&gt;</ept>) to indicate that they’re a placeholder for a <bpt i="2" x="2">&lt;e2&gt;</bpt>type<ept i="2">&lt;/e2&gt;</ept>, not a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらが、値ではなく、<bpt i="2" x="2">&lt;e2&gt;</bpt>型<ept i="2">&lt;/e2&gt;</ept>のためのプレースホルダであることを示すために、型パラメータに常にアッパーキャメルケース名（例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>や<bpt i="1" x="1">&lt;c1&gt;</bpt>MyTypeParameter<ept i="1">&lt;/c1&gt;</ept>など）を与えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always make sure that an optional contains a non-<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> value before using <bpt i="2" x="2">&lt;c2&gt;</bpt>!<ept i="2">&lt;/c2&gt;</ept> to force-unwrap its value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>必ずあるオプショナルが<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>ではない値を含むことを、それの値を強制アンラップする<bpt i="2" x="2">&lt;c2&gt;</bpt>!<ept i="2">&lt;/c2&gt;</ept>を使う前に確かめてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always prefix type property requirements with the <bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept> keyword when you define them in a protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあるプロトコルにおいてそれを定義するとき、常に、型プロパティ要件の前に<bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept>キーワードを置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always use a <bpt i="2" x="2">&lt;c2&gt;</bpt>break<ept i="2">&lt;/c2&gt;</ept> statement to ignore a <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>ケース節を無視するために、常に<bpt i="2" x="2">&lt;c2&gt;</bpt>break<ept i="2">&lt;/c2&gt;</ept>文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Always use a normal optional type if you need to check for a <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> value during the lifetime of a variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある変数の生涯のある時期に<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>値について確認する必要があるならば、必ず普通のオプショナル型を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt>Int8<ept i="0">&lt;/c0&gt;</ept> constant or variable can store numbers between <bpt i="1" x="1">&lt;c1&gt;</bpt>-128<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>127<ept i="2">&lt;/c2&gt;</ept>, whereas a <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept> constant or variable can store numbers between <bpt i="4" x="4">&lt;c4&gt;</bpt>0<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>255<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int8<ept i="0">&lt;/c0&gt;</ept>定数または変数は、<bpt i="1" x="1">&lt;c1&gt;</bpt>-128<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>127<ept i="2">&lt;/c2&gt;</ept>の間の数を保存することができる一方、<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept>定数または変数は、<bpt i="4" x="4">&lt;c4&gt;</bpt>0<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>255<ept i="5">&lt;/c5&gt;</ept>の間の数を保存することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt>available<ept i="0">&lt;/c0&gt;</ept> attribute specifying a Swift version availability can’t additionally specify a declaration’s platform availability.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトバージョン利用可能性を指定している<bpt i="0" x="0">&lt;c0&gt;</bpt>available<ept i="0">&lt;/c0&gt;</ept>属性は、さらに加えて宣言の持つプラットホーム利用可能性を指定することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement is used for executing code based on the evaluation of one or more conditions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文は、一つ以上の条件の評価に基づいてコードを実行するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="1" x="1">&lt;c1&gt;</bpt>available<ept i="1">&lt;/c1&gt;</ept> attribute specifying a Swift version availability can’t use the asterisk.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトバージョン有効性を指定している<bpt i="1" x="1">&lt;c1&gt;</bpt>available<ept i="1">&lt;/c1&gt;</ept>属性は、アスタリスクを使うことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept> statement chained together in this way has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このやり方で一緒につながれる<bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept>文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>array literal<ept i="0">&lt;/e0&gt;</ept> is an ordered collection of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>配列リテラル<ept i="0">&lt;/e0&gt;</ept>は、順序付けられた値のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>array<ept i="0">&lt;/e0&gt;</ept> stores values of the same type in an ordered list.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>配列<ept i="0">&lt;/e0&gt;</ept>は、同じ型の値を順番をつけられたリストに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>associated type<ept i="0">&lt;/e0&gt;</ept> gives a placeholder name to a type that is used as part of the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>関連型<ept i="0">&lt;/e0&gt;</ept>は、プロトコルの一部として使われる型にプレースホルダ名を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>autoclosure<ept i="0">&lt;/e0&gt;</ept> is a closure that is automatically created to wrap an expression that’s being passed as an argument to a function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>自動クロージャ<ept i="0">&lt;/e0&gt;</ept>は、自動的に作成されて、引数として関数に渡されている式を包み込むクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>availability condition<ept i="0">&lt;/e0&gt;</ept> is used as a condition of an <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>guard<ept i="3">&lt;/c3&gt;</ept> statement to query the availability of APIs at runtime, based on specified platforms arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>有効性条件<ept i="0">&lt;/e0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>guard<ept i="3">&lt;/c3&gt;</ept>文の条件として使われて、APIの有効性を実行時に、指定されたプラットホーム引数に基づいて問いただします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>enumeration case pattern<ept i="0">&lt;/e0&gt;</ept> matches a case of an existing enumeration type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>列挙ケース節パターン<ept i="0">&lt;/e0&gt;</ept>は、既存の列挙型のケース節にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>enumeration declaration<ept i="0">&lt;/e0&gt;</ept> introduces a named enumeration type into your program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>列挙宣言<ept i="0">&lt;/e0&gt;</ept>は、名前をつけられた列挙型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>enumeration<ept i="0">&lt;/e0&gt;</ept> defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>列挙<ept i="0">&lt;/e0&gt;</ept>は、一群の関連した値のための共通の型を定義して、それらの値を型安全な方法であなたのコード内で扱えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>explicit member expression<ept i="0">&lt;/e0&gt;</ept> allows access to the members of a named type, a tuple, or a module.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>明示的メンバー式<ept i="0">&lt;/e0&gt;</ept>は、名前付きの型、タプル、またはモジュールのメンバーに対するアクセスを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>expression pattern<ept i="0">&lt;/e0&gt;</ept> represents the value of an expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>式パターン<ept i="0">&lt;/e0&gt;</ept>は、ある式の値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>extension declaration<ept i="0">&lt;/e0&gt;</ept> allows you to extend the behavior of existing types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>拡張宣言<ept i="0">&lt;/e0&gt;</ept>があなたに可能にするのは、既存の型の挙動を拡張することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>identifier pattern<ept i="0">&lt;/e0&gt;</ept> matches any value and binds the matched value to a variable or constant name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>識別子パターン<ept i="0">&lt;/e0&gt;</ept>は、どんな値にでもマッチして、マッチされた値を変数や定数の名前に縛りつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>implicit member expression<ept i="0">&lt;/e0&gt;</ept> is an abbreviated way to access a member of a type, such as an enumeration case or a type method, in a context where type inference can determine the implied type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>暗黙のメンバー式<ept i="0">&lt;/e0&gt;</ept>は、型推論が暗黙の型を決定することができる前後関係において、例えば列挙のケース節や型メソッドなど、ある型のメンバーにアクセスするための簡略された方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>import declaration<ept i="0">&lt;/e0&gt;</ept> lets you access symbols that are declared outside the current file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>インポート宣言<ept i="0">&lt;/e0&gt;</ept>は、あなたに現在のファイルの外側で宣言されるシンボルにアクセスさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>infix operator<ept i="0">&lt;/e0&gt;</ept> is a binary operator that is written between its two operands, such as the familiar addition operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>) in the expression <bpt i="2" x="2">&lt;c2&gt;</bpt>1 + 2<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>接中辞演算子<ept i="0">&lt;/e0&gt;</ept>は、それの２つ演算数の間で書かれる二項演算子です、例えばよく知られた式<bpt i="2" x="2">&lt;c2&gt;</bpt>1 + 2で<ept i="2">&lt;/c2&gt;</ept>の加算演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>initializer declaration<ept i="0">&lt;/e0&gt;</ept> introduces an initializer for a class, structure, or enumeration into your program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>イニシャライザ宣言<ept i="0">&lt;/e0&gt;</ept>は、あなたのプログラムにクラス、構造体、または列挙のためのイニシャライザを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>initializer expression<ept i="0">&lt;/e0&gt;</ept> provides access to a type’s initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、スーパークラスのイニシャライザに委任するために、<bpt i="0" x="0">&lt;e0&gt;</bpt>イニシャライザ式<ept i="0">&lt;/e0&gt;</ept>を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>-times-table is based on a fixed mathematical rule.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>九九の<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>の段は、決められた数学的な規則に基づきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>octal<ept i="0">&lt;/e0&gt;</ept> number, with a <bpt i="1" x="1">&lt;c1&gt;</bpt>0o<ept i="1">&lt;/c1&gt;</ept> prefix</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>８進<ept i="0">&lt;/e0&gt;</ept>数は、接頭辞<bpt i="1" x="1">&lt;c1&gt;</bpt>0o<ept i="1">&lt;/c1&gt;</ept>つきで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>operator declaration<ept i="0">&lt;/e0&gt;</ept> introduces a new infix, prefix, or postfix operator into your program and is declared using the <bpt i="1" x="1">&lt;c1&gt;</bpt>operator<ept i="1">&lt;/c1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>演算子宣言<ept i="0">&lt;/e0&gt;</ept>は、新しい接中辞、接頭辞、または接尾辞演算子をあなたのプログラムに導入します、そしてキーワード<bpt i="1" x="1">&lt;c1&gt;</bpt>operator<ept i="1">&lt;/c1&gt;</ept>を使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>operator<ept i="0">&lt;/e0&gt;</ept> is a special symbol or phrase that you use to check, change, or combine values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>演算子<ept i="0">&lt;/e0&gt;</ept>は、あなたがいろいろな値を調べたり、変えたり、結合したりするために使う、特別な記号または語句です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>optional pattern<ept i="0">&lt;/e0&gt;</ept> matches values wrapped in a <bpt i="1" x="1">&lt;c1&gt;</bpt>some(Wrapped)<ept i="1">&lt;/c1&gt;</ept> case of an <bpt i="2" x="2">&lt;c2&gt;</bpt>Optional&lt;Wrapped&gt;<ept i="2">&lt;/c2&gt;</ept> enumeration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>オプショナルパターン<ept i="0">&lt;/e0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Optional&lt;Wrapped&gt;<ept i="2">&lt;/c2&gt;</ept>列挙の<bpt i="1" x="1">&lt;c1&gt;</bpt>Some(Wrapped)<ept i="1">&lt;/c1&gt;</ept>ケース節でラップされる値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>optional-chaining expression<ept i="0">&lt;/e0&gt;</ept> provides a simplified syntax for using optional values in postfix expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>オプショナル連鎖式<ept i="0">&lt;/e0&gt;</ept>は、オプショナルの値を使うために単純化された構文を接尾辞式において提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>optional-try expression<ept i="0">&lt;/e0&gt;</ept> consists of the <bpt i="1" x="1">&lt;c1&gt;</bpt>try?<ept i="1">&lt;/c1&gt;</ept> operator followed by an expression that can throw an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>オプショナルtry式<ept i="0">&lt;/e0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>try?<ept i="1">&lt;/c1&gt;</ept>演算子と後につづくエラーをスローできる１つの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Optional-Chaining Expression<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> must appear within a postfix expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつの<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オプショナル連鎖式<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>が、ひとつの接尾辞式の内部に現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An HTTP status code is a special value returned by a web server whenever you request a web page.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>HTTP状態コードは、あなたがウェブ・ページを要請するときはいつでもウェブ・サーバーによって返されるある特別な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An arbitrary Unicode scalar, written as <bpt i="0" x="0">&lt;c0&gt;</bpt>\u{<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>}<ept i="2">&lt;/c2&gt;</ept>, where <bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept> is a 1–8 digit hexadecimal number with a value equal to a valid Unicode code point (Unicode is discussed in <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Unicode<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> below)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>任意のユニコード・スカラー、<bpt i="0" x="0">&lt;c0&gt;</bpt>\u{<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>}<ept i="2">&lt;/c2&gt;</ept>のように書かれます、ここで<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>は有効なユニコードコードポイントと等しい値を持つ１-８桁の16進数です（ユニコードは下の<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Unicode<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>で議論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An array allows new items to be inserted and removed at any location in the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列は、新しい項目を差し込まれたり取り外除かれることがその配列のどんな場所においても許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An array literal is written as a list of values, separated by commas, surrounded by a pair of square brackets:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列リテラルは、一対の角括弧に囲まれて、コンマで区切られる値のリストとして書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An arrow (→) is used to mark grammar productions and can be read as “can consist of.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>矢印（→）を使って文法導出を示します、「その文法はこうしたものから成り立つことができる」と読まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An assertion is triggered if you try to access a subscript that is outside of the matrix bounds:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがマトリックス境界の外にある添え字にアクセスしようとするならば、表明が引き起こされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An associated type provides an alias for a type that is used as part of a protocol’s declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連型は、エイリアスをプロトコルの宣言の一部として使われる型のために用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An autoclosure lets you delay evaluation, because the code inside isn’t run until you call the closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自動クロージャは、あなたに評価を延期させます、内部のコードはあなたがそのクロージャを呼び出すまで実行されないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An availability condition has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>有効性条件は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An eight-bit number has seven value bits, so this means <bpt i="3" x="3">&lt;c3&gt;</bpt>2<ept i="3">&lt;/c3&gt;</ept> to the power of <bpt i="4" x="4">&lt;c4&gt;</bpt>7<ept i="4">&lt;/c4&gt;</ept>, or <bpt i="5" x="5">&lt;c5&gt;</bpt>128<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>８ビットの数は７つの値ビットを持ちますので、これは<bpt i="3" x="3">&lt;c3&gt;</bpt>2<ept i="3">&lt;/c3&gt;</ept>の<bpt i="4" x="4">&lt;c4&gt;</bpt>7<ept i="4">&lt;/c4&gt;</ept>乗、つまり<bpt i="5" x="5">&lt;c5&gt;</bpt>128<ept i="5">&lt;/c5&gt;</ept>を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An element name consists of an identifier followed immediately by a colon (:).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>要素名は、識別子に直ちにコロン（：）が続くものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An empty dictionary literal is written as a colon inside a pair of brackets (<bpt i="5" x="5">&lt;c5&gt;</bpt>[:]<ept i="5">&lt;/c5&gt;</ept>) to distinguish it from an empty array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の辞書リテラルは、一対の角括弧の中のコロン（<bpt i="5" x="5">&lt;c5&gt;</bpt>[:]<ept i="5">&lt;/c5&gt;</ept>）として書かれることで、空の配列リテラルからそれを区別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An enclosing function can also return one of its nested functions to allow the nested function to be used in another scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>囲んでいる関数は、また、入れ子にされた関数が別のスコープにおいて使われるのを許可するために、その入れ子にされた関数のうちの１つを返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An enumeration case that’s marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>indirect<ept i="0">&lt;/c0&gt;</ept> modifier must have an associated value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>indirect<ept i="0">&lt;/c0&gt;</ept>修飾子で印される列挙ケース節は、関連値を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An enumeration that is marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>indirect<ept i="1">&lt;/c1&gt;</ept> modifier can contain a mixture of cases that have associated values and cases those that don’t.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>indirect<ept i="1">&lt;/c1&gt;</ept>修飾子で印される列挙は、関連値を持つケース節とそうでないケース節の入り交じったものを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An explicit spelling of <bpt i="0" x="0">&lt;c0&gt;</bpt>unowned<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>unowned<ept i="0">&lt;/c0&gt;</ept>の明確なつづり方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある拡張書記素クラスタは１つ以上のユニコード・スカラーの連なりです、それは（組み合わされて）人間の読み取り可能な１つの文字を作り出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An extension can be used to extend an existing generic type, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Extending a Generic Type<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張は、既存の総称体型を拡張するために使われることができます、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>総称体型を拡張する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An extension can extend an existing type to make it adopt one or more protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張は、既存の型を拡張して、それが一つ以上のプロトコルを採用するようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An implicitly unwrapped optional is a normal optional behind the scenes, but can also be used like a nonoptional value, without the need to unwrap the optional value each time it’s accessed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的にアンラップされるオプショナルは、舞台裏では普通のオプショナルです、しかしまたオプショナルでない値のように扱うこともできます、それがアクセスされるたびにオプショナルの値をアンラップする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An in-out parameter has a value that is passed <bpt i="1" x="1">&lt;e1&gt;</bpt>in<ept i="1">&lt;/e1&gt;</ept> to the function, is modified by the function, and is passed back <bpt i="2" x="2">&lt;e2&gt;</bpt>out<ept i="2">&lt;/e2&gt;</ept> of the function to replace the original value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>in-outパラメータはある値を持ち、それは関数の<bpt i="1" x="1">&lt;e1&gt;</bpt>中に<ept i="1">&lt;/e1&gt;</ept>渡されて、その関数によって修正されて、それから逆にその関数の<bpt i="2" x="2">&lt;e2&gt;</bpt>外に<ept i="2">&lt;/e2&gt;</ept>渡されて本来の値に取って代わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An initializer cannot call any instance methods, read the values of any instance properties, or refer to <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> as a value until after the first phase of initialization is complete.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザは、初期化の最初の段階が完了するまで、どんなインスタンスメソッドも呼ぶこと、どんなインスタンスプロパティの値も読むこと、または<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>をひとつの値として参照することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An instance method can be called only on a specific instance of the type it belongs to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスメソッドは、それが属している型のある特定のインスタンスでだけ呼ばれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An instance method has implicit access to all other instance methods and properties of that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるインスタンスメソッドは、無条件にその型の他のインスタンスメソッドとプロパティの全てへのアクセスを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An instance of a <bpt i="0" x="0">&lt;e0&gt;</bpt>class<ept i="0">&lt;/e0&gt;</ept> is traditionally known as an <bpt i="1" x="1">&lt;e1&gt;</bpt>object<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>クラス<ept i="0">&lt;/e0&gt;</ept>のインスタンスは、伝統的に<bpt i="1" x="1">&lt;e1&gt;</bpt>オブジェクト<ept i="1">&lt;/e1&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An integer type can be initialized with a <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数型は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>値で初期化されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An optional <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> is written as <bpt i="4" x="4">&lt;c4&gt;</bpt>Int?<ept i="4">&lt;/c4&gt;</ept>, not <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt>Int?<ept i="4">&lt;/c4&gt;</ept>のように書かれます、<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An optional protocol requirement can be called with optional chaining, to account for the possibility that the requirement was not implemented by a type that conforms to the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルのプロトコル要件は、オプショナル連鎖を使って呼び出されることができます、それによってプロトコルに準拠する型によって要件が満たされなかったという可能性に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An optional represents two possibilities: Either there <bpt i="1" x="1">&lt;e1&gt;</bpt>is<ept i="1">&lt;/e1&gt;</ept> a value, and you can unwrap the optional to access that value, or there <bpt i="2" x="2">&lt;e2&gt;</bpt>isn’t<ept i="2">&lt;/e2&gt;</ept> a value at all.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるオプショナルは２つの可能性を表します：ある値が存在<bpt i="1" x="1">&lt;e1&gt;</bpt>する<ept i="1">&lt;/e1&gt;</ept>、するとあなたはそのオプショナルをアンラップすることでその値を利用できます、または値がそもそも存在<bpt i="2" x="2">&lt;e2&gt;</bpt>しない<ept i="2">&lt;/e2&gt;</ept>かのいずれか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An optional tuple type such as <bpt i="0" x="0">&lt;c0&gt;</bpt>(Int, Int)?<ept i="0">&lt;/c0&gt;</ept> is different from a tuple that contains optional types such as <bpt i="1" x="1">&lt;c1&gt;</bpt>(Int?, Int?)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>(Int, Int)?<ept i="0">&lt;/c0&gt;</ept>のようなオプショナルタプル型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>(Int?, Int?)<ept i="1">&lt;/c1&gt;</ept>のようなオプショナル型を含むタプルとは異なる方式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An optional value either contains a value or contains <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept> to indicate that a value is missing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの値は、ある値を含むか、値が見つからないことを示す<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>を含むかのどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An optional variable is used here, because players can leave the game at any point.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの変数がここで使われます、なぜなら、プレーヤーはどの時点でもゲームから離れることができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An overridden method named <bpt i="0" x="0">&lt;c0&gt;</bpt>someMethod()<ept i="0">&lt;/c0&gt;</ept> can call the superclass version of <bpt i="1" x="1">&lt;c1&gt;</bpt>someMethod()<ept i="1">&lt;/c1&gt;</ept> by calling <bpt i="2" x="2">&lt;c2&gt;</bpt>super.someMethod()<ept i="2">&lt;/c2&gt;</ept> within the overriding method implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>someMethod()<ept i="0">&lt;/c0&gt;</ept>という名前のオーバーライドされたメソッドは、オーバーライドしているメソッド実装内で<bpt i="2" x="2">&lt;c2&gt;</bpt>super.someMethod()<ept i="2">&lt;/c2&gt;</ept>を呼ぶことによって、スーパークラス版の<bpt i="1" x="1">&lt;c1&gt;</bpt>someMethod()<ept i="1">&lt;/c1&gt;</ept>を呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An overridden property called <bpt i="0" x="0">&lt;c0&gt;</bpt>someProperty<ept i="0">&lt;/c0&gt;</ept> can access the superclass version of <bpt i="1" x="1">&lt;c1&gt;</bpt>someProperty<ept i="1">&lt;/c1&gt;</ept> as <bpt i="2" x="2">&lt;c2&gt;</bpt>super.someProperty<ept i="2">&lt;/c2&gt;</ept> within the overriding getter or setter implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>someProperty<ept i="0">&lt;/c0&gt;</ept>と呼ばれるオーバーライドされたプロパティは、オーバーライドしているゲッターまたはセッター実装内で、<bpt i="2" x="2">&lt;c2&gt;</bpt>super.someProperty<ept i="2">&lt;/c2&gt;</ept>のようにしてスーパークラス版の<bpt i="1" x="1">&lt;c1&gt;</bpt>someProperty<ept i="1">&lt;/c1&gt;</ept>にアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An overridden subscript for <bpt i="0" x="0">&lt;c0&gt;</bpt>someIndex<ept i="0">&lt;/c0&gt;</ept> can access the superclass version of the same subscript as <bpt i="1" x="1">&lt;c1&gt;</bpt>super[someIndex]<ept i="1">&lt;/c1&gt;</ept> from within the overriding subscript implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>someIndex<ept i="0">&lt;/c0&gt;</ept>のためのオーバーライドされた添え字は、オーバーライドしている添え字実装内から<bpt i="1" x="1">&lt;c1&gt;</bpt>super[someIndex]<ept i="1">&lt;/c1&gt;</ept>のようにしてスーパークラス版の同じ添え字にアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An override can make an inherited class member more accessible than its superclass version.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバーライドは、継承されたクラス・メンバーを、そのスーパークラス版よりもアクセス度を高くすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An underscore (<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>) before a parameter name suppresses the argument label.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメーター名の前のアンダースコア（<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>）は、引数ラベルを抑制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An underscore (<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>) parameter is explicitly ignored and can’t be accessed within the body of the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつのアンダースコア（<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>）のパラメータは、明確に無視されます、そして関数の本体内でアクセスされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unowned reference is expected to always have a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非所有者参照は、常にある値を持っていることを期待されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An unowned reference is the appropriate capture method to use to resolve the strong reference cycle in the <bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept> example from earlier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非所有者参照は、以前の<bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept>例での強い参照循環を解消するのために使うのに適切な捕獲の手法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And <bpt i="4" x="4">&lt;c4&gt;</bpt>SomeProtocol.self<ept i="4">&lt;/c4&gt;</ept> returns <bpt i="5" x="5">&lt;c5&gt;</bpt>SomeProtocol<ept i="5">&lt;/c5&gt;</ept> itself, not an instance of a type that conforms to <bpt i="6" x="6">&lt;c6&gt;</bpt>SomeProtocol<ept i="6">&lt;/c6&gt;</ept> at runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そして、<bpt i="4" x="4">&lt;c4&gt;</bpt>SomeProtocol.self<ept i="4">&lt;/c4&gt;</ept>は、<bpt i="5" x="5">&lt;c5&gt;</bpt>SomeProtocol<ept i="5">&lt;/c5&gt;</ept>自身を返します、実行時に<bpt i="6" x="6">&lt;c6&gt;</bpt>SomeProtocol<ept i="6">&lt;/c6&gt;</ept>に準拠するある型のインスタンスではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And because the value of <bpt i="4" x="4">&lt;c4&gt;</bpt>ExampleEnum.c<ept i="4">&lt;/c4&gt;</ept> is explicitly set to <bpt i="5" x="5">&lt;c5&gt;</bpt>5<ept i="5">&lt;/c5&gt;</ept>, the value of <bpt i="6" x="6">&lt;c6&gt;</bpt>ExampleEnum.d<ept i="6">&lt;/c6&gt;</ept> is automatically incremented from <bpt i="7" x="7">&lt;c7&gt;</bpt>5<ept i="7">&lt;/c7&gt;</ept> and is therefore <bpt i="8" x="8">&lt;c8&gt;</bpt>6<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そして<bpt i="4" x="4">&lt;c4&gt;</bpt>ExampleEnum.cの<ept i="4">&lt;/c4&gt;</ept>値が明示的に<bpt i="5" x="5">&lt;c5&gt;</bpt>5<ept i="5">&lt;/c5&gt;</ept>に設定されるので、<bpt i="6" x="6">&lt;c6&gt;</bpt>ExampleEnum.d<ept i="6">&lt;/c6&gt;</ept>の値は<bpt i="7" x="7">&lt;c7&gt;</bpt>5<ept i="7">&lt;/c7&gt;</ept>から自動的に増加して、したがって<bpt i="8" x="8">&lt;c8&gt;</bpt>6<ept i="8">&lt;/c8&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And just like functions and methods, you use the <bpt i="0" x="0">&lt;c0&gt;</bpt>throws<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>rethrows<ept i="1">&lt;/c1&gt;</ept> keyword after an initializer’s parameters to indicate the appropriate behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そして関数やメソッドのように、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>throws<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>rethrows<ept i="1">&lt;/c1&gt;</ept>キーワードをイニシャライザのパラメータの後に使って、ふさわしい挙動を指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And just like functions, you can get a reference to an enumeration case and apply it later in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらにまさに関数のように、あなたはある列挙ケース節の参照を得ることができ、それを後であなたのコードに応用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And so on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>などなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And, because weak references need to allow their value to be changed to <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> at runtime, they are always declared as variables, rather than constants, of an optional type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そしてまた、弱い参照はそれらの値を実行時に<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>に変更されるのを許される必要があることから、それらは常にオプショナル型の変数として宣言されます、定数ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another choice for enumeration cases is to have values associated with the case—these values are determined when you make the instance, and they can be different for each instance of an enumeration case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙ケース節の別の選択はそのケース節と結びつけられる値を持つことになります — それらの値はあなたがインスタンスを作る時に決定されます、そしてそれらはある列挙ケース節のインスタンスそれぞれで異なることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another way to handle errors is to use <bpt i="0" x="0">&lt;c0&gt;</bpt>try?<ept i="0">&lt;/c0&gt;</ept> to convert the result to an optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーを取り扱う別の方法は、<bpt i="0" x="0">&lt;c0&gt;</bpt>try?<ept i="0">&lt;/c0&gt;</ept>を使って結果をオプショナルに変換することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Another way to handle optional values is to provide a default value using the <bpt i="0" x="0">&lt;c0&gt;</bpt>??<ept i="0">&lt;/c0&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの値を取り扱うもう１つのの方法は、省略時の値を<bpt i="0" x="0">&lt;c0&gt;</bpt>??<ept i="0">&lt;/c0&gt;</ept>演算子を使って提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any <bpt i="0" x="0">&lt;c0&gt;</bpt>Dice<ept i="0">&lt;/c0&gt;</ept> instance can now be treated as <bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どんな<bpt i="0" x="0">&lt;c0&gt;</bpt>Dice<ept i="0">&lt;/c0&gt;</ept>インスタンスでも、今や<bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept>として扱われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any additional setup work that uses methods, getters, or setters can also be done at this point.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッド、ゲッター、またはセッターを使うどんな追加の準備作業も、また、この時点で行われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any attempt to override a final method, property, or subscript in a subclass is reported as a compile-time error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるサブクラスの中の最終的なメソッド、プロパティ、または添え字をオーバーライドするどんな試みも、コンパイル時エラーとして報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any attempt to set a property through optional chaining returns a value of type <bpt i="6" x="6">&lt;c6&gt;</bpt>Void?<ept i="6">&lt;/c6&gt;</ept>, which enables you to compare against <bpt i="7" x="7">&lt;c7&gt;</bpt>nil<ept i="7">&lt;/c7&gt;</ept> to see if the property was set successfully:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖を通してプロパティを設定しようとするあらゆる試みは、型<bpt i="6" x="6">&lt;c6&gt;</bpt>Void?<ept i="6">&lt;/c6&gt;</ept>の値を返します、それは、あなたに<bpt i="7" x="7">&lt;c7&gt;</bpt>nil<ept i="7">&lt;/c7&gt;</ept>と比較することでそのプロパティがうまく設定されたかどうか調べることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any attempt to subclass a final class is reported as a compile-time error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最終版クラスにサブクラスを作る試みは何であれ、コンパイル時エラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any bits that are moved beyond the bounds of the integer’s storage are discarded.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数の格納量の境界を越えて動かされるあらゆるビットは、捨てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any class that does not inherit from another class is known as a <bpt i="0" x="0">&lt;e0&gt;</bpt>base class<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>別のクラスから継承しない何らかのクラスは、<bpt i="0" x="0">&lt;e0&gt;</bpt>基盤クラス<ept i="0">&lt;/e0&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any constants or variables assigned a value from an optional binding declaration in a <bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept> statement condition can be used for the rest of the guard statement’s enclosing scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept>文条件の中のオプショナル束縛宣言由来のあらゆる定数または変数は、guard文の囲むスコープの他の部分で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any errors thrown inside a nonthrowing function must be handled inside the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スローしない関数の内部でスローされるどんなエラーも、その関数の内部で取り扱われなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any gaps in an array are closed when an item is removed, and so the value at index <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept> is once again equal to <bpt i="1" x="1">&lt;c1&gt;</bpt>"Six eggs"<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>項目が取り外されるとき、配列でのどんな隙間でも閉じられます、なのでインデックス<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>での値はふたたび<bpt i="1" x="1">&lt;c1&gt;</bpt>"Six eggs"<ept i="1">&lt;/c1&gt;</ept>と等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any initializer in the diagram above can be used to create a fully-initialized instance of the class they belong to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の図の中のどんなイニシャライザでも、それらが属しているクラスの充分に初期化されたインスタンスをつくるために使用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any internal implementation details of your framework can still use the default access level of internal, or can be marked as private or file private if you want to hide them from other parts of the framework’s internal code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのフレームワークのあらゆる内部的実装詳細は、依然として省略時のアクセス水準である内部を使用します、もしくはあなたがそれらをそのフレームワークの内部コードの他の部分から隠したいならば非公開またはファイル限定として印されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any properties stored by the structure are themselves value types, which would also be expected to be copied rather than referenced.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体で保存されるどんなプロパティでもそれら自身値型であり、それはまた参照をつけられるのではなくコピーされることを期待される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any protocol that inherits from a protocol that’s marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept> requirement can likewise be adopted only by class types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept>要件で印されるプロトコルから継承するどんなプロトコルも、同じようにクラス型でのみ採用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any type aliases you define are treated as distinct types for the purposes of access control.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが定義するどんな型エイリアスでも、アクセス制御の目的のためにはっきりした型とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any type argument substituted for a type parameter must meet all the constraints and requirements placed on the type parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型パラメータと置き換えられるどんな型引数でも、型パラメータに設置された制約と要件の全てに応じなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any type can be explicitly declared to be (or implicitly converted to) an optional type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆる型は、オプショナル型であるとして明示的に宣言される（または暗黙的に変換される）ことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any type members added in an extension have the same default access level as type members declared in the original type being extended.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張において加えられるどんな型メンバーでも、拡張されているところの本来の型で宣言される型メンバーと同じ省略時のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept> protocol must be able to specify the type of values it stores.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するあらゆる型は、それが格納する値の型を指定することができなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any type that is <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> can be used safely with the <bpt i="1" x="1">&lt;c1&gt;</bpt>findIndex(of:in:)<ept i="1">&lt;/c1&gt;</ept> function, because it’s guaranteed to support the equal to operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>であるどんな型でも<bpt i="1" x="1">&lt;c1&gt;</bpt>findIndex(of:in:)<ept i="1">&lt;/c1&gt;</ept>関数で問題なく使われることができます、なぜなら、それが同等演算子をサポートすると保証されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any type that satisfies the requirements of a protocol is said to <bpt i="2" x="2">&lt;e2&gt;</bpt>conform<ept i="2">&lt;/e2&gt;</ept> to that protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコルの要件を満たす何らかの型は、そのプロトコルに<bpt i="2" x="2">&lt;e2&gt;</bpt>準拠する<ept i="2">&lt;/e2&gt;</ept>と言われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any variables or constants that were assigned values using an optional binding as part of the condition are available for the rest of the code block that the <bpt i="2" x="2">&lt;c2&gt;</bpt>guard<ept i="2">&lt;/c2&gt;</ept> statement appears in.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル束縛を使ってこの条件の一部として値を代入された、あらゆる変数や定数は、<bpt i="2" x="2">&lt;c2&gt;</bpt>guard<ept i="2">&lt;/c2&gt;</ept>文が現れるコードブロックの残りの部分で利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any whitespace between the backslash and the line break is also omitted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バックスラッシュとラインブレークの間のあらゆる空白もまた省かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Anything that adopts <bpt i="2" x="2">&lt;c2&gt;</bpt>PrettyTextRepresentable<ept i="2">&lt;/c2&gt;</ept> must satisfy all of the requirements enforced by <bpt i="3" x="3">&lt;c3&gt;</bpt>TextRepresentable<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;e4&gt;</bpt>plus<ept i="4">&lt;/e4&gt;</ept> the additional requirements enforced by <bpt i="5" x="5">&lt;c5&gt;</bpt>PrettyTextRepresentable<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>PrettyTextRepresentable<ept i="2">&lt;/c2&gt;</ept>を採用するどんなものでも、<bpt i="3" x="3">&lt;c3&gt;</bpt>TextRepresentable<ept i="3">&lt;/c3&gt;</ept>によって強制される要件の全て、それに<bpt i="4" x="4">&lt;e4&gt;</bpt>加えて<ept i="4">&lt;/e4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>PrettyTextRepresentable<ept i="5">&lt;/c5&gt;</ept>によって強制される追加の要件を満たさなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Anything that is <bpt i="3" x="3">&lt;c3&gt;</bpt>PrettyTextRepresentable<ept i="3">&lt;/c3&gt;</ept> must also be <bpt i="4" x="4">&lt;c4&gt;</bpt>TextRepresentable<ept i="4">&lt;/c4&gt;</ept>, and so the implementation of <bpt i="5" x="5">&lt;c5&gt;</bpt>prettyTextualDescription<ept i="5">&lt;/c5&gt;</ept> starts by accessing the <bpt i="6" x="6">&lt;c6&gt;</bpt>textualDescription<ept i="6">&lt;/c6&gt;</ept> property from the <bpt i="7" x="7">&lt;c7&gt;</bpt>TextRepresentable<ept i="7">&lt;/c7&gt;</ept> protocol to begin an output string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>PrettyTextRepresentable<ept i="3">&lt;/c3&gt;</ept>であるものは何でも、また<bpt i="4" x="4">&lt;c4&gt;</bpt>TextRepresentable<ept i="4">&lt;/c4&gt;</ept>でなければなりません、なので<bpt i="5" x="5">&lt;c5&gt;</bpt>prettyTextualDescription<ept i="5">&lt;/c5&gt;</ept>の実装は出力文字列を開始するために<bpt i="7" x="7">&lt;c7&gt;</bpt>TextRepresentable<ept i="7">&lt;/c7&gt;</ept>プロトコルからの<bpt i="6" x="6">&lt;c6&gt;</bpt>textualDescription<ept i="6">&lt;/c6&gt;</ept>プロパティにアクセスすることによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this attribute to <bpt i="0" x="0">&lt;c0&gt;</bpt>import<ept i="0">&lt;/c0&gt;</ept> declarations for modules compiled with testing enabled to access any entities marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>internal<ept i="1">&lt;/c1&gt;</ept> access-level modifier as if they were declared with the <bpt i="2" x="2">&lt;c2&gt;</bpt>public<ept i="2">&lt;/c2&gt;</ept> access-level modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性をテストすることを可能にされた状態でコンパイルされたモジュールに対する<bpt i="0" x="0">&lt;c0&gt;</bpt>import<ept i="0">&lt;/c0&gt;</ept>宣言に適用することで、<bpt i="1" x="1">&lt;c1&gt;</bpt>internal<ept i="1">&lt;/c1&gt;</ept>アクセス水準修飾子で印されるあらゆる実在に、まるでそれらが<bpt i="2" x="2">&lt;c2&gt;</bpt>public<ept i="2">&lt;/c2&gt;</ept>アクセス水準修飾子を使って宣言されたかのようにアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this attribute to a class to indicate that it’s the application delegate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性をあるクラスに適用することで、それがアプリケーション委任であることを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this attribute to a class to manually specify the name used by <bpt i="0" x="0">&lt;c0&gt;</bpt>NSKeyedArchiver<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NSKeyedUnarchiver<ept i="1">&lt;/c1&gt;</ept> when archiving instances of the class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性をあるクラスに適用することで、手動で<bpt i="0" x="0">&lt;c0&gt;</bpt>NSKeyedArchiver<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>NSKeyedUnarchiver<ept i="1">&lt;/c1&gt;</ept>によって使われる名前の指定を、そのクラスのインスタンスをアーカイブする場合には行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this attribute to a function or method declaration to suppress the compiler warning when the function or method that returns a value is called without using its result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性を関数またはメソッド宣言に適用して、値を返す関数やメソッドがそれの結果を使うことなく呼び出された時にコンパイラが警告を発するのを抑制してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this attribute to a method, property, subscript, or initializer declaration to suppress an implicit <bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性をメソッド、プロパティ、添え字、およびイニシャライザ宣言に適用することで、暗黙的に<bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept>属性となるのを抑制してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this attribute to a parameter’s type in a method or function declaration to indicate that the parameter’s value can be stored for later execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性をメソッドや関数宣言の中のパラメータの型に適用して、そのパラメータの値がその後の実行のために保管されることができるのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this attribute to a parameter’s type in a method or function declaration, for a parameter of a function type that takes no arguments and that returns a value of the type of the expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性を、メソッドまたは関数宣言においてあるパラメータの型に対して、引数を持たずそして式の型の値を返す関数型のあるパラメータのために、適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this attribute to a stored variable property of a class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性をクラスの保存変数プロパティに適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this attribute to an instance method or stored variable property of a class that inherits from <bpt i="0" x="0">&lt;c0&gt;</bpt>NSManagedObject<ept i="0">&lt;/c0&gt;</ept> to indicate that Core Data dynamically provides its implementation at runtime, based on the associated entity description.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性を<bpt i="0" x="0">&lt;c0&gt;</bpt>NSManagedObject<ept i="0">&lt;/c0&gt;</ept>から継承するクラスのインスタンスメソッドまたは保存変数プロパティに適用することで、関連する実体記述に基づいて、Coreデータが動的にそれの実装に実行時に提供されることを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this attribute to any class declaration that can have the <bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性を<bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept>属性を持つことができる何らかのクラス定義に適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this attribute to any declaration that can be represented in Objective-C—for example, nonnested classes, protocols, nongeneric enumerations (constrained to integer raw-value types), properties and methods (including getters and setters) of classes, protocols and optional members of a protocol, initializers, and subscripts.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性をObjective-Cにおいて表わされることができる何らかの宣言に適用してください ― 例えば、入れ子にされないクラス、プロトコル、総称体でない列挙（整数の生の値型に制限される）、クラスのプロパティとメソッド（ゲッターやセッターを含む）、プロトコルおよびあるプロトコルのオプショナルメンバ、イニシャライザ、そして添え字など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this attribute to expose a custom GameplayKit component property to the SpriteKit editor UI.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性を適用することであつらえのGameplayKitコンポーネントプロパティをSpriteKitエディタUIに露出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this attribute to indicate a declaration’s lifecycle relative to certain Swift language versions or certain platforms and operating system versions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性を適用することで、ある宣言の寿命を、特定のスウィフト言語バージョンまたは特定のプラットホームおよびオペレーティングシステムバージョンに関して示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this attribute to the type of a function to indicate its calling conventions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性を関数の型に適用して、それの呼出規約を示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this modifier to a class or to a property, method, or subscript member of a class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この修飾子をクラスに、またはプロパティ、メソッド、またはクラスの添え字メンバーに適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed and subclassed by code in the same module as the declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この修飾子を宣言に適用して、その宣言がアクセスされることおよびサブクラスを作られることが、宣言と同じモジュールの中のコードによって可能なのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed only by code in the same module as the declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この修飾子を宣言に適用して、その宣言が、宣言と同じモジュールの中のコードによってのみアクセスされることができるのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed only by code in the same source file as the declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この修飾子を宣言に適用して、その宣言が、宣言と同じソースファイルの中のコードによってのみアクセスされることができるのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed only by code within the declaration’s immediate enclosing scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この修飾子を宣言に適用して、その宣言がアクセスされることは、宣言が直に囲んでいるスコープ内のコードによってのみ可能なのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this modifier to a designated or convenience initializer of a class to indicate that every subclass must implement that initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この修飾子をクラスの必須または便宜イニシャライザに適用して、全てのサブクラスがそのイニシャライザを実装しなければならないことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this modifier to a protocol’s property, method, or subscript members to indicate that a conforming type isn’t required to implement those members.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この修飾子をプロトコルのプロパティ、メソッド、または添え字メンバーに適用して、ある準拠型がそれらのメンバーを実装する必要がないことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this modifier to a stored variable or stored variable property to indicate that the variable or property has a weak reference to the object stored as its value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この修飾子を保存変数または保存変数プロパティに適用して、その変数またはプロパティがそれの値として格納されるオブジェクトに対して弱い参照を持つことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this modifier to a stored variable property of a class or structure to indicate that the property’s initial value is calculated and stored at most once, when the property is first accessed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この修飾子をクラスまたは構造体の保存変数プロパティに適用して、そのプロパティの初期値が最大でも一度だけ、そのプロパティが最初にアクセスされるときに、計算または格納されることを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this modifier to a stored variable, constant, or stored property to indicate that the variable or property has an unowned reference to the object stored as its value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この修飾子を保存変数、定数、または保存プロパティに適用して、その変数またはプロパティがそれの値として格納されるオブジェクトに対して非所有参照を持つことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Apply this modifier to any member of a class that can be represented by Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この修飾子をObjective-Cによって表わされることのできるクラスのあらゆるメンバーに適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Applying the <bpt i="0" x="0">&lt;c0&gt;</bpt>IBAction<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>IBOutlet<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>IBDesignable<ept i="2">&lt;/c2&gt;</ept>, or <bpt i="3" x="3">&lt;c3&gt;</bpt>IBInspectable<ept i="3">&lt;/c3&gt;</ept> attribute also implies the <bpt i="4" x="4">&lt;c4&gt;</bpt>objc<ept i="4">&lt;/c4&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>IBAction<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>IBOutlet<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>IBDesignable<ept i="2">&lt;/c2&gt;</ept>、または<bpt i="3" x="3">&lt;c3&gt;</bpt>IBInspectable<ept i="3">&lt;/c3&gt;</ept>を適用することはまた、<bpt i="4" x="4">&lt;c4&gt;</bpt>objc<ept i="4">&lt;/c4&gt;</ept>も適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Applying the <bpt i="3" x="3">&lt;c3&gt;</bpt>objc<ept i="3">&lt;/c3&gt;</ept> attribute when it isn’t needed can increase your binary size and adversely affect performance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが必要とされない時に<bpt i="3" x="3">&lt;c3&gt;</bpt>objc<ept i="3">&lt;/c3&gt;</ept>属性を適用することは、あなたのバイナリサイズを増加させ性能に逆効果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Applying this attribute also implies the <bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性を適用することはまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept>属性も暗に意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Applying this attribute also implies the <bpt i="2" x="2">&lt;c2&gt;</bpt>objc<ept i="2">&lt;/c2&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性を適用することはさらにまた<bpt i="2" x="2">&lt;c2&gt;</bpt>objc<ept i="2">&lt;/c2&gt;</ept>属性も意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Applying this attribute to an extension has the same effect as applying it to every member of that extension that isn’t explicitly marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>nonobjc<ept i="0">&lt;/c0&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性をある拡張に適用することは、その拡張のあらゆるメンバで明示的に<bpt i="0" x="0">&lt;c0&gt;</bpt>nonobjc<ept i="0">&lt;/c0&gt;</ept>属性で印されていないものにそれを適用することと同じ効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Applying this attribute to an extension has the same effect as applying it to every member of that extension that isn’t explicitly marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性をある拡張に適用することは、明示的に<bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept>属性で印されていないその拡張のあらゆるメンバにそれを適用することと同じ効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Argument labels must always be used in an initializer if they are defined, and omitting them is a compile-time error:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数ラベルは、それらが定義されるならば常にイニシャライザで使われなければなりません、そして、それらを省略することはコンパイル時エラーになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Argument names in functions and methods are not part of the corresponding function type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数やメソッドの引数名は、対応する関数型の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Arithmetic Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>算術演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Arithmetic operators (<bpt i="2" x="2">&lt;c2&gt;</bpt>+<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>-<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>*<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>/<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>%<ept i="6">&lt;/c6&gt;</ept> and so forth) detect and disallow value overflow, to avoid unexpected results when working with numbers that become larger or smaller than the allowed value range of the type that stores them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>算術演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>+<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>-<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>*<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>/<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>%<ept i="6">&lt;/c6&gt;</ept>その他）は、値があふれること（オーバフロー）を検知して承認しません、数を扱うときにそれらを保存する型の許容される値の範囲より大きいか小さくなる予想外の結果を防ぐためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Array Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Array Type Shorthand Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列型の短縮形構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Array indices are checked for out-of-bounds errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列インデックスは、境界外エラーを確認される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Arrays</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Arrays are ordered collections of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列は、順番をつけられた値のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Arrays in Swift are always zero-indexed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの配列は、常に０からのインデックスをつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Arrays, sets, and dictionaries in Swift are always clear about the types of values and keys that they can store.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの配列、集合、そして辞書は、それらが保存できる値とキーの型について常に明確です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Array’s existing <bpt i="0" x="0">&lt;c0&gt;</bpt>append(_:)<ept i="0">&lt;/c0&gt;</ept> method and subscript enable Swift to infer the appropriate type to use for <bpt i="1" x="1">&lt;c1&gt;</bpt>Item<ept i="1">&lt;/c1&gt;</ept>, just as for the generic <bpt i="2" x="2">&lt;c2&gt;</bpt>Stack<ept i="2">&lt;/c2&gt;</ept> type above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の既存の<bpt i="0" x="0">&lt;c0&gt;</bpt>append(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドと添え字は、スウィフトに、ちょうど上の総称体<bpt i="2" x="2">&lt;c2&gt;</bpt>Stack<ept i="2">&lt;/c2&gt;</ept>型と同じように、<bpt i="1" x="1">&lt;c1&gt;</bpt>Item<ept i="1">&lt;/c1&gt;</ept>に使うのに適当な型を推論するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a general guideline, consider creating a structure when one or more of these conditions apply:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一般的な指針として、これらの状況のうちの１つ以上があてはまるとき、構造体を作成することを考えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a parameter type or return type in a function, method, or initializer</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数、メソッド、またはイニシャライザにおいてパラメータ型または戻り型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, ARC never sets an unowned reference’s value to <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>, which means that unowned references are defined using nonoptional types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、ARCは決して非所有参照の持つ値を<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>に設定しません、それは非所有参照が非オプショナル型を使って定義されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, a failable initializer can return <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> to indicate that initialization failed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、失敗できるイニシャライザは、そのイニシャライザが失敗したのを指し示すために<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, code is not just easier to write, but easier to read and maintain as well.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、コードは書くのがより簡単なだけでなく、読むことおよび管理するのもまたより簡単です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, if multiple cases contain patterns that evaluate to the same value, and thus can match the value of the control expression, the program executes only the code within the first matching case in source order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その結果、複数のケース節が同じ値に評価される、そしてそれゆえ制御式の値にマッチすることができるパターンを含むならば、プログラムはソース順において最初のマッチしているケース節内のコードだけを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, in many cases you don’t need to specify an explicit access level in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その結果、多くの場合には、あなたはあなたのコードにおいて明示的にアクセス水準を指定する必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, it automatically receives a default initializer, as described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Default Initializers<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>省略時のイニシャライザ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述されるように、それは自動的に省略時のイニシャライザを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, only class types can adopt and conform to a protocol that contains optional member requirements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、クラス型だけがオプショナルメンバー要件を含むプロトコルを採用および準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, the <bpt i="5" x="5">&lt;c5&gt;</bpt>endIndex<ept i="5">&lt;/c5&gt;</ept> property isn’t a valid argument to a string’s subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、<bpt i="5" x="5">&lt;c5&gt;</bpt>endIndex<ept i="5">&lt;/c5&gt;</ept>プロパティは、文字列の添え字として有効な引数ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, the <bpt i="2" x="2">&lt;e2&gt;</bpt>statements<ept i="2">&lt;/e2&gt;</ept> are compiled and executed only if the <bpt i="3" x="3">&lt;e3&gt;</bpt>compilation condition<ept i="3">&lt;/e3&gt;</ept> evaluates to <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept> at compile time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、<bpt i="2" x="2">&lt;e2&gt;</bpt>statements（文）<ept i="2">&lt;/e2&gt;</ept>がコンパイル及び実行されるのは<bpt i="3" x="3">&lt;e3&gt;</bpt>compilation condition<ept i="3">&lt;/e3&gt;</ept>がコンパイル時に<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>に評価される場合に限ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, the number of characters in a string can’t be calculated without iterating through the string to determine its extended grapheme cluster boundaries.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その結果、ある文字列の中の文字の数は、それの拡張書記素クラスタ境界を解決するためにその文字列の最初から終わりまで繰り返していくことなしに計算されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, the value of the <bpt i="3" x="3">&lt;c3&gt;</bpt>customerProvider<ept i="3">&lt;/c3&gt;</ept> argument must be allowed to escape the function’s scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その結果、<bpt i="3" x="3">&lt;c3&gt;</bpt>customerProvider<ept i="3">&lt;/c3&gt;</ept>引数の値は関数のスコープを脱出することを許されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, there’s no need to use whitespace to disambiguate between the closing <bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;<ept i="2">&lt;/c2&gt;</ept> characters in constructs like <bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary&lt;String, Array&lt;Int&gt;&gt;<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その結果、閉じ<bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;<ept i="2">&lt;/c2&gt;</ept>文字の間の曖昧さをなくすために空白を使う必要は、<bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary&lt;String, Array&lt;Int&gt;&gt;<ept i="3">&lt;/c3&gt;</ept>のような構造物においてはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, they are both evaluated before the addition is considered.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、それらは両方とも、加算が考慮される前に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, they have a <bpt i="1" x="1">&lt;c1&gt;</bpt>rawValue<ept i="1">&lt;/c1&gt;</ept> property and a failable initializer with the signature <bpt i="2" x="2">&lt;c2&gt;</bpt>init?(rawValue: RawValue)<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>rawValue<ept i="1">&lt;/c1&gt;</ept>プロパティとシグネチャ<bpt i="2" x="2">&lt;c2&gt;</bpt>init?(rawValue: RawValue)<ept i="2">&lt;/c2&gt;</ept>を持つ失敗できるイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, you can use a nonthrowing function in the same places as a throwing one.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、あなたは非スロー関数をスロー関数と同じ場所で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, you can use conditional compilation blocks like <bpt i="0" x="0">&lt;c0&gt;</bpt>#if swift(&gt;=3.2)<ept i="0">&lt;/c0&gt;</ept> to write code that’s compatible with multiple versions of the Swift compiler.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その結果、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>#if swift(&gt;=3.2)<ept i="0">&lt;/c0&gt;</ept>のような条件コンパイルブロックを使って、複数のバージョンのスウィフトコンパイラと互換性のあるコードを記述できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, you can:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、あなたは次のことが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, you do not write the <bpt i="3" x="3">&lt;c3&gt;</bpt>override<ept i="3">&lt;/c3&gt;</ept> modifier when providing a matching implementation of a superclass convenience initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、あなたはスーパークラスの便宜イニシャライザに一致する実装を提供している時に<bpt i="3" x="3">&lt;c3&gt;</bpt>override<ept i="3">&lt;/c3&gt;</ept>修飾子を書きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, you don’t implement the getter or setter directly in the protocol in which it is declared.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、それが宣言されるプロトコルにおいて、あなたは直接ゲッターまたはセッターを実装しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, you must include at least one statement following the colon (<bpt i="3" x="3">&lt;c3&gt;</bpt>:<ept i="3">&lt;/c3&gt;</ept>) of each case label.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その結果、あなたはそれぞれのケース節ラベルのコロン（<bpt i="3" x="3">&lt;c3&gt;</bpt>:<ept i="3">&lt;/c3&gt;</ept>）に続いている文を少なくとも１つは含めなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, you never need to write an inline closure in its fullest form when the closure is used as a function or method argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その結果、あなたは、行内クロージャをその最も完全な形式で書くことは、そのクロージャが関数やメソッドの引数として使われる時にまったく必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a shortcut to accessing its <bpt i="0" x="0">&lt;c0&gt;</bpt>rooms<ept i="0">&lt;/c0&gt;</ept> array, this version of <bpt i="1" x="1">&lt;c1&gt;</bpt>Residence<ept i="1">&lt;/c1&gt;</ept> provides a read-write subscript that provides access to the room at the requested index in the <bpt i="2" x="2">&lt;c2&gt;</bpt>rooms<ept i="2">&lt;/c2&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その<bpt i="0" x="0">&lt;c0&gt;</bpt>rooms<ept i="0">&lt;/c0&gt;</ept>配列にアクセスすることへの近道として、<bpt i="1" x="1">&lt;c1&gt;</bpt>Residence<ept i="1">&lt;/c1&gt;</ept>のこの版は読み出し専用の添え字を提供します、それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>rooms<ept i="2">&lt;/c2&gt;</ept>配列の中の要求されたインデックスでの部屋へのアクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an alternative to associated values, enumeration cases can come prepopulated with default values (called <bpt i="2" x="2">&lt;e2&gt;</bpt>raw values<ept i="2">&lt;/e2&gt;</ept>), which are all of the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連値に代わるものとして、列挙ケース節は全て同じ型の（<bpt i="2" x="2">&lt;e2&gt;</bpt>生の値<ept i="2">&lt;/e2&gt;</ept>と呼ばれる）初期値があらかじめ入れられた状態であることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an alternative to querying their <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept> properties, each <bpt i="1" x="1">&lt;c1&gt;</bpt>UnicodeScalar<ept i="1">&lt;/c1&gt;</ept> value can also be used to construct a new <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> value, such as with string interpolation:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの<bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>プロパティについて尋ねることに代わるものとして、各<bpt i="1" x="1">&lt;c1&gt;</bpt>UnicodeScalar<ept i="1">&lt;/c1&gt;</ept>値は、また、新しい<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>値を造るために使われることもできます、例えば文字列補間を使って：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an alternative to subscripting, use a dictionary’s <bpt i="0" x="0">&lt;c0&gt;</bpt>updateValue(_:forKey:)<ept i="0">&lt;/c0&gt;</ept> method to set or update the value for a particular key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字指定に代わるものとして、辞書の<bpt i="0" x="0">&lt;c0&gt;</bpt>updateValue(_:forKey:)<ept i="0">&lt;/c0&gt;</ept>メソッドを、特定のキーに対する値を設定したり更新したりするために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an example, Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> type has a <bpt i="1" x="1">&lt;c1&gt;</bpt>map(_:)<ept i="1">&lt;/c1&gt;</ept> method which takes a closure expression as its single argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例として、スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>型は<bpt i="1" x="1">&lt;c1&gt;</bpt>map(_:)<ept i="1">&lt;/c1&gt;</ept>メソッドを持ちます、そしてそれは、そのただ一つの引数としてクロージャ式をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an example, consider the task of reading and processing data from a file on disk.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつの例として、ディスク上のファイルからデータを読み込んで処理する作業を考えてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an example, many functions that start an asynchronous operation take a closure argument as a completion handler.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例として、非同期の演算を開始する多くの関数は、クロージャ引数を完了ハンドラとして取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>+++<ept i="0">&lt;/c0&gt;</ept> operator in <bpt i="1" x="1">&lt;c1&gt;</bpt>a +++b<ept i="1">&lt;/c1&gt;</ept> is treated as a prefix unary operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例として、<bpt i="1" x="1">&lt;c1&gt;</bpt>a +++b<ept i="1">&lt;/c1&gt;</ept>における<bpt i="0" x="0">&lt;c0&gt;</bpt>+++<ept i="0">&lt;/c0&gt;</ept>演算子は、接頭辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>+++<ept i="0">&lt;/c0&gt;</ept> operator in <bpt i="1" x="1">&lt;c1&gt;</bpt>a+++ b<ept i="1">&lt;/c1&gt;</ept> is treated as a postfix unary operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例として、<bpt i="1" x="1">&lt;c1&gt;</bpt>a+++ b<ept i="1">&lt;/c1&gt;</ept>における<bpt i="0" x="0">&lt;c0&gt;</bpt>+++<ept i="0">&lt;/c0&gt;</ept>演算子は、接尾辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>+++<ept i="0">&lt;/c0&gt;</ept> operator in <bpt i="1" x="1">&lt;c1&gt;</bpt>a+++b<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>a +++ b<ept i="2">&lt;/c2&gt;</ept> is treated as a binary operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例として、<bpt i="1" x="1">&lt;c1&gt;</bpt>a+++b<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>a +++ b<ept i="2">&lt;/c2&gt;</ept>における<bpt i="0" x="0">&lt;c0&gt;</bpt>+++<ept i="0">&lt;/c0&gt;</ept>演算子は、二項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an example, the <bpt i="1" x="1">&lt;c1&gt;</bpt>+++<ept i="1">&lt;/c1&gt;</ept> operator in <bpt i="2" x="2">&lt;c2&gt;</bpt>a+++.b<ept i="2">&lt;/c2&gt;</ept> is treated as a postfix unary operator (<bpt i="3" x="3">&lt;c3&gt;</bpt>a+++ .b<ept i="3">&lt;/c3&gt;</ept> rather than <bpt i="4" x="4">&lt;c4&gt;</bpt>a +++ .b<ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例として、<bpt i="2" x="2">&lt;c2&gt;</bpt>a+++.b<ept i="2">&lt;/c2&gt;</ept>における<bpt i="1" x="1">&lt;c1&gt;</bpt>+++<ept i="1">&lt;/c1&gt;</ept>演算子は、接尾辞単項演算子とみなされます（<bpt i="3" x="3">&lt;c3&gt;</bpt>a +++ .b<ept i="3">&lt;/c3&gt;</ept>ではなく<bpt i="4" x="4">&lt;c4&gt;</bpt>a+++ .b<ept i="4">&lt;/c4&gt;</ept>）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an example, the grammar of a getter-setter block is defined as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例として、ゲッターセッター・ブロックの文法は、次のように定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an optimization, Swift may instead capture and store a <bpt i="0" x="0">&lt;e0&gt;</bpt>copy<ept i="0">&lt;/e0&gt;</ept> of a value if that value is not mutated by a closure, and if the value is not mutated after the closure is created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつの最適化として、その値がクロージャによって変化させられないならば、そしてその値がクロージャが作成された後に変化されられないならば、スウィフトはそれよりむしろ値の<bpt i="0" x="0">&lt;e0&gt;</bpt>コピー<ept i="0">&lt;/e0&gt;</ept>をキャプチャして保管するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As an optimization, when the argument is a value stored at a physical address in memory, the same memory location is used both inside and outside the function body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつの最適化として、引数がメモリにおいて物理的番地に保存される値である時、同じメモリ位置は関数本体の内側と外側の両方で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As can be seen above, the getter correctly returns a center point of <bpt i="5" x="5">&lt;c5&gt;</bpt>(5, 5)<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上で見られるように、ゲッターは正しく中心点<bpt i="5" x="5">&lt;c5&gt;</bpt>(5, 5)<ept i="5">&lt;/c5&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As demonstrated in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Optional Chaining as an Alternative to Forced Unwrapping<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, you can use optional chaining to access a property on an optional value, and to check if that property access is successful.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>強制アンラップに代わるものとしてのオプショナル連鎖<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で例示されるように、あなたはオプショナル連鎖を使って、あるオプショナル上でプロパティにアクセスして、そのプロパティへのアクセスが成功したか調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As described above, optionals indicate that a constant or variable is allowed to have “no value”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>先に述べたように、オプショナルは、ある定数や変数が「値がない」状態でも許されることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As described above, the ultimate return type of this method call after optional chaining is also <bpt i="3" x="3">&lt;c3&gt;</bpt>String?<ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>先に述べたように、オプショナル連鎖の後ろのこのメソッド呼び出しの最終的な戻り型は、また、<bpt i="3" x="3">&lt;c3&gt;</bpt>String?<ept i="3">&lt;/c3&gt;</ept>です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Control Flow<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, a <bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept> statement must be exhaustive when considering an enumeration’s cases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>制御の流れ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、<bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept>文は列挙のケース節を考慮するとき、徹底的でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Default Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, Swift automatically provides a <bpt i="2" x="2">&lt;e2&gt;</bpt>default initializer<ept i="2">&lt;/e2&gt;</ept> without any arguments for any structure or base class that provides default values for all of its properties and doesn’t provide at least one initializer itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>省略時のイニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、スウィフトは、全く引数を持たない<bpt i="2" x="2">&lt;e2&gt;</bpt>省略時のイニシャライザ<ept i="2">&lt;/e2&gt;</ept>を、あらゆる構造体または基盤クラスで、それのプロパティの全てに省略時の値を提供して、とにかく１つのイニシャライザもそれ自身では提供しないもののために、自動的に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Failable Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, a special form of the <bpt i="2" x="2">&lt;c2&gt;</bpt>return<ept i="2">&lt;/c2&gt;</ept> statement (<bpt i="3" x="3">&lt;c3&gt;</bpt>return nil<ept i="3">&lt;/c3&gt;</ept>) can be used in a failable initializer to indicate initialization failure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>失敗できるイニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、<bpt i="2" x="2">&lt;c2&gt;</bpt>return<ept i="2">&lt;/c2&gt;</ept>文の特別な形式（<bpt i="3" x="3">&lt;c3&gt;</bpt>return nil<ept i="3">&lt;/c3&gt;</ept>）は、失敗できるイニシャライザの中で使用されて初期化失敗を指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Dictionaries<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>, the type of a dictionary’s keys must be <bpt i="3" x="3">&lt;e3&gt;</bpt>hashable<ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>辞書<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述されるように、辞書のキーの型は、<bpt i="3" x="3">&lt;e3&gt;</bpt>ハッシュ化<ept i="3">&lt;/e3&gt;</ept>できなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As discussed in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Initializer Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, classes can have designated and convenience initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>イニシャライザ宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で議論されるように、クラスは、指定および便宜イニシャライザを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As expected, the counter’s <bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept> property increases by three each time <bpt i="4" x="4">&lt;c4&gt;</bpt>increment()<ept i="4">&lt;/c4&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>予想されるように、counterの<bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept>プロパティは、<bpt i="4" x="4">&lt;c4&gt;</bpt>increment()<ept i="4">&lt;/c4&gt;</ept>が呼ばれるたびに３つずつ増加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As in the previous example, the final case matches all possible remaining values, and so a <bpt i="0" x="0">&lt;c0&gt;</bpt>default<ept i="0">&lt;/c0&gt;</ept> case is not needed to make the <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement exhaustive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前の例の場合のように、最後のケース節は全てのあり得る残りの値に適合します、そして<bpt i="0" x="0">&lt;c0&gt;</bpt>default<ept i="0">&lt;/c0&gt;</ept>ケース節はこの<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文を徹底的なものにするのに必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As in this example, careful choice of Boolean constant and variable names can help to keep code readable and concise, while avoiding double negatives or confusing logic statements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例の場合のように、ブールの定数と変数の名前の慎重な選択はコードを読みやすく簡潔にしておくのを助けることができます、その一方で、二重の否定や、混乱させる論理文を避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As its name suggests, the <bpt i="2" x="2">&lt;c2&gt;</bpt>toggle()<ept i="2">&lt;/c2&gt;</ept> method is intended to toggle or invert the state of any conforming type, typically by modifying a property of that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その名前が暗示するように、<bpt i="2" x="2">&lt;c2&gt;</bpt>toggle()<ept i="2">&lt;/c2&gt;</ept>メソッドはあらゆる準拠型の状態を切り換えるか逆にすることを意図します、概してその型のプロパティの修正によって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As mentioned above, different characters can require different amounts of memory to store, so in order to determine which <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> is at a particular position, you must iterate over each Unicode scalar from the start or end of that <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上で述べたように、異なる文字は格納するのに異なるメモリ量を必要とすることがあり得ます、それで<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>がある特定の位置にあることを確定するために、あなたはその<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>の始まりまたは終わりからユニコードスカラーそれぞれにわたってずっと繰り返さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As mentioned above, subclasses do not inherit their superclass initializers by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上で述べたように、サブクラスは何もしなければそれらのスーパークラスのイニシャライザを継承しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As mentioned above, substrings aren’t suitable for long-term storage—because they reuse the storage of the original string, the entire original string must be kept in memory as long as any of its substrings are being used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上で言及したように、下位文字列は長期保管に適していません — それらがオリジナルの文字列のストレージを再利用することから、オリジナルの文字列全体はそれの下位文字列が使われている限りメモリに保存されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As mentioned above, the <bpt i="0" x="0">&lt;c0&gt;</bpt>Rank<ept i="0">&lt;/c0&gt;</ept> enumeration defines a further nested structure of its own, called <bpt i="1" x="1">&lt;c1&gt;</bpt>Values<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上で言及されるように、<bpt i="0" x="0">&lt;c0&gt;</bpt>Rank<ept i="0">&lt;/c0&gt;</ept>列挙は独自の更なる入れ子にされた構造体を定義します、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>Values<ept i="1">&lt;/c1&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As mentioned above, the memory for an object is only considered fully initialized once the initial state of all of its stored properties is known.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上で言及したように、いったんその保存プロパティの全ての最初の状態が知られる場合にのみ、あるオブジェクトに対するメモリが充分に初期化されたとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As mentioned in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Generic Parameter Clause<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, you don’t use a generic argument clause to specify the type arguments of a generic function or initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>総称体パラメータ節<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で言及されるように、あなたは、総称体の関数やイニシャライザの型引数を指定するために総称体引数節を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As soon as all properties of the superclass have an initial value, its memory is considered fully initialized, and Phase 1 is complete.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラスの全てのプロパティが初期値を持つとすぐに、そのメモリが充分に初期化されてすると考慮されます、そして第１段階は完了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As soon as the <bpt i="4" x="4">&lt;c4&gt;</bpt>default<ept i="4">&lt;/c4&gt;</ept> case is matched, the <bpt i="5" x="5">&lt;c5&gt;</bpt>break<ept i="5">&lt;/c5&gt;</ept> statement ends the <bpt i="6" x="6">&lt;c6&gt;</bpt>switch<ept i="6">&lt;/c6&gt;</ept> statement’s execution, and code execution continues from the <bpt i="7" x="7">&lt;c7&gt;</bpt>if let<ept i="7">&lt;/c7&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>default<ept i="4">&lt;/c4&gt;</ept>ケース節が適合したならすぐに、<bpt i="5" x="5">&lt;c5&gt;</bpt>break<ept i="5">&lt;/c5&gt;</ept>文が<bpt i="6" x="6">&lt;c6&gt;</bpt>switch<ept i="6">&lt;/c6&gt;</ept>文の実行を終えます、そしてコード実行は<bpt i="7" x="7">&lt;c7&gt;</bpt>if let<ept i="7">&lt;/c7&gt;</ept>文から続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As such, <bpt i="1" x="1">&lt;c1&gt;</bpt>index<ept i="1">&lt;/c1&gt;</ept> does not have to be declared before it is used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このように、<bpt i="1" x="1">&lt;c1&gt;</bpt>index<ept i="1">&lt;/c1&gt;</ept>は、それが使われる前に宣言される必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As such, the performance characteristics of a <bpt i="3" x="3">&lt;c3&gt;</bpt>throw<ept i="3">&lt;/c3&gt;</ept> statement are comparable to those of a <bpt i="4" x="4">&lt;c4&gt;</bpt>return<ept i="4">&lt;/c4&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>throw<ept i="3">&lt;/c3&gt;</ept>文のいろいろな性能特徴は、それ自体としては、<bpt i="4" x="4">&lt;c4&gt;</bpt>return<ept i="4">&lt;/c4&gt;</ept>文のそれと同程度です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As the above example shows, patterns in a case can also bind constants using the <bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept> keyword (they can also bind variables using the <bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept> keyword).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で示されるように、あるケース節中のいくつかのパターンはまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept>キーワードを使って定数に束縛できます（それらはまた<bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept>キーワードを使って変数に束縛もできます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As the type of a constant, variable, or property</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数、変数、またはプロパティの型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As the type of items in an array, dictionary, or other container</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列、辞書、または他のコンテナ中の項目の型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As their names suggest, the value of a stored variable or a stored variable property is stored in memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの名前が示すように、保存変数または保存変数プロパティの値はメモリに保存されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept> above, you don’t need to declare constants or variables as <bpt i="5" x="5">&lt;c5&gt;</bpt>Bool<ept i="5">&lt;/c5&gt;</ept> if you set them to <bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept> or <bpt i="7" x="7">&lt;c7&gt;</bpt>false<ept i="7">&lt;/c7&gt;</ept> as soon as you create them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept>と同様に、あなたがそれらを作成するやいなや<bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept>または<bpt i="7" x="7">&lt;c7&gt;</bpt>false<ept i="7">&lt;/c7&gt;</ept>に設定するならば、あなたは定数または変数を<bpt i="5" x="5">&lt;c5&gt;</bpt>Bool<ept i="5">&lt;/c5&gt;</ept>として宣言する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with all unsafe operations, you take on the responsiblity for checking that code for safety.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての安全でない操作と同様に、あなたは安全性のためにそのコードを検査する責任があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with an array, you find out the number of items in a <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> by checking its read-only <bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept> property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列と同様に、あなたはある<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>の中の項目の数を、それの読み出し専用の<bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept>プロパティを調べることによって突き止めます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with an overridden property, method or subscript, the presence of the <bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept> modifier prompts Swift to check that the superclass has a matching designated initializer to be overridden, and validates that the parameters for your overriding initializer have been specified as intended.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバーライドされるプロパティ、メソッドや添え字を書く時と同様に、<bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept>修飾子の存在はスウィフトにスーパークラスが一致している、オーバーライドされる指定イニシャライザを持つのを確認すること、そしてあなたがオーバーライドするイニシャライザのパラメータが意図されるように指定されてしまっているのを検証することを促します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with any other type, you can leave it to Swift to infer the function type when you assign a function to a constant or variable:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆる他の型と同様に、あなたが関数を定数または変数に代入するとき、あなたはスウィフトに関数型を推論するように任せることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with arrays, you can create an empty <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> of a certain type by using initializer syntax:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列と同様に、あなたは、特定の型の空の<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>を作成することが、イニシャライザ構文を使うことで行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with arrays, you don’t have to write the type of the dictionary if you’re initializing it with a dictionary literal whose keys and values have consistent types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列と同様に、キーと値が首尾一貫した型をもつ辞書リテラルでそれを初期化しているならば、あなたは辞書の型を書く必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with computed properties, subscript declarations support reading and writing the value of the accessed elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算プロパティと同様に、添え字宣言はアクセスされた要素の値を読み書きすることをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with computed properties, you can choose not to specify the setter’s <bpt i="1" x="1">&lt;c1&gt;</bpt>(newValue)<ept i="1">&lt;/c1&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算プロパティと同様に、あなたはセッターの<bpt i="1" x="1">&lt;c1&gt;</bpt>(newValue)<ept i="1">&lt;/c1&gt;</ept>パラメータを指定しないほうを選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with constant declarations, if the <bpt i="0" x="0">&lt;e0&gt;</bpt>variable name<ept i="0">&lt;/e0&gt;</ept> is a tuple pattern, the name of each item in the tuple is bound to the corresponding value in the initializer <bpt i="1" x="1">&lt;e1&gt;</bpt>expression<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数宣言と同様に、<bpt i="0" x="0">&lt;e0&gt;</bpt>変数名<ept i="0">&lt;/e0&gt;</ept>がタプルパターンであるならば、タプルの中の各項目の名前はイニシャライザ<bpt i="1" x="1">&lt;e1&gt;</bpt>式<ept i="1">&lt;/e1&gt;</ept>の対応する値に縛りつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with function and method parameters, initialization parameters can have both a parameter name for use within the initializer’s body and an argument label for use when calling the initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数とメソッドのパラメータと同様に、初期化パラメータは、イニシャライザの本文内で使用するためのパラメータ名とイニシャライザを呼ぶ時に使用するための引数ラベルの両方を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with function and method parameters, the types of an initializer’s parameters can’t be more private than the initializer’s own access level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数やメソッドパラメータと同様に、イニシャライザのパラメーターの型は、そのイニシャライザ自身のアクセス水準よりも非公開にすることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with methods, properties, and subscripts, you need to mark overridden designated initializers with the <bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッド、プロパティ、そして添え字と同様に、あなたはオーバーライドした指定イニシャライザを<bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept>宣言修飾子で印する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with optionals, if you don’t provide an initial value when you declare an implicitly unwrapped optional variable or property, its value automatically defaults to <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルと同様に、あなたが暗黙的にアンラップされるオプショナルの変数やプロパティに初期値を提供しないならば、その値は自動的に省略時の<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with other examples of type safety in Swift, this approach avoids accidental errors and ensures that the intention of a particular section of code is always clear.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおける型安全に関する他の例と同様に、このやり方は、偶然のエラーを避けること、そしてコードの特定の節の意図を常にはっきりさせることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with other protocol member declarations, these property declarations declare only the getter and setter requirements for types that conform to the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他のプロトコルメンバー宣言と同様に、これらのプロパティ宣言はそのプロトコルに準拠する型のためのゲッターとセッター要件だけを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with prefix operators, postfix operator declarations don’t specify a precedence level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接頭辞演算子と同様に、接尾辞演算子宣言は、優先順位レベルを指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with read-only computed properties, you can simplify the declaration of a read-only subscript by removing the <bpt i="0" x="0">&lt;c0&gt;</bpt>get<ept i="0">&lt;/c0&gt;</ept> keyword and its braces:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>読み出し専用の計算プロパティでのように、あなたは読み出し専用の添え字の宣言を単純化することが、<bpt i="0" x="0">&lt;c0&gt;</bpt>get<ept i="0">&lt;/c0&gt;</ept>キーワードとそれの波括弧を取り除くことによって行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with strong reference cycles between two class instances, you declare each captured reference to be a weak or unowned reference rather than a strong reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのクラスインスタンスの間の強い参照循環と同様に、あなたは各捕らえられた参照が強い参照というよりは弱いまたは非所有者参照であると宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with the closed range operator, the value of <bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept> must not be greater than <bpt i="7" x="7">&lt;c7&gt;</bpt>b<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>完結範囲演算子と同じように、<bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept>の値は<bpt i="7" x="7">&lt;c7&gt;</bpt>b<ept i="7">&lt;/c7&gt;</ept>より大きくてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with the default initializer above, if you want a public structure type to be initializable with a memberwise initializer when used in another module, you must provide a public memberwise initializer yourself as part of the type’s definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上記の省略時のイニシャライザと同様に、あなたがある公開の構造体型を別のモジュール内で使うときにメンバー関連イニシャライザを使って初期化できるようにしたいならば、あなたは公開のメンバー関連イニシャライザをあなた自身でその型定義の一部として提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As with type property requirements, you always prefix type method requirements with the <bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept> keyword when they’re defined in a protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型プロパティ要件と同様に、あなたは常に型メソッド要件の前に、それらがプロトコルにおいて定義されるとき、<bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept>キーワードを置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As you consider the data constructs and functionality that you need for a project, decide whether each data construct should be defined as a class or as a structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがプロジェクトのために必要とするデータ構造と機能性を考慮するので、各データ構造物がクラスとしてまたは構造体として定義されなければならないか決めてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assertions and Preconditions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>表明と前提条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assertions help you find mistakes and incorrect assumptions during development, and preconditions help you detect issues in production.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>表明は、あなたが失策や間違った想定を見つけるのを開発中に助けます、そして前提条件は、あなたが製品における問題点を見抜くのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assigning Constant Properties During Initialization</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化の間に定数プロパティを割り当てる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assigning to self Within a Mutating Method</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変メソッド内部でselfに代入する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assignment Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代入演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assignment and Copy Behavior for Strings, Arrays, and Dictionaries</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列、配列、そして辞書のための代入とコピー挙動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assignment is performed from each part of the <bpt i="4" x="4">&lt;e4&gt;</bpt>value<ept i="4">&lt;/e4&gt;</ept> to the corresponding part of the <bpt i="5" x="5">&lt;e5&gt;</bpt>expression<ept i="5">&lt;/e5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代入は、<bpt i="4" x="4">&lt;e4&gt;</bpt>値<ept i="4">&lt;/e4&gt;</ept>の各部分から<bpt i="5" x="5">&lt;e5&gt;</bpt>式<ept i="5">&lt;/e5&gt;</ept>の対応する部分へと実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Associated Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Associated Types in Action</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連型の動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Associated Types with a Generic Where Clause</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体where節を持つ関連型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Associated Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Associated types are similar to type parameters in generic parameter clauses, but they’re associated with <bpt i="1" x="1">&lt;c1&gt;</bpt>Self<ept i="1">&lt;/c1&gt;</ept> in the protocol in which they’re declared.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連型は、総称体パラメータ節の中の型パラメータに似ています、しかしそれらは、それらが宣言されるプロトコルにおいて<bpt i="1" x="1">&lt;c1&gt;</bpt>Self<ept i="1">&lt;/c1&gt;</ept>と結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Associated types are specified with the <bpt i="1" x="1">&lt;c1&gt;</bpt>associatedtype<ept i="1">&lt;/c1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>associatedtype<ept i="1">&lt;/c1&gt;</ept>キーワードで指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Associated values are set when you create a new constant or variable based on one of the enumeration’s cases, and can be different each time you do so.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連値は、あなたが列挙のケース節のうちの１つに基づいて新しい定数または変数を作るときに設定されます、そしてあなたがそうするたびに違ったものにすることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Assuming that you provide default values for any new properties you introduce in a subclass, the following two rules apply:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが省略時の値をあなたがサブクラスで導入するあらゆる新しいプロパティに用意すると仮定して、以下の２つの規則が適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At compile time, the key-path expression is replaced by a <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>KeyPath<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイル時で、キー値式は<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>KeyPath<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>値によって置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At compile time, the key-path string expression is replaced by a string literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイル時で、キーパス文字列式は文字列リテラルによって置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At parse time, an expression made up of binary operators is represented as a flat list.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構文解析の時、二項演算子から成り立つ式は、平坦なリストとして表わされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At runtime, if the cast succeeds, the value of <bpt i="5" x="5">&lt;e5&gt;</bpt>expression<ept i="5">&lt;/e5&gt;</ept> is wrapped in an optional and returned; otherwise, the value returned is <bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実行時に、キャストが成功したならば、<bpt i="5" x="5">&lt;e5&gt;</bpt>式<ept i="5">&lt;/e5&gt;</ept>の値がひとつのオプショナルの中にラップされて返されます；そうでなければ返される値は<bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At the end of the <bpt i="7" x="7">&lt;c7&gt;</bpt>for<ept i="7">&lt;/c7&gt;</ept>-<bpt i="8" x="8">&lt;c8&gt;</bpt>in<ept i="8">&lt;/c8&gt;</ept> loop, the values of <bpt i="9" x="9">&lt;c9&gt;</bpt>movieCount<ept i="9">&lt;/c9&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt>songCount<ept i="10">&lt;/c10&gt;</ept> contain a count of how many <bpt i="11" x="11">&lt;c11&gt;</bpt>MediaItem<ept i="11">&lt;/c11&gt;</ept> instances were found of each type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt>for<ept i="7">&lt;/c7&gt;</ept>-<bpt i="8" x="8">&lt;c8&gt;</bpt>in<ept i="8">&lt;/c8&gt;</ept>ループの終わりに、<bpt i="9" x="9">&lt;c9&gt;</bpt>movieCount<ept i="9">&lt;/c9&gt;</ept>と<bpt i="10" x="10">&lt;c10&gt;</bpt>songCount<ept i="10">&lt;/c10&gt;</ept>の値は、各型の<bpt i="11" x="11">&lt;c11&gt;</bpt>MediaItem<ept i="11">&lt;/c11&gt;</ept>インスタンスがどれくらい見つけられたかの総数を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At the start of the game, the player is on “square zero”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゲームの開始時点で、プレーヤーは−「正方形ゼロ」の上にいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At this point, the original <bpt i="0" x="0">&lt;c0&gt;</bpt>Barcode.upc<ept i="0">&lt;/c0&gt;</ept> and its integer values are replaced by the new <bpt i="1" x="1">&lt;c1&gt;</bpt>Barcode.qrCode<ept i="1">&lt;/c1&gt;</ept> and its string value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この点で、最初の<bpt i="0" x="0">&lt;c0&gt;</bpt>Barcode.upc<ept i="0">&lt;/c0&gt;</ept>およびその整数値は、新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>Barcode.qrCode<ept i="1">&lt;/c1&gt;</ept>およびその文字列値と取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Attempting to access an index outside of a string’s range or a <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> at an index outside of a string’s range will trigger a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列の範囲外のインデックスにまたはある文字列の範囲外のインデックスで<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>にアクセスを試みることは、実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Attempting to do so is reported as an error when your code is compiled:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうしようとすることは、あなたのコードがコンパイルされる時にエラーとして報告されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Attempting to do so results in a compile-time error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうしようとすることは、それでコンパイル時エラーという結果となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Attributes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Autoclosures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自動クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Automatic Initializer Inheritance</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自動的なイニシャライザ継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Automatic Reference Counting</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自動参照カウント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Availability Condition</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>有効性条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Avoid combining multiple instances of the ternary conditional operator into one compound statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>三項条件演算子を使用したもの複数を１つの複合文に結合することを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Avoiding default fallthrough means that Swift <bpt i="4" x="4">&lt;c4&gt;</bpt>switch<ept i="4">&lt;/c4&gt;</ept> statements are much more concise and predictable than their counterparts in C, and thus they avoid executing multiple <bpt i="5" x="5">&lt;c5&gt;</bpt>switch<ept i="5">&lt;/c5&gt;</ept> cases by mistake.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何もしなくても抜け落ちることを避けることは、スウィフトの<bpt i="4" x="4">&lt;c4&gt;</bpt>switch<ept i="4">&lt;/c4&gt;</ept>文がCでのそれに対応する物よりずっと簡潔で予測できること、そしてそれゆえに、それは誤って複数の<bpt i="5" x="5">&lt;c5&gt;</bpt>switch<ept i="5">&lt;/c5&gt;</ept>ケース節を実行することを回避することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Backslash (<bpt i="0" x="0">&lt;c0&gt;</bpt>\\<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バックスラッシュ（<bpt i="0" x="0">&lt;c0&gt;</bpt>\\<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Based on the values of <bpt i="0" x="0">&lt;c0&gt;</bpt>enteredDoorCode<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>passedRetinaScan<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>hasDoorKey<ept i="2">&lt;/c2&gt;</ept>, the first two subexpressions are <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>enteredDoorCode<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>passedRetinaScan<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>hasDoorKey<ept i="2">&lt;/c2&gt;</ept>の値に基づいて、最初の２つの下位の式は<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Basic Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基本の演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be careful to ensure that operator interactions still behave in the way you intend when porting existing code to Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>既存のコードをスウィフトに移植するとき、依然としてあなたが意図するやり方で演算子相互作用が振る舞うことを確実にするように注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be extended to expand their functionality beyond a default implementation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの機能性を元の実装を越えて広げるために、拡張されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Be warned, though—this function doesn’t compile, for reasons explained after the example:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>注意するように、とは言うものの ― この関数はコンパイルしません、この例の後に説明される理由のために：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept> is less than <bpt i="1" x="1">&lt;c1&gt;</bpt>2<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>(1, "zebra")<ept i="2">&lt;/c2&gt;</ept> is considered less than <bpt i="3" x="3">&lt;c3&gt;</bpt>(2, "apple")<ept i="3">&lt;/c3&gt;</ept>, regardless of any other values in the tuples.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>2<ept i="1">&lt;/c1&gt;</ept>より少ないことから、<bpt i="2" x="2">&lt;c2&gt;</bpt>(1, "zebra")<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>(2, "apple")<ept i="3">&lt;/c3&gt;</ept>より少ないとみなされます、タプルの中のあらゆる他の値に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept> and the array’s elements conform to the <bpt i="2" x="2">&lt;c2&gt;</bpt>TextRepresentable<ept i="2">&lt;/c2&gt;</ept> protocol, the array can use the <bpt i="3" x="3">&lt;c3&gt;</bpt>textualDescription<ept i="3">&lt;/c3&gt;</ept> property to get a textual representation of its contents:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>に準拠して配列要素が<bpt i="2" x="2">&lt;c2&gt;</bpt>TextRepresentable<ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠することから、この配列は<bpt i="3" x="3">&lt;c3&gt;</bpt>textualDescription<ept i="3">&lt;/c3&gt;</ept>プロパティを使ってそれの内容のテキスト表現を取得することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt>BlackjackCard<ept i="0">&lt;/c0&gt;</ept> is a structure with no custom initializers, it has an implicit memberwise initializer, as described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Memberwise Initializers for Structure Types<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>BlackjackCard<ept i="0">&lt;/c0&gt;</ept>があつらえのイニシャライザのない構造体であるので、構造型のための<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>メンバー関連イニシャライザ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述されるように、それは暗黙のメンバー関連イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>, for example, both conform to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Comparable<ept i="2">&lt;/c2&gt;</ept> protocol, this function accepts arguments of either type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>は両方とも<bpt i="2" x="2">&lt;c2&gt;</bpt>Comparable<ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠するので、この関数はどちらの型の引数でも受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt>capitalCity<ept i="0">&lt;/c0&gt;</ept> has a default <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> value, a new <bpt i="2" x="2">&lt;c2&gt;</bpt>Country<ept i="2">&lt;/c2&gt;</ept> instance is considered fully initialized as soon as the <bpt i="3" x="3">&lt;c3&gt;</bpt>Country<ept i="3">&lt;/c3&gt;</ept> instance sets its <bpt i="4" x="4">&lt;c4&gt;</bpt>name<ept i="4">&lt;/c4&gt;</ept> property within its initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>capitalCity<ept i="0">&lt;/c0&gt;</ept>が省略時の<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>値を持つので、新しい<bpt i="2" x="2">&lt;c2&gt;</bpt>Country<ept i="2">&lt;/c2&gt;</ept>インスタンスは、<bpt i="3" x="3">&lt;c3&gt;</bpt>Country<ept i="3">&lt;/c3&gt;</ept>インスタンスがそのイニシャライザ内でその<bpt i="4" x="4">&lt;c4&gt;</bpt>name<ept i="4">&lt;/c4&gt;</ept>プロパティを設定するとすぐに、完全に初期化されると見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt>john.residence<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>, this optional chaining call fails in the same way as before.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>john.residence<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>であるため、このオプショナル連鎖呼び出しは前と同じやり方で失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt>playerOne<ept i="0">&lt;/c0&gt;</ept> is an optional, it is qualified with an exclamation mark (<bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>) when its <bpt i="2" x="2">&lt;c2&gt;</bpt>coinsInPurse<ept i="2">&lt;/c2&gt;</ept> property is accessed to print its default number of coins, and whenever its <bpt i="3" x="3">&lt;c3&gt;</bpt>win(coins:)<ept i="3">&lt;/c3&gt;</ept> method is called:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>playerOne<ept i="0">&lt;/c0&gt;</ept>がオプショナルであることから、それは感嘆符（<bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>）で修飾されます、それのもつ<bpt i="2" x="2">&lt;c2&gt;</bpt>coinsInPurse<ept i="2">&lt;/c2&gt;</ept>プロパティがその省略時のコイン数を出力するためにアクセスされる時に、そして何時でもそれの<bpt i="3" x="3">&lt;c3&gt;</bpt>win(coins:)<ept i="3">&lt;/c3&gt;</ept>メソッドが呼ばれる時に：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt>rangeOfFourItems<ept i="0">&lt;/c0&gt;</ept> is declared as a constant (with the <bpt i="1" x="1">&lt;c1&gt;</bpt>let<ept i="1">&lt;/c1&gt;</ept> keyword), it is not possible to change its <bpt i="2" x="2">&lt;c2&gt;</bpt>firstValue<ept i="2">&lt;/c2&gt;</ept> property, even though <bpt i="3" x="3">&lt;c3&gt;</bpt>firstValue<ept i="3">&lt;/c3&gt;</ept> is a variable property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rangeOfFourItems<ept i="0">&lt;/c0&gt;</ept>が定数（<bpt i="1" x="1">&lt;c1&gt;</bpt>let<ept i="1">&lt;/c1&gt;</ept>キーワードを使って）として宣言されるので、たとえ<bpt i="2" x="2">&lt;c2&gt;</bpt>firstValue<ept i="2">&lt;/c2&gt;</ept>が変数プロパティであるとしても、その<bpt i="3" x="3">&lt;c3&gt;</bpt>firstValue<ept i="3">&lt;/c3&gt;</ept>プロパティを変えることは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept> is a type alias for <bpt i="2" x="2">&lt;c2&gt;</bpt>()<ept i="2">&lt;/c2&gt;</ept>, you can use it to write an empty tuple type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>()<ept i="2">&lt;/c2&gt;</ept>に対する型エイリアスであることから、あなたはそれを使って空のタプル型を書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="1" x="1">&lt;c1&gt;</bpt>beginning<ept i="1">&lt;/c1&gt;</ept> is a substring of <bpt i="2" x="2">&lt;c2&gt;</bpt>greeting<ept i="2">&lt;/c2&gt;</ept>, it reuses the memory that <bpt i="3" x="3">&lt;c3&gt;</bpt>greeting<ept i="3">&lt;/c3&gt;</ept> uses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>beginning<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>greeting<ept i="2">&lt;/c2&gt;</ept>の下位文字列であることから、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>greeting<ept i="3">&lt;/c3&gt;</ept>が使うメモリを再利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="1" x="1">&lt;c1&gt;</bpt>makeASandwich()<ept i="1">&lt;/c1&gt;</ept> can throw an error, the function call is wrapped in a <bpt i="2" x="2">&lt;c2&gt;</bpt>try<ept i="2">&lt;/c2&gt;</ept> expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>makeASandwich()<ept i="1">&lt;/c1&gt;</ept>はエラーをスロー可能なので、この関数呼び出しは<bpt i="2" x="2">&lt;c2&gt;</bpt>try<ept i="2">&lt;/c2&gt;</ept>式で包まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="2" x="2">&lt;c2&gt;</bpt>Resolution<ept i="2">&lt;/c2&gt;</ept> is a structure, a <bpt i="3" x="3">&lt;e3&gt;</bpt>copy<ept i="3">&lt;/e3&gt;</ept> of the existing instance is made, and this new copy is assigned to <bpt i="4" x="4">&lt;c4&gt;</bpt>cinema<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Resolution<ept i="2">&lt;/c2&gt;</ept>が構造体であるので、既存のインスタンスの<bpt i="3" x="3">&lt;e3&gt;</bpt>コピー<ept i="3">&lt;/e3&gt;</ept>が作成されます、そして、この新しいコピーは<bpt i="4" x="4">&lt;c4&gt;</bpt>cinema<ept i="4">&lt;/c4&gt;</ept>に代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="2" x="2">&lt;c2&gt;</bpt>item<ept i="2">&lt;/c2&gt;</ept> is a <bpt i="3" x="3">&lt;c3&gt;</bpt>MediaItem<ept i="3">&lt;/c3&gt;</ept> instance, it’s possible that it <bpt i="4" x="4">&lt;e4&gt;</bpt>might<ept i="4">&lt;/e4&gt;</ept> be a <bpt i="5" x="5">&lt;c5&gt;</bpt>Movie<ept i="5">&lt;/c5&gt;</ept>; equally, it’s also possible that it might be a <bpt i="6" x="6">&lt;c6&gt;</bpt>Song<ept i="6">&lt;/c6&gt;</ept>, or even just a base <bpt i="7" x="7">&lt;c7&gt;</bpt>MediaItem<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>item<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>MediaItem<ept i="3">&lt;/c3&gt;</ept>インスタンスであるので、それが<bpt i="5" x="5">&lt;c5&gt;</bpt>Movie<ept i="5">&lt;/c5&gt;</ept>である<bpt i="4" x="4">&lt;e4&gt;</bpt>かもしれない<ept i="4">&lt;/e4&gt;</ept>可能性があります；等しく、それが<bpt i="6" x="6">&lt;c6&gt;</bpt>Song<ept i="6">&lt;/c6&gt;</ept>かもしれない可能性もまたあります、または単に基盤<bpt i="7" x="7">&lt;c7&gt;</bpt>MediaItem<ept i="7">&lt;/c7&gt;</ept>であることさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="3" x="3">&lt;c3&gt;</bpt>AutomaticallyNamedDocument<ept i="3">&lt;/c3&gt;</ept> copes with the empty string case in a different way than its superclass, its initializer does not need to fail, and so it provides a nonfailable version of the initializer instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>AutomaticallyNamedDocument<ept i="3">&lt;/c3&gt;</ept>が空の文字列の場合をそれのスーパークラスと異なるやり方でうまく処理するので、それのイニシャライザは失敗する必要はありません、それでそれはそうせずに、失敗できない改作のイニシャライザを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="3" x="3">&lt;c3&gt;</bpt>IntStack<ept i="3">&lt;/c3&gt;</ept> conforms to all of the requirements of the <bpt i="4" x="4">&lt;c4&gt;</bpt>Container<ept i="4">&lt;/c4&gt;</ept> protocol, Swift can infer the appropriate <bpt i="5" x="5">&lt;c5&gt;</bpt>Item<ept i="5">&lt;/c5&gt;</ept> to use, simply by looking at the type of the <bpt i="6" x="6">&lt;c6&gt;</bpt>append(_:)<ept i="6">&lt;/c6&gt;</ept> method’s <bpt i="7" x="7">&lt;c7&gt;</bpt>item<ept i="7">&lt;/c7&gt;</ept> parameter and the return type of the subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>IntStack<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>Container<ept i="4">&lt;/c4&gt;</ept>プロトコルの要件の全てに準拠するので、スウィフトは、単に<bpt i="6" x="6">&lt;c6&gt;</bpt>append(_:)<ept i="6">&lt;/c6&gt;</ept>メソッドの<bpt i="7" x="7">&lt;c7&gt;</bpt>item<ept i="7">&lt;/c7&gt;</ept>パラメータの型、そして、添え字の戻り型を見ることによって、使用するのに適切な<bpt i="5" x="5">&lt;c5&gt;</bpt>item<ept i="5">&lt;/c5&gt;</ept>を推論することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="3" x="3">&lt;c3&gt;</bpt>Person<ept i="3">&lt;/c3&gt;</ept> conforms to both protocols, this call is valid, and the <bpt i="4" x="4">&lt;c4&gt;</bpt>wishHappyBirthday(to:)<ept i="4">&lt;/c4&gt;</ept> function can print its birthday greeting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>Person<ept i="3">&lt;/c3&gt;</ept>が両方のプロトコルに準拠するので、これは有効な呼び出しです、それで<bpt i="4" x="4">&lt;c4&gt;</bpt>wishHappyBirthday(to:)<ept i="4">&lt;/c4&gt;</ept>関数はその誕生日のお祝いを出力できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="3" x="3">&lt;c3&gt;</bpt>anotherPoint<ept i="3">&lt;/c3&gt;</ept> is always a tuple of two values, this case matches all possible remaining values, and a <bpt i="4" x="4">&lt;c4&gt;</bpt>default<ept i="4">&lt;/c4&gt;</ept> case is not needed to make the <bpt i="5" x="5">&lt;c5&gt;</bpt>switch<ept i="5">&lt;/c5&gt;</ept> statement exhaustive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>anotherPoint<ept i="3">&lt;/c3&gt;</ept>が常に２つの値のタプルであることから、このケース節は全てのあり得る残りの値にマッチします、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>default<ept i="4">&lt;/c4&gt;</ept>ケース節はこの<bpt i="5" x="5">&lt;c5&gt;</bpt>switch<ept i="5">&lt;/c5&gt;</ept>文を余すところのないものにするのに必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="3" x="3">&lt;c3&gt;</bpt>game<ept i="3">&lt;/c3&gt;</ept> is known to conform to the <bpt i="4" x="4">&lt;c4&gt;</bpt>DiceGame<ept i="4">&lt;/c4&gt;</ept> protocol, it’s guaranteed to have a <bpt i="5" x="5">&lt;c5&gt;</bpt>dice<ept i="5">&lt;/c5&gt;</ept> property, and so the <bpt i="6" x="6">&lt;c6&gt;</bpt>gameDidStart(_:)<ept i="6">&lt;/c6&gt;</ept> method is able to access and print the dice’s <bpt i="7" x="7">&lt;c7&gt;</bpt>sides<ept i="7">&lt;/c7&gt;</ept> property, regardless of what kind of game is being played.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>game<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>DiceGame<ept i="4">&lt;/c4&gt;</ept>プロトコルに従うと知られているので、それは<bpt i="5" x="5">&lt;c5&gt;</bpt>dice<ept i="5">&lt;/c5&gt;</ept>プロパティを持つと保証されます、なので、<bpt i="6" x="6">&lt;c6&gt;</bpt>gameDidStart(_:)<ept i="6">&lt;/c6&gt;</ept>メソッドは、どんな種類のゲームがプレイされているかに関係なく、diceの<bpt i="7" x="7">&lt;c7&gt;</bpt>sides<ept i="7">&lt;/c7&gt;</ept>プロパティにアクセスして出力することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="3" x="3">&lt;c3&gt;</bpt>john.residence<ept i="3">&lt;/c3&gt;</ept> is currently <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>, the subscript call fails:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>john.residence<ept i="3">&lt;/c3&gt;</ept>が現在<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>なので、添え字呼び出しは失敗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="3" x="3">&lt;c3&gt;</bpt>userDefinedColorName<ept i="3">&lt;/c3&gt;</ept> is of an optional type, you can use the nil-coalescing operator to consider its value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>userDefinedColorName<ept i="3">&lt;/c3&gt;</ept>がオプショナル型であるため、あなたはその値を考慮するためにnil合体演算子を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="5" x="5">&lt;c5&gt;</bpt>T<ept i="5">&lt;/c5&gt;</ept> is a placeholder, Swift doesn’t look for an actual type called <bpt i="6" x="6">&lt;c6&gt;</bpt>T<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>T<ept i="5">&lt;/c5&gt;</ept>がプレースホルダであるので、スウィフトは<bpt i="6" x="6">&lt;c6&gt;</bpt>T<ept i="6">&lt;/c6&gt;</ept>と呼ばれる実際の型を捜しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="5" x="5">&lt;c5&gt;</bpt>generator<ept i="5">&lt;/c5&gt;</ept> is known to adopt <bpt i="6" x="6">&lt;c6&gt;</bpt>RandomNumberGenerator<ept i="6">&lt;/c6&gt;</ept>, it’s guaranteed to have a <bpt i="7" x="7">&lt;c7&gt;</bpt>random()<ept i="7">&lt;/c7&gt;</ept> method to call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>generator<ept i="5">&lt;/c5&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt>RandomNumberGenerator<ept i="6">&lt;/c6&gt;</ept>を採用すると知られているので、それは<bpt i="7" x="7">&lt;c7&gt;</bpt>random()<ept i="7">&lt;/c7&gt;</ept>メソッドを呼ぶことを保証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="6" x="6">&lt;c6&gt;</bpt>userDefinedColorName<ept i="6">&lt;/c6&gt;</ept> is <bpt i="7" x="7">&lt;c7&gt;</bpt>nil<ept i="7">&lt;/c7&gt;</ept>, the expression <bpt i="8" x="8">&lt;c8&gt;</bpt>userDefinedColorName ?? defaultColorName<ept i="8">&lt;/c8&gt;</ept> returns the value of <bpt i="9" x="9">&lt;c9&gt;</bpt>defaultColorName<ept i="9">&lt;/c9&gt;</ept>, or <bpt i="10" x="10">&lt;c10&gt;</bpt>"red"<ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>userDefinedColorName<ept i="6">&lt;/c6&gt;</ept>は<bpt i="7" x="7">&lt;c7&gt;</bpt>nil<ept i="7">&lt;/c7&gt;</ept>なので、式<bpt i="8" x="8">&lt;c8&gt;</bpt>userDefinedColorName ?? defaultColorName<ept i="8">&lt;/c8&gt;</ept>は、<bpt i="9" x="9">&lt;c9&gt;</bpt>defaultColorName<ept i="9">&lt;/c9&gt;</ept>の値、すなわち<bpt i="10" x="10">&lt;c10&gt;</bpt>"red"<ept i="10">&lt;/c10&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because Swift is type safe, it performs <bpt i="0" x="0">&lt;e0&gt;</bpt>type checks<ept i="0">&lt;/e0&gt;</ept> when compiling your code and flags any mismatched types as errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトが型安全であるので、それは、あなたのコードをコンパイルするとき<bpt i="0" x="0">&lt;e0&gt;</bpt>型チェック<ept i="0">&lt;/e0&gt;</ept>を実行して、あらゆる組合せを誤った型をエラーとして合図します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because Swift’s <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement is exhaustive and does not allow empty cases, it is sometimes necessary to deliberately match and ignore a case in order to make your intentions explicit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文は網羅的で空のケース節を許さないので、あなたの意図を明確にするために故意にあるケース節を適合してから無視することが時々必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a <bpt i="2" x="2">&lt;c2&gt;</bpt>throw<ept i="2">&lt;/c2&gt;</ept> statement immediately transfers program control, an item will be vended only if all of these requirements are met.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>throw<ept i="2">&lt;/c2&gt;</ept>文が直ちにプログラム制御を移すので、これらの必要なものすべてが満たされる場合にのみ項目は販売されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a credit card will always have a customer, you define its <bpt i="0" x="0">&lt;c0&gt;</bpt>customer<ept i="0">&lt;/c0&gt;</ept> property as an unowned reference, to avoid a strong reference cycle:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クレジットカードが常にひとりの顧客を持つので、強い参照循環を避けるために、あなたはその<bpt i="0" x="0">&lt;c0&gt;</bpt>customer<ept i="0">&lt;/c0&gt;</ept>プロパティを非所有者参照として定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a failed assertion or precondition indicates an invalid program state, there’s no way to catch a failed assertion.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗した表明または前提条件は無効なプログラム状態を示すことから、失敗した表明を受け止めるための方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a selector is created at compile time, not at runtime, the compiler can check that a method or property exists and that they’re exposed to the Objective-C runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるセレクタが作成されるのはコンパイル時であり、実行時でないので、コンパイラはそのメソッドまたはプロパティが存在すること、そしてそれらがObjective-Cランタイムに露出されていることを確かめることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a weak reference does not keep a strong hold on the instance it refers to, it’s possible for that instance to be deallocated while the weak reference is still referring to it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>弱い参照がそれが言及するインスタンスに対する強い支配力を保たないので、弱い参照がまだそれに言及している間にそのインスタンスが割り当て解除されることは可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because addition isn’t part of the essential behavior for a vector, the type method is defined in an extension of <bpt i="2" x="2">&lt;c2&gt;</bpt>Vector2D<ept i="2">&lt;/c2&gt;</ept> rather than in the main structure declaration of <bpt i="3" x="3">&lt;c3&gt;</bpt>Vector2D<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加算はベクトルの欠くことのできない挙動の部分ではないので、この型メソッドは<bpt i="2" x="2">&lt;c2&gt;</bpt>Vector2D<ept i="2">&lt;/c2&gt;</ept>の拡張において定義されます、<bpt i="3" x="3">&lt;c3&gt;</bpt>Vector2D<ept i="3">&lt;/c3&gt;</ept>の主構造定義においてではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because all keys in the literal are of the same type as each other, and likewise all values are of the same type as each other, Swift can infer that <bpt i="0" x="0">&lt;c0&gt;</bpt>[String: String]<ept i="0">&lt;/c0&gt;</ept> is the correct type to use for the <bpt i="1" x="1">&lt;c1&gt;</bpt>airports<ept i="1">&lt;/c1&gt;</ept> dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このリテラルの全てのキーが互いに同じ型である、そして全ての型が互いに他と同じ型であるので、スウィフトは、<bpt i="0" x="0">&lt;c0&gt;</bpt>[String: String]<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>airports<ept i="1">&lt;/c1&gt;</ept>辞書に使うために適切な型であると推測することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because all of the types can be inferred, the return arrow (<bpt i="4" x="4">&lt;c4&gt;</bpt>-&gt;<ept i="4">&lt;/c4&gt;</ept>) and the parentheses around the names of the parameters can also be omitted:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型の全てが推論されることができるので、戻り矢印（<bpt i="4" x="4">&lt;c4&gt;</bpt>-&gt;<ept i="4">&lt;/c4&gt;</ept>）と、パラメータの名前のまわりの丸括弧もまた省略することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because all properties of the <bpt i="0" x="0">&lt;c0&gt;</bpt>ShoppingListItem<ept i="0">&lt;/c0&gt;</ept> class have default values, and because it is a base class with no superclass, <bpt i="1" x="1">&lt;c1&gt;</bpt>ShoppingListItem<ept i="1">&lt;/c1&gt;</ept> automatically gains a default initializer implementation that creates a new instance with all of its properties set to their default values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ShoppingListItem<ept i="0">&lt;/c0&gt;</ept>クラスの全てのプロパティ省略時の値を持つことから、そしてそれがスーパークラスを持たない基盤クラスであることから、<bpt i="1" x="1">&lt;c1&gt;</bpt>ShoppingListItem<ept i="1">&lt;/c1&gt;</ept>は自動的に省略時のイニシャライザ実装を獲得します、それは、それのプロパティの全てをそれらの省略時の値に設定して、新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because all values in the array literal are of the same type, Swift can infer that <bpt i="0" x="0">&lt;c0&gt;</bpt>Set&lt;String&gt;<ept i="0">&lt;/c0&gt;</ept> is the correct type to use for the <bpt i="1" x="1">&lt;c1&gt;</bpt>favoriteGenres<ept i="1">&lt;/c1&gt;</ept> variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列リテラルの中の全ての値が同じ型であることから、スウィフトは<bpt i="0" x="0">&lt;c0&gt;</bpt>Set&lt;String&gt;<ept i="0">&lt;/c0&gt;</ept>が正しい型であると推論することができ、<bpt i="1" x="1">&lt;c1&gt;</bpt>favoriteGenres<ept i="1">&lt;/c1&gt;</ept>変数に使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because all values in the array literal are of the same type, Swift can infer that <bpt i="0" x="0">&lt;c0&gt;</bpt>[String]<ept i="0">&lt;/c0&gt;</ept> is the correct type to use for the <bpt i="1" x="1">&lt;c1&gt;</bpt>shoppingList<ept i="1">&lt;/c1&gt;</ept> variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この配列リテラルの値の全てが同じ型であるので、スウィフトは<bpt i="0" x="0">&lt;c0&gt;</bpt>[String]<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>shoppingList<ept i="1">&lt;/c1&gt;</ept>変数のために利用されるのに正しい型であると推測することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because an addition operator was defined earlier, you don’t need to reimplement the addition process here.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加算演算子は以前に定義されたので、あなたはここでは加算プロセスを再実装する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because an instance is not deallocated until after its deinitializer is called, a deinitializer can access all properties of the instance it is called on and can modify its behavior based on those properties (such as looking up the name of a file that needs to be closed).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスはそれのデイニシャライザが呼ばれる後までは割り当て解除されないので、デイニシャライザはそれが呼ばれるところのインスタンスの全てのプロパティにアクセスすることができて、それらのプロパティに基づいてその挙動を修正することができます（たとえば閉じられる必要があるファイルの名前を調べることなど）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because argument labels are not part of a function’s type, you omit them when writing a function type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数ラベルは関数の型の一部ではないことから、あなたはそれらを関数型を書く時に省略します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because both sides of the addition are now of type <bpt i="0" x="0">&lt;c0&gt;</bpt>UInt16<ept i="0">&lt;/c0&gt;</ept>, the addition is allowed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加算の両側が今では型<bpt i="0" x="0">&lt;c0&gt;</bpt>UInt16<ept i="0">&lt;/c0&gt;</ept>であるので、加算は許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because classes are reference types, <bpt i="0" x="0">&lt;c0&gt;</bpt>tenEighty<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>alsoTenEighty<ept i="1">&lt;/c1&gt;</ept> actually both refer to the <bpt i="2" x="2">&lt;e2&gt;</bpt>same<ept i="2">&lt;/e2&gt;</ept> <bpt i="3" x="3">&lt;c3&gt;</bpt>VideoMode<ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスが参照型であるので、<bpt i="0" x="0">&lt;c0&gt;</bpt>tenEighty<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>alsoTenEighty<ept i="1">&lt;/c1&gt;</ept>は両方とも実際に<bpt i="2" x="2">&lt;e2&gt;</bpt>同じ<ept i="2">&lt;/e2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>VideoMode<ept i="3">&lt;/c3&gt;</ept>インスタンスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because classes are reference types, it is possible for multiple constants and variables to refer to the same single instance of a class behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスが参照型であるので、複数の定数と変数があるクラスの同じ一つのインスタンスに言及することが舞台裏で可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because declarations marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>dynamic<ept i="0">&lt;/c0&gt;</ept> modifier are dispatched using the Objective-C runtime, they must be marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>dynamic<ept i="0">&lt;/c0&gt;</ept>修飾子で印される宣言はObjective-Cランタイムを使ってディスパッチされるので、それらは<bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept>属性で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because downcasting can fail, the type cast operator comes in two different forms.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ダウンキャストは失敗することがありえるので、型キャスト演算子は２つの異なる書式になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because each numeric type can store a different range of values, you must opt in to numeric type conversion on a case-by-case basis.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれの数の型は、値の異なる幅を保存できるので、あなたは数の型変換を一件一件を原則に決めていかなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because fatal errors are never optimized out, unlike assertions or preconditions, you can be sure that execution always halts if it encounters a stub implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>致命的なエラーは決して間違って最適化されません、表明や前提条件と違います、あなたは実行が常に停止することをそれがスタブ実装に遭遇する場合には確信できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because implicit unwrapping changes the meaning of the declaration that contains that type, optional types that are nested inside a tuple type or a generic type—such as the element types of a dictionary or array—can’t be marked as implicitly unwrapped.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的にアンラップされることがその型を含む宣言の意味することを変えることから、タプル型や総称体型の内部に入れ子にされたオプショナル型—例えば辞書や配列に属する要素型など—は、暗黙的にアンラップされるように印されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because implicitly unwrapped optionals have the same <bpt i="0" x="0">&lt;c0&gt;</bpt>Optional&lt;Wrapped&gt;<ept i="0">&lt;/c0&gt;</ept> type as optional values, you can use implicitly unwrapped optionals in all the same places in your code that you can use optionals.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的にアンラップされるオプショナルがオプショナル値と同じ<bpt i="0" x="0">&lt;c0&gt;</bpt>Optional&lt;Wrapped&gt;<ept i="0">&lt;/c0&gt;</ept>型を持つことから、あなたは、あなたのコードにおいてあなたがオプショナルを使うことができるのと同じ場所すべてで暗黙的にアンラップされるオプショナルを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because it does not need to return a value, the function’s definition does not include the return arrow (<bpt i="0" x="0">&lt;c0&gt;</bpt>-&gt;<ept i="0">&lt;/c0&gt;</ept>) or a return type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが値を返す必要がないので、この関数の定義は戻り矢印（<bpt i="0" x="0">&lt;c0&gt;</bpt>-&gt;<ept i="0">&lt;/c0&gt;</ept>）または戻り型を含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because it is an integer, it is rounded down during the division, so <bpt i="2" x="2">&lt;c2&gt;</bpt>16<ept i="2">&lt;/c2&gt;</ept> becomes <bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>58<ept i="4">&lt;/c4&gt;</ept> becomes <bpt i="5" x="5">&lt;c5&gt;</bpt>5<ept i="5">&lt;/c5&gt;</ept>, and <bpt i="6" x="6">&lt;c6&gt;</bpt>510<ept i="6">&lt;/c6&gt;</ept> becomes <bpt i="7" x="7">&lt;c7&gt;</bpt>51<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが整数であるので、除算のときに端数を切り捨てられます、それで<bpt i="2" x="2">&lt;c2&gt;</bpt>16<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>に、<bpt i="4" x="4">&lt;c4&gt;</bpt>58<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>5<ept i="5">&lt;/c5&gt;</ept>に、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>510<ept i="6">&lt;/c6&gt;</ept>は<bpt i="7" x="7">&lt;c7&gt;</bpt>51<ept i="7">&lt;/c7&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because it is in essence an “additive” operator, it has been given the same precedence group as additive infix operators such as <bpt i="2" x="2">&lt;c2&gt;</bpt>+<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>-<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは本質的には「加法的な」演算子であるので、それは<bpt i="2" x="2">&lt;c2&gt;</bpt>+<ept i="2">&lt;/c2&gt;</ept>や<bpt i="3" x="3">&lt;c3&gt;</bpt>-<ept i="3">&lt;/c3&gt;</ept>といった加法的な接中辞演算子と同じ優先順位グループを与えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because it is marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>lazy<ept i="0">&lt;/c0&gt;</ept> modifier, the <bpt i="1" x="1">&lt;c1&gt;</bpt>DataImporter<ept i="1">&lt;/c1&gt;</ept> instance for the <bpt i="2" x="2">&lt;c2&gt;</bpt>importer<ept i="2">&lt;/c2&gt;</ept> property is only created when the <bpt i="3" x="3">&lt;c3&gt;</bpt>importer<ept i="3">&lt;/c3&gt;</ept> property is first accessed, such as when its <bpt i="4" x="4">&lt;c4&gt;</bpt>filename<ept i="4">&lt;/c4&gt;</ept> property is queried:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが<bpt i="0" x="0">&lt;c0&gt;</bpt>lazy<ept i="0">&lt;/c0&gt;</ept>修飾子という特徴をもつので、<bpt i="2" x="2">&lt;c2&gt;</bpt>importer<ept i="2">&lt;/c2&gt;</ept>プロパティのための<bpt i="1" x="1">&lt;c1&gt;</bpt>DataImporter<ept i="1">&lt;/c1&gt;</ept>インスタンスは、<bpt i="3" x="3">&lt;c3&gt;</bpt>importer<ept i="3">&lt;/c3&gt;</ept>プロパティが最初にアクセスされるsgにだけ作成されます、例えばその<bpt i="4" x="4">&lt;c4&gt;</bpt>filename<ept i="4">&lt;/c4&gt;</ept>プロパティがたずねられるときなど：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because it is possible to request a key for which no value exists, a dictionary’s subscript returns an optional value of the dictionary’s value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それに対する値が存在しないキーへの要請が可能であるので、ある辞書の添え字は、その辞書の値型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because it provides a default value for all of the properties it introduces and does not define any initializers itself, <bpt i="0" x="0">&lt;c0&gt;</bpt>ShoppingListItem<ept i="0">&lt;/c0&gt;</ept> automatically inherits <bpt i="1" x="1">&lt;e1&gt;</bpt>all<ept i="1">&lt;/e1&gt;</ept> of the designated and convenience initializers from its superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが、省略時の値をそれが導入するプロパティの全てに与えて、そしてまったくイニシャライザを定義しないので、<bpt i="0" x="0">&lt;c0&gt;</bpt>ShoppingListItem<ept i="0">&lt;/c0&gt;</ept>はそのスーパークラスから自動的に指定および便宜イニシャライザの<bpt i="1" x="1">&lt;e1&gt;</bpt>全て<ept i="1">&lt;/e1&gt;</ept>を継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because it’s a generic type, <bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept> can be used to create a stack of <bpt i="1" x="1">&lt;e1&gt;</bpt>any<ept i="1">&lt;/e1&gt;</ept> valid type in Swift, in a similar manner to <bpt i="2" x="2">&lt;c2&gt;</bpt>Array<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが総称体型であるので、<bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Array<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary<ept i="3">&lt;/c3&gt;</ept>に類似したやり方で、スウィフトにおける<bpt i="1" x="1">&lt;e1&gt;</bpt>あらゆる<ept i="1">&lt;/e1&gt;</ept>有効な型のスタックを作るために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because it’s a type, you can use a protocol in many places where other types are allowed, including:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが型であるので、以下を含む、他の型が許される多くの場所において、あなたはプロトコルを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because it’s an alias, the call to <bpt i="2" x="2">&lt;c2&gt;</bpt>AudioSample.min<ept i="2">&lt;/c2&gt;</ept> actually calls <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt16.min<ept i="3">&lt;/c3&gt;</ept>, which provides an initial value of <bpt i="4" x="4">&lt;c4&gt;</bpt>0<ept i="4">&lt;/c4&gt;</ept> for the <bpt i="5" x="5">&lt;c5&gt;</bpt>maxAmplitudeFound<ept i="5">&lt;/c5&gt;</ept> variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それがエイリアスであるので、<bpt i="2" x="2">&lt;c2&gt;</bpt>AudioSample.min<ept i="2">&lt;/c2&gt;</ept>への呼び出しは実際には<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt16.min<ept i="3">&lt;/c3&gt;</ept>を呼び、それは<bpt i="4" x="4">&lt;c4&gt;</bpt>0<ept i="4">&lt;/c4&gt;</ept>の初期値を<bpt i="5" x="5">&lt;c5&gt;</bpt>maxAmplitudeFound<ept i="5">&lt;/c5&gt;</ept>変数のために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because it’s not necessarily a mistake for code that calls the <bpt i="6" x="6">&lt;c6&gt;</bpt>advance(to:)<ept i="6">&lt;/c6&gt;</ept> method to ignore the return value, this function is marked with the <bpt i="7" x="7">&lt;c7&gt;</bpt>@discardableResult<ept i="7">&lt;/c7&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>advance(to:)<ept i="6">&lt;/c6&gt;</ept>メソッドを呼び出して戻り値を無視することが必ずしもコードの誤りでないことから、この関数は<bpt i="7" x="7">&lt;c7&gt;</bpt>@discardableResult<ept i="7">&lt;/c7&gt;</ept>属性で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because it’s not practical to list every possible <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> value in the example above, a <bpt i="1" x="1">&lt;c1&gt;</bpt>default<ept i="1">&lt;/c1&gt;</ept> case handles any characters that are not matched.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべてのあり得る<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>値を並べることは上の例では実際的ではないので、<bpt i="1" x="1">&lt;c1&gt;</bpt>default<ept i="1">&lt;/c1&gt;</ept>ケース節が適合しないあらゆる文字を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because it’s of an optional type, the <bpt i="3" x="3">&lt;c3&gt;</bpt>delegate<ept i="3">&lt;/c3&gt;</ept> property is automatically set to an initial value of <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それがオプショナル型であるので、<bpt i="3" x="3">&lt;c3&gt;</bpt>delegate<ept i="3">&lt;/c3&gt;</ept>プロパティは自動的に初期値の<bpt i="4" x="4">&lt;c4&gt;</bpt>nilに<ept i="4">&lt;/c4&gt;</ept>設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because multiline string literals use three double quotes instead of just one, you can include a double quote (<bpt i="0" x="0">&lt;c0&gt;</bpt>"<ept i="0">&lt;/c0&gt;</ept>) inside of a multiline string literal without escaping it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行文字列リテラルは、ただ１つではなく３つの二重引用符を使います、あなたは二重引用符（<bpt i="0" x="0">&lt;c0&gt;</bpt>"<ept i="0">&lt;/c0&gt;</ept>）を複数行文字列リテラルの内部にそれをエスケープすることなく含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because of the special way that positive and negative numbers are stored, shifting either of them to the right moves them closer to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正および負の数が保存される特別な方法のため、それらのどちらでも右へシフトすることは、それらをゼロの近くに動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because of the unowned <bpt i="0" x="0">&lt;c0&gt;</bpt>customer<ept i="0">&lt;/c0&gt;</ept> reference, when you break the strong reference held by the <bpt i="1" x="1">&lt;c1&gt;</bpt>john<ept i="1">&lt;/c1&gt;</ept> variable, there are no more strong references to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Customer<ept i="2">&lt;/c2&gt;</ept> instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非所有者<bpt i="0" x="0">&lt;c0&gt;</bpt>customer<ept i="0">&lt;/c0&gt;</ept>参照であることから、あなたが<bpt i="1" x="1">&lt;c1&gt;</bpt>john<ept i="1">&lt;/c1&gt;</ept>変数によって保持される強い参照を壊すとき、<bpt i="2" x="2">&lt;c2&gt;</bpt>Customer<ept i="2">&lt;/c2&gt;</ept>インスタンスへの強い参照はもうそれ以上ありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because of this behavior, the <bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept> cases <bpt i="3" x="3">&lt;c3&gt;</bpt>case let (x, y):<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>case (let x, let y):<ept i="4">&lt;/c4&gt;</ept> match the same values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挙動のため、<bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept>ケース節<bpt i="3" x="3">&lt;c3&gt;</bpt>case let (x、y):<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>case (let x、let y):<ept i="4">&lt;/c4&gt;</ept>は、同じ値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because of this uncertainty, the <bpt i="8" x="8">&lt;c8&gt;</bpt>as?<ept i="8">&lt;/c8&gt;</ept> form of the type cast operator returns an <bpt i="9" x="9">&lt;e9&gt;</bpt>optional<ept i="9">&lt;/e9&gt;</ept> value when attempting to downcast to a subclass type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この不確実性のために、サブクラス型へのダウンキャストを試みるとき、型キャスト演算子の<bpt i="8" x="8">&lt;c8&gt;</bpt>as?<ept i="8">&lt;/c8&gt;</ept>形式は<bpt i="9" x="9">&lt;e9&gt;</bpt>オプショナル<ept i="9">&lt;/e9&gt;</ept>の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because of this, Swift provides an automatic argument label for <bpt i="0" x="0">&lt;e0&gt;</bpt>every<ept i="0">&lt;/e0&gt;</ept> parameter in an initializer if you don’t provide one.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これのため、スウィフトは、あなたがそれを独自に提供しないならば、自動的な引数ラベルをイニシャライザの<bpt i="0" x="0">&lt;e0&gt;</bpt>あらゆる<ept i="0">&lt;/e0&gt;</ept>パラメータに用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because of this, all of the <bpt i="2" x="2">&lt;c2&gt;</bpt>Int.Kind<ept i="2">&lt;/c2&gt;</ept> case values can be written in shorthand form inside the <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> statement, such as <bpt i="4" x="4">&lt;c4&gt;</bpt>.negative<ept i="4">&lt;/c4&gt;</ept> rather than <bpt i="5" x="5">&lt;c5&gt;</bpt>Int.Kind.negative<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのことから、<bpt i="2" x="2">&lt;c2&gt;</bpt>Int.Kind<ept i="2">&lt;/c2&gt;</ept>のケース節の値の全ては、<bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>文内で略記形式で書かれることができます、たとえば<bpt i="5" x="5">&lt;c5&gt;</bpt>Int.Kind.negative<ept i="5">&lt;/c5&gt;</ept>ではなく<bpt i="4" x="4">&lt;c4&gt;</bpt>.negative<ept i="4">&lt;/c4&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because of this, characters in Swift don’t each take up the same amount of memory within a string’s representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これのため、スウィフトの中の文字は、それぞれが同じ量のメモリを文字列の表現において取るわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because of this, it isn’t possible to guarantee that this code will work for <bpt i="2" x="2">&lt;e2&gt;</bpt>every<ept i="2">&lt;/e2&gt;</ept> possible type <bpt i="3" x="3">&lt;c3&gt;</bpt>T<ept i="3">&lt;/c3&gt;</ept>, and an appropriate error is reported when you try to compile the code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このため、このコードが<bpt i="2" x="2">&lt;e2&gt;</bpt>すべての<ept i="2">&lt;/e2&gt;</ept>可能な型<bpt i="3" x="3">&lt;c3&gt;</bpt>T<ept i="3">&lt;/c3&gt;</ept>のために機能することを保証することは可能ではありません、それであなたがこのコードをコンパイルしようとする場合は該当するエラーが報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because of this, the call to <bpt i="4" x="4">&lt;c4&gt;</bpt>john.residence?.address?.street<ept i="4">&lt;/c4&gt;</ept> fails.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このことから、<bpt i="4" x="4">&lt;c4&gt;</bpt>john.residence?.address?.street<ept i="4">&lt;/c4&gt;</ept>への呼び出しは、失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because of this, the more general term <bpt i="3" x="3">&lt;e3&gt;</bpt>instance<ept i="3">&lt;/e3&gt;</ept> is used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これのため、より一般的な語<bpt i="3" x="3">&lt;e3&gt;</bpt>インスタンス<ept i="3">&lt;/e3&gt;</ept>が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because of this, the raw value initializer always returns an <bpt i="1" x="1">&lt;e1&gt;</bpt>optional<ept i="1">&lt;/e1&gt;</ept> enumeration case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのため、生の値のイニシャライザは常に<bpt i="1" x="1">&lt;e1&gt;</bpt>オプショナル<ept i="1">&lt;/e1&gt;</ept>の列挙ケース節を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because of type inference, Swift requires far fewer type declarations than languages such as C or Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型推論のため、スウィフトはCまたはObjective-Cのような言語よりはるかに少ない型宣言しか必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because one value is <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>, the overall expression also evaluates to <bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept>, and access is allowed:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つの値が<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>なので、式全体もまた<bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept>です、そしてアクセスは許可されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because optional patterns are syntactic sugar for <bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept> enumeration case patterns, the following are equivalent:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルパターンは<bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept>列挙ケース節パターンに対する構文糖であるので、以下のものは等価です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because patterns represent the structure of a value rather than any one particular value, you can match them with a variety of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パターンがどれかひとつの特定の値ではなく値の構造を表すので、あなたはそれをいろいろな値と照合（マッチング）できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because protocols are types, begin their names with a capital letter (such as <bpt i="0" x="0">&lt;c0&gt;</bpt>FullyNamed<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>RandomNumberGenerator<ept i="1">&lt;/c1&gt;</ept>) to match the names of other types in Swift (such as <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルが型であるので、それらの名前を大文字で開始してください（例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>FullyNamed<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>RandomNumberGenerator<ept i="1">&lt;/c1&gt;</ept>のように）、それによってスウィフトでの他の型の名前（例えば<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>、および<bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept>）と釣り合いがとれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because superclass <bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept> and subclass <bpt i="1" x="1">&lt;c1&gt;</bpt>B<ept i="1">&lt;/c1&gt;</ept> are defined in the same source file, it’s valid for the <bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept> implementation of <bpt i="3" x="3">&lt;c3&gt;</bpt>someMethod()<ept i="3">&lt;/c3&gt;</ept> to call <bpt i="4" x="4">&lt;c4&gt;</bpt>super.someMethod()<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラス<bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept>とサブクラス<bpt i="1" x="1">&lt;c1&gt;</bpt>B<ept i="1">&lt;/c1&gt;</ept>が同じソースファイルにおいて定義されるので、<bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept>実装の<bpt i="3" x="3">&lt;c3&gt;</bpt>someMethod()<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>super.someMethod()<ept i="4">&lt;/c4&gt;</ept>を呼ぶことは有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> protocol conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>, conforming types must also provide an implementation of the equals operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>==<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>プロトコルが<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠することから、準拠する型はまた同等演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>==<ept i="2">&lt;/c2&gt;</ept>）のあるひとつの実装を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the <bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept> structure provides default values for all of its properties, it receives a default initializer and a memberwise initializer automatically, as described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Default Initializers<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept>構造体がそのプロパティの全てに省略時の値を与えるので、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>省略時のイニシャライザ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述されるように、それは自動的に省略時のイニシャライザとメンバー関連イニシャライザを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the <bpt i="0" x="0">&lt;c0&gt;</bpt>delegate<ept i="0">&lt;/c0&gt;</ept> property is an <bpt i="1" x="1">&lt;e1&gt;</bpt>optional<ept i="1">&lt;/e1&gt;</ept> <bpt i="2" x="2">&lt;c2&gt;</bpt>DiceGameDelegate<ept i="2">&lt;/c2&gt;</ept>, the <bpt i="3" x="3">&lt;c3&gt;</bpt>play()<ept i="3">&lt;/c3&gt;</ept> method uses optional chaining each time it calls a method on the delegate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>delegate<ept i="0">&lt;/c0&gt;</ept>プロパティが<bpt i="1" x="1">&lt;e1&gt;</bpt>オプショナル<ept i="1">&lt;/e1&gt;</ept>の<bpt i="2" x="2">&lt;c2&gt;</bpt>DiceGameDelegate<ept i="2">&lt;/c2&gt;</ept>であるので、<bpt i="3" x="3">&lt;c3&gt;</bpt>play()<ept i="3">&lt;/c3&gt;</ept>メソッドは、それが委任先でメソッドを呼ぶたびにオプショナル連鎖を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the <bpt i="0" x="0">&lt;c0&gt;</bpt>vend(itemNamed:)<ept i="0">&lt;/c0&gt;</ept> method propagates any errors it throws, any code that calls this method must either handle the errors—using a <bpt i="1" x="1">&lt;c1&gt;</bpt>do<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>catch<ept i="2">&lt;/c2&gt;</ept> statement, <bpt i="3" x="3">&lt;c3&gt;</bpt>try?<ept i="3">&lt;/c3&gt;</ept>, or <bpt i="4" x="4">&lt;c4&gt;</bpt>try!<ept i="4">&lt;/c4&gt;</ept>—or continue to propagate them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt>vend(itemNamed:)<ept i="0">&lt;/c0&gt;</ept>メソッドはそれがスローするどんなエラーも伝達するので、このメソッドを呼び出す何らかのコードは、それらのエラーを取り扱うか ― <bpt i="1" x="1">&lt;c1&gt;</bpt>do<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>catch<ept i="2">&lt;/c2&gt;</ept>文、<bpt i="3" x="3">&lt;c3&gt;</bpt>try?<ept i="3">&lt;/c3&gt;</ept>、または<bpt i="4" x="4">&lt;c4&gt;</bpt>try!<ept i="4">&lt;/c4&gt;</ept>を使って ― またはそれらの伝達を続けるか、どちらかをしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the <bpt i="2" x="2">&lt;c2&gt;</bpt>vend(itemNamed:)<ept i="2">&lt;/c2&gt;</ept> method can throw an error, it’s called with the <bpt i="3" x="3">&lt;c3&gt;</bpt>try<ept i="3">&lt;/c3&gt;</ept> keyword in front of it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>vend(itemNamed:)<ept i="2">&lt;/c2&gt;</ept>メソッドはエラーをスローできることから、それはそれの前の<bpt i="3" x="3">&lt;c3&gt;</bpt>try<ept i="3">&lt;/c3&gt;</ept>キーワードとともに呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> must have a case for every possible character, not just every alphabetic character, this <bpt i="4" x="4">&lt;c4&gt;</bpt>switch<ept i="4">&lt;/c4&gt;</ept> statement uses a <bpt i="5" x="5">&lt;c5&gt;</bpt>default<ept i="5">&lt;/c5&gt;</ept> case to match all characters other than <bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt>z<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>は、単にすべてのアルファベット文字ではなく、すべての可能な文字に対してひとつのケース節を持たなければならないことから、この<bpt i="4" x="4">&lt;c4&gt;</bpt>switch<ept i="4">&lt;/c4&gt;</ept>文は<bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept>と<bpt i="7" x="7">&lt;c7&gt;</bpt>z<ept i="7">&lt;/c7&gt;</ept>のほかのすべての文字にマッチするために<bpt i="5" x="5">&lt;c5&gt;</bpt>default<ept i="5">&lt;/c5&gt;</ept>ケース節を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the <bpt i="1" x="1">&lt;e1&gt;</bpt>return type<ept i="1">&lt;/e1&gt;</ept> can be a tuple type, function types support functions and methods that return multiple values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;e1&gt;</bpt>return type<ept i="1">&lt;/e1&gt;</ept>はタプル型であることが可能なので、関数型は複数の値を返す関数およびメソッドをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the arithmetic addition operator is a binary operator, this operator method takes two input parameters of type <bpt i="4" x="4">&lt;c4&gt;</bpt>Vector2D<ept i="4">&lt;/c4&gt;</ept> and returns a single output value, also of type <bpt i="5" x="5">&lt;c5&gt;</bpt>Vector2D<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>算術加算演算子は二項演算子なので、この演算子メソッドは<bpt i="4" x="4">&lt;c4&gt;</bpt>Vector2D<ept i="4">&lt;/c4&gt;</ept>型の２つの入力パラメーターを取り、同じく<bpt i="5" x="5">&lt;c5&gt;</bpt>Vector2D<ept i="5">&lt;/c5&gt;</ept>型のただ１つの出力値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the attempt to access <bpt i="0" x="0">&lt;c0&gt;</bpt>numberOfRooms<ept i="0">&lt;/c0&gt;</ept> has the potential to fail, the optional chaining attempt returns a value of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Int?<ept i="1">&lt;/c1&gt;</ept>, or “optional <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>numberOfRooms<ept i="0">&lt;/c0&gt;</ept>にアクセスする試みは失敗する可能性があるので、オプショナル連鎖は型<bpt i="1" x="1">&lt;c1&gt;</bpt>Int?<ept i="1">&lt;/c1&gt;</ept>の値、すなわち「オプショナルの<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>」、を返すことを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the body of the closure is so short, it can even be written on a single line:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャの本文がたいへん短いので、それは一つの行に書かれさえすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the call to <bpt i="0" x="0">&lt;c0&gt;</bpt>increment(forCount:)<ept i="0">&lt;/c0&gt;</ept> can fail for either of these two reasons, the call returns an <bpt i="1" x="1">&lt;e1&gt;</bpt>optional<ept i="1">&lt;/e1&gt;</ept> <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>increment(forCount:)<ept i="0">&lt;/c0&gt;</ept>への呼び出しがこれらの２つの理由のどちらによっても失敗する可能性があるので、呼び出しは<bpt i="1" x="1">&lt;e1&gt;</bpt>オプショナルの<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the closure’s body contains a single expression (<bpt i="2" x="2">&lt;c2&gt;</bpt>s1 &gt; s2<ept i="2">&lt;/c2&gt;</ept>) that returns a <bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept> value, there is no ambiguity, and the <bpt i="4" x="4">&lt;c4&gt;</bpt>return<ept i="4">&lt;/c4&gt;</ept> keyword can be omitted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャの本文が<bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept>値を返すただ一つの式（<bpt i="2" x="2">&lt;c2&gt;</bpt>s1 &gt; s2<ept i="2">&lt;/c2&gt;</ept>）を含むので、曖昧さはありません、それで<bpt i="4" x="4">&lt;c4&gt;</bpt>return<ept i="4">&lt;/c4&gt;</ept>キーワードは省略されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the data is nested, the enumeration used to store the data also needs to support nesting—this means the enumeration needs to be recursive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>データが入れ子にされるため、データを格納するために使われる列挙もまた、入れ子をサポートする必要があります—これは列挙が再帰することを必要とするのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the function returns a <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept> value, <bpt i="5" x="5">&lt;c5&gt;</bpt>greet(person:)<ept i="5">&lt;/c5&gt;</ept> can be wrapped in a call to the <bpt i="6" x="6">&lt;c6&gt;</bpt>print(_:separator:terminator:)<ept i="6">&lt;/c6&gt;</ept> function to print that string and see its return value, as shown above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>値を返すので、上で見られるように、<bpt i="5" x="5">&lt;c5&gt;</bpt>greet(person:)<ept i="5">&lt;/c5&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt>print(_:separator:terminator:)<ept i="6">&lt;/c6&gt;</ept>関数への呼び出しの中に包まれて、その文字列を出力してその戻り値を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the function’s return type is private, you must mark the function’s overall access level with the <bpt i="0" x="0">&lt;c0&gt;</bpt>private<ept i="0">&lt;/c0&gt;</ept> modifier for the function declaration to be valid:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数の戻り型が非公開であるので、あなたはこの関数宣言が有効になるために関数の全体的なアクセス水準に<bpt i="0" x="0">&lt;c0&gt;</bpt>private<ept i="0">&lt;/c0&gt;</ept>修飾子で印しなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the initializer might fail, it returns an <bpt i="0" x="0">&lt;e0&gt;</bpt>optional<ept i="0">&lt;/e0&gt;</ept> <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>, rather than an <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザが失敗するかもしれないので、それは<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>ではなくて、<bpt i="0" x="0">&lt;e0&gt;</bpt>オプショナル<ept i="0">&lt;/e0&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the key path string is created at compile time, not at runtime, the compiler can check that the property exists and that the property is exposed to the Objective-C runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパス文字列は実行時ではなく、コンパイル時に作成されるため、コンパイラはプロパティが存在することおよびプロパティがObjective-Cランタイムへと露出されることを確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the last line of <bpt i="2" x="2">&lt;c2&gt;</bpt>badStart<ept i="2">&lt;/c2&gt;</ept> doesn’t end with a line break, that line gets combined with the first line of <bpt i="3" x="3">&lt;c3&gt;</bpt>end<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>badStart<ept i="2">&lt;/c2&gt;</ept>の最後の行は改行で終わらないことから、その行は<bpt i="3" x="3">&lt;c3&gt;</bpt>end<ept i="3">&lt;/c3&gt;</ept>の最初の行と結合されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the new <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> instance has been assigned to the <bpt i="1" x="1">&lt;c1&gt;</bpt>reference1<ept i="1">&lt;/c1&gt;</ept> variable, there is now a strong reference from <bpt i="2" x="2">&lt;c2&gt;</bpt>reference1<ept i="2">&lt;/c2&gt;</ept> to the new <bpt i="3" x="3">&lt;c3&gt;</bpt>Person<ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>インスタンスが<bpt i="1" x="1">&lt;c1&gt;</bpt>reference1<ept i="1">&lt;/c1&gt;</ept>変数に代入されたので、強い参照が現在<bpt i="2" x="2">&lt;c2&gt;</bpt>reference1<ept i="2">&lt;/c2&gt;</ept>から新しい<bpt i="3" x="3">&lt;c3&gt;</bpt>Person<ept i="3">&lt;/c3&gt;</ept>インスタンスまで存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the players start off the board, on “square zero”, the board is initialized with 26 zero <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> values, not 25.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレイヤーは、「正方形ゼロ」で盤を始めることから、この盤は26個のゼロ<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>値で初期化されます、25ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the sorting closure is passed as an argument to a method, Swift can infer the types of its parameters and the type of the value it returns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ソート（分類）するクロージャが引数としてメソッドに渡されるので、スウィフトは、それのパラメータの型とそれが返す値の型を推論することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the temperature has increased to <bpt i="0" x="0">&lt;c0&gt;</bpt>40<ept i="0">&lt;/c0&gt;</ept> degrees Fahrenheit, it is no longer cold enough to advise wearing a scarf and so the <bpt i="1" x="1">&lt;c1&gt;</bpt>else<ept i="1">&lt;/c1&gt;</ept> branch is triggered instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>温度が華氏<bpt i="0" x="0">&lt;c0&gt;</bpt>40<ept i="0">&lt;/c0&gt;</ept>度まで増加したので、スカーフを着けることを助言するに足りるほどもはや寒くありません、それで代わりに<bpt i="1" x="1">&lt;c1&gt;</bpt>else<ept i="1">&lt;/c1&gt;</ept>分岐が作動させられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the temperature is neither too cold nor too warm to trigger the <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>else if<ept i="1">&lt;/c1&gt;</ept> conditions, no message is printed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この気温は<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>else if<ept i="1">&lt;/c1&gt;</ept>条件の引き金になるにはあまり寒くもなくあまり暖かくもないので、メッセージは出力されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the tuple’s member values are named as part of the function’s return type, they can be accessed with dot syntax to retrieve the minimum and maximum found values:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプルの構成要素値は、この関数の戻り型の部分で命名されるので、それらは最小および最大の見つけられた値を取り出すためにドット構文でアクセスされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the type alias and the existing type can be used interchangeably, the type alias can’t introduce additional generic constraints.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型エイリアスと既存の型は交換可能に使われることができるので、型エイリアスは追加的な総称体制約を導入することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the value of <bpt i="3" x="3">&lt;c3&gt;</bpt>approximateCount<ept i="3">&lt;/c3&gt;</ept> falls between 12 and 100, <bpt i="4" x="4">&lt;c4&gt;</bpt>naturalCount<ept i="4">&lt;/c4&gt;</ept> is assigned the value <bpt i="5" x="5">&lt;c5&gt;</bpt>"dozens of"<ept i="5">&lt;/c5&gt;</ept>, and execution is transferred out of the <bpt i="6" x="6">&lt;c6&gt;</bpt>switch<ept i="6">&lt;/c6&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>approximateCount<ept i="3">&lt;/c3&gt;</ept>の値が12と100の間で失敗することから、<bpt i="4" x="4">&lt;c4&gt;</bpt>naturalCount<ept i="4">&lt;/c4&gt;</ept>は、値<bpt i="5" x="5">&lt;c5&gt;</bpt>"dozens of"<ept i="5">&lt;/c5&gt;</ept>を代入されます、そして実行は<bpt i="6" x="6">&lt;c6&gt;</bpt>switch<ept i="6">&lt;/c6&gt;</ept>文の外に移されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the value of the <bpt i="0" x="0">&lt;e0&gt;</bpt>condition<ept i="0">&lt;/e0&gt;</ept> is evaluated after the <bpt i="1" x="1">&lt;e1&gt;</bpt>statements<ept i="1">&lt;/e1&gt;</ept> are executed, the <bpt i="2" x="2">&lt;e2&gt;</bpt>statements<ept i="2">&lt;/e2&gt;</ept> in a <bpt i="3" x="3">&lt;c3&gt;</bpt>repeat<ept i="3">&lt;/c3&gt;</ept>-<bpt i="4" x="4">&lt;c4&gt;</bpt>while<ept i="4">&lt;/c4&gt;</ept> statement are executed at least once.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;e1&gt;</bpt>文<ept i="1">&lt;/e1&gt;</ept>が実行された後で<bpt i="0" x="0">&lt;e0&gt;</bpt>条件<ept i="0">&lt;/e0&gt;</ept>の値が評価されるので、<bpt i="3" x="3">&lt;c3&gt;</bpt>repeat<ept i="3">&lt;/c3&gt;</ept>-<bpt i="4" x="4">&lt;c4&gt;</bpt>while<ept i="4">&lt;/c4&gt;</ept>文の中の<bpt i="2" x="2">&lt;e2&gt;</bpt>文<ept i="2">&lt;/e2&gt;</ept>は少なくとも一回は実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the value of the <bpt i="0" x="0">&lt;e0&gt;</bpt>condition<ept i="0">&lt;/e0&gt;</ept> is evaluated before the <bpt i="1" x="1">&lt;e1&gt;</bpt>statements<ept i="1">&lt;/e1&gt;</ept> are executed, the <bpt i="2" x="2">&lt;e2&gt;</bpt>statements<ept i="2">&lt;/e2&gt;</ept> in a <bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept> statement can be executed zero or more times.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;e1&gt;</bpt>文<ept i="1">&lt;/e1&gt;</ept>が実行される前に、<bpt i="0" x="0">&lt;e0&gt;</bpt>条件<ept i="0">&lt;/e0&gt;</ept>の値が評価されるので、<bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept>文の中の<bpt i="2" x="2">&lt;e2&gt;</bpt>文<ept i="2">&lt;/e2&gt;</ept>は０回またはそれ以上実行される可能性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because there are no more strong references to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Apartment<ept i="0">&lt;/c0&gt;</ept> instance, it too is deallocated:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Apartment<ept i="0">&lt;/c0&gt;</ept>インスタンスへの強い参照はもうこれ以上ないので、それも割り当て解除されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because there are no more strong references to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept> instance, it’s deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept>インスタンスへの強い参照はもうないので、それは割り当て解除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because there are no more strong references to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> instance, it’s deallocated and the <bpt i="1" x="1">&lt;c1&gt;</bpt>tenant<ept i="1">&lt;/c1&gt;</ept> property is set to <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もうこれ以上<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>インスタンスへの強い参照はないことから、それは割り当て解除されます、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>tenant<ept i="1">&lt;/c1&gt;</ept>特性は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>に設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because there are no other specific cases, <bpt i="2" x="2">&lt;c2&gt;</bpt>integerToDescribe<ept i="2">&lt;/c2&gt;</ept> is matched by the <bpt i="3" x="3">&lt;c3&gt;</bpt>default<ept i="3">&lt;/c3&gt;</ept> case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他のいかなる特定のケース節もないことから、<bpt i="2" x="2">&lt;c2&gt;</bpt>integerToDescribe<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>default<ept i="3">&lt;/c3&gt;</ept>ケース節に適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because there is at least one strong reference, ARC makes sure that this <bpt i="4" x="4">&lt;c4&gt;</bpt>Person<ept i="4">&lt;/c4&gt;</ept> is kept in memory and is not deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>少なくとも１つの強い参照があるので、ARCはこの<bpt i="4" x="4">&lt;c4&gt;</bpt>Person<ept i="4">&lt;/c4&gt;</ept>がメモリに保たれて割り当て解除されないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because these variables are of an optional type (<bpt i="2" x="2">&lt;c2&gt;</bpt>Person?<ept i="2">&lt;/c2&gt;</ept>, not <bpt i="3" x="3">&lt;c3&gt;</bpt>Person<ept i="3">&lt;/c3&gt;</ept>), they are automatically initialized with a value of <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>, and do not currently reference a <bpt i="5" x="5">&lt;c5&gt;</bpt>Person<ept i="5">&lt;/c5&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの変数がオプショナル型（<bpt i="3" x="3">&lt;c3&gt;</bpt>Person<ept i="3">&lt;/c3&gt;</ept>ではなく、<bpt i="2" x="2">&lt;c2&gt;</bpt>Person?<ept i="2">&lt;/c2&gt;</ept>）であることから、それらは自動的に<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>の値で初期化されて、今は<bpt i="5" x="5">&lt;c5&gt;</bpt>Person<ept i="5">&lt;/c5&gt;</ept>インスタンスに参照をつけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because they are separate instances, setting the width of <bpt i="5" x="5">&lt;c5&gt;</bpt>cinema<ept i="5">&lt;/c5&gt;</ept> to <bpt i="6" x="6">&lt;c6&gt;</bpt>2048<ept i="6">&lt;/c6&gt;</ept> doesn’t affect the width stored in <bpt i="7" x="7">&lt;c7&gt;</bpt>hd<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらが別々のインスタンスであるので、<bpt i="5" x="5">&lt;c5&gt;</bpt>cinema<ept i="5">&lt;/c5&gt;</ept>の幅を<bpt i="6" x="6">&lt;c6&gt;</bpt>2048<ept i="6">&lt;/c6&gt;</ept>に設定することは<bpt i="7" x="7">&lt;c7&gt;</bpt>hd<ept i="7">&lt;/c7&gt;</ept>に保存される幅に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because they’re named types, you can extend their behavior to suit the needs of your program, using an extension declaration, discussed in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Extensions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Extension Declaration<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらが名前付きの型であるので、あなたはそれらの挙動を、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>拡張<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>および<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>拡張宣言<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で議論される拡張宣言を使って、あなたのプログラムの必要に応じて拡張することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because this convenience initializer overrides a designated initializer from its superclass, it must be marked with the <bpt i="5" x="5">&lt;c5&gt;</bpt>override<ept i="5">&lt;/c5&gt;</ept> modifier (as described in <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Initializer Inheritance and Overriding<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この便宜イニシャライザがそれのスーパークラスからの指定イニシャライザをオーバーライドするので、それは<bpt i="5" x="5">&lt;c5&gt;</bpt>override<ept i="5">&lt;/c5&gt;</ept>修飾子で印されなければなりません（<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>イニシャライザの継承およびオーバーライド<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>で記述されるように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because this particular array has specified a value type of <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>, it is allowed to store <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> values only.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この特定の配列が<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>の値型を指定したので、それが貯蔵を許可されるのは<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>値のみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because this particular set has specified a value type of <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>, it is <bpt i="4" x="4">&lt;e4&gt;</bpt>only<ept i="4">&lt;/e4&gt;</ept> allowed to store <bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この問題の集合が明確に指定された<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>の値型を持つことから、それは<bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept>値を格納すること<bpt i="4" x="4">&lt;e4&gt;</bpt>だけ<ept i="4">&lt;/e4&gt;</ept>が許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because this version of <bpt i="0" x="0">&lt;c0&gt;</bpt>Residence<ept i="0">&lt;/c0&gt;</ept> stores an array of <bpt i="1" x="1">&lt;c1&gt;</bpt>Room<ept i="1">&lt;/c1&gt;</ept> instances, its <bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfRooms<ept i="2">&lt;/c2&gt;</ept> property is implemented as a computed property, not a stored property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Residence<ept i="0">&lt;/c0&gt;</ept>のこの改作が<bpt i="1" x="1">&lt;c1&gt;</bpt>Room<ept i="1">&lt;/c1&gt;</ept>インスタンスの配列を格納するので、その<bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfRooms<ept i="2">&lt;/c2&gt;</ept>プロパティは計算プロパティとして実装されます、保存プロパティではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Before updating <bpt i="3" x="3">&lt;c3&gt;</bpt>currentLevel<ept i="3">&lt;/c3&gt;</ept>, this method checks whether the requested new level is already unlocked.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>currentLevel<ept i="3">&lt;/c3&gt;</ept>を更新する前に、このメソッドは要請された新しいレベルがすでに錠を開けられるかどうか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Behind the scenes, <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt16<ept i="1">&lt;/c1&gt;</ept> has an initializer that accepts a <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt8<ept i="2">&lt;/c2&gt;</ept> value, and so this initializer is used to make a new <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt16<ept i="3">&lt;/c3&gt;</ept> from an existing <bpt i="4" x="4">&lt;c4&gt;</bpt>UInt8<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>舞台裏で、<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt16<ept i="1">&lt;/c1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt8<ept i="2">&lt;/c2&gt;</ept>値を受け入れるイニシャライザを持ちます、それでこのイニシャライザが新しい<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt16<ept i="3">&lt;/c3&gt;</ept>を既存の<bpt i="4" x="4">&lt;c4&gt;</bpt>UInt8<ept i="4">&lt;/c4&gt;</ept>から作るために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Behind the scenes, Swift’s compiler optimizes string usage so that actual copying takes place only when absolutely necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>舞台裏で、スウィフトのコンパイラは、実際にコピーすることは絶対に必要なときだけ起こるように、文字列使用を最適化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Behind the scenes, Swift’s native <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> type is built from <bpt i="1" x="1">&lt;e1&gt;</bpt>Unicode scalar<ept i="1">&lt;/e1&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>舞台裏で、スウィフト生得の<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>型は<bpt i="1" x="1">&lt;e1&gt;</bpt>ユニコード・スカラー<ept i="1">&lt;/e1&gt;</ept>値によって組み立てられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Binary Expressions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>二項式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Binary literals begin with <bpt i="1" x="1">&lt;c1&gt;</bpt>0b<ept i="1">&lt;/c1&gt;</ept>, octal literals begin with <bpt i="2" x="2">&lt;c2&gt;</bpt>0o<ept i="2">&lt;/c2&gt;</ept>, and hexadecimal literals begin with <bpt i="3" x="3">&lt;c3&gt;</bpt>0x<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２進のリテラルは<bpt i="1" x="1">&lt;c1&gt;</bpt>0b<ept i="1">&lt;/c1&gt;</ept>から始まります、８進のリテラルは<bpt i="2" x="2">&lt;c2&gt;</bpt>0o<ept i="2">&lt;/c2&gt;</ept>から始まります、そして16進のリテラルは<bpt i="3" x="3">&lt;c3&gt;</bpt>0x<ept i="3">&lt;/c3&gt;</ept>から始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Binary literals contain <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>, octal literals contain <bpt i="4" x="4">&lt;c4&gt;</bpt>0<ept i="4">&lt;/c4&gt;</ept> through <bpt i="5" x="5">&lt;c5&gt;</bpt>7<ept i="5">&lt;/c5&gt;</ept>, and hexadecimal literals contain <bpt i="6" x="6">&lt;c6&gt;</bpt>0<ept i="6">&lt;/c6&gt;</ept> through <bpt i="7" x="7">&lt;c7&gt;</bpt>9<ept i="7">&lt;/c7&gt;</ept> as well as <bpt i="8" x="8">&lt;c8&gt;</bpt>A<ept i="8">&lt;/c8&gt;</ept> through <bpt i="9" x="9">&lt;c9&gt;</bpt>F<ept i="9">&lt;/c9&gt;</ept> in upper- or lowercase.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２進のリテラルは<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>を含みます、８進のリテラルは<bpt i="4" x="4">&lt;c4&gt;</bpt>0<ept i="4">&lt;/c4&gt;</ept>から<bpt i="5" x="5">&lt;c5&gt;</bpt>7<ept i="5">&lt;/c5&gt;</ept>までを含みます、そして、16進のリテラルは<bpt i="6" x="6">&lt;c6&gt;</bpt>0<ept i="6">&lt;/c6&gt;</ept>から<bpt i="7" x="7">&lt;c7&gt;</bpt>9<ept i="7">&lt;/c7&gt;</ept>までに加えて大文字または小文字での<bpt i="8" x="8">&lt;c8&gt;</bpt>A<ept i="8">&lt;/c8&gt;</ept>から<bpt i="9" x="9">&lt;c9&gt;</bpt>F<ept i="9">&lt;/c9&gt;</ept>までを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise AND Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の論理積演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise Left and Right Shift Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の左および右シフト演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise NOT Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の論理否定演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise OR Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の論理和演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise XOR Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の排他的論理和演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise left and right shifts have the effect of multiplying or dividing an integer by a factor of two.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の左または右シフトは、２の因数によって、ある整数を掛けるまたは割る効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bitwise operators can also be useful when you work with raw data from external sources, such as encoding and decoding data for communication over a custom protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位演算子はまた、あなたが外部のソースからの生のデータを扱うとき、役に立つことがありえます、例えば、あつらえのプロトコルを越えて通信するためのデータの符号化や復号など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Blue numbers are shifted, gray numbers are discarded, and orange zeros are inserted:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>青色の数はシフトされます、灰色の数は捨てられます、そしてオレンジ色のゼロが差し込まれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Boolean values are particularly useful when you work with conditional statements such as the <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文のような条件つきの文で作業するとき、ブールの値は特に役に立ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Boolean values are referred to as <bpt i="2" x="2">&lt;e2&gt;</bpt>logical<ept i="2">&lt;/e2&gt;</ept>, because they can only ever be true or false.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブールの値は、<bpt i="2" x="2">&lt;e2&gt;</bpt>論理<ept i="2">&lt;/e2&gt;</ept>として参照されます、なぜならそれらは真か偽であることだけができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Booleans</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Substring<ept i="1">&lt;/c1&gt;</ept> conform to the <bpt i="2" x="2">&lt;e2&gt;</bpt>StringProtocol &lt; //apple_ref/swift/intf/s:s14StringProtocolP&gt;<ept i="2">&lt;/e2&gt;</ept> protocol, which means it’s often convenient for string-manipulation functions to accept a <bpt i="3" x="3">&lt;c3&gt;</bpt>StringProtocol<ept i="3">&lt;/c3&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Substring<ept i="1">&lt;/c1&gt;</ept>の両方とも<bpt i="2" x="2">&lt;e2&gt;</bpt>StringProtocol &lt; //apple_ref/swift/intf/s:s14StringProtocolP&gt;<ept i="2">&lt;/e2&gt;</ept>プロトコルに準拠します、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>StringProtocol<ept i="3">&lt;/c3&gt;</ept>値を受け取ることは文字列操作関数それぞれにとってしばしば都合が良いのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both <bpt i="6" x="6">&lt;c6&gt;</bpt>C1<ept i="6">&lt;/c6&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt>C2<ept i="7">&lt;/c7&gt;</ept> are type parameters for two container types to be determined when the function is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>C1<ept i="6">&lt;/c6&gt;</ept>と<bpt i="7" x="7">&lt;c7&gt;</bpt>C2<ept i="7">&lt;/c7&gt;</ept>の両方は、２つのコンテナ型のための型パラメータで、関数が呼ばれるときに決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both an empty tuple expression and an empty tuple type are written <bpt i="0" x="0">&lt;c0&gt;</bpt>()<ept i="0">&lt;/c0&gt;</ept> in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空のタプル式と空のタプル型は両方とも、<bpt i="0" x="0">&lt;c0&gt;</bpt>()<ept i="0">&lt;/c0&gt;</ept>とスウィフトでは書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both can:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方とも以下のことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both classes correctly conform to the <bpt i="5" x="5">&lt;c5&gt;</bpt>HasArea<ept i="5">&lt;/c5&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方のクラスは、正しく<bpt i="5" x="5">&lt;c5&gt;</bpt>HasArea<ept i="5">&lt;/c5&gt;</ept>プロトコルに従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both constants can now be used independently:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方の定数は、今や独立して使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both designated initializers must call the single designated initializer from the superclass, to satisfy rule 1 from above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上記の規則１を満たすために、両方の指定イニシャライザは、スーパークラスからその一つだけある指定イニシャライザを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both functions have a type of <bpt i="4" x="4">&lt;c4&gt;</bpt>(Int) -&gt; Int<ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方の関数は、<bpt i="4" x="4">&lt;c4&gt;</bpt>(Int) -&gt; Int<ept i="4">&lt;/c4&gt;</ept>の型を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both initializers can be used to create a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Color<ept i="0">&lt;/c0&gt;</ept> instance, by providing named values for each initializer parameter:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方のイニシャライザとも、新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Color<ept i="0">&lt;/c0&gt;</ept>インスタンスを作成するために、各イニシャライザ・パラメータに名前を付けられた値を提供することで、使用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both initializers convert their single argument into the corresponding Celsius value and store this value in a property called <bpt i="4" x="4">&lt;c4&gt;</bpt>temperatureInCelsius<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方のイニシャライザは、それらのただ１つの引数を相当する摂氏の値に変えて、その値を<bpt i="4" x="4">&lt;c4&gt;</bpt>temperatureInCelsius<ept i="4">&lt;/c4&gt;</ept>と呼ばれるプロパティに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both integers and floats can be padded with extra zeros and can contain underscores to help with readability.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数と浮動小数点は、余分のゼロを詰められることができ、読みやすくするためにアンダースコアを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both of these classes also define a deinitializer, which prints the fact that an instance of that class is being deinitialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのクラスの両方ともデイニシャライザを定義します、それは、そのクラスのインスタンスがデイニシャライズされているという事実を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both of these extended grapheme clusters are valid ways to represent the character <bpt i="6" x="6">&lt;c6&gt;</bpt>é<ept i="6">&lt;/c6&gt;</ept>, and so they’re considered to be canonically equivalent:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの拡張書記素クラスタの両方とも、文字<bpt i="6" x="6">&lt;c6&gt;</bpt>é<ept i="6">&lt;/c6&gt;</ept>を表わす有効な方法です、そういうわけでそれらは正準等価とみなされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both of these representations qualify as a single <bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept> value in Swift:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの表し方の双方とも、スウィフトでは単一の<bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept>値としての基準を満たします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both of these variables have an initial value of <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>, by virtue of being optional:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルである利点によって、これらの変数の両方とも、<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>の初期値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both patterns include a binding for <bpt i="3" x="3">&lt;c3&gt;</bpt>distance<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>distance<ept i="4">&lt;/c4&gt;</ept> is an integer in both patterns—which means that the code in the body of the <bpt i="5" x="5">&lt;c5&gt;</bpt>case<ept i="5">&lt;/c5&gt;</ept> can always access a value for <bpt i="6" x="6">&lt;c6&gt;</bpt>distance<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方のパターンは、<bpt i="3" x="3">&lt;c3&gt;</bpt>distance<ept i="3">&lt;/c3&gt;</ept>に対する束縛を含みます、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>distance<ept i="4">&lt;/c4&gt;</ept>は両方のパターンにおいて整数です—それは<bpt i="5" x="5">&lt;c5&gt;</bpt>case<ept i="5">&lt;/c5&gt;</ept>の本文のコードは常に<bpt i="6" x="6">&lt;c6&gt;</bpt>distance<ept i="6">&lt;/c6&gt;</ept>に対する値にアクセスできることを編みします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both place their entire definition within a pair of braces:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方とも、それらの全ての定義を一対の波括弧の範囲内に置きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both properties are inferred to be of type <bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept> by assigning a default value of <bpt i="4" x="4">&lt;c4&gt;</bpt>0.0<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方のプロパティは、省略時の値の<bpt i="4" x="4">&lt;c4&gt;</bpt>0.0<ept i="4">&lt;/c4&gt;</ept>を代入することによって<bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept>型であると推測されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both protocols are adopted by a structure called <bpt i="6" x="6">&lt;c6&gt;</bpt>Person<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方のプロトコルは、<bpt i="6" x="6">&lt;c6&gt;</bpt>Person<ept i="6">&lt;/c6&gt;</ept>と呼ばれる構造体によって採用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both the protocol and the optional requirement must be marked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルとオプショナル要件の両方は、<bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept>属性で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Braces around the body are required.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>本文のまわりの波括弧は必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Branch Statements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>分岐文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Branch statements allow the program to execute certain parts of code depending on the value of one or more conditions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>分岐文は、プログラムが一つ以上の条件の値に従いコードの特定の部分を実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Break Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブレーク文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Break in a Loop Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループ文の中断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Break in a Switch Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>switch文の中断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bridging lets you use an expression of a Swift standard library type such as <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> as its corresponding Foundation type such as <bpt i="1" x="1">&lt;c1&gt;</bpt>NSString<ept i="1">&lt;/c1&gt;</ept> without needing to create a new instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブリッジは、あなたに<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>のようなスウィフト標準ライブラリ型の式を、<bpt i="1" x="1">&lt;c1&gt;</bpt>NSString<ept i="1">&lt;/c1&gt;</ept>のようなそれの対応しているFoundation型として使用させます、新しいインスタンスを作成する必要なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>But if you provide a setter clause, you must also provide a getter clause.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしあなたがセッター節を提供するならば、あなた同様にゲッター節を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By contrast, C requires you to insert an explicit <bpt i="2" x="2">&lt;c2&gt;</bpt>break<ept i="2">&lt;/c2&gt;</ept> statement at the end of every <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> case to prevent fallthrough.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対照的に、Cはあなたに抜け落ちること（フォールスルー）を防ぐために明示的に<bpt i="2" x="2">&lt;c2&gt;</bpt>break<ept i="2">&lt;/c2&gt;</ept>文をあらゆる<bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>ケース節の終わりに書き入れることを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By creating an extension on the protocol, all conforming types automatically gain this method implementation without any additional modification.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張をプロトコル上に作成することによって、すべての準拠している型が自動的にこのメソッド実装をなんら追加の修正なしに手に入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, Swift assigns the raw values starting at zero and incrementing by one each time, but you can change this behavior by explicitly specifying values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態で、スウィフトはゼロで開始して毎回１つ増加させながら生の値を割り当てます、しかしあなたは明示的にそれらの値を指定することでこの挙動を変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, a closure expression captures constants and variables from its surrounding scope with strong references to those values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、クロージャ式は、それの囲んでいるスコープから定数や変数をそれらの値への強い参照を使ってキャプチャします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, any new <bpt i="0" x="0">&lt;c0&gt;</bpt>Bicycle<ept i="0">&lt;/c0&gt;</ept> instance you create will not have a basket.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に何もしなければ、あなたが作成するあらゆる新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Bicycle<ept i="0">&lt;/c0&gt;</ept>インスタンスは、入れ物かごを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, floating-point literals are expressed in decimal (with no prefix), but they can also be expressed in hexadecimal (with a <bpt i="0" x="0">&lt;c0&gt;</bpt>0x<ept i="0">&lt;/c0&gt;</ept> prefix).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態で、浮動小数点リテラルは10進において（接頭辞なしで）表されます、しかしそれらはまた、16進法において（<bpt i="0" x="0">&lt;c0&gt;</bpt>0x<ept i="0">&lt;/c0&gt;</ept>接頭辞で）表されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, functions use their parameter names as labels for their arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に何もしなくとも、関数はそれらのパラメータ名をそれらの引数のラベルとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, initializers declared in a superclass are not inherited by subclasses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、スーパークラスで宣言されるイニシャライザは、サブクラスによって継承されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, integer literals are expressed in decimal; you can specify an alternate base using a prefix.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、整数リテラルは10進法で表されます；あなたは、接頭辞を使用して代替の基数を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, most declarations are implicitly marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>internal<ept i="0">&lt;/c0&gt;</ept> access-level modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時では、大部分の宣言は暗黙的に<bpt i="0" x="0">&lt;c0&gt;</bpt>internal<ept i="0">&lt;/c0&gt;</ept>アクセス水準修飾子で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, only entities marked as open or public are accessible to other modules.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に何もしない状態では、開放または公開と印される実在だけが他のモジュールに利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, parameter names are also used as argument labels.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に何もしなければ、パラメータ名はまた引数ラベルとしても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, parameters use their parameter name as their argument label.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に何もしなければ、パラメータはそれらのパラメータ名をそれらの引数ラベルとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, the <bpt i="0" x="0">&lt;c0&gt;</bpt>asHTML<ept i="0">&lt;/c0&gt;</ept> property is assigned a closure that returns a string representation of an HTML tag.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に何もしなければ、<bpt i="0" x="0">&lt;c0&gt;</bpt>asHTML<ept i="0">&lt;/c0&gt;</ept>プロパティは、あるHTMLタグの文字列表現を返すクロージャを代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, the <bpt i="3" x="3">&lt;c3&gt;</bpt>~=<ept i="3">&lt;/c3&gt;</ept> operator compares two values of the same type using the <bpt i="4" x="4">&lt;c4&gt;</bpt>==<ept i="4">&lt;/c4&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態で、<bpt i="3" x="3">&lt;c3&gt;</bpt>~=<ept i="3">&lt;/c3&gt;</ept>演算子は、同じ型の２つの値を<bpt i="4" x="4">&lt;c4&gt;</bpt>==<ept i="4">&lt;/c4&gt;</ept>演算子を使用して比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, the function terminates the line it prints by adding a line break.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、この関数はそれが出力する行を改行を加えて終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, the parameters used in subscripting don’t have argument labels, unlike functions, methods, and initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態で、添字において使用されるパラメータは引数ラベルを持ちません、関数、メソッド、およびイニシャライザとは違って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, the properties of a value type cannot be modified from within its instance methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、ある値型に属するプロパティは、それのインスタンスメソッド内から修正されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, types that conform to a protocol must implement all properties, methods, and subscripts declared in the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、あるプロトコルに準拠する型は、そのプロトコルにおいて宣言される全てのプロパティ、メソッド、そして添え字を実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, variables, constants, and other named declarations that are declared at the top-level of a source file are accessible to code in every source file that is part of the same module.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態では、あるソースファイルのトップレベルで宣言される変数、定数、そして他の名前をつけられる宣言は、同じモジュールの一部であるすべてのソースファイルの中のコードにアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By making <bpt i="2" x="2">&lt;c2&gt;</bpt>if x = y<ept i="2">&lt;/c2&gt;</ept> invalid, Swift helps you to avoid these kinds of errors in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>if x = y<ept i="2">&lt;/c2&gt;</ept>を無効にすることによって、スウィフトはあなたがこれらの種類のエラーをあなたのコードにおいて避けるのを手伝います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By returning a tuple with two distinct values, each of a different type, the function provides more useful information about its outcome than if it could only return a single value of a single type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの別の値をそれぞれ異なる型で持つひとつのタプルを返すことによって、その関数は、それが一つの型の一つの値を返すことができるだけよりも、その結果に関するより役に立つ情報を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By wrapping the function call in a <bpt i="3" x="3">&lt;c3&gt;</bpt>do<ept i="3">&lt;/c3&gt;</ept> statement, any errors that are thrown will be propagated to the provided <bpt i="4" x="4">&lt;c4&gt;</bpt>catch<ept i="4">&lt;/c4&gt;</ept> clauses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その関数呼び出しを<bpt i="3" x="3">&lt;c3&gt;</bpt>do<ept i="3">&lt;/c3&gt;</ept>文の中に包み込むことによって、スローされるどんなエラーも添付の<bpt i="4" x="4">&lt;c4&gt;</bpt>catch<ept i="4">&lt;/c4&gt;</ept>節に伝えられるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Call a function by following its name with a list of arguments in parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は、その名前の後に丸括弧に入れた引数の目録（リスト）を続けることで呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Call one of the initializers declared within the class, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのクラス内で宣言されるイニシャライザのうちの１つを呼び出す、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>イニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Call one of the initializers declared within the structure, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その構造体の内部で宣言されるイニシャライザの内の１つを呼び出す、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>イニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling Methods Through Optional Chaining</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖を通してメソッドを呼ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling the function multiple times shows this behavior in action:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数を複数回呼ぶことは、活動中にこの挙動を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling the original incrementer (<bpt i="0" x="0">&lt;c0&gt;</bpt>incrementByTen<ept i="0">&lt;/c0&gt;</ept>) again continues to increment its own <bpt i="1" x="1">&lt;c1&gt;</bpt>runningTotal<ept i="1">&lt;/c1&gt;</ept> variable, and does not affect the variable captured by <bpt i="2" x="2">&lt;c2&gt;</bpt>incrementBySeven<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初のインクリメンタ（<bpt i="0" x="0">&lt;c0&gt;</bpt>incrementByTen<ept i="0">&lt;/c0&gt;</ept>）を再び呼ぶことは、それ独自の<bpt i="1" x="1">&lt;c1&gt;</bpt>runningTotal<ept i="1">&lt;/c1&gt;</ept>変数を増加させることを継続します、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>incrementBySeven<ept i="2">&lt;/c2&gt;</ept>によってキャプチャされる変数に影響しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling the superclass’s initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラスのイニシャライザを呼ぶ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calling this initializer returns a <bpt i="3" x="3">&lt;c3&gt;</bpt>Rect<ept i="3">&lt;/c3&gt;</ept> instance whose <bpt i="4" x="4">&lt;c4&gt;</bpt>origin<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>size<ept i="5">&lt;/c5&gt;</ept> properties are both initialized with the default values of <bpt i="6" x="6">&lt;c6&gt;</bpt>Point(x: 0.0, y: 0.0)<ept i="6">&lt;/c6&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt>Size(width: 0.0, height: 0.0)<ept i="7">&lt;/c7&gt;</ept> from their property definitions:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザを呼ぶことは<bpt i="3" x="3">&lt;c3&gt;</bpt>Rect<ept i="3">&lt;/c3&gt;</ept>インスタンスを返します、それは、<bpt i="4" x="4">&lt;c4&gt;</bpt>origin<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>size<ept i="5">&lt;/c5&gt;</ept>プロパティが両方ともそれらのプロパティ定義からの省略時の値の<bpt i="6" x="6">&lt;c6&gt;</bpt>Point(x: 0.0、y: 0.0)<ept i="6">&lt;/c6&gt;</ept>と<bpt i="7" x="7">&lt;c7&gt;</bpt>Size(width: 0.0、height: 0.0)<ept i="7">&lt;/c7&gt;</ept>で初期化されるものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Calls to a throwing function or method must be wrapped in a <bpt i="0" x="0">&lt;c0&gt;</bpt>try<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>try!<ept i="1">&lt;/c1&gt;</ept> expression (that is, in the scope of a <bpt i="2" x="2">&lt;c2&gt;</bpt>try<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>try!<ept i="3">&lt;/c3&gt;</ept> operator).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スロー関数またはメソッドに対する呼び出しは、<bpt i="0" x="0">&lt;c0&gt;</bpt>try<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>try!<ept i="1">&lt;/c1&gt;</ept>式の中に（即ち、<bpt i="2" x="2">&lt;c2&gt;</bpt>try<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>try!<ept i="3">&lt;/c3&gt;</ept>演算子のスコープの中に）包まれなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Capture Lists</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キャプチャリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Capturing Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値を捕獲する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Capturing by reference ensures that <bpt i="6" x="6">&lt;c6&gt;</bpt>runningTotal<ept i="6">&lt;/c6&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt>amount<ept i="7">&lt;/c7&gt;</ept> do not disappear when the call to <bpt i="8" x="8">&lt;c8&gt;</bpt>makeIncrementer<ept i="8">&lt;/c8&gt;</ept> ends, and also ensures that <bpt i="9" x="9">&lt;c9&gt;</bpt>runningTotal<ept i="9">&lt;/c9&gt;</ept> is available the next time the <bpt i="10" x="10">&lt;c10&gt;</bpt>incrementer<ept i="10">&lt;/c10&gt;</ept> function is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照を捕獲することは、<bpt i="8" x="8">&lt;c8&gt;</bpt>makeIncrementer<ept i="8">&lt;/c8&gt;</ept>への呼び出しが終わる時に<bpt i="6" x="6">&lt;c6&gt;</bpt>runningTotal<ept i="6">&lt;/c6&gt;</ept>と<bpt i="7" x="7">&lt;c7&gt;</bpt>amount<ept i="7">&lt;/c7&gt;</ept>が消えてなくならないことを確かにします、そしてまた<bpt i="10" x="10">&lt;c10&gt;</bpt>incrementer<ept i="10">&lt;/c10&gt;</ept>関数が呼ばれる次の時に<bpt i="9" x="9">&lt;c9&gt;</bpt>runningTotal<ept i="9">&lt;/c9&gt;</ept>が利用可能であることを確実にもします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Carriage return (<bpt i="0" x="0">&lt;c0&gt;</bpt>\r<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キャリッジリターン「復帰文字」（<bpt i="0" x="0">&lt;c0&gt;</bpt>\r<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Cases can match many different patterns, including interval matches, tuples, and casts to a specific type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらのケース節は、区間マッチ、タプル、そして特定の型への型キャストを含む、多くの異なるパターンにマッチすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Casting does not actually modify the instance or change its values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キャストは、実際にインスタンスを修正したり、その値を変えたりしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Chaining on Methods with Optional Return Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの戻り値をもつメソッド上で連鎖する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Change <bpt i="0" x="0">&lt;c0&gt;</bpt>optionalName<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>optionalName<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>に変えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Change the printer name to <bpt i="0" x="0">&lt;c0&gt;</bpt>"Never Has Toner"<ept i="0">&lt;/c0&gt;</ept>, so that the <bpt i="1" x="1">&lt;c1&gt;</bpt>send(job:toPrinter:)<ept i="1">&lt;/c1&gt;</ept> function throws an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プリンタ名を<bpt i="0" x="0">&lt;c0&gt;</bpt>"Never Has Toner"<ept i="0">&lt;/c0&gt;</ept>に変更してください、そうすると<bpt i="1" x="1">&lt;c1&gt;</bpt>send(job:toPrinter:)<ept i="1">&lt;/c1&gt;</ept>関数はエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Changing the value of <bpt i="2" x="2">&lt;c2&gt;</bpt>currentDirection<ept i="2">&lt;/c2&gt;</ept> thereafter does not affect the copy of the original value that was stored in <bpt i="3" x="3">&lt;c3&gt;</bpt>rememberedDirection<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それ以降に<bpt i="2" x="2">&lt;c2&gt;</bpt>currentDirection<ept i="2">&lt;/c2&gt;</ept>の値を変えることは、本来の値のコピーに、<bpt i="3" x="3">&lt;c3&gt;</bpt>rememberedDirection<ept i="3">&lt;/c3&gt;</ept>に保存されたものに影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Changing the value of properties defined by the superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラスによって定義されるプロパティの値を変える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Checking API Availability</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>API有効性の確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Checking Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型を調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Checking for Protocol Conformance</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル準拠の確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Checking for an empty string value (such as <bpt i="0" x="0">&lt;c0&gt;</bpt>""<ept i="0">&lt;/c0&gt;</ept> rather than <bpt i="1" x="1">&lt;c1&gt;</bpt>"Giraffe"<ept i="1">&lt;/c1&gt;</ept>) is not the same as checking for <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept> to indicate the absence of an <bpt i="3" x="3">&lt;e3&gt;</bpt>optional<ept i="3">&lt;/e3&gt;</ept> <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の文字列値（例えば<bpt i="1" x="1">&lt;c1&gt;</bpt>"Giraffe"<ept i="1">&lt;/c1&gt;</ept>といったものでなく<bpt i="0" x="0">&lt;c0&gt;</bpt>""<ept i="0">&lt;/c0&gt;</ept>）について調べることは、<bpt i="3" x="3">&lt;e3&gt;</bpt>オプショナル<ept i="3">&lt;/e3&gt;</ept>の<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>値の不在を指し示す<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>について調べることと同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Checking for and casting to a protocol follows exactly the same syntax as checking for and casting to a type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコルについて調べたりそれにキャストすることは、ある型について調べたりキャストするのと正確に同じ構文に従います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Checking the <bpt i="0" x="0">&lt;c0&gt;</bpt>frameRate<ept i="0">&lt;/c0&gt;</ept> property of <bpt i="1" x="1">&lt;c1&gt;</bpt>tenEighty<ept i="1">&lt;/c1&gt;</ept> shows that it correctly reports the new frame rate of <bpt i="2" x="2">&lt;c2&gt;</bpt>30.0<ept i="2">&lt;/c2&gt;</ept> from the underlying <bpt i="3" x="3">&lt;c3&gt;</bpt>VideoMode<ept i="3">&lt;/c3&gt;</ept> instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>tenEighty<ept i="1">&lt;/c1&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>frameRate<ept i="0">&lt;/c0&gt;</ept>プロパティを調べてみると、それが根底にある<bpt i="3" x="3">&lt;c3&gt;</bpt>VideoMode<ept i="3">&lt;/c3&gt;</ept>インスタンス由来の新しいフレームレートの<bpt i="2" x="2">&lt;c2&gt;</bpt>30.0<ept i="2">&lt;/c2&gt;</ept>を正しく報告することがわかります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Checking the <bpt i="0" x="0">&lt;c0&gt;</bpt>width<ept i="0">&lt;/c0&gt;</ept> property of <bpt i="1" x="1">&lt;c1&gt;</bpt>cinema<ept i="1">&lt;/c1&gt;</ept> shows that it has indeed changed to be <bpt i="2" x="2">&lt;c2&gt;</bpt>2048<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>cinema<ept i="1">&lt;/c1&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>width<ept i="0">&lt;/c0&gt;</ept>プロパティをチェックすると、<bpt i="2" x="2">&lt;c2&gt;</bpt>2048<ept i="2">&lt;/c2&gt;</ept>になるように変えられたことを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Chess is played on an 8 x 8 board, with alternating black and white squares.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>チェスは、黒と白の正方形を互い違いに持つ、８×８マスの盤上で行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Choosing Between Classes and Structures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスと構造体のどちらかを選ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Clarified the full list of characters that can be used when defining <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Custom Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>あつらえの演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を定義するとき使われることが出来る文字の完全なリストをわかりやすくしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class <bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept> is a subclass of <bpt i="3" x="3">&lt;c3&gt;</bpt>A<ept i="3">&lt;/c3&gt;</ept>, with a reduced access level of “internal”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス<bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>A<ept i="3">&lt;/c3&gt;</ept>のサブクラスです、そして減少させられたアクセス水準の「内部」を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class Implementations of Protocol Initializer Requirements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ要件プロトコルのクラス実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class Inheritance and Initialization</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス継承と初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class and Structure Instances</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスと構造体のインスタンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class and structure initialization is described in more detail in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Initialization<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスと構造体の初期化は、更に詳細に<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>初期化<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class declarations are declared using the <bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept> keyword and have the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス宣言は、キーワード<bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept>を使用して宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class declarations can’t contain protocol declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス宣言は、プロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class definitions can have at most one deinitializer per class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス定義は、クラスごとに多くとも１つのデイニシャライザしか持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class initialization in Swift is a two-phase process.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでのクラス初期化は、２段階処理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class members with public access, or any more restrictive access level, can be overridden by subclasses only within the module where they’re defined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>公開アクセス、または何らかのより制限のあるアクセス水準を持つクラスメンバーは、それらが定義されるところのモジュール内部でのみ、サブクラスによってオーバライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class types can inherit from a single superclass and conform to any number of protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス型は、１つのスーパークラスから継承することができ、任意の数のプロトコルに準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class-Only Protocols</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス専用プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes Are Reference Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスは、参照型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes and Structures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスと構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes and structures <bpt i="0" x="0">&lt;e0&gt;</bpt>must<ept i="0">&lt;/e0&gt;</ept> set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスと構造体は、それらの保存プロパティの全てを、そのクラスや構造体のインスタンスがつくられる時には適切な初期値に設定する<bpt i="0" x="0">&lt;e0&gt;</bpt>必要があります<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes and structures can also provide implementations of the standard <bpt i="0" x="0">&lt;e0&gt;</bpt>unary operators<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスと構造体は、また、標準の<bpt i="0" x="0">&lt;e0&gt;</bpt>単項演算子<ept i="0">&lt;/e0&gt;</ept>の実施も提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes and structures can provide their own implementations of existing operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスと構造体は、既存の演算子のそれら独自の実装を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes and structures have a similar definition syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスと構造体は、類似した定義構文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes and structures in Swift have many things in common.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでのクラスと構造体は、多くのものを共通して持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes are reference types; instances of a class are referred to, rather than copied, when assigned to variables or constants, or when passed as arguments to a function call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスは、参照型です；クラスのインスタンスは、変数または定数に代入されるとき、または関数呼び出しに対する引数として渡されるときに、コピーされるのではなく、参照されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes can also add property observers to inherited properties in order to be notified when the value of a property changes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスはまた、プロパティの値が変化するとき通知されるように継承されたプロパティにプロパティオブザーバー（監視者）を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes do not have a default memberwise initializer, and so the <bpt i="0" x="0">&lt;c0&gt;</bpt>Food<ept i="0">&lt;/c0&gt;</ept> class provides a designated initializer that takes a single argument called <bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのクラスには省略時のメンバー関連イニシャライザがありません、なので、<bpt i="0" x="0">&lt;c0&gt;</bpt>Food<ept i="0">&lt;/c0&gt;</ept>クラスは<bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept>と呼ばれる１つの引数をとる指定イニシャライザを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes have additional capabilities that structures do not:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスは、構造体がそうしない追加の能力を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes in Swift can call and access methods, properties, and subscripts belonging to their superclass and can provide their own overriding versions of those methods, properties, and subscripts to refine or modify their behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのクラスは、それらのスーパークラスに属しているメソッド、プロパティ、そして添え字の呼び出しやアクセスが行えて、それらのメソッド、プロパティ、そして添え字の独自の優先的に使われる改変板を提供することでそれらの挙動の洗練や修正を行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes may also use the <bpt i="3" x="3">&lt;c3&gt;</bpt>class<ept i="3">&lt;/c3&gt;</ept> keyword to allow subclasses to override the superclass’s implementation of that method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスはまた<bpt i="3" x="3">&lt;c3&gt;</bpt>class<ept i="3">&lt;/c3&gt;</ept>キーワードを使って、サブクラスにスーパークラスのもつそのメソッドの実装のオーバーライドを許可することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes may mark type computed properties with the <bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept> declaration modifier instead to allow subclasses to override the superclass’s implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスは型計算プロパティを代わりに<bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept>宣言修飾子で印をつけて、サブクラスがスーパークラスの実装をオーバーライドすることを許可することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes tend to have very few designated initializers, and it is quite common for a class to have only one.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスはほとんど指定イニシャライザを持たない傾向があります、そして、あるクラスが１つだけしか持たないことは全く普通です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes that implement this method declare the method with the <bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのメソッドを実装するクラスは、このメソッドを<bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept>修飾子を使って宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes with public access, or any more restrictive access level, can be subclassed only within the module where they’re defined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>公開アクセス、または何らかのより制限のあるアクセス水準を持つクラスは、それらが定義されるところのモジュール内部でのみ、サブクラスを作成されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes you define without specifying a superclass automatically become base classes for you to build upon.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラスを指定することなくあなたが定義するクラスは、自動的に基盤クラスになり、あなたが基礎とするために使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes, enumerations, and structs can all adopt protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス、列挙、そして構造体は、全てそのようなプロトコルを採用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes, however, can inherit from other classes, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Inheritance<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスはしかし、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>継承<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、他のクラスから継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれのクラス、構造体、および列挙は、すべてインスタンスメソッドを定義することができます、それは、ある定められた型のあるインスタンスで働くために特定の作業や機能性をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes, structures, and enumerations can also define type methods, which are associated with the type itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス、構造体、および列挙は、また、型メソッドを定義することができます、それは型それ自身に結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes, structures, and enumerations can define <bpt i="0" x="0">&lt;e0&gt;</bpt>subscripts<ept i="0">&lt;/e0&gt;</ept>, which are shortcuts for accessing the member elements of a collection, list, or sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス、構造体、および列挙は、<bpt i="0" x="0">&lt;e0&gt;</bpt>添え字<ept i="0">&lt;/e0&gt;</ept>を定義することができます、それは、コレクション、リスト、またはシーケンスのメンバー要素にアクセスするための近道です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closed Range Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>完結範囲演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closed ranges are also available, by using <bpt i="0" x="0">&lt;c0&gt;</bpt>stride(from:through:by:)<ept i="0">&lt;/c0&gt;</ept> instead:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>完結範囲も利用可能です、代わりに<bpt i="0" x="0">&lt;c0&gt;</bpt>stride(from:through:by:)<ept i="0">&lt;/c0&gt;</ept>を使うことで：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closure Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closure Expression Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャ式構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closure Expressions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closure expression syntax has the following general form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャ式構文は、以下の一般的な形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャ式は、それの周囲の前後関係から値を捕獲することができる軽快な構文で書かれる無名のクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closure expressions provide several syntax optimizations for writing closures in a shortened form without loss of clarity or intent.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャ式は、いくつかの構文最適化を、ある省略形式で明快さや意図の損失なしでクロージャを書くために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closures Are Reference Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャは参照型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closures can capture and store references to any constants and variables from the context in which they are defined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャは、それが定義されている前後関係からのあらゆる定数や変数への参照を捕獲して、保存することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおけるクロージャは、CとObjective-Cでのブロックに、そして他のプログラミング言語でのラムダ（lambda）に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closures take one of three forms:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャは、３つの書式のうちの１つをとります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Code Blocks</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コード・ブロック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Code written at global scope is used as the entry point for the program, so you don’t need a <bpt i="0" x="0">&lt;c0&gt;</bpt>main()<ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>グローバルなスコープで書かれるコードは、プログラムのエントリポイントとして使われるので、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>main()<ept i="0">&lt;/c0&gt;</ept>関数を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Collection Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクション型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Collections of Protocol Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル型のコレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Combining Logical Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理演算子を結合する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comments</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comments are ignored by the Swift compiler when your code is compiled.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコードがコンパイルされるとき、コメントはスウィフトのコンパイラによって無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comments are not statements and do not cause a <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> case to be ignored.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コメントは、文でなくて、<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>ケース節を無視されるようにはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comments are treated as whitespace by the compiler.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コメントは、コンパイラによって空白とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comments can contain additional formatting and markup, as described in <bpt i="0" x="0">&lt;e0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Markup Formatting Reference<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コメントは、さらに追加の書式とマークアップを含む事が、<bpt i="0" x="0">&lt;e0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>マークアップ書式リファレンス<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/e0&gt;</ept>で記述されるように可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comments in Swift are very similar to comments in C. Single-line comments begin with two forward-slashes (<bpt i="0" x="0">&lt;c0&gt;</bpt>//<ept i="0">&lt;/c0&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのコメントは、Cのコメントに非常に似ています。一行コメントは２つのスラッシュで始まります（<bpt i="0" x="0">&lt;c0&gt;</bpt>//<ept i="0">&lt;/c0&gt;</ept>）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compare the return value from the <bpt i="4" x="4">&lt;c4&gt;</bpt>printNumberOfRooms<ept i="4">&lt;/c4&gt;</ept> call against <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept> to see if the method call was successful:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>printNumberOfRooms<ept i="4">&lt;/c4&gt;</ept>呼び出しからの戻り値を<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>と比較して、そのメソッドがうまく呼び出されたか見てください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Classes and Structures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスと構造体を比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparing Strings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列を比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparison Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>比較演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparison operators are often used in conditional statements, such as the <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>比較演算子は、条件文においてしばしば使われます、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文など：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Comparisons like <bpt i="2" x="2">&lt;c2&gt;</bpt>i == 1<ept i="2">&lt;/c2&gt;</ept> are discussed in <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Basic Operators<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>i == 1<ept i="2">&lt;/c2&gt;</ept>のような比較は<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>「基本の演算子」<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compiler Control Statements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラ制御文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compiler control statements allow the program to change aspects of the compiler’s behavior and include a conditional compilation block and a line control statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラ制御文は、プログラムにコンパイラの挙動のいろいろな面を変更できるようにしていて、条件コンパイルブロックと行制御文を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compiler control statements allow the program to change aspects of the compiler’s behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラ制御文は、プログラムに、コンパイラの挙動の様々な面を変更できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compound Assignment Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複合代入演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compound Cases</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複合ケース節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Compound cases can also include value bindings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複合ケース節はまた、値束縛を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Computed Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Computed Variables and Computed Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算変数と計算プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Computed properties are provided by classes, structures, and enumerations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算プロパティは、クラス、構造体、および列挙で提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Computed type properties are always declared as variable properties, in the same way as computed instance properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算型プロパティは、計算インスタンスプロパティと同じ方法で、常に変数プロパティとして宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Computed variables calculate their value, rather than storing it, and they are written in the same way as computed properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算変数は値を計算します、それの貯蔵ではなくて、そして計算プロパティと同じ方法で書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Concatenating Strings and Characters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列と文字の連結</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conditional Compilation Block</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>条件コンパイルブロック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conditional Statements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>条件つきの文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conditional compilation blocks that contain multiple branches have the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数の分岐を含む条件コンパイルブロックは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conditional statements such as the <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement are covered in more detail in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Control Flow<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文のような条件つきの文は、更に詳細に<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>「制御の流れ」<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conform to protocols to provide standard functionality of a certain kind</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特定の種類の標準の機能性を提供するために、プロトコルに準拠します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Consider drawing the tick marks for every minute on a watch face.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>時計盤上のすべての分表示に目盛りを描画することを考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Consider the <bpt i="0" x="0">&lt;c0&gt;</bpt>Hamster<ept i="0">&lt;/c0&gt;</ept> structure from before, which conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept> protocol, and an array of <bpt i="2" x="2">&lt;c2&gt;</bpt>Hamster<ept i="2">&lt;/c2&gt;</ept> values:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前の<bpt i="0" x="0">&lt;c0&gt;</bpt>Hamster<ept i="0">&lt;/c0&gt;</ept>構造体を考えてください、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠します、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>Hamster<ept i="2">&lt;/c2&gt;</ept>値の配列です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Consider this example, which uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>Resolution<ept i="0">&lt;/c0&gt;</ept> structure from the previous example:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例を考慮してください、それは、前の例から<bpt i="0" x="0">&lt;c0&gt;</bpt>Resolution<ept i="0">&lt;/c0&gt;</ept>構造体を使用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constant Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constant and variable names can contain almost any character, including Unicode characters:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数と変数の名前は、ユニコード文字を含めて、ほとんどどんな文字でも含むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constant and variable names can’t contain whitespace characters, mathematical symbols, arrows, private-use (or invalid) Unicode code points, or line- and box-drawing characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数と変数の名前は、空白文字、数学記号、矢印、私的使用（または無効な）Unicodeコード点、または書式印刷文字および罫線素片を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constant declarations are declared using the <bpt i="1" x="1">&lt;c1&gt;</bpt>let<ept i="1">&lt;/c1&gt;</ept> keyword and have the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数宣言は、<bpt i="1" x="1">&lt;c1&gt;</bpt>let<ept i="1">&lt;/c1&gt;</ept>キーワードを使用して宣言され、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constant declarations are not computed properties and therefore do not have getters or setters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数宣言は、計算プロパティではなく、したがって、ゲッターまたはセッターを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constant properties must always have a value <bpt i="1" x="1">&lt;e1&gt;</bpt>before<ept i="1">&lt;/e1&gt;</ept> initialization completes, and therefore cannot be declared as lazy.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数プロパティは常に値を、初期化が完了する<bpt i="1" x="1">&lt;e1&gt;</bpt>前に<ept i="1">&lt;/e1&gt;</ept>持たなければなりません、それゆえに遅延であると宣言されることが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constants and Variables</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数と変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constants and variables are still explicitly typed, but much of the work of specifying their type is done for you.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数と変数は依然として明確に型を決められます、しかしそれらの型を指定する行為のほとんどは、あなたのために行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constants and variables associate a name (such as <bpt i="0" x="0">&lt;c0&gt;</bpt>maximumNumberOfLoginAttempts<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>welcomeMessage<ept i="1">&lt;/c1&gt;</ept>) with a value of a particular type (such as the number <bpt i="2" x="2">&lt;c2&gt;</bpt>10<ept i="2">&lt;/c2&gt;</ept> or the string <bpt i="3" x="3">&lt;c3&gt;</bpt>"Hello"<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数と変数は、ひとつの名前（例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>maximumNumberOfLoginAttempts<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>welcomeMessage<ept i="1">&lt;/c1&gt;</ept>など）を特定の型のひとつの値（例えば数<bpt i="2" x="2">&lt;c2&gt;</bpt>10<ept i="2">&lt;/c2&gt;</ept>または文字列<bpt i="3" x="3">&lt;c3&gt;</bpt>"Hello"<ept i="3">&lt;/c3&gt;</ept>など）と結びつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constants and variables created with optional binding in an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement are available only within the body of the <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文の中でオプショナル束縛を使って作成された定数と変数は、その<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>文の本文の内部でのみ利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constants and variables must be declared before they’re used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数と変数は、それらが使われる前に宣言されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constants and variables of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept> can now contain function instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept>の定数と変数は、今では関数インスタンスを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constants and variables of type <bpt i="2" x="2">&lt;c2&gt;</bpt>Barcode<ept i="2">&lt;/c2&gt;</ept> can store either a <bpt i="3" x="3">&lt;c3&gt;</bpt>.upc<ept i="3">&lt;/c3&gt;</ept> or a <bpt i="4" x="4">&lt;c4&gt;</bpt>.qrCode<ept i="4">&lt;/c4&gt;</ept> (together with their associated values), but they can only store one of them at any given time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="2" x="2">&lt;c2&gt;</bpt>Barcode<ept i="2">&lt;/c2&gt;</ept>の定数と変数は、<bpt i="3" x="3">&lt;c3&gt;</bpt>.upc<ept i="3">&lt;/c3&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt>.qrCode<ept i="4">&lt;/c4&gt;</ept>のどちらでも（それらの関連値と共に）格納することができます、しかしそれらはどんな時でもそれらの１つを保存することだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constants can now be declared without being initialized in local function scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数は今では初期化されることなくローカル関数のスコープ内で宣言されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constants, Variables, Properties, and Subscripts</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数、変数、プロパティ，そして添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Continue Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>継続文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Control Flow</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>制御の流れ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Control Transfer Statements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>制御移動文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Control flow in a loop statement can be changed by a <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept> statement and a <bpt i="1" x="1">&lt;c1&gt;</bpt>continue<ept i="1">&lt;/c1&gt;</ept> statement and is discussed in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Break Statement<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> and <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Continue Statement<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループ文の中の制御の流れは、<bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>文そして<bpt i="1" x="1">&lt;c1&gt;</bpt>continue<ept i="1">&lt;/c1&gt;</ept>文によって変えられることができます、そして下記の<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ブレーク文<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>と<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>継続文<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Control flow in an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement or a <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement can be changed by a <bpt i="2" x="2">&lt;c2&gt;</bpt>break<ept i="2">&lt;/c2&gt;</ept> statement and is discussed in <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Break Statement<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文または<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文の中の制御の流れは、<bpt i="2" x="2">&lt;c2&gt;</bpt>break<ept i="2">&lt;/c2&gt;</ept>文によって変えられることができます、それは下記の<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>ブレーク文<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Control flow statements are used to control the flow of execution in a program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>制御の流れ文は、プログラムにおいて実行の流れを制御するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Control transfer statements are discussed in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Control Transfer Statements<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>制御移動文は、下の<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>制御移動文<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Control transfer statements can change the order in which code in your program is executed by unconditionally transferring program control from one piece of code to another.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>制御移動文は、あなたのプログラムの中のコードが実行される順番を、プログラム制御を１つのコード片から他のものまで無条件に移すことによって変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Convenience initializers are written in the same style, but with the <bpt i="0" x="0">&lt;c0&gt;</bpt>convenience<ept i="0">&lt;/c0&gt;</ept> modifier placed before the <bpt i="1" x="1">&lt;c1&gt;</bpt>init<ept i="1">&lt;/c1&gt;</ept> keyword, separated by a space:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>便宜イニシャライザは同じ形式で書かれます、しかし<bpt i="0" x="0">&lt;c0&gt;</bpt>convenience<ept i="0">&lt;/c0&gt;</ept>修飾子が<bpt i="1" x="1">&lt;c1&gt;</bpt>init<ept i="1">&lt;/c1&gt;</ept>キーワードの前に空白で区切って置かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Convenience initializers can delegate the initialization process to another convenience initializer or to one of the class’s designated initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>便宜イニシャライザは、初期化プロセスを別の便宜イニシャライザに、またはそのクラスの指定イニシャライザのうちの１つに委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Convenience initializers can’t call a superclass’s initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>便宜イニシャライザは、スーパークラスのイニシャライザを呼ぶことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Convenience initializers must always delegate <bpt i="0" x="0">&lt;e0&gt;</bpt>across<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>便宜イニシャライザは、常に<bpt i="0" x="0">&lt;e0&gt;</bpt>横に<ept i="0">&lt;/e0&gt;</ept>委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conversely, <bpt i="0" x="0">&lt;c0&gt;</bpt>LATIN CAPITAL LETTER A<ept i="0">&lt;/c0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>U+0041<ept i="1">&lt;/c1&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt>"A"<ept i="2">&lt;/c2&gt;</ept>), as used in English, is <bpt i="3" x="3">&lt;e3&gt;</bpt>not<ept i="3">&lt;/e3&gt;</ept> equivalent to <bpt i="4" x="4">&lt;c4&gt;</bpt>CYRILLIC CAPITAL LETTER A<ept i="4">&lt;/c4&gt;</ept> (<bpt i="5" x="5">&lt;c5&gt;</bpt>U+0410<ept i="5">&lt;/c5&gt;</ept>, or <bpt i="6" x="6">&lt;c6&gt;</bpt>"А"<ept i="6">&lt;/c6&gt;</ept>), as used in Russian.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>反対に、英語で使われるような、<bpt i="0" x="0">&lt;c0&gt;</bpt>LATIN CAPITAL LETTER A<ept i="0">&lt;/c0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>U+0041<ept i="1">&lt;/c1&gt;</ept>、または<bpt i="2" x="2">&lt;c2&gt;</bpt>"A"<ept i="2">&lt;/c2&gt;</ept>）は、ロシアで使われるような、<bpt i="4" x="4">&lt;c4&gt;</bpt>CYRILLIC CAPITAL LETTER A<ept i="4">&lt;/c4&gt;</ept>（<bpt i="5" x="5">&lt;c5&gt;</bpt>U+0410<ept i="5">&lt;/c5&gt;</ept>、または<bpt i="6" x="6">&lt;c6&gt;</bpt>"А"<ept i="6">&lt;/c6&gt;</ept>）と等しく<bpt i="3" x="3">&lt;e3&gt;</bpt>ありません<ept i="3">&lt;/e3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conversely, always give properties and methods <bpt i="6" x="6">&lt;c6&gt;</bpt>lowerCamelCase<ept i="6">&lt;/c6&gt;</ept> names (such as <bpt i="7" x="7">&lt;c7&gt;</bpt>frameRate<ept i="7">&lt;/c7&gt;</ept> and <bpt i="8" x="8">&lt;c8&gt;</bpt>incrementCount<ept i="8">&lt;/c8&gt;</ept>) to differentiate them from type names.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>逆に、それらを型名と区別するために、常に、プロパティとメソッドに<bpt i="6" x="6">&lt;c6&gt;</bpt>lowerCamelCase ローワーキャメルケース名<ept i="6">&lt;/c6&gt;</ept>（例えば<bpt i="7" x="7">&lt;c7&gt;</bpt>frameRate<ept i="7">&lt;/c7&gt;</ept>や<bpt i="8" x="8">&lt;c8&gt;</bpt>incrementCount<ept i="8">&lt;/c8&gt;</ept>）を与えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conversely, define a capture as a weak reference when the captured reference may become <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> at some point in the future.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>逆に、捕らえられた参照が将来どこかの時点で<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>になるかもしれないときは、捕獲を弱い参照として定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conversely, if you write a subclass initializer that matches a superclass <bpt i="0" x="0">&lt;e0&gt;</bpt>convenience<ept i="0">&lt;/e0&gt;</ept> initializer, that superclass convenience initializer can never be called directly by your subclass, as per the rules described above in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Initializer Delegation for Class Types<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>逆に言えば、上記の<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>クラス型のためのイニシャライザ委任<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述される規則どおりに、あなたがスーパークラスの<bpt i="0" x="0">&lt;e0&gt;</bpt>便宜<ept i="0">&lt;/e0&gt;</ept>イニシャライザに一致するサブクラスのイニシャライザを書くならば、そのスーパークラスの便宜イニシャライザは直接にあなたのサブクラスによって呼び出されることが決してできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conversely, set <bpt i="8" x="8">&lt;c8&gt;</bpt>b<ept i="8">&lt;/c8&gt;</ept> is a <bpt i="9" x="9">&lt;e9&gt;</bpt>subset<ept i="9">&lt;/e9&gt;</ept> of set <bpt i="10" x="10">&lt;c10&gt;</bpt>a<ept i="10">&lt;/c10&gt;</ept>, because all elements in <bpt i="11" x="11">&lt;c11&gt;</bpt>b<ept i="11">&lt;/c11&gt;</ept> are also contained by <bpt i="12" x="12">&lt;c12&gt;</bpt>a<ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>逆に言えば、集合<bpt i="8" x="8">&lt;c8&gt;</bpt>b<ept i="8">&lt;/c8&gt;</ept>は集合<bpt i="10" x="10">&lt;c10&gt;</bpt>a<ept i="10">&lt;/c10&gt;</ept>の<bpt i="9" x="9">&lt;e9&gt;</bpt>下位集合<ept i="9">&lt;/e9&gt;</ept>です、<bpt i="11" x="11">&lt;c11&gt;</bpt>b<ept i="11">&lt;/c11&gt;</ept>の要素すべては<bpt i="12" x="12">&lt;c12&gt;</bpt>a<ept i="12">&lt;/c12&gt;</ept>によってまた含まれるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conversions between integer and floating-point numeric types must be made explicit:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数と浮動小数点数型の間の変換は、明示的に行われる必要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converting Errors to Optional Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーをオプショナルの値に変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Corrected the discussion of the <bpt i="0" x="0">&lt;c0&gt;</bpt>@NSApplicationMain<ept i="0">&lt;/c0&gt;</ept> attribute in the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Declaration Attributes<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@NSApplicationMain<ept i="0">&lt;/c0&gt;</ept>属性の解説を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>宣言属性<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>の節において訂正した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Counting Characters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字を数える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create a constant with an explicit type of <bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept> and a value of <bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>明確に<bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>の型で値<bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept>の定数をつくってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create an instance of a class by putting parentheses after the class name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス名の後に丸括弧を置くことによって、クラスのインスタンスをつくってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create arrays and dictionaries using brackets (<bpt i="0" x="0">&lt;c0&gt;</bpt>[]<ept i="0">&lt;/c0&gt;</ept>), and access their elements by writing the index or key in brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>角括弧（<bpt i="0" x="0">&lt;c0&gt;</bpt>[]<ept i="0">&lt;/c0&gt;</ept>）を使って配列および辞書（連想配列）を作ってください、そしてインデックスまたはキーを角括弧の中に記述することによってそれらの要素にアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create convenience initializers whenever a shortcut to a common initialization pattern will save time or make initialization of the class clearer in intent.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>共通の初期化の繰り返しに対する近道が時間を節約したり、そのクラスの初期化を意図においてより明白にするときはいつでも、便宜イニシャライザをつくってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a Dictionary with a Dictionary Literal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書を辞書リテラルで作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating a Set with an Array Literal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合を配列リテラルで作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating an Array by Adding Two Arrays Together</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの配列を一緒にすることで１つの配列を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating an Array with a Default Value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列を１つの初期値で作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating an Array with an Array Literal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列を配列リテラルで作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating an Empty Array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の配列の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating an Empty Dictionary</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の辞書を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Creating and Initializing an Empty Set</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の集合の作成と初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Custom Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あつらえの演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Custom Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あつらえの型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Custom classes and structures do not receive a default implementation of the <bpt i="0" x="0">&lt;e0&gt;</bpt>equivalence operators<ept i="0">&lt;/e0&gt;</ept>, known as the “equal to” operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>) and “not equal to” operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あつらえのクラスと構造体は、「同等」演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>）そして「不等」演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>）として知られる、<bpt i="0" x="0">&lt;e0&gt;</bpt>同等演算子<ept i="0">&lt;/e0&gt;</ept>たちの省略時の実装を受け取りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Custom infix operators each belong to a precedence group.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あつらえの接中辞演算子それぞれは、ある優先順位グループに属しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Custom initializers can be assigned an access level less than or equal to the type that they initialize.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あつらえのイニシャライザは、それらが初期化する型と同じか低いアクセス水準を割り当てられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Custom operators can begin with one of the ASCII characters <bpt i="0" x="0">&lt;c0&gt;</bpt>/<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>=<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>-<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>+<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>!<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>*<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>%<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>&lt;<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>&gt;<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>&amp;<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>|<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>^<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>?<ept i="12">&lt;/c12&gt;</ept>, or <bpt i="13" x="13">&lt;c13&gt;</bpt>~<ept i="13">&lt;/c13&gt;</ept>, or one of the Unicode characters defined in the grammar below (which include characters from the <bpt i="14" x="14">&lt;e14&gt;</bpt>Mathematical Operators<ept i="14">&lt;/e14&gt;</ept>, <bpt i="15" x="15">&lt;e15&gt;</bpt>Miscellaneous Symbols<ept i="15">&lt;/e15&gt;</ept>, and <bpt i="16" x="16">&lt;e16&gt;</bpt>Dingbats<ept i="16">&lt;/e16&gt;</ept> Unicode blocks, among others).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あつらえの演算子は、ASCII文字<bpt i="0" x="0">&lt;c0&gt;</bpt>/<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>=<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>-<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>+<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>!<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>*<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>%<ept i="6">&lt;/c6&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>&lt;<ept i="7">&lt;/c7&gt;</ept>、<bpt i="8" x="8">&lt;c8&gt;</bpt>&gt;<ept i="8">&lt;/c8&gt;</ept>、<bpt i="9" x="9">&lt;c9&gt;</bpt>&amp;<ept i="9">&lt;/c9&gt;</ept>、<bpt i="10" x="10">&lt;c10&gt;</bpt>|<ept i="10">&lt;/c10&gt;</ept>、<bpt i="11" x="11">&lt;c11&gt;</bpt>^<ept i="11">&lt;/c11&gt;</ept>、<bpt i="12" x="12">&lt;c12&gt;</bpt>?<ept i="12">&lt;/c12&gt;</ept>、および<bpt i="13" x="13">&lt;c13&gt;</bpt>~<ept i="13">&lt;/c13&gt;</ept>のうちの１つ、または以下の文法において定義されるユニコード文字のうちの１つで始まります（それは<bpt i="14" x="14">&lt;e14&gt;</bpt>Mathematical Operators<ept i="14">&lt;/e14&gt;</ept>、<bpt i="15" x="15">&lt;e15&gt;</bpt>Miscellaneous Symbols<ept i="15">&lt;/e15&gt;</ept>、そして<bpt i="16" x="16">&lt;e16&gt;</bpt>Dingbats<ept i="16">&lt;/e16&gt;</ept>ユニコードブロックなどからの文字を含みます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Custom operators can now contain the <bpt i="0" x="0">&lt;c0&gt;</bpt>?<ept i="0">&lt;/c0&gt;</ept> character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あつらえの演算子は、今では<bpt i="0" x="0">&lt;c0&gt;</bpt>?<ept i="0">&lt;/c0&gt;</ept>文字を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Custom types state that they adopt a particular protocol by placing the protocol’s name after the type’s name, separated by a colon, as part of their definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あつらえの型は、それが特定のプロトコルを採用することを、型の名前の後に、コロンで区切って、それらの定義の一部としてプロトコルの名前を置くことによって示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Customizing Initialization</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化をカスタマイズする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Data types that are normally considered basic or primitive in other languages—such as types that represent numbers, characters, and strings—are actually named types, defined and implemented in the Swift standard library using structures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の言語で通常は基本的またはプリミティブであるとみなされるデータ型 ― 例えば数、文字、そして文字列を表す型 ― これらは実際に名前付きの型で、構造体を使用してスウィフト標準ライブラリにおいて定義および実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>DataImporter is a class to import data from an external file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（DataImporterは、データを外部ファイルからインポートするクラスです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Date</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>日付</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Debugging with Assertions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>表明を使ってデバッグする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decimal floating-point literals consist of a sequence of decimal digits followed by either a decimal fraction, a decimal exponent, or both.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>10進の浮動小数点リテラルは、一連の10進の桁に、小数部か10進の指数のどちらか、または両方が続くものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decimal floats can also have an optional <bpt i="1" x="1">&lt;e1&gt;</bpt>exponent<ept i="1">&lt;/e1&gt;</ept>, indicated by an uppercase or lowercase <bpt i="2" x="2">&lt;c2&gt;</bpt>e<ept i="2">&lt;/c2&gt;</ept>; hexadecimal floats must have an exponent, indicated by an uppercase or lowercase <bpt i="3" x="3">&lt;c3&gt;</bpt>p<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>10進浮動小数点はまた、任意に<bpt i="1" x="1">&lt;e1&gt;</bpt>指数<ept i="1">&lt;/e1&gt;</ept>を持つことができ、大文字か小文字の<bpt i="2" x="2">&lt;c2&gt;</bpt>e<ept i="2">&lt;/c2&gt;</ept>で示されます；16進浮動小数点は、指数を持つ必要があり、大文字か小文字の<bpt i="3" x="3">&lt;c3&gt;</bpt>p<ept i="3">&lt;/c3&gt;</ept>で示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Decimal literals contain the digits <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept> through <bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>10進のリテラルは、<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>から<bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept>までの桁を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declaration Attributes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declaration Attributes Used by Interface Builder</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インターフェイスビルダーで使用される宣言属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declaration Modifiers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言修飾子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declarations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declarations in a protocol extension’s body can’t be marked <bpt i="2" x="2">&lt;c2&gt;</bpt>final<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル拡張の本文中の宣言は、<bpt i="2" x="2">&lt;c2&gt;</bpt>final<ept i="2">&lt;/c2&gt;</ept>で印できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declarations marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>open<ept i="0">&lt;/c0&gt;</ept> access-level modifier can also be accessed and subclassed by code in a module that imports the module that contains that declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>open<ept i="0">&lt;/c0&gt;</ept>アクセス水準修飾子で印される宣言はまた、アクセスされることおよびサブクラスを作られることが、その宣言を含むモジュールをインポートするモジュール内のコードによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declarations marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>public<ept i="0">&lt;/c0&gt;</ept> access-level modifier can also be accessed (but not subclassed) by code in a module that imports the module that contains that declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>public<ept i="0">&lt;/c0&gt;</ept>アクセス水準修飾子で印される宣言はまた、アクセスされる（しかしサブクラスは作られない）ことが、その宣言を含むモジュールをインポートするモジュール内のコードによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declare a private member in an extension, and access that member from the original declaration in the same file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある非公開メンバをある拡張の中で宣言する、そしてそのメンバに対して同じファイル中のオリジナルの宣言からアクセスする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declare a private member in one extension, and access that member from another extension in the same file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある非公開メンバを一方の拡張の中で宣言する、そしてそのメンバに対して同じファイル中の別の拡張からアクセスする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declare a private member in the original declaration, and access that member from extensions in the same file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある非公開メンバをオリジナルの宣言の中で宣言する、そしてそのメンバに対して同じファイル中の拡張からアクセスする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declare extensions with the <bpt i="0" x="0">&lt;c0&gt;</bpt>extension<ept i="0">&lt;/c0&gt;</ept> keyword:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>extension<ept i="0">&lt;/c0&gt;</ept>キーワードによって拡張を宣言してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declaring Constants and Variables</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数と変数の宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declaring Protocol Adoption with an Extension</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張を使ってプロトコル採用を宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Default Access Levels</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時のアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Default Initializers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時のイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Default Memberwise Initializers for Structure Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体体型のための省略時のメンバー関連イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Default Parameter Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時のパラメータ値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Default Property Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時のプロパティ値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Default values, however, can’t be specified for method parameters within a protocol’s definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の値は、しかしながら、プロトコル定義の内部のメソッドパラメーターに対して指定されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defer Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>defer文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deferred actions are executed in the reverse of the order that they’re written in your source code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>延期された動作は、それらがあなたのソースコードに書かれた順序の逆に実行されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが捕らえるクロージャとインスタンスが常にお互いに言及して、常に同時に割り当て解除されるときは、クロージャにおいて捕獲を非所有者参照として定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Define and use new nested types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい入れ子にされた型を定義して、使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Define initializers to set up their initial state</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの初期状態を設定するために、イニシャライザを定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Define instance methods and type methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスメソッドと型メソッドを定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Define methods to provide functionality</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>機能性を提供するために、メソッドを定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Define properties to store values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値を格納するために、プロパティを定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Define subscripts</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字を定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Define subscripts to provide access to their values using subscript syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字構文を使ってそれらの値の利用を提供するために、添え字を定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Define the access level for an entity by placing one of the <bpt i="0" x="0">&lt;c0&gt;</bpt>open<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>public<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>internal<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>fileprivate<ept i="3">&lt;/c3&gt;</ept>, or <bpt i="4" x="4">&lt;c4&gt;</bpt>private<ept i="4">&lt;/c4&gt;</ept> modifiers before the entity’s introducer:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある実在にアクセス水準を定義するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>open<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>public<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>internal<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>fileprivate<ept i="3">&lt;/c3&gt;</ept>、または<bpt i="4" x="4">&lt;c4&gt;</bpt>private<ept i="4">&lt;/c4&gt;</ept>修飾子のうちの１つをその実在の導入子の前に置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defining Model Classes for Optional Chaining</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖のモデル・クラスを定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defining a Base Class</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基盤クラスを定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defining a Capture List</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>捕獲リストの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defining a Class Hierarchy for Type Casting</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型キャストのためにクラス階層を定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Defining and Calling Functions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数の定義と呼び出し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Definition Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定義構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deinitialization</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deinitializer Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライザ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deinitializers are called automatically, just before instance deallocation takes place.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライザは、インスタンスの割り当て解除が起こる直前に、自動的に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deinitializers are not called directly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライザは、直接に呼ばれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deinitializers are only available on class types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライザは、クラス型で利用可能なだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deinitializers enable an instance of a class to free up any resources it has assigned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライザは、クラスのインスタンスにそれが代入したどんなリソースでも解放するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deinitializers in Action</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライザの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Deinitializers take no parameters and have the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライザは、パラメータを取らない以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Delaying evaluation is useful for code that has side effects or is computationally expensive, because it lets you control when that code is evaluated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>評価を遅らせることは、副作用を持つまたは計算的に高くつくコードに対して有用です、なぜならそれがあなたに何時そのコードが評価されるかを制御させるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Delegation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>委任</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Delegation can be used to respond to a particular action, or to retrieve data from an external source without needing to know the underlying type of that source.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>委任は、特定の動作に応答したり、外部ソースからそのソースの根底の型を知る必要なしにデータを取り出したりするのに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Designated Initializers and Convenience Initializers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定イニシャライザと便宜イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Designated and Convenience Initializers in Action</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定および便宜イニシャライザの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Designated initializers and deinitializers must always be provided by the original class implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定イニシャライザとデイニシャライザは、常に最初のクラス実施によって提供されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Designated initializers are “funnel” points through which initialization takes place, and through which the initialization process continues up the superclass chain.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定イニシャライザは、「漏斗」地点です、そこを通して初期化が行われ、そこを通して初期化処理がスーパークラス連鎖を上って続いていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Designated initializers can be declared in the context of a class declaration only and therefore can’t be added to a class using an extension declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定イニシャライザは、クラス宣言の文脈においてのみ宣言されることができて、したがって拡張宣言を使ってあるクラスに加えられることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Designated initializers for classes are written in the same way as simple initializers for value types:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスのための指定イニシャライザは、値型のための単純なイニシャライザと同様に書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Designated initializers must always delegate <bpt i="0" x="0">&lt;e0&gt;</bpt>up<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定イニシャライザは、常に<bpt i="0" x="0">&lt;e0&gt;</bpt>上に<ept i="0">&lt;/e0&gt;</ept>委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Despite this simplicity of syntax, Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> type is a fast, modern string implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構文のこの単純さにもかかわらず、スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>型は、速く、現代的な文字列の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dictionaries</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dictionaries are an unordered collection, so their keys and values are iterated over in an arbitrary order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書は、順序付けられないコレクションです、なのでそのキーと値は気まぐれな順番で繰り返されていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dictionaries are unordered collections of key-value associations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書は、「キーと値」を結びつけたものの順番をつけられないコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dictionary Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dictionary Type Shorthand Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書型の略記構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Disabling Error Propagation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラー伝達を抑制する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの異なった状況を区別することは、プログラムにいくらかのエラーを解消すること、そしてなんらかのそれが解消できないエラーを利用者に伝えることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Division (<bpt i="0" x="0">&lt;c0&gt;</bpt>/<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>除算（<bpt i="0" x="0">&lt;c0&gt;</bpt>/<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>do文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not access the value that was passed as an in-out argument, even if the original argument is available in the current scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>in-out引数として渡された値にアクセスしないでください、たとえオリジナルの引数が現在のスコープで利用可能であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do not depend on the implementation of the call-by-reference optimization to try to keep the changes from being overwritten.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの変更を上書きされることから守ろうとして、参照呼び出しの最適化の実装に依存しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do this by placing an exclamation mark after the <bpt i="2" x="2">&lt;c2&gt;</bpt>init<ept i="2">&lt;/c2&gt;</ept> keyword (<bpt i="3" x="3">&lt;c3&gt;</bpt>init!<ept i="3">&lt;/c3&gt;</ept>) instead of a question mark.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを、疑問符ではなく、感嘆符を<bpt i="2" x="2">&lt;c2&gt;</bpt>init<ept i="2">&lt;/c2&gt;</ept>キーワードの後に置くこと（<bpt i="3" x="3">&lt;c3&gt;</bpt>init!<ept i="3">&lt;/c3&gt;</ept>）によって行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Do this by writing the <bpt i="1" x="1">&lt;c1&gt;</bpt>final<ept i="1">&lt;/c1&gt;</ept> modifier before the method, property, or subscript’s introducer keyword (such as <bpt i="2" x="2">&lt;c2&gt;</bpt>final var<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>final func<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>final class func<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>final subscript<ept i="5">&lt;/c5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッド、プロパティ、または添え字の導入子キーワードの前に<bpt i="1" x="1">&lt;c1&gt;</bpt>final<ept i="1">&lt;/c1&gt;</ept>修飾子を書くことによって、これをしてください（例えば、<bpt i="2" x="2">&lt;c2&gt;</bpt>final var<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>final func<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>final class func<ept i="4">&lt;/c4&gt;</ept>、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>final subscript<ept i="5">&lt;/c5&gt;</ept>など）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Document Revision History</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文書改訂履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Doing so clarifies that you intend to provide an override and have not provided a matching definition by mistake.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうすることは、あなたがオーバーライドを提供するつもりであって、誤って同じ定義を提供したのでないことを明らかにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Doing so is consistent with the label’s use alongside the <bpt i="5" x="5">&lt;c5&gt;</bpt>break<ept i="5">&lt;/c5&gt;</ept> statement and helps make the game’s logic clearer to read and understand.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうすることは、<bpt i="5" x="5">&lt;c5&gt;</bpt>break<ept i="5">&lt;/c5&gt;</ept>文と並べるとラベルの使用で調和して、ゲームの論理を読み取って理解するのをより明快にする助けとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Doing so makes it easier for you to reason about your code and enables the Swift compiler to optimize the performance of the collections you create.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうすることは、あなたがあなたのコードについて推論するのをより容易にして、スウィフトのコンパイラにあなたが作成するコレクションの運用性能を最適なものにすることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Don’t use an implicitly unwrapped optional when there’s a possibility of a variable becoming <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> at a later point.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある変数がその後のある時点で<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>になる可能性がある時には、暗黙的にアンラップされるオプショナルを使用しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Don’t worry if you are not familiar with the concept of capturing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがキャプチャの概念に馴染みがなくても、心配いりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Don’t worry if you don’t understand something—everything introduced in this tour is explained in detail in the rest of this book.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>わからないことがあっても心配することはありません ― このツアーにおいて紹介されるすべてのことは、この本の残りで詳細に説明されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Double quote (<bpt i="0" x="0">&lt;c0&gt;</bpt>\"<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>二重引用符（<bpt i="0" x="0">&lt;c0&gt;</bpt>\"<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Downcasting</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ダウンキャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Downcasting to <bpt i="0" x="0">&lt;c0&gt;</bpt>Movie<ept i="0">&lt;/c0&gt;</ept> fails when applied to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Song<ept i="1">&lt;/c1&gt;</ept> instances in the library array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Movie<ept i="0">&lt;/c0&gt;</ept>にダウンキャストすることは、library配列の<bpt i="1" x="1">&lt;c1&gt;</bpt>Song<ept i="1">&lt;/c1&gt;</ept>インスタンスに適用されるとき失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Download Playground</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「遊び場」をダウンロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each <bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept> instance is initialized with a starting allowance of a specified number of coins from the bank during initialization, although a <bpt i="1" x="1">&lt;c1&gt;</bpt>Player<ept i="1">&lt;/c1&gt;</ept> instance may receive fewer than that number if not enough coins are available.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各<bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept>インスタンスは、初期化の間に、胴元からの指定された数のコインの開始手当で初期化されます、とは言え、十分なコインが利用可能でなければ<bpt i="1" x="1">&lt;c1&gt;</bpt>Player<ept i="1">&lt;/c1&gt;</ept>インスタンスはその数より少ないものを受け取るかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> value has an associated <bpt i="1" x="1">&lt;e1&gt;</bpt>index type<ept i="1">&lt;/e1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>String.Index<ept i="2">&lt;/c2&gt;</ept>, which corresponds to the position of each <bpt i="3" x="3">&lt;c3&gt;</bpt>Character<ept i="3">&lt;/c3&gt;</ept> in the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれの<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>値は、結び付けられた<bpt i="1" x="1">&lt;e1&gt;</bpt>インデックス型<ept i="1">&lt;/e1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>String.Index<ept i="2">&lt;/c2&gt;</ept>を持ちます、それは、各<bpt i="3" x="3">&lt;c3&gt;</bpt>Character<ept i="3">&lt;/c3&gt;</ept>のその文字列中での位置に対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each <bpt i="0" x="0">&lt;c0&gt;</bpt>UnicodeScalar<ept i="0">&lt;/c0&gt;</ept> has a <bpt i="1" x="1">&lt;c1&gt;</bpt>value<ept i="1">&lt;/c1&gt;</ept> property that returns the scalar’s 21-bit value, represented within a <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt32<ept i="2">&lt;/c2&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各<bpt i="0" x="0">&lt;c0&gt;</bpt>UnicodeScalar<ept i="0">&lt;/c0&gt;</ept>はひとつの<bpt i="1" x="1">&lt;c1&gt;</bpt>value<ept i="1">&lt;/c1&gt;</ept>プロパティを持ちます、それはそのスカラーの21ビットの値を返します、そしてそれは<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt32<ept i="2">&lt;/c2&gt;</ept>値の範囲内で表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each <bpt i="1" x="1">&lt;c1&gt;</bpt>Starship<ept i="1">&lt;/c1&gt;</ept> class instance stores a mandatory <bpt i="2" x="2">&lt;c2&gt;</bpt>name<ept i="2">&lt;/c2&gt;</ept> and an optional <bpt i="3" x="3">&lt;c3&gt;</bpt>prefix<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各<bpt i="1" x="1">&lt;c1&gt;</bpt>Starship<ept i="1">&lt;/c1&gt;</ept>クラスインスタンスは、義務的な<bpt i="2" x="2">&lt;c2&gt;</bpt>name<ept i="2">&lt;/c2&gt;</ept>そしてオプショナルの<bpt i="3" x="3">&lt;c3&gt;</bpt>prefix<ept i="3">&lt;/c3&gt;</ept>を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each <bpt i="2" x="2">&lt;c2&gt;</bpt>case<ept i="2">&lt;/c2&gt;</ept> compares that value to a number or interval.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各<bpt i="2" x="2">&lt;c2&gt;</bpt>case<ept i="2">&lt;/c2&gt;</ept>は、その値をある数または区間と比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each access-level modifier above optionally accepts a single argument, which consists of the <bpt i="0" x="0">&lt;c0&gt;</bpt>set<ept i="0">&lt;/c0&gt;</ept> keyword enclosed in parentheses (for instance, <bpt i="1" x="1">&lt;c1&gt;</bpt>private(set)<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上記のそれぞれのアクセス水準修飾子は、任意に１つだけの引数を受け入れます、それは丸括弧に囲まれたキーワード<bpt i="0" x="0">&lt;c0&gt;</bpt>set<ept i="0">&lt;/c0&gt;</ept>からなります（例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>private(set)<ept i="1">&lt;/c1&gt;</ept>）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each approach is described in a section below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各取り組みは、以下の節で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each barcode has a “number system” digit, followed by five “manufacturer code” digits and five “product code” digits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各バーコードは、一つの「ナンバーシステム」桁、それに続く５桁の「製造者コード」そして５桁の「商品コード」を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each build target (such as an app bundle or framework) in Xcode is treated as a separate module in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Xcodeでの各ビルドターゲット（例えばアプリ・バンドルまたはフレームワーク）は、スウィフトにおいて別々のモジュールとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each case can also specify that it stores values of a given type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各ケース節は、また、それが特定の型の値を保存することを示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each case must have a unique name and be assigned a unique raw value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれのケース節は、固有な名前を持ち固有な生の値を割り当てられなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each channel has an integer audio level between <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept> inclusive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各チャンネルは、<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>から<bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>を含むまでの整数オーディオ・レベルがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each element of the tuple can be tested against a different value or interval of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプルの各要素は、ある異なる値または値の区間に対して試験されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each enumeration definition defines a brand new type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれの列挙定義は、まっさらの新しい型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each example below shows a different representation of the following string, which is made up of the characters <bpt i="0" x="0">&lt;c0&gt;</bpt>D<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>o<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>g<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>‼<ept i="3">&lt;/c3&gt;</ept> (<bpt i="4" x="4">&lt;c4&gt;</bpt>DOUBLE EXCLAMATION MARK<ept i="4">&lt;/c4&gt;</ept>, or Unicode scalar <bpt i="5" x="5">&lt;c5&gt;</bpt>U+203C<ept i="5">&lt;/c5&gt;</ept>), and the 🐶 character (<bpt i="6" x="6">&lt;c6&gt;</bpt>DOG FACE<ept i="6">&lt;/c6&gt;</ept>, or Unicode scalar <bpt i="7" x="7">&lt;c7&gt;</bpt>U+1F436<ept i="7">&lt;/c7&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の各例は、次の文字列の異なる具象化を示します、それは文字<bpt i="0" x="0">&lt;c0&gt;</bpt>D<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>o<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>g<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>‼<ept i="3">&lt;/c3&gt;</ept>（<bpt i="4" x="4">&lt;c4&gt;</bpt>DOUBLE EXCLAMATION MARK<ept i="4">&lt;/c4&gt;</ept>、またはユニコード・スカラー<bpt i="5" x="5">&lt;c5&gt;</bpt>U+203C<ept i="5">&lt;/c5&gt;</ept>）、そして🐶文字（<bpt i="6" x="6">&lt;c6&gt;</bpt>DOG FACE<ept i="6">&lt;/c6&gt;</ept>またはユニコード・スカラー<bpt i="7" x="7">&lt;c7&gt;</bpt>U+1F436<ept i="7">&lt;/c7&gt;</ept>）から成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each expression can have an optional identifier before it, separated by a colon (<bpt i="1" x="1">&lt;c1&gt;</bpt>:<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各式はそれの前に、コロン（<bpt i="1" x="1">&lt;c1&gt;</bpt>:<ept i="1">&lt;/c1&gt;</ept>）で区切られる任意の識別子を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each form encodes the string in small chunks known as <bpt i="1" x="1">&lt;e1&gt;</bpt>code units<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各方式は、文字列を、<bpt i="1" x="1">&lt;e1&gt;</bpt>符号単位<ept i="1">&lt;/e1&gt;</ept>として知られている小さいかたまりで符号化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each function parameter has both an <bpt i="0" x="0">&lt;e0&gt;</bpt>argument label<ept i="0">&lt;/e0&gt;</ept> and a <bpt i="1" x="1">&lt;e1&gt;</bpt>parameter name<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数パラメーターそれぞれは、<bpt i="0" x="0">&lt;e0&gt;</bpt>引数ラベル<ept i="0">&lt;/e0&gt;</ept>と<bpt i="1" x="1">&lt;e1&gt;</bpt>パラメーター名<ept i="1">&lt;/e1&gt;</ept>の両方を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> has a single stored property called <bpt i="1" x="1">&lt;c1&gt;</bpt>fullName<ept i="1">&lt;/c1&gt;</ept>, which is of type <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>の各インスタンスは、<bpt i="1" x="1">&lt;c1&gt;</bpt>fullName<ept i="1">&lt;/c1&gt;</ept>と呼ばれる１つの保存プロパティを持ちます、それは、型<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each item in a capture list is a pairing of the <bpt i="0" x="0">&lt;c0&gt;</bpt>weak<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>unowned<ept i="1">&lt;/c1&gt;</ept> keyword with a reference to a class instance (such as <bpt i="2" x="2">&lt;c2&gt;</bpt>self<ept i="2">&lt;/c2&gt;</ept>) or a variable initialized with some value (such as <bpt i="3" x="3">&lt;c3&gt;</bpt>delegate = self.delegate!<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>捕獲リストの各項目は、<bpt i="0" x="0">&lt;c0&gt;</bpt>weak<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>unowned<ept i="1">&lt;/c1&gt;</ept>キーワードと、クラスインスタンスへの参照（例えば<bpt i="2" x="2">&lt;c2&gt;</bpt>self<ept i="2">&lt;/c2&gt;</ept>）またはなんらかの値で初期化された変数（例えば<bpt i="3" x="3">&lt;c3&gt;</bpt>delegate = self.delegate!<ept i="3">&lt;/c3&gt;</ept>）を対にしたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each item in a protocol composition list is one of the following; the list can contain at most one class:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル合成リストの各項目は以下のうちの１つです；リストは最大１つのクラスを含むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each item in the dictionary is returned as a <bpt i="0" x="0">&lt;c0&gt;</bpt>(key, value)<ept i="0">&lt;/c0&gt;</ept> tuple when the dictionary is iterated, and you can decompose the <bpt i="1" x="1">&lt;c1&gt;</bpt>(key, value)<ept i="1">&lt;/c1&gt;</ept> tuple’s members as explicitly named constants for use within the body of the <bpt i="2" x="2">&lt;c2&gt;</bpt>for<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>in<ept i="3">&lt;/c3&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の中の各項目は、辞書が繰り返されるとき、<bpt i="0" x="0">&lt;c0&gt;</bpt>(key, value)<ept i="0">&lt;/c0&gt;</ept>タプルとして返されます、そしてあなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>(key, value)<ept i="1">&lt;/c1&gt;</ept>タプルの構成要素を<bpt i="2" x="2">&lt;c2&gt;</bpt>for<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>in<ept i="3">&lt;/c3&gt;</ept>ループの本文内で使用するわかりやすい名前の定数として分解することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each item in the dictionary is returned as a <bpt i="2" x="2">&lt;c2&gt;</bpt>(key, value)<ept i="2">&lt;/c2&gt;</ept> tuple, and you can decompose the tuple’s members into temporary constants or variables as part of the iteration:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の中の各項目は、<bpt i="2" x="2">&lt;c2&gt;</bpt>(key, value)<ept i="2">&lt;/c2&gt;</ept>タプルとして返されます、そしてあなたはタプルの構成要素を一時的な定数または変数に分解することが、この繰り返しの一部として行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each item that you insert into the string literal is wrapped in a pair of parentheses, prefixed by a backslash (<bpt i="2" x="2">&lt;c2&gt;</bpt>\<ept i="2">&lt;/c2&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがリテラル文字列に差し込む各項目は、一対の丸括弧に包まれて、バックスラッシュ（<bpt i="2" x="2">&lt;c2&gt;</bpt>\<ept i="2">&lt;/c2&gt;</ept>）を前に置かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each kind of expression is described in detail in the sections below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各種類の式は、以下の節において詳細に記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each of the comparison operators returns a <bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept> value to indicate whether or not the statement is true:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれの比較演算子は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept>値を返して、その文が真かどうかを指し示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each pair of characters in a hexadecimal number uses 8 bits, so a move 16 places to the right will convert <bpt i="1" x="1">&lt;c1&gt;</bpt>0xCC0000<ept i="1">&lt;/c1&gt;</ept> into <bpt i="2" x="2">&lt;c2&gt;</bpt>0x0000CC<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>16進数の中の文字の各ペアは８ビットを使うので、右への16桁の移動は<bpt i="1" x="1">&lt;c1&gt;</bpt>0xCC0000<ept i="1">&lt;/c1&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>0x0000CC<ept i="2">&lt;/c2&gt;</ept>へと変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each player has a certain number of coins stored in their purse at any time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各々のプレーヤーは、特定の数のコインをいつでもかれらの財布に保管しておきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each position in the matrix is given an initial value of <bpt i="5" x="5">&lt;c5&gt;</bpt>0.0<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行列の中の各位置は、<bpt i="5" x="5">&lt;c5&gt;</bpt>0.0<ept i="5">&lt;/c5&gt;</ept>の初期値を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each raw value must be unique within its enumeration declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の値それぞれは、その列挙宣言の範囲内で固有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each statement in the body of a conditional compilation block is parsed even if it’s not compiled.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>条件コンパイルブロックの本文中の各文は、たとえそれがコンパイルされなくとも、構文解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each time <bpt i="3" x="3">&lt;c3&gt;</bpt>swapTwoValues(_:_:)<ept i="3">&lt;/c3&gt;</ept> is called, the type to use for <bpt i="4" x="4">&lt;c4&gt;</bpt>T<ept i="4">&lt;/c4&gt;</ept> is inferred from the types of values passed to the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>swapTwoValues(_:_:)<ept i="3">&lt;/c3&gt;</ept>が呼ばれるたびに、<bpt i="4" x="4">&lt;c4&gt;</bpt>T<ept i="4">&lt;/c4&gt;</ept>のために使われる型は関数に渡される値の型から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each time through the <bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept> loop, <bpt i="3" x="3">&lt;c3&gt;</bpt>diceRoll<ept i="3">&lt;/c3&gt;</ept> is incremented by one and is then checked to see whether it has become too large.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>毎回<bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept>ループの間、<bpt i="3" x="3">&lt;c3&gt;</bpt>diceRoll<ept i="3">&lt;/c3&gt;</ept>は１増やされて、それからそれが大きくなりすぎていないか調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each turn, you roll a six-sided dice and move by that number of squares, following the horizontal path indicated by the dotted arrow above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>順番になるたび、あなたは六面のさいころを転がします、そしてその数だけ正方形を移動します、上の点線の矢印で示される水平移動の経路をたどっていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each type argument must satisfy all the constraints of the generic parameter it replaces, including any additional requirements specified in a generic <bpt i="6" x="6">&lt;c6&gt;</bpt>where<ept i="6">&lt;/c6&gt;</ept> clause.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各型引数は、それが置き換える総称体パラメータの全ての制約を、総称体<bpt i="6" x="6">&lt;c6&gt;</bpt>where<ept i="6">&lt;/c6&gt;</ept>節で指定される任意の追加の要件を含めて、満たさなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each type method is explicitly scoped to the type it supports.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各型メソッドは、当然ながらそれが支える型にスコープを指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each unassigned case of type <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept> is implicitly assigned a raw value that is automatically incremented from the raw value of the previous case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>の未割り当てのケース節それぞれは、暗黙のうちに生の値を割り当てられます、それは、前のケース節の生の値から自動的に増やされたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each value is associated with a unique <bpt i="1" x="1">&lt;e1&gt;</bpt>key<ept i="1">&lt;/e1&gt;</ept>, which acts as an identifier for that value within the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各値は固有の<bpt i="1" x="1">&lt;e1&gt;</bpt>キー<ept i="1">&lt;/e1&gt;</ept>と結び付けられます、そして、それはその辞書の内部でその値のために識別子の働きをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Early Exit</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>早期退出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Effectively, the addition and the assignment are combined into one operator that performs both tasks at the same time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実質的に、加算と代入は１つの演算子に結合され、同時に両方の作業を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Effectively, they are just two different names for the same single instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>事実上、それらは同じ一つのインスタンスに対する単なる２つの異なる名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Empty array literals are written using an empty pair of square brackets and can be used to create an empty array of a specified type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の配列リテラルは、空の角括弧の対を使って書かれて、指定された型の空の配列をつくるために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enforcing Preconditions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前提条件の遵守</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumeration Case Pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙ケース節パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumeration Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumeration Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumeration Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumeration case patterns appear in <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement case labels and in the case conditions of <bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>guard<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>for<ept i="5">&lt;/c5&gt;</ept>-<bpt i="6" x="6">&lt;c6&gt;</bpt>in<ept i="6">&lt;/c6&gt;</ept> statements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙ケース節パターンは、<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文のケース節ラベル（ケース節表記）において、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>guard<ept i="4">&lt;/c4&gt;</ept>、および<bpt i="5" x="5">&lt;c5&gt;</bpt>for<ept i="5">&lt;/c5&gt;</ept>-<bpt i="6" x="6">&lt;c6&gt;</bpt>in<ept i="6">&lt;/c6&gt;</ept>文のケース節条件において現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumeration case values without associated values (as described in <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Enumerations<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>) are also hashable by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連値なしでの列挙ケース節の値（<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>列挙<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>で記述されます）もまた、そのままでハッシュ化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumeration cases that store associated values can be used as functions that create instances of the enumeration with the specified associated values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連値を格納する列挙ケース節は、関数として使われることができ、それは指定された関連値を持つその列挙のインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumeration declarations can’t contain deinitializer or protocol declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙宣言は、デイニシャライザまたはプロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumeration declarations have two basic forms and are declared using the <bpt i="0" x="0">&lt;c0&gt;</bpt>enum<ept i="0">&lt;/c0&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙宣言は、２つの基本の形式を持ち、キーワード<bpt i="0" x="0">&lt;c0&gt;</bpt>enum<ept i="0">&lt;/c0&gt;</ept>を使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumeration types can adopt any number of protocols, but can’t inherit from classes, structures, or other enumerations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙型は、任意の数のプロトコルに準拠することができます、しかしクラス、構造体、または他の列挙から継承することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations and Structures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙と構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations are often created to support a specific class or structure’s functionality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙は、特定のクラスまたは構造体の機能性を支えるためにたびたびつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations can also define initializers to provide an initial case value; can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙は、さらに、最初のケース節値を提供するためにイニシャライザを定義することができます；それらの本来の実装を越えてそれらの機能性を広げるために拡張されることができます；そして、標準の機能性を提供するためにプロトコルに準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations can have a recursive structure, that is, they can have cases with associated values that are instances of the enumeration type itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙は、再帰構造を持つことができます、すなわち、それは、その列挙型それ自身のインスタンスである関連値を伴うケース節を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations declared in this form are sometimes called <bpt i="0" x="0">&lt;e0&gt;</bpt>discriminated unions<ept i="0">&lt;/e0&gt;</ept> in other programming languages.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この形式で宣言される列挙は、時として他のプログラミング言語では<bpt i="0" x="0">&lt;e0&gt;</bpt>判別共用体<ept i="0">&lt;/e0&gt;</ept>と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations in Swift are first-class types in their own right.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの列挙は、れっきとした第一級の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations in Swift are much more flexible, and do not have to provide a value for each case of the enumeration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの列挙は、ずっと柔軟で、列挙のケース節の各々に値を与える必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations similar to these are known as <bpt i="0" x="0">&lt;e0&gt;</bpt>discriminated unions<ept i="0">&lt;/e0&gt;</ept>, <bpt i="1" x="1">&lt;e1&gt;</bpt>tagged unions<ept i="1">&lt;/e1&gt;</ept>, or <bpt i="2" x="2">&lt;e2&gt;</bpt>variants<ept i="2">&lt;/e2&gt;</ept> in other programming languages.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これに似ている列挙は、他のプログラミング言語で<bpt i="0" x="0">&lt;e0&gt;</bpt>判別共用体<ept i="0">&lt;/e0&gt;</ept>、<bpt i="1" x="1">&lt;e1&gt;</bpt>タグ付き共用体<ept i="1">&lt;/e1&gt;</ept>、または<bpt i="2" x="2">&lt;e2&gt;</bpt>バリアント<ept i="2">&lt;/e2&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations that have cases of a raw-value type implicitly conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>RawRepresentable<ept i="0">&lt;/c0&gt;</ept> protocol, defined in the Swift standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「生の値」型のケース節を持つ列挙は、スウィフト標準ライブラリで定義される<bpt i="0" x="0">&lt;c0&gt;</bpt>RawRepresentable<ept i="0">&lt;/c0&gt;</ept>プロトコルに暗黙的に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations with Cases of Any Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>随意の型のケース節をもつ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations with Cases of a Raw-Value Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「生の値」型のケース節を持つ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations with Indirection</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>間接参照を持つ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations with raw values automatically receive a failable initializer, <bpt i="0" x="0">&lt;c0&gt;</bpt>init?(rawValue:)<ept i="0">&lt;/c0&gt;</ept>, that takes a parameter called <bpt i="1" x="1">&lt;c1&gt;</bpt>rawValue<ept i="1">&lt;/c1&gt;</ept> of the appropriate raw-value type and selects a matching enumeration case if one is found, or triggers an initialization failure if no matching value exists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の値を持つ列挙は、自動的にひとつの失敗できるイニシャライザ、<bpt i="0" x="0">&lt;c0&gt;</bpt>init?(rawValue:)<ept i="0">&lt;/c0&gt;</ept>を受け取ります、それは、適切な「生の値」型の<bpt i="1" x="1">&lt;c1&gt;</bpt>rawValue<ept i="1">&lt;/c1&gt;</ept>と呼ばれるパラメータを取って、適合する列挙ケース節をそれが見つかったならば選択します、または適合する値が存在しないならば初期化失敗を引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations with raw values now have a <bpt i="0" x="0">&lt;c0&gt;</bpt>rawValue<ept i="0">&lt;/c0&gt;</ept> property rather than a <bpt i="1" x="1">&lt;c1&gt;</bpt>toRaw()<ept i="1">&lt;/c1&gt;</ept> method and a failable initializer with a <bpt i="2" x="2">&lt;c2&gt;</bpt>rawValue<ept i="2">&lt;/c2&gt;</ept> parameter rather than a <bpt i="3" x="3">&lt;c3&gt;</bpt>fromRaw()<ept i="3">&lt;/c3&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の値を持つ列挙は、今では<bpt i="1" x="1">&lt;c1&gt;</bpt>toRaw()<ept i="1">&lt;/c1&gt;</ept>メソッドではなく<bpt i="0" x="0">&lt;c0&gt;</bpt>rawValue<ept i="0">&lt;/c0&gt;</ept>プロパティを、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>fromRaw()<ept i="3">&lt;/c3&gt;</ept>メソッドではなく<bpt i="2" x="2">&lt;c2&gt;</bpt>rawValue<ept i="2">&lt;/c2&gt;</ept>パラメーターを使う失敗できるイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Equal to (<bpt i="0" x="0">&lt;c0&gt;</bpt>a == b<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同等である（<bpt i="0" x="0">&lt;c0&gt;</bpt>a == b<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Equivalence Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同等演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Error Handling</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーの処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Error handling allows controlled recovery from unexpected failures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラー処理が、予期せぬ失敗からの制御された復旧を可能にする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Error handling in Swift interoperates with error handling patterns that use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSError<ept i="0">&lt;/c0&gt;</ept> class in Cocoa and Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでのエラー処理は、CocoaとObjective-Cでの<bpt i="0" x="0">&lt;c0&gt;</bpt>NSError<ept i="0">&lt;/c0&gt;</ept>クラスを使うエラー処理パターンと相互運用性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Error handling in Swift resembles exception handling in other languages, with the use of the <bpt i="0" x="0">&lt;c0&gt;</bpt>try<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>throw<ept i="2">&lt;/c2&gt;</ept> keywords.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおけるエラー処理は、<bpt i="0" x="0">&lt;c0&gt;</bpt>try<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>throw<ept i="2">&lt;/c2&gt;</ept>キーワードの使用とともに、他の言語での例外処理に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Escaping Closures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>脱出クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Evaluating an expression returns a value, causes a side effect, or both.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある式を評価することは、ひとつの値を返す、ある副作用を引き起こす、あるいはその両方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even if your source file has a mix of carriage returns and line feeds, all of the line breaks in the string will be the same.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえあなたのソースファイルがキャリッジリターンとラインフィードの混合を持つとしても、文字列の中のラインブレークの全ては同じになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even on 32-bit platforms, <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> can store any value between <bpt i="2" x="2">&lt;c2&gt;</bpt>-2,147,483,648<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>2,147,483,647<ept i="3">&lt;/c3&gt;</ept>, and is large enough for many integer ranges.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>32ビットのプラットホーム上でさえ、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>-2,147,483,648<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>2,147,483,647<ept i="3">&lt;/c3&gt;</ept>の間のどんな値でも保存することができ、多くの整数範囲のために十分に大きいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though <bpt i="0" x="0">&lt;c0&gt;</bpt>Rank<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Suit<ept i="1">&lt;/c1&gt;</ept> are nested within <bpt i="2" x="2">&lt;c2&gt;</bpt>BlackjackCard<ept i="2">&lt;/c2&gt;</ept>, their type can be inferred from context, and so the initialization of this instance is able to refer to the enumeration cases by their case names (<bpt i="3" x="3">&lt;c3&gt;</bpt>.ace<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>.spades<ept i="4">&lt;/c4&gt;</ept>) alone.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえ<bpt i="0" x="0">&lt;c0&gt;</bpt>Rank<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Suit<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>BlackjackCard<ept i="2">&lt;/c2&gt;</ept>内部に入れ子にされるとしても、それらの型は前後関係から推論されることができます、なのでこのインスタンスの初期化は、列挙ケース節を参照することがもっぱらそれらのケース節名（<bpt i="3" x="3">&lt;c3&gt;</bpt>.ace<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>.spades<ept i="4">&lt;/c4&gt;</ept>）のみによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though <bpt i="0" x="0">&lt;c0&gt;</bpt>RecipeIngredient<ept i="0">&lt;/c0&gt;</ept> provides the <bpt i="1" x="1">&lt;c1&gt;</bpt>init(name: String)<ept i="1">&lt;/c1&gt;</ept> initializer as a convenience initializer, <bpt i="2" x="2">&lt;c2&gt;</bpt>RecipeIngredient<ept i="2">&lt;/c2&gt;</ept> has nonetheless provided an implementation of all of its superclass’s designated initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえ<bpt i="0" x="0">&lt;c0&gt;</bpt>RecipeIngredient<ept i="0">&lt;/c0&gt;</ept>が便宜イニシャライザとして<bpt i="1" x="1">&lt;c1&gt;</bpt>init(name: String)<ept i="1">&lt;/c1&gt;</ept>イニシャライザを提供するとしても、<bpt i="2" x="2">&lt;c2&gt;</bpt>RecipeIngredient<ept i="2">&lt;/c2&gt;</ept>はそれでもやはりそれのスーパークラスの指定イニシャライザの全ての実装を提供しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though <bpt i="5" x="5">&lt;c5&gt;</bpt>hd<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>cinema<ept i="6">&lt;/c6&gt;</ept> now have the same width and height, they are two completely different instances behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえ<bpt i="5" x="5">&lt;c5&gt;</bpt>hd<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>cinema<ept i="6">&lt;/c6&gt;</ept>が現在同じ幅と高さを持つとしても、それらは舞台裏では２つの完全に異なるインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though the <bpt i="3" x="3">&lt;c3&gt;</bpt>text<ept i="3">&lt;/c3&gt;</ept> property is now a constant, it can still be set within the class’s initializer:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえ<bpt i="3" x="3">&lt;c3&gt;</bpt>text<ept i="3">&lt;/c3&gt;</ept>プロパティが今や定数であるとしても、それはクラスのイニシャライザの内部ではまだ設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though the closure refers to <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> multiple times, it only captures one strong reference to the <bpt i="1" x="1">&lt;c1&gt;</bpt>HTMLElement<ept i="1">&lt;/c1&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえクロージャが複数回<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>に言及するとしても、それはその<bpt i="1" x="1">&lt;c1&gt;</bpt>HTMLElement<ept i="1">&lt;/c1&gt;</ept>インスタンスへの１つの強い参照を捕獲するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though the first element of the <bpt i="0" x="0">&lt;c0&gt;</bpt>customersInLine<ept i="0">&lt;/c0&gt;</ept> array is removed by the code inside the closure, the array element isn’t removed until the closure is actually called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえ<bpt i="0" x="0">&lt;c0&gt;</bpt>customersInLine<ept i="0">&lt;/c0&gt;</ept>配列の最初の要素がクロージャ内部のコードによって取り除かれるとしても、その配列要素はクロージャが実際に呼び出されるまで実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though the stack and the array are of a different type, they both conform to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Container<ept i="3">&lt;/c3&gt;</ept> protocol, and both contain the same type of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえスタックと配列が異なる型であるとしても、それらは両方とも<bpt i="3" x="3">&lt;c3&gt;</bpt>Container<ept i="3">&lt;/c3&gt;</ept>プロトコルに準拠して、両方とも同じ型の値を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though the variable <bpt i="0" x="0">&lt;c0&gt;</bpt>protocolValue<ept i="0">&lt;/c0&gt;</ept> has a runtime type of <bpt i="1" x="1">&lt;c1&gt;</bpt>SimpleClass<ept i="1">&lt;/c1&gt;</ept>, the compiler treats it as the given type of <bpt i="2" x="2">&lt;c2&gt;</bpt>ExampleProtocol<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえ変数<bpt i="0" x="0">&lt;c0&gt;</bpt>protocolValue<ept i="0">&lt;/c0&gt;</ept>が実行時の型として<bpt i="1" x="1">&lt;c1&gt;</bpt>SimpleClass<ept i="1">&lt;/c1&gt;</ept>を持つとしても、コンパイラはそれを与えられた型<bpt i="2" x="2">&lt;c2&gt;</bpt>ExampleProtocol<ept i="2">&lt;/c2&gt;</ept>とみなします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though there are two optional chaining operations, one after another, the result is still wrapped in a single optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえ２つのオプショナル連鎖演算があったとしても、後から後から、その結果は依然としてただ１つのオプショナルの中にラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though you don’t write an explicit getter and setter for a stored property, Swift still synthesizes an implicit getter and setter for you to provide access to the stored property’s backing storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえあなたが保存プロパティのために明確なゲッターとセッターを書かないとしても、スウィフトは保存プロパティのもつ支援外部記憶へのアクセスを提供するためにあなたのためにまだ暗黙のゲッターとセッターを総合的に扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> instance has a <bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept> property of type <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> and an optional <bpt i="3" x="3">&lt;c3&gt;</bpt>apartment<ept i="3">&lt;/c3&gt;</ept> property that is initially <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆる<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>インスタンスは、型<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept>プロパティと初期時には<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>であるオプショナルの<bpt i="3" x="3">&lt;c3&gt;</bpt>apartment<ept i="3">&lt;/c3&gt;</ept>プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement consists of multiple possible <bpt i="1" x="1">&lt;e1&gt;</bpt>cases<ept i="1">&lt;/e1&gt;</ept>, each of which begins with the <bpt i="2" x="2">&lt;c2&gt;</bpt>case<ept i="2">&lt;/c2&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆる<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文は複数の起こりうる<bpt i="1" x="1">&lt;e1&gt;</bpt>ケース節<ept i="1">&lt;/e1&gt;</ept>から成ります。そして、それぞれは<bpt i="2" x="2">&lt;c2&gt;</bpt>case<ept i="2">&lt;/c2&gt;</ept>キーワードから始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement must be <bpt i="1" x="1">&lt;e1&gt;</bpt>exhaustive<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆる<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文は、<bpt i="1" x="1">&lt;e1&gt;</bpt>徹底的<ept i="1">&lt;/e1&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every class must have at least one designated initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆるクラスは、少なくとも１つの指定イニシャライザを持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every conditional compilation block begins with the <bpt i="0" x="0">&lt;c0&gt;</bpt>#if<ept i="0">&lt;/c0&gt;</ept> compilation directive and ends with the <bpt i="1" x="1">&lt;c1&gt;</bpt>#endif<ept i="1">&lt;/c1&gt;</ept> compilation directive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての条件コンパイルブロックは、<bpt i="0" x="0">&lt;c0&gt;</bpt>#if<ept i="0">&lt;/c0&gt;</ept>コンパイル指令で始まって、<bpt i="1" x="1">&lt;c1&gt;</bpt>#endif<ept i="1">&lt;/c1&gt;</ept>コンパイル指令で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every function has a <bpt i="0" x="0">&lt;e0&gt;</bpt>function name<ept i="0">&lt;/e0&gt;</ept>, which describes the task that the function performs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆる関数は<bpt i="0" x="0">&lt;e0&gt;</bpt>関数名<ept i="0">&lt;/e0&gt;</ept>を持ち、それはその関数が実行する作業を形容します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every function has a specific <bpt i="0" x="0">&lt;e0&gt;</bpt>function type<ept i="0">&lt;/e0&gt;</ept>, made up of the parameter types and the return type of the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆる関数は特定の<bpt i="0" x="0">&lt;e0&gt;</bpt>関数型<ept i="0">&lt;/e0&gt;</ept>を持ちます、それは、その関数のパラメータ型と戻り型から成り立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every function in Swift has a type, consisting of the function’s parameter types and return type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのあらゆる関数は、その関数のパラメータ型と戻り型から成る、ある型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every instance of Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> type represents a single <bpt i="1" x="1">&lt;e1&gt;</bpt>extended grapheme cluster<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>型の全てのインスタンスは、単一の<bpt i="1" x="1">&lt;e1&gt;</bpt>拡張書記素クラスタ（房、群）<ept i="1">&lt;/e1&gt;</ept>を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every instance of a type has an implicit property called <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>, which is exactly equivalent to the instance itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型のすべてのインスタンスは、暗黙的に<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>と呼ばれるプロパティを持ちます、それは、正確にそのインスタンスそれ自身に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every item in the shopping list starts out as “unpurchased”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>購入品目リストでのあらゆる項目は、「未購入」として始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every property needs a value assigned—either in its declaration (as with <bpt i="3" x="3">&lt;c3&gt;</bpt>numberOfSides<ept i="3">&lt;/c3&gt;</ept>) or in the initializer (as with <bpt i="4" x="4">&lt;c4&gt;</bpt>name<ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆるプロパティは、代入される値を必要とします ― その宣言において（<bpt i="3" x="3">&lt;c3&gt;</bpt>numberOfSides<ept i="3">&lt;/c3&gt;</ept>でのように）またはイニシャライザにおいて（<bpt i="4" x="4">&lt;c4&gt;</bpt>name<ept i="4">&lt;/c4&gt;</ept>でのように）のどちらでも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every string is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらゆる文字列は、符号化に依存しないUnicode文字から構成されます、そして多彩なUnicode表現においてそのような文字にアクセスするための支援を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every time a player finishes a level, that level is unlocked for all players on the device.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレーヤーがあるレベルを終了するごとに、そのレベルはその装置上の全てのプレーヤーのために鍵を外されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every time you create a new instance of a class, ARC allocates a chunk of memory to store information about that instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがクラスの新しいインスタンスをつくるたびに、ARCはメモリのある量を割り当てて、そのインスタンスに関する情報を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Every time you create a new instance of that type, it has its own set of property values, separate from any other instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがその型の新しいインスタンスをつくるたびに、それは、他のあらゆるインスタンスから独立した、独自のひと組のプロパティ値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Examples of <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Closure Expressions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> now use the global <bpt i="2" x="2">&lt;c2&gt;</bpt>sorted(_:_:)<ept i="2">&lt;/c2&gt;</ept> function rather than the global <bpt i="3" x="3">&lt;c3&gt;</bpt>sort(_:_:)<ept i="3">&lt;/c3&gt;</ept> function, to reflect the new array value semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>クロージャ式<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の例は、現在はグローバルな<bpt i="2" x="2">&lt;c2&gt;</bpt>sorted(_:_:)<ept i="2">&lt;/c2&gt;</ept>関数を、グローバルな<bpt i="3" x="3">&lt;c3&gt;</bpt>sort(_:_:)<ept i="3">&lt;/c3&gt;</ept>関数のかわりに使用します、それによって新しい配列値意味論を反映します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Examples of good candidates for structures include:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体の良い候補者の例には、次のようなものがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Executing the last <bpt i="1" x="1">&lt;c1&gt;</bpt>defer<ept i="1">&lt;/c1&gt;</ept> statement in a given scope first means that statements inside that last <bpt i="2" x="2">&lt;c2&gt;</bpt>defer<ept i="2">&lt;/c2&gt;</ept> statement can refer to resources that will be cleaned up by other <bpt i="3" x="3">&lt;c3&gt;</bpt>defer<ept i="3">&lt;/c3&gt;</ept> statements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある特定のスコープ中の最後の<bpt i="1" x="1">&lt;c1&gt;</bpt>defer<ept i="1">&lt;/c1&gt;</ept>文の実行が最初であることは、その最後の<bpt i="2" x="2">&lt;c2&gt;</bpt>defer<ept i="2">&lt;/c2&gt;</ept>文内の文は別の<bpt i="3" x="3">&lt;c3&gt;</bpt>defer<ept i="3">&lt;/c3&gt;</ept>文によってクリーンアップされることになるリソースを参照できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Execution Does Not Fall Through Cases Implicitly</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実行は暗黙のうちにケース節を抜け落ちません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Execution doesn’t continue to the next case, so there is no need to explicitly break out of the switch at the end of each case’s code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実行は次の条件部分に続かないので、各条件部分のコードの終わりで明示的にスイッチから抜け出す必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Existing bits are moved to the left or right by the requested number of places.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>既存のビットは、左または右へ要請された桁数だけ動かされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Existing instances of a type automatically adopt and conform to a protocol when that conformance is added to the instance’s type in an extension.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型の既存のインスタンスたちは、そのインスタンスの型に拡張の中で準拠が加えられるとき、そのプロトコルを自動的に採用して準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Experiment</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>試してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Explicit Member Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>明示的メンバー式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Explicit Parentheses</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>明確な括弧</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Expression Pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>式パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Expression patterns appear only in <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement case labels.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>式パターンは、<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文のケース節ラベルにおいてのみ現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Expressions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extended Grapheme Clusters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張書記素クラスタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extended grapheme clusters are a flexible way to represent many complex script characters as a single <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張書記素クラスタは、多くの複雑な書き方の文字を単一の<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>値として表わす適応性に富む方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extended grapheme clusters are canonically equivalent if they have the same linguistic meaning and appearance, even if they’re composed from different Unicode scalars behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張書記素クラスタが正準等価であるのは、それらが同じ言語的な意味と外観を持つ場合です、たとえそれらが舞台裏で異なるユニコードスカラーから組み立てられるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extended grapheme clusters can be composed of multiple Unicode scalars.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張書記素クラスタは、多数のユニコード・スカラーから構成される可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extended grapheme clusters enable scalars for enclosing marks (such as <bpt i="0" x="0">&lt;c0&gt;</bpt>COMBINING ENCLOSING CIRCLE<ept i="0">&lt;/c0&gt;</ept>, or <bpt i="1" x="1">&lt;c1&gt;</bpt>U+20DD<ept i="1">&lt;/c1&gt;</ept>) to enclose other Unicode scalars as part of a single <bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張書記素クラスタは、囲み記号としてのスカラー（<bpt i="0" x="0">&lt;c0&gt;</bpt>COMBINING ENCLOSING CIRCLE<ept i="0">&lt;/c0&gt;</ept>、または<bpt i="1" x="1">&lt;c1&gt;</bpt>U+20DD<ept i="1">&lt;/c1&gt;</ept>）を可能にして、単一の<bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept>値の一部として他のユニコード・スカラーを囲み入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extending a Generic Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体型を拡張する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extending an Existing Type to Specify an Associated Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>既存の型を拡張して関連型を指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extending existing types to provide initializers that accept new types (including your own type definitions) is covered in <bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>Extensions<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい型（あなた独自の型定義を含む）を受け入れるイニシャライザを提供するように既存の型を拡張することは、<bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>「拡張」<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extension Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extension Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extension declarations are declared using the <bpt i="1" x="1">&lt;c1&gt;</bpt>extension<ept i="1">&lt;/c1&gt;</ept> keyword and have the following forms:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張宣言は、キーワード<bpt i="1" x="1">&lt;c1&gt;</bpt>extension<ept i="1">&lt;/c1&gt;</ept>を使って宣言されます、そして以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extension declarations can add protocol conformance to an existing class, structure, and enumeration type in the <bpt i="0" x="0">&lt;e0&gt;</bpt>adopted protocols<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張宣言は、プロトコル準拠を既存のクラス、構造体、そして列挙型に加えることが<bpt i="0" x="0">&lt;e0&gt;</bpt>adopted protocols 採用プロトコル<ept i="0">&lt;/e0&gt;</ept>において可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extension declarations can contain initializer declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張宣言は、イニシャライザ宣言を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extension declarations can’t add class inheritance to an existing class, and therefore you can specify only a list of protocols after the <bpt i="1" x="1">&lt;e1&gt;</bpt>type name<ept i="1">&lt;/e1&gt;</ept> and colon.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張宣言は、クラス継承を既存のクラスに加えることができません、従ってあなたは単にプロトコルのリストだけを<bpt i="1" x="1">&lt;e1&gt;</bpt>type name 型名<ept i="1">&lt;/e1&gt;</ept>とコロンの後に指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extension declarations can’t contain deinitializer or protocol declarations, stored properties, property observers, or other extension declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張宣言は、デイニシャライザまたはプロトコル宣言、保存プロパティ、プロパティオブザーバー、または他の拡張宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extension declarations that extend a generic type can include <bpt i="0" x="0">&lt;e0&gt;</bpt>requirements<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体型を拡張する拡張宣言は、<bpt i="0" x="0">&lt;e0&gt;</bpt>requirements<ept i="0">&lt;/e0&gt;</ept>を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions are similar to categories in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張は、Objective-Cでのカテゴリーに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions can add computed instance properties and computed type properties to existing types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張は、既存の型に計算インスタンスプロパティと計算型プロパティを加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions can add new computed properties, but they cannot add stored properties, or add property observers to existing properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張は新しい計算プロパティを加えることができます、しかし、それは保存プロパティを加えることができません、またプロパティオブザーバーを既存のプロパティに加えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions can add new convenience initializers to a class, but they cannot add new designated initializers or deinitializers to a class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張は、新しい便利なイニシャライザをクラスに加えることができます、しかし、それは新しい指定イニシャライザまたはデイニシャライザをクラスに加えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions can add new functionality to a type, but they cannot override existing functionality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張は、新しい機能性をある型に加えることができます、しかしそれは既存の機能性をオーバーライドすることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions can add new initializers to existing types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張は、新しいイニシャライザを既存の型に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions can add new instance methods and type methods to existing types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張は、新しいインスタンスメソッドと型メソッドを既存の型に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions can add new nested types to existing classes, structures, and enumerations:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張は、新しい入れ子にされた型を既存のクラス、構造体、および列挙に加えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions can add new properties, methods, and subscripts to an existing type, and are therefore able to add any requirements that a protocol may demand.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張は、新しいプロパティ、メソッド、そして添え字を既存の型に加えることができます、したがって、あるプロトコルが要求するであろうどんな要件でも加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions can add new subscripts to an existing type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張は、新しい添え字を既存の型に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions in Swift can:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの拡張は、以下が可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions of a generic type can also include requirements that instances of the extended type must satisfy in order to gain the new functionality, as discussed in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Extensions with a Generic Where Clause<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある総称体型のそれぞれの拡張はまた、拡張された型のインスタンスが新しい機能性を獲得する手段として満たさなければならない要件を含むことができます、下の<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>総称体where節を持つ拡張<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions that are in the same file as the class, structure, or enumeration that they extend behave as if the code in the extension had been written as part of the original type’s declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが拡張するクラス、構造体、または列挙と同じファイルの中にある拡張は、まるでその拡張の中のコードがオリジナルの型の持つ宣言の一部として書かれたかのように振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions to a type in the same file can access that type’s private members.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じファイル中のある型への拡張は、その型のもつ非公開メソッドメンバにアクセスできる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions with a Generic Where Clause</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体where節を持つ拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Failable Initializer Requirements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できるイニシャライザ要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Failable Initializers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Failable Initializers for Enumerations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙のための失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Failable Initializers for Enumerations with Raw Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の値を使う列挙のための失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fallthrough</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>抜け落ちる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fallthrough Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>フォールスルー文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, <bpt i="0" x="0">&lt;c0&gt;</bpt>Residence<ept i="0">&lt;/c0&gt;</ept> defines an optional property called <bpt i="1" x="1">&lt;c1&gt;</bpt>address<ept i="1">&lt;/c1&gt;</ept>, with a type of <bpt i="2" x="2">&lt;c2&gt;</bpt>Address?<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最終的に、<bpt i="0" x="0">&lt;c0&gt;</bpt>Residence<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>address<ept i="1">&lt;/c1&gt;</ept>と呼ばれるオプショナルのプロパティを、<bpt i="2" x="2">&lt;c2&gt;</bpt>Address?<ept i="2">&lt;/c2&gt;</ept>の型で定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, any convenience initializers in the chain have the option to customize the instance and to work with <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後に、連鎖の中のあらゆる便宜イニシャライザは、インスタンスを好みに合わせて作り変えるために、<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>を扱うために選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, it is set to a frame rate of <bpt i="5" x="5">&lt;c5&gt;</bpt>25.0<ept i="5">&lt;/c5&gt;</ept> frames per second.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後に、それは１秒につき<bpt i="5" x="5">&lt;c5&gt;</bpt>25.0<ept i="5">&lt;/c5&gt;</ept>フレームのフレームレートに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, once the subclass’s designated initializer is finished, the convenience initializer that was originally called can perform additional customization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後に、一旦サブクラスの指定イニシャライザが作業をし終えるならば、最初に呼ばれた便宜イニシャライザは追加の特注処理を実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, the <bpt i="1" x="1">&lt;c1&gt;</bpt>default<ept i="1">&lt;/c1&gt;</ept> case matches any other character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最終的に、<bpt i="1" x="1">&lt;c1&gt;</bpt>default<ept i="1">&lt;/c1&gt;</ept>ケース節が他の文字のすべてにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, the blue component is obtained by performing a bitwise AND between the numbers <bpt i="0" x="0">&lt;c0&gt;</bpt>0xCC6699<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>0x0000FF<ept i="1">&lt;/c1&gt;</ept>, which gives an output value of <bpt i="2" x="2">&lt;c2&gt;</bpt>0x000099<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後に、青の構成要素は数<bpt i="0" x="0">&lt;c0&gt;</bpt>0xCC6699<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>0x0000FF<ept i="1">&lt;/c1&gt;</ept>との間のビット単位の論理積を実行することによって得られます、それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>0x000099<ept i="2">&lt;/c2&gt;</ept>の出力値を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Finally, the overall minimum and maximum values are returned as a tuple of two <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後に、全体で最も小さいそして最も大きい値が２つの<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>値のタプルとして返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Find out whether a <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> value is empty by checking its Boolean <bpt i="1" x="1">&lt;c1&gt;</bpt>isEmpty<ept i="1">&lt;/c1&gt;</ept> property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>値が空かどうかを、それのブールの<bpt i="1" x="1">&lt;c1&gt;</bpt>isEmpty<ept i="1">&lt;/c1&gt;</ept>プロパティを調べることで確認してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>First, it’s possible that <bpt i="1" x="1">&lt;c1&gt;</bpt>dataSource<ept i="1">&lt;/c1&gt;</ept> may be <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>, and so <bpt i="3" x="3">&lt;c3&gt;</bpt>dataSource<ept i="3">&lt;/c3&gt;</ept> has a question mark after its name to indicate that <bpt i="4" x="4">&lt;c4&gt;</bpt>increment(forCount:)<ept i="4">&lt;/c4&gt;</ept> should be called only if <bpt i="5" x="5">&lt;c5&gt;</bpt>dataSource<ept i="5">&lt;/c5&gt;</ept> isn’t <bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第１に、<bpt i="1" x="1">&lt;c1&gt;</bpt>dataSource<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>かもしれない可能性があります、なので、<bpt i="3" x="3">&lt;c3&gt;</bpt>dataSource<ept i="3">&lt;/c3&gt;</ept>はその名前の後に疑問符を持ち、<bpt i="5" x="5">&lt;c5&gt;</bpt>dataSource<ept i="5">&lt;/c5&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept>でない場合にのみ<bpt i="4" x="4">&lt;c4&gt;</bpt>increment(forCount:)<ept i="4">&lt;/c4&gt;</ept>が呼ばれるべきであるのを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>First, two classes called <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Residence<ept i="1">&lt;/c1&gt;</ept> are defined:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初に、<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Residence<ept i="1">&lt;/c1&gt;</ept>（個人と邸宅）と呼ばれる２つのクラスが定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>First, you can add <bpt i="0" x="0">&lt;c0&gt;</bpt>-1<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>-4<ept i="1">&lt;/c1&gt;</ept>, simply by performing a standard binary addition of all eight bits (including the sign bit), and discarding anything that doesn’t fit in the eight bits once you’re done:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第１に、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>-1<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>-4<ept i="1">&lt;/c1&gt;</ept>に加えることが、単純に８つのビット全て（符号ビットを含む）の通常のバイナリの加算を実行して、あなたがそうしたならばその８ビットに収まらない何でも捨てることによって行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Floating-Point Literals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Floating-Point Numbers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Floating-point literals can be decimal (with no prefix), or hexadecimal (with a <bpt i="0" x="0">&lt;c0&gt;</bpt>0x<ept i="0">&lt;/c0&gt;</ept> prefix).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点リテラルは、10進（接頭辞なし）、または16進（接頭辞<bpt i="0" x="0">&lt;c0&gt;</bpt>0x<ept i="0">&lt;/c0&gt;</ept>つき）であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Floating-point literals can begin with leading zeros (<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>), but are likewise ignored and don’t affect the base or value of the literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点リテラルは、いくつかのゼロ（<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>）を先頭に始まることができます、しかし同様に無視されて、リテラルの基数または値に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Floating-point to integer conversion must also be made explicit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点を整数に変換することは、また、明示的に行われる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Floating-point types can represent a much wider range of values than integer types, and can store numbers that are much larger or smaller than can be stored in an <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点型は、整数型よりずっと広い値の幅を表すことができ、そして<bpt i="0" x="0">&lt;c0&gt;</bpt>Intに<ept i="0">&lt;/c0&gt;</ept>保存できるよりずっと大きいまたは小さい数を保存することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Floating-point values are always truncated when used to initialize a new integer value in this way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この方法で新しい整数値を初期化するとき、浮動小数点値は常に切り詰められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a complete list of Swift operator precedences and associativity rules, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Expressions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの演算子優先順位と結合性規則の完全な一覧のために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>式<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a complete list of operators and precedence groups provided by the Swift standard library, see <bpt i="6" x="6">&lt;e6&gt;</bpt><it pos="begin" x="7">&lt;!7&gt;</it>Swift Standard Library Operators Reference<it pos="begin" x="8">&lt;!8&gt;</it><ept i="6">&lt;/e6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト標準ライブラリによって提供される演算子と優先順位グループの完全なリストとして、<bpt i="6" x="6">&lt;e6&gt;</bpt><it pos="begin" x="7">&lt;!7&gt;</it>Swift標準ライブラリ演算子リファレンス<it pos="begin" x="8">&lt;!8&gt;</it><ept i="6">&lt;/e6&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a complete list of the compound assignment operators provided by the Swift standard library, see <bpt i="0" x="0">&lt;e0&gt;</bpt><it pos="begin" x="1">&lt;!1&gt;</it>Swift Standard Library Operators Reference<it pos="begin" x="2">&lt;!2&gt;</it><ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト標準ライブラリで提供される複合代入演算子の完全な一覧は、<bpt i="0" x="0">&lt;e0&gt;</bpt><it pos="begin" x="1">&lt;!1&gt;</it>スウィフト標準ライブラリ演算子リファレンス<it pos="begin" x="2">&lt;!2&gt;</it><ept i="0">&lt;/e0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a complete list of the operator precedence groups and associativity settings, for the operators provided by the Swift standard library, see <bpt i="4" x="4">&lt;e4&gt;</bpt><it pos="begin" x="5">&lt;!5&gt;</it>Swift Standard Library Operators Reference<it pos="begin" x="6">&lt;!6&gt;</it><ept i="4">&lt;/e4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子優先順位グループと結合性設定の完全なリストとして、スウィフト標準ライブラリによって定義される演算子については、<bpt i="4" x="4">&lt;e4&gt;</bpt><it pos="begin" x="5">&lt;!5&gt;</it>Swift Standard Library Operators Reference<it pos="begin" x="6">&lt;!6&gt;</it><ept i="4">&lt;/e4&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a description of the <bpt i="0" x="0">&lt;e0&gt;</bpt>Snakes and Ladders<ept i="0">&lt;/e0&gt;</ept> gameplay, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Break<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section of the <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Control Flow<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ヘビとはしご<ept i="0">&lt;/e0&gt;</ept>のゲームプレイの解説として、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>制御の流れ<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>の<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>中断する<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>の節を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a detailed discussion of the Swift standard library <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> type, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Arrays<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト標準ライブラリ<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>型の詳細な議論のために、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>配列<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a detailed discussion of the Swift standard library <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> type, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Dictionaries<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト標準ライブラリ<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>型の詳細な議論として、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>辞書<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a detailed discussion of the behavior of in-out parameters and associated compiler optimizations, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>In-Out Parameters<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>in-outパラメータの挙動と関連するコンパイラ最適化の詳細な議論として、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>in-outパラメータ<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a detailed discussion of the behavior of in-out parameters, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>In-Out Parameters<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>in-outパラメータの振る舞いの詳細な議論のために、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>in-outパラメータ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a dictionary that stores <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> values, for example, the method returns a value of type <bpt i="2" x="2">&lt;c2&gt;</bpt>String?<ept i="2">&lt;/c2&gt;</ept>, or “optional <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値を保存する辞書に対しては、このメソッドは型<bpt i="2" x="2">&lt;c2&gt;</bpt>String?<ept i="2">&lt;/c2&gt;</ept>、すなわち「オプショナルの<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>」の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a discussion and several examples of classes that include various kinds of declarations, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Classes and Structures<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>議論および、いろいろな種類の宣言を含むクラスのいくつかの例のために、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>クラスと構造体<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a discussion and several examples of extensions that include various kinds of declarations, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Extensions<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>議論といろいろな種類の宣言を含む拡張のいくつかの例のために、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>拡張<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a discussion and several examples of structures that include various kinds of declarations, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Classes and Structures<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>議論および、いろいろな種類の宣言を含む構造体のいくつかの例のために、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>クラスと構造体<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a discussion of nested functions, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Nested Functions<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされた関数の議論のために、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>入れ子にされた関数<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a list of characters that can be used to define custom operators, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Operators<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あつらえの演算子を定義するために使用できる文字のリストとして、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>演算子<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a paragraph element, the closure would return <bpt i="3" x="3">&lt;c3&gt;</bpt>"&lt;p&gt;some text&lt;/p&gt;"<ept i="3">&lt;/c3&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt>"&lt;p /&gt;"<ept i="4">&lt;/c4&gt;</ept>, depending on whether the <bpt i="5" x="5">&lt;c5&gt;</bpt>text<ept i="5">&lt;/c5&gt;</ept> property equals <bpt i="6" x="6">&lt;c6&gt;</bpt>"some text"<ept i="6">&lt;/c6&gt;</ept> or <bpt i="7" x="7">&lt;c7&gt;</bpt>nil<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>段落要素のために、このクロージャは、<bpt i="5" x="5">&lt;c5&gt;</bpt>text<ept i="5">&lt;/c5&gt;</ept>プロパティが<bpt i="6" x="6">&lt;c6&gt;</bpt>"some text"<ept i="6">&lt;/c6&gt;</ept>または<bpt i="7" x="7">&lt;c7&gt;</bpt>nil<ept i="7">&lt;/c7&gt;</ept>に等しいかどうかに従って、<bpt i="3" x="3">&lt;c3&gt;</bpt>"&lt;p&gt;some text&lt;/p&gt;"<ept i="3">&lt;/c3&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt>"&lt;p /&gt;"<ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a property marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>NSManaged<ept i="1">&lt;/c1&gt;</ept> attribute, Core Data also provides the storage at runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>NSManaged<ept i="1">&lt;/c1&gt;</ept>属性で印されるプロパティに対して、Coreデータはまたストレージを実行時に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a protocol that inherits from another protocol, you add a constraint to an inherited associated type by including the generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clause in the protocol declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>別のプロトコルから継承するプロトコルに対して、あなたは継承された関連型への制約の追加を、総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節をそのプロトコル宣言の中で含めることによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a type that is defined as <bpt i="1" x="1">&lt;c1&gt;</bpt>public<ept i="1">&lt;/c1&gt;</ept>, the default initializer is considered internal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>public<ept i="1">&lt;/c1&gt;</ept>として定義される型のために、その省略時のイニシャライザは内部と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an alternative way to write this example without defining the <bpt i="0" x="0">&lt;c0&gt;</bpt>init()<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>init(origin:size:)<ept i="1">&lt;/c1&gt;</ept> initializers yourself, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Extensions<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>init()<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>init(origin:size:)<ept i="1">&lt;/c1&gt;</ept>イニシャライザをあなた自身で定義することなくこの例を書く代わりの方法のために、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>拡張<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example and more information about the <bpt i="0" x="0">&lt;c0&gt;</bpt>unowned<ept i="0">&lt;/c0&gt;</ept> modifier, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Unowned References<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>unowned<ept i="0">&lt;/c0&gt;</ept>修飾子についての例とさらなる情報として、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>非所有参照<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example and more information about the <bpt i="1" x="1">&lt;c1&gt;</bpt>weak<ept i="1">&lt;/c1&gt;</ept> modifier, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Weak References<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>weak<ept i="1">&lt;/c1&gt;</ept>修飾子についての例と更なる情報のために、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>弱い参照<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example of an autoclosure function type parameter, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Autoclosures<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自動クロージャ関数型パラメータの例として、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>自動クロージャ<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example of an enumeration definition that uses a type inheritance clause to specify the type of its raw values, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Raw Values<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その生の値の型を指定するために型継承節を使う列挙定義の例のために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>生の値<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example of how to use a <bpt i="0" x="0">&lt;c0&gt;</bpt>fallthrough<ept i="0">&lt;/c0&gt;</ept> statement in a <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Control Transfer Statements<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> in <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Control Flow<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>fallthrough<ept i="0">&lt;/c0&gt;</ept>文を<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文において使う方法の例のために、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>制御移動文<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を章<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>制御の流れ<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example of how to use a <bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept> statement, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Propagating Errors Using Throwing Functions<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> in <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Error Handling<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept>文を使う方法の例のために、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>スロー関数を使ってエラーを伝える<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>エラー処理<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>の章で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example of how to use a deinitializer in a class declaration, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Deinitialization<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス宣言においてデイニシャライザを使う方法の例のために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>デイニシャライズ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example of how to use protocol inheritance, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocol Inheritance<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル継承を使う方法の例のために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコル継承<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example of how to use the <bpt i="0" x="0">&lt;c0&gt;</bpt>autoclosure<ept i="0">&lt;/c0&gt;</ept> attribute, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Autoclosures<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> and <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Function Type<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>autoclosure<ept i="0">&lt;/c0&gt;</ept>属性を使用する方法の例として、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>自動クロージャ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>と<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>関数型<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example of how to use the <bpt i="0" x="0">&lt;c0&gt;</bpt>final<ept i="0">&lt;/c0&gt;</ept> attribute, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Preventing Overrides<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>final<ept i="0">&lt;/c0&gt;</ept>属性を使う方法の例として、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>オーバーライドを防ぐ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example of how to use the <bpt i="0" x="0">&lt;c0&gt;</bpt>lazy<ept i="0">&lt;/c0&gt;</ept> modifier, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Lazy Stored Properties<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>lazy<ept i="0">&lt;/c0&gt;</ept>修飾子を使う方法の例として、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>遅延保存プロパティ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example of how to use the <bpt i="2" x="2">&lt;c2&gt;</bpt>escaping<ept i="2">&lt;/c2&gt;</ept> attribute, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Escaping Closures<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>escaping<ept i="2">&lt;/c2&gt;</ept>属性を使う方法の例として、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>脱出クロージャ<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example that demonstrates both of these features, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Functions with Multiple Return Values<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの特徴の両方を示す例のために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>複数の戻り値をもつ関数<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example that uses a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement to match enumeration cases containing associated values, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Associated Values<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連値を含んでいる列挙ケース節にマッチするために<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文を使う例のために、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>関連値<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example that uses a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement to match values with <bpt i="1" x="1">&lt;c1&gt;</bpt>is<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>as<ept i="2">&lt;/c2&gt;</ept> patterns, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Type Casting for Any and AnyObject<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文を使用して、さまざまに値を<bpt i="1" x="1">&lt;c1&gt;</bpt>is<ept i="1">&lt;/c1&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt>as<ept i="2">&lt;/c2&gt;</ept>パターンとマッチする例のために、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>AnyおよびAnyObjectに対する型キャスト<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example that uses a variadic parameter, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Variadic Parameters<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変長パラメータを使う例のために、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>可変長パラメータ<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example that uses a variadic parameter, see <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Variadic Parameters<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変長パラメータを使う例のために、<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>可変長パラメータ<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example that uses the ternary conditional operator, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Ternary Conditional Operator<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>三項条件演算子を使用する例のために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>三項条件演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an extended discussion and several examples of class inheritance, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Inheritance<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス継承の広範囲にわたる議論といくつかの例のために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>継承<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an overview of generics in Swift, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Generics<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでの総称体の概要のために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>総称体<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For both signed and unsigned integers, overflow in the positive direction wraps around from the maximum valid integer value back to the minimum, and overflow in the negative direction wraps around from the minimum value to the maximum.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号つきおよび符号なし整数の両方に対して、正の方向でのオーバフローは最大限の有効な整数値から逆に最小限へとぐるっと送り込まれ、負の方向でのオーバフローは最小限の値から最大限へとぐるっと送り込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For brevity, multiple values are covered in a single <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>簡潔にするため、複数の値が１つの<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>ケース節で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For characters in strings, “greater than” means “appears later in the alphabet than”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の中の文字のために、「より大きい」は「アルファベットにおいてより後に現れる」ことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For class instances, a constant property can be modified during initialization only by the class that introduces it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスインスタンスのために、定数プロパティは、それを導入するクラスによってのみ初期化の間に修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For class instances, the initializer that’s called must be marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept> keyword or the entire class marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>final<ept i="1">&lt;/c1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスインスタンスに対しては、呼び出されるイニシャライザが<bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept>キーワードで印されるか、クラス全体が<bpt i="1" x="1">&lt;c1&gt;</bpt>final<ept i="1">&lt;/c1&gt;</ept>キーワードで印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For computed type properties for class types, you can use the <bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept> keyword instead to allow subclasses to override the superclass’s implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス型のための計算型プロパティに対しては、あなたは代わりに<bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept>キーワードを使って、サブクラスにそのスーパークラスの実装のオーバーライドを許可することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For convenience and because the distinction isn’t that important in Swift, the term <bpt i="0" x="0">&lt;e0&gt;</bpt>declaration<ept i="0">&lt;/e0&gt;</ept> covers both declarations and definitions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>便利さとその区別がスウィフトにおいてそんなに重要でないことから、用語<bpt i="0" x="0">&lt;e0&gt;</bpt>宣言<ept i="0">&lt;/e0&gt;</ept>は、宣言と定義を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For decimal numbers with an exponent of <bpt i="0" x="0">&lt;c0&gt;</bpt>exp<ept i="0">&lt;/c0&gt;</ept>, the base number is multiplied by 10<bpt i="1" x="1">&lt;s1&gt;</bpt>exp<ept i="1">&lt;/s1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>exp<ept i="0">&lt;/c0&gt;</ept>の指数を持つある10進数に対して、その基数は10<bpt i="1" x="1">&lt;s1&gt;</bpt>exp<ept i="1">&lt;/s1&gt;</ept>を掛けられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For details, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Break in a Switch Statement<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>スイッチ文の中断<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For each entry in the capture list, a constant is initialized to the value of the constant or variable that has the same name in the surrounding scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キャプチャリストのそれぞれの登録項目に対して、その定数や変数の値へとひとつの定数が初期化されます、それは囲んでいるスコープの中で同じ名前を待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For each integer in the array, the function considers the <bpt i="2" x="2">&lt;c2&gt;</bpt>kind<ept i="2">&lt;/c2&gt;</ept> computed property for that integer, and prints an appropriate description.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その配列の各整数に対して、この関数はその整数に対する<bpt i="2" x="2">&lt;c2&gt;</bpt>kind<ept i="2">&lt;/c2&gt;</ept>計算プロパティを考慮して、適切な説明を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For each item in the array, the <bpt i="1" x="1">&lt;c1&gt;</bpt>enumerated()<ept i="1">&lt;/c1&gt;</ept> method returns a tuple composed of an integer and the item.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この配列の各項目に対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>enumerated()<ept i="1">&lt;/c1&gt;</ept>メソッドは、整数とその項目から成るひとつのタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For each item, the function checks whether the item from <bpt i="4" x="4">&lt;c4&gt;</bpt>someContainer<ept i="4">&lt;/c4&gt;</ept> isn’t equal to the corresponding item in <bpt i="5" x="5">&lt;c5&gt;</bpt>anotherContainer<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各項目のために、関数は<bpt i="4" x="4">&lt;c4&gt;</bpt>someContainer<ept i="4">&lt;/c4&gt;</ept>からの項目が<bpt i="5" x="5">&lt;c5&gt;</bpt>anotherContainer<ept i="5">&lt;/c5&gt;</ept>での対応する項目と同等でないかどうか確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example in the code below, <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> is included in the capture list but <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept> is not, which gives them different behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば以下のコードにおいて、<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>はキャプチャリストに含まれますが<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>はそうではありません、そのことはそれらに異なる挙動を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="0" x="0">&lt;c0&gt;</bpt>((Int, Int)) -&gt; Void<ept i="0">&lt;/c0&gt;</ept> is the type of a function that takes a single parameter of the tuple type <bpt i="1" x="1">&lt;c1&gt;</bpt>(Int, Int)<ept i="1">&lt;/c1&gt;</ept> and doesn’t return any value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>((Int, Int)) -&gt; Void<ept i="0">&lt;/c0&gt;</ept>は、タプル型<bpt i="1" x="1">&lt;c1&gt;</bpt>(Int, Int)<ept i="1">&lt;/c1&gt;</ept>の単一のパラメータを取り、何ら値を返さない関数の型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="0" x="0">&lt;c0&gt;</bpt>(Int)<ept i="0">&lt;/c0&gt;</ept> is equivalent to <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>(Int)<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> is a type identifier that directly refers to the named type <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>, and the type identifier <bpt i="2" x="2">&lt;c2&gt;</bpt>Dictionary&lt;String, Int&gt;<ept i="2">&lt;/c2&gt;</ept> directly refers to the named type <bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary&lt;String, Int&gt;<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>は、直接に名前付きの型<bpt i="1" x="1">&lt;c1&gt;</bpt>Intに<ept i="1">&lt;/c1&gt;</ept>言及する型識別子です、そして型識別子<bpt i="2" x="2">&lt;c2&gt;</bpt>Dictionary&lt;String, Int&gt;<ept i="2">&lt;/c2&gt;</ept>は、直接に名前付きの型<bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary&lt;String, Int&gt;<ept i="3">&lt;/c3&gt;</ept>に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="0" x="0">&lt;c0&gt;</bpt>LATIN SMALL LETTER E WITH ACUTE<ept i="0">&lt;/c0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>U+00E9<ept i="1">&lt;/c1&gt;</ept>) is canonically equivalent to <bpt i="2" x="2">&lt;c2&gt;</bpt>LATIN SMALL LETTER E<ept i="2">&lt;/c2&gt;</ept> (<bpt i="3" x="3">&lt;c3&gt;</bpt>U+0065<ept i="3">&lt;/c3&gt;</ept>) followed by <bpt i="4" x="4">&lt;c4&gt;</bpt>COMBINING ACUTE ACCENT<ept i="4">&lt;/c4&gt;</ept> (<bpt i="5" x="5">&lt;c5&gt;</bpt>U+0301<ept i="5">&lt;/c5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>LATIN SMALL LETTER E WITH ACUTE<ept i="0">&lt;/c0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>U+00E9<ept i="1">&lt;/c1&gt;</ept>）は、<bpt i="2" x="2">&lt;c2&gt;</bpt>LATIN SMALL LETTER E<ept i="2">&lt;/c2&gt;</ept>（<bpt i="3" x="3">&lt;c3&gt;</bpt>U+0065<ept i="3">&lt;/c3&gt;</ept>）に<bpt i="4" x="4">&lt;c4&gt;</bpt>COMBINING ACUTE ACCENT<ept i="4">&lt;/c4&gt;</ept>（<bpt i="5" x="5">&lt;c5&gt;</bpt>U+0301<ept i="5">&lt;/c5&gt;</ept>）を続けたものと正準等価です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="1" x="1">&lt;c1&gt;</bpt>.+.<ept i="1">&lt;/c1&gt;</ept> is treated as a single operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>.+.<ept i="1">&lt;/c1&gt;</ept>は単一の演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;S1: Sequence, S2: Sequence&gt; where S1.Iterator.Element == S2.Iterator.Element<ept i="1">&lt;/c1&gt;</ept> expresses the constraints that <bpt i="2" x="2">&lt;c2&gt;</bpt>S1<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>S2<ept i="3">&lt;/c3&gt;</ept> conform to the <bpt i="4" x="4">&lt;c4&gt;</bpt>Sequence<ept i="4">&lt;/c4&gt;</ept> protocol and that the elements of both sequences must be of the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;S1: Sequence, S2: Sequence&gt; where S1.Iterator.Element == S2.Iterator.Element<ept i="1">&lt;/c1&gt;</ept>が表す制約は、<bpt i="2" x="2">&lt;c2&gt;</bpt>S1<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>S2<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>Sequence<ept i="4">&lt;/c4&gt;</ept>プロトコルに準拠すること、そして両方のシーケンスの要素が同じ型でなければならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="1" x="1">&lt;c1&gt;</bpt>SomeClass.self<ept i="1">&lt;/c1&gt;</ept> returns <bpt i="2" x="2">&lt;c2&gt;</bpt>SomeClass<ept i="2">&lt;/c2&gt;</ept> itself, not an instance of <bpt i="3" x="3">&lt;c3&gt;</bpt>SomeClass<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>SomeClass.self<ept i="1">&lt;/c1&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt>SomeClass<ept i="2">&lt;/c2&gt;</ept>自身を返します、<bpt i="3" x="3">&lt;c3&gt;</bpt>SomeClass<ept i="3">&lt;/c3&gt;</ept>のインスタンスではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept> is not a valid identifier, but <bpt i="2" x="2">&lt;c2&gt;</bpt>`class`<ept i="2">&lt;/c2&gt;</ept> is valid.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept>は有効な識別子ではありません、しかし、<bpt i="2" x="2">&lt;c2&gt;</bpt>`class`<ept i="2">&lt;/c2&gt;</ept>は有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="1" x="1">&lt;c1&gt;</bpt>x.self<ept i="1">&lt;/c1&gt;</ept> evaluates to <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>x.self<ept i="1">&lt;/c1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="2" x="2">&lt;c2&gt;</bpt>+.+<ept i="2">&lt;/c2&gt;</ept> is treated as the <bpt i="3" x="3">&lt;c3&gt;</bpt>+<ept i="3">&lt;/c3&gt;</ept> operator followed by the <bpt i="4" x="4">&lt;c4&gt;</bpt>.+<ept i="4">&lt;/c4&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="2" x="2">&lt;c2&gt;</bpt>+.+<ept i="2">&lt;/c2&gt;</ept>は、<bpt i="3" x="3">&lt;c3&gt;</bpt>+<ept i="3">&lt;/c3&gt;</ept>演算子に<bpt i="4" x="4">&lt;c4&gt;</bpt>.+<ept i="4">&lt;/c4&gt;</ept>演算子が続くとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="3" x="3">&lt;c3&gt;</bpt>0xFp2<ept i="3">&lt;/c3&gt;</ept> represents 15 x 2<bpt i="4" x="4">&lt;s4&gt;</bpt>2<ept i="4">&lt;/s4&gt;</ept>, which evaluates to <bpt i="5" x="5">&lt;c5&gt;</bpt>60<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="3" x="3">&lt;c3&gt;</bpt>0xFp2<ept i="3">&lt;/c3&gt;</ept>は15 × 2<bpt i="4" x="4">&lt;s4&gt;</bpt>2<ept i="4">&lt;/s4&gt;</ept>を表します、それは<bpt i="5" x="5">&lt;c5&gt;</bpt>60<ept i="5">&lt;/c5&gt;</ept>に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="3" x="3">&lt;c3&gt;</bpt>1.25e2<ept i="3">&lt;/c3&gt;</ept> represents 1.25 x 10<bpt i="4" x="4">&lt;s4&gt;</bpt>2<ept i="4">&lt;/s4&gt;</ept>, which evaluates to <bpt i="5" x="5">&lt;c5&gt;</bpt>125.0<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="3" x="3">&lt;c3&gt;</bpt>1.25e2<ept i="3">&lt;/c3&gt;</ept>は1.25 × 10<bpt i="4" x="4">&lt;s4&gt;</bpt>2<ept i="4">&lt;/s4&gt;</ept>を表します、それは<bpt i="5" x="5">&lt;c5&gt;</bpt>125.0<ept i="5">&lt;/c5&gt;</ept>に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="5" x="5">&lt;c5&gt;</bpt>&lt;S: Sequence&gt; where S.Iterator.Element: Equatable<ept i="5">&lt;/c5&gt;</ept> specifies that <bpt i="6" x="6">&lt;c6&gt;</bpt>S<ept i="6">&lt;/c6&gt;</ept> conforms to the <bpt i="7" x="7">&lt;c7&gt;</bpt>Sequence<ept i="7">&lt;/c7&gt;</ept> protocol and that the associated type <bpt i="8" x="8">&lt;c8&gt;</bpt>S.Iterator.Element<ept i="8">&lt;/c8&gt;</ept> conforms to the <bpt i="9" x="9">&lt;c9&gt;</bpt>Equatable<ept i="9">&lt;/c9&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="5" x="5">&lt;c5&gt;</bpt>&lt;S: Sequence&gt; where S.Iterator.Element: Equatable<ept i="5">&lt;/c5&gt;</ept>が指定するのは、<bpt i="6" x="6">&lt;c6&gt;</bpt>S<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Sequence<ept i="7">&lt;/c7&gt;</ept>プロトコルに準拠すること、そして関連型<bpt i="8" x="8">&lt;c8&gt;</bpt>S.Iterator.Element<ept i="8">&lt;/c8&gt;</ept>が<bpt i="9" x="9">&lt;c9&gt;</bpt>Equatable<ept i="9">&lt;/c9&gt;</ept>プロトコルに準拠することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="6" x="6">&lt;c6&gt;</bpt>Int8<ept i="6">&lt;/c6&gt;</ept> conforms to the <bpt i="7" x="7">&lt;c7&gt;</bpt>ExpressibleByIntegerLiteral<ept i="7">&lt;/c7&gt;</ept> protocol, and therefore it can be used in the type annotation for the integer literal <bpt i="8" x="8">&lt;c8&gt;</bpt>42<ept i="8">&lt;/c8&gt;</ept> in the declaration <bpt i="9" x="9">&lt;c9&gt;</bpt>let x: Int8 = 42<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="6" x="6">&lt;c6&gt;</bpt>Int8<ept i="6">&lt;/c6&gt;</ept>は<bpt i="7" x="7">&lt;c7&gt;</bpt>ExpressibleByIntegerLiteral<ept i="7">&lt;/c7&gt;</ept>プロトコルに準拠します、したがってそれは宣言<bpt i="9" x="9">&lt;c9&gt;</bpt>let x: Int8 = 42<ept i="9">&lt;/c9&gt;</ept>の中の整数リテラル<bpt i="8" x="8">&lt;c8&gt;</bpt>42<ept i="8">&lt;/c8&gt;</ept>のための型注釈において使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, Hangul syllables from the Korean alphabet can be represented as either a precomposed or decomposed sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、コリアン・アルファベットのハングル音節は、最初から組み立てられるか、または分解されて並べたもののどちらでも表わすことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> type implements a subscript to set and retrieve the values stored in a <bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept>インスタンスに保存される値を設定したり取り出すために添え字を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> type places a limitation on the types that can be used as keys for a dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>型は、辞書のキーとして使われることができる型に制限を置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, Swift’s <bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Dictionary<ept i="2">&lt;/c2&gt;</ept> types are both generic collections.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、スウィフトの<bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>Dictionary<ept i="2">&lt;/c2&gt;</ept>型は、両方とも総称体コレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, a case named <bpt i="1" x="1">&lt;c1&gt;</bpt>venus<ept i="1">&lt;/c1&gt;</ept> in a Swift <bpt i="2" x="2">&lt;c2&gt;</bpt>Planet<ept i="2">&lt;/c2&gt;</ept> enumeration is exposed to Objective-C code as a case named <bpt i="3" x="3">&lt;c3&gt;</bpt>PlanetVenus<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、スウィフトの<bpt i="2" x="2">&lt;c2&gt;</bpt>Planet<ept i="2">&lt;/c2&gt;</ept>列挙の中の<bpt i="1" x="1">&lt;c1&gt;</bpt>venus<ept i="1">&lt;/c1&gt;</ept>と名付けられるケース節は、Objective-Cコードに<bpt i="3" x="3">&lt;c3&gt;</bpt>PlanetVenus<ept i="3">&lt;/c3&gt;</ept>と名付けられるケース節として暴露されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, a method of type <bpt i="0" x="0">&lt;c0&gt;</bpt>(Int) -&gt; String<ept i="0">&lt;/c0&gt;</ept> becomes <bpt i="1" x="1">&lt;c1&gt;</bpt>((Int) -&gt; String)?<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、型<bpt i="0" x="0">&lt;c0&gt;</bpt>(Int) -&gt; String<ept i="0">&lt;/c0&gt;</ept>のメソッドは<bpt i="1" x="1">&lt;c1&gt;</bpt>((Int) -&gt; String)?<ept i="1">&lt;/c1&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, a private type alias can alias a private, file-private, internal, public, or open type, but a public type alias can’t alias an internal, file-private, or private type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、非公開の型エイリアスは、非公開、ファイル外非公開、内部、公開、または開放型のエイリアス（別名）となることができます、しかし公開型エイリアスは、内部、ファイル外非公開、または非公開型をエイリアスできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, a variadic parameter with a name of <bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<ept i="0">&lt;/c0&gt;</ept> and a type of <bpt i="1" x="1">&lt;c1&gt;</bpt>Double...<ept i="1">&lt;/c1&gt;</ept> is made available within the function’s body as a constant array called <bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept> of type <bpt i="3" x="3">&lt;c3&gt;</bpt>[Double]<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<ept i="0">&lt;/c0&gt;</ept>の名前と<bpt i="1" x="1">&lt;c1&gt;</bpt>Double...<ept i="1">&lt;/c1&gt;</ept>の型を持つある可変長パラメータは、関数の本文内で型<bpt i="2" x="2">&lt;c2&gt;</bpt>[Double]<ept i="2">&lt;/c2&gt;</ept>の<bpt i="3" x="3">&lt;c3&gt;</bpt>numbers<ept i="3">&lt;/c3&gt;</ept>と呼ばれるある定数配列として利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, all of the following string literals have the same value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下の文字列リテラルの全ては、同じ値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, because <bpt i="1" x="1">&lt;c1&gt;</bpt>SomeClass.self<ept i="1">&lt;/c1&gt;</ept> evaluates to the <bpt i="2" x="2">&lt;c2&gt;</bpt>SomeClass<ept i="2">&lt;/c2&gt;</ept> type itself, you can pass it to a function or method that accepts a type-level argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>SomeClass.self<ept i="1">&lt;/c1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>SomeClass<ept i="2">&lt;/c2&gt;</ept>型それ自体に評価されるので、あなたはそれを型レベルの引数を受け入れる関数またはメソッドへ渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, both <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> can be compared, which means tuples of the type <bpt i="2" x="2">&lt;c2&gt;</bpt>(Int, String)<ept i="2">&lt;/c2&gt;</ept> can be compared.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>は両方とも比較されることができます、それは型<bpt i="2" x="2">&lt;c2&gt;</bpt>(Int, String)<ept i="2">&lt;/c2&gt;</ept>のタプルが比較されることができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider the case of requesting the sunrise and sunset times from a server.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、日の出と日没の時間をあるサーバーに要請する場合を考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, given the following simple protocol:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下の簡単なプロトコルを与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, here is an enumeration that stores simple arithmetic expressions:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ここに単純な算術式を格納する列挙があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, here’s a function that evaluates an arithmetic expression:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ここに算術式の数値を求める関数があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, here’s how you might represent the error conditions of operating a vending machine inside a game:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ここにあなたが表すかもしれないあるゲーム内の自動販売機操作のエラー状況がどのようなものかがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if a public type conforms to an internal protocol, the type’s implementation of each protocol requirement must be at least “internal”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ある公開型が内部プロトコルに準拠するならば、その型の持つ各プロトコル要件の実装は少なくとも「内部」でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if you assign a literal value of <bpt i="0" x="0">&lt;c0&gt;</bpt>42<ept i="0">&lt;/c0&gt;</ept> to a new constant without saying what type it is, Swift infers that you want the constant to be an <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>, because you have initialized it with a number that looks like an integer:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたがそれがどんな型であるかについて言うことなく、新しい定数にリテラル値<bpt i="0" x="0">&lt;c0&gt;</bpt>42<ept i="0">&lt;/c0&gt;</ept>を代入するならば、スウィフトは、あなたがその定数に<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>であって欲しいのだと推測します、なぜならあなたがそれを整数のように見える数で初期化したからです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if you compose a tuple from two different types, one with internal access and one with private access, the access level for that compound tuple type will be private.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたが２つの異なる型、内部アクセスを持つものと非公開アクセスを持つものからタプルを組み立てるならば、その複合のタプル型のためのアクセス水準は非公開になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if you create a custom class to open a file and write some data to it, you might need to close the file before the class instance is deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたがファイルを開いてそれに何かのデータを書くあつらえのクラスを作成するならば、クラスインスタンスが割り当て解除される前に、あなたはファイルを閉じる必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if you define a file-private class, that class can only be used as the type of a property, or as a function parameter or return type, in the source file in which the file-private class is defined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたがあるファイル外非公開のクラスを定義するならば、そのクラスは、プロパティの型として、または関数パラメータや戻り型として、そのファイル外非公開クラスが定義されるソースファイルの中で使われることだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if you initialize a new string with the four-character word <bpt i="0" x="0">&lt;c0&gt;</bpt>cafe<ept i="0">&lt;/c0&gt;</ept>, and then append a <bpt i="1" x="1">&lt;c1&gt;</bpt>COMBINING ACUTE ACCENT<ept i="1">&lt;/c1&gt;</ept> (<bpt i="2" x="2">&lt;c2&gt;</bpt>U+0301<ept i="2">&lt;/c2&gt;</ept>) to the end of the string, the resulting string will still have a character count of <bpt i="3" x="3">&lt;c3&gt;</bpt>4<ept i="3">&lt;/c3&gt;</ept>, with a fourth character of <bpt i="4" x="4">&lt;c4&gt;</bpt>é<ept i="4">&lt;/c4&gt;</ept>, not <bpt i="5" x="5">&lt;c5&gt;</bpt>e<ept i="5">&lt;/c5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたがある新しい文字列を４文字の単語<bpt i="0" x="0">&lt;c0&gt;</bpt>cafe<ept i="0">&lt;/c0&gt;</ept>で初期化して、それから<bpt i="1" x="1">&lt;c1&gt;</bpt>COMBINING ACUTE ACCENT<ept i="1">&lt;/c1&gt;</ept>（<bpt i="2" x="2">&lt;c2&gt;</bpt>U+0301<ept i="2">&lt;/c2&gt;</ept>）をその文字列の終わりに加えたならば、結果の文字列は依然として文字数<bpt i="3" x="3">&lt;c3&gt;</bpt>4<ept i="3">&lt;/c3&gt;</ept>で、<bpt i="5" x="5">&lt;c5&gt;</bpt>e<ept i="5">&lt;/c5&gt;</ept>ではなく、<bpt i="4" x="4">&lt;c4&gt;</bpt>é<ept i="4">&lt;/c4&gt;</ept>の４番目の文字を持ちます：&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if your app uses a custom subclass of <bpt i="3" x="3">&lt;c3&gt;</bpt>UIApplication<ept i="3">&lt;/c3&gt;</ept> as its principal class, call the <bpt i="4" x="4">&lt;c4&gt;</bpt>UIApplicationMain(_:_:_:_:)<ept i="4">&lt;/c4&gt;</ept> function instead of using this attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたのアプリがそれの主役クラス（プリンシパルクラス）として<bpt i="3" x="3">&lt;c3&gt;</bpt>UIApplication<ept i="3">&lt;/c3&gt;</ept>のあつらえのサブクラスを使うならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>UIApplicationMain(_:_:_:_:)<ept i="4">&lt;/c4&gt;</ept>関数をこの属性を使用する代わりに呼んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, in the code below, the closure passed to <bpt i="2" x="2">&lt;c2&gt;</bpt>someFunctionWithEscapingClosure(_:)<ept i="2">&lt;/c2&gt;</ept> is an escaping closure, which means it needs to refer to <bpt i="3" x="3">&lt;c3&gt;</bpt>self<ept i="3">&lt;/c3&gt;</ept> explicitly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードにおいて、<bpt i="2" x="2">&lt;c2&gt;</bpt>someFunctionWithEscapingClosure(_:)<ept i="2">&lt;/c2&gt;</ept>に渡されるクロージャは脱出クロージャです、それは、それが<bpt i="3" x="3">&lt;c3&gt;</bpt>self<ept i="3">&lt;/c3&gt;</ept>を明示的に参照する必要があるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, in the declaration <bpt i="0" x="0">&lt;c0&gt;</bpt>let x: Int8 = 42<ept i="0">&lt;/c0&gt;</ept>, Swift uses the explicit type annotation (<bpt i="1" x="1">&lt;c1&gt;</bpt>: Int8<ept i="1">&lt;/c1&gt;</ept>) to infer that the type of the integer literal <bpt i="2" x="2">&lt;c2&gt;</bpt>42<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、宣言<bpt i="0" x="0">&lt;c0&gt;</bpt>let x: Int8 = 42<ept i="0">&lt;/c0&gt;</ept>において、スウィフトは明示的な型注釈（<bpt i="1" x="1">&lt;c1&gt;</bpt>: Int8<ept i="1">&lt;/c1&gt;</ept>）を使って、整数リテラル<bpt i="2" x="2">&lt;c2&gt;</bpt>42<ept i="2">&lt;/c2&gt;</ept>の型は<bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept>であると推論します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, in the declaration <bpt i="8" x="8">&lt;c8&gt;</bpt>let str = "Hello, world"<ept i="8">&lt;/c8&gt;</ept>, the default inferred type of the string literal <bpt i="9" x="9">&lt;c9&gt;</bpt>"Hello, world"<ept i="9">&lt;/c9&gt;</ept> is <bpt i="10" x="10">&lt;c10&gt;</bpt>String<ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、宣言<bpt i="8" x="8">&lt;c8&gt;</bpt>let str = "Hello, world"<ept i="8">&lt;/c8&gt;</ept>において、文字列リテラル<bpt i="9" x="9">&lt;c9&gt;</bpt>"Hello, world"<ept i="9">&lt;/c9&gt;</ept>の省略時の推論される型は<bpt i="10" x="10">&lt;c10&gt;</bpt>String<ept i="10">&lt;/c10&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, in the following assignment 10 is assigned to <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> and 20 is ignored:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下の代入において、10は<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>に代入されて20は無視されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, in the following code <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept> have the same value and behavior:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードにおいて<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept>は、同じ値と挙動を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, in the following constant declaration, <bpt i="1" x="1">&lt;c1&gt;</bpt>someValue<ept i="1">&lt;/c1&gt;</ept> is an identifier pattern that matches the value <bpt i="2" x="2">&lt;c2&gt;</bpt>42<ept i="2">&lt;/c2&gt;</ept> of type <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下の定数宣言において、<bpt i="1" x="1">&lt;c1&gt;</bpt>someValue<ept i="1">&lt;/c1&gt;</ept>は、型<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>の値<bpt i="2" x="2">&lt;c2&gt;</bpt>42<ept i="2">&lt;/c2&gt;</ept>にマッチする識別子パターンです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, instances of a user-defined class named <bpt i="1" x="1">&lt;c1&gt;</bpt>MyClass<ept i="1">&lt;/c1&gt;</ept> have the type <bpt i="2" x="2">&lt;c2&gt;</bpt>MyClass<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>MyClass<ept i="1">&lt;/c1&gt;</ept>という名前をつけられるユーザー定義のクラスのインスタンスは、型<bpt i="2" x="2">&lt;c2&gt;</bpt>MyClass<ept i="2">&lt;/c2&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, instead of writing <bpt i="0" x="0">&lt;c0&gt;</bpt>var x: Int = 0<ept i="0">&lt;/c0&gt;</ept>, you can write <bpt i="1" x="1">&lt;c1&gt;</bpt>var x = 0<ept i="1">&lt;/c1&gt;</ept>, omitting the type completely—the compiler correctly infers that <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept> names a value of type <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>var x: Int = 0<ept i="0">&lt;/c0&gt;</ept>を書く代わりに、あなたは型を完全に省略して<bpt i="1" x="1">&lt;c1&gt;</bpt>var x = 0<ept i="1">&lt;/c1&gt;</ept>と書くことができます ― コンパイラは、<bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>が型<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>の値に名をつけると正しく推測します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, operator precedence explains why the following expression equals <bpt i="0" x="0">&lt;c0&gt;</bpt>17<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、演算子優先順位は、なぜ以下の式が<bpt i="0" x="0">&lt;c0&gt;</bpt>17<ept i="0">&lt;/c0&gt;</ept>に等しいのかを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, suppose an inventory tracking system needs to track products by two different types of barcode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ある在庫追跡システムが、２つの異なる型のバーコードによって製品を追跡する必要があると思ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, suppose you want to make a version of <bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept> that includes an iterator, like what the <bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept> protocol uses in the standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたが<bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept>のあるバージョンを作りたいと仮定してください、それはあるイテレータ、標準ライブラリで使われている<bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept>プロトコルのようなものを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>Int16<ept i="0">&lt;/c0&gt;</ept> integer type can hold any signed integer between <bpt i="1" x="1">&lt;c1&gt;</bpt>-32768<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>32767<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Int16<ept i="0">&lt;/c0&gt;</ept>整数型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>-32768<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>32767<ept i="2">&lt;/c2&gt;</ept>の間のどんな符号つき整数でも持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>PrettyTextRepresentable<ept i="0">&lt;/c0&gt;</ept> protocol, which inherits the <bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept> protocol can provide a default implementation of its required <bpt i="2" x="2">&lt;c2&gt;</bpt>prettyTextualDescription<ept i="2">&lt;/c2&gt;</ept> property to simply return the result of accessing the <bpt i="3" x="3">&lt;c3&gt;</bpt>textualDescription<ept i="3">&lt;/c3&gt;</ept> property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept>プロトコルを継承する<bpt i="0" x="0">&lt;c0&gt;</bpt>prettyTextualDescription<ept i="0">&lt;/c0&gt;</ept>プロパティは、それの必須プロパティ<bpt i="2" x="2">&lt;c2&gt;</bpt>prettyTextualDescription<ept i="2">&lt;/c2&gt;</ept>の省略時の実装を提供して、単に<bpt i="3" x="3">&lt;c3&gt;</bpt>textualDescription<ept i="3">&lt;/c3&gt;</ept>プロパティの結果を返すようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>RandomNumberGenerator<ept i="0">&lt;/c0&gt;</ept> protocol can be extended to provide a <bpt i="1" x="1">&lt;c1&gt;</bpt>randomBool()<ept i="1">&lt;/c1&gt;</ept> method, which uses the result of the required <bpt i="2" x="2">&lt;c2&gt;</bpt>random()<ept i="2">&lt;/c2&gt;</ept> method to return a random <bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>RandomNumberGenerator<ept i="0">&lt;/c0&gt;</ept>プロトコルは拡張されて<bpt i="1" x="1">&lt;c1&gt;</bpt>randomBool()<ept i="1">&lt;/c1&gt;</ept>メソッドを提供することができます、それは必須メソッドの<bpt i="2" x="2">&lt;c2&gt;</bpt>random()<ept i="2">&lt;/c2&gt;</ept>を利用してランダムな<bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept>値を返すものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>UntitledDocument<ept i="0">&lt;/c0&gt;</ept> subclass below is always named <bpt i="1" x="1">&lt;c1&gt;</bpt>"[Untitled]"<ept i="1">&lt;/c1&gt;</ept>, and it uses the failable <bpt i="2" x="2">&lt;c2&gt;</bpt>init(name:)<ept i="2">&lt;/c2&gt;</ept> initializer from its superclass during initialization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、下の<bpt i="0" x="0">&lt;c0&gt;</bpt>UntitledDocument<ept i="0">&lt;/c0&gt;</ept>サブクラスは、常に<bpt i="1" x="1">&lt;c1&gt;</bpt>"[Untitled]"<ept i="1">&lt;/c1&gt;</ept>と名前をつけられます、そしてそれは失敗できる<bpt i="2" x="2">&lt;c2&gt;</bpt>init(name:)<ept i="2">&lt;/c2&gt;</ept>イニシャライザをそれのスーパークラスから初期化の間に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>asHTML<ept i="0">&lt;/c0&gt;</ept> property could be set to a closure that defaults to some text if the <bpt i="1" x="1">&lt;c1&gt;</bpt>text<ept i="1">&lt;/c1&gt;</ept> property is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>, in order to prevent the representation from returning an empty HTML tag:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>asHTML<ept i="0">&lt;/c0&gt;</ept>プロパティは、あるクロージャに設定されることができます、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>text<ept i="1">&lt;/c1&gt;</ept>プロパティが<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>ならば特に何もしなくともいくらかのテキストになり、その表現が空のHTMLタグを返すことを予防する手段となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="10" x="10">&lt;c10&gt;</bpt>&lt;<ept i="10">&lt;/c10&gt;</ept> operator has an associativity of <bpt i="11" x="11">&lt;c11&gt;</bpt>none<ept i="11">&lt;/c11&gt;</ept>, which means <bpt i="12" x="12">&lt;c12&gt;</bpt>1 &lt; 2 &lt; 3<ept i="12">&lt;/c12&gt;</ept> is not a valid expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="10" x="10">&lt;c10&gt;</bpt>&lt;<ept i="10">&lt;/c10&gt;</ept>演算子は、<bpt i="11" x="11">&lt;c11&gt;</bpt>none<ept i="11">&lt;/c11&gt;</ept>の関係性を持ちます、それは<bpt i="12" x="12">&lt;c12&gt;</bpt>1 &lt; 2 &lt; 3<ept i="12">&lt;/c12&gt;</ept>が有効な式でないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="2" x="2">&lt;c2&gt;</bpt>assert(condition:message:file:line:)<ept i="2">&lt;/c2&gt;</ept> function takes an autoclosure for its <bpt i="3" x="3">&lt;c3&gt;</bpt>condition<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>message<ept i="4">&lt;/c4&gt;</ept> parameters; its <bpt i="5" x="5">&lt;c5&gt;</bpt>condition<ept i="5">&lt;/c5&gt;</ept> parameter is evaluated only in debug builds and its <bpt i="6" x="6">&lt;c6&gt;</bpt>message<ept i="6">&lt;/c6&gt;</ept> parameter is evaluated only if <bpt i="7" x="7">&lt;c7&gt;</bpt>condition<ept i="7">&lt;/c7&gt;</ept> is <bpt i="8" x="8">&lt;c8&gt;</bpt>false<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="2" x="2">&lt;c2&gt;</bpt>assert(condition:message:file:line:)<ept i="2">&lt;/c2&gt;</ept>関数は自動クロージャをそれの<bpt i="3" x="3">&lt;c3&gt;</bpt>condition<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>message<ept i="4">&lt;/c4&gt;</ept>パラメータとして取ります；それの<bpt i="5" x="5">&lt;c5&gt;</bpt>condition<ept i="5">&lt;/c5&gt;</ept>パラメータはデバッグビルドにおいてのみ評価されます、そしてそれの<bpt i="6" x="6">&lt;c6&gt;</bpt>message<ept i="6">&lt;/c6&gt;</ept>パラメータは<bpt i="7" x="7">&lt;c7&gt;</bpt>condition<ept i="7">&lt;/c7&gt;</ept>が<bpt i="8" x="8">&lt;c8&gt;</bpt>false<ept i="8">&lt;/c8&gt;</ept>である場合にのみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="5" x="5">&lt;c5&gt;</bpt>buyFavoriteSnack(person:vendingMachine:)<ept i="5">&lt;/c5&gt;</ept> in the example below is also a throwing function, and any errors that the <bpt i="6" x="6">&lt;c6&gt;</bpt>vend(itemNamed:)<ept i="6">&lt;/c6&gt;</ept> method throws will propagate up to the point where the <bpt i="7" x="7">&lt;c7&gt;</bpt>buyFavoriteSnack(person:vendingMachine:)<ept i="7">&lt;/c7&gt;</ept> function is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえば、下の例の<bpt i="5" x="5">&lt;c5&gt;</bpt>buyFavoriteSnack(person:vendingMachine:)<ept i="5">&lt;/c5&gt;</ept>もまたスロー関数です、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>vend(itemNamed:)<ept i="6">&lt;/c6&gt;</ept>メソッドがスローするあらゆるエラーは、<bpt i="7" x="7">&lt;c7&gt;</bpt>buyFavoriteSnack(person:vendingMachine:)<ept i="7">&lt;/c7&gt;</ept>関数が呼び出される地点へとさかのぼり伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the addition (<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>) and subtraction (<bpt i="1" x="1">&lt;c1&gt;</bpt>-<ept i="1">&lt;/c1&gt;</ept>) operators belong to the <bpt i="2" x="2">&lt;c2&gt;</bpt>AdditionPrecedence<ept i="2">&lt;/c2&gt;</ept> group, and the multiplication (<bpt i="3" x="3">&lt;c3&gt;</bpt>*<ept i="3">&lt;/c3&gt;</ept>) and division (<bpt i="4" x="4">&lt;c4&gt;</bpt>/<ept i="4">&lt;/c4&gt;</ept>) operators belong to the <bpt i="5" x="5">&lt;c5&gt;</bpt>MultiplicationPrecedence<ept i="5">&lt;/c5&gt;</ept> group.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、加算（<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>）および減算（<bpt i="1" x="1">&lt;c1&gt;</bpt>-<ept i="1">&lt;/c1&gt;</ept>）演算子は、<bpt i="2" x="2">&lt;c2&gt;</bpt>AdditionPrecedence<ept i="2">&lt;/c2&gt;</ept>グルーブに所属し、そして乗算（<bpt i="3" x="3">&lt;c3&gt;</bpt>*<ept i="3">&lt;/c3&gt;</ept>）および減算（<bpt i="4" x="4">&lt;c4&gt;</bpt>/<ept i="4">&lt;/c4&gt;</ept>）演算子は<bpt i="5" x="5">&lt;c5&gt;</bpt>MultiplicationPrecedence<ept i="5">&lt;/c5&gt;</ept>グルーブに属します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the addition assignment operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>+=<ept i="2">&lt;/c2&gt;</ept>) combines addition and assignment into a single operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、加算代入演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>+=<ept i="2">&lt;/c2&gt;</ept>）は、加算と代入を一回の操作に結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the addition operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>) adds two numbers, as in <bpt i="2" x="2">&lt;c2&gt;</bpt>let i = 1 + 2<ept i="2">&lt;/c2&gt;</ept>, and the logical AND operator (<bpt i="3" x="3">&lt;c3&gt;</bpt>&amp;&amp;<ept i="3">&lt;/c3&gt;</ept>) combines two Boolean values, as in <bpt i="4" x="4">&lt;c4&gt;</bpt>if enteredDoorCode &amp;&amp; passedRetinaScan<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、加算演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>）は、<bpt i="2" x="2">&lt;c2&gt;</bpt>let i = 1 + 2<ept i="2">&lt;/c2&gt;</ept>のように、２つの数を加えてひとつにします、そして論理積演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt>&amp;&amp;<ept i="3">&lt;/c3&gt;</ept>）は、<bpt i="4" x="4">&lt;c4&gt;</bpt>if enteredDoorCode &amp;&amp; passedRetinaScan<ept i="4">&lt;/c4&gt;</ept>のように、２つのブール値を組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the class below ensures that the side length of its triangle is always the same as the side length of its square.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、下のクラスは、その三角形の横の長さが常にその正方形の横の長さと同じものであることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the declarations of <bpt i="1" x="1">&lt;c1&gt;</bpt>SubProtocol<ept i="1">&lt;/c1&gt;</ept> below are equivalent:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、下の<bpt i="1" x="1">&lt;c1&gt;</bpt>SubProtocol<ept i="1">&lt;/c1&gt;</ept>の宣言は同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the definition of <bpt i="0" x="0">&lt;c0&gt;</bpt>PQR<ept i="0">&lt;/c0&gt;</ept> in the code below is equivalent to <bpt i="1" x="1">&lt;c1&gt;</bpt>P &amp; Q &amp; R<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードでの<bpt i="0" x="0">&lt;c0&gt;</bpt>PQR<ept i="0">&lt;/c0&gt;</ept>の定義は、<bpt i="1" x="1">&lt;c1&gt;</bpt>P &amp; Q &amp; R<ept i="1">&lt;/c1&gt;</ept>と同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the expression <bpt i="0" x="0">&lt;c0&gt;</bpt>2 + 3 * 5<ept i="0">&lt;/c0&gt;</ept> is initially understood as a flat list of five items, <bpt i="1" x="1">&lt;c1&gt;</bpt>2<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>+<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>*<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>5<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、式<bpt i="0" x="0">&lt;c0&gt;</bpt>2 + 3 * 5<ept i="0">&lt;/c0&gt;</ept>は、最初に５つの項目、<bpt i="1" x="1">&lt;c1&gt;</bpt>2<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>+<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>*<ept i="4">&lt;/c4&gt;</ept>、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>5<ept i="5">&lt;/c5&gt;</ept>の平坦なリストとして理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the expression <bpt i="2" x="2">&lt;c2&gt;</bpt>(5 + 4) * 2<ept i="2">&lt;/c2&gt;</ept> has a number on the right-hand side of the multiplication and another expression on the left-hand side of the multiplication.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、式<bpt i="2" x="2">&lt;c2&gt;</bpt>(5 + 4) * 2<ept i="2">&lt;/c2&gt;</ept>は、１つの数を掛け算の右手側に、そして別の式を掛け算の左手側に持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following are equivalent:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のものはどれも等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code declares a <bpt i="1" x="1">&lt;c1&gt;</bpt>ComparableContainer<ept i="1">&lt;/c1&gt;</ept> protocol that requires <bpt i="2" x="2">&lt;c2&gt;</bpt>Item<ept i="2">&lt;/c2&gt;</ept> to conform to <bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードは<bpt i="1" x="1">&lt;c1&gt;</bpt>ComparableContainer<ept i="1">&lt;/c1&gt;</ept>プロトコルを宣言します、それは<bpt i="2" x="2">&lt;c2&gt;</bpt>Item<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>に準拠することを要求します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code defines a version of <bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept> that requires the items in the container to be equatable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードは<bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept>のあるバージョンを定義します、それはコンテナの中の項目に同等評価可能であることを要求するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code handles all three cases of the <bpt i="6" x="6">&lt;c6&gt;</bpt>VendingMachineError<ept i="6">&lt;/c6&gt;</ept> enumeration, but all other errors have to be handled by its surrounding scope:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードは<bpt i="6" x="6">&lt;c6&gt;</bpt>VendingMachineError<ept i="6">&lt;/c6&gt;</ept>列挙のケース節の３つすべてを取り扱います、しかし他のエラーすべてはそれの取り囲んでいるスコープで処理されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code isn’t valid because the element <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept> in the tuple pattern <bpt i="3" x="3">&lt;c3&gt;</bpt>(x, 0)<ept i="3">&lt;/c3&gt;</ept> is an expression pattern:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードは有効ではありません、タプルパターン<bpt i="3" x="3">&lt;c3&gt;</bpt>(x, 0)<ept i="3">&lt;/c3&gt;</ept>の中の要素<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>が式パターンであるためです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code iterates through the closed range <bpt i="2" x="2">&lt;c2&gt;</bpt>1...3<ept i="2">&lt;/c2&gt;</ept>, ignoring the current value of the range on each iteration of the loop:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、完結範囲<bpt i="2" x="2">&lt;c2&gt;</bpt>1...3<ept i="2">&lt;/c2&gt;</ept>のすべてに繰り返す以下のコードは、ループの各繰り返しにおいて範囲の現在の値を無視しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code throws an error to indicate that five additional coins are needed by the vending machine:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードはあるエラーをスローして、５つの追加のコインが自動販売機に必要とされることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code uses <bpt i="1" x="1">&lt;c1&gt;</bpt>\.someProperty<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードは<bpt i="1" x="1">&lt;c1&gt;</bpt>\.someProperty<ept i="1">&lt;/c1&gt;</ept>を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code uses <bpt i="1" x="1">&lt;c1&gt;</bpt>\OuterStructure.outerProperty.someProperty<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードは<bpt i="1" x="1">&lt;c1&gt;</bpt>\OuterStructure.outerProperty.someProperty<ept i="1">&lt;/c1&gt;</ept>を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code uses a <bpt i="0" x="0">&lt;c0&gt;</bpt>loadImage(atPath:)<ept i="0">&lt;/c0&gt;</ept> function, which loads the image resource at a given path or throws an error if the image can’t be loaded.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードは<bpt i="0" x="0">&lt;c0&gt;</bpt>loadImage(atPath:)<ept i="0">&lt;/c0&gt;</ept>関数を使います、それは画像リソースを与えられたパスでロードします、または画像がロードできないならばエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code uses several approaches to fetch data, or returns <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> if all of the approaches fail.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードはいくつかの取り組みを使ってデータを取ってきます、またはすべての取り組みが失敗するならば<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following is invalid because the <bpt i="6" x="6">&lt;c6&gt;</bpt>catch<ept i="6">&lt;/c6&gt;</ept> clause would handle the error thrown by <bpt i="7" x="7">&lt;c7&gt;</bpt>alwaysThrows()<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のものは無効です、なぜなら<bpt i="6" x="6">&lt;c6&gt;</bpt>catch<ept i="6">&lt;/c6&gt;</ept>節が<bpt i="7" x="7">&lt;c7&gt;</bpt>alwaysThrows()<ept i="7">&lt;/c7&gt;</ept>によってスローされるエラーを取り扱おうとするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following listing shows chained method calls split over several lines:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコード出力は、連結されたメソッド呼び出しがいくつかの行に分けられるのを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following protocol can be adopted only by class types:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のプロトコルはクラス型によってのみ採用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the function type <bpt i="1" x="1">&lt;c1&gt;</bpt>(Int) -&gt; (Int) -&gt; Int<ept i="1">&lt;/c1&gt;</ept> is understood as <bpt i="2" x="2">&lt;c2&gt;</bpt>(Int) -&gt; ((Int) -&gt; Int)<ept i="2">&lt;/c2&gt;</ept>—that is, a function that takes an <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> and returns another function that takes and returns an <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、関数型<bpt i="1" x="1">&lt;c1&gt;</bpt>(Int) -&gt; (Int) -&gt; Int<ept i="1">&lt;/c1&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt>(Int) -&gt; ((Int) -&gt; Int)<ept i="2">&lt;/c2&gt;</ept>として理解されます ― すなわち、ひとつの<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>を取って、ひとつの<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>を取りそして返す別の関数を返す関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the initializer for the <bpt i="0" x="0">&lt;c0&gt;</bpt>PurchasedSnack<ept i="0">&lt;/c0&gt;</ept> structure in the listing below calls a throwing function as part of the initialization process, and it handles any errors that it encounters by propagating them to its caller.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコード出力の<bpt i="0" x="0">&lt;c0&gt;</bpt>PurchasedSnack<ept i="0">&lt;/c0&gt;</ept>構造体のためのイニシャライザは、スロー関数を初期化処理の一部として呼び出します、そしてそれは、それが遭遇するどんなエラーもそれの呼び出し側にそれらを伝達することによって取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the metatype of the class type <bpt i="2" x="2">&lt;c2&gt;</bpt>SomeClass<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>SomeClass.Type<ept i="3">&lt;/c3&gt;</ept> and the metatype of the protocol <bpt i="4" x="4">&lt;c4&gt;</bpt>SomeProtocol<ept i="4">&lt;/c4&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>SomeProtocol.Protocol<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、クラス型<bpt i="2" x="2">&lt;c2&gt;</bpt>SomeClass<ept i="2">&lt;/c2&gt;</ept>のメタタイプは<bpt i="3" x="3">&lt;c3&gt;</bpt>SomeClass.Type<ept i="3">&lt;/c3&gt;</ept>です、そして、プロトコル<bpt i="4" x="4">&lt;c4&gt;</bpt>SomeProtocol<ept i="4">&lt;/c4&gt;</ept>のメタタイプは<bpt i="5" x="5">&lt;c5&gt;</bpt>SomeProtocol.Protocol<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the structure of a tuple <bpt i="1" x="1">&lt;c1&gt;</bpt>(1, 2)<ept i="1">&lt;/c1&gt;</ept> is a comma-separated list of two elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、タプル<bpt i="1" x="1">&lt;c1&gt;</bpt>(1, 2)<ept i="1">&lt;/c1&gt;</ept>の構造は、コンマで区切られた２つの要素のリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the subtraction operator (<bpt i="5" x="5">&lt;c5&gt;</bpt>-<ept i="5">&lt;/c5&gt;</ept>) is left-associative, so the expression <bpt i="6" x="6">&lt;c6&gt;</bpt>4 - 5 - 6<ept i="6">&lt;/c6&gt;</ept> is grouped as <bpt i="7" x="7">&lt;c7&gt;</bpt>(4 - 5) - 6<ept i="7">&lt;/c7&gt;</ept> and evaluates to <bpt i="8" x="8">&lt;c8&gt;</bpt>-7<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、減算演算子（<bpt i="5" x="5">&lt;c5&gt;</bpt>-<ept i="5">&lt;/c5&gt;</ept>）は左結合です、それで式<bpt i="6" x="6">&lt;c6&gt;</bpt>4 - 5 - 6<ept i="6">&lt;/c6&gt;</ept>は<bpt i="7" x="7">&lt;c7&gt;</bpt>(4 - 5) - 6<ept i="7">&lt;/c7&gt;</ept>のようにグループにされて、<bpt i="8" x="8">&lt;c8&gt;</bpt>-7<ept i="8">&lt;/c8&gt;</ept>に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the tuple pattern <bpt i="0" x="0">&lt;c0&gt;</bpt>(x, y): (Int, Int)<ept i="0">&lt;/c0&gt;</ept> in the constant declaration <bpt i="1" x="1">&lt;c1&gt;</bpt>let (x, y): (Int, Int) = (1, 2)<ept i="1">&lt;/c1&gt;</ept> matches only tuple types in which both elements are of type <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、定数宣言<bpt i="1" x="1">&lt;c1&gt;</bpt>let (x, y): (Int, Int) = (1, 2)<ept i="1">&lt;/c1&gt;</ept>におけるタプルパターン<bpt i="0" x="0">&lt;c0&gt;</bpt>(x, y): (Int, Int)<ept i="0">&lt;/c0&gt;</ept>は、両方の要素が型<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>であるタプル型だけにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the type identifier in the following code references the named type <bpt i="1" x="1">&lt;c1&gt;</bpt>MyType<ept i="1">&lt;/c1&gt;</ept> that is declared in the <bpt i="2" x="2">&lt;c2&gt;</bpt>ExampleModule<ept i="2">&lt;/c2&gt;</ept> module.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードの型識別子は、<bpt i="2" x="2">&lt;c2&gt;</bpt>ExampleModule<ept i="2">&lt;/c2&gt;</ept>モジュールで宣言される名前付きの型<bpt i="1" x="1">&lt;c1&gt;</bpt>MyType<ept i="1">&lt;/c1&gt;</ept>を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the values of <bpt i="1" x="1">&lt;c1&gt;</bpt>textA<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>textB<ept i="2">&lt;/c2&gt;</ept> in the example below are identical—no runtime concatenation is performed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえば、以下の例の<bpt i="1" x="1">&lt;c1&gt;</bpt>textA<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>textB<ept i="2">&lt;/c2&gt;</ept>の値は同一です ― 実行時連結は行われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, there are two things named <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> in the code below, a variable in the outer scope and a constant in the inner scope, but they both refer to the same object because of reference semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と名前をつけられる２つのものが以下のコードにはあります、外側のスコープの中の変数と内側のスコープの中の定数、しかしそれらは両方とも同じオブジェクトを参照します、なぜなら参照意味論だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, this is useful when the name of a declaration is changed between releases of a framework or library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、これは宣言の名前がフレームワークまたはライブラリのリリースの間で変更されたときに役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, this protocol, called <bpt i="0" x="0">&lt;c0&gt;</bpt>TextRepresentable<ept i="0">&lt;/c0&gt;</ept>, can be implemented by any type that has a way to be represented as text.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、このプロトコル、<bpt i="0" x="0">&lt;c0&gt;</bpt>TextRepresentable<ept i="0">&lt;/c0&gt;</ept>と呼ばれるものは、テキストとして表わされる方法を持つどんな型によってでも実装されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, to create a new stack of strings, you write <bpt i="1" x="1">&lt;c1&gt;</bpt>Stack&lt;String&gt;()<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、新しく文字列のスタックを作成するために、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>Stack&lt;String&gt;()<ept i="1">&lt;/c1&gt;</ept>を書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, use a precondition to check that a subscript is not out of bounds, or to check that a function has been passed a valid value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、前提時要件を使って、ある添え字が範囲外でないことを調べてください、またはある関数が有効な値を渡されていることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, when a computed property or a property with observers is passed as an in-out parameter, its getter is called as part of the function call and its setter is called as part of the function return.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、計算プロパティまたはオブザーバを持つプロパティがin-outパラメータとして渡される時、それのゲッターは関数呼び出しの一部として呼び出され、それのセッターは関数の戻りの一部として呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, writing <bpt i="0" x="0">&lt;c0&gt;</bpt>shoppingList[shoppingList.count] = "Salt"<ept i="0">&lt;/c0&gt;</ept> to try to append an item to the end of the array results in a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>shoppingList[shoppingList.count] = "Salt"<ept i="0">&lt;/c0&gt;</ept>と書くことでこの配列の終わりに項目を加えようとするのは実行時エラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you access elements in an <bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept> instance as <bpt i="2" x="2">&lt;c2&gt;</bpt>someArray[index]<ept i="2">&lt;/c2&gt;</ept> and elements in a <bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary<ept i="3">&lt;/c3&gt;</ept> instance as <bpt i="4" x="4">&lt;c4&gt;</bpt>someDictionary[key]<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはある<bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept>インスタンスの中の要素に<bpt i="2" x="2">&lt;c2&gt;</bpt>someArray[index]<ept i="2">&lt;/c2&gt;</ept>として、そしてある<bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary<ept i="3">&lt;/c3&gt;</ept>インスタンスの中の要素に<bpt i="4" x="4">&lt;c4&gt;</bpt>someDictionary[key]<ept i="4">&lt;/c4&gt;</ept>のようにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can create a three-dimensional array of integers using three sets of square brackets:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたは３つ固めた角括弧を使って整数の三次元配列をつくることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can decompose the elements of a tuple and bind the value of each element to a corresponding identifier pattern.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはタプルの要素を分解して、各要素の値を対応する識別子パターンへと縛り付けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can define a constant or variable to be of a function type and assign an appropriate function to that variable:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはある関数型となる定数または変数を定義して、適切な関数をその変数に代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can define a public type that can be used in other modules, but whose conformance to an internal protocol can only be used within the internal protocol’s defining module.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえば、あなたは、別のモジュール内で使われることができる公開の型を定義することができます、しかし内部プロトコルに準拠するものは、ただその内部プロトコル定義のモジュール内で使われることができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can refine the behavior of that existing implementation, or store a modified value in an existing inherited variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはその既存の実施の挙動を洗練させたり、既存の継承された変数に修正された値を保存することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can replace the type parameter <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> in <bpt i="1" x="1">&lt;c1&gt;</bpt>Array&lt;Element&gt;<ept i="1">&lt;/c1&gt;</ept> with a specialized version of an array, <bpt i="2" x="2">&lt;c2&gt;</bpt>Array&lt;Int&gt;<ept i="2">&lt;/c2&gt;</ept>, to form an array whose elements are themselves arrays of integers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>Array&lt;Element&gt;<ept i="1">&lt;/c1&gt;</ept>における型パラメータ<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>を配列の特殊化版、<bpt i="2" x="2">&lt;c2&gt;</bpt>Array&lt;Int&gt;<ept i="2">&lt;/c2&gt;</ept>で置き換えて、要素それ自身が整数の配列である配列を作り出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can rewrite the above example to compare the <bpt i="1" x="1">&lt;c1&gt;</bpt>point<ept i="1">&lt;/c1&gt;</ept> expression with a string representations of points.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたは上記の例を書き直して、<bpt i="1" x="1">&lt;c1&gt;</bpt>point<ept i="1">&lt;/c1&gt;</ept>式をpoint（座標）の文字列表現と比較するようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can use a <bpt i="4" x="4">&lt;c4&gt;</bpt>defer<ept i="4">&lt;/c4&gt;</ept> statement to ensure that file descriptors are closed and manually allocated memory is freed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたは<bpt i="4" x="4">&lt;c4&gt;</bpt>defer<ept i="4">&lt;/c4&gt;</ept>文を使ってファイル記述子が閉じられて手動割り当てメモリが解放されることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can use the protocol composition type <bpt i="0" x="0">&lt;c0&gt;</bpt>ProtocolA &amp; ProtocolB &amp; ProtocolC<ept i="0">&lt;/c0&gt;</ept> instead of declaring a new protocol that inherits from <bpt i="1" x="1">&lt;c1&gt;</bpt>ProtocolA<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>ProtocolB<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>ProtocolC<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、プロトコル合成型<bpt i="0" x="0">&lt;c0&gt;</bpt>ProtocolA &amp; ProtocolB &amp; ProtocolC<ept i="0">&lt;/c0&gt;</ept>を使うことが、<bpt i="1" x="1">&lt;c1&gt;</bpt>ProtocolA<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>ProtocolB<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>ProtocolC<ept i="3">&lt;/c3&gt;</ept>から継承する新しいプロトコルを宣言する代わりに行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can’t write <bpt i="0" x="0">&lt;c0&gt;</bpt>let b = a += 2<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>let b = a += 2<ept i="0">&lt;/c0&gt;</ept>を書くことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you use declarations to introduce functions and methods, variables and constants, and to define new, named enumeration, structure, class, and protocol types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはいろいろな宣言を使って、関数やメソッド、変数や定数を導入したり、そして新しく名前付きの、列挙、構造体、クラス、そしてプロトコル型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For examples of conforming types that implement the method requirements of a protocol, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Method Requirements<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコルのメソッド要件を満たすものである準拠している型の例のために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>メソッド要件<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For examples of conforming types that implement the property requirements of a protocol, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Property Requirements<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコルのプロパティ要件を実装するものである、準拠している型の例のために、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>プロパティ要件<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For examples of how to use a <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept> statement, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Break<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> and <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Labeled Statements<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> in <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Control Flow<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>文を使う方法の例のために、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>ブレーク文<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>と<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>ラベルをつけられた文<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を章<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>制御の流れ<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For examples of how to use a <bpt i="0" x="0">&lt;c0&gt;</bpt>continue<ept i="0">&lt;/c0&gt;</ept> statement, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Continue<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> and <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Labeled Statements<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> in <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Control Flow<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>continue<ept i="0">&lt;/c0&gt;</ept>文を使う方法の例のために、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>続ける<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>と<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>ラベルをつけられた文<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を章<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>制御の流れ<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For examples of how to use these various types of values in <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statements, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Switch<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> in <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Control Flow<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのいろいろな型の値を<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文で使う方法の例のために、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>スイッチ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>制御の流れ<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For hexadecimal numbers with an exponent of <bpt i="0" x="0">&lt;c0&gt;</bpt>exp<ept i="0">&lt;/c0&gt;</ept>, the base number is multiplied by 2<bpt i="1" x="1">&lt;s1&gt;</bpt>exp<ept i="1">&lt;/s1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>exp<ept i="0">&lt;/c0&gt;</ept>の指数を持つある16進数に対して、その基数は２<bpt i="1" x="1">&lt;s1&gt;</bpt>exp<ept i="1">&lt;/s1&gt;</ept>を掛けられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information about key-value coding and key-value observing, see <bpt i="3" x="3">&lt;e3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Key-Value Coding Programming Guide<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/e3&gt;</ept> and <bpt i="5" x="5">&lt;e5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Key-Value Observing Programming Guide<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/e5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー値コーディングとキー値監視についての情報として、<bpt i="3" x="3">&lt;e3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>キー値コーディングプログラミングガイド<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/e3&gt;</ept>（日本語文書）と<bpt i="5" x="5">&lt;e5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>キー値監視プログラミングガイド<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/e5&gt;</ept>（日本語文書）を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information about parameters with default values, see <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Default Parameter Values<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の値を持つパラメータについての情報として、<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>省略時のパラメータ値<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information about passing a closure as an argument to a function, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Function Call Expression<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャを引数として関数に渡すことに関する情報については、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>関数呼び出し式<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information about reference types, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Structures and Enumerations Are Value Types<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照型に関して詳しくは、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>構造体と列挙は値型です<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information about subscript declarations, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocol Subscript Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字宣言に関して詳しくは、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコル添え字宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information about the behavior of these operators, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Basic Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Advanced Operators<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの演算子の挙動に関して詳しくは、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>基本の演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>先進の演算子<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information about the operators provided by the Swift standard library, see <bpt i="0" x="0">&lt;e0&gt;</bpt><it pos="begin" x="1">&lt;!1&gt;</it>Swift Standard Library Operators Reference<it pos="begin" x="2">&lt;!2&gt;</it><ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト標準ライブラリによって提供される演算子についての情報のために、<bpt i="0" x="0">&lt;e0&gt;</bpt><it pos="begin" x="1">&lt;!1&gt;</it>スウィフト標準ライブラリ演算子リファレンス<it pos="begin" x="2">&lt;!2&gt;</it><ept i="0">&lt;/e0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information about the operators provided by the Swift standard library, see <bpt i="2" x="2">&lt;e2&gt;</bpt><it pos="begin" x="3">&lt;!3&gt;</it>Swift Standard Library Operators Reference<it pos="begin" x="4">&lt;!4&gt;</it><ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト標準ライブラリによって提供される演算子についての情報のために、<bpt i="2" x="2">&lt;e2&gt;</bpt><it pos="begin" x="3">&lt;!3&gt;</it>スウィフト標準ライブラリ演算子リファレンス<it pos="begin" x="4">&lt;!4&gt;</it><ept i="2">&lt;/e2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information about value types, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Structures and Enumerations Are Value Types<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型に関して詳しくは、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>構造体と列挙は値型です<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information on optional chaining, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Optional Chaining<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖に関する情報のために、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>オプショナル連鎖<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information on using playground literals in Xcode, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Xcode Help<ept i="0">&lt;/a0&gt;</ept> &gt; Use playgrounds &gt; Add a literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Xcodeにおけるプレイグラウンドリテラルの使用に関するさらなる情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>Xcode Help<ept i="0">&lt;/a0&gt;</ept> &gt; Use playgrounds &gt; Add a literal を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance methods on value types (that is, structures and enumerations) you place the <bpt i="1" x="1">&lt;c1&gt;</bpt>mutating<ept i="1">&lt;/c1&gt;</ept> keyword before a method’s <bpt i="2" x="2">&lt;c2&gt;</bpt>func<ept i="2">&lt;/c2&gt;</ept> keyword to indicate that the method is allowed to modify the instance it belongs to and any properties of that instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型（すなわち、構造体と列挙）のインスタンスメソッドのために、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>mutating<ept i="1">&lt;/c1&gt;</ept>キーワードをメソッドの<bpt i="2" x="2">&lt;c2&gt;</bpt>func<ept i="2">&lt;/c2&gt;</ept>キーワードの前に置いて、メソッドがそれが属しているインスタンスおよびそのインスタンスのあらゆるプロパティを修正するのを許可されることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, a <bpt i="10" x="10">&lt;e10&gt;</bpt>control expression<ept i="10">&lt;/e10&gt;</ept> matches the case in the example below only if it is a tuple that contains two elements of the same value, such as <bpt i="11" x="11">&lt;c11&gt;</bpt>(1, 1)<ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ある<bpt i="10" x="10">&lt;e10&gt;</bpt>制御式<ept i="10">&lt;/e10&gt;</ept>は、それが同じ値の２つの要素を持つタプル、例えば<bpt i="11" x="11">&lt;c11&gt;</bpt>(1, 1)<ept i="11">&lt;/c11&gt;</ept>のようなものである場合にのみ、以下の例におけるケース節にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, failable initializers are implemented for numeric type conversions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、いくつかの失敗できるイニシャライザが数値型変換のために実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, if you write <bpt i="4" x="4">&lt;c4&gt;</bpt>let dict: Dictionary = ["A": 1]<ept i="4">&lt;/c4&gt;</ept>, the compiler infers that <bpt i="5" x="5">&lt;c5&gt;</bpt>dict<ept i="5">&lt;/c5&gt;</ept> has the type <bpt i="6" x="6">&lt;c6&gt;</bpt>Dictionary&lt;String, Int&gt;<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえば、あなたが<bpt i="4" x="4">&lt;c4&gt;</bpt>let dict: Dictionary = ["A": 1]<ept i="4">&lt;/c4&gt;</ept>を書くならば、コンパイラは<bpt i="5" x="5">&lt;c5&gt;</bpt>dict<ept i="5">&lt;/c5&gt;</ept>が型<bpt i="6" x="6">&lt;c6&gt;</bpt>Dictionary&lt;String, Int&gt;<ept i="6">&lt;/c6&gt;</ept>を持つと推測します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, in addition to the values of scalar types, such as integers and characters, your code can branch on the values of any type, including floating-point numbers, strings, tuples, instances of custom classes, and optionals.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえば、整数と文字のようなスカラー型の値に加えて、あなたのコードは、浮動小数点数、文字列、タプル、あつらえのクラスのインスタンス、そしてオプショナルを含むあらゆる型の値に関して分岐することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, in the example below, the use of <bpt i="0" x="0">&lt;c0&gt;</bpt>Point<ept i="0">&lt;/c0&gt;</ept> in the type annotation refers to the tuple type <bpt i="1" x="1">&lt;c1&gt;</bpt>(Int, Int)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえば、下記の例で、型注釈において<bpt i="0" x="0">&lt;c0&gt;</bpt>Point<ept i="0">&lt;/c0&gt;</ept>を使うことは、タプル型<bpt i="1" x="1">&lt;c1&gt;</bpt>(Int, Int)<ept i="1">&lt;/c1&gt;</ept>に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, in the generic function below, the generic parameter <bpt i="1" x="1">&lt;c1&gt;</bpt>T: Comparable<ept i="1">&lt;/c1&gt;</ept> indicates that any type argument substituted for the type parameter <bpt i="2" x="2">&lt;c2&gt;</bpt>T<ept i="2">&lt;/c2&gt;</ept> must conform to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえば、下記の総称体関数において、総称体パラメータ<bpt i="1" x="1">&lt;c1&gt;</bpt>T: Comparable<ept i="1">&lt;/c1&gt;</ept>は、型パラメータ<bpt i="2" x="2">&lt;c2&gt;</bpt>T<ept i="2">&lt;/c2&gt;</ept>と置き換えられる任意の型の引数は<bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>プロトコルに準拠しなければならないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, the pattern <bpt i="2" x="2">&lt;c2&gt;</bpt>(x, y)<ept i="2">&lt;/c2&gt;</ept> matches the tuple <bpt i="3" x="3">&lt;c3&gt;</bpt>(1, 2)<ept i="3">&lt;/c3&gt;</ept> and any other two-element tuple.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえば、パターン<bpt i="2" x="2">&lt;c2&gt;</bpt>(x, y)<ept i="2">&lt;/c2&gt;</ept>はタプル<bpt i="3" x="3">&lt;c3&gt;</bpt>(1, 2)<ept i="3">&lt;/c3&gt;</ept>および他のどんな２要素タプルにでもマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, the tuple type <bpt i="1" x="1">&lt;c1&gt;</bpt>(Int, (Int, Int))<ept i="1">&lt;/c1&gt;</ept> contains two elements: The first is the named type <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>, and the second is another compound type <bpt i="3" x="3">&lt;c3&gt;</bpt>(Int, Int)<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえば、タプル型<bpt i="1" x="1">&lt;c1&gt;</bpt>(Int, (Int, Int))<ept i="1">&lt;/c1&gt;</ept>は、２つの要素を含みます：第一は名前付きの型<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>です、そして第二は別の複合の型<bpt i="3" x="3">&lt;c3&gt;</bpt>(Int, Int)<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, the variadic parameter <bpt i="1" x="1">&lt;c1&gt;</bpt>Int...<ept i="1">&lt;/c1&gt;</ept> is treated as <bpt i="2" x="2">&lt;c2&gt;</bpt>[Int]<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえば、可変長パラメータ<bpt i="1" x="1">&lt;c1&gt;</bpt>Int...<ept i="1">&lt;/c1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>[Int]<ept i="2">&lt;/c2&gt;</ept>とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, the variadic parameter <bpt i="3" x="3">&lt;c3&gt;</bpt>Int...<ept i="3">&lt;/c3&gt;</ept> is treated as <bpt i="4" x="4">&lt;c4&gt;</bpt>[Int]<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえば、可変長パラメータ<bpt i="3" x="3">&lt;c3&gt;</bpt>Int...<ept i="3">&lt;/c3&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>[Int]<ept i="4">&lt;/c4&gt;</ept>とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, when integers are used for raw values, the implicit value for each case is one more than the previous case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、整数が生の値のために使われるとき、各ケース節に対する暗黙の値は、その前のケース節よりもうひとつ多くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, you can assign values of implicitly unwrapped optionals to variables, constants, and properties of optionals, and vice versa.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえば、あなたは暗黙的にアンラップされるオプショナルの値を、オプショナルの変数、定数、そしてプロパティに代入することができます、その逆もまたできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, you can constrain the associated types of type parameters to conform to protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえば、あなたは型パラメータの関連型をいくらかのプロトコルに準拠するように制約することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, you can define an extension to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept> protocol that applies to any collection whose elements conform to the <bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept> protocol from the example above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはある拡張を<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>プロトコルに対して定義することができます、それはその要素が上の例の<bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠するあらゆるコレクションに適用するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more about extensions, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Extensions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張についてのより多くのために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>拡張<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more about operator method, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Operator Methods<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子メソッドについてさらに、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>演算子メソッド<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more about the <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>For-In Loops<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更に<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループについて、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>for-inループ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more details, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocol Extensions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコル拡張<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more discussion and examples of in-out parameters, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>In-Out Parameters<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>in-outパラメータの議論と例のために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>in-outパラメータ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> subscripting, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Accessing and Modifying a Dictionary<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>で添え字を使うことの詳細については、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>辞書へのアクセスと修正<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about capture lists, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Capture Lists<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キャプチャリストについての更なる情報として、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>キャプチャリスト<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about compound cases, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Compound Cases<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複合ケース節についてのさらなる情報として、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>複合ケース節<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about conforming to protocols, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocols<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルに準拠することについての更なる情報は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコル<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about constants and for guidance about when to use them, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Constants and Variables<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Stored Properties<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数の詳細について、そしていつそれらを使うべきかの手引きとして、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>定数と変数<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>および<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>保存プロパティ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about deinitializers, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Deinitialization<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライザの詳細については、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>デイニシャライザ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clauses and to see an example of one in a generic function declaration, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Generic Where Clauses<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節のさらなる情報のために、そして総称体関数定義におけるそれの一例を見るために、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>総称体where節<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about how to use the <bpt i="2" x="2">&lt;c2&gt;</bpt>optional<ept i="2">&lt;/c2&gt;</ept> modifier and for guidance about how to access optional protocol members—for example, when you’re not sure whether a conforming type implements them—see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Optional Protocol Requirements<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>optional<ept i="2">&lt;/c2&gt;</ept>修飾子を使う方法についての更なる情報のために、そしてオプショナルプロトコルメンバーにアクセスする方法についての手引きとして ― 例えば、あなたがある準拠型がそれらを実装するかどうか確信が持てない時など ― <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>オプショナルのプロトコル要件<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about how to use the <bpt i="4" x="4">&lt;c4&gt;</bpt>optional<ept i="4">&lt;/c4&gt;</ept> declaration modifier and for guidance about how to access optional protocol members—for example, when you’re not sure whether a conforming type implements them—see <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Optional Protocol Requirements<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>optional<ept i="4">&lt;/c4&gt;</ept>宣言修飾子を働かせる方法に関する詳細は、そして、オプショナルのプロトコルメンバーにアクセスする方法 ― 例えば、ある準拠している型がそれらを実装するかどうかについてあなたが確信が持てない時など ― についての手引きとして<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>オプショナルのプロトコル要件<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about implicitly unwrapped optional types, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Implicitly Unwrapped Optionals<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的にアンラップされるオプショナル型の詳細については、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>暗黙的にアンラップされるオプショナル<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about initializer delegation, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Initializer Delegation for Value Types<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Initializer Delegation for Class Types<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ委任についての更なる情報として、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>値型のためのイニシャライザ委任<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>クラス型のためのイニシャライザ委任<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about pattern matching, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Patterns<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パターンマッチングについての更なる情報として、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>パターン<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about precedence groups and to see the syntax for defining your own operators and precedence groups, see <bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>Operator Declaration<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>優先順位グループについてのさらなる情報として、そしてあなた独自の演算子と優先順位グループを定義するための構文を見るには、<bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>演算子宣言<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about subscripting and to see examples of subscript declarations, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Subscripts<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字に関するより多くの情報のために、そして、添え字宣言の例を見るために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>添え字<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about the <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> type, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Strings and Characters<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>String Structure Reference<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>型の詳細については、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>文字列と文字<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>String Structure Reference<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about the <bpt i="3" x="3">&lt;c3&gt;</bpt>fallthrough<ept i="3">&lt;/c3&gt;</ept> statement, see <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Fallthrough Statement<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>fallthrough<ept i="3">&lt;/c3&gt;</ept>文の詳細については、下記の<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>フォールスルー文<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about the patterns you can use in a <bpt i="5" x="5">&lt;c5&gt;</bpt>catch<ept i="5">&lt;/c5&gt;</ept> clause, see <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Patterns<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="5" x="5">&lt;c5&gt;</bpt>catch<ept i="5">&lt;/c5&gt;</ept>節において使うパターンについての更なる情報として、<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>パターン<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about this attribute, see <bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>Attributes<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性についてのさらなる情報として、<bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>属性<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about this class, see <bpt i="1" x="1">&lt;a1&gt;</bpt>Error Handling<ept i="1">&lt;/a1&gt;</ept> in <bpt i="2" x="2">&lt;e2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Using Swift with Cocoa and Objective-C (Swift 4)<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このクラスについての更なる情報として、<bpt i="1" x="1">&lt;a1&gt;</bpt>エラーの処理<ept i="1">&lt;/a1&gt;</ept>を<bpt i="2" x="2">&lt;e2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>SwiftをCocoaとObjective-Cとともに使う（Swift 4）<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/e2&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about type casting and to see examples that use the type-casting operators, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Type Casting<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型キャストに関するより多くの情報のために、そして、型キャスト演算子を使用する例をより多く見るために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>型キャスト<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about using <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> with Foundation and Cocoa, see <bpt i="1" x="1">&lt;a1&gt;</bpt>Working with Cocoa Data Types<ept i="1">&lt;/a1&gt;</ept> in <bpt i="2" x="2">&lt;e2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Using Swift with Cocoa and Objective-C (Swift 4)<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>FoundationとCocoaとともに<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>を使うことについてのさらなる情報として、<bpt i="1" x="1">&lt;a1&gt;</bpt>Cocoaデータ型を扱う<ept i="1">&lt;/a1&gt;</ept>を<bpt i="2" x="2">&lt;e2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>SwiftをCocoaとObjective-Cと共に使う（Swift 4）<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/e2&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about using <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> with Foundation and Cocoa, see <bpt i="1" x="1">&lt;a1&gt;</bpt>Working with Cocoa Data Types<ept i="1">&lt;/a1&gt;</ept> in <bpt i="2" x="2">&lt;e2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Using Swift with Cocoa and Objective-C (Swift 4)<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>FoundationとCocoaとともに<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>を使うことについてのさらなる情報として、<bpt i="1" x="1">&lt;a1&gt;</bpt>Cocoaデータ型を扱う<ept i="1">&lt;/a1&gt;</ept>を<bpt i="2" x="2">&lt;e2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>SwiftをCocoaとObjective-Cと共に使う（Swift 4）<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/e2&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about using <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept> with Foundation and Cocoa, see <bpt i="1" x="1">&lt;a1&gt;</bpt>Working with Cocoa Data Types<ept i="1">&lt;/a1&gt;</ept> in <bpt i="2" x="2">&lt;e2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Using Swift with Cocoa and Objective-C (Swift 4)<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>FoundationとCocoaとともに<bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>を使うことについてのさらなる情報として、<bpt i="1" x="1">&lt;a1&gt;</bpt>Cocoaデータ型を扱う<ept i="1">&lt;/a1&gt;</ept>を<bpt i="2" x="2">&lt;e2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>SwiftをCocoaとObjective-Cと共に使う（Swift 4）<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/e2&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about using <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> with Foundation and Cocoa, see <bpt i="1" x="1">&lt;a1&gt;</bpt>Working with Cocoa Data Types<ept i="1">&lt;/a1&gt;</ept> in <bpt i="2" x="2">&lt;e2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Using Swift with Cocoa and Objective-C (Swift 4)<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>FoundationとCocoaとともに<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>を使うことについてのさらなる情報として、<bpt i="1" x="1">&lt;a1&gt;</bpt>Cocoaデータ型を扱う<ept i="1">&lt;/a1&gt;</ept>を<bpt i="2" x="2">&lt;e2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>SwiftをCocoaとObjective-Cと共に使う（Swift 4）<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/e2&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about using key paths in Swift code that interacts with Objective-C APIs, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Keys and Key Paths<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Using Swift with Cocoa and Objective-C (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-C APIと相互作用するスウィフトコードにおけるキーパスの使用についてのさらなる情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>キーとキーパス<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>SwiftをCocoaとObjective-Cと共に使う（Swift 4）<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about using multiple optional chaining operations, see <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Linking Multiple Levels of Chaining<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数のオプショナル連鎖演算を使用することについての更なる情報として、<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>連鎖の複数の階層を結ぶ<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about using selectors in Swift code that interacts with Objective-C APIs, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Objective-C Selectors<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Using Swift with Cocoa and Objective-C (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-C APIと相互作用するスウィフトコードにおいてセレクタを使うことについての更なる情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>Objective-Cセレクタ<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>SwiftをCocoaとObjective-Cと共に使う (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>において見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information and examples of capture lists, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Resolving Strong Reference Cycles for Closures<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キャプチャリストのより多くの情報と例のために、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>クロージャのための強い参照循環の解消<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information and examples of closure expressions, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Closure Expressions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャ式のより多くの情報と例のために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>クロージャ式<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information and examples, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Associated Types<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より多くの情報と例のために、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>関連型<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information and to see an example of how to use property observers, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Property Observers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より多くの情報のために、そして、プロパティオブザーバーを使う方法の例を見るために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロパティオブザーバー<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information and to see an example, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>In-Out Parameters<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より多くの情報のために、そして、例を見るために、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>In-Outパラメータ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information and to see examples of cases with associated value types, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Associated Values<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より多くの情報のために、そして関連値型をもつケース節の例を見るために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>関連値<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information and to see examples of cases with raw-value types, see <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Raw Values<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より多くの情報のために、そして「生の値」型をもつケース節の例を見るために、<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>生の値<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information and to see examples of computed properties, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Computed Properties<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より多くの情報のために、そして、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>計算プロパティ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の例を見るために、計算プロパティを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information and to see examples of failable initializers, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Failable Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらなる情報と、失敗できるイニシャライザの例を見るために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>失敗できるイニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information and to see examples of how to use <bpt i="0" x="0">&lt;c0&gt;</bpt>try<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>try?<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>try!<ept i="2">&lt;/c2&gt;</ept>, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Error Handling<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より多くの情報のために、そして<bpt i="0" x="0">&lt;c0&gt;</bpt>try<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>try?<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>try!<ept i="2">&lt;/c2&gt;</ept>文を使う方法の例を見るために、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>エラーを処理する<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information and to see examples of how to use statement labels, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Labeled Statements<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Control Flow<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より多くの情報のために、そして、文ラベルを使用する方法の例を見るために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ラベルをつけられた文<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>制御の流れ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information and to see examples that show how to use optional types, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Optionals<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より多くの情報のために、そしてオプショナル型を使う方法を示す例を見るために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オプショナル<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information on bridging, see <bpt i="2" x="2">&lt;a2&gt;</bpt>Working with Cocoa Data Types<ept i="2">&lt;/a2&gt;</ept> in <bpt i="3" x="3">&lt;e3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Using Swift with Cocoa and Objective-C (Swift 4)<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブリッジに関する更なる情報として、<bpt i="2" x="2">&lt;a2&gt;</bpt>ココアデータ型を扱う<ept i="2">&lt;/a2&gt;</ept>を<bpt i="3" x="3">&lt;e3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>SwiftをCocoaとObjective-Cと共に使う（Swift 4）<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/e3&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information on functions with the <bpt i="2" x="2">&lt;c2&gt;</bpt>Never<ept i="2">&lt;/c2&gt;</ept> return type, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Functions that Never Return<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Never<ept i="2">&lt;/c2&gt;</ept>戻り型を持つ関数でのさらなる情報は、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>決して戻らない関数<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information on property observers, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Property Observers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティオブザーバーの詳細については、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロパティオブザーバー<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information on required initializers, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Required Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>必須イニシャライザに関する更なる情報として、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>必須イニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Type Variable Properties<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>型変数プロパティ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;c0&gt;</bpt><it pos="begin" x="1">&lt;!1&gt;</it>type(of:)<it pos="begin" x="2">&lt;!2&gt;</it><ept i="0">&lt;/c0&gt;</ept> in the Swift standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="0" x="0">&lt;c0&gt;</bpt><it pos="begin" x="1">&lt;!1&gt;</it>type(of:)<it pos="begin" x="2">&lt;!2&gt;</it><ept i="0">&lt;/c0&gt;</ept>をスウィフト標準ライブラリで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Assigning Constant Properties During Initialization<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>初期化の間に定数プロパティを割り当てる<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Classes and Structures<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>クラスと構造体<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Constant Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>定数宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Extensions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>拡張<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Failable Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらなる情報として、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>失敗できるイニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Inheritance<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Type Casting<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>, <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Deinitialization<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>, and <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Automatic Reference Counting<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>継承<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>型キャスト<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>、<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>デイニシャライズ<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>、そして<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>自動参照カウント<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Properties<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Methods<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>, <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Subscripts<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>, <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Initialization<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>, <bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>Extensions<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>, and <bpt i="10" x="10">&lt;s10&gt;</bpt><bpt i="11" x="11">&lt;a11&gt;</bpt>Protocols<ept i="11">&lt;/a11&gt;</ept><ept i="10">&lt;/s10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロパティ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>メソッド<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>、<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>添え字<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>、<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>初期化<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>、<bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>拡張<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>、そして<bpt i="10" x="10">&lt;s10&gt;</bpt><bpt i="11" x="11">&lt;a11&gt;</bpt>プロトコル<ept i="11">&lt;/a11&gt;</ept><ept i="10">&lt;/s10&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Automatic Initializer Inheritance<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報は、以下の<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>自動的なイニシャライザ継承<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Functions with Multiple Return Values<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>「複数の戻り値をもつ関数」<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Optional Binding<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>オプショナルの束縛<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Sets<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>集合<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Strong Reference Cycles for Closures<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>クロージャのための強い参照循環<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Checking for Protocol Conformance<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>プロトコル準拠の確認<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Declaration Attributes<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>宣言属性<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Precedence Group Declaration<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらなる情報は、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>優先順位グループ定義<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Classes and Structures<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>クラスと構造体<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Type-Casting Operators<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>型キャスト演算子<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Raw Values<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> and <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Enumerations with Cases of a Raw-Value Type<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として、<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>生の値<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>と「<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>生の値」型のケース節を持つ列挙<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more on <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loops, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Control Flow<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループの詳細については、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>制御の流れ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more on arrays and dictionaries, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Collection Types<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列と辞書の詳細について、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>コレクション型<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more on arrays, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Arrays<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の詳細については、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>配列<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more on generic types and collections, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Generics<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体型とコレクションの詳細は<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>「総称体」<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more on ranges, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Range Operators<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲に関する詳細は、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>範囲演算子<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more on reference and value semantics, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Structures and Enumerations Are Value Types<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Classes Are Reference Types<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照および値意味論についての詳細として、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>構造体と列挙は値型です<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>クラスは、参照型です<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more on the <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Control Flow<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文の詳細については、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>制御の流れ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more on the <bpt i="2" x="2">&lt;c2&gt;</bpt>final<ept i="2">&lt;/c2&gt;</ept> modifier, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Preventing Overrides<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>final<ept i="2">&lt;/c2&gt;</ept>修飾子に関する更なる情報として、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>オーバーライドを防ぐ<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more on these capabilities, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Properties<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Methods<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>, <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Initialization<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>, <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Extensions<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>, and <bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>Protocols<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの能力の詳細について、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロパティ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>メソッド<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>、<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>初期化<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>、<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>拡張<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>、そして<bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>プロトコル<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For readability, a compound case can also be written over multiple lines.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可読性のために、複合ケース節はまた複数行にわたって描かれることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For simple numeric values, the unary minus operator converts positive numbers into their negative equivalent and vice versa.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単純な数の値のために、この単項マイナス演算子は正の数をその負の等価物に変えます、逆の場合も同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For the <bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfLegs<ept i="2">&lt;/c2&gt;</ept> dictionary above, the key-value subscript takes and returns a value of type <bpt i="3" x="3">&lt;c3&gt;</bpt>Int?<ept i="3">&lt;/c3&gt;</ept>, or “optional int”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfLegs<ept i="2">&lt;/c2&gt;</ept>辞書のために、その「キーと値」添え字は型<bpt i="3" x="3">&lt;c3&gt;</bpt>Int?<ept i="3">&lt;/c3&gt;</ept>、つまり「オプショナルのint」の値を受け取りそして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For the best experience, open this chapter as a playground in Xcode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最もよい体験方法として、Xcodeでplayground（遊び場）としてこの章を開いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For the example above, this enables the names of <bpt i="0" x="0">&lt;c0&gt;</bpt>Suit<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Rank<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>Values<ept i="2">&lt;/c2&gt;</ept> to be kept deliberately short, because their names are naturally qualified by the context in which they are defined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、これは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Suit<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Rank<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>Values<ept i="2">&lt;/c2&gt;</ept>の名前が故意に短いままにしておかれるようにします、なぜなら、それらが定義される文脈によってそれらの名前が自然に修飾されて限定されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For the numeric cards, it uses the rank’s raw <bpt i="8" x="8">&lt;c8&gt;</bpt>Int<ept i="8">&lt;/c8&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数字カードのために、それは等級の生の<bpt i="8" x="8">&lt;c8&gt;</bpt>Int<ept i="8">&lt;/c8&gt;</ept>値を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For the other three properties, new <bpt i="4" x="4">&lt;c4&gt;</bpt>VideoMode<ept i="4">&lt;/c4&gt;</ept> instances will be initialized with an <bpt i="5" x="5">&lt;c5&gt;</bpt>interlaced<ept i="5">&lt;/c5&gt;</ept> setting of <bpt i="6" x="6">&lt;c6&gt;</bpt>false<ept i="6">&lt;/c6&gt;</ept> (meaning “noninterlaced video”), a playback frame rate of <bpt i="7" x="7">&lt;c7&gt;</bpt>0.0<ept i="7">&lt;/c7&gt;</ept>, and an optional <bpt i="8" x="8">&lt;c8&gt;</bpt>String<ept i="8">&lt;/c8&gt;</ept> value called <bpt i="9" x="9">&lt;c9&gt;</bpt>name<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の３つのプロパティのために、新しい<bpt i="4" x="4">&lt;c4&gt;</bpt>VideoMode<ept i="4">&lt;/c4&gt;</ept>インスタンスは、<bpt i="6" x="6">&lt;c6&gt;</bpt>false<ept i="6">&lt;/c6&gt;</ept>に設定される<bpt i="5" x="5">&lt;c5&gt;</bpt>interlaced<ept i="5">&lt;/c5&gt;</ept>（「ノンインタレース・ビデオ」を意味します）、<bpt i="7" x="7">&lt;c7&gt;</bpt>0.0<ept i="7">&lt;/c7&gt;</ept>の再生フレームレート、<bpt i="9" x="9">&lt;c9&gt;</bpt>name<ept i="9">&lt;/c9&gt;</ept>というオプショナルの<bpt i="8" x="8">&lt;c8&gt;</bpt>String<ept i="8">&lt;/c8&gt;</ept>値で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For the purpose of access control, extensions to the same type that are in the same file share an access-control scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセス制御の目的のために、同じ型で同じファイルの中にあるものに対する拡張それらは、アクセス制御スコープを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For the purposes of these rules, the characters <bpt i="0" x="0">&lt;c0&gt;</bpt>(<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>[<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>{<ept i="2">&lt;/c2&gt;</ept> before an operator, the characters <bpt i="3" x="3">&lt;c3&gt;</bpt>)<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>]<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>}<ept i="5">&lt;/c5&gt;</ept> after an operator, and the characters <bpt i="6" x="6">&lt;c6&gt;</bpt>,<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>;<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>:<ept i="8">&lt;/c8&gt;</ept> are also considered whitespace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの規則を理由に、演算子の前の文字<bpt i="0" x="0">&lt;c0&gt;</bpt>(<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>[<ept i="1">&lt;/c1&gt;</ept>、および<bpt i="2" x="2">&lt;c2&gt;</bpt>{<ept i="2">&lt;/c2&gt;</ept>、演算子の後の文字<bpt i="3" x="3">&lt;c3&gt;</bpt>)<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>]<ept i="4">&lt;/c4&gt;</ept>、および<bpt i="5" x="5">&lt;c5&gt;</bpt>}<ept i="5">&lt;/c5&gt;</ept>、そして文字<bpt i="6" x="6">&lt;c6&gt;</bpt>,<ept i="6">&lt;/c6&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>;<ept i="7">&lt;/c7&gt;</ept>、および<bpt i="8" x="8">&lt;c8&gt;</bpt>:<ept i="8">&lt;/c8&gt;</ept>は、また、空白と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For the purposes of this example, <bpt i="2" x="2">&lt;c2&gt;</bpt>+++<ept i="2">&lt;/c2&gt;</ept> is treated as a new “prefix doubling” operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例の目的のために、<bpt i="2" x="2">&lt;c2&gt;</bpt>+++<ept i="2">&lt;/c2&gt;</ept>は新しい「接頭辞倍加」演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For these types, Objective-C methods typically return a special value (such as <bpt i="2" x="2">&lt;c2&gt;</bpt>NSNotFound<ept i="2">&lt;/c2&gt;</ept>) to indicate the absence of a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの型のために、Objective-Cメソッドは、値の欠如を示すために概して特別な値（例えば<bpt i="2" x="2">&lt;c2&gt;</bpt>NSNotFound<ept i="2">&lt;/c2&gt;</ept>）を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For this calculation, the individual counter values each time through the loop are unnecessary—the code simply executes the loop the correct number of times.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この計算では、ループするごとに個別のカウンタ値は必要ではありません ― このコードは単に正しい回数ループを実行するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For this reason, Swift strings can’t be indexed by integer values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この理由のために、スウィフトの文字列は整数値でインデックス付けされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For value types, you use <bpt i="0" x="0">&lt;c0&gt;</bpt>self.init<ept i="0">&lt;/c0&gt;</ept> to refer to other initializers from the same value type when writing your own custom initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型のために、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>self.init<ept i="0">&lt;/c0&gt;</ept>を使って、あなた独自のあつらえのイニシャライザを書くとき同じ値型の他のイニシャライザに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For-In Loops</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>for-inループ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For-In Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>For-In文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Forced-Value Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>強制された値式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Foundation also extends <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> to expose methods defined by <bpt i="3" x="3">&lt;c3&gt;</bpt>NSString<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Foundationはまた、<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>を拡張して<bpt i="3" x="3">&lt;c3&gt;</bpt>NSString<ept i="3">&lt;/c3&gt;</ept>によって定義されるメソッドに触れさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function Argument Labels and Parameter Names</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数の引数ラベルとパラメータ名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function Call Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数呼び出し式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function Parameters and Return Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数のパラメータと戻り値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function Types as Parameter Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータ型としての関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function Types as Return Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>戻り型としての関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function call expressions have the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数呼び出し式は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function declarations are declared using the <bpt i="2" x="2">&lt;c2&gt;</bpt>func<ept i="2">&lt;/c2&gt;</ept> keyword and have the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数宣言は、キーワード<bpt i="2" x="2">&lt;c2&gt;</bpt>func<ept i="2">&lt;/c2&gt;</ept>を使って宣言されます、そして以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function parameters and return values are extremely flexible in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数パラメータと戻り値は、スウィフトではとても柔軟です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function parameters are a comma-separated list where each parameter has one of several forms.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数パラメータはひとつの「コンマ区切り」のリストです、そこにおいて各パラメータはいくつかの書式のうちの１つを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function parameters are constants by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数パラメータは、特に何もしなければ定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function parameters can have both a name (for use within the function’s body) and an argument label (for use when calling the function), as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Function Argument Labels and Parameter Names<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数パラメータは、名前（関数の本文内で使うため）と引数ラベル（関数を呼び出すとき使うため）の両方を持つことができます、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>関数の引数ラベルとパラメータ名<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function type parameters with the <bpt i="0" x="0">&lt;c0&gt;</bpt>escaping<ept i="0">&lt;/c0&gt;</ept> type attribute require explicit use of <bpt i="1" x="1">&lt;c1&gt;</bpt>self.<ept i="1">&lt;/c1&gt;</ept> for properties or methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>escaping<ept i="0">&lt;/c0&gt;</ept>型属性を持つ関数型パラメーターは、明示的な<bpt i="1" x="1">&lt;c1&gt;</bpt>self.<ept i="1">&lt;/c1&gt;</ept>の使用をプロパティやメソッドに対して必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function types that can throw an error must be marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>throws<ept i="0">&lt;/c0&gt;</ept> keyword, and function types that can rethrow an error must be marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>rethrows<ept i="1">&lt;/c1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーを投げ掛けること（スロー）ができる関数型は、<bpt i="0" x="0">&lt;c0&gt;</bpt>throws<ept i="0">&lt;/c0&gt;</ept>キーワードで印されなければなりません、そしてエラーを再度投げ掛けること（再スロー）ができる関数型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>rethrows<ept i="1">&lt;/c1&gt;</ept>キーワードで印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions With Multiple Parameters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数のパラメーターを持つ関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions Without Parameters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータのない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions Without Return Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>戻り値のない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions and Closures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数とクロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions and methods that can throw an error must be marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>throws<ept i="0">&lt;/c0&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーをスローできる関数とメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>throws<ept i="0">&lt;/c0&gt;</ept>キーワードで印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions and methods with the <bpt i="1" x="1">&lt;c1&gt;</bpt>Never<ept i="1">&lt;/c1&gt;</ept> return type are called <bpt i="2" x="2">&lt;e2&gt;</bpt>nonreturning<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Never<ept i="1">&lt;/c1&gt;</ept>戻り型を持つ関数およびメソッドは、<bpt i="2" x="2">&lt;e2&gt;</bpt>非復帰<ept i="2">&lt;/e2&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions are a first-class type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は、第一級（ファーストクラス）の種類のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions are actually a special case of closures: blocks of code that can be called later.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は、実際のところクロージャ：後刻に呼び出されることができるコードのひとまとまり、の特別な場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions are not required to define a return type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は、戻り型を定義することを要求されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions are not required to define input parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は、入力パラメータを定義することを要求されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions can also be written within other functions to encapsulate useful functionality within a nested function scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は、また、他の関数の内部で記述されることで、役に立つ機能性を入れ子にされた関数スコープ内でカプセル化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions can be nested.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は、入れ子にされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions can have multiple input parameters, which are written within the function’s parentheses, separated by commas.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は複数の入力パラメータを持つことが出来ます、それは関数の丸括弧内に書かれ、コンマで区切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions can return multiple values using a tuple type as the return type of the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は、関数の戻り型としてタプル型を使って、複数の値を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions that Never Return</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>決して返らない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions with Multiple Return Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数の戻り値を持つ関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions without a defined return type return a special value of type <bpt i="2" x="2">&lt;c2&gt;</bpt>Void<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>戻り型定義のない関数は、型<bpt i="2" x="2">&lt;c2&gt;</bpt>Void<ept i="2">&lt;/c2&gt;</ept>の特別な値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fundamental Set Operations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合演算の基本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Furthermore, a new <bpt i="0" x="0">&lt;c0&gt;</bpt>CreditCard<ept i="0">&lt;/c0&gt;</ept> instance can <bpt i="1" x="1">&lt;e1&gt;</bpt>only<ept i="1">&lt;/e1&gt;</ept> be created by passing a <bpt i="2" x="2">&lt;c2&gt;</bpt>number<ept i="2">&lt;/c2&gt;</ept> value and a <bpt i="3" x="3">&lt;c3&gt;</bpt>customer<ept i="3">&lt;/c3&gt;</ept> instance to a custom <bpt i="4" x="4">&lt;c4&gt;</bpt>CreditCard<ept i="4">&lt;/c4&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらに、新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>CreditCard<ept i="0">&lt;/c0&gt;</ept>インスタンスは、<bpt i="2" x="2">&lt;c2&gt;</bpt>number<ept i="2">&lt;/c2&gt;</ept>値と<bpt i="3" x="3">&lt;c3&gt;</bpt>customer<ept i="3">&lt;/c3&gt;</ept>インスタンスをあつらえの<bpt i="4" x="4">&lt;c4&gt;</bpt>CreditCard<ept i="4">&lt;/c4&gt;</ept>イニシャライザに渡すことによって<bpt i="1" x="1">&lt;e1&gt;</bpt>のみ<ept i="1">&lt;/e1&gt;</ept>作成されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generic Argument Clause</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体引数節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generic Functions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generic Parameter Clause</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体パラメータ節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generic Parameters and Arguments</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体パラメータと引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generic Subscripts</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generic Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generic Where Clauses</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体where節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generic classes can inherit from other generic and nongeneric classes, but a nongeneric class can inherit only from other nongeneric classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体クラスは、他の総称体および非総称体クラスから継承することができます、しかし非総称体クラスはただ他の非総称体クラスからのみ継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generic code enables you to write such a function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体コードは、あなたにこのような関数を書くことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generics are one of the most powerful features of Swift, and much of the Swift standard library is built with generic code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体は、スウィフトの最も強力な特徴のうちの１つです、そして、多くのスウィフト標準ライブラリは総称体コードで組み立てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Gettable and settable properties are indicated by writing <bpt i="1" x="1">&lt;c1&gt;</bpt>{ get set }<ept i="1">&lt;/c1&gt;</ept> after their type declaration, and gettable properties are indicated by writing <bpt i="2" x="2">&lt;c2&gt;</bpt>{ get }<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>取得可能かつまた設定可能なプロパティは、それらの型宣言の後に<bpt i="1" x="1">&lt;c1&gt;</bpt>{ get set }<ept i="1">&lt;/c1&gt;</ept>を書くことによって示されます、そして取得可能なプロパティは<bpt i="2" x="2">&lt;c2&gt;</bpt>{ get }<ept i="2">&lt;/c2&gt;</ept>を書くことによって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Getters and Setters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゲッターとセッター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Getters and setters for constants, variables, properties, and subscripts automatically receive the same access level as the constant, variable, property, or subscript they belong to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数、変数、プロパティ、そして添え字のためのゲッターとセッターは、自動的に、それらが属している定数、変数、プロパティまたは添え字と同じアクセス水準を受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Give enumeration types singular rather than plural names, so that they read as self-evident:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙型に複数形よりむしろ単数形の名前を与えてください、わかりきったことという印象を受けるので：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Give types <bpt i="0" x="0">&lt;c0&gt;</bpt>UpperCamelCase<ept i="0">&lt;/c0&gt;</ept> names (such as <bpt i="1" x="1">&lt;c1&gt;</bpt>SomeClass<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>SomeStructure<ept i="2">&lt;/c2&gt;</ept> here) to match the capitalization of standard Swift types (such as <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>Bool<ept i="5">&lt;/c5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準のスウィフト型（例えば<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>Bool<ept i="5">&lt;/c5&gt;</ept>）の大文字の使用法に合うように、型に<bpt i="0" x="0">&lt;c0&gt;</bpt>UpperCamelCase アッパーキャメルケース名<ept i="0">&lt;/c0&gt;</ept>（例えば<bpt i="1" x="1">&lt;c1&gt;</bpt>SomeClass<ept i="1">&lt;/c1&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt>SomeStructure<ept i="2">&lt;/c2&gt;</ept>）を与えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Global and Local Variables</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>グローバルおよびローカル変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Global and nested functions, as introduced in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Functions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, are actually special cases of closures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>関数<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で紹介される、グローバルおよび入れ子にされた関数は、実際にはクロージャの特別な場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Global constants and variables are always computed lazily, in a similar manner to <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Lazy Stored Properties<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>グローバルな定数と変数は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>遅延保存プロパティ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>と似たやり方で、常に遅延計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Global functions are closures that have a name and do not capture any values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>グローバルな関数は、名前を持ち、まったく値をキャプチャしない（捕獲しない）クロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Global variables are variables that are defined outside of any function, method, closure, or type context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>グローバルな変数は、あらゆる関数、メソッド、クロージャ、または型の文脈の外で定義される変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a binary expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>二項式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a branch statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>分岐文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a break statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブレーク文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a class declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a closure expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャ式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a code block</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コードブロックの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a compiler control statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラ制御文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a conditional compilation block</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>条件コンパイルプロックの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a conditional operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>条件演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a constant declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a continue statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>継続文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a control transfer statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>制御移動文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a declaration modifier</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言修飾子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a defer statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>defer文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a deinitializer declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライザ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a dictionary type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a do statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>do文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a fallthrough statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>フォールスルー文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a floating-point literal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a for-in statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>for-in文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a forced-value expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>強制された値の式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a function call expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数呼び出し式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a function declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a function type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a generic argument clause</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体引数節の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a generic parameter clause</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体パラメータ節の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a getter-setter block</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゲッターセッター・ブロックの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a guard statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>guard文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a implicit member expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的メンバー式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a key-path expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパス式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a key-path string expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパス文字列式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a labeled statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ラベルをつけられた文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a line control statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行制御文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a literal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a literal expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リテラル式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a loop statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループ文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a metatype type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メタタイプ型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a parenthesized expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>丸括弧に入れられた式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a postfix expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接尾辞式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a precedence group declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>優先順位グループ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a prefix expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接頭辞式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a primary expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基本式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a protocol associated type declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル関連型宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a protocol composition type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル構成型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a protocol declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a protocol initializer declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル・イニシャライザ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a protocol method declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルメソッド宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a protocol property declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルプロパティ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a protocol subscript declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル添え字宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a repeat-while statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>repeat-while文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a return statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>return文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a selector expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>セレクタ式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a self expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>self式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a string literal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a structure declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a subscript declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a subscript expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a superclass expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラス式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a switch statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>switch文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a throw statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スロー文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a top-level declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>トップレベル宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a try expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>try式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a tuple expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプル式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a tuple pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプル・パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a tuple type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプル型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a type alias declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型エイリアス宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a type annotation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型注釈の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a type casting pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型キャスト・パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a type identifier</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型識別子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a type inheritance clause</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型継承節の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a type-casting operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型キャスト演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a value-binding pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値束縛パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a variable declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a while statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>while文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a wildcard expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ワイルドカード式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of a wildcard pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ワイルドカード・パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an array type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an assignment operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代入演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an attribute</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>属性の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an availability condition</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>有効性条件の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an enumeration case pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙ケース節パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an enumeration declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an explicit member expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>明示的メンバー式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an expression pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>式パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an extension declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an identifier</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>識別子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an identifier pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>識別子パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an if statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>if文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an implicitly unwrapped optional type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的にアンラップされるオプショナル型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an import declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポート宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an initializer declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an initializer expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an integer literal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an operator declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an optional pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルパターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an optional type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of an optional-chaining expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grammar of whitespace</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空白の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Greater than (<bpt i="0" x="0">&lt;c0&gt;</bpt>a &gt; b<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より大きい（<bpt i="0" x="0">&lt;c0&gt;</bpt>a &gt; b<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Greater than or equal to (<bpt i="0" x="0">&lt;c0&gt;</bpt>a &gt;= b<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より大きいか等しい、以上（<bpt i="0" x="0">&lt;c0&gt;</bpt>a &gt;= b<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Greet n times</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（n回あいさつします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Grouping parentheses don’t change an expression’s type—for example, the type of <bpt i="1" x="1">&lt;c1&gt;</bpt>(1)<ept i="1">&lt;/c1&gt;</ept> is simply <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>グループ化括弧はある式のもつ型を変えません — 例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>(1)<ept i="1">&lt;/c1&gt;</ept>の型は単に<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Guard Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>guard文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Guiding Principle of Access Levels</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセス水準の原理指針</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Half-Open Range Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>半開範囲演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Half-open ranges are particularly useful when you work with zero-based lists such as arrays, where it’s useful to count up to (but not including) the length of the list:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>半開範囲は、あなたが配列のようなゼロに基づくリストを扱うとき特に便利です、そこにおいて、そのリストの長さまで（しかしそれは含まずに）数え上げるのに役に立ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Handling Errors</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーを処理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Handling Errors Using Do-Catch</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>do-catchを使ってエラーを処理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hash Values for Set Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Set型のためのハッシュ値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Having created a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept> instance, you can access its <bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept> property to print a human-readable description of the vehicle’s current speed:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept>インスタンスを作成したら、あなたはそれの<bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept>プロパティにアクセスして、その乗り物の現在速度の説明を人の読めるように出力することが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here are two classes, <bpt i="0" x="0">&lt;c0&gt;</bpt>Circle<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Country<ept i="1">&lt;/c1&gt;</ept>, both of which conform to the <bpt i="2" x="2">&lt;c2&gt;</bpt>HasArea<ept i="2">&lt;/c2&gt;</ept> protocol:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その両方とも<bpt i="2" x="2">&lt;c2&gt;</bpt>HasArea<ept i="2">&lt;/c2&gt;</ept>プロトコルに従う２つのクラス、<bpt i="0" x="0">&lt;c0&gt;</bpt>Circle<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Country<ept i="1">&lt;/c1&gt;</ept>が、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here is the general form of a <bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> statement:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに<bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>文の一般的な形式があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here the function returns an integer, so <bpt i="9" x="9">&lt;c9&gt;</bpt>x<ept i="9">&lt;/c9&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt>y<ept i="10">&lt;/c10&gt;</ept> are optional integers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに整数を返す関数があります、それで<bpt i="9" x="9">&lt;c9&gt;</bpt>x<ept i="9">&lt;/c9&gt;</ept>と<bpt i="10" x="10">&lt;c10&gt;</bpt>y<ept i="10">&lt;/c10&gt;</ept>はオプショナル整数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, <bpt i="0" x="0">&lt;c0&gt;</bpt>$0<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>$1<ept i="1">&lt;/c1&gt;</ept> refer to the closure’s first and second <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>$0<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>$1<ept i="1">&lt;/c1&gt;</ept>は、クロージャの１番目と２番目の<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>引数に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, <bpt i="0" x="0">&lt;c0&gt;</bpt>AudioSample<ept i="0">&lt;/c0&gt;</ept> is defined as an alias for <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt16<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>AudioSample<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt16<ept i="1">&lt;/c1&gt;</ept>に対するエイリアス（別名）として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> disambiguates between a method parameter called <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> and an instance property that is also called <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>と呼ばれるメソッドパラメータと同様にまた<bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>と呼ばれるインスタンスプロパティの間の曖昧さをなくします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, a new array called <bpt i="0" x="0">&lt;c0&gt;</bpt>breakfastList<ept i="0">&lt;/c0&gt;</ept> is created from an array literal containing three new <bpt i="1" x="1">&lt;c1&gt;</bpt>ShoppingListItem<ept i="1">&lt;/c1&gt;</ept> instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>breakfastList<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しい配列は、３つの新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>ShoppingListItem<ept i="1">&lt;/c1&gt;</ept>インスタンスを含んでいる配列リテラルからつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, an additional <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement was added to respond to particularly warm temperatures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、追加の<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文は、特に暖かい気温に反応するために加えられました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, the <bpt i="4" x="4">&lt;c4&gt;</bpt>shoppingList<ept i="4">&lt;/c4&gt;</ept> array is initialized with two <bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept> values (<bpt i="6" x="6">&lt;c6&gt;</bpt>"Eggs"<ept i="6">&lt;/c6&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt>"Milk"<ept i="7">&lt;/c7&gt;</ept>), written within an array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここで、<bpt i="4" x="4">&lt;c4&gt;</bpt>shoppingList<ept i="4">&lt;/c4&gt;</ept>配列は、配列リテラル内に書かれる２つの<bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept>値（<bpt i="6" x="6">&lt;c6&gt;</bpt>"Eggs"<ept i="6">&lt;/c6&gt;</ept>と<bpt i="7" x="7">&lt;c7&gt;</bpt>"Milk"<ept i="7">&lt;/c7&gt;</ept>）で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, the <bpt i="6" x="6">&lt;c6&gt;</bpt>favoriteGenres<ept i="6">&lt;/c6&gt;</ept> set is initialized with three <bpt i="7" x="7">&lt;c7&gt;</bpt>String<ept i="7">&lt;/c7&gt;</ept> values (<bpt i="8" x="8">&lt;c8&gt;</bpt>"Rock"<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>"Classical"<ept i="9">&lt;/c9&gt;</ept>, and <bpt i="10" x="10">&lt;c10&gt;</bpt>"Hip hop"<ept i="10">&lt;/c10&gt;</ept>), written within an array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、<bpt i="6" x="6">&lt;c6&gt;</bpt>favoriteGenres<ept i="6">&lt;/c6&gt;</ept>集合は、配列リテラル内に書かれる、３つの<bpt i="7" x="7">&lt;c7&gt;</bpt>String<ept i="7">&lt;/c7&gt;</ept>値（<bpt i="8" x="8">&lt;c8&gt;</bpt>"Rock"<ept i="8">&lt;/c8&gt;</ept>、<bpt i="9" x="9">&lt;c9&gt;</bpt>"Classical"<ept i="9">&lt;/c9&gt;</ept>、そして<bpt i="10" x="10">&lt;c10&gt;</bpt>"Hip hop"<ept i="10">&lt;/c10&gt;</ept>）で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, the deinitializer simply returns all of the player’s coins to the bank:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、デイニシャライザは単に胴元にプレーヤーのコインの全てを返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, the function type of the <bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept> method’s argument makes it clear that a <bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept> value must be returned by the closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept>メソッドの引数である関数型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept>値がクロージャによって返されなければならないことを明白にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, the player has won 2,000 coins.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、プレーヤーは2,000個のコインを獲得しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, the possibility that <bpt i="10" x="10">&lt;c10&gt;</bpt>increment(forCount:)<ept i="10">&lt;/c10&gt;</ept> might not be implemented is also handled by optional chaining.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、<bpt i="10" x="10">&lt;c10&gt;</bpt>increment(forCount:)<ept i="10">&lt;/c10&gt;</ept>が実装されないかもしれないという可能性もまたオプショナル連鎖によって取り扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, the raw values for an enumeration called <bpt i="0" x="0">&lt;c0&gt;</bpt>ASCIIControlCharacter<ept i="0">&lt;/c0&gt;</ept> are defined to be of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept>, and are set to some of the more common ASCII control characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>ASCIIControlCharacter<ept i="0">&lt;/c0&gt;</ept>と呼ばれる列挙に対する生の値は、型<bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept>であると定義されて、たいへんありふれたASCII制御文字のいくつかに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, the superclass has a single designated initializer and two convenience initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、スーパークラスは一つの指定イニシャライザと２つの便宜イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, the value of the constant <bpt i="0" x="0">&lt;c0&gt;</bpt>three<ept i="0">&lt;/c0&gt;</ept> is used to create a new value of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>, so that both sides of the addition are of the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、定数<bpt i="0" x="0">&lt;c0&gt;</bpt>three<ept i="0">&lt;/c0&gt;</ept>の値が、<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>型の新しい値をつくるために使われます、それでこの加算の両側は同じ型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here, they are used to print the categorization of the point.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここでは、それらはポイントの分類を出力するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a class called <bpt i="0" x="0">&lt;c0&gt;</bpt>Animal<ept i="0">&lt;/c0&gt;</ept>, which doesn’t conform to the <bpt i="1" x="1">&lt;c1&gt;</bpt>HasArea<ept i="1">&lt;/c1&gt;</ept> protocol:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>HasArea<ept i="1">&lt;/c1&gt;</ept>プロトコルに従わない<bpt i="0" x="0">&lt;c0&gt;</bpt>Animal<ept i="0">&lt;/c0&gt;</ept>と呼ばれるクラスが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a function called <bpt i="0" x="0">&lt;c0&gt;</bpt>chooseStepFunction(backward:)<ept i="0">&lt;/c0&gt;</ept>, whose return type is <bpt i="1" x="1">&lt;c1&gt;</bpt>(Int) -&gt; Int<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに<bpt i="0" x="0">&lt;c0&gt;</bpt>chooseStepFunction(backward:)<ept i="0">&lt;/c0&gt;</ept>と呼ばれる関数があります、それの戻り型は<bpt i="1" x="1">&lt;c1&gt;</bpt>(Int) -&gt; Int<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a function with no input parameters, which always returns the same <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> message whenever it is called:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに入力パラメータのない関数があります、そしてそれは、それが呼ばれるときはいつでも、常に同じ<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>メッセージを返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a generic version of the <bpt i="1" x="1">&lt;c1&gt;</bpt>swapTwoInts(_:_:)<ept i="1">&lt;/c1&gt;</ept> function from above, called <bpt i="2" x="2">&lt;c2&gt;</bpt>swapTwoValues(_:_:)<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、上記の<bpt i="1" x="1">&lt;c1&gt;</bpt>swapTwoInts(_:_:)<ept i="1">&lt;/c1&gt;</ept>関数の総称体版があります、それは<bpt i="2" x="2">&lt;c2&gt;</bpt>swapTwoValues(_:_:)<ept i="2">&lt;/c2&gt;</ept>と呼ばれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a generic version of the same code:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じコードの総称体版は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a more complex class, which also adopts and conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>FullyNamed<ept i="0">&lt;/c0&gt;</ept> protocol:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>また、<bpt i="0" x="0">&lt;c0&gt;</bpt>FullyNamed<ept i="0">&lt;/c0&gt;</ept>プロトコルを採用して準拠するさらに複雑なクラスが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a more complex data source called <bpt i="0" x="0">&lt;c0&gt;</bpt>TowardsZeroSource<ept i="0">&lt;/c0&gt;</ept>, which makes a <bpt i="1" x="1">&lt;c1&gt;</bpt>Counter<ept i="1">&lt;/c1&gt;</ept> instance count up or down towards zero from its current <bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>TowardsZeroSource<ept i="0">&lt;/c0&gt;</ept>と呼ばれるより複雑なデータ・ソースがここにあります、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Counter<ept i="1">&lt;/c1&gt;</ept>インスタンスをその現在の<bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept>値から上下にゼロの方へ数えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a nongeneric function called <bpt i="0" x="0">&lt;c0&gt;</bpt>findIndex(ofString:in:)<ept i="0">&lt;/c0&gt;</ept>, which is given a <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> value to find and an array of <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> values within which to find it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに<bpt i="0" x="0">&lt;c0&gt;</bpt>findIndex(ofString:in:)<ept i="0">&lt;/c0&gt;</ept>と呼ばれる非総称体関数があります、それは、見つける<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値と、そこにおいてそれを捜す<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>値からなる配列を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a simple <bpt i="0" x="0">&lt;c0&gt;</bpt>CounterDataSource<ept i="0">&lt;/c0&gt;</ept> implementation where the data source returns a constant value of <bpt i="1" x="1">&lt;c1&gt;</bpt>3<ept i="1">&lt;/c1&gt;</ept> every time it’s queried.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある単純な<bpt i="0" x="0">&lt;c0&gt;</bpt>CounterDataSource<ept i="0">&lt;/c0&gt;</ept>実装がここにあります、そこにおいて、データ・ソースは<bpt i="1" x="1">&lt;c1&gt;</bpt>3<ept i="1">&lt;/c1&gt;</ept>の定数値をそれが問い合わされるたびに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a skeleton outline of how a closure can be used to provide a default property value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、あるクロージャが省略時のプロパティ値を提供するために使われることができる方法の骨組み概要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a standard, nongeneric function called <bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept>, which swaps two <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> values:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、通常の、非総称体の<bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept>と呼ばれる関数があります、それは、２つの<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値を交換します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a variation of the <bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:)<ept i="0">&lt;/c0&gt;</ept> function that takes a person’s name and hometown and returns a greeting:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに<bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:)<ept i="0">&lt;/c0&gt;</ept>関数の変形があります、それはある個人の名前と出身地をとって挨拶を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a version of the <bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:)<ept i="0">&lt;/c0&gt;</ept> function, which prints its own <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> value rather than returning it:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに<bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:)<ept i="0">&lt;/c0&gt;</ept>関数の改作があります、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値を自身で出力します、それを返すのではなく：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a version of the <bpt i="0" x="0">&lt;e0&gt;</bpt>Snakes and Ladders<ept i="0">&lt;/e0&gt;</ept> game originally introduced in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Control Flow<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>制御の流れ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で元々は紹介される<bpt i="0" x="0">&lt;e0&gt;</bpt>ヘビとはしご<ept i="0">&lt;/e0&gt;</ept>ゲームのひとつの改作が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s a version of the nongeneric <bpt i="0" x="0">&lt;c0&gt;</bpt>IntStack<ept i="0">&lt;/c0&gt;</ept> type from earlier, adapted to conform to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept> protocol:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以前の非総称体の<bpt i="0" x="0">&lt;c0&gt;</bpt>IntStack<ept i="0">&lt;/c0&gt;</ept>型の改作、<bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠するために適応させたものが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an alternative version of the <bpt i="1" x="1">&lt;c1&gt;</bpt>Rect<ept i="1">&lt;/c1&gt;</ept> structure, which takes advantage of this shorthand notation:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この短縮形表記法を利用する<bpt i="1" x="1">&lt;c1&gt;</bpt>Rect<ept i="1">&lt;/c1&gt;</ept>構造体の代替版が、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example for the four main points of a compass:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、コンパスの主な４方位のための例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of <bpt i="0" x="0">&lt;c0&gt;</bpt>makeIncrementer<ept i="0">&lt;/c0&gt;</ept> in action:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>動作している<bpt i="0" x="0">&lt;c0&gt;</bpt>makeIncrementer<ept i="0">&lt;/c0&gt;</ept>の例がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of <bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept> in action.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept>の作動する例が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of a deinitializer in action.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライザの動作の例は、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of a function called <bpt i="0" x="0">&lt;c0&gt;</bpt>makeIncrementer<ept i="0">&lt;/c0&gt;</ept>, which contains a nested function called <bpt i="1" x="1">&lt;c1&gt;</bpt>incrementer<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、<bpt i="0" x="0">&lt;c0&gt;</bpt>makeIncrementer<ept i="0">&lt;/c0&gt;</ept>と呼ばれる関数の例があります、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>incrementer<ept i="1">&lt;/c1&gt;</ept>と呼ばれる入れ子にされた関数を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of a function called <bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept>, which has two in-out integer parameters called <bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに<bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept>と呼ばれる関数の例があります、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept>と呼ばれる２つのin-out整数パラメータを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of a protocol called <bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept>, which declares an associated type called <bpt i="1" x="1">&lt;c1&gt;</bpt>Item<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept>と呼ばれるプロトコルの例がここにあります、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>Item<ept i="1">&lt;/c1&gt;</ept>と呼ばれる関連型を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of a protocol that inherits the <bpt i="0" x="0">&lt;c0&gt;</bpt>TextRepresentable<ept i="0">&lt;/c0&gt;</ept> protocol from above:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="0" x="0">&lt;c0&gt;</bpt>TextRepresentable<ept i="0">&lt;/c0&gt;</ept>プロトコルを継承するプロトコルの例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of a protocol used as a type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型として使われるプロトコルの例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of a protocol with a single instance property requirement:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ただ一つのインスタンスプロパティ要件を持つプロトコルの例が、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of a read-only subscript implementation, which defines a <bpt i="0" x="0">&lt;c0&gt;</bpt>TimesTable<ept i="0">&lt;/c0&gt;</ept> structure to represent an <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>-times-table of integers:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに読み出し専用の添え字の実施の例があります、それは、整数の九九の<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>段を表す<bpt i="0" x="0">&lt;c0&gt;</bpt>TimesTable<ept i="0">&lt;/c0&gt;</ept>構造体を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of a simple structure that adopts and conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>FullyNamed<ept i="0">&lt;/c0&gt;</ept> protocol:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>FullyNamed<ept i="0">&lt;/c0&gt;</ept>プロトコルを採用して準拠する単純な構造体の例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of a structure definition and a class definition:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体定義とクラス定義の例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of how Automatic Reference Counting works.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自動参照カウントがどのように働くかの例は、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of how a strong reference cycle can be created by accident.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>強い参照循環がどのように偶然に作られることができるかの例は、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of how constants and variables can be used to track the number of login attempts a user has made:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに定数と変数が、どのようにあるユーザーが行ったログインの試みの数を追跡するために使われることができるかの例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of how error handling can be used to respond to different error conditions:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにどのようにエラー処理が異なるエラー状態に応答するために使われることができるかの例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of how optionals can be used to cope with the absence of a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、値の欠如に対処するためにどのようにオプショナルが使われることができるかの１つの例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of this syntax for a <bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> loop, although the principle is the same for all loops and <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statements:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、この構文の<bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>ループに対する例があります、とはいえその原則は全てのループと<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文のための同じです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of using <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept> to work with a mix of different types, including function types and nonclass types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数型と非クラス型を含む、異なった型の混合を扱うために<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept>を使う例が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of what happens when an unsigned integer is allowed to overflow in the positive direction, using the overflow addition operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+<ept i="0">&lt;/c0&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、オーバフロー加算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+<ept i="0">&lt;/c0&gt;</ept>）を使用して、正の向きにおいて符号なし整数がオーバフローを許されるとき何が起こるかの例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example that combines the <bpt i="0" x="0">&lt;c0&gt;</bpt>Named<ept i="0">&lt;/c0&gt;</ept> protocol from the previous example with a <bpt i="1" x="1">&lt;c1&gt;</bpt>Location<ept i="1">&lt;/c1&gt;</ept> class:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに１つの例があります、それは前の例からの<bpt i="0" x="0">&lt;c0&gt;</bpt>Named<ept i="0">&lt;/c0&gt;</ept>プロトコルを<bpt i="1" x="1">&lt;c1&gt;</bpt>Location<ept i="1">&lt;/c1&gt;</ept>クラスと結び付けます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example that combines two protocols called <bpt i="0" x="0">&lt;c0&gt;</bpt>Named<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Aged<ept i="1">&lt;/c1&gt;</ept> into a single protocol composition requirement on a function parameter:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、関数パラメータ上で<bpt i="0" x="0">&lt;c0&gt;</bpt>Named<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Aged<ept i="1">&lt;/c1&gt;</ept>と呼ばれる２つのプロトコルを１つのプロトコル合成要件に結合する例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example that defines a simple <bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept> class, which can be used to count the number of times an action occurs:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単純な<bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept>クラスを定義する例がここにあります、それは、ある動作が起こる回数を数えるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example that stores raw ASCII values alongside named enumeration cases:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定した列挙ケース節の傍らに生のASCII値を格納する例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example to print the results of the math functions from above:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに上記の数学関数の結果を出力する例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example using the overflow subtraction operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-<ept i="0">&lt;/c0&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにオーバフロー減算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-<ept i="0">&lt;/c0&gt;</ept>）を使った例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example, using the <bpt i="0" x="0">&lt;c0&gt;</bpt>VideoMode<ept i="0">&lt;/c0&gt;</ept> class defined above:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上で定義される<bpt i="0" x="0">&lt;c0&gt;</bpt>VideoMode<ept i="0">&lt;/c0&gt;</ept>クラスを使用している例がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example, which calculates the height for a table row.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにひとつの例があります、それはあるテーブルの列の高さを計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにひとつの例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an expanded version of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Celsius<ept i="0">&lt;/c0&gt;</ept> example from earlier, with an additional initializer to create a new <bpt i="1" x="1">&lt;c1&gt;</bpt>Celsius<ept i="1">&lt;/c1&gt;</ept> instance from a <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept> value that is already in the Celsius scale:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに前の<bpt i="0" x="0">&lt;c0&gt;</bpt>Celsius<ept i="0">&lt;/c0&gt;</ept>例の拡張版があります、それは追加のイニシャライザを使って、既に摂氏尺度である<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>値から新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>Celsius<ept i="1">&lt;/c1&gt;</ept>インスタンスを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an implementation of a class that adopts and conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>RandomNumberGenerator<ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>RandomNumberGenerator<ept i="0">&lt;/c0&gt;</ept>プロトコルを採用して準拠するクラスの実施が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s another example, for a function with no parameters or return value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もう一つの例がここにあります、パラメータおよび戻り値のないある関数です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how <bpt i="0" x="0">&lt;c0&gt;</bpt>DiceGameTracker<ept i="0">&lt;/c0&gt;</ept> looks in action:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>動作中の<bpt i="0" x="0">&lt;c0&gt;</bpt>DiceGameTracker<ept i="0">&lt;/c0&gt;</ept>がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how <bpt i="0" x="0">&lt;c0&gt;</bpt>stackOfStrings<ept i="0">&lt;/c0&gt;</ept> looks after pushing these four values on to the stack:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの４つの値をそのスタックにプッシュした後で<bpt i="0" x="0">&lt;c0&gt;</bpt>stackOfStrings<ept i="0">&lt;/c0&gt;</ept>がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how bit shifting looks in Swift code:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビットシフトがスウィフトコードにおいてどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how phase 1 looks for an initialization call for a hypothetical subclass and superclass:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第１段階がある仮定のサブクラスとスーパークラスのための初期化呼び出しを捜す方法がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how phase 2 looks for the same initialization call:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第２段階が同じ初期化呼び出しを捜す方法は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the <bpt i="0" x="0">&lt;c0&gt;</bpt>Dice<ept i="0">&lt;/c0&gt;</ept> class can be used to create a six-sided dice with a <bpt i="1" x="1">&lt;c1&gt;</bpt>LinearCongruentialGenerator<ept i="1">&lt;/c1&gt;</ept> instance as its random number generator:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Dice<ept i="0">&lt;/c0&gt;</ept>クラスが、６面のさいころをつくるためにその乱数生成器として<bpt i="1" x="1">&lt;c1&gt;</bpt>LinearCongruentialGenerator<ept i="1">&lt;/c1&gt;</ept>インスタンスをつかってどのように使われることができるかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the <bpt i="0" x="0">&lt;c0&gt;</bpt>allItemsMatch(_:_:)<ept i="0">&lt;/c0&gt;</ept> function looks in action:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>動作中の<bpt i="0" x="0">&lt;c0&gt;</bpt>allItemsMatch(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数がどのように見えるかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the <bpt i="0" x="0">&lt;c0&gt;</bpt>isTop(_:)<ept i="0">&lt;/c0&gt;</ept> method looks in action:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>動作中の<bpt i="0" x="0">&lt;c0&gt;</bpt>isTop(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドがどのように見えるかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the bits inside an <bpt i="0" x="0">&lt;c0&gt;</bpt>Int8<ept i="0">&lt;/c0&gt;</ept> look for the number <bpt i="1" x="1">&lt;c1&gt;</bpt>-4<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int8<ept i="0">&lt;/c0&gt;</ept>内のビットが数<bpt i="1" x="1">&lt;c1&gt;</bpt>-4<ept i="1">&lt;/c1&gt;</ept>に対してどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the bits inside an <bpt i="2" x="2">&lt;c2&gt;</bpt>Int8<ept i="2">&lt;/c2&gt;</ept> look for the number <bpt i="3" x="3">&lt;c3&gt;</bpt>4<ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Int8<ept i="2">&lt;/c2&gt;</ept>内のビットが数<bpt i="3" x="3">&lt;c3&gt;</bpt>4<ept i="3">&lt;/c3&gt;</ept>に対してどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the cycle looks:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>循環がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the first lines compare:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の行がどのくらい似ているかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the method looks:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのようにそのメソッドが見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the references look now that you’ve linked the two instances together:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが２つのインスタンスを結びつけた今、参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the references look with the capture list in place:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>捕獲リストで適切にされた参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the references look, now that you’ve linked the two instances:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが２つのインスタンスを結んだ今、これらの参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the remainder operator works.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに剰余演算子が機能する方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the stack looks after popping its top value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スタックがその一番上の値をポップした後にどう見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the strong references look after creating and assigning these two instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの２つのインスタンスの作成と代入の後に強い参照がどのように見えるかが、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the strong references look after you link the two instances together:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが２つのインスタンスを結びつけた後に強い参照がどのように見えるかが、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how the strong references look after you set the <bpt i="0" x="0">&lt;c0&gt;</bpt>john<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>unit4A<ept i="1">&lt;/c1&gt;</ept> variables to <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>john<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>unit4A<ept i="1">&lt;/c1&gt;</ept>変数を<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>に設定したあと、強い参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how to write a nongeneric version of a stack, in this case for a stack of <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> values:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スタックの非総称体版を書く方法がここにあります、これは<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>値のスタックの場合です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how two-phase initialization plays out, based on the four safety checks above:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２段階初期化が、上の４つの安全点検に基づいて最後までやり終える方法がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how you call a type method on a class called <bpt i="0" x="0">&lt;c0&gt;</bpt>SomeClass<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが型メソッドを<bpt i="0" x="0">&lt;c0&gt;</bpt>SomeClass<ept i="0">&lt;/c0&gt;</ept>と呼ばれるクラスの上で呼び出す方法がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how you can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>map(_:)<ept i="0">&lt;/c0&gt;</ept> method with a trailing closure to convert an array of <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> values into an array of <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、あなたが<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値の配列を<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>値の配列に変えるために後付クロージャとともに<bpt i="0" x="0">&lt;c0&gt;</bpt>map(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドをどのように使用できるかがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how you might expect a generic version of <bpt i="0" x="0">&lt;c0&gt;</bpt>findIndex(ofString:in:)<ept i="0">&lt;/c0&gt;</ept>, called <bpt i="1" x="1">&lt;c1&gt;</bpt>findIndex(of:in:)<ept i="1">&lt;/c1&gt;</ept>, to be written.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが予想する<bpt i="0" x="0">&lt;c0&gt;</bpt>findIndex(ofString:in:)<ept i="0">&lt;/c0&gt;</ept>の総称体版、<bpt i="1" x="1">&lt;c1&gt;</bpt>findIndex(of:in:)<ept i="1">&lt;/c1&gt;</ept>と呼ばれるものが書かれる方法はここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how you use the <bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept> class to create and print a new instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが新しいインスタンスを作成して出力するために<bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept>クラスを使用する方法は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how you write that:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがそれをどう書くかここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how you write the <bpt i="1" x="1">&lt;c1&gt;</bpt>HTMLElement<ept i="1">&lt;/c1&gt;</ept> class to avoid the cycle:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="1" x="1">&lt;c1&gt;</bpt>HTMLElement<ept i="1">&lt;/c1&gt;</ept>クラスを循環を避けるように書く方法は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s the <bpt i="0" x="0">&lt;e0&gt;</bpt>Snakes and Ladders<ept i="0">&lt;/e0&gt;</ept> example again, written as a <bpt i="1" x="1">&lt;c1&gt;</bpt>repeat<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept> loop rather than a <bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに再び<bpt i="0" x="0">&lt;e0&gt;</bpt>「ヘビとはしご」<ept i="0">&lt;/e0&gt;</ept>の例があります、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>repeat<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept>ループとして書かれます、<bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept>ループではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s the general form of a <bpt i="0" x="0">&lt;c0&gt;</bpt>repeat<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept> loop:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>repeat<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept>ループの一般的な形式は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s the general form of a <bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> loop:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>ループの一般的な形式は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s the initial array to be sorted:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>分類される最初の配列は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hexadecimal floating-point literals consist of a <bpt i="0" x="0">&lt;c0&gt;</bpt>0x<ept i="0">&lt;/c0&gt;</ept> prefix, followed by an optional hexadecimal fraction, followed by a hexadecimal exponent.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>16進の浮動小数点リテラルは、<bpt i="0" x="0">&lt;c0&gt;</bpt>0x<ept i="0">&lt;/c0&gt;</ept>接頭辞、続けて任意の16進の小数部、それに続く16進の指数から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Higher-precedence operators are evaluated before lower-precedence ones.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より高い優先順位の演算子は、より低い優先順位のもの前に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Horizontal tab (<bpt i="0" x="0">&lt;c0&gt;</bpt>\t<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>水平タブ（<bpt i="0" x="0">&lt;c0&gt;</bpt>\t<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How ARC Works</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ARCは、どのように働きますか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How Deinitialization Works</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライズはどのように働くか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>How to Read the Grammar</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この文法を読む方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, Swift classes and structures are much closer in functionality than in other languages, and much of this chapter describes functionality that can apply to instances of <bpt i="2" x="2">&lt;e2&gt;</bpt>either<ept i="2">&lt;/e2&gt;</ept> a class or a structure type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、スウィフトのクラスと構造体は他の言語においてよりも機能性において非常に近いものです、したがってこの章の多くはクラスまたは構造体型の<bpt i="2" x="2">&lt;e2&gt;</bpt>両方の<ept i="2">&lt;/e2&gt;</ept>インスタンスに適用されることができる機能性を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, Swift only performs an <bpt i="0" x="0">&lt;e0&gt;</bpt>actual<ept i="0">&lt;/e0&gt;</ept> copy behind the scenes when it is absolutely necessary to do so.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、スウィフトは<bpt i="0" x="0">&lt;e0&gt;</bpt>実際の<ept i="0">&lt;/e0&gt;</ept>コピーを、そうすることが絶対に不可欠な時に舞台裏で行うだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, a method marked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>objc<ept i="2">&lt;/c2&gt;</ept> attribute can override a method marked with the <bpt i="3" x="3">&lt;c3&gt;</bpt>nonobjc<ept i="3">&lt;/c3&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、<bpt i="2" x="2">&lt;c2&gt;</bpt>objc<ept i="2">&lt;/c2&gt;</ept>属性で印されるメソッドは<bpt i="3" x="3">&lt;c3&gt;</bpt>nonobjc<ept i="3">&lt;/c3&gt;</ept>属性で印されるメソッドをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, a unit test target can access any internal entity, if you mark the import declaration for a product module with the <bpt i="0" x="0">&lt;c0&gt;</bpt>@testable<ept i="0">&lt;/c0&gt;</ept> attribute and compile that product module with testing enabled.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、あなたが製品モジュールのためのインポート宣言を<bpt i="0" x="0">&lt;c0&gt;</bpt>@testable<ept i="0">&lt;/c0&gt;</ept>属性で印して、その製品モジュールをテスト可能な状態にコンパイルするならば、ユニットテストターゲットはあらゆる内部実在にアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, adding parentheses around a type doesn’t have any effect.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>けれども、ある型の周りに丸括弧を加えることは全く影響はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, at the point that they’re stored in the <bpt i="3" x="3">&lt;c3&gt;</bpt>objectWithArea<ept i="3">&lt;/c3&gt;</ept> constant, they’re only known to be of type <bpt i="4" x="4">&lt;c4&gt;</bpt>HasArea<ept i="4">&lt;/c4&gt;</ept>, and so only their <bpt i="5" x="5">&lt;c5&gt;</bpt>area<ept i="5">&lt;/c5&gt;</ept> property can be accessed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、それらが定数の<bpt i="3" x="3">&lt;c3&gt;</bpt>objectWithArea<ept i="3">&lt;/c3&gt;</ept>に格納される時点で、それらは型<bpt i="4" x="4">&lt;c4&gt;</bpt>HasArea<ept i="4">&lt;/c4&gt;</ept>であるということを知られているだけです、なので、それらの<bpt i="5" x="5">&lt;c5&gt;</bpt>area<ept i="5">&lt;/c5&gt;</ept>プロパティだけがアクセスされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, avoid using keywords as names unless you have absolutely no choice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたに選択が全くない場合を除き、キーワードをなんらかの名前として使用することを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, because <bpt i="1" x="1">&lt;c1&gt;</bpt>asHTML<ept i="1">&lt;/c1&gt;</ept> is a closure property rather than an instance method, you can replace the default value of the <bpt i="2" x="2">&lt;c2&gt;</bpt>asHTML<ept i="2">&lt;/c2&gt;</ept> property with a custom closure, if you want to change the HTML rendering for a particular HTML element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、<bpt i="1" x="1">&lt;c1&gt;</bpt>asHTML<ept i="1">&lt;/c1&gt;</ept>はインスタンスメソッドではなくクロージャプロパティであるので、あなたが特定のHTML要素に対してHTML解釈を変更したいならば、あなたはあつらえのクロージャで<bpt i="2" x="2">&lt;c2&gt;</bpt>asHTML<ept i="2">&lt;/c2&gt;</ept>プロパティの省略時の値を置き替えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, because it’s called with a string constant, you can see that the initializer won’t fail, so no runtime error can occur in this case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、それは文字列定数で呼び出されるので、あなたはこのイニシャライザが失敗することはないと分かります、それで実行時エラーはこの場合には起こりえません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, because of Swift’s type inference, you don’t have to write the type of the set if you’re initializing it with an array literal containing values of the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、スウィフトのもつ型推論のために、あなたが同じ型の値を含んでいる配列リテラルを使ってそれを初期化しているならば、あなたは集合の型を書く必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, because the closure refers to <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> within its body (as a way to reference <bpt i="2" x="2">&lt;c2&gt;</bpt>self.name<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>self.text<ept i="3">&lt;/c3&gt;</ept>), the closure <bpt i="4" x="4">&lt;e4&gt;</bpt>captures<ept i="4">&lt;/e4&gt;</ept> self, which means that it holds a strong reference back to the <bpt i="5" x="5">&lt;c5&gt;</bpt>HTMLElement<ept i="5">&lt;/c5&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、クロージャがその本文内で<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>に言及する（<bpt i="2" x="2">&lt;c2&gt;</bpt>self.name<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>self.text<ept i="3">&lt;/c3&gt;</ept>を参照する方法として）ので、クロージャはselfを<bpt i="4" x="4">&lt;e4&gt;</bpt>捕獲<ept i="4">&lt;/e4&gt;</ept>します、それは、今度は逆にそれが<bpt i="5" x="5">&lt;c5&gt;</bpt>HTMLElement<ept i="5">&lt;/c5&gt;</ept>インスタンスへの強い参照を保持することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, before you learn how to break a strong reference cycle with a closure capture list, it’s useful to understand how such a cycle can be caused.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたがクロージャ捕獲リストで強い参照循環を壊す方法を学ぶ前に、そのような循環がどのように引き起こされることがありえるか理解することは役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, before you learn how to resolve a strong reference cycle, it’s useful to understand how such a cycle is caused.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたが強い参照循環を解消する方法を学ぶ前に、そのような循環がどのように引き起こされるか理解することは役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, for the inline closure expression, the parameters and return type are written <bpt i="2" x="2">&lt;e2&gt;</bpt>inside<ept i="2">&lt;/e2&gt;</ept> the curly braces, not outside of them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、行内クロージャ式のために、パラメータと戻り型は、波括弧の<bpt i="2" x="2">&lt;e2&gt;</bpt>内側<ept i="2">&lt;/e2&gt;</ept>に書かれます、その外側ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, functions and methods with no return type have an implicit return type of <bpt i="0" x="0">&lt;c0&gt;</bpt>Void<ept i="0">&lt;/c0&gt;</ept>, as described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Functions Without Return Values<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>戻り値のない関数<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述されるように、戻り型のない関数やメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Void<ept i="0">&lt;/c0&gt;</ept>の暗黙の戻り型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if ARC were to deallocate an instance that was still in use, it would no longer be possible to access that instance’s properties, or call that instance’s methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、ARCがまだ使用中だったインスタンスの割り当て解除をすることになったならば、そのインスタンスのプロパティにアクセスすることや、そのインスタンスのメソッドを呼ぶことは、もはや可能でないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if multiple matches are possible, the first matching case is always used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、複数の適合が出来るならば、最初の適合するケース節が常に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if you apply both a prefix and a postfix operator to the same operand, the postfix operator is applied first.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたが接頭辞演算子と接尾辞演算子の両方を同じ演算数を適用したならば、接尾辞演算子が最初に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if you iterate over the contents of this array, the items you receive back are typed as <bpt i="3" x="3">&lt;c3&gt;</bpt>MediaItem<ept i="3">&lt;/c3&gt;</ept>, and not as <bpt i="4" x="4">&lt;c4&gt;</bpt>Movie<ept i="4">&lt;/c4&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>Song<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたがこの配列の内容上に繰り返すならば、あなたがそこから取り出す項目は、<bpt i="3" x="3">&lt;c3&gt;</bpt>MediaItem<ept i="3">&lt;/c3&gt;</ept>型としてであって、<bpt i="4" x="4">&lt;c4&gt;</bpt>Movie<ept i="4">&lt;/c4&gt;</ept>または<bpt i="5" x="5">&lt;c5&gt;</bpt>Song<ept i="5">&lt;/c5&gt;</ept>ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if you need to modify the properties of your structure or enumeration within a particular method, you can opt in to <bpt i="0" x="0">&lt;e0&gt;</bpt>mutating<ept i="0">&lt;/e0&gt;</ept> behavior for that method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたがある特定のメソッド内であなたの構造体または列挙のプロパティを修正する必要があるならば、あなたはそのメソッドのために<bpt i="0" x="0">&lt;e0&gt;</bpt>可変<ept i="0">&lt;/e0&gt;</ept>挙動を選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if you write whitespace at the beginning of a line in addition to what’s before the closing quotes, that whitespace <bpt i="1" x="1">&lt;e1&gt;</bpt>is<ept i="1">&lt;/e1&gt;</ept> included.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、あなたが閉じ引用符の前のものに加えて空白文字をある行の始まりで書くならば、その空白文字は含められ<bpt i="1" x="1">&lt;e1&gt;</bpt>ます<ept i="1">&lt;/e1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, in a few cases ARC requires more information about the relationships between parts of your code in order to manage memory for you.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、２、３の場合には、ARCは、あなたのためにメモリを管理するために、あなたのコードの部分間の関係に関するより多くの情報を要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, initializers do not have an identifying function name before their parentheses in the way that functions and methods do.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、イニシャライザは、関数とメソッドがするように識別する関数名をその括弧の前に持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, instances of enumeration types have value semantics, which means they have a fixed layout in memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、列挙型のインスタンスは値意味論を持ちます、それは、それらがメモリにおいてある固定された配置を持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, it is more convenient (and clearer in intent) for the <bpt i="3" x="3">&lt;c3&gt;</bpt>init(center:size:)<ept i="3">&lt;/c3&gt;</ept> initializer to take advantage of an existing initializer that already provides exactly that functionality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、すでに正確にその機能性を提供する既存のイニシャライザを利用するほうが、<bpt i="3" x="3">&lt;c3&gt;</bpt>init(center:size:)<ept i="3">&lt;/c3&gt;</ept>イニシャライザにとってより便利です（そして意図においてより明白です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, it is not appropriate for an animal to have an empty string as the value of its <bpt i="7" x="7">&lt;c7&gt;</bpt>species<ept i="7">&lt;/c7&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、ある動物にとってそれの<bpt i="7" x="7">&lt;c7&gt;</bpt>species<ept i="7">&lt;/c7&gt;</ept>（種族）プロパティの値として空の文字列を持つことはふさわしくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, it is sometimes useful to be able to store <bpt i="1" x="1">&lt;e1&gt;</bpt>associated values<ept i="1">&lt;/e1&gt;</ept> of other types alongside these case values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、他の型の<bpt i="1" x="1">&lt;e1&gt;</bpt>関連値<ept i="1">&lt;/e1&gt;</ept>をこれらのケース節値の傍らに保存することができることは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, it is sometimes useful to write shorter versions of function-like constructs without a full declaration and name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、まるまる完全な宣言や名前なしに、関数のような構造物のより短いものをいろいろと書くことは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, its behavior in Swift for negative numbers means that, strictly speaking, it’s a remainder rather than a modulo operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、スウィフトでの負数に対するそれの挙動は、それが、厳密に言って、剰余（remainder）であり、モジュロ（modulo）演算でないのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, it’s possible to write code in which an instance of a class <bpt i="0" x="0">&lt;e0&gt;</bpt>never<ept i="0">&lt;/e0&gt;</ept> gets to a point where it has zero strong references.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、あるクラスのあるインスタンスが、強い参照を１つも持たない状態になることが<bpt i="0" x="0">&lt;e0&gt;</bpt>決してない<ept i="0">&lt;/e0&gt;</ept>コードを書くことは、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, it’s sometimes useful to enforce certain <bpt i="2" x="2">&lt;e2&gt;</bpt>type constraints<ept i="2">&lt;/e2&gt;</ept> on the types that can be used with generic functions and generic types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、総称体関数と総称体型で使われることができる型に、特定の<bpt i="2" x="2">&lt;e2&gt;</bpt>型制約<ept i="2">&lt;/e2&gt;</ept>を強制することは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, like all type aliases, <bpt i="3" x="3">&lt;c3&gt;</bpt>Void<ept i="3">&lt;/c3&gt;</ept> is always a type—you can’t use it to write an empty tuple expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、すべての型エイリアスのように、<bpt i="3" x="3">&lt;c3&gt;</bpt>Void<ept i="3">&lt;/c3&gt;</ept>は常にある型です—あなたはそれを使って空のタプル式を書くことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, loops and conditional statements can both use the <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept> statement to end their execution prematurely.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、ループと条件文は、両方ともしかるべき時よりも早くそれらの実行を終えるために<bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>文を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, multiple levels of optional chaining do not add more levels of optionality to the returned value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、オプショナル連鎖の複数の階層は、返された値にさらにオプショナルの階層を加えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, not every string can be converted into an integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、すべての文字列が、整数に変えられることができるというわけでありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, only nongeneric global functions, and local functions or closures that don’t capture any local variables, can be used as a function with C function calling conventions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、非総称体グローバル関数だけは、つまり全くローカル変数をキャプチャしないローカル関数またはクロージャは、C関数呼出規約を持つ関数として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, properties can also be associated with the type itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、プロパティはまた、型それ自体に結び付けられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, rather than two class instances, this time it’s a class instance and a closure that are keeping each other alive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし２つのクラスインスタンスではなく、今度は、それはお互いを生かし続けているクラスインスタンスとクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, remainder and multiplication have the <bpt i="0" x="0">&lt;e0&gt;</bpt>same<ept i="0">&lt;/e0&gt;</ept> precedence as each other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、剰余と乗算は、互いに<bpt i="0" x="0">&lt;e0&gt;</bpt>同じ<ept i="0">&lt;/e0&gt;</ept>優先順位を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, semicolons <bpt i="1" x="1">&lt;e1&gt;</bpt>are<ept i="1">&lt;/e1&gt;</ept> required if you want to write multiple separate statements on a single line:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それにもかかわらず、セミコロンは必要と<bpt i="1" x="1">&lt;e1&gt;</bpt>されます<ept i="1">&lt;/e1&gt;</ept>、もしあなたが一つの行に複数の別々の文を書きたい場合には：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, structure instances are always passed by <bpt i="0" x="0">&lt;e0&gt;</bpt>value<ept i="0">&lt;/e0&gt;</ept>, and class instances are always passed by <bpt i="1" x="1">&lt;e1&gt;</bpt>reference<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、構造体インスタンスは常に<bpt i="0" x="0">&lt;e0&gt;</bpt>値<ept i="0">&lt;/e0&gt;</ept>によって渡されます、そして、クラスインスタンスは常に<bpt i="1" x="1">&lt;e1&gt;</bpt>参照<ept i="1">&lt;/e1&gt;</ept>によって渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, superclass initializers <bpt i="0" x="0">&lt;e0&gt;</bpt>are<ept i="0">&lt;/e0&gt;</ept> automatically inherited if certain conditions are met.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、スーパークラスのイニシャライザは、決まった条件が満たされるならば、自動的に継承<bpt i="0" x="0">&lt;e0&gt;</bpt>されます<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, that argument is now an inline closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、この引数は今では１つの行内クロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, that property declaration can’t be implemented as a constant property or a read-only computed property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、そのプロパティ宣言は、定数プロパティまたは読み出し専用の計算プロパティとして実装されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the <bpt i="0" x="0">&lt;c0&gt;</bpt>width<ept i="0">&lt;/c0&gt;</ept> property of the original <bpt i="1" x="1">&lt;c1&gt;</bpt>hd<ept i="1">&lt;/c1&gt;</ept> instance still has the old value of <bpt i="2" x="2">&lt;c2&gt;</bpt>1920<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、最初の<bpt i="1" x="1">&lt;c1&gt;</bpt>hd<ept i="1">&lt;/c1&gt;</ept>インスタンスの<bpt i="0" x="0">&lt;c0&gt;</bpt>width<ept i="0">&lt;/c0&gt;</ept>プロパティは、まだ<bpt i="2" x="2">&lt;c2&gt;</bpt>1920<ept i="2">&lt;/c2&gt;</ept>の古い値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the <bpt i="1" x="1">&lt;c1&gt;</bpt>fatalError(_:file:line:)<ept i="1">&lt;/c1&gt;</ept> function always halts execution, regardless of optimization settings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、<bpt i="1" x="1">&lt;c1&gt;</bpt>fatalError(_:file:line:)<ept i="1">&lt;/c1&gt;</ept>関数は常に実行を停止します、最適化設定に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the <bpt i="2" x="2">&lt;c2&gt;</bpt>&amp;&amp;<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>||<ept i="3">&lt;/c3&gt;</ept> operators still operate on only two values, so this is actually three smaller expressions chained together.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、<bpt i="2" x="2">&lt;c2&gt;</bpt>&amp;&amp;<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>||<ept i="3">&lt;/c3&gt;</ept>演算子は依然として２つの値だけに作用します、なのでこれは実際のところ１つに繋がれた３つのより小さい式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the access level for the <bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfEdits<ept i="2">&lt;/c2&gt;</ept> property is marked with a <bpt i="3" x="3">&lt;c3&gt;</bpt>private(set)<ept i="3">&lt;/c3&gt;</ept> modifier to indicate that the property’s getter still has the default access level of internal, but the property is settable only from within code that’s part of the <bpt i="4" x="4">&lt;c4&gt;</bpt>TrackedString<ept i="4">&lt;/c4&gt;</ept> structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、<bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfEdits<ept i="2">&lt;/c2&gt;</ept>プロパティのためのアクセス水準は、<bpt i="3" x="3">&lt;c3&gt;</bpt>private(set)<ept i="3">&lt;/c3&gt;</ept>修飾子を使って印を付けられて、そのプロパティの持つゲッターが依然として省略時のアクセス水準の内部を持つ、しかしプロパティは<bpt i="4" x="4">&lt;c4&gt;</bpt>TrackedString<ept i="4">&lt;/c4&gt;</ept>構造体の部分であるコード内からのみ設定可能であることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the actual answer is <bpt i="0" x="0">&lt;c0&gt;</bpt>17<ept i="0">&lt;/c0&gt;</ept>, not <bpt i="1" x="1">&lt;c1&gt;</bpt>5<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、実際の答えは<bpt i="0" x="0">&lt;c0&gt;</bpt>17<ept i="0">&lt;/c0&gt;</ept>です、<bpt i="1" x="1">&lt;c1&gt;</bpt>5<ept i="1">&lt;/c1&gt;</ept>ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the alternative example below is valid:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、これに代わる以下の例は有効です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the emergency override password is known, so the overall compound expression still evaluates to <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、非常用解除パスワードは知られているので、複合式全体はなお<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>と評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the error must be handled by <bpt i="3" x="3">&lt;e3&gt;</bpt>some<ept i="3">&lt;/e3&gt;</ept> surrounding scope—either by an enclosing <bpt i="4" x="4">&lt;c4&gt;</bpt>do<ept i="4">&lt;/c4&gt;</ept>-<bpt i="5" x="5">&lt;c5&gt;</bpt>catch<ept i="5">&lt;/c5&gt;</ept> clause that handles the error or by being inside a throwing function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、エラーは<bpt i="3" x="3">&lt;e3&gt;</bpt>何らか<ept i="3">&lt;/e3&gt;</ept>の取り囲んでいるスコープによって処理される必要があります ― そのエラーを処理する 囲んでいる<bpt i="4" x="4">&lt;c4&gt;</bpt>do<ept i="4">&lt;/c4&gt;</ept>-<bpt i="5" x="5">&lt;c5&gt;</bpt>catch<ept i="5">&lt;/c5&gt;</ept>節によって、またはスロー関数内部によって、このどちらかで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the first line of <bpt i="2" x="2">&lt;c2&gt;</bpt>swapTwoValues(_:_:)<ept i="2">&lt;/c2&gt;</ept> is slightly different from <bpt i="3" x="3">&lt;c3&gt;</bpt>swapTwoInts(_:_:)<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、<bpt i="2" x="2">&lt;c2&gt;</bpt>swapTwoValues(_:_:)<ept i="2">&lt;/c2&gt;</ept>の最初の行は、わずかに<bpt i="3" x="3">&lt;c3&gt;</bpt>swapTwoInts(_:_:)<ept i="3">&lt;/c3&gt;</ept>と異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the function does not perform any safety checks on the array it is passed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、この関数は、それが渡される配列に関してどんな安全確認も実行しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the initializer for <bpt i="2" x="2">&lt;c2&gt;</bpt>Country<ept i="2">&lt;/c2&gt;</ept> cannot pass <bpt i="3" x="3">&lt;c3&gt;</bpt>self<ept i="3">&lt;/c3&gt;</ept> to the <bpt i="4" x="4">&lt;c4&gt;</bpt>City<ept i="4">&lt;/c4&gt;</ept> initializer until a new <bpt i="5" x="5">&lt;c5&gt;</bpt>Country<ept i="5">&lt;/c5&gt;</ept> instance is fully initialized, as described in <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Two-Phase Initialization<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>２段階初期化<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>で記述されるように、<bpt i="2" x="2">&lt;c2&gt;</bpt>Country<ept i="2">&lt;/c2&gt;</ept>のためのイニシャライザは、<bpt i="3" x="3">&lt;c3&gt;</bpt>self<ept i="3">&lt;/c3&gt;</ept>を<bpt i="4" x="4">&lt;c4&gt;</bpt>City<ept i="4">&lt;/c4&gt;</ept>イニシャライザに渡すことが、新しい<bpt i="5" x="5">&lt;c5&gt;</bpt>Country<ept i="5">&lt;/c5&gt;</ept>インスタンスが完全に初期化されるまでできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the method is still able to use type casting to query the type of the underlying instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、このメソッドは依然として基盤インスタンスの型についてたずねるために型キャストを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the same letter can also be represented as a <bpt i="4" x="4">&lt;e4&gt;</bpt>pair<ept i="4">&lt;/e4&gt;</ept> of scalars—a standard letter <bpt i="5" x="5">&lt;c5&gt;</bpt>e<ept i="5">&lt;/c5&gt;</ept> (<bpt i="6" x="6">&lt;c6&gt;</bpt>LATIN SMALL LETTER E<ept i="6">&lt;/c6&gt;</ept>, or <bpt i="7" x="7">&lt;c7&gt;</bpt>U+0065<ept i="7">&lt;/c7&gt;</ept>), followed by the <bpt i="8" x="8">&lt;c8&gt;</bpt>COMBINING ACUTE ACCENT<ept i="8">&lt;/c8&gt;</ept> scalar (<bpt i="9" x="9">&lt;c9&gt;</bpt>U+0301<ept i="9">&lt;/c9&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、同じ文字はまた、<bpt i="4" x="4">&lt;e4&gt;</bpt>一対<ept i="4">&lt;/e4&gt;</ept>のスカラー ― 通常の文字<bpt i="5" x="5">&lt;c5&gt;</bpt>e<ept i="5">&lt;/c5&gt;</ept>（<bpt i="6" x="6">&lt;c6&gt;</bpt>LATIN SMALL LETTER E<ept i="6">&lt;/c6&gt;</ept>、または<bpt i="7" x="7">&lt;c7&gt;</bpt>U+0065<ept i="7">&lt;/c7&gt;</ept>）、それに続けて<bpt i="8" x="8">&lt;c8&gt;</bpt>COMBINING ACUTE ACCENT<ept i="8">&lt;/c8&gt;</ept>スカラー（<bpt i="9" x="9">&lt;c9&gt;</bpt>U+0301<ept i="9">&lt;/c9&gt;</ept>）として表わされることも出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the subclass must not be generic, and must not inherit from any generic classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、サブクラスは総称体である必要はありません、そして何らかの総称体クラスから継承する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, the value of <bpt i="2" x="2">&lt;c2&gt;</bpt>john.residence.address<ept i="2">&lt;/c2&gt;</ept> is currently <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、<bpt i="2" x="2">&lt;c2&gt;</bpt>john.residence.address<ept i="2">&lt;/c2&gt;</ept>の値は、現在は<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, there is a third scenario, in which <bpt i="0" x="0">&lt;e0&gt;</bpt>both<ept i="0">&lt;/e0&gt;</ept> properties should always have a value, and neither property should ever be <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> once initialization is complete.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、第３の筋書きがあります、そこにおいて<bpt i="0" x="0">&lt;e0&gt;</bpt>両方の<ept i="0">&lt;/e0&gt;</ept>プロパティは常に値を持たなければなりません、そして一旦初期化が終了しているならば、どちらのプロパティも決して<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>であってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, there is an exception if the compilation condition includes a <bpt i="0" x="0">&lt;c0&gt;</bpt>swift()<ept i="0">&lt;/c0&gt;</ept> platform condition: The statements are parsed only if the compiler’s version of Swift matches what is specified in the platform condition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、例外があります、それはコンパイル条件が<bpt i="0" x="0">&lt;c0&gt;</bpt>swift()<ept i="0">&lt;/c0&gt;</ept>プラットホーム条件を含む場合です：文はスウィフトのコンパイラのバージョンがプラットホーム条件において指定されるものと合致する場合にのみ構文解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, there is no harm in using the <bpt i="3" x="3">&lt;c3&gt;</bpt>gameLoop<ept i="3">&lt;/c3&gt;</ept> label with the <bpt i="4" x="4">&lt;c4&gt;</bpt>continue<ept i="4">&lt;/c4&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、<bpt i="3" x="3">&lt;c3&gt;</bpt>gameLoop<ept i="3">&lt;/c3&gt;</ept>ラベルを<bpt i="4" x="4">&lt;c4&gt;</bpt>continue<ept i="4">&lt;/c4&gt;</ept>文で使用することに害はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, they can contain other string literals.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、それは、他の文字列リテラルを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, this code always triggers a runtime error when <bpt i="4" x="4">&lt;c4&gt;</bpt>residence<ept i="4">&lt;/c4&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>, as illustrated above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、<bpt i="4" x="4">&lt;c4&gt;</bpt>residence<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>nilの<ept i="5">&lt;/c5&gt;</ept>とき、上で説明するように、このコードは常に実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, this doesn’t mean that you have to specify the type of every constant and variable that you declare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、これはあなたがすべてのあなたが宣言する定数と変数の型を指定しなければならないことを意味しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, this is a rather long-winded way to write what is essentially a single-expression function (<bpt i="0" x="0">&lt;c0&gt;</bpt>a &gt; b<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、これは本質的に単一式の関数（<bpt i="0" x="0">&lt;c0&gt;</bpt>a &gt; b<ept i="0">&lt;/c0&gt;</ept>）であるものを書くには、相当に長たらしい方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, this means that they are not exactly the same as in C-based languages.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、これはCに基づく言語とそれらが厳密には同じでないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, type properties are queried and set on the <bpt i="0" x="0">&lt;e0&gt;</bpt>type<ept i="0">&lt;/e0&gt;</ept>, not on an instance of that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、型プロパティは、その型のインスタンスにではなく、その<bpt i="0" x="0">&lt;e0&gt;</bpt>型<ept i="0">&lt;/e0&gt;</ept>に問い合わせられ設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, unlike strings, you use substrings for only a short amount of time while performing actions on a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、文字列と違い、ある文字列に関して様々な行為を行う間の短いある程度の時間だけのために、あなたは下位文字列を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, using them to enforce valid data and state causes your app to terminate more predictably if an invalid state occurs, and helps makes the problem easier to debug.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、それらを使って有効なデータと状態を遵守させることは、あなたのアプリに不正な状態が生じる場合により予測のつく結びとなるようにします、そして問題をより簡単にデバッグする助けとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, when the tuples’ first elements are the same, their second elements <bpt i="6" x="6">&lt;e6&gt;</bpt>are<ept i="6">&lt;/e6&gt;</ept> compared—this is what happens on the second and third line.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、タプルのもつ最初の要素が同じ場合、２番目の要素は比較<bpt i="6" x="6">&lt;e6&gt;</bpt>されます<ept i="6">&lt;/e6&gt;</ept> — これが２番目と３番目の行で起こることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, when there isn’t a meaningful relationship between them, it’s traditional to name them using single letters such as <bpt i="5" x="5">&lt;c5&gt;</bpt>T<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>U<ept i="6">&lt;/c6&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>V<ept i="7">&lt;/c7&gt;</ept>, such as <bpt i="8" x="8">&lt;c8&gt;</bpt>T<ept i="8">&lt;/c8&gt;</ept> in the <bpt i="9" x="9">&lt;c9&gt;</bpt>swapTwoValues(_:_:)<ept i="9">&lt;/c9&gt;</ept> function above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、意味がある関係がそれらの間に無かった時、例えば<bpt i="8" x="8">&lt;c8&gt;</bpt>swapTwoValues(_:_:)<ept i="8">&lt;/c8&gt;</ept>における<bpt i="9" x="9">&lt;c9&gt;</bpt>T<ept i="9">&lt;/c9&gt;</ept>のように、<bpt i="5" x="5">&lt;c5&gt;</bpt>T<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>U<ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>V<ept i="7">&lt;/c7&gt;</ept>などの一文字を使ってそれらに名前をつけるのが伝統的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, when you are working with your own resources, you might need to perform some additional cleanup yourself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたがあなた独自のリソース（計算資源）を扱うとき、あなたは追加のいくらかの掃除をあなた自身でする必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, when you specifically want an overflow condition to truncate the number of available bits, you can opt in to this behavior rather than triggering an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたがに利用できるビットの数を切り詰めるために特にオーバフロー条件を望むとき、あなたはエラーを引き起こすのではなくこの挙動を選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, with ARC, values are deallocated as soon as their last strong reference is removed, making weak references unsuitable for such a purpose.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、ARCでは、値はその最後の強い参照が削除されるやいなや割り当て解除されて、弱い参照をそのような目的のためにふさわしくないものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, you call type methods on the type, not on an instance of that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたは型のメソッドを型の上で呼び出します、その型のインスタンスの上ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, you can also define <bpt i="0" x="0">&lt;e0&gt;</bpt>computed variables<ept i="0">&lt;/e0&gt;</ept> and define observers for stored variables, in either a global or local scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたはまた、<bpt i="0" x="0">&lt;e0&gt;</bpt>計算変数<ept i="0">&lt;/e0&gt;</ept>を定義すること、そして保存変数のためにオブザーバーを定義することが、グローバルなまたはローカルなスコープのどちらにおいても可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, you can provide explicit argument labels using the same syntax that functions, methods, and initializers use.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、あなたは明示的に引数ラベルを提供することが、関数、メソッド、およびイニシャライザが使うのと同じ構文を使うことで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, you can still change <bpt i="3" x="3">&lt;c3&gt;</bpt>tenEighty.frameRate<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>alsoTenEighty.frameRate<ept i="4">&lt;/c4&gt;</ept> because the values of the <bpt i="5" x="5">&lt;c5&gt;</bpt>tenEighty<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>alsoTenEighty<ept i="6">&lt;/c6&gt;</ept> constants themselves do not actually change.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたはそれでもなお<bpt i="3" x="3">&lt;c3&gt;</bpt>tenEighty.frameRate<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>alsoTenEighty.frameRate<ept i="4">&lt;/c4&gt;</ept>を変更することができます、なぜなら<bpt i="5" x="5">&lt;c5&gt;</bpt>tenEighty<ept i="5">&lt;/c5&gt;</ept>および<bpt i="6" x="6">&lt;c6&gt;</bpt>alsoTenEighty<ept i="6">&lt;/c6&gt;</ept>定数それら自身の値は実のところ変わらないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, you can’t construct an instance of a protocol, because protocols do not actually provide the implementations for the requirements they specify.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたはプロトコルからインスタンスを造ることができません、なぜならプロトコルは実際にはそれらが指定する要件に対する実装を用意しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, you don’t always have to write the type explicitly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたは必ずしも明確に型を書く必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Identical to (<bpt i="0" x="0">&lt;c0&gt;</bpt>===<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同一である（<bpt i="0" x="0">&lt;c0&gt;</bpt>===<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Identifier Pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>識別子パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Identifiers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>識別子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Identifiers patterns within a value-binding pattern bind new named variables or constants to their matching values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値束縛パターン内の複数の識別子パターンは、複数の新しい名前をつけられた変数または定数を、それらがマッチしている値に縛りつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Identity Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同一性演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>someThrowingFunction()<ept i="0">&lt;/c0&gt;</ept> throws an error, the value of <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>y<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>someThrowingFunction()<ept i="0">&lt;/c0&gt;</ept>がエラーをスローするならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>y<ept i="2">&lt;/c2&gt;</ept>の値は<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>, execution continues to step 2.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>ならば、実行はステップ２に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>, execution returns to step 1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>ならば、実行はステップ１に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, the program is finished executing the <bpt i="2" x="2">&lt;c2&gt;</bpt>repeat<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>ならば、プログラムは<bpt i="2" x="2">&lt;c2&gt;</bpt>repeat<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept>文の実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, the program is finished executing the <bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>ならば、プログラムは<bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept>文の実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept> aren’t of the same type, it isn’t possible to swap their values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>が同じ型でないならば、それらの値を交換することは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="3" x="3">&lt;c3&gt;</bpt>question<ept i="3">&lt;/c3&gt;</ept> is true, it evaluates <bpt i="4" x="4">&lt;c4&gt;</bpt>answer1<ept i="4">&lt;/c4&gt;</ept> and returns its value; otherwise, it evaluates <bpt i="5" x="5">&lt;c5&gt;</bpt>answer2<ept i="5">&lt;/c5&gt;</ept> and returns its value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>question<ept i="3">&lt;/c3&gt;</ept>が真実ならば、それは<bpt i="4" x="4">&lt;c4&gt;</bpt>answer1<ept i="4">&lt;/c4&gt;</ept>を評価して、その値を返します；そうでなければ、それは<bpt i="5" x="5">&lt;c5&gt;</bpt>answer2<ept i="5">&lt;/c5&gt;</ept>を評価して、その値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt>count<ept i="4">&lt;/c4&gt;</ept> is already zero, the method returns <bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept> to indicate that no further counting should take place.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>count<ept i="4">&lt;/c4&gt;</ept>がすでにゼロであるならば、メソッドは<bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>を返して、これ以上数えることは必要ないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt>square<ept i="4">&lt;/c4&gt;</ept> is valid, the value stored in <bpt i="5" x="5">&lt;c5&gt;</bpt>board[square]<ept i="5">&lt;/c5&gt;</ept> is added to the current <bpt i="6" x="6">&lt;c6&gt;</bpt>square<ept i="6">&lt;/c6&gt;</ept> value to move the player up or down any ladders or snakes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>square<ept i="4">&lt;/c4&gt;</ept>が有効ならば、<bpt i="5" x="5">&lt;c5&gt;</bpt>board[square]<ept i="5">&lt;/c5&gt;</ept>に格納される値は現在の<bpt i="6" x="6">&lt;c6&gt;</bpt>square<ept i="6">&lt;/c6&gt;</ept>の値に加えられて、はしごや蛇があればプレーヤーを上や下に動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>if文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If Statements and Forced Unwrapping</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>if文と強制アンラップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a <bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> clause doesn’t have a pattern, the clause matches any error and binds the error to a local constant named <bpt i="2" x="2">&lt;c2&gt;</bpt>error<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>節がパターンを持たないならば、その節はあらゆるエラーにマッチします、そしてそのエラーを<bpt i="2" x="2">&lt;c2&gt;</bpt>error<ept i="2">&lt;/c2&gt;</ept>と名前を付けられるローカル定数に束縛します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a <bpt i="2" x="2">&lt;c2&gt;</bpt>catch<ept i="2">&lt;/c2&gt;</ept> clause does not specify a pattern, the <bpt i="3" x="3">&lt;c3&gt;</bpt>catch<ept i="3">&lt;/c3&gt;</ept> clause matches and binds any error to a local constant named <bpt i="4" x="4">&lt;c4&gt;</bpt>error<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="2" x="2">&lt;c2&gt;</bpt>catch<ept i="2">&lt;/c2&gt;</ept>節がパターンを指定しないならば、その<bpt i="3" x="3">&lt;c3&gt;</bpt>catch<ept i="3">&lt;/c3&gt;</ept>節はマッチしてあらゆるエラーを<bpt i="4" x="4">&lt;c4&gt;</bpt>error<ept i="4">&lt;/c4&gt;</ept>と名前をつけられるローカル定数に束縛します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a <bpt i="5" x="5">&lt;c5&gt;</bpt>where<ept i="5">&lt;/c5&gt;</ept> clause is present, the <bpt i="6" x="6">&lt;e6&gt;</bpt>statements<ept i="6">&lt;/e6&gt;</ept> within the relevant case are executed only if the value of the <bpt i="7" x="7">&lt;e7&gt;</bpt>control expression<ept i="7">&lt;/e7&gt;</ept> matches one of the patterns of the case and the expression of the <bpt i="8" x="8">&lt;c8&gt;</bpt>where<ept i="8">&lt;/c8&gt;</ept> clause evaluates to <bpt i="9" x="9">&lt;c9&gt;</bpt>true<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>where<ept i="5">&lt;/c5&gt;</ept>節が存在するならば、関連するケース節の範囲内のいくらかの<bpt i="6" x="6">&lt;e6&gt;</bpt>文<ept i="6">&lt;/e6&gt;</ept>は、<bpt i="7" x="7">&lt;e7&gt;</bpt>制御式<ept i="7">&lt;/e7&gt;</ept>の値がケース節のパターンの１つとマッチして、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>where<ept i="8">&lt;/c8&gt;</ept>節が<bpt i="9" x="9">&lt;c9&gt;</bpt>true<ept i="9">&lt;/c9&gt;</ept>に評価される場合にだけ、実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a <bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept> is empty, <bpt i="7" x="7">&lt;c7&gt;</bpt>startIndex<ept i="7">&lt;/c7&gt;</ept> and <bpt i="8" x="8">&lt;c8&gt;</bpt>endIndex<ept i="8">&lt;/c8&gt;</ept> are equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>が空ならば、<bpt i="7" x="7">&lt;c7&gt;</bpt>startIndex<ept i="7">&lt;/c7&gt;</ept>と<bpt i="8" x="8">&lt;c8&gt;</bpt>endIndex<ept i="8">&lt;/c8&gt;</ept>は同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a class has a superclass, list the superclass name before any protocols it adopts, followed by a comma:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラスがスーパークラスを持つならば、それが採用するあらゆるプロトコルの前に、コンマに続けてスーパークラス名を列記してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a closure does not specify a parameter list or return type because they can be inferred from context, place the capture list at the very start of the closure, followed by the <bpt i="0" x="0">&lt;c0&gt;</bpt>in<ept i="0">&lt;/c0&gt;</ept> keyword:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャがパラメータ・リストまたは戻り型を、それらが前後関係から推論されることができるために指定しないならば、捕獲リストをクロージャのまさしくその始まりに、<bpt i="0" x="0">&lt;c0&gt;</bpt>in<ept i="0">&lt;/c0&gt;</ept>キーワードに続けて置いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a closure expression is provided as the function or method’s only argument and you provide that expression as a trailing closure, you do not need to write a pair of parentheses <bpt i="0" x="0">&lt;c0&gt;</bpt>()<ept i="0">&lt;/c0&gt;</ept> after the function or method’s name when you call the function:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャ式がただ関数やメソッドの引数としてだけ提供され、そしてあなたが後付クロージャとしてその式を提供するならば、あなたがその関数を呼ぶときに、一対の丸括弧<bpt i="0" x="0">&lt;c0&gt;</bpt>()<ept i="0">&lt;/c0&gt;</ept>を関数やメソッドの名前の後に書く必要はありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a computed property’s setter does not define a name for the new value to be set, a default name of <bpt i="0" x="0">&lt;c0&gt;</bpt>newValue<ept i="0">&lt;/c0&gt;</ept> is used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算プロパティのセッターが設定される新しい値の名前を定義しないならば、省略時の名前の<bpt i="0" x="0">&lt;c0&gt;</bpt>newValue<ept i="0">&lt;/c0&gt;</ept>が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a conforming type provides its own implementation of a required method or property, that implementation will be used instead of the one provided by the extension.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>準拠している型がある必須のメソッドやプロパティのそれ自身の実装を提供する場合は、その実装が拡張によって提供されるものの代わりに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a conforming type satisfies the requirements for multiple constrained extensions that provide implementations for the same method or property, Swift will use the implementation corresponding to the most specialized constraints.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある準拠型が同じメソッドやプロパティに対する実装を提供する複数の制約付き拡張の要件を満たすならば、スウィフトは最も特殊化した制約と一致している実装を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a constant or variable in your code needs to work with the absence of a value under certain conditions, always declare it as an optional value of the appropriate type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコードの中の定数または変数が特定の条件下で値の欠如を取り扱う必要があるならば、常に、それを適切な型のオプショナルの値として宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a constant, variable, property, or subscript makes use of a private type, the constant, variable, property, or subscript must also be marked as <bpt i="0" x="0">&lt;c0&gt;</bpt>private<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数、変数、プロパティ、または添え字が非公開の型を利用するならば、定数、変数、プロパティ、または添え字はまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>private<ept i="0">&lt;/c0&gt;</ept>と印しされなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a default value is defined, you can omit that parameter when calling the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の値が定義されるならば、あなたは関数を呼ぶときそのパラメータを省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a function type has only one parameter and that parameter’s type is a tuple type, then the tuple type must be parenthesized when writing the function’s type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある関数型がただ１つだけのパラメータを持ちそしてそのパラメータの型がタプル型であるならば、その場合そのタプル型は関数の型を記述する時に丸括弧に入れられなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a function type includes more than a single arrow (<bpt i="0" x="0">&lt;c0&gt;</bpt>-&gt;<ept i="0">&lt;/c0&gt;</ept>), the function types are grouped from right to left.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある関数型がただ１つだけの矢印（<bpt i="0" x="0">&lt;c0&gt;</bpt>-&gt;<ept i="0">&lt;/c0&gt;</ept>）ではなくもっと多く含むならば、その関数型は右から左にグループにされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a match is found, one of the <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> statement’s cases sets an optional <bpt i="4" x="4">&lt;c4&gt;</bpt>Int?<ept i="4">&lt;/c4&gt;</ept> variable called <bpt i="5" x="5">&lt;c5&gt;</bpt>possibleIntegerValue<ept i="5">&lt;/c5&gt;</ept> to an appropriate integer value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつの適合が見つけられるならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>文のケース節の一つは、<bpt i="5" x="5">&lt;c5&gt;</bpt>possibleIntegerValue<ept i="5">&lt;/c5&gt;</ept>と呼ばれるあるオプショナルの<bpt i="4" x="4">&lt;c4&gt;</bpt>Int?<ept i="4">&lt;/c4&gt;</ept>変数を適切な整数値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a match is found, the program executes the <bpt i="2" x="2">&lt;e2&gt;</bpt>statements<ept i="2">&lt;/e2&gt;</ept> listed within the scope of that case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>マッチが見つけられるならば、プログラムはそのケース節のスコープ内で列記される<bpt i="2" x="2">&lt;e2&gt;</bpt>文<ept i="2">&lt;/e2&gt;</ept>を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a nonfailable initializer delegates to an <bpt i="2" x="2">&lt;c2&gt;</bpt>init!<ept i="2">&lt;/c2&gt;</ept> failable initializer that fails and returns <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>, then a runtime error is raised (as if you used the <bpt i="4" x="4">&lt;c4&gt;</bpt>!<ept i="4">&lt;/c4&gt;</ept> operator to unwrap an optional that has a <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept> value).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できないイニシャライザが、ある失敗して<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を返す失敗できるイニシャライザ<bpt i="2" x="2">&lt;c2&gt;</bpt>init!<ept i="2">&lt;/c2&gt;</ept>へと委任するならば、その時は実行時エラーが（まるであなたが<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>の値を持つオプショナルをアンラップするために<bpt i="4" x="4">&lt;c4&gt;</bpt>!<ept i="4">&lt;/c4&gt;</ept>演算子を使ったかのように）引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a parameter has an argument label, the argument <bpt i="0" x="0">&lt;e0&gt;</bpt>must<ept i="0">&lt;/e0&gt;</ept> be labeled when you call the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある引数が引数ラベルを持つならば、その引数は、あなたがその関数を呼ぶ時にラベルを付けられる<bpt i="0" x="0">&lt;e0&gt;</bpt>必要があります<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a particular dice roll would take you beyond square 25, you must roll again until you roll the exact number needed to land on square 25.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある特定のさいころを振る回が、正方形25を越えてあなたを連れて行くならば、あなたは正方形25に到着するのに必要な正確な数を出すまで、再びさいころを振らなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a period appears at the beginning of a line, it is understood as part of an explicit member expression, not as an implicit member expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ピリオドがある行の初めに現れたならば、それはある明示的なメンバー式の一部として理解されます、ひとつの明示的なメンバー式としてではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a postfix expression that contains an optional-chaining expression is nested inside other postfix expressions, only the outermost expression returns an optional type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖式を含む接尾辞式が、他の接尾辞式の内部に入れ子にされるならば、最も外部の式だけがオプショナル型を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a property always takes the same initial value, provide a default value rather than setting a value within an initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロパティが常に同じ初期値をとるならば、イニシャライザ内で値を設定することよりむしろ省略時の値を提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a property declaration includes both the <bpt i="0" x="0">&lt;c0&gt;</bpt>get<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>set<ept i="1">&lt;/c1&gt;</ept> keywords, a conforming type can implement it with a stored variable property or a computed property that is both readable and writeable (that is, one that implements both a getter and a setter).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロパティ宣言が<bpt i="0" x="0">&lt;c0&gt;</bpt>get<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>set<ept i="1">&lt;/c1&gt;</ept>キーワードを両方とも含むならば、準拠している型はそれを、保存変数プロパティや計算プロパティを使って実装することができます、それは読み出し可能と書き込み可能の両方であるものです（すなわち、ゲッターとセッターのどちらも実装できるもの）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a property declaration includes only the <bpt i="2" x="2">&lt;c2&gt;</bpt>get<ept i="2">&lt;/c2&gt;</ept> keyword, it can be implemented as any kind of property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティ宣言が<bpt i="2" x="2">&lt;c2&gt;</bpt>get<ept i="2">&lt;/c2&gt;</ept>キーワードだけを含むならば、それはどんな種類のプロパティとしてでも実装されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a property marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>lazy<ept i="0">&lt;/c0&gt;</ept> modifier is accessed by multiple threads simultaneously and the property has not yet been initialized, there is no guarantee that the property will be initialized only once.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>lazy<ept i="0">&lt;/c0&gt;</ept>修飾子で印されるプロパティが複数のスレッドによって同時にアクセスされ、そのプロパティがその時まだ初期化されないならば、そのプロパティがただ一度だけ初期化されるとは保障されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a protocol is marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept> attribute, the <bpt i="1" x="1">&lt;c1&gt;</bpt>AnyObject<ept i="1">&lt;/c1&gt;</ept> requirement is implicitly applied to that protocol; there’s no need to mark the protocol with the <bpt i="2" x="2">&lt;c2&gt;</bpt>AnyObject<ept i="2">&lt;/c2&gt;</ept> requirement explicitly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコルが<bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept>属性で印されるならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>AnyObject<ept i="1">&lt;/c1&gt;</ept>要件は暗黙的にそのプロトコルに適用されます；<bpt i="2" x="2">&lt;c2&gt;</bpt>AnyObject<ept i="2">&lt;/c2&gt;</ept>要件で明示的に印する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a protocol requires a property to be gettable and settable, that property requirement can’t be fulfilled by a constant stored property or a read-only computed property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコルがプロパティに取得可能かつまた設定可能であることを要求するならば、そのプロパティ要件は、定数保存プロパティまたは読み出し専用の計算プロパティによって満たされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a stored property’s default value requires some customization or setup, you can use a closure or global function to provide a customized default value for that property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある保存プロパティの省略時の値が、いくらかの特別な注文または準備を必要とするならば、あなたは特注の省略時の値をそのプロパティのために用意するために、クロージャまたはグローバル関数を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a stored value in your code won’t change, always declare it as a constant with the <bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある保存された値をあなたのコードにおいて変化させる予定がないならば、常に<bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept>キーワードを使ってそれを定数として宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a subclass overrides a designated initializer from a superclass, and also implements a matching initializer requirement from a protocol, mark the initializer implementation with both the <bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>override<ept i="1">&lt;/c1&gt;</ept> modifiers:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるサブクラスが、スーパークラスからの指定イニシャライザをオーバーライドして、またプロトコルからのイニシャライザ要件にも合致するものを実装するならば、そのイニシャライザ実装を<bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>override<ept i="1">&lt;/c1&gt;</ept>の両方の修飾子を使って印してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a subscript returns a value of optional type—such as the key subscript of Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> type—place a question mark <bpt i="1" x="1">&lt;e1&gt;</bpt>after<ept i="1">&lt;/e1&gt;</ept> the subscript’s closing bracket to chain on its optional return value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある添え字がオプショナル型の値を返すならば ― 例えばスウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>型のキー添え字 ― 疑問符をその添え字の閉じ括弧の<bpt i="1" x="1">&lt;e1&gt;</bpt>後ろに<ept i="1">&lt;/e1&gt;</ept>置いて、そのオプショナルの戻り値の上に連鎖を繋げてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a type already conforms to all of the requirements of a protocol, but has not yet stated that it adopts that protocol, you can make it adopt the protocol with an empty extension:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型があるプロトコルの要件の全てにすでに準拠するが、それがそのプロトコルを採用するとまだ示していなかったならば、あなたは空の拡張を使ってそれがそのプロトコルを採用するようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a type is public, but a protocol it conforms to is internal, the type’s conformance to that protocol is also internal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型が公開である、しかしそれが準拠するプロトコルは内部であるならば、そのプロトコルに対する型の準拠もまた内部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a value (known as a “raw” value) <bpt i="0" x="0">&lt;e0&gt;</bpt>is<ept i="0">&lt;/e0&gt;</ept> provided for each enumeration case, the value can be a string, a character, or a value of any integer or floating-point type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値（「生」の値として知られるもの）が列挙のケース節の各々のために提供されて<bpt i="0" x="0">&lt;e0&gt;</bpt>いる<ept i="0">&lt;/e0&gt;</ept>場合には、その値は文字列、文字、またはあらゆる整数または浮動小数点型の値であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If all of the associated values for an enumeration case are extracted as constants, or if all are extracted as variables, you can place a single <bpt i="0" x="0">&lt;c0&gt;</bpt>var<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>let<ept i="1">&lt;/c1&gt;</ept> annotation before the case name, for brevity:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙ケース節の関連値の全てが定数として抽出されるならば、または全てが変数として抽出されるならば、あなたは簡潔に<bpt i="0" x="0">&lt;c0&gt;</bpt>var<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>let<ept i="1">&lt;/c1&gt;</ept>注釈一つだけをケース節名の前に置くことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If all the elements are equal, then the tuples themselves are equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての要素が等しいならば、その時それらのタプル自体が等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an <bpt i="0" x="0">&lt;c0&gt;</bpt>available<ept i="0">&lt;/c0&gt;</ept> attribute only specifies an <bpt i="1" x="1">&lt;c1&gt;</bpt>introduced<ept i="1">&lt;/c1&gt;</ept> argument in addition to a platform or language name argument, the following shorthand syntax can be used instead:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>available<ept i="0">&lt;/c0&gt;</ept>属性がただ１つの<bpt i="1" x="1">&lt;c1&gt;</bpt>introduced<ept i="1">&lt;/c1&gt;</ept>引数をプラットホームまたは言語名引数に加えて指定するならば、以下の略記構文が代わりに利用可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an audio signal comes in with a higher value than <bpt i="4" x="4">&lt;c4&gt;</bpt>10<ept i="4">&lt;/c4&gt;</ept>, it will be capped to this threshold value (as described below).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある音声信号が<bpt i="4" x="4">&lt;c4&gt;</bpt>10<ept i="4">&lt;/c4&gt;</ept>より高い値でやってくるならば、それはこの限界値に制限されます（下記のように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an empty string is found, an initialization failure is triggered.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし空の文字列が見つけられたならば、初期化失敗が引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an enumeration has raw values, those values are determined as part of the declaration, which means every instance of a particular enumeration case always has the same raw value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある列挙が生の値を持つならば、それらの値は宣言の一部として決定されます、それはある特定の列挙ケース節のすべてのインスタンスが常に同じ生の値を持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an error actually is thrown, you’ll get a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーが実際はスローされたならば、あなたは実行時エラーを受け取るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an error is thrown and it matches the <bpt i="1" x="1">&lt;c1&gt;</bpt>SandwichError.outOfCleanDishes<ept i="1">&lt;/c1&gt;</ept> case, then the <bpt i="2" x="2">&lt;c2&gt;</bpt>washDishes()<ept i="2">&lt;/c2&gt;</ept> function will be called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーがスローされてそれが<bpt i="1" x="1">&lt;c1&gt;</bpt>SandwichError.outOfCleanDishes<ept i="1">&lt;/c1&gt;</ept>ケース節にマッチするならば、そのとき<bpt i="2" x="2">&lt;c2&gt;</bpt>washDishes()<ept i="2">&lt;/c2&gt;</ept>関数が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an error is thrown and it matches the <bpt i="3" x="3">&lt;c3&gt;</bpt>SandwichError.missingIngredients<ept i="3">&lt;/c3&gt;</ept> case, then the <bpt i="4" x="4">&lt;c4&gt;</bpt>buyGroceries(_:)<ept i="4">&lt;/c4&gt;</ept> function is called with the associated <bpt i="5" x="5">&lt;c5&gt;</bpt>[String]<ept i="5">&lt;/c5&gt;</ept> value captured by the <bpt i="6" x="6">&lt;c6&gt;</bpt>catch<ept i="6">&lt;/c6&gt;</ept> pattern.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーがスローされてそれが<bpt i="3" x="3">&lt;c3&gt;</bpt>SandwichError.missingIngredients<ept i="3">&lt;/c3&gt;</ept>ケース節にマッチするならば、そのとき<bpt i="4" x="4">&lt;c4&gt;</bpt>buyGroceries(_:)<ept i="4">&lt;/c4&gt;</ept>関数がその<bpt i="6" x="6">&lt;c6&gt;</bpt>catch<ept i="6">&lt;/c6&gt;</ept>パターンによってキャプチャされた<bpt i="5" x="5">&lt;c5&gt;</bpt>[String]<ept i="5">&lt;/c5&gt;</ept>関連値とともに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an error is thrown by the code in the <bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept> clause, it is matched against the <bpt i="3" x="3">&lt;c3&gt;</bpt>catch<ept i="3">&lt;/c3&gt;</ept> clauses to determine which one of them can handle the error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるエラーが<bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept>節の中にあるコードによってスローされるならば、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>catch<ept i="3">&lt;/c3&gt;</ept>節と照合されて、それらの１つがそのエラーを処理できると決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an error is thrown while evaluating the <bpt i="1" x="1">&lt;c1&gt;</bpt>try?<ept i="1">&lt;/c1&gt;</ept> expression, the value of the expression is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>try?<ept i="1">&lt;/c1&gt;</ept>式を評価している間にエラーがスローされたならば、式の値は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an error is thrown, execution immediately transfers to the <bpt i="2" x="2">&lt;c2&gt;</bpt>catch<ept i="2">&lt;/c2&gt;</ept> clauses, which decide whether to allow propagation to continue.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーがスローされるならば、実行は直ちに<bpt i="2" x="2">&lt;c2&gt;</bpt>catch<ept i="2">&lt;/c2&gt;</ept>節に移ります、それは伝達を継続させるかどうか結論を下します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an implicitly unwrapped optional is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> and you try to access its wrapped value, you’ll trigger a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的にアンラップされるオプショナルが<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>であり、あなたがそれのラップされた値にアクセスしようとするならば、あなたは実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an instance of an optional type contains a value, you can access that value using the postfix operator <bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept>, as shown below:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル型のインスタンスが値を含むならば、あなたが接尾辞演算子<bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept>を使用してその値にアクセスすることができます、以下に示すように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an instance of the extended type satisfies the <bpt i="1" x="1">&lt;e1&gt;</bpt>requirements<ept i="1">&lt;/e1&gt;</ept>, the instance gains the behavior specified in the declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張された型のインスタンスが<bpt i="1" x="1">&lt;e1&gt;</bpt>requirements<ept i="1">&lt;/e1&gt;</ept>を満たすならば、そのインスタンスはその宣言の中で指定される挙動を獲得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an operator doesn’t begin with a dot, it can’t contain a dot elsewhere.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある演算子がドットで始まらないならば、それはどこか他にドットを含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an operator has no whitespace on the left but is followed immediately by a dot (<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>), it’s treated as a postfix unary operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある演算子が左側では空白を持たないが直ちに続けて１つのドット（<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>）を持つならば、それは接尾辞単項演算子と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an operator has whitespace around both sides or around neither side, it’s treated as a binary operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある演算子が、空白をそのまわりの両側に持つか、そのまわりのどちら側にも持たないならば、それは二項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an operator has whitespace on the left side only, it’s treated as a prefix unary operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある演算子が左側だけで空白を持つならば、それは接頭辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an operator has whitespace on the right side only, it’s treated as a postfix unary operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある演算子が右側だけで空白を持つならば、それは接尾辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an optional has a value, it’s considered to be “not equal to” <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるオプショナルが値を持つならば、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>と「同等でない」と判断されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If any of the patterns match, then the case is considered to match.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらのパターンのどれかが合致するならば、そのときそのケース節は合致するとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If any of the values in the optional bindings are <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> or any Boolean condition evaluates to <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>, the whole <bpt i="3" x="3">&lt;c3&gt;</bpt>if<ept i="3">&lt;/c3&gt;</ept> statement’s condition is considered to be <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何れかのオプショナル束縛の中の値が<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>であるか何かのブール条件の評価が<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>になるならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>if<ept i="3">&lt;/c3&gt;</ept>文の条件の全体が<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>であるとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If casting to the specified <bpt i="7" x="7">&lt;e7&gt;</bpt>type<ept i="7">&lt;/e7&gt;</ept> is guaranteed to fail or is guaranteed to succeed, a compile-time error is raised.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定された<bpt i="7" x="7">&lt;e7&gt;</bpt>型<ept i="7">&lt;/e7&gt;</ept>へのキャストが失敗すると保証されるまたは成功すると保証される場合には、コンパイル時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If either value is <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>, the overall expression will also be <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どちらかの値が<bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>ならば、全体的な式もまた<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If it doesn’t, the new value the convenience initializer assigns will be overwritten by its own class’s designated initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それがそうしないならば、便宜イニシャライザが代入する新しい値は、それ自身のクラスの指定イニシャライザによって上書きされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If it doesn’t, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それがそうしないならば、指定イニシャライザが代入する新しい値は、スーパークラスによってそれ自身の初期化の一部として上書きされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If it is, a message is printed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしそうならば、メッセージが出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If it’s <bpt i="0" x="0">&lt;e0&gt;</bpt>not<ept i="0">&lt;/e0&gt;</ept> possible to retrieve a value from the <bpt i="1" x="1">&lt;c1&gt;</bpt>increment(forCount:)<ept i="1">&lt;/c1&gt;</ept> method—either because <bpt i="2" x="2">&lt;c2&gt;</bpt>dataSource<ept i="2">&lt;/c2&gt;</ept> is nil, or because the data source doesn’t implement <bpt i="3" x="3">&lt;c3&gt;</bpt>increment(forCount:)<ept i="3">&lt;/c3&gt;</ept>—then the <bpt i="4" x="4">&lt;c4&gt;</bpt>increment()<ept i="4">&lt;/c4&gt;</ept> method tries to retrieve a value from the data source’s <bpt i="5" x="5">&lt;c5&gt;</bpt>fixedIncrement<ept i="5">&lt;/c5&gt;</ept> property instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値を<bpt i="1" x="1">&lt;c1&gt;</bpt>increment(forCount:)<ept i="1">&lt;/c1&gt;</ept>メソッドから取り出すことが可能で<bpt i="0" x="0">&lt;e0&gt;</bpt>ない<ept i="0">&lt;/e0&gt;</ept>ならば ― <bpt i="2" x="2">&lt;c2&gt;</bpt>dataSource<ept i="2">&lt;/c2&gt;</ept>がnilであるから、またはデータ・ソースが<bpt i="3" x="3">&lt;c3&gt;</bpt>increment(forCount:)<ept i="3">&lt;/c3&gt;</ept>を実装しないからのどちらでも ― その時<bpt i="4" x="4">&lt;c4&gt;</bpt>increment()<ept i="4">&lt;/c4&gt;</ept>メソッドはその代わりに値をデータ・ソースの<bpt i="5" x="5">&lt;c5&gt;</bpt>fixedIncrement<ept i="5">&lt;/c5&gt;</ept>プロパティから取り出そうとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If it’s not appropriate to provide a case for every possible value, you can define a default case to cover any values that are not addressed explicitly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべてのあり得る値に対してひとつのケース節を用意することが妥当でないならば、あなたはdefault（省略時）ケース節を定義することで、明確に言及されないどんな値にも対応できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If multiple <bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept> statements appear in the same scope, the order they appear is the reverse of the order they are executed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数の<bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept>文が同じスコープに現れるならば、それらが現れる順番が、それらが実行される順番の逆です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If no error is thrown, the <bpt i="0" x="0">&lt;c0&gt;</bpt>eatASandwich()<ept i="0">&lt;/c0&gt;</ept> function is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーがスローされないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>eatASandwich()<ept i="0">&lt;/c0&gt;</ept>関数が呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If no error is thrown, the remaining statements in the <bpt i="3" x="3">&lt;c3&gt;</bpt>do<ept i="3">&lt;/c3&gt;</ept> statement are executed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーかスローされないならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>do<ept i="3">&lt;/c3&gt;</ept>の中の残っている文が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If no initializers are declared, and all properties of the class declaration were given initial values, call the class’s default initializer, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Default Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザが宣言されない、そして全てのクラス宣言のプロパティが初期値を与えられるならば、クラスの省略時のイニシャライザを呼び出す、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>省略時のイニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If no initializers are declared, and all properties of the structure declaration were given initial values, call the structure’s default initializer, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Default Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザが宣言されない、そしてその構造体宣言の全てのプロパティが初期値を与えられたならば、構造体の省略時のイニシャライザを呼び出す、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>省略時のイニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If no initializers are declared, call the structure’s memberwise initializer, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Memberwise Initializers for Structure Types<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザが宣言されないならば、その構造体のメンバー関連イニシャライザ呼び出す、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>構造型のためのメンバー関連イニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If none of the <bpt i="2" x="2">&lt;c2&gt;</bpt>catch<ept i="2">&lt;/c2&gt;</ept> clauses handle the error, the error propagates to the surrounding scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どの<bpt i="2" x="2">&lt;c2&gt;</bpt>catch<ept i="2">&lt;/c2&gt;</ept>節もエラーを処理しないならば、エラーは取り囲んでいるスコープへと伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If part of your code requires a <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>, type safety prevents you from passing it an <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> by mistake.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコードの一部が<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>を要求するならば、型安全はあなたが間違ってそれに<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>を渡すことを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If part of your code requires a <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>, you can’t pass it an <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> by mistake.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコードの一部が<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>を要求するならば、あなたは誤ってそれに<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>を渡すことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If such a determination can be made, the error is considered handled.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのような決定が為されるならば、エラーは処理されたと判断されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If that condition is not met, the code inside the <bpt i="0" x="0">&lt;c0&gt;</bpt>else<ept i="0">&lt;/c0&gt;</ept> branch is executed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その条件が満たされないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>else<ept i="0">&lt;/c0&gt;</ept>分岐の内部のコードが実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>?<ept i="1">&lt;/c1&gt;</ept> predefined operator has no whitespace on the left, it’s treated as a postfix operator, regardless of whether it has whitespace on the right.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あらかじめ定義された演算子<bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>?<ept i="1">&lt;/c1&gt;</ept>が左側に空白を持たないならば、それは接尾辞演算子と見なされます、それが右側に空白を持つかどうかに関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> value does not have enough digits for the requested index, the subscript implementation returns <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>, as if the number had been padded with zeros to the left:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>値には要十分な桁が請されたインデックスに対してないならば、この添え字実装は、まるで数が左にゼロを詰められたように<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept> statement above did not use the <bpt i="1" x="1">&lt;c1&gt;</bpt>gameLoop<ept i="1">&lt;/c1&gt;</ept> label, it would break out of the <bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept> statement, not the <bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>文が<bpt i="1" x="1">&lt;c1&gt;</bpt>gameLoop<ept i="1">&lt;/c1&gt;</ept>ラベルを使用しないならば、それは、<bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept>文ではなく、<bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept>文から抜け出すでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept> statement’s condition is met, code execution continues after the <bpt i="1" x="1">&lt;c1&gt;</bpt>guard<ept i="1">&lt;/c1&gt;</ept> statement’s closing brace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept>文の条件が満たされるならば、コード実行は<bpt i="1" x="1">&lt;c1&gt;</bpt>guard<ept i="1">&lt;/c1&gt;</ept>文の閉じ中括弧の後に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="2" x="2">&lt;c2&gt;</bpt>array<ept i="2">&lt;/c2&gt;</ept> argument contains an empty array, the <bpt i="3" x="3">&lt;c3&gt;</bpt>minMax(array:)<ept i="3">&lt;/c3&gt;</ept> function, as defined above, will trigger a runtime error when attempting to access <bpt i="4" x="4">&lt;c4&gt;</bpt>array[0]<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>array<ept i="2">&lt;/c2&gt;</ept>引数が空の配列を含んでいるならば、上で定義される<bpt i="3" x="3">&lt;c3&gt;</bpt>minMax(array:)<ept i="3">&lt;/c3&gt;</ept>関数は、<bpt i="4" x="4">&lt;c4&gt;</bpt>array[0]<ept i="4">&lt;/c4&gt;</ept>にアクセスしようとする時に実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="3" x="3">&lt;c3&gt;</bpt>case<ept i="3">&lt;/c3&gt;</ept> for <bpt i="4" x="4">&lt;c4&gt;</bpt>.west<ept i="4">&lt;/c4&gt;</ept> is omitted, this code does not compile, because it does not consider the complete list of <bpt i="5" x="5">&lt;c5&gt;</bpt>CompassPoint<ept i="5">&lt;/c5&gt;</ept> cases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>.west<ept i="4">&lt;/c4&gt;</ept>のための<bpt i="3" x="3">&lt;c3&gt;</bpt>case<ept i="3">&lt;/c3&gt;</ept>が省略されるならば、このコードはコンパイルしません、なぜなら、それが<bpt i="5" x="5">&lt;c5&gt;</bpt>CompassPoint<ept i="5">&lt;/c5&gt;</ept>のケース節の完全なリストを考慮しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="3" x="3">&lt;c3&gt;</bpt>quantity<ept i="3">&lt;/c3&gt;</ept> is invalid, the entire initialization process fails immediately and no further initialization code is executed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>quantity<ept i="3">&lt;/c3&gt;</ept>が無効ならば、初期化処理全体が直ちに失敗して、以降の初期化コードは実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="4" x="4">&lt;c4&gt;</bpt>delegate<ept i="4">&lt;/c4&gt;</ept> property is nil, these delegate calls fail gracefully and without error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>delegate<ept i="4">&lt;/c4&gt;</ept>プロパティがnilならば、これらの委任先呼び出しはエラーなしで美しく失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="5" x="5">&lt;c5&gt;</bpt>delegate<ept i="5">&lt;/c5&gt;</ept> property is non-nil, the delegate methods are called, and are passed the <bpt i="6" x="6">&lt;c6&gt;</bpt>SnakesAndLadders<ept i="6">&lt;/c6&gt;</ept> instance as a parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>delegate<ept i="5">&lt;/c5&gt;</ept>プロパティがnilでないならば、委任先のさまざまなメソッドが呼ばれます、そしてパラメータとして<bpt i="6" x="6">&lt;c6&gt;</bpt>SnakesAndLadders<ept i="6">&lt;/c6&gt;</ept>インスタンスを渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;e0&gt;</bpt>condition<ept i="0">&lt;/e0&gt;</ept> evaluates to <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>, the conditional operator evaluates the first expression and returns its value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>条件<ept i="0">&lt;/e0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>に評価されるならば、条件演算子は最初の式を評価して、その値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;e0&gt;</bpt>constant name<ept i="0">&lt;/e0&gt;</ept> of a constant declaration is a tuple pattern, the name of each item in the tuple is bound to the corresponding value in the initializer <bpt i="1" x="1">&lt;e1&gt;</bpt>expression<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数宣言の<bpt i="0" x="0">&lt;e0&gt;</bpt>定数名<ept i="0">&lt;/e0&gt;</ept>がタプルパターンであるならば、タプルの中の各項目の名前は、イニシャライザ<bpt i="1" x="1">&lt;e1&gt;</bpt>式<ept i="1">&lt;/e1&gt;</ept>の中の対応する値に縛りつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;e0&gt;</bpt>expression<ept i="0">&lt;/e0&gt;</ept> does not throw an error, the value of the optional-try expression is an optional containing the value of the <bpt i="1" x="1">&lt;e1&gt;</bpt>expression<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;e0&gt;</bpt>expression（式）<ept i="0">&lt;/e0&gt;</ept>がエラーをスローしないならば、オプショナルtry式の値はひとつのオプショナルになり、その<bpt i="1" x="1">&lt;e1&gt;</bpt>expression（式）<ept i="1">&lt;/e1&gt;</ept>の値を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;e0&gt;</bpt>expression<ept i="0">&lt;/e0&gt;</ept> throws an error, a runtime error is produced.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;e0&gt;</bpt>expression（式）<ept i="0">&lt;/e0&gt;</ept>がエラーをスローするならば、実行時エラーが生み出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="0" x="0">&lt;e0&gt;</bpt>type name<ept i="0">&lt;/e0&gt;</ept> is a class, structure, or enumeration type, the extension extends that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>type name<ept i="0">&lt;/e0&gt;</ept>がクラス、構造体、または列挙型ならば、その拡張はその型を拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="1" x="1">&lt;e1&gt;</bpt>type name<ept i="1">&lt;/e1&gt;</ept> is a protocol type, the extension extends all types that conform to that protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;e1&gt;</bpt>type name<ept i="1">&lt;/e1&gt;</ept>がプロトコル型ならば、その拡張はそのプロトコルに準拠するすべての型を拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the <bpt i="2" x="2">&lt;e2&gt;</bpt>expression<ept i="2">&lt;/e2&gt;</ept> is a tuple, the <bpt i="3" x="3">&lt;e3&gt;</bpt>value<ept i="3">&lt;/e3&gt;</ept> must be a tuple with the same number of elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;e2&gt;</bpt>式<ept i="2">&lt;/e2&gt;</ept>がタプルであるならば、<bpt i="3" x="3">&lt;e3&gt;</bpt>値<ept i="3">&lt;/e3&gt;</ept>は同じ数の要素をもつタプルでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the Boolean condition in the assertion or precondition evaluates to <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>, code execution continues as usual.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>表明または前提条件におけるブール条件が<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>に評価されるならば、コードは普段通り続けて実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the captured reference will never become <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>, it should always be captured as an unowned reference, rather than a weak reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>捕獲された参照が決して<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>にならないならば、それは常に、非所有者参照として捕らえられなければなりません、弱い参照ではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the case contains multiple patterns that match the control expression, all of the patterns must contain the same constant or variable bindings, and each bound variable or constant must have the same type in all of the case’s patterns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>制御式にマッチする複数のパターンをケース節が含むならば、そのパターンのすべてが同じ定数または変数束縛を含まなければなりません、そして束縛された変数または定数の各々は、そのケース節の持つパターンのすべてで同じ型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the cast fails, a runtime error is raised.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キャストが失敗したならば、実行時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the class doesn’t inherit from another class, the list can begin with a protocol instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスが別のクラスから継承しないならば、このリストは代わりにプロトコルで始まることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the class inherits any properties from its superclass, one of the superclass’s designated initializers must be called before any of these properties can be set or modified in the current class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスが何らかのプロパティをそのスーパークラスから受け継ぐならば、これらのプロパティのどれかが現在のクラスにおいて設定または修正されることができる前に、スーパークラスの指定イニシャライザのうちの１つが呼ばれなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the closure is never called, the expression inside the closure is never evaluated, which means the array element is never removed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このクロージャが決して呼び出されないならば、クロージャ内部の式は決して評価されません、それは配列要素が決して取り除かれないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the code already checks the condition, you use the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>assertionFailure(_:file:line:)<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function to indicate that an assertion has failed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コードがすでに条件を調べるならば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>assertionFailure(_:file:line:)<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を使って表明が失敗していることを示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the condition evaluates to <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>, the current state of the program is invalid; code execution ends, and your app is terminated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>条件が<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>に評価されるならば、プログラムの現在の状態は無効です；コード実行は止まり、そしてあなたのアプリは終了させられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the condition is <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>, a set of statements is repeated until the condition becomes <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その条件が<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>ならば、条件が<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>になるまで、ひとかたまりの文が繰り返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the context already provides type information, you can create an empty dictionary with an empty dictionary literal, which is written as <bpt i="0" x="0">&lt;c0&gt;</bpt>[:]<ept i="0">&lt;/c0&gt;</ept> (a colon inside a pair of square brackets):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前後関係がすでに型の情報を提供するならば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>[:]<ept i="0">&lt;/c0&gt;</ept>（一対の角括弧の内側のひとつのコロン）として書かれる空の辞書リテラルを使って、空の辞書を作成することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the conversion is successful, the <bpt i="0" x="0">&lt;c0&gt;</bpt>actualNumber<ept i="0">&lt;/c0&gt;</ept> constant becomes available for use within the first branch of the <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変換が成功しているならば、定数<bpt i="0" x="0">&lt;c0&gt;</bpt>actualNumber<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>文の最初の分岐の内部での利用に役立てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the dice roll will move the player <bpt i="0" x="0">&lt;e0&gt;</bpt>beyond<ept i="0">&lt;/e0&gt;</ept> the final square, the move is invalid and the player needs to roll again.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さいころの目が最後の正方形を<bpt i="0" x="0">&lt;e0&gt;</bpt>越えて<ept i="0">&lt;/e0&gt;</ept>プレーヤーを動かすならば、その移動は無効です、そしてプレーヤーは再びさいころを振る必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the dice roll will move the player onto the final square, the game is over.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さいころの目が最後の正方形の上へプレーヤーを動かすならば、ゲームは終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the dictionary contains a value for the requested key, the subscript returns an optional value containing the existing value for that key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その辞書が要請されたキーに対する値を含むならば、添え字はそのキーに対する既存の値を含んでいるオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the downcasting succeeds, the properties of <bpt i="0" x="0">&lt;c0&gt;</bpt>movie<ept i="0">&lt;/c0&gt;</ept> are then used to print a description for that <bpt i="1" x="1">&lt;c1&gt;</bpt>Movie<ept i="1">&lt;/c1&gt;</ept> instance, including the name of its <bpt i="2" x="2">&lt;c2&gt;</bpt>director<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ダウンキャストが成功するならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>movie<ept i="0">&lt;/c0&gt;</ept>のプロパティがそれから使用されて、その<bpt i="1" x="1">&lt;c1&gt;</bpt>Movie<ept i="1">&lt;/c1&gt;</ept>インスタンスの、それの<bpt i="2" x="2">&lt;c2&gt;</bpt>director<ept i="2">&lt;/c2&gt;</ept>（監督）の名前を含む説明を出力することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the enumeration case you’re trying to match has any associated values, the corresponding enumeration case pattern must specify a tuple pattern that contains one element for each associated value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがマッチしようとしている列挙ケース節が関連値を持つならば、対応する列挙ケース節パターンは、各関連値に対して１つの要素を含んでいるタプルパターンを指定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the first case doesn’t have a value set, its value is <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初のケース節が値を設定されないならば、それの値は<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the first string (<bpt i="0" x="0">&lt;c0&gt;</bpt>s1<ept i="0">&lt;/c0&gt;</ept>) is greater than the second string (<bpt i="1" x="1">&lt;c1&gt;</bpt>s2<ept i="1">&lt;/c1&gt;</ept>), the <bpt i="2" x="2">&lt;c2&gt;</bpt>backward(_:_:)<ept i="2">&lt;/c2&gt;</ept> function will return <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>, indicating that <bpt i="4" x="4">&lt;c4&gt;</bpt>s1<ept i="4">&lt;/c4&gt;</ept> should appear before <bpt i="5" x="5">&lt;c5&gt;</bpt>s2<ept i="5">&lt;/c5&gt;</ept> in the sorted array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の文字列（<bpt i="0" x="0">&lt;c0&gt;</bpt>s1<ept i="0">&lt;/c0&gt;</ept>）が第二の文字列（<bpt i="1" x="1">&lt;c1&gt;</bpt>s2<ept i="1">&lt;/c1&gt;</ept>）より大きいならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>backward(_:_:)<ept i="2">&lt;/c2&gt;</ept>関数は、ソートされた配列において<bpt i="4" x="4">&lt;c4&gt;</bpt>s1<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>s2<ept i="5">&lt;/c5&gt;</ept>の前に現れなければならないことを示す、<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the function definition includes names for its parameters, the function call must include names before its argument values separated by a colon (<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数定義がそれのパラメータたちの名前を含むならば、関数呼び出しはそれらの引数値の前にその名前をコロン（<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>）で区切って含まなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the function has a return type of <bpt i="0" x="0">&lt;c0&gt;</bpt>Void<ept i="0">&lt;/c0&gt;</ept>, the return type can be omitted as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数が<bpt i="0" x="0">&lt;c0&gt;</bpt>Void<ept i="0">&lt;/c0&gt;</ept>の戻り型を持つならば、次のように戻り型は省略されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the function specifies a return type, you write the <bpt i="3" x="3">&lt;c3&gt;</bpt>throws<ept i="3">&lt;/c3&gt;</ept> keyword before the return arrow (<bpt i="4" x="4">&lt;c4&gt;</bpt>-&gt;<ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その関数が戻り型を指定するならば、あなたは<bpt i="3" x="3">&lt;c3&gt;</bpt>throws<ept i="3">&lt;/c3&gt;</ept>キーワードを戻り矢印（<bpt i="4" x="4">&lt;c4&gt;</bpt>-&gt;<ept i="4">&lt;/c4&gt;</ept>）の前に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the function throws an error, the specific error is discarded and the result is <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数がエラーをスローするならば、その具体的なエラーは廃棄されます、そしてその結果は<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the initial value doesn’t provide enough information (or if there is no initial value), specify the type by writing it after the variable, separated by a colon.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の値が十分な情報を提供しないならば（または最初の値がないならば）、変数の後にコロンで区切ってそれを書くことによって型を指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the left side of a Logical OR expression is <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>, the right side is not evaluated, because it can’t change the outcome of the overall expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理和式の左側が<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>ならば、右側は評価されません、なぜならそれが式全体の結論を変えることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the loop finishes without finding a mismatch, the two containers match, and the function returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループが一致しない組合せを見つけることなく終わるならば、２つのコンテナは合致します、そして関数は<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the match succeeds, the type of the matched value is cast to the <bpt i="2" x="2">&lt;e2&gt;</bpt>pattern<ept i="2">&lt;/e2&gt;</ept> specified in the right-hand side of the <bpt i="3" x="3">&lt;c3&gt;</bpt>as<ept i="3">&lt;/c3&gt;</ept> pattern.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>マッチが成功するならば、マッチされた値の型は、<bpt i="3" x="3">&lt;c3&gt;</bpt>as<ept i="3">&lt;/c3&gt;</ept>パターンの右手側で指定される<bpt i="2" x="2">&lt;e2&gt;</bpt>パターン<ept i="2">&lt;/e2&gt;</ept>にキャストされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the new value of <bpt i="0" x="0">&lt;c0&gt;</bpt>currentLevel<ept i="0">&lt;/c0&gt;</ept> (after any capping) is higher than any value previously received by <bpt i="1" x="1">&lt;e1&gt;</bpt>any<ept i="1">&lt;/e1&gt;</ept> <bpt i="2" x="2">&lt;c2&gt;</bpt>AudioChannel<ept i="2">&lt;/c2&gt;</ept> instance, the property observer stores the new <bpt i="3" x="3">&lt;c3&gt;</bpt>currentLevel<ept i="3">&lt;/c3&gt;</ept> value in the <bpt i="4" x="4">&lt;c4&gt;</bpt>maxInputLevelForAllChannels<ept i="4">&lt;/c4&gt;</ept> type property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>currentLevel<ept i="0">&lt;/c0&gt;</ept>の新しい値が（制限を受けた後に）<bpt i="1" x="1">&lt;e1&gt;</bpt>あらゆる<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>AudioChannel<ept i="2">&lt;/c2&gt;</ept>インスタンスで以前に受けた値より高いならば、プロパティオブザーバーは、新しい<bpt i="3" x="3">&lt;c3&gt;</bpt>currentLevel<ept i="3">&lt;/c3&gt;</ept>値を型プロパティ<bpt i="4" x="4">&lt;c4&gt;</bpt>maxInputLevelForAllChannels<ept i="4">&lt;/c4&gt;</ept>に保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the new value of <bpt i="0" x="0">&lt;c0&gt;</bpt>currentLevel<ept i="0">&lt;/c0&gt;</ept> is greater than the allowed <bpt i="1" x="1">&lt;c1&gt;</bpt>thresholdLevel<ept i="1">&lt;/c1&gt;</ept>, the property observer caps <bpt i="2" x="2">&lt;c2&gt;</bpt>currentLevel<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>thresholdLevel<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>currentLevel<ept i="0">&lt;/c0&gt;</ept>の新しい値が許可された<bpt i="1" x="1">&lt;c1&gt;</bpt>thresholdLevel<ept i="1">&lt;/c1&gt;</ept>より大きいならば、このプロパティオブザーバーは<bpt i="2" x="2">&lt;c2&gt;</bpt>currentLevel<ept i="2">&lt;/c2&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt>thresholdLevel<ept i="3">&lt;/c3&gt;</ept>に制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the omitted types can’t be inferred, a compile-time error is raised.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略された型が推論されることができないならば、コンパイル時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the optional <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> does contain a value—that is, if the delegate and method both exist, and the method returned a value—the unwrapped <bpt i="4" x="4">&lt;c4&gt;</bpt>amount<ept i="4">&lt;/c4&gt;</ept> is added onto the stored <bpt i="5" x="5">&lt;c5&gt;</bpt>count<ept i="5">&lt;/c5&gt;</ept> property, and incrementation is complete.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>が値を含むならば ― すなわち、委任先とメソッドが両方とも存在する、そしてメソッドが値を返すならば ― アンラップされた<bpt i="4" x="4">&lt;c4&gt;</bpt>amount<ept i="4">&lt;/c4&gt;</ept>が保存<bpt i="5" x="5">&lt;c5&gt;</bpt>count<ept i="5">&lt;/c5&gt;</ept>プロパティへと加えられます、そして増加作業は完了です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the optional contains a value, the property, method, or subscript call succeeds; if the optional is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>, the property, method, or subscript call returns <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのオプショナルが値を含むならば、プロパティ、メソッド、または添え字の呼び出しは成功します；そのオプショナルが<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>であるならば、プロパティ、メソッド、または添え字の呼び出しは<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the optional value is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>, the conditional is <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> and the code in braces is skipped.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの値が<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>ならば、この条件文は<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>になります、そして波括弧の中のコードはスキップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the optional value is missing, the default value is used instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル値が見つからないならば、省略時の値が代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the parameter is omitted when calling the function, the default value is used instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメーターが関数呼び出し時に省略されるならば、省略時の値が代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the player has moved on or beyond square number <bpt i="1" x="1">&lt;c1&gt;</bpt>25<ept i="1">&lt;/c1&gt;</ept>, the loop’s condition evaluates to <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept> and the game ends.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレーヤーが<bpt i="1" x="1">&lt;c1&gt;</bpt>25<ept i="1">&lt;/c1&gt;</ept>番目の正方形の上にまたは越えて移動したならば、ループの条件は<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>に評価してゲームは終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the protocol only requires a property to be gettable, the requirement can be satisfied by any kind of property, and it’s valid for the property to be also settable if this is useful for your own code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルがプロパティに取得可能であるのを要求するだけならば、その要件はどんなプロパティにでもよって満たされることができます、そして、同時にまた設定可能でもあることは、もしそれがあなた自身のコードに役立つ場合には、そのプロパティにとって有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the raw-value type is specified as <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> and you don’t assign a value to the cases explicitly, they are implicitly assigned the values <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>2<ept i="3">&lt;/c3&gt;</ept>, and so on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もし生の値型が<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>として指定され、あなたが明示的に値をそれぞれのケース節に割り当てないならば、それらは暗黙のうちに値<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>2<ept i="3">&lt;/c3&gt;</ept>、等々を割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the raw-value type is specified as <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> and you don’t assign values to the cases explicitly, each unassigned case is implicitly assigned a string with the same text as the name of that case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「生の値」型が<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>として指定されてあなたが明示的に値をそのケース節に割り当てないならば、未割り当てのケース節のそれぞれは暗黙的にそのケース節の名前である同じテキストをもつ文字列を割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the right side of the assignment is a tuple with multiple values, its elements can be decomposed into multiple constants or variables at once:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代入の右側が、複数の値をもつタプルであるならば、その要素は同時に複数の定数または変数に分解されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the specified key isn’t contained in the dictionary, the subscript returns <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定されたキーがその辞書に含まれないならば、添え字は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the square’s value is greater than <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>, it’s the base of a ladder, and is represented by <bpt i="1" x="1">&lt;c1&gt;</bpt>▲<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正方形の値が<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>より大きいならば、それははしごの基部であって、<bpt i="1" x="1">&lt;c1&gt;</bpt>▲<ept i="1">&lt;/c1&gt;</ept>によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the square’s value is less than <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>, it’s the head of a snake, and is represented by <bpt i="1" x="1">&lt;c1&gt;</bpt>▼<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正方形の値が<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>より小さいならば、それはヘビの頭であって、<bpt i="1" x="1">&lt;c1&gt;</bpt>▼<ept i="1">&lt;/c1&gt;</ept>によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the stack is empty, <bpt i="2" x="2">&lt;c2&gt;</bpt>topItem<ept i="2">&lt;/c2&gt;</ept> returns <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>; if the stack isn’t empty, <bpt i="4" x="4">&lt;c4&gt;</bpt>topItem<ept i="4">&lt;/c4&gt;</ept> returns the final item in the <bpt i="5" x="5">&lt;c5&gt;</bpt>items<ept i="5">&lt;/c5&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スタックが空ならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>topItem<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を返します；スタックが空でないならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>topItem<ept i="4">&lt;/c4&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>items<ept i="5">&lt;/c5&gt;</ept>配列の最後の項目を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the subclass overrides all of the superclass’s designated initializers, it inherits the superclass’s convenience initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブクラスがスーパークラスの指定イニシャライザのすべてをオーバーライドするならば、それはスーパークラスの便宜イニシャライザたちを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the subscript declaration includes both the <bpt i="0" x="0">&lt;c0&gt;</bpt>get<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>set<ept i="1">&lt;/c1&gt;</ept> keywords, a conforming type must implement both a getter and a setter clause.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字宣言が<bpt i="0" x="0">&lt;c0&gt;</bpt>get<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>set<ept i="1">&lt;/c1&gt;</ept>キーワードを両方とも含むならば、準拠している型はゲッターとセッター節を両方とも実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the subscript declaration includes only the <bpt i="2" x="2">&lt;c2&gt;</bpt>get<ept i="2">&lt;/c2&gt;</ept> keyword, a conforming type must implement <bpt i="3" x="3">&lt;e3&gt;</bpt>at least<ept i="3">&lt;/e3&gt;</ept> a getter clause and optionally can implement a setter clause.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字宣言が<bpt i="2" x="2">&lt;c2&gt;</bpt>get<ept i="2">&lt;/c2&gt;</ept>キーワードだけを含むならば、準拠している型は、<bpt i="3" x="3">&lt;e3&gt;</bpt>少なくとも<ept i="3">&lt;/e3&gt;</ept>ゲッター節を実装しなければなりません、そして随意にセッター節を実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the total number of steps has increased, a message is printed to indicate how many new steps have been taken.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総歩数が増加したならば、どれくらいの新たな歩数がとられたかについて示すためにメッセージが出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the trailing closure is the function’s only argument, the parentheses can be omitted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後付クロージャが関数のただ一つの引数であるならば、括弧は省略されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the tuple type to be returned from a function has the potential to have “no value” for the entire tuple, you can use an <bpt i="0" x="0">&lt;e0&gt;</bpt>optional<ept i="0">&lt;/e0&gt;</ept> tuple return type to reflect the fact that the entire tuple can be <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある関数から返されるタプル型がタプル全体として「値がない」見込みがあるならば、あなたはタプル全体が<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>であることが出来るのを反映するために<bpt i="0" x="0">&lt;e0&gt;</bpt>オプショナル<ept i="0">&lt;/e0&gt;</ept>タプルの戻り型を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the two items aren’t equal, then the two containers don’t match, and the function returns <bpt i="6" x="6">&lt;c6&gt;</bpt>false<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの項目が等しくないならば、２つのコンテナは合致しません、そして関数は<bpt i="6" x="6">&lt;c6&gt;</bpt>false<ept i="6">&lt;/c6&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the type already implements all of the requirements, you can leave the body of the extension declaration empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その型が要件の全てをすでに実装するならば、あなたは拡張宣言の本文を空のままにしておいてかまいません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the type conversion cannot maintain the value, the initializer fails.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型変換が値を維持できないならば、イニシャライザは失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the type of the expression’s value is a class, you can mark the expression in a capture list with <bpt i="0" x="0">&lt;c0&gt;</bpt>weak<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>unowned<ept i="1">&lt;/c1&gt;</ept> to capture a weak or unowned reference to the expression’s value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この式の値の型がクラスならば、あなたはその式をキャプチャリストの中で<bpt i="0" x="0">&lt;c0&gt;</bpt>weak<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>unowned<ept i="1">&lt;/c1&gt;</ept>を使って印を付けて、式の値に対する弱いまたは非所有の参照をキャプチャすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the type they extend is also in the same file, they share the type’s access-control scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらが拡張した型もまた同じファイルにあるならば、それらはその型のもつアクセス制御スコープを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the type you are trying to retrieve is <bpt i="0" x="0">&lt;e0&gt;</bpt>already<ept i="0">&lt;/e0&gt;</ept> optional, it will not become <bpt i="1" x="1">&lt;e1&gt;</bpt>more<ept i="1">&lt;/e1&gt;</ept> optional because of the chaining.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが取り出そうとしている型が<bpt i="0" x="0">&lt;e0&gt;</bpt>すでに<ept i="0">&lt;/e0&gt;</ept>オプショナルならば、それは連鎖であることから<bpt i="1" x="1">&lt;e1&gt;</bpt>さらに<ept i="1">&lt;/e1&gt;</ept>オプショナルにはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the type you are trying to retrieve is not optional, it will become optional because of the optional chaining.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが取り出そうとしている型がオプショナルでないならば、それはオプショナル連鎖であることからオプショナルになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value before the <bpt i="1" x="1">&lt;c1&gt;</bpt>?<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>, everything after the <bpt i="3" x="3">&lt;c3&gt;</bpt>?<ept i="3">&lt;/c3&gt;</ept> is ignored and the value of the whole expression is <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>?<ept i="1">&lt;/c1&gt;</ept>の前の値が<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>ならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>?<ept i="3">&lt;/c3&gt;</ept>の後のすべてのものは、無視されて、その全体の式の値は<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>, no operation is performed and therefore no runtime error is produced.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その値が<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>ならば、演算は実行されません、したがって、実行時エラーは生じません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> is non-<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>, the value of <bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept> is not evaluated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>の値が<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>でないならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept>の値は評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of <bpt i="3" x="3">&lt;c3&gt;</bpt>age<ept i="3">&lt;/c3&gt;</ept> is negative, as in the code above, then <bpt i="4" x="4">&lt;c4&gt;</bpt>age &gt;= 0<ept i="4">&lt;/c4&gt;</ept> evaluates to <bpt i="5" x="5">&lt;c5&gt;</bpt>false<ept i="5">&lt;/c5&gt;</ept>, and the assertion fails, terminating the application.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>age<ept i="3">&lt;/c3&gt;</ept>の値が負であるならば、上のコードでのように、そのとき<bpt i="4" x="4">&lt;c4&gt;</bpt>age &gt;= 0<ept i="4">&lt;/c4&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>false<ept i="5">&lt;/c5&gt;</ept>に評価され、そして表明は失敗して、アプリケーションを終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of <bpt i="4" x="4">&lt;c4&gt;</bpt>integerToDescribe<ept i="4">&lt;/c4&gt;</ept> is one of the prime numbers in the list, the function appends text to the end of <bpt i="5" x="5">&lt;c5&gt;</bpt>description<ept i="5">&lt;/c5&gt;</ept>, to note that the number is prime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>integerToDescribe<ept i="4">&lt;/c4&gt;</ept>の値がリストにある素数の一つであるならば、数が素数であることを書き留めるために、関数は<bpt i="5" x="5">&lt;c5&gt;</bpt>description<ept i="5">&lt;/c5&gt;</ept>の終わりにテキストを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of <bpt i="8" x="8">&lt;c8&gt;</bpt>a<ept i="8">&lt;/c8&gt;</ept> is equal to <bpt i="9" x="9">&lt;c9&gt;</bpt>b<ept i="9">&lt;/c9&gt;</ept>, then the resulting range will be empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt>a<ept i="8">&lt;/c8&gt;</ept>の値が<bpt i="9" x="9">&lt;c9&gt;</bpt>b<ept i="9">&lt;/c9&gt;</ept>と等しいならば、そのとき結果として生じる範囲は空になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of the <bpt i="0" x="0">&lt;e0&gt;</bpt>expression<ept i="0">&lt;/e0&gt;</ept> is not <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>, the optional value is unwrapped and returned with the corresponding nonoptional type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>式<ept i="0">&lt;/e0&gt;</ept>の値が<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>でないならば、オプショナルの値は包装を取られて、対応する非オプショナル型で返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of the expression does not match the value of the return type declared in the function or method declaration, the expression’s value is converted to the return type before it is returned to the calling function or method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>式の値が関数またはメソッド宣言において宣言される戻り型の値にマッチしないならば、それが関数またはメソッドを呼んでいるところに返される前に、式の値は戻り型に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of the optional-chaining expression is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>, all of the other operations in the postfix expression are ignored and the entire postfix expression evaluates to <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖式の値が<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>ならば、接尾辞式での他の演算の全ては無視されます、そして接尾辞式の全体は<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of the optional-chaining expression is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>, the expression on the right-hand side of the assignment operator is not evaluated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖式の値が<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>ならば、代入演算子の右手側での式は評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value of the optional-chaining expression is not <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>, the value of the optional-chaining expression is unwrapped and used to evaluate the rest of the postfix expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖式の値が<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>でないならば、オプショナル連鎖式の値はアンラップされて、接尾辞式の残りを評価するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the value returned is not <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>, it is assigned to the <bpt i="6" x="6">&lt;e6&gt;</bpt>item<ept i="6">&lt;/e6&gt;</ept> pattern, the program executes the <bpt i="7" x="7">&lt;e7&gt;</bpt>statements<ept i="7">&lt;/e7&gt;</ept>, and then continues execution at the beginning of the loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返される値が<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>でないならば、それは<bpt i="6" x="6">&lt;e6&gt;</bpt>item（項目）<ept i="6">&lt;/e6&gt;</ept>パターンに割り当てられて、プログラムは<bpt i="7" x="7">&lt;e7&gt;</bpt>statements（文）<ept i="7">&lt;/e7&gt;</ept>を実行して、それからループの初めに戻って実行を続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If there are expressions of multiple types, <bpt i="2" x="2">&lt;c2&gt;</bpt>T<ept i="2">&lt;/c2&gt;</ept> is their closest common supertype.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数の型の式があるならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>T<ept i="2">&lt;/c2&gt;</ept>はそれらの最も近い共通のスーパー型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If there are expressions of multiple types, <bpt i="3" x="3">&lt;c3&gt;</bpt>Key<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Value<ept i="4">&lt;/c4&gt;</ept> are the closest common supertype for their respective values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数の型の式があるならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>Key<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>Value<ept i="4">&lt;/c4&gt;</ept>はそれらめいめいの値に対して最も近い共通のスーパー型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If there are not enough coins, <bpt i="1" x="1">&lt;c1&gt;</bpt>Bank<ept i="1">&lt;/c1&gt;</ept> returns a smaller number than the number that was requested (and returns zero if no coins are left in the bank).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>十分なコインがないならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>Bank<ept i="1">&lt;/c1&gt;</ept>は要請された数より少ない数を返します（そしてコインが胴元に残っていないならばゼロを返します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If there isn’t suitable type information available, Swift infers that the literal’s type is one of the default literal types defined in the Swift standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>適した型情報が得られなかったならば、スウィフトはそのリテラルの型はスウィフト標準ライブラリで定義される省略時のリテラル型の１つと推論します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If they contain a different number of items, there’s no way that they can match, and the function returns <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらが異なる数の項目を含むならば、それらが合致することができる術はありません、そして関数は<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this check is not performed, <bpt i="0" x="0">&lt;c0&gt;</bpt>board[square]<ept i="0">&lt;/c0&gt;</ept> might try to access a value outside the bounds of the <bpt i="1" x="1">&lt;c1&gt;</bpt>board<ept i="1">&lt;/c1&gt;</ept> array, which would trigger a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この確認が行われなかったならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>board[square]<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>board<ept i="1">&lt;/c1&gt;</ept>配列の境界外で値にアクセスしようとするかもしれません、それは実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this is successful, set a new temporary constant called <bpt i="2" x="2">&lt;c2&gt;</bpt>movie<ept i="2">&lt;/c2&gt;</ept> to the value stored in the returned optional <bpt i="3" x="3">&lt;c3&gt;</bpt>Movie<ept i="3">&lt;/c3&gt;</ept>.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これが成功するならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>movie<ept i="2">&lt;/c2&gt;</ept>と呼ばれる新しい一時的な定数を、返されたオプショナルの<bpt i="3" x="3">&lt;c3&gt;</bpt>Movie<ept i="3">&lt;/c3&gt;</ept>に格納される値に設定してください。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If this isn’t the case, <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> is preferred, even when the values to be stored are known to be nonnegative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合でないならば、保存される値が負数でないことがわかっている時でさえ、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>がむしろ好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If type information can be inferred, you can write an empty array as <bpt i="0" x="0">&lt;c0&gt;</bpt>[]<ept i="0">&lt;/c0&gt;</ept> and an empty dictionary as <bpt i="1" x="1">&lt;c1&gt;</bpt>[:]<ept i="1">&lt;/c1&gt;</ept>—for example, when you set a new value for a variable or pass an argument to a function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型情報が推論されることが出来るならば、あなたは空の配列を<bpt i="0" x="0">&lt;c0&gt;</bpt>[]<ept i="0">&lt;/c0&gt;</ept>のように、そして空の辞書を<bpt i="1" x="1">&lt;c1&gt;</bpt>[:]<ept i="1">&lt;/c1&gt;</ept>のように書くことができます ― 例えば、あなたが新しい値を変数に設定したり、関数に引数を渡す時に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If we’ve entered the correct door code and passed the retina scan, or if we have a valid door key, or if we know the emergency override password, then allow access.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>私達が正しいドア・コードを入力して網膜走査をパスしたならば、または私達が有効なドア・キーを持つならば、または私達が非常用解除パスワードを知っているならば、その時アクセスを許可してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you access the variable or property after the object has been deallocated, its value is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが変数またはプロパティにそのオブジェクトがデアロケートされてしまった後にアクセスするならば、それの値は<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you apply the <bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept> attribute to an enumeration, each enumeration case is exposed to Objective-C code as the concatenation of the enumeration name and the case name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept>属性をある列挙に適応したならば、個々の列挙ケース節はObjective-Cコードに列挙名とそのケース節名を連結したものとして暴露されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are familiar with C, you will know that C enumerations assign related names to a set of integer values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがCに精通しているならば、あなたはCの列挙がひとまとめの整数値それぞれに対して関連した名前を割り当てるということを知っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are working with particularly long string values, be aware that the <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> property must iterate over the Unicode scalars in the entire string in order to determine the characters for that string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが特に長い文字列値を扱う場合は、<bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>プロパティは、その文字列の文字を決定する目的で文字列全体のユニコード・スカラーのすべてに繰り返しを行わなければならないことを知っていてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you assign a closure to a property of a class instance, and the closure captures that instance by referring to the instance or its members, you will create a strong reference cycle between the closure and the instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが、あるクロージャをあるクラスインスタンスのプロパティに代入して、そしてクロージャがそのインスタンスを、インスタンスまたはそのメンバ（属するもの）に言及することによって捕獲するならば、あなたはクロージャとインスタンスの間で強い参照循環をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you assign a non-<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> value to <bpt i="1" x="1">&lt;c1&gt;</bpt>userDefinedColorName<ept i="1">&lt;/c1&gt;</ept> and perform the nil-coalescing operator check again, the value wrapped inside <bpt i="2" x="2">&lt;c2&gt;</bpt>userDefinedColorName<ept i="2">&lt;/c2&gt;</ept> is used instead of the default:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>でない値を<bpt i="1" x="1">&lt;c1&gt;</bpt>userDefinedColorName<ept i="1">&lt;/c1&gt;</ept>に代入して、nil合体演算子による確認をふたたび実行するならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>userDefinedColorName<ept i="2">&lt;/c2&gt;</ept>内にラップされた値は省略時のものの代わりに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you assign a value to a property within its own <bpt i="2" x="2">&lt;c2&gt;</bpt>didSet<ept i="2">&lt;/c2&gt;</ept> observer, the new value that you assign replaces the one that was just set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが独自の<bpt i="2" x="2">&lt;c2&gt;</bpt>didSet<ept i="2">&lt;/c2&gt;</ept>オブザーバーの内部で値をプロパティに代入するならば、あなたが代入する新しい値はついさっき設定されたものを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you assign an array, a set, or a dictionary to a constant, that collection is <bpt i="2" x="2">&lt;e2&gt;</bpt>immutable<ept i="2">&lt;/e2&gt;</ept>, and its size and contents cannot be changed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある配列、集合、または辞書をある定数に代入したならば、そのコレクションは<bpt i="2" x="2">&lt;e2&gt;</bpt>不変<ept i="2">&lt;/e2&gt;</ept>になります、そしてそれの大きさと内容は変更されることが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you assign an instance of a reference type to a constant, you can still change that instance’s variable properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが参照型のインスタンスを定数に代入するならば、あなたは依然としてそのインスタンスの変数プロパティを変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you assign the same <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> instance to two more variables, two more strong references to that instance are established:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが同じ<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>インスタンスをさらに２つの変数に代入するならば、そのインスタンスへのさらに２つの強い参照が確立されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you break <bpt i="2" x="2">&lt;e2&gt;</bpt>that<ept i="2">&lt;/e2&gt;</ept> strong reference, there are no more strong references to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Apartment<ept i="3">&lt;/c3&gt;</ept> instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="2" x="2">&lt;e2&gt;</bpt>その<ept i="2">&lt;/e2&gt;</ept>強い参照を壊すならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>Apartment<ept i="3">&lt;/c3&gt;</ept>インスタンスへの強い参照はもうこれ以上ありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you break two of these strong references (including the original reference) by assigning <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> to two of the variables, a single strong reference remains, and the <bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept> instance is not deallocated:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが変数のうちの２つに<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を代入することによってこれらの強い参照のうちの（最初の参照を含む）２つを壊すならば、１つの強い参照が残ります、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept>インスタンスは割り当て解除されません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you call this method on an optional value with optional chaining, the method’s return type will be <bpt i="0" x="0">&lt;c0&gt;</bpt>Void?<ept i="0">&lt;/c0&gt;</ept>, not <bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept>, because return values are always of an optional type when called through optional chaining.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこのメソッドをあるオプショナルの値の上でオプショナル連鎖を使って呼ぶならば、メソッドの戻り値は<bpt i="0" x="0">&lt;c0&gt;</bpt>Void?<ept i="0">&lt;/c0&gt;</ept>になります、<bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept>ではなく、なぜならば、オプショナル連鎖を通して呼び出されるとき戻り値は常にオプショナルだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you combine integer and floating-point literals in an expression, a type of <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> will be inferred from the context:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある式の中で整数と浮動小数点リテラルを結合するならば、その前後関係から<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>の型が推論されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you compile in unchecked mode (<bpt i="0" x="0">&lt;c0&gt;</bpt>-Ounchecked<ept i="0">&lt;/c0&gt;</ept>), preconditions aren’t checked.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが未検査モード（<bpt i="0" x="0">&lt;c0&gt;</bpt>-Ounchecked<ept i="0">&lt;/c0&gt;</ept>）でコンパイルするならば、前提条件は調べられません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create a <bpt i="0" x="0">&lt;c0&gt;</bpt>CartItem<ept i="0">&lt;/c0&gt;</ept> instance with a nonempty name and a quantity of <bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept> or more, initialization succeeds:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>CartItem<ept i="0">&lt;/c0&gt;</ept>インスタンスを空でない名前と<bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>以上の数量で作成するならば、初期化は成功します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create a <bpt i="0" x="0">&lt;c0&gt;</bpt>TrackedString<ept i="0">&lt;/c0&gt;</ept> instance and modify its string value a few times, you can see the <bpt i="1" x="1">&lt;c1&gt;</bpt>numberOfEdits<ept i="1">&lt;/c1&gt;</ept> property value update to match the number of modifications:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>TrackedString<ept i="0">&lt;/c0&gt;</ept>インスタンスをつくって、２、３回その文字列値を修正するならば、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>numberOfEdits<ept i="1">&lt;/c1&gt;</ept>プロパティが修正の数に合うように更新されるのを見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> instance, its <bpt i="1" x="1">&lt;c1&gt;</bpt>residence<ept i="1">&lt;/c1&gt;</ept> property is default initialized to <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>, by virtue of being optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>インスタンスをつくるならば、その<bpt i="1" x="1">&lt;c1&gt;</bpt>residence<ept i="1">&lt;/c1&gt;</ept>プロパティは、オプショナルである長所によって、省略時で<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>に初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create a new <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> value, that <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> value is <bpt i="4" x="4">&lt;e4&gt;</bpt>copied<ept i="4">&lt;/e4&gt;</ept> when it’s passed to a function or method, or when it’s assigned to a constant or variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが新しい<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>値をつくるならば、その<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>値は、それが関数またはメソッドに渡される時に、またはそれが定数または変数に代入される時に、<bpt i="4" x="4">&lt;e4&gt;</bpt>コピーされます<ept i="4">&lt;/e4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create a new instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Train<ept i="0">&lt;/c0&gt;</ept> and call its <bpt i="1" x="1">&lt;c1&gt;</bpt>makeNoise()<ept i="1">&lt;/c1&gt;</ept> method, you can see that the <bpt i="2" x="2">&lt;c2&gt;</bpt>Train<ept i="2">&lt;/c2&gt;</ept> subclass version of the method is called:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Train<ept i="0">&lt;/c0&gt;</ept>の新しいインスタンスを作成してそれの<bpt i="1" x="1">&lt;c1&gt;</bpt>makeNoise()<ept i="1">&lt;/c1&gt;</ept>メソットを呼び出すならば、あなたはサブクラス板の<bpt i="2" x="2">&lt;c2&gt;</bpt>Train<ept i="2">&lt;/c2&gt;</ept>メソッドが呼び出されるのを見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create a second incrementer, it will have its own stored reference to a new, separate <bpt i="0" x="0">&lt;c0&gt;</bpt>runningTotal<ept i="0">&lt;/c0&gt;</ept> variable:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが第２のインクリメンタをつくるならば、それは、独自に保存された、ある新しい、別個の<bpt i="0" x="0">&lt;c0&gt;</bpt>runningTotal<ept i="0">&lt;/c0&gt;</ept>変数への参照を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create a second player, whom you try to move to a level that is not yet unlocked by any player in the game, the attempt to set the player’s current level fails:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが二番目のプレーヤーを作成して、あなたがその人をそのゲームにおいてどのプレーヤーによってもまだ錠を開けられていないレベルへ動かそうとするならば、プレーヤーの現在のレベルを決めるその試みは失敗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create an array, a set, or a dictionary, and assign it to a variable, the collection that is created will be <bpt i="0" x="0">&lt;e0&gt;</bpt>mutable<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある配列、集合、または辞書を作成して、それをある変数に代入したならば、作成されたコレクションは<bpt i="0" x="0">&lt;e0&gt;</bpt>可変<ept i="0">&lt;/e0&gt;</ept>となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Bicycle<ept i="0">&lt;/c0&gt;</ept>, you can call its inherited <bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept> computed property to see how its <bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfWheels<ept i="2">&lt;/c2&gt;</ept> property has been updated:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Bicycle<ept i="0">&lt;/c0&gt;</ept>のインスタンスを作成するならば、あなたはそれの継承された<bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept>計算プロパティを呼び出して、どのようにそれの<bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfWheels<ept i="2">&lt;/c2&gt;</ept>プロパティが更新されたか見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Tandem<ept i="0">&lt;/c0&gt;</ept>, you can work with any of its new and inherited properties, and query the read-only <bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept> property it inherits from <bpt i="2" x="2">&lt;c2&gt;</bpt>Vehicle<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Tandem<ept i="0">&lt;/c0&gt;</ept>のインスタンスを作成するならば、あなたはそれの新規および継承するプロパティを扱うことができて、それが<bpt i="2" x="2">&lt;c2&gt;</bpt>Vehicle<ept i="2">&lt;/c2&gt;</ept>から継承する読み込み専用の<bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept>プロパティについて問い合わせることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create an instance of a structure and assign that instance to a constant, you cannot modify the instance’s properties, even if they were declared as variable properties:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが構造体のインスタンスをつくって、そのインスタンスを定数に代入するならば、あなたはそのインスタンスのもつプロパティを、たとえそれらが変数プロパティとして宣言されたとしても、修正することはできません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create an instance of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Car<ept i="0">&lt;/c0&gt;</ept> class and set its <bpt i="1" x="1">&lt;c1&gt;</bpt>gear<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>currentSpeed<ept i="2">&lt;/c2&gt;</ept> properties, you can see that its <bpt i="3" x="3">&lt;c3&gt;</bpt>description<ept i="3">&lt;/c3&gt;</ept> property returns the tailored description defined within the <bpt i="4" x="4">&lt;c4&gt;</bpt>Car<ept i="4">&lt;/c4&gt;</ept> class:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Car<ept i="0">&lt;/c0&gt;</ept>クラスのインスタンスを作成して、それの<bpt i="1" x="1">&lt;c1&gt;</bpt>gear<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>currentSpeed<ept i="2">&lt;/c2&gt;</ept>プロパティを設定するならば、あなたはそれの<bpt i="3" x="3">&lt;c3&gt;</bpt>description<ept i="3">&lt;/c3&gt;</ept>プロパティが<bpt i="4" x="4">&lt;c4&gt;</bpt>Car<ept i="4">&lt;/c4&gt;</ept>クラス内で定義される特注の説明を返すのを見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create and assign an actual <bpt i="0" x="0">&lt;c0&gt;</bpt>Residence<ept i="0">&lt;/c0&gt;</ept> instance to <bpt i="1" x="1">&lt;c1&gt;</bpt>john.residence<ept i="1">&lt;/c1&gt;</ept>, with one or more <bpt i="2" x="2">&lt;c2&gt;</bpt>Room<ept i="2">&lt;/c2&gt;</ept> instances in its <bpt i="3" x="3">&lt;c3&gt;</bpt>rooms<ept i="3">&lt;/c3&gt;</ept> array, you can use the <bpt i="4" x="4">&lt;c4&gt;</bpt>Residence<ept i="4">&lt;/c4&gt;</ept> subscript to access the actual items in the <bpt i="5" x="5">&lt;c5&gt;</bpt>rooms<ept i="5">&lt;/c5&gt;</ept> array through optional chaining:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが実際の<bpt i="0" x="0">&lt;c0&gt;</bpt>Residence<ept i="0">&lt;/c0&gt;</ept>インスタンスをつくって<bpt i="1" x="1">&lt;c1&gt;</bpt>john.residence<ept i="1">&lt;/c1&gt;</ept>に代入して、その<bpt i="3" x="3">&lt;c3&gt;</bpt>rooms<ept i="3">&lt;/c3&gt;</ept>配列の中に一つ以上の<bpt i="2" x="2">&lt;c2&gt;</bpt>Room<ept i="2">&lt;/c2&gt;</ept>インスタンスをもつならば、あなたは<bpt i="4" x="4">&lt;c4&gt;</bpt>Residence<ept i="4">&lt;/c4&gt;</ept>添え字を使って、オプショナル連鎖を通して<bpt i="5" x="5">&lt;c5&gt;</bpt>rooms<ept i="5">&lt;/c5&gt;</ept>配列の実際の項目にアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you create your own class or structure to represent a complex data model, for example, then the meaning of “equal to” for that class or structure isn’t something that Swift can guess for you.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが例えば独自のクラスまたは構造体を作成してある複合データモデルを表すならば、そのときそのクラスまたは構造体のための「同等」の意味することはスウィフトがあなたのために推測することができる何かではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you define a new protocol that inherits from an existing protocol, the new protocol can have at most the same access level as the protocol it inherits from.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが既存のプロトコルから継承する新しいプロトコルを定義するならば、新しいプロトコルは最大ではそれが継承するプロトコルと同じアクセス水準を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you define a protocol instance method requirement that is intended to mutate instances of any type that adopts the protocol, mark the method with the <bpt i="0" x="0">&lt;c0&gt;</bpt>mutating<ept i="0">&lt;/c0&gt;</ept> keyword as part of the protocol’s definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがそのプロトコルを採用するあらゆる型のインスタンスを変化させることを意図したインスタンスメソッド要件プロトコルを定義するならば、プロトコルの定義の一部としてそのメソッドに<bpt i="0" x="0">&lt;c0&gt;</bpt>mutating<ept i="0">&lt;/c0&gt;</ept>キーワードで印をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you define a public protocol, the protocol’s requirements require a public access level for those requirements when they’r implemented.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある公開プロトコルを定義するならば、そのプロトコルは、それらの要件のために対してそれらが実装されるときに公開アクセス水準を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you define a type’s access level as internal or public (or use the default access level of internal without specifying an access level explicitly), the default access level of the type’s members will be internal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある型のアクセス水準を内部または公開として定義する（または明示的にアクセス水準を指定することなく省略時のアクセス水準である内部を使用する）ならば、その型のメンバーの省略時のアクセス水準は内部になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you define a type’s access level as private or file private, the default access level of its members will also be private or file private.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある型のアクセス水準を非公開またはファイル外非公開として定義するならば、そのメンバーの省略時のアクセス水準も、非公開またはファイル外非公開になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you define an enumeration with a raw-value type, the enumeration automatically receives an initializer that takes a value of the raw value’s type (as a parameter called <bpt i="0" x="0">&lt;c0&gt;</bpt>rawValue<ept i="0">&lt;/c0&gt;</ept>) and returns either an enumeration case or <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが列挙を「生の値」型を使って定義したならば、その列挙は生の値の方の値を（<bpt i="0" x="0">&lt;c0&gt;</bpt>rawValue<ept i="0">&lt;/c0&gt;</ept>と呼ばれるパラメーターとして）とって、一つの列挙ケース節か<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>のどちらかを返すイニシャライザを自動的に受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you define an extension to add new functionality to an existing type, the new functionality will be available on all existing instances of that type, even if they were created before the extension was defined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが新しい機能性を既存の型に加えるために拡張を定義するならば、新しい機能性はその型の全ての既存の例で利用可能になります、たとえそれらが拡張が定義される前につくられたとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you define an optional variable without providing a default value, the variable is automatically set to <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> for you:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが既定値を提供することなくオプショナルの変数を定義するならば、その変数はあなたのために自動的に<bpt i="0" x="0">&lt;c0&gt;</bpt>nilに<ept i="0">&lt;/c0&gt;</ept>設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you didn’t mark the parameter of this function with <bpt i="1" x="1">&lt;c1&gt;</bpt>@escaping<ept i="1">&lt;/c1&gt;</ept>, you would get a compile-time error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこの関数のパラメータを<bpt i="1" x="1">&lt;c1&gt;</bpt>@escaping<ept i="1">&lt;/c1&gt;</ept>で印しないならば、あなたはコンパイル時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you do not provide a setter name, the default parameter name to the setter is <bpt i="1" x="1">&lt;c1&gt;</bpt>newValue<ept i="1">&lt;/c1&gt;</ept>, as described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Shorthand Setter Declaration<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがセッター名を提供しないならば、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>短縮形セッター宣言<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されるように、セッターへの省略時のパラメータ名は<bpt i="1" x="1">&lt;c1&gt;</bpt>newValue<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you do not provide a setter name, the default parameter name to the setter is <bpt i="1" x="1">&lt;c1&gt;</bpt>value<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがセッター名を提供しないならば、セッターへの省略時ののパラメータ名は<bpt i="1" x="1">&lt;c1&gt;</bpt>value<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you do not provide setter names, the default parameter name to the <bpt i="5" x="5">&lt;c5&gt;</bpt>willSet<ept i="5">&lt;/c5&gt;</ept> observer is <bpt i="6" x="6">&lt;c6&gt;</bpt>newValue<ept i="6">&lt;/c6&gt;</ept> and the default parameter name to the <bpt i="7" x="7">&lt;c7&gt;</bpt>didSet<ept i="7">&lt;/c7&gt;</ept> observer is <bpt i="8" x="8">&lt;c8&gt;</bpt>oldValue<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがセッター名を提供しないならば、<bpt i="5" x="5">&lt;c5&gt;</bpt>willSet<ept i="5">&lt;/c5&gt;</ept>オブザーバーへの初期状態でのパラメータ名は<bpt i="6" x="6">&lt;c6&gt;</bpt>newValue<ept i="6">&lt;/c6&gt;</ept>です、そして、<bpt i="7" x="7">&lt;c7&gt;</bpt>didSet<ept i="7">&lt;/c7&gt;</ept>オブザーバーへの初期状態でのパラメータ名は<bpt i="8" x="8">&lt;c8&gt;</bpt>oldValue<ept i="8">&lt;/c8&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you do not want to use an argument label for an initializer parameter, write an underscore (<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>) instead of an explicit argument label for that parameter to override the default behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがイニシャライザ・パラメータのために引数ラベルを使うことを望まないならば、そのパラメータに対して明示的な引数ラベルを書くのではなくひとつのアンダーバー（<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>）を書いて、省略時の挙動をオーバーライドしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you don’t explicitly write <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>, Swift assumes that you are referring to a property or method of the current instance whenever you use a known property or method name within a method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが明示的に<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>を書かないならば、スウィフトは、あなたがメソッド内で既知のプロパティまたはメソッド名を使用するときはいつでも、あなたが現在のインスタンスに属するプロパティまたはメソッドに言及していると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you don’t need each value from a sequence, you can ignore the values by using an underscore in place of a variable name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある連続物からの各値を必要としないならば、あなたは変数の名前の代わりにアンダースコアを使うことによってその値を無視することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you don’t need to compute the property but still need to provide code that is run before and after setting a new value, use <bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが、プロパティを計算する必要がないにもかかわらず新しい値の設定の前や後で実行されるコードを提供する必要があるならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept>や<bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you don’t provide an initial value when you declare an optional variable or property, its value automatically defaults to <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの変数またはプロパティを宣言する時にあなたが最初の値を提供しないならば、その値は自動的に省略時の<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you don’t specify the type of value you need, Swift uses <bpt i="0" x="0">&lt;e0&gt;</bpt>type inference<ept i="0">&lt;/e0&gt;</ept> to work out the appropriate type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが必要とする値の型をあなたが指定しないならば、スウィフトは適切な型を導きだすために<bpt i="0" x="0">&lt;e0&gt;</bpt>型推論<ept i="0">&lt;/e0&gt;</ept>を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you don’t use this attribute, supply a <bpt i="0" x="0">&lt;c0&gt;</bpt>main.swift<ept i="0">&lt;/c0&gt;</ept> file with code at the top level that calls the <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>UIApplicationMain(_:_:_:_:)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこの属性を使わないならば、<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>UIApplicationMain(_:_:_:_:)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>関数を呼ぶトップレベルでのコードを持つ<bpt i="0" x="0">&lt;c0&gt;</bpt>main.swift<ept i="0">&lt;/c0&gt;</ept>ファイルを提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you don’t use this attribute, supply a <bpt i="0" x="0">&lt;c0&gt;</bpt>main.swift<ept i="0">&lt;/c0&gt;</ept> file with code at the top level that calls the <bpt i="1" x="1">&lt;c1&gt;</bpt>NSApplicationMain(_:_:)<ept i="1">&lt;/c1&gt;</ept> function as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこの属性を使わないならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>NSApplicationMain(_:_:)<ept i="1">&lt;/c1&gt;</ept>関数を呼ぶトップレベルコードを持つ<bpt i="0" x="0">&lt;c0&gt;</bpt>main.swift<ept i="0">&lt;/c0&gt;</ept>ファイルを以下のように提供してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you don’t want an argument label for a parameter, write an underscore (<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>) instead of an explicit argument label for that parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあるパラメーターに引数ラベルを使うことを望まないならば、そのパラメーターに対して明示的な引数ラベルの代わりにひとつのアンダースコア（<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you don’t want to modify the inherited property’s value within the overriding getter, you can simply pass through the inherited value by returning <bpt i="0" x="0">&lt;c0&gt;</bpt>super.someProperty<ept i="0">&lt;/c0&gt;</ept> from the getter, where <bpt i="1" x="1">&lt;c1&gt;</bpt>someProperty<ept i="1">&lt;/c1&gt;</ept> is the name of the property you are overriding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがオーバーライドのゲッター内で継承されたプロパティの値を修正したくないならば、あなたは、そのゲッターから<bpt i="0" x="0">&lt;c0&gt;</bpt>super.someProperty<ept i="0">&lt;/c0&gt;</ept>を返すことによって、単に継承された値を通り抜けさせることができます、ここで<bpt i="1" x="1">&lt;c1&gt;</bpt>someProperty<ept i="1">&lt;/c1&gt;</ept>はあなたがオーバーライドしているプロパティの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you don’t write the parameter name and parentheses within your implementation, the parameter is made available with a default parameter name of <bpt i="2" x="2">&lt;c2&gt;</bpt>newValue<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがパラメータ名と丸括弧をあなたの実装内で書かないならば、パラメータは省略時のパラメータ名の<bpt i="2" x="2">&lt;c2&gt;</bpt>newValue<ept i="2">&lt;/c2&gt;</ept>を使って利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you extend a file-private type, any new type members you add have a default access level of file private.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあるファイル外非公開型を拡張するならば、あなたが加えるどんな新しい型メンバーでも省略時のアクセス水準であるファイル外非公開を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you extend a private type, any new type members you add have a default access level of private.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある非公開型を拡張するならば、あなたが加えるどんな新しい型メンバーでも省略時のアクセス水準である非公開を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you extend a public or internal type, any new type members you add have a default access level of internal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある公開または内部型を拡張するならば、あなたが加えるどんな新しい型メンバーでも省略時のアクセス水準である内部を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you group together aspects of your app’s code as a stand-alone framework—perhaps to encapsulate and reuse that code across multiple applications—then everything you define within that framework will be part of a separate module when it’s imported and used within an app, or when it’s used within another framework.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが、あなたのアプリのコードのさまざまな面をスタンドアローンのフレームワークとして ― おそらくそのコードをカプセル化して複数のアプリケーションに渡って再利用するために ― １つにまとめるならば、あなたがそのフレームワーク内で定義するすべてのものは、それがアプリ内にインポートされて使われるとき、またはそれがもう一つのフレームワーク内で使われるとき、別々のモジュール部分になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you have experience with C, C++, or Objective-C, you may know that these languages use <bpt i="0" x="0">&lt;e0&gt;</bpt>pointers<ept i="0">&lt;/e0&gt;</ept> to refer to addresses in memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがC、C++、またはObjective-Cで経験を持つならば、あなたはこれらの言語がメモリのアドレスに言及するために<bpt i="0" x="0">&lt;e0&gt;</bpt>ポインター<ept i="0">&lt;/e0&gt;</ept>を使用するということを知っているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you have experience with Objective-C, you may know that it provides <bpt i="0" x="0">&lt;e0&gt;</bpt>two<ept i="0">&lt;/e0&gt;</ept> ways to store values and references as part of a class instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがObjective-Cでの経験を持つならば、あなたはそれがクラスインスタンスの一部として値や参照を保存するために<bpt i="0" x="0">&lt;e0&gt;</bpt>２つの<ept i="0">&lt;/e0&gt;</ept>方法を提供するということを知っているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you have written code in C or Objective-C, this syntax looks familiar to you—in Swift, this line of code is a complete program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがCまたはObjective-Cでコードを書いたことがあるならば、この構文はあなたにとって馴染みがあるものでしょう ― スウィフトにおいて、コードのこの行は、ひとつの完全なプログラムです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you implement a <bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept> observer, it’s passed the new property value as a constant parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept>オブザーバーを実装するならば、それは新しいプロパティ値を定数パラメータとして渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you implement the <bpt i="0" x="0">&lt;c0&gt;</bpt>Togglable<ept i="0">&lt;/c0&gt;</ept> protocol for a structure or enumeration, that structure or enumeration can conform to the protocol by providing an implementation of the <bpt i="1" x="1">&lt;c1&gt;</bpt>toggle()<ept i="1">&lt;/c1&gt;</ept> method that is also marked as <bpt i="2" x="2">&lt;c2&gt;</bpt>mutating<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Togglable<ept i="0">&lt;/c0&gt;</ept>プロトコルをある構造体または列挙のために実装するならば、その構造体または列挙は、同様に<bpt i="2" x="2">&lt;c2&gt;</bpt>mutating<ept i="2">&lt;/c2&gt;</ept>として印される<bpt i="1" x="1">&lt;c1&gt;</bpt>toggle()<ept i="1">&lt;/c1&gt;</ept>メソッドの実施を提供することによって、このプロトコルに準拠できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you mark a protocol instance method requirement as <bpt i="0" x="0">&lt;c0&gt;</bpt>mutating<ept i="0">&lt;/c0&gt;</ept>, you don’t need to write the <bpt i="1" x="1">&lt;c1&gt;</bpt>mutating<ept i="1">&lt;/c1&gt;</ept> keyword when writing an implementation of that method for a class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがインスタンスメソッド要件プロトコルに<bpt i="0" x="0">&lt;c0&gt;</bpt>mutating<ept i="0">&lt;/c0&gt;</ept>として印するならば、あるクラスのためにそのメソッドの実装を書くとき、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>mutating<ept i="1">&lt;/c1&gt;</ept>キーワードを書く必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you mark an initializer with the <bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept> declaration modifier, you don’t also mark the initializer with the <bpt i="1" x="1">&lt;c1&gt;</bpt>override<ept i="1">&lt;/c1&gt;</ept> modifier when you override the required initializer in a subclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがイニシャライザを<bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept>宣言修飾子で印するならば、あなたはさらにそのイニシャライザを<bpt i="1" x="1">&lt;c1&gt;</bpt>override<ept i="1">&lt;/c1&gt;</ept>宣言修飾子で印することは、あなたがサブクラスの必須イニシャライザをオーバーライドする場合には、しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you name the elements in a tuple, you can use the element names to access the values of those elements:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがタプルの要素に名をつけるならば、あなたはそれらの要素の値にアクセスするために要素名を使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need C-style fallthrough behavior, you can opt in to this behavior on a case-by-case basis with the <bpt i="0" x="0">&lt;c0&gt;</bpt>fallthrough<ept i="0">&lt;/c0&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがC形式のフォールスルー挙動を必要とするならば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>fallthrough<ept i="0">&lt;/c0&gt;</ept>キーワードを使ってそれぞれ個別にこの挙動を選択できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need a string that spans several lines, use a multiline string literal—a sequence of characters surrounded by three double quotes:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがいくつかの行に及ぶ文字列を必要とするならば、複数行文字列リテラル — ３つの二重引用符で囲まれる一連の文字、を使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need the behavior of the <bpt i="2" x="2">&lt;c2&gt;</bpt>swapTwoValues(_:_:)<ept i="2">&lt;/c2&gt;</ept> function in your own code, you can use Swift’s existing <bpt i="3" x="3">&lt;c3&gt;</bpt>swap(_:_:)<ept i="3">&lt;/c3&gt;</ept> function rather than providing your own implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあなた自身のコードにおいて<bpt i="2" x="2">&lt;c2&gt;</bpt>swapTwoValues(_:_:)<ept i="2">&lt;/c2&gt;</ept>関数の挙動を必要とするならば、あなたはあなた自身の実施を提供するのではなくスウィフトの既存の<bpt i="3" x="3">&lt;c3&gt;</bpt>swap(_:_:)<ept i="3">&lt;/c3&gt;</ept>関数を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need the integer index of each item as well as its value, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>enumerated()<ept i="0">&lt;/c0&gt;</ept> method to iterate over the array instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがその値のみならず各項目の整数インデックスを必要とするならば、代わりに<bpt i="0" x="0">&lt;c0&gt;</bpt>enumerated()<ept i="0">&lt;/c0&gt;</ept>メソッドを配列じゅうを繰り返し処理するのに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to capture an in-out parameter without mutating it or to observe changes made by other code, use a capture list to explicitly capture the parameter immutably.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがin-outパラメータをキャプチャする必要がそれを変化させることなしにまたは他のコードによってなされる変更を監視するためにあるならば、キャプチャリストを使うことで明示的にそのパラメータを不変にキャプチャしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to capture and mutate an in-out parameter, use an explicit local copy, such as in multithreaded code that ensures all mutation has finished before the function returns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがin-outパラメータをキャプチャして変化させる必要があるならば、明示的なローカルコピーを使ってください、例えばすべての変化がその関数が返るまえに完了してしまっていることを保証するマルチスレッド化されたコードにおいてなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to convert a value to a different type, explicitly make an instance of the desired type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある値を異なる型に変換する必要があるならば、明示的に望む型のインスタンスにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to expose many declarations, you can group them in an extension that has the <bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが多くの宣言を露出する必要があるならば、あなたはそれらを<bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept>属性を持つある拡張にまとめることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to give a constant or variable the same name as a reserved Swift keyword, surround the keyword with backticks (<bpt i="0" x="0">&lt;c0&gt;</bpt>`<ept i="0">&lt;/c0&gt;</ept>) when using it as a name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが予約済みのスウィフトのキーワードと同じ名前を定数または変数に与える必要があるならば、名前としてそれを使うときバッククォート（<bpt i="0" x="0">&lt;c0&gt;</bpt>`<ept i="0">&lt;/c0&gt;</ept>）でそのキーワードを囲んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to pass a closure expression to a function as the function’s final argument and the closure expression is long, it can be useful to write it as a <bpt i="0" x="0">&lt;e0&gt;</bpt>trailing closure<ept i="0">&lt;/e0&gt;</ept> instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが関数の最後の引数としてクロージャ式を関数に渡す必要がある、そして、クロージャ式が長いならば、代わりに<bpt i="0" x="0">&lt;e0&gt;</bpt>後付クロージャ<ept i="0">&lt;/e0&gt;</ept>としてそれを書くことは役に立つことがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to use a dictionary’s keys or values with an API that takes an <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> instance, initialize a new array with the <bpt i="1" x="1">&lt;c1&gt;</bpt>keys<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>values<ept i="2">&lt;/c2&gt;</ept> property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが、ある辞書のキーまたは値を、<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>インスタンスを引数にとるAPIで使う必要があるならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>keys<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>values<ept i="2">&lt;/c2&gt;</ept>プロパティによってひとつの新しい配列を初期化してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you omit the parameter names and both types, omit the <bpt i="0" x="0">&lt;c0&gt;</bpt>in<ept i="0">&lt;/c0&gt;</ept> keyword before the statements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがパラメータ名と両方の型を省略するならば、文の前の<bpt i="0" x="0">&lt;c0&gt;</bpt>in<ept i="0">&lt;/c0&gt;</ept>キーワードを省略します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you omit the precedence group for an operator, Swift uses the default precedence group, <bpt i="0" x="0">&lt;c0&gt;</bpt>DefaultPrecedence<ept i="0">&lt;/c0&gt;</ept>, which specifies a precedence just higher than <bpt i="1" x="1">&lt;c1&gt;</bpt>TernaryPrecedence<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが優先順位グループを省略するならば、スウィフトは省略時の優先順位グループ、<bpt i="0" x="0">&lt;c0&gt;</bpt>DefaultPrecedence<ept i="0">&lt;/c0&gt;</ept>を使います、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>TernaryPrecedence<ept i="1">&lt;/c1&gt;</ept>のすぐ上の優先順位を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you omit the version number, omit the colon (<bpt i="1" x="1">&lt;c1&gt;</bpt>:<ept i="1">&lt;/c1&gt;</ept>) as well.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこのバージョン番号を省略したならば、コロン（<bpt i="1" x="1">&lt;c1&gt;</bpt>:<ept i="1">&lt;/c1&gt;</ept>）も同様に省いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you omit these parentheses, you are trying to assign the closure itself to the property, and not the return value of the closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこの丸括弧を省略するならば、あなたはプロパティにクロージャそれ自体を代入することを試みています、つまりそのクロージャの戻り値でなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you only need some of the tuple’s values, ignore parts of the tuple with an underscore (<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>) when you decompose the tuple:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがタプルの値の一部を必要とするだけならば、あなたがタプルを分解するとき、アンダースコア（<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>）で、タプルの一部を無視してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you pass a property that has observers to a function as an in-out parameter, the <bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept> observers are always called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがオブザーバーを持つプロパティをある関数へin-outパラメータとして渡すならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept>オブザーバーは常に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you pass an empty string value to the failable initializer’s <bpt i="0" x="0">&lt;c0&gt;</bpt>species<ept i="0">&lt;/c0&gt;</ept> parameter, the initializer triggers an initialization failure:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが失敗できるイニシャライザの<bpt i="0" x="0">&lt;c0&gt;</bpt>species<ept i="0">&lt;/c0&gt;</ept>パラメータに空の文字列値を渡すならば、イニシャライザは初期化失敗を引き起こします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you provide a new initializer with an extension, you are still responsible for making sure that each instance is fully initialized once the initializer completes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが新しいイニシャライザを拡張によって提供する場合、あなたは依然として、一旦イニシャライザが完了するならば各インスタンスが完全に初期化されることを確かにする責任があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you provide a setter as part of a property override, you must also provide a getter for that override.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがプロパティオーバーライドの一部としてセッターを提供するならば、あなたはまたそのオーバーライドのためにゲッターも提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you provide a setter name, it is used as the name of the parameter to the setter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがセッター名を提供するならば、それがセッターにパラメータの名前として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you provide an initial value for a constant or variable at the point that it’s defined, Swift can almost always infer the type to be used for that constant or variable, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Type Safety and Type Inference<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが最初の値を定数または変数に、それが定義される時点で提供するならば、スウィフトはたいていその定数または変数のために使われる型を推測することが、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>「型安全と型推論」<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you provide setter names, they are used as the parameter names to the <bpt i="3" x="3">&lt;c3&gt;</bpt>willSet<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>didSet<ept i="4">&lt;/c4&gt;</ept> observers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがセッター名を提供するならば、それらが<bpt i="3" x="3">&lt;c3&gt;</bpt>willSet<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>didSet<ept i="4">&lt;/c4&gt;</ept>オブザーバーへのパラメータ名として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you read strictly from left to right, you might expect the expression to be calculated as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが厳密に左から右に読んだならば、あなたはこの式を以下のように計算されることを期待するでしょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you really do need to use an optional value as an <bpt i="2" x="2">&lt;c2&gt;</bpt>Any<ept i="2">&lt;/c2&gt;</ept> value, you can use the <bpt i="3" x="3">&lt;c3&gt;</bpt>as<ept i="3">&lt;/c3&gt;</ept> operator to explicitly cast the optional to <bpt i="4" x="4">&lt;c4&gt;</bpt>Any<ept i="4">&lt;/c4&gt;</ept>, as shown below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが本当にオプショナル値を<bpt i="2" x="2">&lt;c2&gt;</bpt>Any<ept i="2">&lt;/c2&gt;</ept>値として使う必要があるならば、あなたは<bpt i="3" x="3">&lt;c3&gt;</bpt>as<ept i="3">&lt;/c3&gt;</ept>演算子を使って明示的にオプショナルを<bpt i="4" x="4">&lt;c4&gt;</bpt>Any<ept i="4">&lt;/c4&gt;</ept>へキャストすることが、以下で示すように行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you set an actual <bpt i="0" x="0">&lt;c0&gt;</bpt>Address<ept i="0">&lt;/c0&gt;</ept> instance as the value for <bpt i="1" x="1">&lt;c1&gt;</bpt>john.residence.address<ept i="1">&lt;/c1&gt;</ept>, and set an actual value for the address’s <bpt i="2" x="2">&lt;c2&gt;</bpt>street<ept i="2">&lt;/c2&gt;</ept> property, you can access the value of the <bpt i="3" x="3">&lt;c3&gt;</bpt>street<ept i="3">&lt;/c3&gt;</ept> property through multilevel optional chaining:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが実際の<bpt i="0" x="0">&lt;c0&gt;</bpt>Address<ept i="0">&lt;/c0&gt;</ept>インスタンスを<bpt i="1" x="1">&lt;c1&gt;</bpt>john.residence.address<ept i="1">&lt;/c1&gt;</ept>のための値として設定して、そしてアドレスのもつ<bpt i="2" x="2">&lt;c2&gt;</bpt>street<ept i="2">&lt;/c2&gt;</ept>プロパティのために実際の値を設定するならば、あなたは複数階層のオプショナル連鎖を通して<bpt i="3" x="3">&lt;c3&gt;</bpt>street<ept i="3">&lt;/c3&gt;</ept>プロパティの値にアクセスすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you set the <bpt i="0" x="0">&lt;c0&gt;</bpt>currentLevel<ept i="0">&lt;/c0&gt;</ept> of the <bpt i="1" x="1">&lt;e1&gt;</bpt>left<ept i="1">&lt;/e1&gt;</ept> channel to <bpt i="2" x="2">&lt;c2&gt;</bpt>7<ept i="2">&lt;/c2&gt;</ept>, you can see that the <bpt i="3" x="3">&lt;c3&gt;</bpt>maxInputLevelForAllChannels<ept i="3">&lt;/c3&gt;</ept> type property is updated to equal <bpt i="4" x="4">&lt;c4&gt;</bpt>7<ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="1" x="1">&lt;e1&gt;</bpt>左<ept i="1">&lt;/e1&gt;</ept>のチャンネルの<bpt i="0" x="0">&lt;c0&gt;</bpt>currentLevel<ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>7<ept i="2">&lt;/c2&gt;</ept>に設定するならば、あなたは型プロパティ<bpt i="3" x="3">&lt;c3&gt;</bpt>maxInputLevelForAllChannels<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>7<ept i="4">&lt;/c4&gt;</ept>に等しくなるよう更新されるのを見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you set the <bpt i="0" x="0">&lt;c0&gt;</bpt>paragraph<ept i="0">&lt;/c0&gt;</ept> variable to <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> and break its strong reference to the <bpt i="2" x="2">&lt;c2&gt;</bpt>HTMLElement<ept i="2">&lt;/c2&gt;</ept> instance, neither the <bpt i="3" x="3">&lt;c3&gt;</bpt>HTMLElement<ept i="3">&lt;/c3&gt;</ept> instance nor its closure are deallocated, because of the strong reference cycle:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>paragraph<ept i="0">&lt;/c0&gt;</ept>変数を<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>に設定して、<bpt i="2" x="2">&lt;c2&gt;</bpt>HTMLElement<ept i="2">&lt;/c2&gt;</ept>へのそれの強い参照を壊すならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>HTMLElement<ept i="3">&lt;/c3&gt;</ept>インスタンスもそれのクロージャも割り当て解除されません、強い参照循環のためです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you set the strong reference from the <bpt i="2" x="2">&lt;c2&gt;</bpt>paragraph<ept i="2">&lt;/c2&gt;</ept> variable to <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>, the <bpt i="4" x="4">&lt;c4&gt;</bpt>HTMLElement<ept i="4">&lt;/c4&gt;</ept> instance is deallocated, as can be seen from the printing of its deinitializer message in the example below:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが強い参照である<bpt i="2" x="2">&lt;c2&gt;</bpt>paragraph<ept i="2">&lt;/c2&gt;</ept>変数を<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>に設定するならば、その<bpt i="4" x="4">&lt;c4&gt;</bpt>HTMLElement<ept i="4">&lt;/c4&gt;</ept>インスタンスは、下の例におけるそれのデイニシャライザのメッセージの出力から分かるように、割り当て解除されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you specify a type by name, you can access the type’s initializer without using an initializer expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある型を名前で指定するならば、あなたはその型のイニシャライザにイニシャライザ式を使うことなくアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you specify the Objective-C name for a class, protocol, or enumeration, include a three-letter prefix on the name, as described in <bpt i="2" x="2">&lt;a2&gt;</bpt>Conventions<ept i="2">&lt;/a2&gt;</ept> in <bpt i="3" x="3">&lt;e3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Programming with Objective-C<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがObjective-C名をクラス、プロトコル、または列挙に指定するならば、ある３文字接頭辞をその名前に含めて下さい、<bpt i="2" x="2">&lt;a2&gt;</bpt>Conventions<ept i="2">&lt;/a2&gt;</ept>で<bpt i="3" x="3">&lt;e3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Programming with Objective-C<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/e3&gt;</ept>において記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you subtract <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept> from <bpt i="3" x="3">&lt;c3&gt;</bpt>00000000<ept i="3">&lt;/c3&gt;</ept> using the overflow subtraction operator (<bpt i="4" x="4">&lt;c4&gt;</bpt>&amp;-<ept i="4">&lt;/c4&gt;</ept>), the number will overflow and wrap around to <bpt i="5" x="5">&lt;c5&gt;</bpt>11111111<ept i="5">&lt;/c5&gt;</ept>, or <bpt i="6" x="6">&lt;c6&gt;</bpt>255<ept i="6">&lt;/c6&gt;</ept> in decimal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがオーバフロー減算演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt>&amp;-<ept i="4">&lt;/c4&gt;</ept>）を使用して<bpt i="3" x="3">&lt;c3&gt;</bpt>00000000<ept i="3">&lt;/c3&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>を減ずるならば、その数はあふれ出てぐるっと送り込まれて<bpt i="5" x="5">&lt;c5&gt;</bpt>11111111<ept i="5">&lt;/c5&gt;</ept>、10進での<bpt i="6" x="6">&lt;c6&gt;</bpt>255<ept i="6">&lt;/c6&gt;</ept>になります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you throw an error in a function, the function returns immediately and the code that called the function handles the error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが関数においてエラーをスローするならば、その関数は直ちに返ります、そして関数を呼んだコードがエラーを取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you tried to do this without a generic <bpt i="1" x="1">&lt;c1&gt;</bpt>where<ept i="1">&lt;/c1&gt;</ept> clause, you would have a problem: The implementation of <bpt i="2" x="2">&lt;c2&gt;</bpt>isTop(_:)<ept i="2">&lt;/c2&gt;</ept> uses the <bpt i="3" x="3">&lt;c3&gt;</bpt>==<ept i="3">&lt;/c3&gt;</ept> operator, but the definition of <bpt i="4" x="4">&lt;c4&gt;</bpt>Stack<ept i="4">&lt;/c4&gt;</ept> doesn’t require its items to be equatable, so using the <bpt i="5" x="5">&lt;c5&gt;</bpt>==<ept i="5">&lt;/c5&gt;</ept> operator results in a compile-time error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが総称体<bpt i="1" x="1">&lt;c1&gt;</bpt>where<ept i="1">&lt;/c1&gt;</ept>節なしにこれをしようとするならば、あなたは問題を抱えることになるでしょう：<bpt i="2" x="2">&lt;c2&gt;</bpt>isTop(_:)<ept i="2">&lt;/c2&gt;</ept>の実装は<bpt i="3" x="3">&lt;c3&gt;</bpt>==<ept i="3">&lt;/c3&gt;</ept>演算子を使います、しかし<bpt i="4" x="4">&lt;c4&gt;</bpt>Stack<ept i="4">&lt;/c4&gt;</ept>の定義はそれの項目に同等評価可能であることを要求しません、それで<bpt i="5" x="5">&lt;c5&gt;</bpt>==<ept i="5">&lt;/c5&gt;</ept>演算子の使用はコンパイル時エラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to access <bpt i="3" x="3">&lt;c3&gt;</bpt>numberOfRooms<ept i="3">&lt;/c3&gt;</ept> with the same optional chaining as before, it will now return an <bpt i="4" x="4">&lt;c4&gt;</bpt>Int?<ept i="4">&lt;/c4&gt;</ept> that contains the default <bpt i="5" x="5">&lt;c5&gt;</bpt>numberOfRooms<ept i="5">&lt;/c5&gt;</ept> value of <bpt i="6" x="6">&lt;c6&gt;</bpt>1<ept i="6">&lt;/c6&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが前と同じオプショナル連鎖で<bpt i="3" x="3">&lt;c3&gt;</bpt>numberOfRooms<ept i="3">&lt;/c3&gt;</ept>にアクセスしようとするならば、それは今では省略時の<bpt i="5" x="5">&lt;c5&gt;</bpt>numberOfRooms<ept i="5">&lt;/c5&gt;</ept>値の<bpt i="6" x="6">&lt;c6&gt;</bpt>1<ept i="6">&lt;/c6&gt;</ept>を含む<bpt i="4" x="4">&lt;c4&gt;</bpt>Int?<ept i="4">&lt;/c4&gt;</ept>を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to access an unsafe unowned reference after the instance that it refers to is deallocated, your program will try to access the memory location where the instance used to be, which is an unsafe operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが安全でない非所有参照に、それが参照するインスタンスがデアロケートされてしまった後にアクセスすることを試みるならば、あなたのプログラムはそのインスタンスが存在するのに使われたところの位置でメモリにアクセスしようと試みるでしょう、それはメモリ安全ではない操作です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to access or modify a value for an index that is outside of an array’s existing bounds, you will trigger a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが配列のもつ存在する境界の外にあるインデックスに対する値にアクセスまたは変更しようとするならば、あなたは実行時エラーの引き金を引くことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to access the <bpt i="0" x="0">&lt;c0&gt;</bpt>numberOfRooms<ept i="0">&lt;/c0&gt;</ept> property of this person’s <bpt i="1" x="1">&lt;c1&gt;</bpt>residence<ept i="1">&lt;/c1&gt;</ept>, by placing an exclamation mark after <bpt i="2" x="2">&lt;c2&gt;</bpt>residence<ept i="2">&lt;/c2&gt;</ept> to force the unwrapping of its value, you trigger a runtime error, because there is no <bpt i="3" x="3">&lt;c3&gt;</bpt>residence<ept i="3">&lt;/c3&gt;</ept> value to unwrap:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこの人の<bpt i="1" x="1">&lt;c1&gt;</bpt>residence<ept i="1">&lt;/c1&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>numberOfRooms<ept i="0">&lt;/c0&gt;</ept>プロパティに、その値を強制アンラップするため<bpt i="2" x="2">&lt;c2&gt;</bpt>residence<ept i="2">&lt;/c2&gt;</ept>の後に感嘆符を置くことによって、アクセスしようとするならば、あなたは実行時エラーを引き起こします、なぜなら、アンラップする<bpt i="3" x="3">&lt;c3&gt;</bpt>residence<ept i="3">&lt;/c3&gt;</ept>値はないからです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to access the value of an unowned reference after that instance has been deallocated, you’ll get a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある非所有者参照の値に、そのインスタンスがデアロケートされてしまった後にアクセスしようとするならば、あなたは実行時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to access the variable or property after the object has been deallocated, a runtime error is raised.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが変数またはプロパティにそのオブジェクトがデアロケートされてしまった後にアクセスすることを試みるならば、実行時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to access the variable or property after the object has been deallocated, you’ll access the memory at the location where the object used to be, which is a memory-unsafe operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが変数またはプロパティに、そのオブジェクトがデアロケートされてしまった後にアクセスすることを試みるならば、あなたはそのオブジェクトが存在するのに使われたところの位置でメモリにアクセスするでしょう、それはメモリ安全ではない操作です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to call the <bpt i="0" x="0">&lt;c0&gt;</bpt>isTop(_:)<ept i="0">&lt;/c0&gt;</ept> method on a stack whose elements aren’t equatable, you’ll get a compile-time error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>isTop(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを、それの持つ要素が同等評価可能でないスタック上で呼び出そうとするならば、あなたはコンパイル時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to create a <bpt i="0" x="0">&lt;c0&gt;</bpt>CartItem<ept i="0">&lt;/c0&gt;</ept> instance with a <bpt i="1" x="1">&lt;c1&gt;</bpt>quantity<ept i="1">&lt;/c1&gt;</ept> value of <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>, the <bpt i="3" x="3">&lt;c3&gt;</bpt>CartItem<ept i="3">&lt;/c3&gt;</ept> initializer causes initialization to fail:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>CartItem<ept i="0">&lt;/c0&gt;</ept>インスタンスを<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>quantity<ept i="1">&lt;/c1&gt;</ept>値で作成することを試みるならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>CartItem<ept i="3">&lt;/c3&gt;</ept>イニシャライザが初期化を失敗する原因となります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to find a planet with a position of <bpt i="0" x="0">&lt;c0&gt;</bpt>11<ept i="0">&lt;/c0&gt;</ept>, the optional <bpt i="1" x="1">&lt;c1&gt;</bpt>Planet<ept i="1">&lt;/c1&gt;</ept> value returned by the raw value initializer will be <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>11<ept i="0">&lt;/c0&gt;</ept>の位置で惑星を見つけようとするならば、生の値のイニシャライザによって返されるオプショナルの<bpt i="1" x="1">&lt;c1&gt;</bpt>Planet<ept i="1">&lt;/c1&gt;</ept>値は、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>になります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to insert a number into an integer constant or variable that cannot hold that value, by default Swift reports an error rather than allowing an invalid value to be created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある数をその値を持つことができない整数の定数や変数の中へ入れようとするならば、初期状態では、スウィフトは無効な値がつくられるようにするのではなく、エラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to retrieve an <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> value through optional chaining, an <bpt i="1" x="1">&lt;c1&gt;</bpt>Int?<ept i="1">&lt;/c1&gt;</ept> is always returned, no matter how many levels of chaining are used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがオプショナル連鎖を通して<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>値を取り出そうと試すならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int?<ept i="1">&lt;/c1&gt;</ept>が常に返されます、どんなに多くの連鎖階層が使われようともです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to set the <bpt i="0" x="0">&lt;c0&gt;</bpt>currentLevel<ept i="0">&lt;/c0&gt;</ept> of the <bpt i="1" x="1">&lt;e1&gt;</bpt>right<ept i="1">&lt;/e1&gt;</ept> channel to <bpt i="2" x="2">&lt;c2&gt;</bpt>11<ept i="2">&lt;/c2&gt;</ept>, you can see that the right channel’s <bpt i="3" x="3">&lt;c3&gt;</bpt>currentLevel<ept i="3">&lt;/c3&gt;</ept> property is capped to the maximum value of <bpt i="4" x="4">&lt;c4&gt;</bpt>10<ept i="4">&lt;/c4&gt;</ept>, and the <bpt i="5" x="5">&lt;c5&gt;</bpt>maxInputLevelForAllChannels<ept i="5">&lt;/c5&gt;</ept> type property is updated to equal <bpt i="6" x="6">&lt;c6&gt;</bpt>10<ept i="6">&lt;/c6&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="1" x="1">&lt;e1&gt;</bpt>右<ept i="1">&lt;/e1&gt;</ept>のチャンネルの<bpt i="0" x="0">&lt;c0&gt;</bpt>currentLevel<ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>11<ept i="2">&lt;/c2&gt;</ept>に設定しようとするならば、あなたは右のチャンネルの<bpt i="3" x="3">&lt;c3&gt;</bpt>currentLevel<ept i="3">&lt;/c3&gt;</ept>プロパティが最大値の<bpt i="4" x="4">&lt;c4&gt;</bpt>10<ept i="4">&lt;/c4&gt;</ept>に制限されるのを見ることができます、そして型プロパティ<bpt i="5" x="5">&lt;c5&gt;</bpt>maxInputLevelForAllChannels<ept i="5">&lt;/c5&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt>10<ept i="6">&lt;/c6&gt;</ept>に等しくなるよう更新されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you try to use an implicitly unwrapped optional that has a value of <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>, you’ll get a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>の値を持つ暗黙的にアンラップされるオプショナルを使うことを試みるならば、あなたは実行時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use a capture list, you must also use the <bpt i="0" x="0">&lt;c0&gt;</bpt>in<ept i="0">&lt;/c0&gt;</ept> keyword, even if you omit the parameter names, parameter types, and return type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがキャプチャリストを使うならば、あなたはまた<bpt i="0" x="0">&lt;c0&gt;</bpt>in<ept i="0">&lt;/c0&gt;</ept>キーワードも使わなければなりません、たとえあなたがパラメータ名、パラメータ型、そして戻り型を省略するとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use a closure to initialize a property, remember that the rest of the instance has not yet been initialized at the point that the closure is executed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがプロパティを初期化するためにクロージャを使うならば、そのクロージャが実行される時点で、残りのインスタンスはまだ初期化されていないのを思い出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use an extension to add an initializer to a value type that provides default values for all of its stored properties and does not define any custom initializers, you can call the default initializer and memberwise initializer for that value type from within your extension’s initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが拡張を、その保存プロパティの全てに省略時の値を与えて全くあつらえのイニシャライザを定義しない値型に、イニシャライザを加えるために使うならば、あなたはその値型のための省略時のイニシャライザとメンバー関連イニシャライザを、あなたの拡張のイニシャライザ内から呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use multiple <bpt i="2" x="2">&lt;c2&gt;</bpt>available<ept i="2">&lt;/c2&gt;</ept> attributes the effective availability is the combination of the platform and Swift availabilities.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが複数の<bpt i="2" x="2">&lt;c2&gt;</bpt>available<ept i="2">&lt;/c2&gt;</ept>属性を使うならば、有効な利用可能性はプラットホームとスウィフト利用可能性の組み合わせとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use these shorthand argument names within your closure expression, you can omit the closure’s argument list from its definition, and the number and type of the shorthand argument names will be inferred from the expected function type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこれらの短縮形引数名をあなたのクロージャ式の中で使用するならば、あなたはクロージャの引数リストをその定義から省略することができます、そして、短縮形引数名の数と型は期待される関数型から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want a custom subclass to present one or more of the same initializers as its superclass, you can provide a custom implementation of those initializers within the subclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが、あるあつらえのサブクラスにそれのスーパークラスと同じイニシャライザがひとつ以上存在することを望むならば、あなたはそれらのイニシャライザのあつらえの実装をそのサブクラスにおいて提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want a function to modify a parameter’s value, and you want those changes to persist after the function call has ended, define that parameter as an <bpt i="0" x="0">&lt;e0&gt;</bpt>in-out parameter<ept i="0">&lt;/e0&gt;</ept> instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある関数にパラメータの値を修正して欲しいならば、そしてあなたが関数呼び出しが終わった後それらの変化に存続して欲しいならば、代わりにそのパラメータを<bpt i="0" x="0">&lt;e0&gt;</bpt>in-outパラメータ<ept i="0">&lt;/e0&gt;</ept>として定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want a nested type within a public type to be publicly available, you must explicitly declare the nested type as public.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが公開型の内側で入れ子にされた型に公開的に利用できて欲しいならば、あなたは明確に入れ子にされた型を公開として宣言しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want a public type to be initializable with a no-argument initializer when used in another module, you must explicitly provide a public no-argument initializer yourself as part of the type’s definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある公開型を別のモジュール内で使うときに引数のないイニシャライザを使って初期化できるようにしたいならば、あなたはある公開の引数のないイニシャライザをあなた自身でその型定義の一部として明示的に提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want a type member to be public, you must explicitly mark it as such.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが型のメンバーに公開であって欲しいならば、あなたは明確にそれをそのように印しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want an autoclosure that is allowed to escape, use both the <bpt i="0" x="0">&lt;c0&gt;</bpt>@autoclosure<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>@escaping<ept i="1">&lt;/c1&gt;</ept> attributes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが脱出を許可される自動クロージャを望むならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>@autoclosure<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>@escaping<ept i="1">&lt;/c1&gt;</ept>属性を両方とも使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want to assign an explicit access level to a protocol type, do so at the point that you define the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが明確なアクセス水準をあるプロトコル型に割り当てたいならば、あなたがそのプロトコルを定義する時点でそうしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want to observe changes to a property’s value, and you are already providing a custom setter for that property, you can simply observe any value changes from within the custom setter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあるプロパティの値に対する変更を監視したい、そしてあなたが既にあつらえのセッターをそのプロパティのために提供しているならば、あなたは簡単にあつらえのセッター内からどんな値の変化でも監視することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want to perform further optional chaining on this method’s return value, place the optional chaining question mark <bpt i="0" x="0">&lt;e0&gt;</bpt>after<ept i="0">&lt;/e0&gt;</ept> the method’s parentheses:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこのメソッドの戻り値の上でさらにオプショナル連鎖を実行したいならば、メソッドの丸括弧の<bpt i="0" x="0">&lt;e0&gt;</bpt>後に<ept i="0">&lt;/e0&gt;</ept>オプショナル連鎖の疑問符を置いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want to remove the final item from an array, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>removeLast()<ept i="0">&lt;/c0&gt;</ept> method rather than the <bpt i="1" x="1">&lt;c1&gt;</bpt>remove(at:)<ept i="1">&lt;/c1&gt;</ept> method to avoid the need to query the array’s <bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが配列から最後の項目を取り除きたいならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>removeLast()<ept i="0">&lt;/c0&gt;</ept>メソッドを<bpt i="1" x="1">&lt;c1&gt;</bpt>remove(at:)<ept i="1">&lt;/c1&gt;</ept>メソッドよりむしろ使用して、配列の<bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept>プロパティについてたずねる必要を避けるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want to specify an explicit access level for a custom type, do so at the point that you define the type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあつらえの型のために明示的にアクセス水準を指定したいならば、あなたが型を定義する時点でそうしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want to swap two <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> values, or two <bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept> values, you have to write more functions, such as the <bpt i="4" x="4">&lt;c4&gt;</bpt>swapTwoStrings(_:_:)<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>swapTwoDoubles(_:_:)<ept i="5">&lt;/c5&gt;</ept> functions shown below:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが２つの<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>値、または２つの<bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept>の値を交換したいならば、あなたはより多くの関数を書かなければなりません、例えば以下で示される<bpt i="4" x="4">&lt;c4&gt;</bpt>swapTwoStrings(_:_:)<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>swapTwoDoubles(_:_:)<ept i="5">&lt;/c5&gt;</ept>関数のように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want to use line breaks to make your source code easier to read, but you don’t want the line breaks to be part of the string’s value, write a backslash (<bpt i="0" x="0">&lt;c0&gt;</bpt>\<ept i="0">&lt;/c0&gt;</ept>) at the end of those lines:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが改行を使うことであなたのソースコードを読みやすくしたい、しかしあなたがその改行に文字列の値の一部であることを望まないならば、バックスラッシュを（<bpt i="0" x="0">&lt;c0&gt;</bpt>\<ept i="0">&lt;/c0&gt;</ept>）それらの行の終わりに書いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you want your custom value type to be initializable with the default initializer and memberwise initializer, and also with your own custom initializers, write your custom initializers in an extension rather than as part of the value type’s original implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが、あなたのあつらえの値型に省略時のイニシャライザとメンバー関連イニシャライザで、その上にあなた自身のあつらえのイニシャライザで初期化可能にされて欲しいならば、あなたのあつらえのイニシャライザを値型の元々の実装の一部としてではなく、ある拡張の中で書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you wanted to manipulate the value of <bpt i="0" x="0">&lt;c0&gt;</bpt>actualNumber<ept i="0">&lt;/c0&gt;</ept> within the first branch of the <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept> statement, you could write <bpt i="2" x="2">&lt;c2&gt;</bpt>if var actualNumber<ept i="2">&lt;/c2&gt;</ept> instead, and the value contained within the optional would be made available as a variable rather than a constant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>actualNumber<ept i="0">&lt;/c0&gt;</ept>の値を<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>文の最初の分岐内で取り扱うことを望むならば、あなたは<bpt i="2" x="2">&lt;c2&gt;</bpt>if var actualNumber<ept i="2">&lt;/c2&gt;</ept>を代わりに書くことができたでしょう、そしてオプショナル内部に含まれる値は定数ではなく変数として利用可能にされたでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you write <bpt i="0" x="0">&lt;c0&gt;</bpt>inout<ept i="0">&lt;/c0&gt;</ept> in front of a parameter’s type, the parameter can be modified inside the scope of the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>inout<ept i="0">&lt;/c0&gt;</ept>をパラメータの型のすぐ前に書くならば、そのパラメータは関数のスコープ内部において修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If your custom type has a stored property that is logically allowed to have “no value”—perhaps because its value cannot be set during initialization, or because it is allowed to have “no value” at some later point—declare the property with an <bpt i="0" x="0">&lt;e0&gt;</bpt>optional<ept i="0">&lt;/e0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの特注で作った型が論理的に「無い値」を持つことを許される保存プロパティを ― もしかしたらそれの値が初期化の間に設定されることができないかもしれないため、または後の時点でそれが「無い値」を持つことを許されるため ― 持つならば、そのプロパティを<bpt i="0" x="0">&lt;e0&gt;</bpt>オプショナル<ept i="0">&lt;/e0&gt;</ept>の型で宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If your data structure is likely to persist beyond a temporary scope, model it as a class or structure, rather than as a tuple.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのデータ構造が、一時的な範囲を越えて存続しそうならば、タプルとしてよりも、クラスまたは構造体としてそれをモデル化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのサブクラスがまったく指定イニシャライザを定義しないならば、それは自動的にそれのスーパークラスの指定イニシャライザの全てを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If your subclass provides an implementation of <bpt i="0" x="0">&lt;e0&gt;</bpt>all<ept i="0">&lt;/e0&gt;</ept> of its superclass designated initializers—either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition—then it automatically inherits all of the superclass convenience initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もしあなたのサブクラスがそれのスーパークラスの指定イニシャライザの実装の<bpt i="0" x="0">&lt;e0&gt;</bpt>全て<ept i="0">&lt;/e0&gt;</ept>を ― 規則１に従ってそれらを継承することによって、またはあつらえの実装をそれの定義の一部として提供することによってのどちらかで ― 提供するならば、その時それは自動的にスーパークラスの便宜イニシャライザの全てを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If your turn ends at the bottom of a ladder, you move up that ladder.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの番がはしごの下で終わるならば、あなたはそのはしごを上ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If your turn ends at the head of a snake, you move down that snake.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの番がヘビの頭のところで終わるならば、あなたはそのヘビを下ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you’re implementing a prefix or postfix operator, you must also mark that method declaration with the corresponding <bpt i="4" x="4">&lt;c4&gt;</bpt>prefix<ept i="4">&lt;/c4&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>postfix<ept i="5">&lt;/c5&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが接頭辞または接尾辞演算子を実装しているならば、あなたはまたそのメソッド宣言を対応する<bpt i="4" x="4">&lt;c4&gt;</bpt>prefix<ept i="4">&lt;/c4&gt;</ept>または<bpt i="5" x="5">&lt;c5&gt;</bpt>postfix<ept i="5">&lt;/c5&gt;</ept>宣言修飾子で印をしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you’re implementing the method in an extension, use the <bpt i="3" x="3">&lt;c3&gt;</bpt>class<ept i="3">&lt;/c3&gt;</ept> modifier if you’re extending a class and the <bpt i="4" x="4">&lt;c4&gt;</bpt>static<ept i="4">&lt;/c4&gt;</ept> modifier if you’re extending a structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこのメソッドをある拡張の中で実装するならば、あなたがクラスを拡張しているなら<bpt i="3" x="3">&lt;c3&gt;</bpt>class<ept i="3">&lt;/c3&gt;</ept>修飾子を、あなたが構造体を拡張しているなら<bpt i="4" x="4">&lt;c4&gt;</bpt>static<ept i="4">&lt;/c4&gt;</ept>修飾子を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you’re using multiline string literals to build up the lines of a longer string, you want every line in the string to end with a line break, including the last line.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが複数行文字列リテラルを使ってたくさんの行の長い文字列を作り上げようとしているならば、あなたはその文字列のすべての行を、最後の行を含めて改行で終わりたいと思うでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Implement an <bpt i="2" x="2">&lt;c2&gt;</bpt>area()<ept i="2">&lt;/c2&gt;</ept> and a <bpt i="3" x="3">&lt;c3&gt;</bpt>simpleDescription()<ept i="3">&lt;/c3&gt;</ept> method on the <bpt i="4" x="4">&lt;c4&gt;</bpt>Circle<ept i="4">&lt;/c4&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>area()<ept i="2">&lt;/c2&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt>simpleDescription()<ept i="3">&lt;/c3&gt;</ept>メソッドを<bpt i="4" x="4">&lt;c4&gt;</bpt>Circle<ept i="4">&lt;/c4&gt;</ept>クラス上で実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Implicit Member Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙のメンバー式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Implicit Returns from Single-Expression Closures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単一式のクロージャからの値を暗黙的に返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Implicit returns from single-expression closures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単一式のクロージャからの値を暗黙的に返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Implicitly Assigned Raw Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的に割り当てられる生の値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Implicitly Unwrapped Optional Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的にアンラップされるオプショナルの型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Implicitly Unwrapped Optionals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的にアンラップされるオプショナル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Implicitly unwrapped optionals are useful when an optional’s value is confirmed to exist immediately after the optional is first defined and can definitely be assumed to exist at every point thereafter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的にアンラップされるオプショナルは、あるオプショナルの値が存在するのをそのオプショナルが最初に定義された直後に確かめられて、それ以降あらゆる所で存在するのを自信を持って仮定出来るようにされる場合に役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Import Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポート宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Important</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>重要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Improved the discussion of autoclosures in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Autoclosures<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自動クロージャの説明を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>自動クロージャ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節において改善した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Blackjack, the Ace cards have a value of either one or eleven.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブラックジャックにおいて、「エース」のカードは、１または11のどちらかの値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In C and Objective-C, you define static constants and variables associated with a type as <bpt i="0" x="0">&lt;e0&gt;</bpt>global<ept i="0">&lt;/e0&gt;</ept> static variables.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>CとObjective-Cでは、あなたは静的定数および<bpt i="0" x="0">&lt;e0&gt;</bpt>グローバルな<ept i="0">&lt;/e0&gt;</ept>静的変数として型と結びついた変数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept> is a pointer to a nonexistent object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>は、ある存在しないオブジェクトへのポインターです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, classes are the only types that can define methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、クラスはメソッドを定義することができる唯一の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, you can define type-level methods only for Objective-C classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、あなたはObjective-Cクラスのためにだけ型レベルのメソッドを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statements don’t fall through the bottom of each case and into the next one.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文は、それぞれのケース節の底を抜け落ちて次のものにいきません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> isn’t a pointer—it’s the absence of a value of a certain type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>はポインターではありません ― それは、ある特定の型のある値の不在です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, an enumeration to define product barcodes of either type might look like this:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて、両方の種類の製品バーコードを定義する列挙は、これのように見えるかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, as in C, the remainder operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>%<ept i="2">&lt;/c2&gt;</ept>) and the multiplication operator (<bpt i="3" x="3">&lt;c3&gt;</bpt>*<ept i="3">&lt;/c3&gt;</ept>) have a higher precedence than the addition operator (<bpt i="4" x="4">&lt;c4&gt;</bpt>+<ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、Cでのように、剰余演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>%<ept i="2">&lt;/c2&gt;</ept>）と乗算演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt>*<ept i="3">&lt;/c3&gt;</ept>）は、加算演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt>+<ept i="4">&lt;/c4&gt;</ept>）より高い優先順位を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, as in Objective-C, protocol conformance is global—it isn’t possible for a type to conform to a protocol in two different ways within the same program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて、Objective-Cにおいてと同様に、プロトコル準拠はグローバルです ― ひとつの型にとって、同じプログラム内でひとつのプロトコルに２つの異なる方法で準拠することは、可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, errors are represented by values of types that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Error<ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、エラーは<bpt i="0" x="0">&lt;c0&gt;</bpt>Error<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型の値によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, every possible value of the control expression’s type must match the value of at least one pattern of a case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて、制御式のもつ型のあらゆる可能な値は、少なくともあるケース節の１つのパターンの値にマッチしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, however, type properties are written as part of the type’s definition, within the type’s outer curly braces, and each type property is explicitly scoped to the type it supports.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、しかしながら、型プロパティは、型の定義の一部として、型の外縁の波括弧の内部に書かれます、そして各型プロパティは、明確にそれが支持する型にスコープを定められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, many basic data types such as <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>Dictionary<ept i="2">&lt;/c2&gt;</ept> are implemented as structures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、多くの基本的なデータ型、<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept>、および<bpt i="2" x="2">&lt;c2&gt;</bpt>Dictionary<ept i="2">&lt;/c2&gt;</ept>などが、構造体として実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, most declarations are also definitions in the sense that they are implemented or initialized at the same time they are declared.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて、大部分の宣言はまた、それらが宣言されるのと同時にそれらが実装または初期化されるという意味で定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, the simplest form of a closure that can capture values is a nested function, written within the body of another function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて、値をキャプチャできるクロージャの最も単純な形式は、別の関数の本文内に書かれる、入れ子にされた関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, there are four kinds of expressions: prefix expressions, binary expressions, primary expressions, and postfix expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトには、４種類の式があります：接頭辞式、二項式、基本式、そして接尾辞式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, there are three kinds of statements: simple statements, compiler control statements, and control flow statements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトには、３種類の文があります：単純な文、コンパイラ制御文、そして制御の流れ文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, there are two basic kinds of patterns: those that successfully match any kind of value, and those that may fail to match a specified value at runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトには、２つの基本的な種類のパターンがあります：あらゆる種類の値に成功裏にマッチするものたち、そして指定された値にマッチするのを実行時に失敗するものたち。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, there are two kinds of types: named types and compound types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトには、２つの種類の型：名前付きの型と複合の型があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, this can be done in a single line:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて、これは一つの行でされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, this would be written as:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、これはこのように書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, type information can also flow in the opposite direction—from the root down to the leaves.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、型情報は逆方向にも流れます ― 根から下って葉っぱまで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can choose whether to define a class, structure, or enumeration, and still have the flexibility to define methods on the type you create.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたは、クラス、構造体、または列挙を定義すべきかを選択することができます、そしてまだあなたがつくる型でメソッドを定義する柔軟性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can define type-level methods for all classes, structures, and enumerations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたは全てのクラス、構造体、および列挙のために型レベルのメソッドを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can even extend a protocol to provide implementations of its requirements or add additional functionality that conforming types can take advantage of.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたはプロトコルを拡張してその要件の実装を提供することやそれの準拠型が利用することができる追加の機能性を加えることさえ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can nest loops and conditional statements inside other loops and conditional statements to create complex control flow structures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたはループおよび条件文を他のループおよび条件文の中に入れ子にして、複雑な制御の流れの構造を作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you define a class or a structure in a single file, and the external interface to that class or structure is automatically made available for other code to use.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたは一つのファイルにおいてクラスまたは構造体を定義します、そして、そのクラスまたは構造体への外部インタフェースは自動的に他のコードが使うことが可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Xcode, for example, the <bpt i="1" x="1">&lt;c1&gt;</bpt>print(_:separator:terminator:)<ept i="1">&lt;/c1&gt;</ept> function prints its output in Xcode’s “console” pane.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、Xcodeでは、<bpt i="1" x="1">&lt;c1&gt;</bpt>print(_:separator:terminator:)<ept i="1">&lt;/c1&gt;</ept>関数はその出力をXcodeの「コンソール」枠に表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept> statement, the increment expression is still evaluated after the <bpt i="1" x="1">&lt;c1&gt;</bpt>continue<ept i="1">&lt;/c1&gt;</ept> statement is executed, because the increment expression is evaluated after the execution of the loop’s body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>文において、増加式は<bpt i="1" x="1">&lt;c1&gt;</bpt>continue<ept i="1">&lt;/c1&gt;</ept>文が実行されたあと依然として評価されます、なぜなら増加式がループの本文の実行の後に評価されるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a class declaration, the <bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept> keyword has the same effect as marking the declaration with both the <bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>final<ept i="2">&lt;/c2&gt;</ept> declaration modifiers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス宣言において、キーワード<bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept>は宣言を<bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>final<ept i="2">&lt;/c2&gt;</ept>宣言修飾子の両方で印することと同じ効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a dictionary literal, the key and value in each key-value pair are separated by a colon.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書リテラルでは、それぞれの「キーと値」の対の中のキーと値は、コロンで区切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a few cases, regular font text is used to describe the right-hand side of a grammar production rule.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２、３の場合には、標準活字のテキストが説明のために文法導出規則の右側で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a multiline string literal, writing a backslash (<bpt i="0" x="0">&lt;c0&gt;</bpt>\<ept i="0">&lt;/c0&gt;</ept>) at the end of a line omits that line break from the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行文字列リテラルにおいて、バックスラッシュ（<bpt i="0" x="0">&lt;c0&gt;</bpt>\<ept i="0">&lt;/c0&gt;</ept>）を行の終わりで書くことはそのラインブレークを文字列から省きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a mutating method of a value type, you can assign a new instance of that value type to <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型の可変メソッドでは、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>にその値型の新しいインスタンスを代入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In a type method, <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> refers to the current type in which it occurs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型メソッドでは、<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>はそれが現れているところの現在の型に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to comparing against specific values, Swift provides several ways for each case to specify more complex matching patterns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある特定の値に対して比較することに加えて、スウィフトは、それぞれのケース節のために、より複雑な適合パターンを指定するためのいくつかの方法を用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to familiar types, Swift introduces advanced types not found in Objective-C, such as tuples.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>よく知られている型に加えて、スウィフトはObjective-Cで見られない先進の型を導入します、例えばタプルのような。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to generic functions, Swift enables you to define your own <bpt i="0" x="0">&lt;e0&gt;</bpt>generic types<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体関数に加えて、スウィフトはあなたに独自の<bpt i="0" x="0">&lt;e0&gt;</bpt>総称体型<ept i="0">&lt;/e0&gt;</ept>を定義することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to its list of protocols, a protocol composition can also contain one class type, which you can use to specify a required superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかのプロトコルからなるそれのリストに加えて、あるプロトコル合成はまた１つのクラス型を含むことができます、それはあなたが必要とされるスーパークラスを指定するのに使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to its type property and type methods, <bpt i="0" x="0">&lt;c0&gt;</bpt>LevelTracker<ept i="0">&lt;/c0&gt;</ept> tracks an individual player’s progress through the game.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その型プロパティと型メソッドに加えて、<bpt i="0" x="0">&lt;c0&gt;</bpt>LevelTracker<ept i="0">&lt;/c0&gt;</ept>は個々のプレーヤーのゲームを通しての進捗を追います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to matching a pattern with a value, you can extract part or all of a composite value and bind each part to a constant or variable name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パターンを値とマッチングすることに加えて、あなたはある複合値の部分または全てを抽出して、各部分を定数や変数の名前に結び付ける（束縛する）ことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to offering various levels of access control, Swift reduces the need to specify explicit access control levels by providing default access levels for typical scenarios.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセス制御のいろいろな水準を提供することに加えて、スウィフトは省略時のアクセス水準を典型的なシナリオのために用意することによって明示的にアクセス制御水準を指定する必要を減らします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to properties, you can use instance variables as a backing store for the values stored in a property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティに加えて、あなたはインスタンス変数をプロパティに保管される値に対する支援外部記憶として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to simple properties that are stored, properties can have a getter and a setter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存される単純なプロパティに加えて、プロパティはゲッター（取得メソッド）とセッター（設定メソッド）を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to specifying major version numbers like iOS 8 or macOS 10.10, you can specify minor versions numbers like iOS 8.3 and macOS 10.10.3.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メジャーなバージョン数をiOS 8やmacOS 10.10のように指定することに加えて、あなたはマイナーバージョン数を、iOS 8.3そしてmacOS 10.10.3のように指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to specifying requirements that conforming types must implement, you can extend a protocol to implement some of these requirements or to implement additional functionality that conforming types can take advantage of.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>準拠する型が実装しなければならない要件を指定することに加えて、あなたはあるプロトコルを拡張してそれらの要件のいくつかを実装したり、更なる機能性を実装したりできます、それらは、準拠する型それぞれで利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to stored properties, classes, structures, and enumerations can define <bpt i="0" x="0">&lt;e0&gt;</bpt>computed properties<ept i="0">&lt;/e0&gt;</ept>, which do not actually store a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存プロパティに加えて、クラス、構造体、および列挙は<bpt i="0" x="0">&lt;e0&gt;</bpt>計算プロパティ<ept i="0">&lt;/e0&gt;</ept>を定義することができます、それは、実際に値を保存しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to the characteristics it inherits, the <bpt i="0" x="0">&lt;c0&gt;</bpt>Bicycle<ept i="0">&lt;/c0&gt;</ept> class defines a new stored property, <bpt i="1" x="1">&lt;c1&gt;</bpt>hasBasket<ept i="1">&lt;/c1&gt;</ept>, with a default value of <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept> (inferring a type of <bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept> for the property).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが継承する特徴に加えて、<bpt i="0" x="0">&lt;c0&gt;</bpt>Bicycle<ept i="0">&lt;/c0&gt;</ept>クラスは新しい保存プロパティ、<bpt i="1" x="1">&lt;c1&gt;</bpt>hasBasket<ept i="1">&lt;/c1&gt;</ept>を、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>の省略時の値を使って定義します（このプロパティに対しては<bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept>の型が推論されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to the operators described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Basic Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, Swift provides several advanced operators that perform more complex value manipulation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>基本の演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述される演算子に加えて、スウィフトはより複雑な値操作を実行するいくつかの先進の演算子を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to the standard library operators, you use <bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;<ept i="0">&lt;/c0&gt;</ept> immediately before the name of a variable that’s being passed as an in-out argument to a function call expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>標準ライブラリ演算子に加えて、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;<ept i="0">&lt;/c0&gt;</ept>を変数の名前の直前で使います、それはin-out引数として関数呼び出し式に渡されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to these two simple properties, the <bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept> class defines a lazy property called <bpt i="1" x="1">&lt;c1&gt;</bpt>asHTML<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの２つの単純なプロパティに加えて、<bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept>クラスは、<bpt i="1" x="1">&lt;c1&gt;</bpt>asHTML<ept i="1">&lt;/c1&gt;</ept>と呼ばれる遅延プロパティを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to user-defined named types, the Swift standard library defines many commonly used named types, including those that represent arrays, dictionaries, and optional values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユーザー定義の名前付きの型に加えて、スウィフト標準ライブラリは、配列、辞書、そしてオプショナル値を表すものたちを含む、多くの一般に使われる名前付きの型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to verifying your expectations at runtime, assertions and preconditions also become a useful form of documentation within the code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの期待を実行時で実証するのに加えて、表明と前提条件はまたコード内部での有用な文書化形式となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, Swift provides a <bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept> statement to introduce scope, and catch and handle errors, and a <bpt i="1" x="1">&lt;c1&gt;</bpt>defer<ept i="1">&lt;/c1&gt;</ept> statement for running cleanup actions just before the current scope exits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加えて、スウィフトは、<bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>文をスコープを導入し、それでエラーを捕えて処理するために、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>defer<ept i="1">&lt;/c1&gt;</ept>文を現在のスコープを脱出する直前にさまざまな片付け活動を実行するために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, the <bpt i="5" x="5">&lt;c5&gt;</bpt>catch<ept i="5">&lt;/c5&gt;</ept> clause must handle only errors thrown by one of the rethrowing function’s throwing parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加えて、その<bpt i="5" x="5">&lt;c5&gt;</bpt>catch<ept i="5">&lt;/c5&gt;</ept>節はスロー関数の持つスローパラメータの１つによってスローされるエラーのみを取り扱わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, you can define property observers to monitor changes in a property’s value, which you can respond to with custom actions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それに加えて、あなたはプロパティオブザーバーを定義して、あるプロパティの値の変化を監視することができて、あなたはあつらえの動作でそれに応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, you can override any class member (method, property, initializer, or subscript) that is visible in a certain access context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それに加えて、あなたは特定のアクセス前後関係において見えるあらゆるクラスメンバー（メソッド、プロパティ、イニシャライザ、または添え字）をオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In all other cases, define a class, and create instances of that class to be managed and passed by reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全ての他の場合には、クラスを定義してください、そしてそのクラスのインスタンスをつくって、参照で管理されて渡されるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In all other cases, the dice roll is a valid move.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の全ての場合には、さいころの目は有効な移動となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In all other cases, you must use an initializer expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての他の場合では、あなたはイニシャライザ式を使う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In all three functions, the types of <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept> must be the same.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>３つの関数すべてにおいて、<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>の型は同じでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement, the conditional must be a Boolean expression—this means that code such as <bpt i="1" x="1">&lt;c1&gt;</bpt>if score { ... }<ept i="1">&lt;/c1&gt;</ept> is an error, not an implicit comparison to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文において、その条件を表すのはブール式でなければなりません ― これは<bpt i="1" x="1">&lt;c1&gt;</bpt>if score { ... }<ept i="1">&lt;/c1&gt;</ept>のようなコードがエラーになることを意味します、暗黙的なゼロとの比較はしないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In an initializer, constant properties can now only assign a value once.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある初期化において、定数プロパティは今ではただ一度しか値を割り当てることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In an initializer, subscript, or instance method, <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> refers to the current instance of the type in which it occurs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ、添え字、またはインスタンスメソッドでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>はそれが現れているところの型の現在のインスタンスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In both cases, it is written as <bpt i="1" x="1">&lt;c1&gt;</bpt>(s1: String, s2: String) -&gt; Bool<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方の場合において、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>(s1: String, s2: String) -&gt; Bool<ept i="1">&lt;/c1&gt;</ept>のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In both cases, program control is then transferred to the condition of the enclosing loop statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方の場合において、プログラム制御はそれから囲んでいるループ文の条件へ移されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In both cases, program control is then transferred to the first line of code following the enclosing loop or <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement, if any.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方の場合において、プログラム制御はそれから、もしあれば、それを囲んでいるループまたは<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文に続くコードの最初の行へ移されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In both cases, the constant <bpt i="0" x="0">&lt;c0&gt;</bpt>someArray<ept i="0">&lt;/c0&gt;</ept> is declared as an array of strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方の場合で、定数の<bpt i="0" x="0">&lt;c0&gt;</bpt>someArray<ept i="0">&lt;/c0&gt;</ept>は、文字列の配列として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In both cases, the constant <bpt i="0" x="0">&lt;c0&gt;</bpt>someDictionary<ept i="0">&lt;/c0&gt;</ept> is declared as a dictionary with strings as keys and integers as values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方の場合で、定数<bpt i="0" x="0">&lt;c0&gt;</bpt>someDictionary<ept i="0">&lt;/c0&gt;</ept>は、キーとして文字列そして値として整数を持つ辞書として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In both cases, the letter <bpt i="0" x="0">&lt;c0&gt;</bpt>é<ept i="0">&lt;/c0&gt;</ept> is represented as a single Swift <bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept> value that represents an extended grapheme cluster.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方の場合で、文字<bpt i="0" x="0">&lt;c0&gt;</bpt>é<ept i="0">&lt;/c0&gt;</ept>は、単一のスウィフトの<bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept>値として表わされます、それはひとつの拡張書記素クラスタを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In both cases, the value of the whole expression is an optional value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方の場合で、その全体の式の値は、オプショナルの値となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In both cases, the variable <bpt i="0" x="0">&lt;c0&gt;</bpt>optionalInteger<ept i="0">&lt;/c0&gt;</ept> is declared to have the type of an optional integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方の場合には、変数<bpt i="0" x="0">&lt;c0&gt;</bpt>optionalInteger<ept i="0">&lt;/c0&gt;</ept>は、オプショナル整数の型を持つと宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In both cases, you must mark the initializer implementation with the <bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept> modifier:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方の場合で、あなたはそのイニシャライザ実装を<bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept>修飾子で印しなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In both of the examples above, the type information is passed up from the leaves of the expression tree to its root.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例の両方とも、型情報は、式ツリーの葉っぱから、その根までさかのぼって渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In certain constructs, operators with a leading <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>&gt;<ept i="1">&lt;/c1&gt;</ept> may be split into two or more tokens.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特定の構造物において、先導する<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>&gt;<ept i="1">&lt;/c1&gt;</ept>をもつ演算子は、２つ以上のトークンに分割されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast to optionals, which can use the presence or absence of a value to communicate success or failure of a function, error handling allows you to determine the underlying cause of failure, and, if necessary, propagate the error to another part of your program.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルと対比して（それは値の有無を使って、ある関数の成否を伝えることができます）、エラー処理はあなたに根本的な失敗の原因を突き止めること、そして、必要ならば、そのエラーをあなたのプログラムの別の部分に伝えることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast to the <bpt i="4" x="4">&lt;c4&gt;</bpt>willSet<ept i="4">&lt;/c4&gt;</ept> observer, the old value of the variable or property is passed to the <bpt i="5" x="5">&lt;c5&gt;</bpt>didSet<ept i="5">&lt;/c5&gt;</ept> observer in case you still need access to it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>willSet<ept i="4">&lt;/c4&gt;</ept>オブザーバーと対照的に、変数またはプロパティの古い値が、あなたがまだそれへのアクセスを必要とする場合に備えて<bpt i="5" x="5">&lt;c5&gt;</bpt>didSet<ept i="5">&lt;/c5&gt;</ept>オブザーバーに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast with <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statements in C and Objective-C, <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statements in Swift do not fall through the bottom of each case and into the next one by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>CおよびObjective-Cの<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文とは対照的に、スウィフトの<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文は、なにもしなくても、各ケース節の底を突き抜けて次のものに行ったりしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast with generic types, you don’t specify a generic argument clause when you use a generic function or initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体型と対照的に、あなたが総称体の関数やイニシャライザを使うとき、あなたは総称体引数節を指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, <bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept> can’t be compared, which means tuples that contain a Boolean value can’t be compared.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対照的に、<bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept>は比較されることができません、それはブール値を含むタプルは比較されることができないのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, <bpt i="4" x="4">&lt;c4&gt;</bpt>newString<ept i="4">&lt;/c4&gt;</ept> is a string—when it’s created from the substring, it has its own storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対照的に、<bpt i="4" x="4">&lt;c4&gt;</bpt>newString<ept i="4">&lt;/c4&gt;</ept>は文字列です — それが下位文字列から作成されるとき、それはそれ独自のストレージを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, both lines of <bpt i="4" x="4">&lt;c4&gt;</bpt>goodStart<ept i="4">&lt;/c4&gt;</ept> end with a line break, so when it’s combined with <bpt i="5" x="5">&lt;c5&gt;</bpt>end<ept i="5">&lt;/c5&gt;</ept> the result has three lines, as expected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対照的に、<bpt i="4" x="4">&lt;c4&gt;</bpt>goodStart<ept i="4">&lt;/c4&gt;</ept>の行は両方とも改行で終わります、それでそれが<bpt i="5" x="5">&lt;c5&gt;</bpt>end<ept i="5">&lt;/c5&gt;</ept>と結合される場合その結果は３行になります、予想通りに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, the closure passed to <bpt i="4" x="4">&lt;c4&gt;</bpt>someFunctionWithNonescapingClosure(_:)<ept i="4">&lt;/c4&gt;</ept> is a nonescaping closure, which means it can refer to <bpt i="5" x="5">&lt;c5&gt;</bpt>self<ept i="5">&lt;/c5&gt;</ept> implicitly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対照的に、<bpt i="4" x="4">&lt;c4&gt;</bpt>someFunctionWithNonescapingClosure(_:)<ept i="4">&lt;/c4&gt;</ept>に渡されるクロージャは非脱出クロージャです、それは、それが<bpt i="5" x="5">&lt;c5&gt;</bpt>self<ept i="5">&lt;/c5&gt;</ept>を暗黙的に参照できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, the constants and variables created with a <bpt i="2" x="2">&lt;c2&gt;</bpt>guard<ept i="2">&lt;/c2&gt;</ept> statement are available in the lines of code that follow the <bpt i="3" x="3">&lt;c3&gt;</bpt>guard<ept i="3">&lt;/c3&gt;</ept> statement, as described in <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Early Exit<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対照的に、<bpt i="2" x="2">&lt;c2&gt;</bpt>guard<ept i="2">&lt;/c2&gt;</ept>文で作成された定数と変数は、その<bpt i="3" x="3">&lt;c3&gt;</bpt>guard<ept i="3">&lt;/c3&gt;</ept>文以降のコード行において利用可能です、<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>早期退出<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>において議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, there is only one variable named <bpt i="8" x="8">&lt;c8&gt;</bpt>b<ept i="8">&lt;/c8&gt;</ept>—the <bpt i="9" x="9">&lt;c9&gt;</bpt>b<ept i="9">&lt;/c9&gt;</ept> in the outer scope—so changes from inside or outside the closure are visible in both places.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対照的に、<bpt i="8" x="8">&lt;c8&gt;</bpt>b<ept i="8">&lt;/c8&gt;</ept>と名前を付けられるただ１つだけの変数があります ― 外側のスコープの中の<bpt i="9" x="9">&lt;c9&gt;</bpt>b<ept i="9">&lt;/c9&gt;</ept> ― それでクロージャ内部および外部からの変更は、両方の場所で見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, use an unowned reference when the other instance has the same lifetime or a longer lifetime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対照的に、非所有参照を他のインスタンスが同じ生涯またはより長い生涯を持つ場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, when creating a selector for a property’s setter, the <bpt i="1" x="1">&lt;e1&gt;</bpt>property name<ept i="1">&lt;/e1&gt;</ept> must be a reference to a variable property only.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対照的に、プロパティのセッターのためのセレクタを作成するとき、<bpt i="1" x="1">&lt;e1&gt;</bpt>property name<ept i="1">&lt;/e1&gt;</ept>は必ず変数プロパティへの参照でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, without parentheses, <bpt i="2" x="2">&lt;c2&gt;</bpt>(Int, Int) -&gt; Void<ept i="2">&lt;/c2&gt;</ept> is the type of a function that takes two <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> parameters and doesn’t return any value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対して、丸括弧なしで、<bpt i="2" x="2">&lt;c2&gt;</bpt>(Int, Int) -&gt; Void<ept i="2">&lt;/c2&gt;</ept>は、２つの<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>パラメータを取り、何ら値を返さない関数の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In dot syntax, you write the property name immediately after the instance name, separated by a period (<bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept>), without any spaces:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ドット構文において、あなたはプロパティ名をインスタンス名の直後に、終止符（<bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept>）で区切り、どんな空白もなしで、書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In each case, a new copy of the existing <bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept> value is created, and the new copy is passed or assigned, not the original version.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれの場合において、既存の<bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept>値の新しいコピーがつくられます、そしてその新しいコピーが渡されるか代入されます、元々のものではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In each case, the type parameter is replaced with an <bpt i="3" x="3">&lt;e3&gt;</bpt>actual<ept i="3">&lt;/e3&gt;</ept> type whenever the function is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれの場合において、型パラメータは、その関数が呼ばれるときはいつでも<bpt i="3" x="3">&lt;e3&gt;</bpt>実際の<ept i="3">&lt;/e3&gt;</ept>型と取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In each form, the name of the operator can contain only the operator characters defined in <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Operators<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各形式において、演算子の名前は<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>演算子<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>で定義される演算子文字だけを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In each form, the opening and closing braces are required.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各形式で、開始と終了の波括弧は必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In either case, if you delegate to another initializer that causes initialization to fail, the entire initialization process fails immediately, and no further initialization code is executed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どちらの場合においても、あなたが初期化失敗の原因となる別のイニシャライザに委任するならば、全体の初期化プロセスは直ちに失敗します、そしてそれ以上初期化コードが実行されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In either case, the value of the postfix expression is still of an optional type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いずれにせよ、接尾辞式の値は、依然としてオプショナル型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In either case, these accesses cause the closure to “capture” <bpt i="2" x="2">&lt;c2&gt;</bpt>self<ept i="2">&lt;/c2&gt;</ept>, creating a strong reference cycle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いずれにせよ、これらのアクセスは、クロージャが強い参照循環をつくって<bpt i="2" x="2">&lt;c2&gt;</bpt>self<ept i="2">&lt;/c2&gt;</ept>を「捕獲する」ことを引き起こします</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In essence, it’s the same problem as above—two strong references are keeping each other alive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>本質において、それは上記と同じ問題です ― ２つの強い参照が、お互いを生かし続けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In fact, <bpt i="1" x="1">&lt;c1&gt;</bpt>someFunction()<ept i="1">&lt;/c1&gt;</ept> won’t compile as written below:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実際、<bpt i="1" x="1">&lt;c1&gt;</bpt>someFunction()<ept i="1">&lt;/c1&gt;</ept>は以下のように書かれるときコンパイルしないでしょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In fact, all of the basic types in Swift—integers, floating-point numbers, Booleans, strings, arrays and dictionaries—are value types, and are implemented as structures behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実際、スウィフトにおける基本の型の全て ― 整数、浮動小数点数、ブール、文字列、配列および辞書 ― は、値型であり、そして舞台裏では構造体として実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In fact, if the <bpt i="2" x="2">&lt;e2&gt;</bpt>first<ept i="2">&lt;/e2&gt;</ept> value is <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>, the second value won’t even be evaluated, because it can’t possibly make the overall expression equate to <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実際には、<bpt i="2" x="2">&lt;e2&gt;</bpt>最初の<ept i="2">&lt;/e2&gt;</ept>値が<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>ならば、２番目の値は評価されさえしません、なぜならそれがどうやっても式全体を<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>と等しくすることが出来ないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In fact, in cases where there isn’t a meaningful raw value, you don’t have to provide one.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実際、意味がある生の値がない状況の場合には、あなたはそれを提供する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In fact, the point (0, 0) could match all <bpt i="1" x="1">&lt;e1&gt;</bpt>four<ept i="1">&lt;/e1&gt;</ept> of the cases in this example.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実際、点(0, 0)は、この例ではケース節の<bpt i="1" x="1">&lt;e1&gt;</bpt>４つ<ept i="1">&lt;/e1&gt;</ept>全てに適合することができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In fact, you’ve been using generics throughout the <bpt i="0" x="0">&lt;e0&gt;</bpt>Language Guide<ept i="0">&lt;/e0&gt;</ept>, even if you didn’t realize it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実際、たとえあなたがそれを実感しなかったとしても、あなたはこの<bpt i="0" x="0">&lt;e0&gt;</bpt>言語ガイド<ept i="0">&lt;/e0&gt;</ept>を通して総称体を使用していました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In its general form, the availability condition takes a list of platform names and versions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それの一般的な形式において、有効性条件はプラットホーム名とバージョンを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In its simplest form, a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement compares a value against one or more values of the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その最も単純な形式では、<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文は、ある値を、同じ型の一つ以上の値に対して比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In its simplest form, a stored property is a constant or variable that is stored as part of an instance of a particular class or structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その最も単純な形式で、保存プロパティは、特定のクラスまたは構造体のあるひとつのインスタンスの一部として保存される定数または変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In its simplest form, an initializer is like an instance method with no parameters, written using the <bpt i="1" x="1">&lt;c1&gt;</bpt>init<ept i="1">&lt;/c1&gt;</ept> keyword:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その最も単純な形式では、イニシャライザはパラメータのないインスタンスメソッドのようです、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>init<ept i="1">&lt;/c1&gt;</ept>キーワードを使用して書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In its simplest form, the <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement has a single <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept> condition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その最も単純な形式において、<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文はただ１つだけの<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>条件を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In most cases, this means that memory management “just works” in Swift, and you do not need to think about memory management yourself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの場合、これは、スウィフトにおいてメモリ管理が「正確に機能する」こと、そしてあなたはあなた自身でメモリ管理について考える必要がないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In most cases, tokens are generated from the characters of a Swift source file by considering the longest possible substring from the input text, within the constraints of the grammar that are specified below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの場合、トークンは、スウィフトのソースファイルの文字から、下で指定される文法の制約の範囲内で、その入力テキストからの最も長く取ることのできる下位文字列を考慮することによって生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In most cases, type parameters have descriptive names, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Value<ept i="1">&lt;/c1&gt;</ept> in <bpt i="2" x="2">&lt;c2&gt;</bpt>Dictionary&lt;Key, Value&gt;<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept> in <bpt i="4" x="4">&lt;c4&gt;</bpt>Array&lt;Element&gt;<ept i="4">&lt;/c4&gt;</ept>, which tells the reader about the relationship between the type parameter and the generic type or function it’s used in.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの場合には、型パラメータは描写的な名前を持ちます、たとえば<bpt i="2" x="2">&lt;c2&gt;</bpt>Dictionary&lt;Key, Value&gt;<ept i="2">&lt;/c2&gt;</ept>における<bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Value<ept i="1">&lt;/c1&gt;</ept>および<bpt i="4" x="4">&lt;c4&gt;</bpt>Array&lt;Element&gt;<ept i="4">&lt;/c4&gt;</ept>における<bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept>など、それは読み手に型パラメータとそれがその中で使われる総称体型や関数との関係について語ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In most cases, you don’t need to pick a specific size of integer to use in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの場合、あなたはあなたのコードにおいて使用するのに整数の特定のサイズを選択する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order for this rule to be satisfied, a designated initializer must make sure that all of its own properties are initialized before it hands off up the chain.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この規則が満たされるために、指定イニシャライザは、それがその連鎖を上って手渡す前に、それ自身のプロパティの全てが初期化されることを確認しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to work with them as their native type, you need to <bpt i="6" x="6">&lt;e6&gt;</bpt>check<ept i="6">&lt;/e6&gt;</ept> their type, or <bpt i="7" x="7">&lt;e7&gt;</bpt>downcast<ept i="7">&lt;/e7&gt;</ept> them to a different type, as described below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらをそれらの生来の型として取り扱うために、下で述べるように、あなたはそれらの型を<bpt i="6" x="6">&lt;e6&gt;</bpt>調べる<ept i="6">&lt;/e6&gt;</ept>こと、またはそれらを異なる型へ<bpt i="7" x="7">&lt;e7&gt;</bpt>ダウンキャスト<ept i="7">&lt;/e7&gt;</ept>することが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In other words, the following two declarations are equivalent:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>言い換えると、以下の２つの宣言は、等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, a protocol can declare that conforming types must implement certain properties, methods, initializers, and subscripts.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に、プロトコルは、準拠している型が特定のプロパティ、メソッド、イニシャライザ、そして添え字を実装しなければならないと宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, the <bpt i="3" x="3">&lt;e3&gt;</bpt>raw-value type<ept i="3">&lt;/e3&gt;</ept> must conform to the <bpt i="4" x="4">&lt;c4&gt;</bpt>Equatable<ept i="4">&lt;/c4&gt;</ept> protocol and one of the following protocols: <bpt i="5" x="5">&lt;c5&gt;</bpt>ExpressibleByIntegerLiteral<ept i="5">&lt;/c5&gt;</ept> for integer literals, <bpt i="6" x="6">&lt;c6&gt;</bpt>ExpressibleByFloatLiteral<ept i="6">&lt;/c6&gt;</ept> for floating-point literals, <bpt i="7" x="7">&lt;c7&gt;</bpt>ExpressibleByStringLiteral<ept i="7">&lt;/c7&gt;</ept> for string literals that contain any number of characters, and <bpt i="8" x="8">&lt;c8&gt;</bpt>ExpressibleByUnicodeScalarLiteral<ept i="8">&lt;/c8&gt;</ept> or <bpt i="9" x="9">&lt;c9&gt;</bpt>ExpressibleByExtendedGraphemeClusterLiteral<ept i="9">&lt;/c9&gt;</ept> for string literals that contain only a single character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に、<bpt i="3" x="3">&lt;e3&gt;</bpt>生の値型<ept i="3">&lt;/e3&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt>Equatable<ept i="4">&lt;/c4&gt;</ept>プロトコルおよび次のプロトコルの内の１つに準拠しなければなりません：整数リテラルのための<bpt i="5" x="5">&lt;c5&gt;</bpt>ExpressibleByIntegerLiteral<ept i="5">&lt;/c5&gt;</ept>、浮動小数点リテラルのための<bpt i="6" x="6">&lt;c6&gt;</bpt>ExpressibleByFloatLiteral<ept i="6">&lt;/c6&gt;</ept>、随意の数の文字を含む文字列リテラルのための<bpt i="7" x="7">&lt;c7&gt;</bpt>ExpressibleByStringLiteral<ept i="7">&lt;/c7&gt;</ept>、そしてただ１つの文字だけを含む文字列リテラルのための<bpt i="8" x="8">&lt;c8&gt;</bpt>ExpressibleByUnicodeScalarLiteral<ept i="8">&lt;/c8&gt;</ept>または<bpt i="9" x="9">&lt;c9&gt;</bpt>ExpressibleByExtendedGraphemeClusterLiteral<ept i="9">&lt;/c9&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In particular, the order you insert items into a <bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept> doesn’t define the order they are iterated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に、あなたが<bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept>へと項目を挿入する順序はそれらが反復される順序を定義しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In practice, this means that most custom data constructs should be classes, not structures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実際問題として、これは、ほとんどのあつらえのデータ構造はクラスでなければならないことを意味します、構造体ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In practice, this means that you do not need to write initializer overrides in many common scenarios, and can inherit your superclass initializers with minimal effort whenever it is safe to do so.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実際問題として、これは、あなたが多くの通常の状況ではイニシャライザのオーバーライドを書く必要がなく、そしてそれが安全にそうできる時はいつでも最小の努力であなたのスーパークラスのイニシャライザを継承することができることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In practice, you don’t need to write <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> in your code very often.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実際問題として、あなたは頻繁にあなたのコードに<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>を書く必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In production builds, the condition inside an assertion isn’t evaluated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロダクションビルドでは、表明内の条件は評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In situations where either type would be appropriate, <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept> is preferred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どちらの型でも適切である状況では、<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>が望ましいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In some cases, this requirement is satisfied by inheriting one or more designated initializers from a superclass, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Automatic Initializer Inheritance<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>若干の場合には、この必要条件は、下記の<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>自動的なイニシャライザ継承<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、あるスーパークラスから一つ以上の指定イニシャライザを継承することによって満たされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In some situations, you might not want to use closed ranges, which include both endpoints.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じ状況において、あなたは完結範囲を使いたいと思うかもしれません、それは両方の終端を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In systems that use garbage collection, weak pointers are sometimes used to implement a simple caching mechanism because objects with no strong references are deallocated only when memory pressure triggers garbage collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ガベージコレクションを使うシステムにおいて、時おり弱いポインタが簡単なキャッシュの仕組みを実装するために使われます、なぜなら強い参照を持たないオブジェクトは、メモリの逼迫がガベージコレクションを引き起こす時のみに割り当て解除されるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In that context, <bpt i="2" x="2">&lt;c2&gt;</bpt>Self<ept i="2">&lt;/c2&gt;</ept> refers to the eventual type that conforms to the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その文脈で、<bpt i="2" x="2">&lt;c2&gt;</bpt>Self<ept i="2">&lt;/c2&gt;</ept>はそのプロトコルに準拠する結果として生じる型に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the <bpt i="0" x="0">&lt;c0&gt;</bpt>Apartment<ept i="0">&lt;/c0&gt;</ept> example above, it’s appropriate for an apartment to be able to have no tenant at some point in its lifetime, and so a weak reference is an appropriate way to break the reference cycle in this case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="0" x="0">&lt;c0&gt;</bpt>Apartment<ept i="0">&lt;/c0&gt;</ept>例において、あるアパートがその生涯のどこかの時点で賃借人がいないことがあるというのは妥当です、なのでこの場合は弱い参照が参照循環を壊す適切な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the <bpt i="0" x="0">&lt;c0&gt;</bpt>CompassPoint<ept i="0">&lt;/c0&gt;</ept> example above, <bpt i="1" x="1">&lt;c1&gt;</bpt>north<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>south<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>east<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>west<ept i="4">&lt;/c4&gt;</ept> do not implicitly equal <bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>1<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>2<ept i="7">&lt;/c7&gt;</ept> and <bpt i="8" x="8">&lt;c8&gt;</bpt>3<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="0" x="0">&lt;c0&gt;</bpt>CompassPoint<ept i="0">&lt;/c0&gt;</ept>例で、<bpt i="1" x="1">&lt;c1&gt;</bpt>north<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>south<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>east<ept i="3">&lt;/c3&gt;</ept>そして<bpt i="4" x="4">&lt;c4&gt;</bpt>west<ept i="4">&lt;/c4&gt;</ept>は、暗黙のうちに<bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>1<ept i="6">&lt;/c6&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>2<ept i="7">&lt;/c7&gt;</ept>そして<bpt i="8" x="8">&lt;c8&gt;</bpt>3<ept i="8">&lt;/c8&gt;</ept>に等しくはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the <bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoValues(_:_:)<ept i="0">&lt;/c0&gt;</ept> example above, the placeholder type <bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept> is an example of a <bpt i="2" x="2">&lt;e2&gt;</bpt>type parameter<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoValues(_:_:)<ept i="0">&lt;/c0&gt;</ept>例で、プレースホルダ型<bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>は<bpt i="2" x="2">&lt;e2&gt;</bpt>型パラメータ<ept i="2">&lt;/e2&gt;</ept>の一例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the <bpt i="2" x="2">&lt;c2&gt;</bpt>welcomeMessage<ept i="2">&lt;/c2&gt;</ept> example above, no initial value is provided, and so the type of the <bpt i="3" x="3">&lt;c3&gt;</bpt>welcomeMessage<ept i="3">&lt;/c3&gt;</ept> variable is specified with a type annotation rather than being inferred from an initial value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="2" x="2">&lt;c2&gt;</bpt>welcomeMessage<ept i="2">&lt;/c2&gt;</ept>の例では、初期値が提供されません、それで<bpt i="3" x="3">&lt;c3&gt;</bpt>welcomeMessage<ept i="3">&lt;/c3&gt;</ept>変数の型は、最初の値から推論されるのではなく、型注釈で指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the <bpt i="5" x="5">&lt;c5&gt;</bpt>repeat<ept i="5">&lt;/c5&gt;</ept>-<bpt i="6" x="6">&lt;c6&gt;</bpt>while<ept i="6">&lt;/c6&gt;</ept> loop above, <bpt i="7" x="7">&lt;c7&gt;</bpt>square += board[square]<ept i="7">&lt;/c7&gt;</ept> is always executed <bpt i="8" x="8">&lt;e8&gt;</bpt>immediately after<ept i="8">&lt;/e8&gt;</ept> the loop’s <bpt i="9" x="9">&lt;c9&gt;</bpt>while<ept i="9">&lt;/c9&gt;</ept> condition confirms that <bpt i="10" x="10">&lt;c10&gt;</bpt>square<ept i="10">&lt;/c10&gt;</ept> is still on the board.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="5" x="5">&lt;c5&gt;</bpt>repeat<ept i="5">&lt;/c5&gt;</ept>-<bpt i="6" x="6">&lt;c6&gt;</bpt>while<ept i="6">&lt;/c6&gt;</ept>ループにおいて、<bpt i="7" x="7">&lt;c7&gt;</bpt>square += board[square]<ept i="7">&lt;/c7&gt;</ept>は常に、このループの<bpt i="9" x="9">&lt;c9&gt;</bpt>while<ept i="9">&lt;/c9&gt;</ept>条件が<bpt i="10" x="10">&lt;c10&gt;</bpt>square<ept i="10">&lt;/c10&gt;</ept>はまだ盤上かを確認した<bpt i="8" x="8">&lt;e8&gt;</bpt>直後<ept i="8">&lt;/e8&gt;</ept>に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the above example, <bpt i="0" x="0">&lt;c0&gt;</bpt>approximateCount<ept i="0">&lt;/c0&gt;</ept> is evaluated in a <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、<bpt i="0" x="0">&lt;c0&gt;</bpt>approximateCount<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文において評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the above example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>buyFavoriteSnack(person:vendingMachine:)<ept i="0">&lt;/c0&gt;</ept> function is called in a <bpt i="1" x="1">&lt;c1&gt;</bpt>try<ept i="1">&lt;/c1&gt;</ept> expression, because it can throw an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>buyFavoriteSnack(person:vendingMachine:)<ept i="0">&lt;/c0&gt;</ept>関数は<bpt i="1" x="1">&lt;c1&gt;</bpt>try<ept i="1">&lt;/c1&gt;</ept>式の中で呼び出されます、それがエラーをスローできるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the above example, the raw value of <bpt i="0" x="0">&lt;c0&gt;</bpt>ExampleEnum.a<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept> and the value of <bpt i="2" x="2">&lt;c2&gt;</bpt>ExampleEnum.b<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上記の例で、<bpt i="0" x="0">&lt;c0&gt;</bpt>ExampleEnum.a<ept i="0">&lt;/c0&gt;</ept>の値は<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>です、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>ExampleEnum.b<ept i="2">&lt;/c2&gt;</ept>の値は<bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the above example, the raw value of <bpt i="0" x="0">&lt;c0&gt;</bpt>GamePlayMode.cooperative<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>"cooperative"<ept i="1">&lt;/c1&gt;</ept>, the raw value of <bpt i="2" x="2">&lt;c2&gt;</bpt>GamePlayMode.individual<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>"individual"<ept i="3">&lt;/c3&gt;</ept>, and the raw value of <bpt i="4" x="4">&lt;c4&gt;</bpt>GamePlayMode.competitive<ept i="4">&lt;/c4&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>"competitive"<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上記の例で、<bpt i="0" x="0">&lt;c0&gt;</bpt>GamePlayMode.cooperative<ept i="0">&lt;/c0&gt;</ept>の生の値は<bpt i="1" x="1">&lt;c1&gt;</bpt>"cooperative"<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>GamePlayMode.individual<ept i="2">&lt;/c2&gt;</ept>の生の値は<bpt i="3" x="3">&lt;c3&gt;</bpt>"individual"<ept i="3">&lt;/c3&gt;</ept>、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>GamePlayMode.competitive<ept i="4">&lt;/c4&gt;</ept>の生の値は<bpt i="5" x="5">&lt;c5&gt;</bpt>"competitive"<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the body of the function, the copy is modified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数の本体において、そのコピーが修正されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the case of the <bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept> method, the purpose of the closure is clear from the fact that sorting is taking place, and it is safe for a reader to assume that the closure is likely to be working with <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> values, because it is assisting with the sorting of an array of strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept>メソッドの場合、クロージャの目的はソートが行われているという事実から明快です、そして、読者がクロージャは<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値を扱っているようだと仮定しても差し支えありません、なぜならそれがいくつかの文字列からなる配列のソートを手伝っているからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the case where it equals <bpt i="1" x="1">&lt;c1&gt;</bpt>.north<ept i="1">&lt;/c1&gt;</ept>, print <bpt i="2" x="2">&lt;c2&gt;</bpt>"Lots of planets have a north"<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが<bpt i="1" x="1">&lt;c1&gt;</bpt>.north<ept i="1">&lt;/c1&gt;</ept>に等しい場合には、<bpt i="2" x="2">&lt;c2&gt;</bpt>"Lots of planets have a north"<ept i="2">&lt;/c2&gt;</ept>を出力する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the case where it equals <bpt i="3" x="3">&lt;c3&gt;</bpt>.south<ept i="3">&lt;/c3&gt;</ept>, print <bpt i="4" x="4">&lt;c4&gt;</bpt>"Watch out for penguins"<ept i="4">&lt;/c4&gt;</ept>.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが<bpt i="3" x="3">&lt;c3&gt;</bpt>.south<ept i="3">&lt;/c3&gt;</ept>に等しい場合には、<bpt i="4" x="4">&lt;c4&gt;</bpt>"Watch out for penguins"<ept i="4">&lt;/c4&gt;</ept>を出力する。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the code above, concatenating <bpt i="0" x="0">&lt;c0&gt;</bpt>badStart<ept i="0">&lt;/c0&gt;</ept> with <bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept> produces a two-line string, which isn’t the desired result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上のコードにおいて、<bpt i="0" x="0">&lt;c0&gt;</bpt>badStart<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>と連結することは、２行の文字列を生成します、それは望んだ結果ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the code above, instead of calling the closure passed to it as its <bpt i="0" x="0">&lt;c0&gt;</bpt>customerProvider<ept i="0">&lt;/c0&gt;</ept> argument, the <bpt i="1" x="1">&lt;c1&gt;</bpt>collectCustomerProviders(_:)<ept i="1">&lt;/c1&gt;</ept> function appends the closure to the <bpt i="2" x="2">&lt;c2&gt;</bpt>customerProviders<ept i="2">&lt;/c2&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上のコードにおいて、それの<bpt i="0" x="0">&lt;c0&gt;</bpt>customerProvider<ept i="0">&lt;/c0&gt;</ept>引数としてそれに渡されるクロージャを呼び出す代わりに、<bpt i="1" x="1">&lt;c1&gt;</bpt>collectCustomerProviders(_:)<ept i="1">&lt;/c1&gt;</ept>関数は、そのクロージャを<bpt i="2" x="2">&lt;c2&gt;</bpt>customerProviders<ept i="2">&lt;/c2&gt;</ept>配列に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the code below, <bpt i="3" x="3">&lt;c3&gt;</bpt>john<ept i="3">&lt;/c3&gt;</ept> has a <bpt i="4" x="4">&lt;c4&gt;</bpt>residence<ept i="4">&lt;/c4&gt;</ept> property value of <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下記のコードにおいて、<bpt i="3" x="3">&lt;c3&gt;</bpt>john<ept i="3">&lt;/c3&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>の<bpt i="4" x="4">&lt;c4&gt;</bpt>residence<ept i="4">&lt;/c4&gt;</ept>プロパティ値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the code example below, the dictionary’s keys are decomposed into a constant called <bpt i="4" x="4">&lt;c4&gt;</bpt>animalName<ept i="4">&lt;/c4&gt;</ept>, and the dictionary’s values are decomposed into a constant called <bpt i="5" x="5">&lt;c5&gt;</bpt>legCount<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下のコード例において、辞書のキーは<bpt i="4" x="4">&lt;c4&gt;</bpt>animalName<ept i="4">&lt;/c4&gt;</ept>と呼ばれる定数へと分解されます、そして辞書の値は<bpt i="5" x="5">&lt;c5&gt;</bpt>legCount<ept i="5">&lt;/c5&gt;</ept>と呼ばれる定数へと分解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the context of <bpt i="2" x="2">&lt;c2&gt;</bpt>Vector2D<ept i="2">&lt;/c2&gt;</ept>, it makes sense to consider “equal” as meaning “both instances have the same <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept> values and <bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept> values”, and so this is the logic used by the operator implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Vector2D<ept i="2">&lt;/c2&gt;</ept>の文脈では、「同等」を「両方のインスタンスが同じ<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>値と<bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept>値を持つ」ことを意味すると考えるのが道理にかなっています、なのでそれが演算子実装によって使われる論理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the door access example above, it’s useful to add parentheses around the first part of the compound expression to make its intent explicit:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上のドア・アクセスの例で、その意図を明確にするために複合式の最初の部分のまわりに丸括弧を加えることは、役に立ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, <bpt i="0" x="0">&lt;c0&gt;</bpt>Ace<ept i="0">&lt;/c0&gt;</ept> is explicitly given a raw value of <bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>, and the rest of the raw values are assigned in order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例では、<bpt i="0" x="0">&lt;c0&gt;</bpt>Ace<ept i="0">&lt;/c0&gt;</ept>は暗黙的に<bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>の生の値を与えられます、そして残りの生の値は順に割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, <bpt i="0" x="0">&lt;c0&gt;</bpt>CompassPoint.south<ept i="0">&lt;/c0&gt;</ept> has an implicit raw value of <bpt i="1" x="1">&lt;c1&gt;</bpt>"south"<ept i="1">&lt;/c1&gt;</ept>, and so on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>CompassPoint.south<ept i="0">&lt;/c0&gt;</ept>は暗黙的な生の値の<bpt i="1" x="1">&lt;c1&gt;</bpt>"south"<ept i="1">&lt;/c1&gt;</ept>をもちます、等々。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, <bpt i="0" x="0">&lt;c0&gt;</bpt>Planet.mercury<ept i="0">&lt;/c0&gt;</ept> has an explicit raw value of <bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Planet.venus<ept i="2">&lt;/c2&gt;</ept> has an implicit raw value of <bpt i="3" x="3">&lt;c3&gt;</bpt>2<ept i="3">&lt;/c3&gt;</ept>, and so on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>Planet.mercury<ept i="0">&lt;/c0&gt;</ept>は明示的な生の値の<bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>を持ちます、<bpt i="2" x="2">&lt;c2&gt;</bpt>Planet.venus<ept i="2">&lt;/c2&gt;</ept>は暗黙的な生の値の<bpt i="3" x="3">&lt;c3&gt;</bpt>2<ept i="3">&lt;/c3&gt;</ept>を持ちます、等々。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, <bpt i="0" x="0">&lt;c0&gt;</bpt>SomeClassOnlyProtocol<ept i="0">&lt;/c0&gt;</ept> can only be adopted by class types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、<bpt i="0" x="0">&lt;c0&gt;</bpt>SomeClassOnlyProtocol<ept i="0">&lt;/c0&gt;</ept>はクラス型によってのみ採用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, <bpt i="0" x="0">&lt;c0&gt;</bpt>greeting<ept i="0">&lt;/c0&gt;</ept> is a string, which means it has a region of memory where the characters that make up the string are stored.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>greeting<ept i="0">&lt;/c0&gt;</ept>は文字列です、それはその文字列を作り上げる文字が格納されるところのメモリ領域をそれが持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, <bpt i="0" x="0">&lt;c0&gt;</bpt>incrementBySeven<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>incrementByTen<ept i="1">&lt;/c1&gt;</ept> are constants, but the closures these constants refer to are still able to increment the <bpt i="2" x="2">&lt;c2&gt;</bpt>runningTotal<ept i="2">&lt;/c2&gt;</ept> variables that they have captured.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、<bpt i="0" x="0">&lt;c0&gt;</bpt>incrementBySeven<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>incrementByTen<ept i="1">&lt;/c1&gt;</ept>は定数です、しかしこれらの定数が言及するクロージャはそれでもなお、それらが捕獲した<bpt i="2" x="2">&lt;c2&gt;</bpt>runningTotal<ept i="2">&lt;/c2&gt;</ept>変数を増加させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, <bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept> is a constant whose value is automatically set at the start of each iteration of the loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、<bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept>は、ループの各繰り返しの開始時点でその値が自動的に設定される定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, <bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept> distributes to each identifier pattern in the tuple pattern <bpt i="1" x="1">&lt;c1&gt;</bpt>(x, y)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、<bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept>は、タプルパターン<bpt i="1" x="1">&lt;c1&gt;</bpt>(x, y)<ept i="1">&lt;/c1&gt;</ept>における各識別子パターンに分配されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, <bpt i="2" x="2">&lt;c2&gt;</bpt>possiblePlanet<ept i="2">&lt;/c2&gt;</ept> is of type <bpt i="3" x="3">&lt;c3&gt;</bpt>Planet?<ept i="3">&lt;/c3&gt;</ept>, or “optional <bpt i="4" x="4">&lt;c4&gt;</bpt>Planet<ept i="4">&lt;/c4&gt;</ept>.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、<bpt i="2" x="2">&lt;c2&gt;</bpt>possiblePlanet<ept i="2">&lt;/c2&gt;</ept>は型<bpt i="3" x="3">&lt;c3&gt;</bpt>Planet?<ept i="3">&lt;/c3&gt;</ept>、すなわち「オプショナルの<bpt i="4" x="4">&lt;c4&gt;</bpt>Planet<ept i="4">&lt;/c4&gt;</ept>」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, <bpt i="3" x="3">&lt;c3&gt;</bpt>length<ept i="3">&lt;/c3&gt;</ept> is initialized when the new range is created and cannot be changed thereafter, because it is a constant property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、<bpt i="3" x="3">&lt;c3&gt;</bpt>length<ept i="3">&lt;/c3&gt;</ept>は新しい範囲が作成される時に初期化されます、そしてその後は変更されることが出来ません、なぜならそれが変数プロパティだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, an empty string (<bpt i="5" x="5">&lt;c5&gt;</bpt>""<ept i="5">&lt;/c5&gt;</ept>) is a valid, nonoptional <bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例において、空の文字列（<bpt i="5" x="5">&lt;c5&gt;</bpt>""<ept i="5">&lt;/c5&gt;</ept>）は有効な、オプショナルでない<bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, even though the entire multiline string literal is indented, the first and last lines in the string don’t begin with any whitespace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例において、たとえ複数行リテラル全体が字下げされるとしても、その文字列の最初と最後の行は全く空白で始まりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, it is guaranteed that <bpt i="2" x="2">&lt;c2&gt;</bpt>number % 10<ept i="2">&lt;/c2&gt;</ept> will always be a valid subscript key for the <bpt i="3" x="3">&lt;c3&gt;</bpt>digitNames<ept i="3">&lt;/c3&gt;</ept> dictionary, and so an exclamation mark is used to force-unwrap the <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept> value stored in the subscript’s optional return value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で<bpt i="2" x="2">&lt;c2&gt;</bpt>number % 10<ept i="2">&lt;/c2&gt;</ept>は常に<bpt i="3" x="3">&lt;c3&gt;</bpt>digitNames<ept i="3">&lt;/c3&gt;</ept>辞書のための有効な添え字キーであることを求められます、なのでその添え字のオプショナルの戻り値に保管した<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>値を強制アンラップするために感嘆符が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, it is the choice of closure that <bpt i="1" x="1">&lt;c1&gt;</bpt>incrementByTen<ept i="1">&lt;/c1&gt;</ept> <bpt i="2" x="2">&lt;e2&gt;</bpt>refers to<ept i="2">&lt;/e2&gt;</ept> that is constant, and not the contents of the closure itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例では、それは「クロージャの選択」です、それが<bpt i="1" x="1">&lt;c1&gt;</bpt>incrementByTen<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;e2&gt;</bpt>参照するもの<ept i="2">&lt;/e2&gt;</ept>であり、それは定数であり、そしてクロージャ自身の内容ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, the <bpt i="5" x="5">&lt;c5&gt;</bpt>allItemsMatch(_:_:)<ept i="5">&lt;/c5&gt;</ept> function correctly reports that all of the items in the two containers match.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、<bpt i="5" x="5">&lt;c5&gt;</bpt>allItemsMatch(_:_:)<ept i="5">&lt;/c5&gt;</ept>関数は、２つのコンテナの中の項目の全てが一致すると正しく報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, the <bpt i="5" x="5">&lt;c5&gt;</bpt>description<ept i="5">&lt;/c5&gt;</ept> property correctly reports that the Ace of Spades has a value of <bpt i="6" x="6">&lt;c6&gt;</bpt>1<ept i="6">&lt;/c6&gt;</ept> or <bpt i="7" x="7">&lt;c7&gt;</bpt>11<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、<bpt i="5" x="5">&lt;c5&gt;</bpt>description<ept i="5">&lt;/c5&gt;</ept>プロパティは、スペードのエースが<bpt i="6" x="6">&lt;c6&gt;</bpt>1<ept i="6">&lt;/c6&gt;</ept>または<bpt i="7" x="7">&lt;c7&gt;</bpt>11<ept i="7">&lt;/c7&gt;</ept>の値を持つことを正しく報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, the <bpt i="7" x="7">&lt;c7&gt;</bpt>Key<ept i="7">&lt;/c7&gt;</ept> type parameter is constrained to conform to the <bpt i="8" x="8">&lt;c8&gt;</bpt>Hashable<ept i="8">&lt;/c8&gt;</ept> protocol and therefore <bpt i="9" x="9">&lt;c9&gt;</bpt>String<ept i="9">&lt;/c9&gt;</ept> must also conform to the <bpt i="10" x="10">&lt;c10&gt;</bpt>Hashable<ept i="10">&lt;/c10&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、<bpt i="7" x="7">&lt;c7&gt;</bpt>Key<ept i="7">&lt;/c7&gt;</ept>型パラメータは、<bpt i="8" x="8">&lt;c8&gt;</bpt>Hashable<ept i="8">&lt;/c8&gt;</ept>プロトコルに準拠することを強制されます、したがって<bpt i="9" x="9">&lt;c9&gt;</bpt>String<ept i="9">&lt;/c9&gt;</ept>もまた<bpt i="10" x="10">&lt;c10&gt;</bpt>Hashable<ept i="10">&lt;/c10&gt;</ept>プロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, the compiler infers that <bpt i="0" x="0">&lt;c0&gt;</bpt>myVariable<ept i="0">&lt;/c0&gt;</ept> is an integer because its initial value is an integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、コンパイラは<bpt i="0" x="0">&lt;c0&gt;</bpt>myVariable<ept i="0">&lt;/c0&gt;</ept>が整数であると推測します、その最初の値が整数であるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, the first three decimal <bpt i="0" x="0">&lt;c0&gt;</bpt>codeUnit<ept i="0">&lt;/c0&gt;</ept> values (<bpt i="1" x="1">&lt;c1&gt;</bpt>68<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>111<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>103<ept i="3">&lt;/c3&gt;</ept>) represent the characters <bpt i="4" x="4">&lt;c4&gt;</bpt>D<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>o<ept i="5">&lt;/c5&gt;</ept>, and <bpt i="6" x="6">&lt;c6&gt;</bpt>g<ept i="6">&lt;/c6&gt;</ept>, whose UTF-8 representation is the same as their ASCII representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例において、最初の３つの10進の<bpt i="0" x="0">&lt;c0&gt;</bpt>codeUnit<ept i="0">&lt;/c0&gt;</ept>値（<bpt i="1" x="1">&lt;c1&gt;</bpt>68<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>111<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>103<ept i="3">&lt;/c3&gt;</ept>）は、文字<bpt i="4" x="4">&lt;c4&gt;</bpt>D<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>o<ept i="5">&lt;/c5&gt;</ept>、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>g<ept i="6">&lt;/c6&gt;</ept>を表わします、これらのUTF-８叙述はそれらのASCII叙述と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, the operator is used to determine an initial value for a <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept> variable called <bpt i="5" x="5">&lt;c5&gt;</bpt>colorNameToUse<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、この演算子は<bpt i="5" x="5">&lt;c5&gt;</bpt>colorNameToUse<ept i="5">&lt;/c5&gt;</ept>と呼ばれるある<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>変数の初期値を確定するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, the use of an implicitly unwrapped optional means that all of the two-phase class initializer requirements are satisfied.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、暗黙的にアンラップされるオプショナルの使用は、２段階のクラスイニシャライザの必要とする条件の全てが満たされることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, the value of <bpt i="0" x="0">&lt;c0&gt;</bpt>multiplier<ept i="0">&lt;/c0&gt;</ept> is inserted into a string literal as <bpt i="1" x="1">&lt;c1&gt;</bpt>\(multiplier)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、<bpt i="0" x="0">&lt;c0&gt;</bpt>multiplier<ept i="0">&lt;/c0&gt;</ept>の値は、文字列リテラルに<bpt i="1" x="1">&lt;c1&gt;</bpt>\(multiplier)<ept i="1">&lt;/c1&gt;</ept>として差し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, you can see the left-to-right comparison behavior on the first line.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例において、あなたは左から右への比較挙動を最初の行において見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, you place the optional chaining question mark <bpt i="0" x="0">&lt;e0&gt;</bpt>after<ept i="0">&lt;/e0&gt;</ept> the parentheses, because the optional value you are chaining on is the <bpt i="1" x="1">&lt;c1&gt;</bpt>buildingIdentifier()<ept i="1">&lt;/c1&gt;</ept> method’s return value, and not the <bpt i="2" x="2">&lt;c2&gt;</bpt>buildingIdentifier()<ept i="2">&lt;/c2&gt;</ept> method itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、あなたは丸括弧の<bpt i="0" x="0">&lt;e0&gt;</bpt>後に<ept i="0">&lt;/e0&gt;</ept>オプショナル連鎖の疑問符を置きます、なぜなら、あなたがその上に連鎖しているオプショナルの値は<bpt i="1" x="1">&lt;c1&gt;</bpt>buildingIdentifier()<ept i="1">&lt;/c1&gt;</ept>メソッドの戻り値であって、<bpt i="2" x="2">&lt;c2&gt;</bpt>buildingIdentifier()<ept i="2">&lt;/c2&gt;</ept>メソッドそれ自体ではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, class <bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept> is a public class with a file-private method called <bpt i="1" x="1">&lt;c1&gt;</bpt>someMethod()<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下記の例で、クラス<bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept>は公開のクラスです、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>someMethod()<ept i="1">&lt;/c1&gt;</ept>と呼ばれるあるファイル外非公開のメソッドを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, the <bpt i="0" x="0">&lt;c0&gt;</bpt>CompassPoint<ept i="0">&lt;/c0&gt;</ept> enumeration has an explicit access level of “public”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>CompassPoint<ept i="0">&lt;/c0&gt;</ept>列挙は明示的な「公開」のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, the <bpt i="0" x="0">&lt;c0&gt;</bpt>VendingMachine<ept i="0">&lt;/c0&gt;</ept> class has a <bpt i="1" x="1">&lt;c1&gt;</bpt>vend(itemNamed:)<ept i="1">&lt;/c1&gt;</ept> method that throws an appropriate <bpt i="2" x="2">&lt;c2&gt;</bpt>VendingMachineError<ept i="2">&lt;/c2&gt;</ept> if the requested item is not available, is out of stock, or has a cost that exceeds the current deposited amount:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>VendingMachine<ept i="0">&lt;/c0&gt;</ept>クラスは<bpt i="1" x="1">&lt;c1&gt;</bpt>vend(itemNamed:)<ept i="1">&lt;/c1&gt;</ept>メソッドを持ちます、それは、要求された項目が利用可能でない、在庫切れ、または現在預け入れされた総額を超える価格を持つならば対応する<bpt i="2" x="2">&lt;c2&gt;</bpt>VendingMachineError<ept i="2">&lt;/c2&gt;</ept>をスローします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, the constant <bpt i="0" x="0">&lt;c0&gt;</bpt>twoThousand<ept i="0">&lt;/c0&gt;</ept> is of type <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt16<ept i="1">&lt;/c1&gt;</ept>, whereas the constant <bpt i="2" x="2">&lt;c2&gt;</bpt>one<ept i="2">&lt;/c2&gt;</ept> is of type <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下記の例で、定数<bpt i="0" x="0">&lt;c0&gt;</bpt>twoThousand<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>型UInt16<ept i="1">&lt;/c1&gt;</ept>ですが、定数<bpt i="2" x="2">&lt;c2&gt;</bpt>one<ept i="2">&lt;/c2&gt;</ept>は型<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, the first <bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept> value (<bpt i="1" x="1">&lt;c1&gt;</bpt>hasDoorKey<ept i="1">&lt;/c1&gt;</ept>) is <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>, but the second value (<bpt i="3" x="3">&lt;c3&gt;</bpt>knowsOverridePassword<ept i="3">&lt;/c3&gt;</ept>) is <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下記の例で、最初の<bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept>値（<bpt i="1" x="1">&lt;c1&gt;</bpt>hasDoorKey<ept i="1">&lt;/c1&gt;</ept>）は<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>です、しかし、第二の値（<bpt i="3" x="3">&lt;c3&gt;</bpt>knowsOverridePassword<ept i="3">&lt;/c3&gt;</ept>）は<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, the values of <bpt i="0" x="0">&lt;c0&gt;</bpt>firstBits<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>otherBits<ept i="1">&lt;/c1&gt;</ept> each have a bit set to <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept> in a location that the other does not.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下記の例で、<bpt i="0" x="0">&lt;c0&gt;</bpt>firstBits<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>otherBits<ept i="1">&lt;/c1&gt;</ept>それぞれの値は、他のものがそうでない場所で、ビットを<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, the values of <bpt i="0" x="0">&lt;c0&gt;</bpt>firstSixBits<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>lastSixBits<ept i="1">&lt;/c1&gt;</ept> both have four middle bits equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下記の例で、<bpt i="0" x="0">&lt;c0&gt;</bpt>firstSixBits<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>lastSixBits<ept i="1">&lt;/c1&gt;</ept>の値は、<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>と等しい４つの中間のビットを両方とも持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, the values of <bpt i="0" x="0">&lt;c0&gt;</bpt>someBits<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>moreBits<ept i="1">&lt;/c1&gt;</ept> have different bits set to <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下記の例で、<bpt i="0" x="0">&lt;c0&gt;</bpt>someBits<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>moreBits<ept i="1">&lt;/c1&gt;</ept>の値は、<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>に設定される異なるビットを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, when <bpt i="0" x="0">&lt;c0&gt;</bpt>c<ept i="0">&lt;/c0&gt;</ept> is not <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>, its value is unwrapped and used to evaluate <bpt i="2" x="2">&lt;c2&gt;</bpt>.property<ept i="2">&lt;/c2&gt;</ept>, the value of which is used to evaluate <bpt i="3" x="3">&lt;c3&gt;</bpt>.performAction()<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下記の例で、<bpt i="0" x="0">&lt;c0&gt;</bpt>c<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>でないとき、その値はアンラップされて<bpt i="2" x="2">&lt;c2&gt;</bpt>.property<ept i="2">&lt;/c2&gt;</ept>を評価するために使われ、その値が<bpt i="3" x="3">&lt;c3&gt;</bpt>.performAction()<ept i="3">&lt;/c3&gt;</ept>を評価するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the examples above, ARC is able to track the number of references to the new <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> instance you create and to deallocate that <bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept> instance when it’s no longer needed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、ARCはあなたがつくる新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>インスタンスへの参照の数を追跡して、その<bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept>インスタンスをそれがもはや必要でないとき割り当て解除することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the expression <bpt i="1" x="1">&lt;c1&gt;</bpt>1 + 2<ept i="1">&lt;/c1&gt;</ept>, the <bpt i="2" x="2">&lt;c2&gt;</bpt>+<ept i="2">&lt;/c2&gt;</ept> symbol is a binary operator and its two operands are the values <bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>2<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>式<bpt i="1" x="1">&lt;c1&gt;</bpt>1 + 2<ept i="1">&lt;/c1&gt;</ept>において、記号<bpt i="2" x="2">&lt;c2&gt;</bpt>+<ept i="2">&lt;/c2&gt;</ept>は二項演算子です、そしてその２つの演算数は値<bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>2<ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the extension, you must implement all of the adopted protocol’s requirements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張において、あなたは採用されたプロトコルの要件の全てを実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the first case, a type identifier refers to a type alias of a named or compound type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第一の場合には、型識別子は、名前付きまたは複合の型の型エイリアスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the first case, the cluster contains a single scalar; in the second case, it’s a cluster of two scalars:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の場合では、クラスタは、ただ１つだけのスカラーを含みます；２番目の場合には、それは、２つのスカラーのクラスタ（１つの房、群れ）です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the first example, the expression <bpt i="0" x="0">&lt;c0&gt;</bpt>someTuple<ept i="0">&lt;/c0&gt;</ept> is specified to have the tuple type <bpt i="1" x="1">&lt;c1&gt;</bpt>(Double, Double)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の例で、式<bpt i="0" x="0">&lt;c0&gt;</bpt>someTuple<ept i="0">&lt;/c0&gt;</ept>は、タプル型<bpt i="1" x="1">&lt;c1&gt;</bpt>(Double, Double)<ept i="1">&lt;/c1&gt;</ept>を持つと指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the first of these two checks, the <bpt i="0" x="0">&lt;c0&gt;</bpt>didSet<ept i="0">&lt;/c0&gt;</ept> observer sets <bpt i="1" x="1">&lt;c1&gt;</bpt>currentLevel<ept i="1">&lt;/c1&gt;</ept> to a different value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの２つのチェックで最初のものにおいて、<bpt i="0" x="0">&lt;c0&gt;</bpt>didSet<ept i="0">&lt;/c0&gt;</ept>オブザーバーは、<bpt i="1" x="1">&lt;c1&gt;</bpt>currentLevel<ept i="1">&lt;/c1&gt;</ept>を異なる値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the first phase, each stored property is assigned an initial value by the class that introduced it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の段階では、各保存プロパティは、それを導入したクラスによって、初期値を代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the following example, for instance, the explicit type annotation (<bpt i="0" x="0">&lt;c0&gt;</bpt>: Float<ept i="0">&lt;/c0&gt;</ept>) on the constant <bpt i="1" x="1">&lt;c1&gt;</bpt>eFloat<ept i="1">&lt;/c1&gt;</ept> causes the numeric literal <bpt i="2" x="2">&lt;c2&gt;</bpt>2.71828<ept i="2">&lt;/c2&gt;</ept> to have an inferred type of <bpt i="3" x="3">&lt;c3&gt;</bpt>Float<ept i="3">&lt;/c3&gt;</ept> instead of <bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下の例において、定数<bpt i="1" x="1">&lt;c1&gt;</bpt>eFloat<ept i="1">&lt;/c1&gt;</ept>での明示的な型注釈（<bpt i="0" x="0">&lt;c0&gt;</bpt>: Float<ept i="0">&lt;/c0&gt;</ept>）は、数値リテラル<bpt i="2" x="2">&lt;c2&gt;</bpt>2.71828<ept i="2">&lt;/c2&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt>Float<ept i="3">&lt;/c3&gt;</ept>の推論される型を持つようにします、<bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept>ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the last example above, the <bpt i="0" x="0">&lt;c0&gt;</bpt>width<ept i="0">&lt;/c0&gt;</ept> property of the <bpt i="1" x="1">&lt;c1&gt;</bpt>resolution<ept i="1">&lt;/c1&gt;</ept> property of <bpt i="2" x="2">&lt;c2&gt;</bpt>someVideoMode<ept i="2">&lt;/c2&gt;</ept> is set directly, without your needing to set the entire <bpt i="3" x="3">&lt;c3&gt;</bpt>resolution<ept i="3">&lt;/c3&gt;</ept> property to a new value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の最後の例で、<bpt i="2" x="2">&lt;c2&gt;</bpt>someVideoMode<ept i="2">&lt;/c2&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>resolution<ept i="1">&lt;/c1&gt;</ept>プロパティの<bpt i="0" x="0">&lt;c0&gt;</bpt>width<ept i="0">&lt;/c0&gt;</ept>プロパティは直接に設定されます、あなたが<bpt i="3" x="3">&lt;c3&gt;</bpt>resolution<ept i="3">&lt;/c3&gt;</ept>プロパティ全体を新しい値に設定する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the line of code that says <bpt i="4" x="4">&lt;c4&gt;</bpt>return greeting<ept i="4">&lt;/c4&gt;</ept>, the function finishes its execution and returns the current value of <bpt i="5" x="5">&lt;c5&gt;</bpt>greeting<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>return greeting<ept i="4">&lt;/c4&gt;</ept>を告げるコード行において、関数はその実行を終えて<bpt i="5" x="5">&lt;c5&gt;</bpt>greeting<ept i="5">&lt;/c5&gt;</ept>の現在の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the previous example, it’s not easy to see that <bpt i="1" x="1">&lt;c1&gt;</bpt>someAddress<ept i="1">&lt;/c1&gt;</ept> is never evaluated, because accessing a constant doesn’t have any side effects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前の例において、<bpt i="1" x="1">&lt;c1&gt;</bpt>someAddress<ept i="1">&lt;/c1&gt;</ept>が決して評価されないというのはわかりやすいとはいえません、なぜならある定数を代入することは、何ら副作用を持たないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the second case, a type identifier uses dot (<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>) syntax to refer to named types declared in other modules or nested within other types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第二の場合には、型識別子は、他のモジュールで宣言される、または他の型の内部で入れ子にされる名前付きの型を参照するためにドット（<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>）構文を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the second example, the parameter <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept> to the function <bpt i="3" x="3">&lt;c3&gt;</bpt>someFunction<ept i="3">&lt;/c3&gt;</ept> is specified to have the type <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第二の例で関数<bpt i="3" x="3">&lt;c3&gt;</bpt>someFunction<ept i="3">&lt;/c3&gt;</ept>のためのパラメータ<bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>は、型<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>を持つ指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the setter for <bpt i="0" x="0">&lt;c0&gt;</bpt>perimeter<ept i="0">&lt;/c0&gt;</ept>, the new value has the implicit name <bpt i="1" x="1">&lt;c1&gt;</bpt>newValue<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>perimeter<ept i="0">&lt;/c0&gt;</ept>のためのセッターにおいて、新しい値は、隠された名前<bpt i="1" x="1">&lt;c1&gt;</bpt>newValue<ept i="1">&lt;/c1&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the two examples below, <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> is inferred to be <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> respectively:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の２つの例で、<bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>はそれぞれ<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>Stringで<ept i="2">&lt;/c2&gt;</ept>あると推測されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In these cases, it’s useful to remove the need to check and unwrap the optional’s value every time it’s accessed, because it can be safely assumed to have a value all of the time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの場合には、オプショナルの値をそれがアクセスされるたびに確認してアンラップする必要を無くすことは役に立ちます、なぜならそれがいつでも値を持つと安全に仮定されることが出来るためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In these cases, you can omit the value from one side of the range operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの場合、あなたは範囲演算子の１つの側から値を省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, <bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> is used as a placeholder in three places:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合、<bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>はプレースホルダとして３つの場所で使われます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, because the image is shipped with the application, no error will be thrown at runtime, so it is appropriate to disable error propagation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合、画像はアプリケーションとともに出荷されるので、エラーが実行時にスローされることはありません、それでふさわしいのはエラー伝達を抑制することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, if the <bpt i="0" x="0">&lt;c0&gt;</bpt>init(name:)<ept i="0">&lt;/c0&gt;</ept> initializer of the superclass were ever called with an empty string as the name, the forced unwrapping operation would result in a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合、スーパークラスの<bpt i="0" x="0">&lt;c0&gt;</bpt>init(name:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザがもしかその名前として空の文字列で呼び出されたならば、強制アンラップ操作は実行時エラーという結果になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, it is not possible to retrieve a planet with a position of <bpt i="5" x="5">&lt;c5&gt;</bpt>11<ept i="5">&lt;/c5&gt;</ept>, and so the <bpt i="6" x="6">&lt;c6&gt;</bpt>else<ept i="6">&lt;/c6&gt;</ept> branch is executed instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合、<bpt i="5" x="5">&lt;c5&gt;</bpt>11<ept i="5">&lt;/c5&gt;</ept>の位置で惑星を取り出すことは可能ではありません、それで<bpt i="6" x="6">&lt;c6&gt;</bpt>else<ept i="6">&lt;/c6&gt;</ept>分岐が代わりに実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, the array literal contains two <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> values and nothing else.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合、配列リテラルは、２つの<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>値を含んでいて他には何も含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, the capture list is <bpt i="2" x="2">&lt;c2&gt;</bpt>[unowned self]<ept i="2">&lt;/c2&gt;</ept>, which means “capture self as an unowned reference rather than a strong reference”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合、捕獲リストは<bpt i="2" x="2">&lt;c2&gt;</bpt>[unowned self]<ept i="2">&lt;/c2&gt;</ept>です、それは、「selfを強い参照ではなく非所有者参照として捕獲する」ことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, the expression is written as <bpt i="3" x="3">&lt;c3&gt;</bpt>\(Double(multiplier) * 2.5)<ept i="3">&lt;/c3&gt;</ept> when it’s included inside the string literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合、式は、それが文字列リテラルに含められる時、<bpt i="3" x="3">&lt;c3&gt;</bpt>\(Double(multiplier) * 2.5)<ept i="3">&lt;/c3&gt;</ept>と書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this case, the loop contains only one statement, which prints an entry from the five-times table for the current value of <bpt i="5" x="5">&lt;c5&gt;</bpt>index<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合では、ループは１つの文だけを含みます、それは、<bpt i="5" x="5">&lt;c5&gt;</bpt>index<ept i="5">&lt;/c5&gt;</ept>の現在の値に対する九九の５の段の項を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this data model, a customer may or may not have a credit card, but a credit card will <bpt i="4" x="4">&lt;e4&gt;</bpt>always<ept i="4">&lt;/e4&gt;</ept> be associated with a customer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このデータ・モデルにおいて、顧客はクレジットカードを持っているかもしれないし、持っていないかもしれません、しかし、クレジットカードは<bpt i="4" x="4">&lt;e4&gt;</bpt>常に<ept i="4">&lt;/e4&gt;</ept>ひとりの顧客と結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this data model, every country must always have a capital city, and every city must always belong to a country.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このデータ・モデルにおいて、あらゆる国に常に主都がなければなりません、そして、あらゆる都市は常に国に属していなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this dictionary, the keys are three-letter International Air Transport Association codes, and the values are airport names:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この辞書では、キーは３文字の国際航空運送協会コードです、そして値は空港名です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>(404, "Not Found")<ept i="0">&lt;/c0&gt;</ept> is a tuple that describes an <bpt i="1" x="1">&lt;e1&gt;</bpt>HTTP status code<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、<bpt i="0" x="0">&lt;c0&gt;</bpt>(404, "Not Found")<ept i="0">&lt;/c0&gt;</ept>がひとつのタプルです、それは<bpt i="1" x="1">&lt;e1&gt;</bpt>HTTP状態コード<ept i="1">&lt;/e1&gt;</ept>を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>firstNumber<ept i="0">&lt;/c0&gt;</ept> is a named constant for the value <bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>secondNumber<ept i="2">&lt;/c2&gt;</ept> is a named constant for the value <bpt i="3" x="3">&lt;c3&gt;</bpt>42<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、<bpt i="0" x="0">&lt;c0&gt;</bpt>firstNumber<ept i="0">&lt;/c0&gt;</ept>は、値<bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>のための名前をつけられた定数です、そして、<bpt i="2" x="2">&lt;c2&gt;</bpt>secondNumber<ept i="2">&lt;/c2&gt;</ept>は値<bpt i="3" x="3">&lt;c3&gt;</bpt>42<ept i="3">&lt;/c3&gt;</ept>のための名前をつけられた定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>someResolution.width<ept i="0">&lt;/c0&gt;</ept> refers to the <bpt i="1" x="1">&lt;c1&gt;</bpt>width<ept i="1">&lt;/c1&gt;</ept> property of <bpt i="2" x="2">&lt;c2&gt;</bpt>someResolution<ept i="2">&lt;/c2&gt;</ept>, and returns its default initial value of <bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、<bpt i="0" x="0">&lt;c0&gt;</bpt>someResolution.width<ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>someResolution<ept i="2">&lt;/c2&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>width<ept i="1">&lt;/c1&gt;</ept>プロパティに言及して、その省略時の初期値の<bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, <bpt i="4" x="4">&lt;c4&gt;</bpt>actualNumber<ept i="4">&lt;/c4&gt;</ept> is simply used to print the result of the conversion.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、<bpt i="4" x="4">&lt;c4&gt;</bpt>actualNumber<ept i="4">&lt;/c4&gt;</ept>は単にその変換の結果を出力するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, <bpt i="6" x="6">&lt;c6&gt;</bpt>PrettyTextRepresentable<ept i="6">&lt;/c6&gt;</ept> adds a single requirement to provide a gettable property called <bpt i="7" x="7">&lt;c7&gt;</bpt>prettyTextualDescription<ept i="7">&lt;/c7&gt;</ept> that returns a <bpt i="8" x="8">&lt;c8&gt;</bpt>String<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、<bpt i="6" x="6">&lt;c6&gt;</bpt>PrettyTextRepresentable<ept i="6">&lt;/c6&gt;</ept>は１つの要件を加えて、<bpt i="8" x="8">&lt;c8&gt;</bpt>String<ept i="8">&lt;/c8&gt;</ept>を返す<bpt i="7" x="7">&lt;c7&gt;</bpt>prettyTextualDescription<ept i="7">&lt;/c7&gt;</ept>と呼ばれる取得可能なプロパティを提供するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, a <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> value of <bpt i="1" x="1">&lt;c1&gt;</bpt>1.0<ept i="1">&lt;/c1&gt;</ept> is considered to represent “one meter”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、<bpt i="1" x="1">&lt;c1&gt;</bpt>1.0<ept i="1">&lt;/c1&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>値は「１メートル」を表すと考慮されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, a new instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>TimesTable<ept i="0">&lt;/c0&gt;</ept> is created to represent the three-times-table.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、<bpt i="0" x="0">&lt;c0&gt;</bpt>TimesTable<ept i="0">&lt;/c0&gt;</ept>の新しいインスタンスは、九九の３の段を表すためにつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, code execution continues if <bpt i="0" x="0">&lt;c0&gt;</bpt>age &gt;= 0<ept i="0">&lt;/c0&gt;</ept> evaluates to <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>, that is, if the value of <bpt i="2" x="2">&lt;c2&gt;</bpt>age<ept i="2">&lt;/c2&gt;</ept> is nonnegative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、コード実行は<bpt i="0" x="0">&lt;c0&gt;</bpt>age &gt;= 0<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>に評価されるならば、すなわち<bpt i="2" x="2">&lt;c2&gt;</bpt>age<ept i="2">&lt;/c2&gt;</ept>の値が負でないならば継続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, each item in the array might be a <bpt i="0" x="0">&lt;c0&gt;</bpt>Movie<ept i="0">&lt;/c0&gt;</ept>, or it might be a <bpt i="1" x="1">&lt;c1&gt;</bpt>Song<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、配列の各項目は<bpt i="0" x="0">&lt;c0&gt;</bpt>Movie<ept i="0">&lt;/c0&gt;</ept>であるかもしれませんし、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>Song<ept i="1">&lt;/c1&gt;</ept>であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, initialization begins with a call to a convenience initializer on the subclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、初期化はサブクラス上での便宜イニシャライザへの呼び出しから始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, it checks whether <bpt i="7" x="7">&lt;c7&gt;</bpt>game<ept i="7">&lt;/c7&gt;</ept> is actually an instance of <bpt i="8" x="8">&lt;c8&gt;</bpt>SnakesAndLadders<ept i="8">&lt;/c8&gt;</ept> behind the scenes, and prints an appropriate message if so.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、<bpt i="7" x="7">&lt;c7&gt;</bpt>game<ept i="7">&lt;/c7&gt;</ept>が実際に舞台裏でS<bpt i="8" x="8">&lt;c8&gt;</bpt>nakesAndLadders<ept i="8">&lt;/c8&gt;</ept>のインスタンスであるかどうか調べて、もしそうならば適切なメッセージを出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, it simply prints out the value that is about to be set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、それは単に設定されようとしている値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, it would be preferable to write the sorting closure inline, using closure expression syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、クロージャ式構文を使って、ソート・クロージャを行内に書くことがずっと好ましいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>Named<ept i="0">&lt;/c0&gt;</ept> protocol has a single requirement for a gettable <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> property called <bpt i="2" x="2">&lt;c2&gt;</bpt>name<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>Named<ept i="0">&lt;/c0&gt;</ept>プロトコルは、取得可能な<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>プロパティで<bpt i="2" x="2">&lt;c2&gt;</bpt>name<ept i="2">&lt;/c2&gt;</ept>と呼ばれるものに対するただ１つの要件を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>buyFavoriteSnack(person: vendingMachine:)<ept i="0">&lt;/c0&gt;</ept> function looks up a given person’s favorite snack and tries to buy it for them by calling the <bpt i="1" x="1">&lt;c1&gt;</bpt>vend(itemNamed:)<ept i="1">&lt;/c1&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>buyFavoriteSnack(person: vendingMachine:)<ept i="0">&lt;/c0&gt;</ept>関数は指定された個人のお気に入りのスナックを探してそれを彼らのために仕入れることを<bpt i="1" x="1">&lt;c1&gt;</bpt>vend(itemNamed:)<ept i="1">&lt;/c1&gt;</ept>メソッドを呼ぶことによって試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>makeASandwich()<ept i="0">&lt;/c0&gt;</ept> function will throw an error if no clean dishes are available or if any ingredients are missing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>makeASandwich()<ept i="0">&lt;/c0&gt;</ept>関数は、綺麗な皿が利用可能でないならばまたは何の食材も見つからないならばエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the attempt to set the <bpt i="0" x="0">&lt;c0&gt;</bpt>address<ept i="0">&lt;/c0&gt;</ept> property of <bpt i="1" x="1">&lt;c1&gt;</bpt>john.residence<ept i="1">&lt;/c1&gt;</ept> will fail, because <bpt i="2" x="2">&lt;c2&gt;</bpt>john.residence<ept i="2">&lt;/c2&gt;</ept> is currently <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="1" x="1">&lt;c1&gt;</bpt>john.residence<ept i="1">&lt;/c1&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>address<ept i="0">&lt;/c0&gt;</ept>プロパティを設定する試みは失敗します、なぜなら<bpt i="2" x="2">&lt;c2&gt;</bpt>john.residence<ept i="2">&lt;/c2&gt;</ept>が現在<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the attempt to set the <bpt i="0" x="0">&lt;c0&gt;</bpt>address<ept i="0">&lt;/c0&gt;</ept> property of <bpt i="1" x="1">&lt;c1&gt;</bpt>john.residence<ept i="1">&lt;/c1&gt;</ept> will succeed, because the value of <bpt i="2" x="2">&lt;c2&gt;</bpt>john.residence<ept i="2">&lt;/c2&gt;</ept> currently contains a valid <bpt i="3" x="3">&lt;c3&gt;</bpt>Address<ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、<bpt i="1" x="1">&lt;c1&gt;</bpt>john.residence<ept i="1">&lt;/c1&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>address<ept i="0">&lt;/c0&gt;</ept>プロパティを設定しようとする試みは成功します、なぜなら<bpt i="2" x="2">&lt;c2&gt;</bpt>john.residence<ept i="2">&lt;/c2&gt;</ept>の値は現在は有効な<bpt i="3" x="3">&lt;c3&gt;</bpt>Address<ept i="3">&lt;/c3&gt;</ept>インスタンスを含むからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the closing <bpt i="4" x="4">&lt;c4&gt;</bpt>&gt;<ept i="4">&lt;/c4&gt;</ept> characters are not treated as a single token that may then be misinterpreted as a bit shift <bpt i="5" x="5">&lt;c5&gt;</bpt>&gt;&gt;<ept i="5">&lt;/c5&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、閉じ<bpt i="4" x="4">&lt;c4&gt;</bpt>&gt;<ept i="4">&lt;/c4&gt;</ept>文字たちは、単一のトークンとして見なされることはなく、それでビットシフト演算子<bpt i="5" x="5">&lt;c5&gt;</bpt>&gt;&gt;<ept i="5">&lt;/c5&gt;</ept>と誤解されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the maximum number of allowed login attempts is declared as a constant, because the maximum value never changes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例において、許可されるログインの試みの最大数は、最大の値が決して変わらないので、定数として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the number <bpt i="2" x="2">&lt;c2&gt;</bpt>5<ept i="2">&lt;/c2&gt;</ept> is correctly identified as a prime number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、数<bpt i="2" x="2">&lt;c2&gt;</bpt>5<ept i="2">&lt;/c2&gt;</ept>は正しく素数と確認されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the superclass for <bpt i="0" x="0">&lt;c0&gt;</bpt>RecipeIngredient<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Food<ept i="1">&lt;/c1&gt;</ept>, which has a single convenience initializer called <bpt i="2" x="2">&lt;c2&gt;</bpt>init()<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、<bpt i="0" x="0">&lt;c0&gt;</bpt>RecipeIngredient<ept i="0">&lt;/c0&gt;</ept>のためのスーパークラスは<bpt i="1" x="1">&lt;c1&gt;</bpt>Food<ept i="1">&lt;/c1&gt;</ept>です、それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>init()<ept i="2">&lt;/c2&gt;</ept>と呼ばれる一つの便宜イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the value of <bpt i="0" x="0">&lt;c0&gt;</bpt>friendlyWelcome<ept i="0">&lt;/c0&gt;</ept> is changed from <bpt i="1" x="1">&lt;c1&gt;</bpt>"Hello!"<ept i="1">&lt;/c1&gt;</ept> to <bpt i="2" x="2">&lt;c2&gt;</bpt>"Bonjour!"<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、<bpt i="0" x="0">&lt;c0&gt;</bpt>friendlyWelcome<ept i="0">&lt;/c0&gt;</ept>の値は、<bpt i="1" x="1">&lt;c1&gt;</bpt>"Hello!"<ept i="1">&lt;/c1&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt>"Bonjour!"<ept i="2">&lt;/c2&gt;</ept>に変えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this example, the variable <bpt i="0" x="0">&lt;c0&gt;</bpt>number<ept i="0">&lt;/c0&gt;</ept> is initialized with the value of the closure’s <bpt i="1" x="1">&lt;c1&gt;</bpt>number<ept i="1">&lt;/c1&gt;</ept> parameter, so that the value can be modified within the closure body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例では、変数<bpt i="0" x="0">&lt;c0&gt;</bpt>number<ept i="0">&lt;/c0&gt;</ept>はこのクロージャの持つ<bpt i="1" x="1">&lt;c1&gt;</bpt>number<ept i="1">&lt;/c1&gt;</ept>パラメータの値を使って初期化されます、それでその値はクロージャ本体の内部で修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this figure, the left channel has a current level of <bpt i="2" x="2">&lt;c2&gt;</bpt>9<ept i="2">&lt;/c2&gt;</ept>, and the right channel has a current level of <bpt i="3" x="3">&lt;c3&gt;</bpt>7<ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この図には、左のチャンネルに現在<bpt i="2" x="2">&lt;c2&gt;</bpt>9<ept i="2">&lt;/c2&gt;</ept>のレベルがあり、右のチャンネルに現在<bpt i="3" x="3">&lt;c3&gt;</bpt>7<ept i="3">&lt;/c3&gt;</ept>のレベルがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this form, each case block consists of the <bpt i="0" x="0">&lt;c0&gt;</bpt>case<ept i="0">&lt;/c0&gt;</ept> keyword followed by one or more enumeration cases, separated by commas.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この形式では、それぞれのケース節ブロックはキーワード<bpt i="0" x="0">&lt;c0&gt;</bpt>case<ept i="0">&lt;/c0&gt;</ept>とそれに続く一つ以上の、コンマで区切られた、列挙ケース節から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this form, each case block consists of the <bpt i="0" x="0">&lt;c0&gt;</bpt>case<ept i="0">&lt;/c0&gt;</ept> keyword, followed by one or more enumeration cases, separated by commas.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この形式では、それぞれのケース節ブロックはキーワード<bpt i="0" x="0">&lt;c0&gt;</bpt>case<ept i="0">&lt;/c0&gt;</ept>、それに続けて、コンマで区切られる一つ以上の列挙ケース節から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this implementation, the input parameters are named <bpt i="0" x="0">&lt;c0&gt;</bpt>left<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>right<ept i="1">&lt;/c1&gt;</ept> to represent the <bpt i="2" x="2">&lt;c2&gt;</bpt>Vector2D<ept i="2">&lt;/c2&gt;</ept> instances that will be on the left side and right side of the <bpt i="3" x="3">&lt;c3&gt;</bpt>+<ept i="3">&lt;/c3&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この実装において、入力パラメータは、<bpt i="0" x="0">&lt;c0&gt;</bpt>left<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>right<ept i="1">&lt;/c1&gt;</ept>という名前をつけられ、<bpt i="3" x="3">&lt;c3&gt;</bpt>+<ept i="3">&lt;/c3&gt;</ept>演算子の左側と右側にある<bpt i="2" x="2">&lt;c2&gt;</bpt>Vector2D<ept i="2">&lt;/c2&gt;</ept>インスタンスを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this scenario, it’s useful to combine an unowned property on one class with an implicitly unwrapped optional property on the other class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この筋書きにおいて、一方のクラス上の非所有者プロパティと他方のクラス上の暗黙的にアンラップされるオプショナルのプロパティを結合することは、役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this situation, the parameter name takes precedence, and it becomes necessary to refer to the property in a more qualified way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この状況には、パラメータ名が優先されます、そして、より対象を限定するやり方でプロパティに言及することが必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In this version of the game, the <bpt i="0" x="0">&lt;e0&gt;</bpt>first<ept i="0">&lt;/e0&gt;</ept> action in the loop is to check for a ladder or a snake.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゲームのこの改作において、ループでの<bpt i="0" x="0">&lt;e0&gt;</bpt>最初<ept i="0">&lt;/e0&gt;</ept>の活動は、はしごまたはヘビについて調べることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In-Out Parameters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>In-Outパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In-out parameters are an alternative way for a function to have an effect outside of the scope of its function body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>in-outパラメータは、その関数本体のスコープの外で効果を持つようにする関数のための代替の方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In-out parameters are discussed in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>In-Out Parameters<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>in-outパラメータは、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>in-outパラメータ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In-out parameters are discussed in detail in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>In-Out Parameters<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>, below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>in-outパラメータは詳細に、下で、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>in-outパラメータ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>において議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In-out parameters are not the same as returning a value from a function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>in-outパラメータは、関数からある値が返されることと同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In-out parameters are passed as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>in-outパラメータは、以下のように渡されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In-out parameters cannot have default values, and variadic parameters cannot be marked as <bpt i="0" x="0">&lt;c0&gt;</bpt>inout<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>In-outパラメータは省略時の値を持つことができません、そして可変長パラメータは<bpt i="0" x="0">&lt;c0&gt;</bpt>inout<ept i="0">&lt;/c0&gt;</ept>として印されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Includes a new section on <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Extended Grapheme Clusters<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> and more information about <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Unicode Scalars<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept> and <bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>Comparing Strings<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>拡張書記素クラスタ<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>に関する新しい節そして<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>ユニコード・スカラー<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>と<bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>文字列を比較する<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>についての更なる情報を含めました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Indeed, if you are writing a single-target app, you may not need to specify explicit access control levels at all.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実際に、あなたが単一ターゲットのアプリを書いているならば、明確なアクセス制御水準を指定する必要はまったくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Indeed, if you delete the <bpt i="8" x="8">&lt;c8&gt;</bpt>typealias Item = Int<ept i="8">&lt;/c8&gt;</ept> line from the code above, everything still works, because it’s clear what type should be used for <bpt i="9" x="9">&lt;c9&gt;</bpt>Item<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>本当に、あなたが上のコードから行<bpt i="8" x="8">&lt;c8&gt;</bpt>typealias Item = Int<ept i="8">&lt;/c8&gt;</ept>を削除するならば、すべては依然として働きます、なぜなら、どんな型が<bpt i="9" x="9">&lt;c9&gt;</bpt>Item<ept i="9">&lt;/c9&gt;</ept>のために使われなければならないかは明白であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Indeed, if you tried to access the instance, your app would most likely crash.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実はそれどころか、あなたがそのインスタンスにアクセスしようとするならば、あなたのアプリはたぶんクラッシュするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Indentation at the start of each quoted line is removed, as long as it matches the indentation of the closing quote.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各引用された行の始まりでの字下げは、それが閉じ引用符の字下げと合致するのであれば、取り除かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inferring Type From Context</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文脈から型を推論する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inferring parameter and return value types from context</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前後関係からパラメータおよび戻り値の型を推論する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Infix <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Operator Methods<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> no longer require the <bpt i="2" x="2">&lt;c2&gt;</bpt>@infix<ept i="2">&lt;/c2&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接中辞<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>演算子メソッド<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>はもはや<bpt i="2" x="2">&lt;c2&gt;</bpt>@infix<ept i="2">&lt;/c2&gt;</ept>属性を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Infix operators can optionally specify a precedence group.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接中辞演算子は、任意に優先順位グループを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inheritance</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inheritance enables one class to inherit the characteristics of another.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>継承は、あるクラスが他のものの特徴を受け継ぐのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inheritance is a fundamental behavior that differentiates classes from other types in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>継承は、スウィフトにおいてクラスを他の型と区別する基本的挙動です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initial values for the properties of the new instance can be passed to the memberwise initializer by name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいインスタンスのプロパティのための初期値は、名前でメンバー関連イニシャライザに渡されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initial values for the properties of the new instance can be passed to the memberwise initializer by name:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいインスタンスのプロパティのための最初の値は、名前によってメンバー関連イニシャライザに渡されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initialization</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initialization Parameters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initialization failure propagates through initializer delegation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化失敗は、イニシャライザ委任を通じて伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initialization parameters have the same capabilities and syntax as function and method parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化パラメータは、関数およびメソッドのパラメータと同じ能力と構文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializer Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializer Delegation for Class Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス型のためのイニシャライザ委任</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializer Delegation for Value Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型のためのイニシャライザ委任</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializer Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializer Inheritance and Overriding</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザの継承およびオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializer Parameters Without Argument Labels</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数ラベルのないイニシャライザ・パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializer Requirements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializer declarations are declared using the <bpt i="1" x="1">&lt;c1&gt;</bpt>init<ept i="1">&lt;/c1&gt;</ept> keyword and have two basic forms.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ宣言は、キーワード<bpt i="1" x="1">&lt;c1&gt;</bpt>init<ept i="1">&lt;/c1&gt;</ept>を使って宣言されて、２つの基本の書式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializers are described in more detail in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Initialization<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザは、更に詳細に<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>初期化<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializers are now able to access <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> and can modify its properties, call its instance methods, and so on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザは、今では<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>にアクセスすることができます、そしてそれのプロパティを修正すること、それのインスタンスをメソッドを呼び出すこと、などが行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializers can call other initializers to perform part of an instance’s initialization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザは、あるインスタンスの初期化の一部を実行するために他のイニシャライザを呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializers can delegate to other initializers in the enumeration, but the initialization process is complete only after an initializer assigns one of the enumeration cases to <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザは、その列挙の中の他のイニシャライザに委任することができます、しかしその初期化処理はあるイニシャライザが列挙ケース節のうちの１つを<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>に代入した後になって初めて終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializers in structures and enumerations can call other declared initializers to delegate part or all of the initialization process.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体および列挙のイニシャライザは、初期化プロセスの一部または全てを委任するために他の宣言済みイニシャライザを呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializing an Empty String</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の文字列を初期化する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializing from a Raw Value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の値から初期化する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inserting <bpt i="0" x="0">&lt;c0&gt;</bpt>-9<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept> into the equation yields:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>-9<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept>を等式に入れることは、以下を生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inserting <bpt i="0" x="0">&lt;c0&gt;</bpt>9<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept> into this equation yields:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>9<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept>をこの等式に入れることは、以下を生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inserting and Removing</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>差し込みと削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inside a closure with no explicit parameter names, the parameters are implicitly named <bpt i="0" x="0">&lt;c0&gt;</bpt>$0<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>$1<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>$2<ept i="2">&lt;/c2&gt;</ept>, and so on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>明確なパラメータ名のないクロージャの内部で、パラメータは暗黙のうちに<bpt i="0" x="0">&lt;c0&gt;</bpt>$0<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>$1<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>$2<ept i="2">&lt;/c2&gt;</ept>、などと名前をつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inside a function, the value of <bpt i="0" x="0">&lt;c0&gt;</bpt>#function<ept i="0">&lt;/c0&gt;</ept> is the name of that function, inside a method it is the name of that method, inside a property getter or setter it is the name of that property, inside special members like <bpt i="1" x="1">&lt;c1&gt;</bpt>init<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>subscript<ept i="2">&lt;/c2&gt;</ept> it is the name of that keyword, and at the top level of a file it is the name of the current module.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数の内側では、<bpt i="0" x="0">&lt;c0&gt;</bpt>#function<ept i="0">&lt;/c0&gt;</ept>の値は、その関数の名前であり、メソッドの内側ではそれはそのメソッドの名前であり、プロパティゲッターやセッターの内側ではそれはそのプロパティの名前であり、<bpt i="1" x="1">&lt;c1&gt;</bpt>init<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>subscript<ept i="2">&lt;/c2&gt;</ept>のような特別なメンバーの内側ではそれはそのキーワードの名前であり、そしてあるファイルのトップレベルではそれは現在のモジュールの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inside a protocol declaration, a type alias can give a shorter and more convenient name to a type that is used frequently.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル宣言の内部で、型エイリアスはより短くより便利な名前を頻繁に使われる型に提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inside the <bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept> block, you mark code that can throw an error by writing <bpt i="3" x="3">&lt;c3&gt;</bpt>try<ept i="3">&lt;/c3&gt;</ept> in front of it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept>ブロックの内部で、あなたはエラーをスローできるコードを、それの前に<bpt i="3" x="3">&lt;c3&gt;</bpt>try<ept i="3">&lt;/c3&gt;</ept>を書くことによって印します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inside the <bpt i="4" x="4">&lt;c4&gt;</bpt>catch<ept i="4">&lt;/c4&gt;</ept> block, the error is automatically given the name <bpt i="5" x="5">&lt;c5&gt;</bpt>error<ept i="5">&lt;/c5&gt;</ept> unless you give it a different name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>catch<ept i="4">&lt;/c4&gt;</ept>ブロック内部で、エラーは、あなたがそれに別の名前を与えるのでない限り、自動的に名前<bpt i="5" x="5">&lt;c5&gt;</bpt>error<ept i="5">&lt;/c5&gt;</ept>を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inside the switch, the enumeration case is referred to by the abbreviated form <bpt i="3" x="3">&lt;c3&gt;</bpt>.hearts<ept i="3">&lt;/c3&gt;</ept> because the value of <bpt i="4" x="4">&lt;c4&gt;</bpt>self<ept i="4">&lt;/c4&gt;</ept> is already known to be a suit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スイッチの内側では、列挙のケース節は省略された形式<bpt i="3" x="3">&lt;c3&gt;</bpt>.hearts<ept i="3">&lt;/c3&gt;</ept>によって参照されます、なぜなら<bpt i="4" x="4">&lt;c4&gt;</bpt>self<ept i="4">&lt;/c4&gt;</ept>の値がすでに組み札のひとつ（スペード、クラブ、ハート、ダイヤのどれか）であるということがわかっているからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instance Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instance methods added with an extension can also modify (or <bpt i="0" x="0">&lt;e0&gt;</bpt>mutate<ept i="0">&lt;/e0&gt;</ept>) the instance itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張を使って加えられるインスタンスメソッドは、また、インスタンスそれ自体を修正（または<bpt i="0" x="0">&lt;e0&gt;</bpt>変更<ept i="0">&lt;/e0&gt;</ept>）することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instance methods have exactly the same syntax as functions, as described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Functions<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスメソッドは、関数と正確に同じ構文を持ちます、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>関数<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instance methods, as described above, are methods that are called on an instance of a particular type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスメソッドは、先に述べたように、特定の型のインスタンスの上で呼ばれるメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instance properties are properties that belong to an instance of a particular type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスプロパティは、ある特定の型のあるひとつのインスタンスに属しているプロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instances of <bpt i="0" x="0">&lt;c0&gt;</bpt>FixedLengthRange<ept i="0">&lt;/c0&gt;</ept> have a variable stored property called <bpt i="1" x="1">&lt;c1&gt;</bpt>firstValue<ept i="1">&lt;/c1&gt;</ept> and a constant stored property called <bpt i="2" x="2">&lt;c2&gt;</bpt>length<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>FixedLengthRange<ept i="0">&lt;/c0&gt;</ept>のインスタンスは<bpt i="1" x="1">&lt;c1&gt;</bpt>firstValue<ept i="1">&lt;/c1&gt;</ept>と呼ばれる変数保存プロパティと<bpt i="2" x="2">&lt;c2&gt;</bpt>length<ept i="2">&lt;/c2&gt;</ept>と呼ばれる定数保存プロパティをもちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instances of <bpt i="0" x="0">&lt;c0&gt;</bpt>Hamster<ept i="0">&lt;/c0&gt;</ept> can now be used wherever <bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept> is the required type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept>が必要な型であるどこででも、<bpt i="0" x="0">&lt;c0&gt;</bpt>Hamster<ept i="0">&lt;/c0&gt;</ept>のインスタンスが現在使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instances of class types can also implement a <bpt i="0" x="0">&lt;e0&gt;</bpt>deinitializer<ept i="0">&lt;/e0&gt;</ept>, which performs any custom cleanup just before an instance of that class is deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス型のインスタンスはまた、<bpt i="0" x="0">&lt;e0&gt;</bpt>デイニシャライザ<ept i="0">&lt;/e0&gt;</ept>を実装することができます、それは、そのクラスのインスタンスの割り当て解除がされる直前に、何らかのあつらえのクリーンアップ作業を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead of generating a random number, it starts with a <bpt i="0" x="0">&lt;c0&gt;</bpt>diceRoll<ept i="0">&lt;/c0&gt;</ept> value of <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無作為な数を生成する代わりに、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>diceRoll<ept i="0">&lt;/c0&gt;</ept>値から始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead of returning a new point, this method actually modifies the point on which it is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい点を返す代わりに、このメソッドは、それが呼び出された点を実際に修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, <bpt i="6" x="6">&lt;c6&gt;</bpt>Rect<ept i="6">&lt;/c6&gt;</ept> defines a custom getter and setter for a computed variable called <bpt i="7" x="7">&lt;c7&gt;</bpt>center<ept i="7">&lt;/c7&gt;</ept>, to enable you to work with the rectangle’s <bpt i="8" x="8">&lt;c8&gt;</bpt>center<ept i="8">&lt;/c8&gt;</ept> as if it were a real stored property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、<bpt i="6" x="6">&lt;c6&gt;</bpt>Rect<ept i="6">&lt;/c6&gt;</ept>は、<bpt i="7" x="7">&lt;c7&gt;</bpt>center<ept i="7">&lt;/c7&gt;</ept>と呼ばれる計算される変数のためにあつらえのゲッターとセッターを定義して、矩形の<bpt i="8" x="8">&lt;c8&gt;</bpt>center<ept i="8">&lt;/c8&gt;</ept>をそれがまったく保存プロパティであるかのようにあなたが扱うことができるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, a literal is parsed as having infinite precision and Swift’s type inference attempts to infer a type for the literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうではなく、リテラルは無限精度を持つものとして解析されて、スウィフトの型推論はそのリテラルの型を推測することを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, it makes more sense to create the <bpt i="3" x="3">&lt;c3&gt;</bpt>DataImporter<ept i="3">&lt;/c3&gt;</ept> instance if and when it is first used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、それが最初に必要とされる時になれば<bpt i="3" x="3">&lt;c3&gt;</bpt>DataImporter<ept i="3">&lt;/c3&gt;</ept>を作成するほうが筋が通ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, make an explicit check against <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept> with the <bpt i="6" x="6">&lt;c6&gt;</bpt>==<ept i="6">&lt;/c6&gt;</ept> or <bpt i="7" x="7">&lt;c7&gt;</bpt>!=<ept i="7">&lt;/c7&gt;</ept> operators to find out if an optional contains a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>に備えて、<bpt i="6" x="6">&lt;c6&gt;</bpt>==<ept i="6">&lt;/c6&gt;</ept>または<bpt i="7" x="7">&lt;c7&gt;</bpt>!=<ept i="7">&lt;/c7&gt;</ept>演算子を使ってオプショナルが値を持つかどうか確認するために明示的に調べてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, the <bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept> type’s existing type parameter name, <bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>, is used within the extension to indicate the optional type of the <bpt i="2" x="2">&lt;c2&gt;</bpt>topItem<ept i="2">&lt;/c2&gt;</ept> computed property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうしなくても、<bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept>型の既存の型パラメーター名、<bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>は、拡張の内部で<bpt i="2" x="2">&lt;c2&gt;</bpt>topItem<ept i="2">&lt;/c2&gt;</ept>計算プロパティの元々の型を指し示すために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, the addition assignment operator method takes advantage of the existing addition operator method, and uses it to set the left value to be the left value plus the right value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、追加代入演算子メソッドは、既存の加算演算子メソッドを利用して、左の値を右の値を加えた左の値に設定するためにそれを使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, the different enumeration cases are fully-fledged values in their own right, with an explicitly defined type of <bpt i="9" x="9">&lt;c9&gt;</bpt>CompassPoint<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、異なる列挙ケース節は、ある明示的に定義された<bpt i="9" x="9">&lt;c9&gt;</bpt>CompassPoint<ept i="9">&lt;/c9&gt;</ept>の型を持つ、他に頼らない完全に自立した値です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, the entire <bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept> statement finishes its execution as soon as the first matching <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> case is completed, without requiring an explicit <bpt i="4" x="4">&lt;c4&gt;</bpt>break<ept i="4">&lt;/c4&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、最初のマッチしている<bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept>ケース節の部分が完了されるとすぐに、<bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>文の全体がその実行を終えます、明確な<bpt i="4" x="4">&lt;c4&gt;</bpt>break<ept i="4">&lt;/c4&gt;</ept>文を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, the loop is executed until a particular condition is satisfied.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、このループは特定の条件が満たされるまで実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, the protocol’s own access level is used to provide the default access level for each protocol requirement implementation within the extension.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、プロトコル自身のアクセス水準が、省略時のアクセス水準を拡張内の各プロトコル要件実施のために提供するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, the type parameter list from the <bpt i="0" x="0">&lt;e0&gt;</bpt>original<ept i="0">&lt;/e0&gt;</ept> type definition is available within the body of the extension, and the original type parameter names are used to refer to the type parameters from the original definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうしなくても、<bpt i="0" x="0">&lt;e0&gt;</bpt>元々の<ept i="0">&lt;/e0&gt;</ept>型定義からの型パラメーターリストは、その拡張の本文内で利用可能です、そして元々の型パラメーター名は、元々の定義からの型パラメーターを参照するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, these references are defined like any other constant or variable in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、これらの参照は、スウィフトにおけるあらゆる他の定数または変数と同じように定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, they are called only when the value is set outside of an initialization context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうではなく、値が初期化の文脈の外で設定されるときにだけ、それらは呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、それらは他のプロパティや値を間接的に取得したり設定したりするためにゲッターと任意のセッターを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, this example calls <bpt i="4" x="4">&lt;c4&gt;</bpt>UInt16(one)<ept i="4">&lt;/c4&gt;</ept> to create a new <bpt i="5" x="5">&lt;c5&gt;</bpt>UInt16<ept i="5">&lt;/c5&gt;</ept> initialized with the value of <bpt i="6" x="6">&lt;c6&gt;</bpt>one<ept i="6">&lt;/c6&gt;</ept>, and uses this value in place of the original:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、この例は<bpt i="6" x="6">&lt;c6&gt;</bpt>one<ept i="6">&lt;/c6&gt;</ept>の値で初期化される新しい<bpt i="5" x="5">&lt;c5&gt;</bpt>UInt16<ept i="5">&lt;/c5&gt;</ept>を作るために<bpt i="4" x="4">&lt;c4&gt;</bpt>UInt16(one)<ept i="4">&lt;/c4&gt;</ept>を呼んで、オリジナルの代わりにこの値を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use separate <bpt i="1" x="1">&lt;c1&gt;</bpt>available<ept i="1">&lt;/c1&gt;</ept> attributes to specify a Swift version availability and one or more platform availabilities.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、<bpt i="1" x="1">&lt;c1&gt;</bpt>available<ept i="1">&lt;/c1&gt;</ept>属性を使うことで、スウィフトバージョン利用可能性と１つ以上のプラットホーム利用可能性を指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use the <bpt i="3" x="3">&lt;c3&gt;</bpt>append(_:)<ept i="3">&lt;/c3&gt;</ept> method, or append a single-item array with the <bpt i="4" x="4">&lt;c4&gt;</bpt>+=<ept i="4">&lt;/c4&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、<bpt i="3" x="3">&lt;c3&gt;</bpt>append(_:)<ept i="3">&lt;/c3&gt;</ept>メソッドを使ってください、または単一項目の配列を<bpt i="4" x="4">&lt;c4&gt;</bpt>+=<ept i="4">&lt;/c4&gt;</ept>演算子を使って加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integer Bounds</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数の限界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integer Conversion</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integer Literals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integer and Floating-Point Conversion</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数と浮動小数点の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integer literals can be written as:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数リテラルは、次のように書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integer literals can begin with leading zeros (<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>), but they’re likewise ignored and don’t affect the base or value of the literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数リテラルは、いくつかのゼロ（<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>）を先頭に始まることができます、しかしそれらは同様に無視されて、リテラルの基数または値に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integers are checked for overflow.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数は、オーバーフローを確認される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integers are either <bpt i="3" x="3">&lt;e3&gt;</bpt>signed<ept i="3">&lt;/e3&gt;</ept> (positive, zero, or negative) or <bpt i="4" x="4">&lt;e4&gt;</bpt>unsigned<ept i="4">&lt;/e4&gt;</ept> (positive or zero).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数は、<bpt i="3" x="3">&lt;e3&gt;</bpt>符号つき<ept i="3">&lt;/e3&gt;</ept>（正、ゼロ、または負）または<bpt i="4" x="4">&lt;e4&gt;</bpt>符号なし<ept i="4">&lt;/e4&gt;</ept>（正またはゼロ）のどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Interface Builder attributes are declaration attributes used by Interface Builder to synchronize with Xcode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかのインターフェイスビルダー属性は、Xcodeと同期するためにインターフェイスビルダーによって使用される宣言属性です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Interval Matching</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>区間マッチング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It adds a <bpt i="2" x="2">&lt;c2&gt;</bpt>director<ept i="2">&lt;/c2&gt;</ept> property on top of the base <bpt i="3" x="3">&lt;c3&gt;</bpt>MediaItem<ept i="3">&lt;/c3&gt;</ept> class, with a corresponding initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、対応するイニシャライザを使って、基盤クラス<bpt i="3" x="3">&lt;c3&gt;</bpt>MediaItem<ept i="3">&lt;/c3&gt;</ept>の上に<bpt i="2" x="2">&lt;c2&gt;</bpt>director<ept i="2">&lt;/c2&gt;</ept>プロパティを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It also cannot transfer control into a case block whose pattern contains value binding patterns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはまた、パターンが値束縛パターンを含むケース節ブロックに制御を移すことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It also defines a computed property called <bpt i="3" x="3">&lt;c3&gt;</bpt>description<ept i="3">&lt;/c3&gt;</ept>, which uses the values stored in <bpt i="4" x="4">&lt;c4&gt;</bpt>rank<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>suit<ept i="5">&lt;/c5&gt;</ept> to build a description of the name and value of the card.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはまた、<bpt i="3" x="3">&lt;c3&gt;</bpt>description<ept i="3">&lt;/c3&gt;</ept>と呼ばれる計算プロパティを定義します、それは、<bpt i="4" x="4">&lt;c4&gt;</bpt>rank<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>suit<ept i="5">&lt;/c5&gt;</ept>に保管される値を使って、カードの名前と説明の値を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It also defines an array of integers, ready to be converted into strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはまた、文字列に変換される準備ができている整数の配列も定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It also means you can be confident about the type of values you will retrieve from a collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはまた、あなたがコレクションから取り出す値の型をあなたが確信できることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It also offers two methods—<bpt i="2" x="2">&lt;c2&gt;</bpt>distribute(coins:)<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>receive(coins:)<ept i="3">&lt;/c3&gt;</ept>—to handle the distribution and collection of coins.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはまた、２つのメソッド ― <bpt i="2" x="2">&lt;c2&gt;</bpt>distribute(coins:)<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>receive(coins:)<ept i="3">&lt;/c3&gt;</ept>— ― を提供して、コインの配布と回収を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It also provides a method called <bpt i="2" x="2">&lt;c2&gt;</bpt>complete(level:)<ept i="2">&lt;/c2&gt;</ept>, which is called whenever a player completes a particular level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはまた<bpt i="2" x="2">&lt;c2&gt;</bpt>complete(level:)<ept i="2">&lt;/c2&gt;</ept>と呼ばれるメソッドを提供します、それは、プレーヤーが特定のレベルを完了するときはいつでも呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It also tracks the current level for an individual player.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはまた、個々のプレーヤーのために現在のレベルを追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It appends a colon and a line break, and uses this as the start of its pretty text representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはコロンと改行を追加します、そしてそれのきれいなテキスト表示のスタートとして、これを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It calculates the last digit of <bpt i="1" x="1">&lt;c1&gt;</bpt>number<ept i="1">&lt;/c1&gt;</ept> by using the remainder operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>number % 10<ept i="2">&lt;/c2&gt;</ept>), and uses this digit to look up an appropriate string in the <bpt i="3" x="3">&lt;c3&gt;</bpt>digitNames<ept i="3">&lt;/c3&gt;</ept> dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>number<ept i="1">&lt;/c1&gt;</ept>の最後の桁を剰余演算子を使用することによって計算して（<bpt i="2" x="2">&lt;c2&gt;</bpt>number % 10<ept i="2">&lt;/c2&gt;</ept>）、この桁を<bpt i="3" x="3">&lt;c3&gt;</bpt>digitNames<ept i="3">&lt;/c3&gt;</ept>辞書で適切な文字列を捜すために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It calls the provided function with the values <bpt i="4" x="4">&lt;c4&gt;</bpt>3<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>5<ept i="5">&lt;/c5&gt;</ept>, and prints the result of <bpt i="6" x="6">&lt;c6&gt;</bpt>8<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、提供された関数を値<bpt i="4" x="4">&lt;c4&gt;</bpt>3<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>5<ept i="5">&lt;/c5&gt;</ept>を使って呼び出して、結果の<bpt i="6" x="6">&lt;c6&gt;</bpt>8<ept i="6">&lt;/c6&gt;</ept>を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can also be useful to define requirements for associated types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連型のために要件を定義することは、また同様に役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can also match a value with a range of values, by checking whether the value is contained within the range, as the following example shows.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはまた、ある値をある範囲の値と照合することが、その値がその範囲に含まれるかどうかを調べることによって可能です、以下の例が示すように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can be described as “a tuple of type <bpt i="3" x="3">&lt;c3&gt;</bpt>(Int, String)<ept i="3">&lt;/c3&gt;</ept>”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは型<bpt i="3" x="3">&lt;c3&gt;</bpt>(Int, String)<ept i="3">&lt;/c3&gt;</ept>のタプルとして記述されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can be read as “not <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>”, as seen in the following example:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、「<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>でない」のように読まれることができます、下記の例では見られるように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can be useful to require a type to conform to multiple protocols at the same time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型に複数のプロトコルに一時に従うことを要求することは、役に立つことがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can do this with a control transfer statement such as <bpt i="2" x="2">&lt;c2&gt;</bpt>return<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>break<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>continue<ept i="4">&lt;/c4&gt;</ept>, or <bpt i="5" x="5">&lt;c5&gt;</bpt>throw<ept i="5">&lt;/c5&gt;</ept>, or it can call a function or method that doesn’t return, such as <bpt i="6" x="6">&lt;c6&gt;</bpt>fatalError(_:file:line:)<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはこれを制御移動文<bpt i="2" x="2">&lt;c2&gt;</bpt>return<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>break<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>continue<ept i="4">&lt;/c4&gt;</ept>、または<bpt i="5" x="5">&lt;c5&gt;</bpt>throw<ept i="5">&lt;/c5&gt;</ept>などで行えます、またはそれは復帰しない関数やメソッド、例えば<bpt i="6" x="6">&lt;c6&gt;</bpt>fatalError(_:file:line:)<ept i="6">&lt;/c6&gt;</ept>を呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can sometimes be useful to find out if two constants or variables refer to exactly the same instance of a class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの定数または変数が正確にあるクラスの同じインスタンスに言及するかどうかについて、知ることは時々役に立つことがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It cannot be called in isolation without an existing instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、単独で既存のインスタンスなしで呼ばれることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It cannot be modified by a subclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、サブクラスによって修正されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can’t call any other initializers of the same class, and if the class has a superclass, it must call one of the superclass’s designated initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは同じクラスの他のどのイニシャライザも呼ぶことができません、そしてそのクラスがスーパークラスを持つならば、それはスーパークラスの指定イニシャライザのうちの１つを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can’t contain three unescaped double quotes next to each other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、お互いは別として３つのエスケープされない二重引用符を含むことが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It compares the new value of <bpt i="2" x="2">&lt;c2&gt;</bpt>totalSteps<ept i="2">&lt;/c2&gt;</ept> against the old value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>totalSteps<ept i="2">&lt;/c2&gt;</ept>の新しい値をその古い値と比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It consists of a period (<bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept>) between the item and the identifier of its member.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、その項目とそれのメンバーの識別子の間のピリオド（<bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept>）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It delegates across to a designated initializer from the same class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、横の同じクラスの指定イニシャライザに向かって委任します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It does this by capturing a <bpt i="3" x="3">&lt;e3&gt;</bpt>reference<ept i="3">&lt;/e3&gt;</ept> to <bpt i="4" x="4">&lt;c4&gt;</bpt>runningTotal<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>amount<ept i="5">&lt;/c5&gt;</ept> from the surrounding function and using them within its own function body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、それを囲んでいる関数から<bpt i="4" x="4">&lt;c4&gt;</bpt>runningTotal<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>amount<ept i="5">&lt;/c5&gt;</ept>への<bpt i="3" x="3">&lt;e3&gt;</bpt>参照<ept i="3">&lt;/e3&gt;</ept>を捕獲して、それらをそれ自身の関数本文内で使うことによってこれを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It does this by implementing the optional <bpt i="2" x="2">&lt;c2&gt;</bpt>fixedIncrement<ept i="2">&lt;/c2&gt;</ept> property requirement:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、オプショナルの<bpt i="2" x="2">&lt;c2&gt;</bpt>fixedIncrement<ept i="2">&lt;/c2&gt;</ept>プロパティ要件を実装することによってこれをします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It doesn’t make sense for <bpt i="5" x="5">&lt;c5&gt;</bpt>volume<ept i="5">&lt;/c5&gt;</ept> to be settable, because it would be ambiguous as to which values of <bpt i="6" x="6">&lt;c6&gt;</bpt>width<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>height<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>depth<ept i="8">&lt;/c8&gt;</ept> should be used for a particular <bpt i="9" x="9">&lt;c9&gt;</bpt>volume<ept i="9">&lt;/c9&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>volume<ept i="5">&lt;/c5&gt;</ept>が設定可能であることは意味をなしません、なぜなら特定の<bpt i="9" x="9">&lt;c9&gt;</bpt>volume<ept i="9">&lt;/c9&gt;</ept>値に対して<bpt i="6" x="6">&lt;c6&gt;</bpt>width<ept i="6">&lt;/c6&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>height<ept i="7">&lt;/c7&gt;</ept>、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>depth<ept i="8">&lt;/c8&gt;</ept>にどの値が使われなければならないかはあいまいだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It doesn’t matter that <bpt i="4" x="4">&lt;c4&gt;</bpt>"zebra"<ept i="4">&lt;/c4&gt;</ept> isn’t less than <bpt i="5" x="5">&lt;c5&gt;</bpt>"apple"<ept i="5">&lt;/c5&gt;</ept>, because the comparison is already determined by the tuples’ first elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>"zebra"<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>"apple"<ept i="5">&lt;/c5&gt;</ept>より少ないことは問題ではありません、この比較はすでにタプルの最初の要素によって決定されているからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It doesn’t matter what that function’s implementation actually does—it matters only that the function is of the correct type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その関数の実装が実際に何をするかは、重要ではありません ― ただ関数が正しい型であるのが重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It doesn’t take any arguments, and when it’s called, it returns the value of the expression that’s wrapped inside of it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、全く引数を取りません、そしてそれが呼ばれる時、その内部に包み込まれた式の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It doubles the <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept> values of a <bpt i="5" x="5">&lt;c5&gt;</bpt>Vector2D<ept i="5">&lt;/c5&gt;</ept> instance, by adding the vector to itself with the addition assignment operator defined earlier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは<bpt i="5" x="5">&lt;c5&gt;</bpt>Vector2D<ept i="5">&lt;/c5&gt;</ept>インスタンスの<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept>値を、そのベクトルをそれ自体へと以前に定義される加算代入演算子を使って加えることによって２倍にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It enables you to represent almost any character from any language in a standardized form, and to read and write those characters to and from an external source such as a text file or web page.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたにほとんどどんな文字でもどんな言語のものでも標準化された方式で表わすこと、そしてそれらの文字を、テキスト・ファイルやウェブ・ページのような外部のソースへ書き込んだり、それらから読み込んだりすることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It evaluates an addition or multiplication by evaluating the expression on the left-hand side, evaluating the expression on the right-hand side, and then adding them or multiplying them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは加算や乗算を、左手側の式を評価し、右手側の式を評価して、それからそれらを加算や乗算することで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It executes a set of statements only if that condition is <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、その条件が<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>の場合にだけ、あるひとまとめにした文を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It explicitly converts the count from <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> to <bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept> to be able to do floating-point division.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、明示的に総数を<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>から<bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept>へ変換して、浮動小数点除算ができるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It has already been initialized with the value contained <bpt i="2" x="2">&lt;e2&gt;</bpt>within<ept i="2">&lt;/e2&gt;</ept> the optional, and so there’s no need to use the <bpt i="3" x="3">&lt;c3&gt;</bpt>!<ept i="3">&lt;/c3&gt;</ept> suffix to access its value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、すでにオプショナルの<bpt i="2" x="2">&lt;e2&gt;</bpt>内部に<ept i="2">&lt;/e2&gt;</ept>含まれる値で初期化されています、それでその値にアクセスするために<bpt i="3" x="3">&lt;c3&gt;</bpt>!<ept i="3">&lt;/c3&gt;</ept>接尾辞を使う必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It has one of the following forms:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、以下の書式のうちの１つを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It has the following forms:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、以下の各形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It illustrates how the designated initializers in this hierarchy act as “funnel” points for class initialization, simplifying the interrelationships among classes in the chain:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、この階層の中の指定イニシャライザが、どのようにクラス初期化のために「漏斗」地点の働きをして、この連鎖におけるクラス間の相互関係を単純化しているかを図示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It introduces an <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> property called <bpt i="4" x="4">&lt;c4&gt;</bpt>quantity<ept i="4">&lt;/c4&gt;</ept> (in addition to the <bpt i="5" x="5">&lt;c5&gt;</bpt>name<ept i="5">&lt;/c5&gt;</ept> property it inherits from <bpt i="6" x="6">&lt;c6&gt;</bpt>Food<ept i="6">&lt;/c6&gt;</ept>) and defines two initializers for creating <bpt i="7" x="7">&lt;c7&gt;</bpt>RecipeIngredient<ept i="7">&lt;/c7&gt;</ept> instances:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、<bpt i="4" x="4">&lt;c4&gt;</bpt>quantity<ept i="4">&lt;/c4&gt;</ept>と呼ばれる<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>プロパティ（加えてそれが<bpt i="6" x="6">&lt;c6&gt;</bpt>Food<ept i="6">&lt;/c6&gt;</ept>から受け継ぐ<bpt i="5" x="5">&lt;c5&gt;</bpt>name<ept i="5">&lt;/c5&gt;</ept>プロパティ）を導入して、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>RecipeIngredient<ept i="7">&lt;/c7&gt;</ept>インスタンスをつくるために２つのイニシャライザを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is a single-player game, but can store information for multiple players on a single device.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはシングルプレーヤーのゲームです、しかし一つの装置上で複数のプレーヤーのために情報を蓄えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is always better to be specific about the types you expect to work with in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いつでもより望ましいのは、あなたのコードで扱うことをあなたが期待する型について明確にすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is always possible to infer the parameter types and return type when passing a closure to a function or method as an inline closure expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャを関数やメソッドに行内クロージャ式として渡すとき、パラメータ型と戻り型を推論することは常に可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is automatically assigned a default value of <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>, meaning “no string yet”, when a new instance of <bpt i="4" x="4">&lt;c4&gt;</bpt>SurveyQuestion<ept i="4">&lt;/c4&gt;</ept> is initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、<bpt i="4" x="4">&lt;c4&gt;</bpt>SurveyQuestion<ept i="4">&lt;/c4&gt;</ept>の新しいインスタンスは初期化される時に、「まだ無い文字列」を意味する、省略時の値の<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を自動的に代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is explained in detail below in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Capturing Values<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、下で詳細に<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>値を捕獲する（キャプチャする）<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の中で説明されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is good practice to create immutable collections in all cases where the collection does not need to change.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのコレクションを変更する必要がないすべての場合において不変のコレクションを作成することは良い習慣です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is implicitly declared simply by its inclusion in the loop declaration, without the need for a <bpt i="2" x="2">&lt;c2&gt;</bpt>let<ept i="2">&lt;/c2&gt;</ept> declaration keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはループ宣言にひっくるめることによって、<bpt i="2" x="2">&lt;c2&gt;</bpt>let<ept i="2">&lt;/c2&gt;</ept>宣言キーワードの必要なしで、簡易に暗黙のうちに宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is important to consider each operator’s precedence and associativity when working out the order in which a compound expression will be calculated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複合の式が計算される順番を解決するとき、各演算子の優先順位と結合性を考慮することは、重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is not appropriate to set <bpt i="1" x="1">&lt;c1&gt;</bpt>threeTimesTable[someIndex]<ept i="1">&lt;/c1&gt;</ept> to a new value, and so the subscript for <bpt i="2" x="2">&lt;c2&gt;</bpt>TimesTable<ept i="2">&lt;/c2&gt;</ept> is defined as a read-only subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>threeTimesTable[someIndex]<ept i="1">&lt;/c1&gt;</ept>を新しい値に設定することは適切ではありません、なので<bpt i="2" x="2">&lt;c2&gt;</bpt>TimesTable<ept i="2">&lt;/c2&gt;</ept>のための添え字は、読み出し専用の添え字として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is not possible for Swift to guess what would qualify as “equal” for your own custom types, because the meaning of “equal” depends on the roles that those types play in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトには何があなたのあつらえの型にとって「等しい」と認められるべきか推測することは不可能です、なぜなら「等しい」の意味はそれらの型があなたのコードで演じる役割に依存するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is not possible to overload the default assignment operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>=<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>もとからある代入演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>=<ept i="0">&lt;/c0&gt;</ept>）をオーバーロードすることは不可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is not strictly necessary to use the <bpt i="0" x="0">&lt;c0&gt;</bpt>gameLoop<ept i="0">&lt;/c0&gt;</ept> label when calling <bpt i="1" x="1">&lt;c1&gt;</bpt>continue gameLoop<ept i="1">&lt;/c1&gt;</ept> to jump to the next iteration of the loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループの次の繰り返しへジャンプするために<bpt i="1" x="1">&lt;c1&gt;</bpt>continue gameLoop<ept i="1">&lt;/c1&gt;</ept>を呼ぶとき、<bpt i="0" x="0">&lt;c0&gt;</bpt>gameLoop<ept i="0">&lt;/c0&gt;</ept>ラベルを使用することは厳密には必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is not valid to write the following code, because the first case is empty:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初のケース節が空であるので、以下のコードを書くことは、有効ではありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is often useful to execute different pieces of code based on certain conditions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特定の状況に基づいて異なるコード小片を実行することは、しばしば役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is possible for a <bpt i="0" x="0">&lt;c0&gt;</bpt>DataManager<ept i="0">&lt;/c0&gt;</ept> instance to manage its data without ever importing data from a file, so there is no need to create a new <bpt i="1" x="1">&lt;c1&gt;</bpt>DataImporter<ept i="1">&lt;/c1&gt;</ept> instance when the <bpt i="2" x="2">&lt;c2&gt;</bpt>DataManager<ept i="2">&lt;/c2&gt;</ept> itself is created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>DataManager<ept i="0">&lt;/c0&gt;</ept>インスタンスがそれのもつデータを管理することはデータをファイルから一度もインポートしなくとも可能ですので、<bpt i="2" x="2">&lt;c2&gt;</bpt>DataManager<ept i="2">&lt;/c2&gt;</ept>自体がつくられるときに、新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>DataImporter<ept i="1">&lt;/c1&gt;</ept>インスタンスをつくる必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is reasonable to expect that the encapsulated values will be copied rather than referenced when you assign or pass around an instance of that structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがその構造体のインスタンスをあちこち代入したり、渡したりするとき、カプセル化された値が参照をつけられるのではなくコピーされるのが当然だと思うことが道筋が立っている。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is set to be interlaced, and is given a name of <bpt i="4" x="4">&lt;c4&gt;</bpt>"1080i"<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、インターレースに設定され、<bpt i="4" x="4">&lt;c4&gt;</bpt>"1080i"<ept i="4">&lt;/c4&gt;</ept>の名前を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is sometimes useful to define a class, structure, or enumeration for which initialization can fail.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それに対するイニシャライザが失敗できるクラス、構造体、または列挙を定義することは時として便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is the <bpt i="12" x="12">&lt;c12&gt;</bpt>frameRate<ept i="12">&lt;/c12&gt;</ept> property of the underlying <bpt i="13" x="13">&lt;c13&gt;</bpt>VideoMode<ept i="13">&lt;/c13&gt;</ept> that is changed, not the values of the constant references to that <bpt i="14" x="14">&lt;c14&gt;</bpt>VideoMode<ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、根底にある<bpt i="13" x="13">&lt;c13&gt;</bpt>VideoMode<ept i="13">&lt;/c13&gt;</ept>の変更可能な<bpt i="12" x="12">&lt;c12&gt;</bpt>frameRate<ept i="12">&lt;/c12&gt;</ept>プロパティです、その<bpt i="14" x="14">&lt;c14&gt;</bpt>VideoMode<ept i="14">&lt;/c14&gt;</ept>に対する参照をもつこれら定数の値ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is then incremented by <bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept> using the overflow addition operator (<bpt i="5" x="5">&lt;c5&gt;</bpt>&amp;+<ept i="5">&lt;/c5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、それからオーバフロー加算演算子（<bpt i="5" x="5">&lt;c5&gt;</bpt>&amp;+<ept i="5">&lt;/c5&gt;</ept>）を使って<bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept>だけ増やされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It is therefore appropriate to write this initializer as <bpt i="1" x="1">&lt;c1&gt;</bpt>init(_ celsius: Double)<ept i="1">&lt;/c1&gt;</ept> so that it can be called by providing an unnamed <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、適切なのはこのイニシャライザを<bpt i="1" x="1">&lt;c1&gt;</bpt>init(_ celsius: Double)<ept i="1">&lt;/c1&gt;</ept>のように書くことであり、それによってそれは名前のない<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>値を提供することで呼び出されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It iterates over the items in the container to add them up, and divides by the container’s count to compute the average.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、コンテナの中の項目すべてにわたって繰り返していき、それらを合計します、そしてコンテナの総数で除算することで平均を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It lets you write the code that’s typically executed without wrapping it in an <bpt i="2" x="2">&lt;c2&gt;</bpt>else<ept i="2">&lt;/c2&gt;</ept> block, and it lets you keep the code that handles a violated requirement next to the requirement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはあなたにコードをそれが概ね<bpt i="2" x="2">&lt;c2&gt;</bpt>else<ept i="2">&lt;/c2&gt;</ept>ブロックの内にそれを包み込むことなしに実行されるように書かせて、尚且つそれはあなたにコードをそれがある破られた要件から次の要件を取り扱うように保ったままにさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It makes for shorter, clearer initializers and enables you to infer the type of the property from its default value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、より短い、より明白なイニシャライザを作り、あなたにその省略時の値からプロパティの型を推論するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It may seem an unusual way to represent negative numbers, but it has several advantages.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは負数を表す普通でない方法のようかもしれません、しかしそれはいくつかの利点を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It multiplies a starting value of <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept> (that is, <bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept> to the power of <bpt i="4" x="4">&lt;c4&gt;</bpt>0<ept i="4">&lt;/c4&gt;</ept>) by <bpt i="5" x="5">&lt;c5&gt;</bpt>3<ept i="5">&lt;/c5&gt;</ept>, ten times, using a closed range that starts with <bpt i="6" x="6">&lt;c6&gt;</bpt>1<ept i="6">&lt;/c6&gt;</ept> and ends with <bpt i="7" x="7">&lt;c7&gt;</bpt>10<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは開始値の<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>（すなわち、<bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept>の<bpt i="4" x="4">&lt;c4&gt;</bpt>0<ept i="4">&lt;/c4&gt;</ept>乗）に<bpt i="5" x="5">&lt;c5&gt;</bpt>3<ept i="5">&lt;/c5&gt;</ept>を掛けることを、10回、<bpt i="6" x="6">&lt;c6&gt;</bpt>1<ept i="6">&lt;/c6&gt;</ept>から始まり<bpt i="7" x="7">&lt;c7&gt;</bpt>10<ept i="7">&lt;/c7&gt;</ept>で終わる完結範囲を使って行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It must be possible to access a count of the items in the container through a <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> property that returns an <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンテナの中の項目の総数にアクセスすることが<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値を返す<bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>プロパティを通して可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It must be possible to add a new item to the container with an <bpt i="0" x="0">&lt;c0&gt;</bpt>append(_:)<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい項目をコンテナに加えることが<bpt i="0" x="0">&lt;c0&gt;</bpt>append(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドで可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It must be possible to retrieve each item in the container with a subscript that takes an <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> index value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンテナの中の各項目を取り出すことが<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>インデックス値をとる添え字で可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It provides a gettable <bpt i="2" x="2">&lt;c2&gt;</bpt>dice<ept i="2">&lt;/c2&gt;</ept> property and a <bpt i="3" x="3">&lt;c3&gt;</bpt>play()<ept i="3">&lt;/c3&gt;</ept> method in order to conform to the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、プロトコルに従うために取得可能な<bpt i="2" x="2">&lt;c2&gt;</bpt>dice<ept i="2">&lt;/c2&gt;</ept>プロパティと<bpt i="3" x="3">&lt;c3&gt;</bpt>play()<ept i="3">&lt;/c3&gt;</ept>メソッドを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It resets a <bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfTurns<ept i="2">&lt;/c2&gt;</ept> property to zero when the game starts, increments it each time a new turn begins, and prints out the total number of turns once the game has ended.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、ゲームが始まるとき<bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfTurns<ept i="2">&lt;/c2&gt;</ept>プロパティをゼロに再設定します、新しいターンが開始するときそれぞれそれを増加させます、そしてひとたびゲームが終わってしまったならばターンの総数を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It returns <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept> if the <bpt i="4" x="4">&lt;e4&gt;</bpt>expression<ept i="4">&lt;/e4&gt;</ept> can be cast to the specified <bpt i="5" x="5">&lt;e5&gt;</bpt>type<ept i="5">&lt;/e5&gt;</ept>; otherwise, it returns <bpt i="6" x="6">&lt;c6&gt;</bpt>false<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、<bpt i="4" x="4">&lt;e4&gt;</bpt>式<ept i="4">&lt;/e4&gt;</ept>が指定された<bpt i="5" x="5">&lt;e5&gt;</bpt>型<ept i="5">&lt;/e5&gt;</ept>へキャストできるならば<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>を返します；そうでなければ<bpt i="6" x="6">&lt;c6&gt;</bpt>false<ept i="6">&lt;/c6&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It returns a new number whose bits are set to <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept> only if the bits were equal to <bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept> in <bpt i="4" x="4">&lt;e4&gt;</bpt>both<ept i="4">&lt;/e4&gt;</ept> input numbers:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはある新しい数を返します、それのビットは<bpt i="4" x="4">&lt;e4&gt;</bpt>両方の<ept i="4">&lt;/e4&gt;</ept>入力数においてビットが<bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>と等しかった場合にだけ<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>に設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It returns an integer value to indicate the actual number of coins that were provided.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、提供されたコインの実際の数を示す整数値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It returns either the enumeration case matching the raw value or <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> if there is no matching <bpt i="2" x="2">&lt;c2&gt;</bpt>Rank<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、その生の値に合致する列挙ケース節、または合致する<bpt i="2" x="2">&lt;c2&gt;</bpt>Rank<ept i="2">&lt;/c2&gt;</ept>がないならば<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>のどちらかを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It says “I am done with the current loop iteration” without leaving the loop altogether.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、そのループをすっかり止めてしまわずに「私は、現在のループ繰り返しを終えた」と言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It starts by calculating an appropriate origin point based on a <bpt i="2" x="2">&lt;c2&gt;</bpt>center<ept i="2">&lt;/c2&gt;</ept> point and a <bpt i="3" x="3">&lt;c3&gt;</bpt>size<ept i="3">&lt;/c3&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>center<ept i="2">&lt;/c2&gt;</ept>地点と<bpt i="3" x="3">&lt;c3&gt;</bpt>size<ept i="3">&lt;/c3&gt;</ept>値に基づいて適切な原点を計算することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It starts with an initial value of <bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、初期値の<bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>から始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It states that it adopts the <bpt i="1" x="1">&lt;c1&gt;</bpt>FullyNamed<ept i="1">&lt;/c1&gt;</ept> protocol as part of the first line of its definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、その定義の最初の行の部分でそれが<bpt i="1" x="1">&lt;c1&gt;</bpt>FullyNamed<ept i="1">&lt;/c1&gt;</ept>プロトコルを採用すると述べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It then calls (or <bpt i="4" x="4">&lt;e4&gt;</bpt>delegates<ept i="4">&lt;/e4&gt;</ept>) to the <bpt i="5" x="5">&lt;c5&gt;</bpt>init(origin:size:)<ept i="5">&lt;/c5&gt;</ept> initializer, which stores the new origin and size values in the appropriate properties:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、それから<bpt i="5" x="5">&lt;c5&gt;</bpt>init(origin:size:)<ept i="5">&lt;/c5&gt;</ept>イニシャライザに呼び出し（または<bpt i="4" x="4">&lt;e4&gt;</bpt>委任<ept i="4">&lt;/e4&gt;</ept>）をします、それは、新しい原点とサイズ値を適切なプロパティに格納します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It then calls a designated initializer on its superclass to continue the initialization up the chain.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはそれから、連鎖を上って初期化を続けるために、そのスーパークラス上で指定イニシャライザを呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It then continues to repeat the loop until the condition is <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはそれから、条件が<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>になるまでループを繰り返し続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It then declares a variable called <bpt i="0" x="0">&lt;c0&gt;</bpt>cinema<ept i="0">&lt;/c0&gt;</ept> and sets it to the current value of <bpt i="1" x="1">&lt;c1&gt;</bpt>hd<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、それから<bpt i="0" x="0">&lt;c0&gt;</bpt>cinema<ept i="0">&lt;/c0&gt;</ept>と呼ばれる変数を宣言して、それを<bpt i="1" x="1">&lt;c1&gt;</bpt>hd<ept i="1">&lt;/c1&gt;</ept>の現在の値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It then executes an appropriate block of code, based on the first pattern that matches successfully.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはそれから、うまく合う最初のパターンに基づいて、適切なコードのブロックを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It then iterates through the array of board squares, and appends a geometric shape to represent the contents of each square:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、それからボードの正方形の配列の端から端まで繰り返して、ある幾何学形を各正方形の内容を表わすために追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It then uses the <bpt i="6" x="6">&lt;c6&gt;</bpt>fallthrough<ept i="6">&lt;/c6&gt;</ept> keyword to “fall into” the <bpt i="7" x="7">&lt;c7&gt;</bpt>default<ept i="7">&lt;/c7&gt;</ept> case as well.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはそれから<bpt i="6" x="6">&lt;c6&gt;</bpt>fallthrough<ept i="6">&lt;/c6&gt;</ept>キーワードを使って、<bpt i="7" x="7">&lt;c7&gt;</bpt>default<ept i="7">&lt;/c7&gt;</ept>ケース節にもまた「落ちていく」ようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It uses an instance property called <bpt i="1" x="1">&lt;c1&gt;</bpt>currentLevel<ept i="1">&lt;/c1&gt;</ept> to track the level that a player is currently playing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは<bpt i="1" x="1">&lt;c1&gt;</bpt>currentLevel<ept i="1">&lt;/c1&gt;</ept>と呼ばれるインスタンスプロパティをプレーヤーが現在プレイしているレベルを追跡するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It uses special values for <bpt i="4" x="4">&lt;c4&gt;</bpt>jack<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>queen<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>king<ept i="6">&lt;/c6&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>ace<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、<bpt i="4" x="4">&lt;c4&gt;</bpt>jack<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>queen<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>king<ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>ace<ept i="7">&lt;/c7&gt;</ept>のために特別な値を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It uses these methods to keep track of the number of turns a game has taken.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あるゲームがとったターンの数の情報を得続けるためにこれらのメソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It would be convenient for an inventory tracking system to be able to store UPC barcodes as a tuple of four integers, and QR code barcodes as a string of any length.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UPCバーコードを４つの整数のタプルとして、そしてQRコード・バーコードを任意の長さの文字列として保存できるのは、在庫追跡システムにとって便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It would be much more useful to define a <bpt i="2" x="2">&lt;e2&gt;</bpt>generic<ept i="2">&lt;/e2&gt;</ept> <bpt i="3" x="3">&lt;c3&gt;</bpt>Stack<ept i="3">&lt;/c3&gt;</ept> class, that can manage a stack of <bpt i="4" x="4">&lt;e4&gt;</bpt>any<ept i="4">&lt;/e4&gt;</ept> type of value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それをもっと役に立つようにするには、<bpt i="2" x="2">&lt;e2&gt;</bpt>総称体<ept i="2">&lt;/e2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Stack<ept i="3">&lt;/c3&gt;</ept>クラスを定義することです、それは<bpt i="4" x="4">&lt;e4&gt;</bpt>あらゆる<ept i="4">&lt;/e4&gt;</ept>型の値のスタックを管理することができるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Iterating Over a Dictionary</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書じゅうを繰り返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Iterating Over a Set</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合全体を繰り返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Iterating Over an Array</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列じゅうを繰り返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Its combination of safety and speed make Swift an excellent choice for everything from “Hello, world!” to an entire operating system.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その安全とスピードの連携は、スウィフトを「Hello, world!」からオペレーティングシステム全体までのあらゆることに対する素晴らしい選択とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Its conciseness can lead to hard-to-read code if overused.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その簡潔さは、濫用されるならば、読み辛いコードに至る可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Its keys are of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>, and its values are of type <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのキーは<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>型です、そしてその値は<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Its parameters are then implicitly named <bpt i="0" x="0">&lt;c0&gt;</bpt>$<ept i="0">&lt;/c0&gt;</ept> followed by their position: <bpt i="1" x="1">&lt;c1&gt;</bpt>$0<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>$1<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>$2<ept i="3">&lt;/c3&gt;</ept>, and so on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのパラメータは、それから暗黙のうちに<bpt i="0" x="0">&lt;c0&gt;</bpt>$<ept i="0">&lt;/c0&gt;</ept>の後にそれらの位置が続く名前：<bpt i="1" x="1">&lt;c1&gt;</bpt>$0<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>$1<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>$2<ept i="3">&lt;/c3&gt;</ept>、などをつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Its size is based on a constant called <bpt i="1" x="1">&lt;c1&gt;</bpt>finalSquare<ept i="1">&lt;/c1&gt;</ept>, which is used to initialize the array and also to check for a win condition later in the example.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その大きさは<bpt i="1" x="1">&lt;c1&gt;</bpt>finalSquare<ept i="1">&lt;/c1&gt;</ept>と呼ばれる定数に基づきます、そして、それがこの配列を初期化して、さらにこの例の後半で勝利したかどうか調べるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s a compile-time error to override a method without the <bpt i="1" x="1">&lt;c1&gt;</bpt>override<ept i="1">&lt;/c1&gt;</ept> modifier or to use the <bpt i="2" x="2">&lt;c2&gt;</bpt>override<ept i="2">&lt;/c2&gt;</ept> modifier on a method that doesn’t override a superclass method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>override<ept i="1">&lt;/c1&gt;</ept>宣言修飾子なしでメソッドをオーバーライドするか、スーパークラスメソッドをオーバーライドしないメソッドで<bpt i="2" x="2">&lt;c2&gt;</bpt>override<ept i="2">&lt;/c2&gt;</ept>宣言修飾子を使用することは、コンパイル時エラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s a compile-time error to write a structure or enumeration definition that tries to adopt <bpt i="1" x="1">&lt;c1&gt;</bpt>SomeClassOnlyProtocol<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>SomeClassOnlyProtocol<ept i="1">&lt;/c1&gt;</ept>を採用しようと試みる構造体や列挙定義を書くことは、コンパイル時エラーになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s a safe, fast, and interactive programming language that combines the best in modern language thinking with wisdom from the wider Apple engineering culture and the diverse contributions from its open-source community.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、安全で、高速な、そしてインタラクティブなプログラミング言語であり、現代の言語の最良の思想を、幅広いアップル工学文化由来の知的資産およびそのオープンソース・コミュニティからの多様な貢献と結合するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s a shortcut for evaluating one of two expressions based on whether <bpt i="2" x="2">&lt;c2&gt;</bpt>question<ept i="2">&lt;/c2&gt;</ept> is true or false.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>question<ept i="2">&lt;/c2&gt;</ept>が真実であるか間違っているかに基づいて、２つの式のうちの１つを評価することに対する近道です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s an industrial-quality programming language that’s as expressive and enjoyable as a scripting language.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、スクリプティング言語と同じくらい表現豊かで楽しい、工業品質のプログラミング言語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s applied to a class to indicate that the class can’t be subclassed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはクラスに適用されて、そのクラスがサブクラスを作られることができないのを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s applied to a property, method, or subscript of a class to indicate that a class member can’t be overridden in any subclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはプロパティ、メソッド、またはクラスの添え字に適用されて、そのクラスメンバーがあらゆるサブクラスにおいてオーバーライドされることができないのを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s common to <bpt i="0" x="0">&lt;e0&gt;</bpt>call<ept i="0">&lt;/e0&gt;</ept> functions that take autoclosures, but it’s not common to <bpt i="1" x="1">&lt;e1&gt;</bpt>implement<ept i="1">&lt;/e1&gt;</ept> that kind of function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自動クロージャを取る関数を<bpt i="0" x="0">&lt;e0&gt;</bpt>呼び出す<ept i="0">&lt;/e0&gt;</ept>のは普通です、しかしそのような関数を<bpt i="1" x="1">&lt;e1&gt;</bpt>実装する<ept i="1">&lt;/e1&gt;</ept>のは一般的ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s either an <bpt i="11" x="11">&lt;c11&gt;</bpt>Int<ept i="11">&lt;/c11&gt;</ept>, or it’s nothing at all.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはひとつの<bpt i="11" x="11">&lt;c11&gt;</bpt>Int<ept i="11">&lt;/c11&gt;</ept>、またはそれは全く何も無いかのどちらかです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s even valid for a subclass member to call a superclass member that has lower access permissions than the subclass member, as long as the call to the superclass’s member takes place within an allowed access level context (that is, within the same source file as the superclass for a file-private member call, or within the same module as the superclass for an internal member call):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラスのメンバーへの呼び出しがある許されるアクセス水準文脈内で（すなわち、ファイル外非公開メンバー呼び出しのためのスーパークラスと同じソースファイル内で、または内部メンバー呼び出しのためのスーパークラスと同じモジュール内で）起こる限り、サブクラスメンバーより低いアクセス許可を持つスーパークラスメンバーを呼び出すことは、サブクラスメンバーにとってさえ有効です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s more useful, and considerably more flexible, to write a single function that swaps two values of <bpt i="0" x="0">&lt;e0&gt;</bpt>any<ept i="0">&lt;/e0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらに役に立ち、そしてよりずっと柔軟であるのは、<bpt i="0" x="0">&lt;e0&gt;</bpt>あらゆる<ept i="0">&lt;/e0&gt;</ept>型の２つの値を交換できるただ１つの関数を書くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s not of type <bpt i="2" x="2">&lt;c2&gt;</bpt>Dice<ept i="2">&lt;/c2&gt;</ept>, or <bpt i="3" x="3">&lt;c3&gt;</bpt>DiceGame<ept i="3">&lt;/c3&gt;</ept>, or <bpt i="4" x="4">&lt;c4&gt;</bpt>Hamster<ept i="4">&lt;/c4&gt;</ept>, even if the actual instance behind the scenes is of one of those types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは型<bpt i="2" x="2">&lt;c2&gt;</bpt>Dice<ept i="2">&lt;/c2&gt;</ept>、または<bpt i="3" x="3">&lt;c3&gt;</bpt>DiceGame<ept i="3">&lt;/c3&gt;</ept>、または<bpt i="4" x="4">&lt;c4&gt;</bpt>Hamster<ept i="4">&lt;/c4&gt;</ept>ではありません、たとえ舞台裏の実際のインスタンスがそれらの型のうちの１つであるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s not valid to mark the definition of <bpt i="0" x="0">&lt;c0&gt;</bpt>someFunction()<ept i="0">&lt;/c0&gt;</ept> with the <bpt i="1" x="1">&lt;c1&gt;</bpt>public<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>internal<ept i="2">&lt;/c2&gt;</ept> modifiers, or to use the default setting of internal, because public or internal users of the function might not have appropriate access to the private class used in the function’s return type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>someFunction()<ept i="0">&lt;/c0&gt;</ept>の定義が<bpt i="1" x="1">&lt;c1&gt;</bpt>public<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>internal<ept i="2">&lt;/c2&gt;</ept>を使って印されること、または省略時設定の内部を使うことは有効ではありません、なぜなら、この関数の公開や内部のユーザーは適切なアクセスを関数の戻り型の中で使われる非公開クラスに対して持たないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s not valid to write a public property with a private type, for example.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、非公開の型で公開のプロパティを書くことは、有効ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s now possible to iterate over the items in the array, and print each item’s textual description:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>現在この配列の項目の上に繰り返して、各項目のもつ説明テキストを出力することが可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s possible that the dice roll may have moved the player beyond square 25, in which case the game is over.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さいころを振ることが正方形25を越えてプレーヤーを動かす可能性はあり得ます、その場合にはゲームは終了です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s rare that you need to write type annotations in practice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが型注釈を書く必要があることは実際問題として、まれです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s said to be <bpt i="5" x="5">&lt;e5&gt;</bpt>half-open<ept i="5">&lt;/e5&gt;</ept> because it contains its first value, but not its final value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが<bpt i="5" x="5">&lt;e5&gt;</bpt>半開<ept i="5">&lt;/e5&gt;</ept>と言われるのは、それがその最初の値を含むけれども、その最後の値は含まないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s sometimes necessary for a method to modify (or <bpt i="0" x="0">&lt;e0&gt;</bpt>mutate<ept i="0">&lt;/e0&gt;</ept>) the instance it belongs to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッドがそれが属しているインスタンスを修正する（または<bpt i="0" x="0">&lt;e0&gt;</bpt>変化させる<ept i="0">&lt;/e0&gt;</ept>）ことは、時々必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It’s sometimes useful to include parentheses when they’re not strictly needed, to make the intention of a complex expression easier to read.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複雑な式をより簡単に読めるようにするため、丸括弧をそれらが厳密には必要とされないとき含むことは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Just before this happens, its deinitializer is called automatically, and its coins are returned to the bank.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これが起こる直前に、そのデイニシャライザは自動的に呼ばれます、そしてそのコインは胴元に返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Just like functions and methods, initializers can throw or rethrow errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数やメソッドのように、イニシャライザはエラーをスローまたは再スローできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Just like when you include a value on both sides, the final value isn’t part of the range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ちょうどあなたが両方の側で１つの値を含める場合のように、最後の値はその範囲の一部分ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keeping the sign bit the same during this shift means that negative integers remain negative as their value moves closer to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このシフトの間に符号ビットを同じに保つことは、それの値がゼロの近くに動くとき、負整数が負のままであることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Key paths can be used to access properties by passing them to the <bpt i="3" x="3">&lt;c3&gt;</bpt>subscript(keyPath:)<ept i="3">&lt;/c3&gt;</ept> subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパスは、それらを<bpt i="3" x="3">&lt;c3&gt;</bpt>subscript(keyPath:)<ept i="3">&lt;/c3&gt;</ept>添え字に渡すことによってプロパティにアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Key-Path Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパス式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Key-Path String Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパス文字列式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keywords and Punctuation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーワードと句読点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keywords other than <bpt i="2" x="2">&lt;c2&gt;</bpt>inout<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>var<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>let<ept i="4">&lt;/c4&gt;</ept> can be used as parameter names in a function declaration or function call without being escaped with backticks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>inout<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>var<ept i="3">&lt;/c3&gt;</ept>、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>let<ept i="4">&lt;/c4&gt;</ept>以外のキーワードは、パラメータ名として関数定義または関数呼び出しにおいてバッククォートでエスケープされることなく使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keywords reserved in particular contexts: <bpt i="0" x="0">&lt;c0&gt;</bpt>associativity<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>convenience<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>dynamic<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>didSet<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>final<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>get<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>infix<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>indirect<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>lazy<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>left<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>mutating<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>none<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>nonmutating<ept i="12">&lt;/c12&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt>optional<ept i="13">&lt;/c13&gt;</ept>, <bpt i="14" x="14">&lt;c14&gt;</bpt>override<ept i="14">&lt;/c14&gt;</ept>, <bpt i="15" x="15">&lt;c15&gt;</bpt>postfix<ept i="15">&lt;/c15&gt;</ept>, <bpt i="16" x="16">&lt;c16&gt;</bpt>precedence<ept i="16">&lt;/c16&gt;</ept>, <bpt i="17" x="17">&lt;c17&gt;</bpt>prefix<ept i="17">&lt;/c17&gt;</ept>, <bpt i="18" x="18">&lt;c18&gt;</bpt>Protocol<ept i="18">&lt;/c18&gt;</ept>, <bpt i="19" x="19">&lt;c19&gt;</bpt>required<ept i="19">&lt;/c19&gt;</ept>, <bpt i="20" x="20">&lt;c20&gt;</bpt>right<ept i="20">&lt;/c20&gt;</ept>, <bpt i="21" x="21">&lt;c21&gt;</bpt>set<ept i="21">&lt;/c21&gt;</ept>, <bpt i="22" x="22">&lt;c22&gt;</bpt>Type<ept i="22">&lt;/c22&gt;</ept>, <bpt i="23" x="23">&lt;c23&gt;</bpt>unowned<ept i="23">&lt;/c23&gt;</ept>, <bpt i="24" x="24">&lt;c24&gt;</bpt>weak<ept i="24">&lt;/c24&gt;</ept>, and <bpt i="25" x="25">&lt;c25&gt;</bpt>willSet<ept i="25">&lt;/c25&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特定の前後関係において予約されるキーワード：<bpt i="0" x="0">&lt;c0&gt;</bpt>associativity<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>convenience<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>dynamic<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>didSet<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>final<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>get<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>infix<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>indirect<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>lazy<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>left<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>mutating<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>none<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>nonmutating<ept i="12">&lt;/c12&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt>optional<ept i="13">&lt;/c13&gt;</ept>, <bpt i="14" x="14">&lt;c14&gt;</bpt>override<ept i="14">&lt;/c14&gt;</ept>, <bpt i="15" x="15">&lt;c15&gt;</bpt>postfix<ept i="15">&lt;/c15&gt;</ept>, <bpt i="16" x="16">&lt;c16&gt;</bpt>precedence<ept i="16">&lt;/c16&gt;</ept>, <bpt i="17" x="17">&lt;c17&gt;</bpt>prefix<ept i="17">&lt;/c17&gt;</ept>, <bpt i="18" x="18">&lt;c18&gt;</bpt>Protocol<ept i="18">&lt;/c18&gt;</ept>, <bpt i="19" x="19">&lt;c19&gt;</bpt>required<ept i="19">&lt;/c19&gt;</ept>, <bpt i="20" x="20">&lt;c20&gt;</bpt>right<ept i="20">&lt;/c20&gt;</ept>, <bpt i="21" x="21">&lt;c21&gt;</bpt>set<ept i="21">&lt;/c21&gt;</ept>, <bpt i="22" x="22">&lt;c22&gt;</bpt>Type<ept i="22">&lt;/c22&gt;</ept>, <bpt i="23" x="23">&lt;c23&gt;</bpt>unowned<ept i="23">&lt;/c23&gt;</ept>, <bpt i="24" x="24">&lt;c24&gt;</bpt>weak<ept i="24">&lt;/c24&gt;</ept>, そして<bpt i="25" x="25">&lt;c25&gt;</bpt>willSet<ept i="25">&lt;/c25&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keywords that begin with a number sign (<bpt i="0" x="0">&lt;c0&gt;</bpt>#<ept i="0">&lt;/c0&gt;</ept>): <bpt i="1" x="1">&lt;c1&gt;</bpt>#available<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>#colorLiteral<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>#column<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>#else<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>#elseif<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>#endif<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>#file<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>#fileLiteral<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>#function<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>#if<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>#imageLiteral<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>#line<ept i="12">&lt;/c12&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt>#selector<ept i="13">&lt;/c13&gt;</ept>, and <bpt i="14" x="14">&lt;c14&gt;</bpt>#sourceLocation<ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>番号記号（<bpt i="0" x="0">&lt;c0&gt;</bpt>#<ept i="0">&lt;/c0&gt;</ept>）で始まるキーワード：<bpt i="1" x="1">&lt;c1&gt;</bpt>#available<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>#colorLiteral<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>#column<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>#else<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>#elseif<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>#endif<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>#file<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>#fileLiteral<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>#function<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>#if<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>#imageLiteral<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>#line<ept i="12">&lt;/c12&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt>#selector<ept i="13">&lt;/c13&gt;</ept>, そして<bpt i="14" x="14">&lt;c14&gt;</bpt>#sourceLocation<ept i="14">&lt;/c14&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keywords used in declarations: <bpt i="0" x="0">&lt;c0&gt;</bpt>associatedtype<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>deinit<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>enum<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>extension<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>fileprivate<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>func<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>import<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>init<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>inout<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>internal<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>let<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>open<ept i="12">&lt;/c12&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt>operator<ept i="13">&lt;/c13&gt;</ept>, <bpt i="14" x="14">&lt;c14&gt;</bpt>private<ept i="14">&lt;/c14&gt;</ept>, <bpt i="15" x="15">&lt;c15&gt;</bpt>protocol<ept i="15">&lt;/c15&gt;</ept>, <bpt i="16" x="16">&lt;c16&gt;</bpt>public<ept i="16">&lt;/c16&gt;</ept>, <bpt i="17" x="17">&lt;c17&gt;</bpt>static<ept i="17">&lt;/c17&gt;</ept>, <bpt i="18" x="18">&lt;c18&gt;</bpt>struct<ept i="18">&lt;/c18&gt;</ept>, <bpt i="19" x="19">&lt;c19&gt;</bpt>subscript<ept i="19">&lt;/c19&gt;</ept>, <bpt i="20" x="20">&lt;c20&gt;</bpt>typealias<ept i="20">&lt;/c20&gt;</ept>, and <bpt i="21" x="21">&lt;c21&gt;</bpt>var<ept i="21">&lt;/c21&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言において使用されるキーワード：<bpt i="0" x="0">&lt;c0&gt;</bpt>associatedtype<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>deinit<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>enum<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>extension<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>fileprivate<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>func<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>import<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>init<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>inout<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>internal<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>let<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>open<ept i="12">&lt;/c12&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt>operator<ept i="13">&lt;/c13&gt;</ept>, <bpt i="14" x="14">&lt;c14&gt;</bpt>private<ept i="14">&lt;/c14&gt;</ept>, <bpt i="15" x="15">&lt;c15&gt;</bpt>protocol<ept i="15">&lt;/c15&gt;</ept>, <bpt i="16" x="16">&lt;c16&gt;</bpt>public<ept i="16">&lt;/c16&gt;</ept>, <bpt i="17" x="17">&lt;c17&gt;</bpt>static<ept i="17">&lt;/c17&gt;</ept>, <bpt i="18" x="18">&lt;c18&gt;</bpt>struct<ept i="18">&lt;/c18&gt;</ept>, <bpt i="19" x="19">&lt;c19&gt;</bpt>subscript<ept i="19">&lt;/c19&gt;</ept>, <bpt i="20" x="20">&lt;c20&gt;</bpt>typealias<ept i="20">&lt;/c20&gt;</ept>, そして<bpt i="21" x="21">&lt;c21&gt;</bpt>var<ept i="21">&lt;/c21&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keywords used in expressions and types: <bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Any<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>catch<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>is<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>rethrows<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>super<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>self<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>Self<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>throw<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>throws<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>true<ept i="12">&lt;/c12&gt;</ept>, and <bpt i="13" x="13">&lt;c13&gt;</bpt>try<ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>式と型において使用されるキーワード：<bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Any<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>catch<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>is<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>rethrows<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>super<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>self<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>Self<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>throw<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>throws<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>true<ept i="12">&lt;/c12&gt;</ept>, そして<bpt i="13" x="13">&lt;c13&gt;</bpt>try<ept i="13">&lt;/c13&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keywords used in patterns: <bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パターンにおいて使用されるキーワード：<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keywords used in statements: <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>case<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>continue<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>default<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>defer<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>do<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>else<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>fallthrough<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>for<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>guard<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>if<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>in<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>repeat<ept i="12">&lt;/c12&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt>return<ept i="13">&lt;/c13&gt;</ept>, <bpt i="14" x="14">&lt;c14&gt;</bpt>switch<ept i="14">&lt;/c14&gt;</ept>, <bpt i="15" x="15">&lt;c15&gt;</bpt>where<ept i="15">&lt;/c15&gt;</ept>, and <bpt i="16" x="16">&lt;c16&gt;</bpt>while<ept i="16">&lt;/c16&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文において使用されるキーワード：<bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>case<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>continue<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>default<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>defer<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>do<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>else<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>fallthrough<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>for<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>guard<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>if<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>in<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>repeat<ept i="12">&lt;/c12&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt>return<ept i="13">&lt;/c13&gt;</ept>, <bpt i="14" x="14">&lt;c14&gt;</bpt>switch<ept i="14">&lt;/c14&gt;</ept>, <bpt i="15" x="15">&lt;c15&gt;</bpt>where<ept i="15">&lt;/c15&gt;</ept>, そして<bpt i="16" x="16">&lt;c16&gt;</bpt>while<ept i="16">&lt;/c16&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Labeled Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ラベルをつけられた文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Labeled Statements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ラベルをつけられた文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Language Guide</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>言語ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Language Reference</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>言語リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Lazy Stored Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延保存プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that should not be performed unless or until it is needed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延プロパティはまた、プロパティのための最初の値が、それが必要でないなら、あるいは必要になるまで、実行されるべきではない複雑なまたはコンピュータ処理的に高くつく準備を必要とするときに役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Lazy properties are useful when the initial value for a property is dependent on outside factors whose values are not known until after an instance’s initialization is complete.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延プロパティが役に立つのは、プロパティのための最初の値がインスタンスの初期化が終了する後まで値が知られない外部の要因に依存しているときです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Less than (<bpt i="0" x="0">&lt;c0&gt;</bpt>a &lt; b<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より小さい、未満（<bpt i="0" x="0">&lt;c0&gt;</bpt>a &lt; b<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Less than or equal to (<bpt i="0" x="0">&lt;c0&gt;</bpt>a &lt;= b<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より小さいか等しい、以下（<bpt i="0" x="0">&lt;c0&gt;</bpt>a &lt;= b<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Lexical Structure</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>語彙の構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like C, Swift has only one ternary operator, the ternary conditional operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>a ? b : c<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cのように、スウィフトはただ１つの三項演算子、三項条件演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>a ? b : c<ept i="1">&lt;/c1&gt;</ept>）だけをもちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like C, Swift provides <bpt i="0" x="0">&lt;e0&gt;</bpt>compound assignment operators<ept i="0">&lt;/e0&gt;</ept> that combine assignment (<bpt i="1" x="1">&lt;c1&gt;</bpt>=<ept i="1">&lt;/c1&gt;</ept>) with another operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cのように、スウィフトは<bpt i="0" x="0">&lt;e0&gt;</bpt>複合代入演算子<ept i="0">&lt;/e0&gt;</ept>を提供します、それは、代入（<bpt i="1" x="1">&lt;c1&gt;</bpt>=<ept i="1">&lt;/c1&gt;</ept>）を別の演算と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like C, Swift uses variables to store and refer to values by an identifying name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cのように、スウィフトはひとつの識別名によっていろいろな値を保管したり引用したりするために、変数を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement, the compiler attempts to infer whether <bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> clauses are exhaustive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文のように、コンパイラは<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>節が徹底的であるか推論を試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like a function declaration, a closure contains statements, and it captures constants and variables from its enclosing scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数宣言の様に、クロージャはいくつかの文を含みます、そしてそれは、定数と変数をそれの取り囲むスコープからキャプチャします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like a function, an initializer can be used as a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数のように、イニシャライザは値として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like a weak reference, an <bpt i="0" x="0">&lt;e0&gt;</bpt>unowned reference<ept i="0">&lt;/e0&gt;</ept> does not keep a strong hold on the instance it refers to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>弱い参照のように、<bpt i="0" x="0">&lt;e0&gt;</bpt>非所有者参照<ept i="0">&lt;/e0&gt;</ept>は、それが言及するインスタンスに対する強い支配力を保ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like a weak reference, the type of the property or value must be a class type; unlike a weak reference, the type is nonoptional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>弱い参照のように、プロパティや値の型はクラス型でなければなりません；弱い参照と違って、その型は非オプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like all types in Swift, these integer types have capitalized names.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおける全ての型のように、これらの整数型は頭文字を使った名前を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like classes and all other named types, enumerations can have methods associated with them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスや全ての他の名前をつけられた型のように、列挙はそれと結びつけられるメソッドを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like other types in Swift, their names (such as <bpt i="0" x="0">&lt;c0&gt;</bpt>CompassPoint<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Planet<ept i="1">&lt;/c1&gt;</ept>) should start with a capital letter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおける他の型のように、それらの名前（例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>CompassPoint<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>Planet<ept i="1">&lt;/c1&gt;</ept>）は、大文字から始めなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like strings, each substring has a region of memory where the characters that make up the substring are stored.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列のように、下位文字列それぞれはメモリのある領域を持ち、そこで下位文字列を作り上げる文字が格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like structures but unlike classes, enumerations are value types; instances of an enumeration are copied when assigned to variables or constants, or when passed as arguments to a function call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体のように、しかしクラスとは違い、列挙は値型です；列挙のインスタンスは、変数や定数に代入されるとき、または関数呼び出しに引数として渡されるときにコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like the <bpt i="3" x="3">&lt;c3&gt;</bpt>remove(at:)<ept i="3">&lt;/c3&gt;</ept> method, <bpt i="4" x="4">&lt;c4&gt;</bpt>removeLast()<ept i="4">&lt;/c4&gt;</ept> returns the removed item:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>removeAtIndex(_:)<ept i="3">&lt;/c3&gt;</ept>メソッドのように、<bpt i="4" x="4">&lt;c4&gt;</bpt>remove(at:)<ept i="4">&lt;/c4&gt;</ept>は取り除かれた項目を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like the Logical AND operator above, the Logical OR operator uses short-circuit evaluation to consider its expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の論理積演算子のように、論理和演算子はその式を考慮するために短絡評価を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like the body of an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement, each <bpt i="1" x="1">&lt;c1&gt;</bpt>case<ept i="1">&lt;/c1&gt;</ept> is a separate branch of code execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文の本文のように、各<bpt i="1" x="1">&lt;c1&gt;</bpt>case<ept i="1">&lt;/c1&gt;</ept>は別々の分岐のコード実行です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like the subscript examples above, the <bpt i="1" x="1">&lt;c1&gt;</bpt>updateValue(_:forKey:)<ept i="1">&lt;/c1&gt;</ept> method sets a value for a key if none exists, or updates the value if that key already exists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の添え字の例のように、<bpt i="1" x="1">&lt;c1&gt;</bpt>updateValue(_:forKey:)<ept i="1">&lt;/c1&gt;</ept>メソッドは、まったく何も存在しないならばあるキーに対して値を設定します、またはキーがすでに存在するならばその値を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, because <bpt i="4" x="4">&lt;c4&gt;</bpt>Void<ept i="4">&lt;/c4&gt;</ept> is a type alias for <bpt i="5" x="5">&lt;c5&gt;</bpt>()<ept i="5">&lt;/c5&gt;</ept>, the function type <bpt i="6" x="6">&lt;c6&gt;</bpt>(Void) -&gt; Void<ept i="6">&lt;/c6&gt;</ept> is the same as <bpt i="7" x="7">&lt;c7&gt;</bpt>(()) -&gt; ()<ept i="7">&lt;/c7&gt;</ept>—a function that takes a single argument that is an empty tuple.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、<bpt i="4" x="4">&lt;c4&gt;</bpt>Void<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>()<ept i="5">&lt;/c5&gt;</ept>に対する型エイリアスであることから、関数型<bpt i="6" x="6">&lt;c6&gt;</bpt>(Void) -&gt; Void<ept i="6">&lt;/c6&gt;</ept>は<bpt i="7" x="7">&lt;c7&gt;</bpt>(()) -&gt; ()<ept i="7">&lt;/c7&gt;</ept> — ただ１つの引数を取りそれが空のタプルである関数、と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, if any of the structure’s stored properties are file private, the initializer is file private.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、構造体の持つ保存プロパティのいずれかがファイル外非公開ならば、イニシャライザはファイル外非公開です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, if you don’t specify a type for a floating-point literal, Swift infers that you want to create a <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、あなたがある浮動小数点リテラルのために型を指定しないならば、スウィフトはあなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>をつくりたいと推測します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, if you made a subclass of <bpt i="4" x="4">&lt;c4&gt;</bpt>Location<ept i="4">&lt;/c4&gt;</ept> that didn’t conform to the <bpt i="5" x="5">&lt;c5&gt;</bpt>Named<ept i="5">&lt;/c5&gt;</ept> protocol, calling <bpt i="6" x="6">&lt;c6&gt;</bpt>beginConcert(in:)<ept i="6">&lt;/c6&gt;</ept> with an instance of that type is also invalid.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、あなたが<bpt i="4" x="4">&lt;c4&gt;</bpt>Location<ept i="4">&lt;/c4&gt;</ept>のサブクラスで<bpt i="5" x="5">&lt;c5&gt;</bpt>Named<ept i="5">&lt;/c5&gt;</ept>プロトコルに準拠しないものを作成したならば、<bpt i="6" x="6">&lt;c6&gt;</bpt>beginConcert(in:)<ept i="6">&lt;/c6&gt;</ept>をその型のインスタンスで呼び出すことはまた無効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, method and function declarations are written the same way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらにまた、メソッドおよび関数の宣言も同じやり方で書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, the <bpt i="2" x="2">&lt;c2&gt;</bpt>willSet<ept i="2">&lt;/c2&gt;</ept> clause is optional when you provide a <bpt i="3" x="3">&lt;c3&gt;</bpt>didSet<ept i="3">&lt;/c3&gt;</ept> clause.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、あなたが<bpt i="3" x="3">&lt;c3&gt;</bpt>didSet<ept i="3">&lt;/c3&gt;</ept>節を提供するとき、<bpt i="2" x="2">&lt;c2&gt;</bpt>willSet<ept i="2">&lt;/c2&gt;</ept>節は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, the failable initializer for <bpt i="4" x="4">&lt;c4&gt;</bpt>Product<ept i="4">&lt;/c4&gt;</ept> checks the <bpt i="5" x="5">&lt;c5&gt;</bpt>name<ept i="5">&lt;/c5&gt;</ept> value, and the initializer process fails immediately if <bpt i="6" x="6">&lt;c6&gt;</bpt>name<ept i="6">&lt;/c6&gt;</ept> is the empty string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、<bpt i="4" x="4">&lt;c4&gt;</bpt>Product<ept i="4">&lt;/c4&gt;</ept>のための失敗できるイニシャライザは、<bpt i="5" x="5">&lt;c5&gt;</bpt>name<ept i="5">&lt;/c5&gt;</ept>値を確認して、<bpt i="6" x="6">&lt;c6&gt;</bpt>name<ept i="6">&lt;/c6&gt;</ept>が空の文字列ならば初期化処理は直ちに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, type safety prevents you from accidentally passing an optional <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> to a piece of code that requires a nonoptional <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらに、型安全はあなたがうっかりしてオプショナル<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>を、非オプショナル<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>を要求するコード部分に渡すことを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, you can use <bpt i="4" x="4">&lt;c4&gt;</bpt>SuperClass &amp; ProtocolA<ept i="4">&lt;/c4&gt;</ept> instead of declaring a new protocol that is a subclass of <bpt i="5" x="5">&lt;c5&gt;</bpt>SuperClass<ept i="5">&lt;/c5&gt;</ept> and conforms to <bpt i="6" x="6">&lt;c6&gt;</bpt>ProtocolA<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、あなたは<bpt i="4" x="4">&lt;c4&gt;</bpt>SuperClass &amp; ProtocolA<ept i="4">&lt;/c4&gt;</ept>を使うことが、<bpt i="5" x="5">&lt;c5&gt;</bpt>SuperClass<ept i="5">&lt;/c5&gt;</ept>のサブクラスで<bpt i="6" x="6">&lt;c6&gt;</bpt>ProtocolA<ept i="6">&lt;/c6&gt;</ept>に準拠する新しいプロトコルを宣言する代わりに行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Line Control Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行制御文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Line breaks in a multiline string literal are normalized to use the line feed character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行文字列リテラルの中のラインブレークは、正規化されて、ラインフィード文字を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Line feed (<bpt i="0" x="0">&lt;c0&gt;</bpt>\n<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ラインフィード「字送り文字」（<bpt i="0" x="0">&lt;c0&gt;</bpt>\n<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Linking Multiple Levels of Chaining</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>連鎖の複数の階層を結ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Literal</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Literal Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リテラル式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Literal words and punctuation are indicated by boldface <bpt i="0" x="0">&lt;c0&gt;</bpt>constant width<ept i="0">&lt;/c0&gt;</ept> text and appear only on the right-hand side of a grammar production rule.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リテラルの単語と句読点は、太字体の<bpt i="0" x="0">&lt;c0&gt;</bpt>等幅<ept i="0">&lt;/c0&gt;</ept>テキストによって示されて、文法導出規則の右側だけに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Literals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>様々なリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Local constants and variables are never computed lazily.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ローカルな定数と変数は、決して遅延して計算されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Local variables are variables that are defined within a function, method, or closure context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ローカル変数は、関数、メソッド、またはクロージャの文脈の範囲内で定義される変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Logical AND (<bpt i="0" x="0">&lt;c0&gt;</bpt>a &amp;&amp; b<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理積（<bpt i="0" x="0">&lt;c0&gt;</bpt>a &amp;&amp; b<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Logical AND Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理積演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Logical NOT (<bpt i="0" x="0">&lt;c0&gt;</bpt>!a<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理否定（<bpt i="0" x="0">&lt;c0&gt;</bpt>!a<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Logical NOT Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理否定演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Logical OR (<bpt i="0" x="0">&lt;c0&gt;</bpt>a || b<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理和（<bpt i="0" x="0">&lt;c0&gt;</bpt>a || b<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Logical OR Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理和演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Logical Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Loop Statements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループ文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Loop statements allow a block of code to be executed repeatedly, branch statements allow a certain block of code to be executed only when certain conditions are met, and control transfer statements provide a way to alter the order in which code is executed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループ文はコードの１ブロックが繰り返して実行されるようにします、分岐文はコードの特定のブロックを特定の条件が満たされるときにだけ実行されるようにします、そして制御移動文はコードが実行される順番を変える方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Loop statements allow a block of code to be executed repeatedly, depending on the conditions specified in the loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループ文は、ループにおいて指定される条件に従って、コードの１ブロックを繰り返して実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Make an existing type conform to a protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>既存の型をプロトコルに準拠させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Make another subclass of <bpt i="0" x="0">&lt;c0&gt;</bpt>NamedShape<ept i="0">&lt;/c0&gt;</ept> called <bpt i="1" x="1">&lt;c1&gt;</bpt>Circle<ept i="1">&lt;/c1&gt;</ept> that takes a radius and a name as arguments to its initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NamedShape<ept i="0">&lt;/c0&gt;</ept>の別のサブクラス、<bpt i="1" x="1">&lt;c1&gt;</bpt>Circle<ept i="1">&lt;/c1&gt;</ept>と呼ばれるものを作ってください、それはそのイニシャライザに対する引数として半径と名前をとるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Marking a class as open explicitly indicates that you’ve considered the impact of code from other modules using that class as a superclass, and that you’ve designed your class’s code accordingly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラスを明示的に開放とすることが指し示すのは、あなたが、そのクラスをスーパークラスとして使っている、他のモジュール由来のコードの影響を考慮に入れるということです、そしてあなたがあなたのクラスのコードをそれに従って設計するということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Marking a closure with <bpt i="0" x="0">&lt;c0&gt;</bpt>@escaping<ept i="0">&lt;/c0&gt;</ept> means you have to refer to <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> explicitly within the closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャを<bpt i="0" x="0">&lt;c0&gt;</bpt>@escaping<ept i="0">&lt;/c0&gt;</ept>で印することは、あなたがそのクロージャ内部で<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>を明示的に参照しなければならないのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Matched values in a <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> case can be bound to temporary constants or variables for use within the case’s body, and complex matching conditions can be expressed with a <bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept> clause for each case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>ケース節においてマッチされた値は、そのケース節内の本文で使われるために一時的な定数や変数に結び付けられることができます、そして複雑なマッチ条件が各ケース節に対して<bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept>節を使って表わされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Matching Enumeration Values with a Switch Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スイッチ文で列挙値を照合する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Memberwise Initializers for Structure Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体型のためのメンバー関連イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Memory for a new instance of that class is allocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのクラスの新しいインスタンスに対するメモリが割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Memory is managed automatically.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリは、自動的に管理される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Metatype Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メタタイプ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Method Requirements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッド要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Methods associated with a type rather than an instance of a type must be marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept> declaration modifier for enumerations and structures or the <bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept> declaration modifier for classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型のインスタンスとではなく、ある型と結び付けられるメソッドは、列挙と構造体では<bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept>宣言修飾子で、クラスでは<bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept>宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Methods on a subclass that override the superclass’s implementation are marked with <bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept>—overriding a method by accident, without <bpt i="1" x="1">&lt;c1&gt;</bpt>override<ept i="1">&lt;/c1&gt;</ept>, is detected by the compiler as an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるサブクラスのメソッドで、そのスーパークラスの実装をオーバーライド（再定義）するものは、<bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept>で印を付けられます ― <bpt i="1" x="1">&lt;c1&gt;</bpt>override<ept i="1">&lt;/c1&gt;</ept>なしで、偶然にメソッドをオーバーライドすることは、コンパイラによってエラーとして検出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Methods on an enumeration or a structure that modify <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> must be marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>mutating<ept i="1">&lt;/c1&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙または構造体での<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>を修正するメソッドは、<bpt i="1" x="1">&lt;c1&gt;</bpt>mutating<ept i="1">&lt;/c1&gt;</ept>宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Methods that override a superclass method must be marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラスのメソッドをオーバーライドするメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept>宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Methods, properties, or subscripts that you add to a class in an extension can also be marked as final within the extension’s definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある拡張においてクラスに加えるメソッド、プロパティ、または添え字は、また、拡張の定義内で最終版として印されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Modify the <bpt i="0" x="0">&lt;c0&gt;</bpt>anyCommonElements(_:_:)<ept i="0">&lt;/c0&gt;</ept> function to make a function that returns an array of the elements that any two sequences have in common.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>共通したなんらかの２つの連続物である要素たちをもつある配列を返す関数になるように、<bpt i="0" x="0">&lt;c0&gt;</bpt>anyCommonElements(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数を修正してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Modifying Value Types from Within Instance Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型をインスタンスメソッド内から修正する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Modules and Source Files</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>モジュールとソースファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>More generally, any unqualified method and property names that you use within the body of a type method will refer to other type-level methods and properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より一般的に言えば、あなたがある型メソッドの本文内で使うどんな非修飾のメソッドやプロパティ名でも、他の型レベルのメソッドやプロパティに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Moreover, <bpt i="0" x="0">&lt;c0&gt;</bpt>IntStack<ept i="0">&lt;/c0&gt;</ept> specifies that for this implementation of <bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept>, the appropriate <bpt i="2" x="2">&lt;c2&gt;</bpt>Item<ept i="2">&lt;/c2&gt;</ept> to use is a type of <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらに、<bpt i="0" x="0">&lt;c0&gt;</bpt>IntStack<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept>のこの実施のために、適切な<bpt i="2" x="2">&lt;c2&gt;</bpt>Item<ept i="2">&lt;/c2&gt;</ept>として使用するのは<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>型であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Most code should use the <bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept> attribute instead, to expose only the declarations that are needed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどのコードは、<bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept>属性を代わりに使って、必要とされる宣言だけを露出するべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Most of the time, a type identifier directly refers to a named type with the same name as the identifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの場合、型識別子は、名前付きの型に、その識別子と同じ名前で直接に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiline String Literals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行文字列リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiline comments begin with <bpt i="1" x="1">&lt;c1&gt;</bpt>/*<ept i="1">&lt;/c1&gt;</ept> and end with <bpt i="2" x="2">&lt;c2&gt;</bpt>*/<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行コメントは<bpt i="1" x="1">&lt;c1&gt;</bpt>/*<ept i="1">&lt;/c1&gt;</ept>で始まり<bpt i="2" x="2">&lt;c2&gt;</bpt>*/<ept i="2">&lt;/c2&gt;</ept>で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiline comments start with a forward-slash followed by an asterisk (<bpt i="0" x="0">&lt;c0&gt;</bpt>/*<ept i="0">&lt;/c0&gt;</ept>) and end with an asterisk followed by a forward-slash (<bpt i="1" x="1">&lt;c1&gt;</bpt>*/<ept i="1">&lt;/c1&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行コメントは、スラッシュに続く星印（<bpt i="0" x="0">&lt;c0&gt;</bpt>/*<ept i="0">&lt;/c0&gt;</ept>）で始まり、星印に続くスラッシュ（<bpt i="1" x="1">&lt;c1&gt;</bpt>*/<ept i="1">&lt;/c1&gt;</ept>）で終わります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiple cases can appear on a single line, separated by commas:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数のケース節は、コンマで区切られて、ただ一つの行に現れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiple optional bindings can now appear in a single <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement as a comma-separated list of assignment expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数のオプショナル束縛は、今では単一の<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文においてコンマ区切りの代入式のリストとして現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiple protocols can be listed, and are separated by commas:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数のプロトコルが、コンマで区切られて、リストされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数の問い合わせが一緒に鎖で繋げられることができます、そして連鎖の中のどれかの輪が<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>ならば、その連鎖全体がいさぎよく失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiple switch cases that share the same body can be combined by writing several patterns after <bpt i="0" x="0">&lt;c0&gt;</bpt>case<ept i="0">&lt;/c0&gt;</ept>, with a comma between each of the patterns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じ本文を共有する複数のケース節は、<bpt i="0" x="0">&lt;c0&gt;</bpt>case<ept i="0">&lt;/c0&gt;</ept>の後にそれぞれのパターンを、それぞれのパターンの間のコンマとともに書くことによって結合されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Multiplication (<bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>乗算（<bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mutability of Collections</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コレクションの可変性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mutating Instance Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変インスタンスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mutating Method Requirements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変メソッド要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mutating methods can assign an entirely new instance to the implicit <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変メソッドは、まったく新しいインスタンスを暗黙の<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>プロパティに代入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mutating methods for enumerations can set the implicit <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> parameter to be a different case from the same enumeration:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙のための可変メソッドは、暗黙の<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>パラメータを同じ列挙からの異なるケース節に設定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Named types include classes, structures, enumerations, and protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>名前付きの型は、クラス、構造体、列挙、そしてプロトコルを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Naming Constants and Variables</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数と変数に名をつける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Naming Type Parameters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型パラメータに名をつける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Negative floating-point literals are expressed by prepending a minus sign (<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>) to a floating-point literal, as in <bpt i="1" x="1">&lt;c1&gt;</bpt>-42.5<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>負の浮動小数点数は、浮動小数点リテラルに単項マイナス演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>）を前につけることによって表わされます、<bpt i="1" x="1">&lt;c1&gt;</bpt>-42.5<ept i="1">&lt;/c1&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Negative integers literals are expressed by prepending a minus sign (<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>) to an integer literal, as in <bpt i="1" x="1">&lt;c1&gt;</bpt>-42<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>負整数リテラルは、負符号（<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>）をリテラル整数の前に付けることによって表されます、<bpt i="1" x="1">&lt;c1&gt;</bpt>-42<ept i="1">&lt;/c1&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Negative numbers, however, are stored differently.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>負の数は、しかし異なって保存されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Neither type of formatting affects the underlying value of the literal:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>書式整形のどちらの種類も、もととなるリテラルの値に影響を及ぼしません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested Functions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされた関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされた型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested Types in Action</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされた型の動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested functions are closures that have a name and can capture values from their enclosing function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされた関数は、名前を持ち、それを囲んでいる関数から値を捕獲することができるクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested functions are hidden from the outside world by default, but can still be called and used by their enclosing function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされた関数は、初期状態では外界から隠されます、しかしそれにもかかわらず、それらを囲む関数によって呼び出されて使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested functions have access to variables that were declared in the outer function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされた関数は、外側の関数において宣言された変数に、アクセスをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested functions, as introduced in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Nested Functions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, are a convenient means of naming and defining self-contained blocks of code as part of a larger function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>入れ子にされた関数<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>は、入れ子にされた関数の中で紹介されるように、より大きい関数の一部として、いろいろな完全独立のコードの塊を名前をつけて定義する便利な手段です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested multiline comments enable you to comment out large blocks of code quickly and easily, even if the code already contains multiline comments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされた複数行コメントによって、たとえコードがすでに複数行コメントを含むとしても、あなたは速く簡単にコードの大きなブロックをコメントアウトすることが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested types defined within a file-private type have an automatic access level of file private.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ファイル外非公開型の内側で定義される入れ子にされた型は、自動的なアクセス水準としてファイル外非公開を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested types defined within a private type have an automatic access level of private.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非公開型の内側で定義される入れ子にされた型は、自動的なアクセス水準として非公開を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested types defined within a public type or an internal type have an automatic access level of internal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>公開型または内部型の内側で定義される入れ子にされた型は、自動的なアクセス水準として内部を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nesting multiline comments is allowed, but the comment markers must be balanced.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行コメントが入れ子にされることは許されます、しかしコメント目印が釣り合っている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>New barcodes can then be created using either type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいバーコードは、それからどちらの型を使ってでも作成されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>New document that describes Swift 1.0, Apple’s new programming language for building iOS and OS X apps.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>iOSおよびOS Xアプリ構築のためのAppleの新しいプログラミング言語、スウィフト 1.0を解説する新しい文書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>New operators are declared at a global level using the <bpt i="0" x="0">&lt;c0&gt;</bpt>operator<ept i="0">&lt;/c0&gt;</ept> keyword, and are marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>prefix<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>infix<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>postfix<ept i="3">&lt;/c3&gt;</ept> modifiers:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい演算子は<bpt i="0" x="0">&lt;c0&gt;</bpt>operator<ept i="0">&lt;/c0&gt;</ept>キーワードを使ってグローバル水準で宣言されます、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>prefix<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>infix<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>postfix<ept i="3">&lt;/c3&gt;</ept>修飾子で印されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Next, <bpt i="0" x="0">&lt;c0&gt;</bpt>tenEighty<ept i="0">&lt;/c0&gt;</ept> is assigned to a new constant, called <bpt i="1" x="1">&lt;c1&gt;</bpt>alsoTenEighty<ept i="1">&lt;/c1&gt;</ept>, and the frame rate of <bpt i="2" x="2">&lt;c2&gt;</bpt>alsoTenEighty<ept i="2">&lt;/c2&gt;</ept> is modified:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次に、<bpt i="0" x="0">&lt;c0&gt;</bpt>tenEighty<ept i="0">&lt;/c0&gt;</ept>は、新しい定数、<bpt i="1" x="1">&lt;c1&gt;</bpt>alsoTenEighty<ept i="1">&lt;/c1&gt;</ept>と呼ばれるものに代入されます、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>alsoTenEighty<ept i="2">&lt;/c2&gt;</ept>のフレームレートが修正されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Next, the <bpt i="0" x="0">&lt;c0&gt;</bpt>width<ept i="0">&lt;/c0&gt;</ept> property of <bpt i="1" x="1">&lt;c1&gt;</bpt>cinema<ept i="1">&lt;/c1&gt;</ept> is amended to be the width of the slightly-wider 2K standard used for digital cinema projection (<bpt i="2" x="2">&lt;c2&gt;</bpt>2048<ept i="2">&lt;/c2&gt;</ept> pixels wide and <bpt i="3" x="3">&lt;c3&gt;</bpt>1080<ept i="3">&lt;/c3&gt;</ept> pixels high):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次に、<bpt i="1" x="1">&lt;c1&gt;</bpt>cinema<ept i="1">&lt;/c1&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>width<ept i="0">&lt;/c0&gt;</ept>プロパティは、デジタル映画館投影のために使われるわずかにより広い2Kの標準の幅（<bpt i="2" x="2">&lt;c2&gt;</bpt>2048<ept i="2">&lt;/c2&gt;</ept>ピクセル幅の広さで<bpt i="3" x="3">&lt;c3&gt;</bpt>1080<ept i="3">&lt;/c3&gt;</ept>ピクセルの高さがある）になるように改められます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nil-Coalescing Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>nil合体演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>No Implicit Fallthrough</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>知らずに突き抜けない（フォールスルーしない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>No further code from the current iteration of the loop is executed, and no further iterations of the loop are started.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループの現在の繰り返しからそれ以上のコードは実行されません、そしてループのそれ以上の繰り返しは始まりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>No ladder on the board takes the player straight to square 25, and so it isn’t possible to win the game by moving up a ladder.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>盤上のはしごは、プレーヤーをまっすぐ正方形25に連れて行きません、なので、はしごを上がることでゲームに勝つことは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>No other properties or variables are still referring to the <bpt i="5" x="5">&lt;c5&gt;</bpt>Player<ept i="5">&lt;/c5&gt;</ept> instance, and so it is deallocated in order to free up its memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他のいかなるプロパティまたは変数も、もはや<bpt i="5" x="5">&lt;c5&gt;</bpt>Player<ept i="5">&lt;/c5&gt;</ept>インスタンスに言及していません、なのでそれは、それのもつメモリを開放するために順次割り当て解除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nonassociative operators of the same precedence level can’t appear adjacent to each to other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じ優先順位レベルを持つ非結合演算子は、互いに隣同士に現れることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nonetheless, any protocol you create will become a fully-fledged type for use in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それでもなお、あなたがつくるどんなプロトコルでも、あなたのコードに用いられるひとつの完全に自立した型になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nonetheless, because it’s of type <bpt i="5" x="5">&lt;c5&gt;</bpt>TextRepresentable<ept i="5">&lt;/c5&gt;</ept>, and anything that is <bpt i="6" x="6">&lt;c6&gt;</bpt>TextRepresentable<ept i="6">&lt;/c6&gt;</ept> is known to have a <bpt i="7" x="7">&lt;c7&gt;</bpt>textualDescription<ept i="7">&lt;/c7&gt;</ept> property, it’s safe to access <bpt i="8" x="8">&lt;c8&gt;</bpt>thing.textualDescription<ept i="8">&lt;/c8&gt;</ept> each time through the loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それでもなお、それが<bpt i="5" x="5">&lt;c5&gt;</bpt>TextRepresentable<ept i="5">&lt;/c5&gt;</ept>型であり、そして、<bpt i="6" x="6">&lt;c6&gt;</bpt>TextRepresentable<ept i="6">&lt;/c6&gt;</ept>であるもの全てが<bpt i="7" x="7">&lt;c7&gt;</bpt>textualDescription<ept i="7">&lt;/c7&gt;</ept>プロパティを持つと知られているので、それがループの各回で<bpt i="8" x="8">&lt;c8&gt;</bpt>thing.textualDescription<ept i="8">&lt;/c8&gt;</ept>にアクセスするのは安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nonetheless, class <bpt i="4" x="4">&lt;c4&gt;</bpt>B<ept i="4">&lt;/c4&gt;</ept> provides an override of <bpt i="5" x="5">&lt;c5&gt;</bpt>someMethod()<ept i="5">&lt;/c5&gt;</ept> with an access level of “internal”, which is <bpt i="6" x="6">&lt;e6&gt;</bpt>higher<ept i="6">&lt;/e6&gt;</ept> than the original implementation of <bpt i="7" x="7">&lt;c7&gt;</bpt>someMethod()<ept i="7">&lt;/c7&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それにもかかわらず、クラス<bpt i="4" x="4">&lt;c4&gt;</bpt>B<ept i="4">&lt;/c4&gt;</ept>は、「内部」のアクセス水準を持つ<bpt i="5" x="5">&lt;c5&gt;</bpt>someMethod()<ept i="5">&lt;/c5&gt;</ept>のオーバーライドを提供します、それは元々の<bpt i="7" x="7">&lt;c7&gt;</bpt>someMethod()<ept i="7">&lt;/c7&gt;</ept>の実装よりも<bpt i="6" x="6">&lt;e6&gt;</bpt>より高い<ept i="6">&lt;/e6&gt;</ept>です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nonetheless, it is useful for a <bpt i="10" x="10">&lt;c10&gt;</bpt>Cuboid<ept i="10">&lt;/c10&gt;</ept> to provide a read-only computed property to enable external users to discover its current calculated volume.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それでもなお、<bpt i="10" x="10">&lt;c10&gt;</bpt>Cuboid<ept i="10">&lt;/c10&gt;</ept>が外部のユーザーにその現在の計算された体積を見つけられるように読み出し専用の計算プロパティを提供することは、役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>にもかかわらず、スウィフトの多くの部分は、あなたのCとObjective-Cでの開発経験からきっとお馴染みのものでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nonetheless, the <bpt i="4" x="4">&lt;c4&gt;</bpt>Item<ept i="4">&lt;/c4&gt;</ept> alias provides a way to refer to the type of the items in a <bpt i="5" x="5">&lt;c5&gt;</bpt>Container<ept i="5">&lt;/c5&gt;</ept>, and to define a type for use with the <bpt i="6" x="6">&lt;c6&gt;</bpt>append(_:)<ept i="6">&lt;/c6&gt;</ept> method and subscript, to ensure that the expected behavior of any <bpt i="7" x="7">&lt;c7&gt;</bpt>Container<ept i="7">&lt;/c7&gt;</ept> is enforced.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それでもなお、<bpt i="4" x="4">&lt;c4&gt;</bpt>Item<ept i="4">&lt;/c4&gt;</ept>エイリアスは、<bpt i="5" x="5">&lt;c5&gt;</bpt>Container<ept i="5">&lt;/c5&gt;</ept>の中の項目の型に言及するための、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>append(_:)<ept i="6">&lt;/c6&gt;</ept>メソッドと添え字で使うための型を定義するための、ひとつの方法を提供します、それによってあらゆる<bpt i="7" x="7">&lt;c7&gt;</bpt>Container<ept i="7">&lt;/c7&gt;</ept>が期待される挙動を強制されることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nonetheless, they’re all classes, and so instances of all three types can be used to initialize an array that stores values of type <bpt i="3" x="3">&lt;c3&gt;</bpt>AnyObject<ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それでもなお、それらは全てクラスです、なので、３つの型全てのインスタンスは、型<bpt i="3" x="3">&lt;c3&gt;</bpt>AnyObject<ept i="3">&lt;/c3&gt;</ept>の値を格納するある配列を初期化するために使用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nonetheless, you can still make the types explicit if you wish, and doing so is encouraged if it avoids ambiguity for readers of your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それでもなお、あなたが望むならば、依然としてあなたは型を明確にすることができます、そして、それがあなたのコードの読者のために曖昧さを避けるならば、そうすることは推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nonreturning functions and methods either cause an irrecoverable error or begin a sequence of work that continues indefinitely.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非復帰関数およびメソッドは、回復不能のエラーを起こすかまたは無期限に続く一連の作業を始めるかのどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nor can they begin with a number, although numbers may be included elsewhere within the name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そしてそれらは数字から始まることもできません、けれども数字が名前内のどこか他で含まれることはできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nor can you change a constant into a variable or a variable into a constant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そして、あなたはある定数を変数に、またはある変数を定数に変更することもできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Not all possible <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> values will find a matching planet, however.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、全ての可能な<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>値が、適合する惑星を見つけるというわけでありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Not equal to (<bpt i="0" x="0">&lt;c0&gt;</bpt>a != b<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同等でない（<bpt i="0" x="0">&lt;c0&gt;</bpt>a != b<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Not every type in Swift can be compared with the equal to operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの中のすべての型が、同等演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>）で比較されることができるというわけでありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Not identical to (<bpt i="0" x="0">&lt;c0&gt;</bpt>!==<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同一でない（<bpt i="0" x="0">&lt;c0&gt;</bpt>!==<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Not only are optionals safer and more expressive than <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept> pointers in Objective-C, they’re at the heart of many of Swift’s most powerful features.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルはObjective-Cでの<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>ポインターより安全でさらに表現豊かであるだけでなく、それはスウィフトのたくさんある非常に強力な特徴のうち核心的なものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note also that you cannot provide both an overriding setter and an overriding property observer for the same property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが同じプロパティに対してオーバーライドしたセッターとオーバーライドしたプロパティオブザーバーの両方を提供することができない点にまた、注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note how the generic version of <bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept> is essentially the same as the nongeneric version, but with a type parameter called <bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> instead of an actual type of <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept>の総称体版が、本質的にどれほど非総称体版と同じものであるかに注意してください、しかし<bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>と呼ばれる型パラメータを実際の型<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>の代わりに持つことは除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that <bpt i="0" x="0">&lt;c0&gt;</bpt>tenEighty<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>alsoTenEighty<ept i="1">&lt;/c1&gt;</ept> are declared as <bpt i="2" x="2">&lt;e2&gt;</bpt>constants<ept i="2">&lt;/e2&gt;</ept>, rather than variables.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>tenEighty<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>alsoTenEighty<ept i="1">&lt;/c1&gt;</ept>が、変数ではなく、<bpt i="2" x="2">&lt;e2&gt;</bpt>定数<ept i="2">&lt;/e2&gt;</ept>として宣言される点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that <bpt i="3" x="3">&lt;c3&gt;</bpt>@objc<ept i="3">&lt;/c3&gt;</ept> protocols can be adopted only by classes that inherit from Objective-C classes or other <bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept> classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>@objc<ept i="3">&lt;/c3&gt;</ept>プロトコルがObjective-Cクラスや他の<bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept>クラスから継承するクラスによってのみ採用される点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that <bpt i="6" x="6">&lt;c6&gt;</bpt>x<ept i="6">&lt;/c6&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt>y<ept i="7">&lt;/c7&gt;</ept> are an optional of whatever type <bpt i="8" x="8">&lt;c8&gt;</bpt>someThrowingFunction()<ept i="8">&lt;/c8&gt;</ept> returns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>x<ept i="6">&lt;/c6&gt;</ept>と<bpt i="7" x="7">&lt;c7&gt;</bpt>y<ept i="7">&lt;/c7&gt;</ept>は、たとえどんなものでも<bpt i="8" x="8">&lt;c8&gt;</bpt>someThrowingFunction()<ept i="8">&lt;/c8&gt;</ept>が返す型のオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that <bpt i="0" x="0">&lt;e0&gt;</bpt>two<ept i="0">&lt;/e0&gt;</ept> levels of optional chaining are at play here.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここで<bpt i="0" x="0">&lt;e0&gt;</bpt>２つの<ept i="0">&lt;/e0&gt;</ept>階層のオプショナル連鎖が働いていることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that Swift infers a type of <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> for the <bpt i="1" x="1">&lt;c1&gt;</bpt>someString<ept i="1">&lt;/c1&gt;</ept> constant because it’s initialized with a string literal value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトが型<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>someString<ept i="1">&lt;/c1&gt;</ept>定数に対して推論することに注意してください、それが文字列リテラル値で初期化されるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that Swift’s use of extended grapheme clusters for <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> values means that string concatenation and modification may not always affect a string’s character count.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>値に対する拡張書記素クラスタの使用は、文字列の連結と修正が常に文字列の文字数に影響を与えないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that an exclamation mark (<bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept>) is used to unwrap and access the instances stored inside the <bpt i="1" x="1">&lt;c1&gt;</bpt>john<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>unit4A<ept i="2">&lt;/c2&gt;</ept> optional variables, so that the properties of those instances can be set:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>感嘆符（<bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept>）が使われることに注意してください、そうすることでオプショナル変数の<bpt i="1" x="1">&lt;c1&gt;</bpt>john<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>unit4A<ept i="2">&lt;/c2&gt;</ept>に保存されるインスタンスがアンラップされてアクセスされるようになります、それでそれらのインスタンスのプロパティが設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that if you define a custom initializer for a value type, you will no longer have access to the default initializer (or the memberwise initializer, if it is a structure) for that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある値型のためにあつらえのイニシャライザを定義するならば、あなたがもはやその型の省略時のイニシャライザに（および、それが構造体の場合には、メンバー関連イニシャライザにも）アクセスをしない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that if you override a failable superclass initializer with a nonfailable subclass initializer, the only way to delegate up to the superclass initializer is to force-unwrap the result of the failable superclass initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>注意することは、あなたが失敗できるスーパークラス・イニシャライザを、失敗できないサブクラス・イニシャライザでオーバーライドする場合、唯一の方法としてスーパークラスのイニシャライザにまで委任するには、失敗できるスーパークラスイニシャライザの結果を強制アンラップすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that in the example above, you are trying to retrieve the value of the <bpt i="0" x="0">&lt;c0&gt;</bpt>street<ept i="0">&lt;/c0&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例で、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>street<ept i="0">&lt;/c0&gt;</ept>プロパティの値を取り出そうとしている点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that it is not possible to call these initializers without using argument labels.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数ラベルを使用することなくこれらのイニシャライザを呼び出すことは可能でない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that neither deinitializer was called when you set these two variables to <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこれらの２つの変数を<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>に設定したとき、どちらのデイニシャライザも呼ばれなかった点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that no whitespace may appear between the type and the <bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空白が型と<bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept>の間に現れないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that no whitespace may appear between the type and the <bpt i="1" x="1">&lt;c1&gt;</bpt>?<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空白が型と<bpt i="1" x="1">&lt;c1&gt;</bpt>?<ept i="1">&lt;/c1&gt;</ept>の間に現れないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that not all 21-bit Unicode scalars are assigned to a character—some scalars are reserved for future assignment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全ての21ビットのユニコード・スカラーがひとつの文字に割り当てられる訳ではないことに注意してください ― いくつかのスカラーは将来の割り当てのために取っておかれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the <bpt i="0" x="0">&lt;c0&gt;</bpt>delegate<ept i="0">&lt;/c0&gt;</ept> property is defined as an <bpt i="1" x="1">&lt;e1&gt;</bpt>optional<ept i="1">&lt;/e1&gt;</ept> <bpt i="2" x="2">&lt;c2&gt;</bpt>DiceGameDelegate<ept i="2">&lt;/c2&gt;</ept>, because a delegate isn’t required in order to play the game.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>delegate<ept i="0">&lt;/c0&gt;</ept>プロパティが、<bpt i="1" x="1">&lt;e1&gt;</bpt>オプショナル<ept i="1">&lt;/e1&gt;</ept>の<bpt i="2" x="2">&lt;c2&gt;</bpt>DiceGameDelegate<ept i="2">&lt;/c2&gt;</ept>として定義される点に注意してください、delegateがゲームをプレイするために必須でないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the <bpt i="0" x="0">&lt;c0&gt;</bpt>thing<ept i="0">&lt;/c0&gt;</ept> constant is of type <bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>thing<ept i="0">&lt;/c0&gt;</ept>定数が型<bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept>であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the array contains four items, but <bpt i="0" x="0">&lt;c0&gt;</bpt>0..&lt;count<ept i="0">&lt;/c0&gt;</ept> only counts as far as <bpt i="1" x="1">&lt;c1&gt;</bpt>3<ept i="1">&lt;/c1&gt;</ept> (the index of the last item in the array), because it’s a half-open range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この配列が４つの項目を含む点に注意してください、しかし<bpt i="0" x="0">&lt;c0&gt;</bpt>0..&lt;count<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>3<ept i="1">&lt;/c1&gt;</ept>（この配列の最後の項目のインデックス）まで数えるだけです、なぜならそれが半開範囲であるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the closure’s end curly brace is followed by an empty pair of parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャの閉じ波括弧に、一対の空の丸括弧が続くことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the declaration of parameters and return type for this inline closure is identical to the declaration from the <bpt i="0" x="0">&lt;c0&gt;</bpt>backward(_:_:)<ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行内クロージャのためのパラメータと戻り型の宣言が、<bpt i="0" x="0">&lt;c0&gt;</bpt>backward(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数の宣言と同一であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the entire function type is wrapped in the optional, not the method’s return value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッドの戻り値ではなく、その関数型の全体がオプショナルの中のラップされることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the message <bpt i="0" x="0">&lt;c0&gt;</bpt>"John Appleseed is being initialized"<ept i="0">&lt;/c0&gt;</ept> is printed at the point that you call the <bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept> class’s initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept>クラスのイニシャライザを呼んだ時点で、メッセージ<bpt i="0" x="0">&lt;c0&gt;</bpt>"John Appleseed is being initialized"<ept i="0">&lt;/c0&gt;</ept>が出力されるという点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the message in the <bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept> deinitializer is not printed, which shows that the <bpt i="1" x="1">&lt;c1&gt;</bpt>HTMLElement<ept i="1">&lt;/c1&gt;</ept> instance is not deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept>デイニシャライザにおけるメッセージが出力されないことに注意してください、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>HTMLElement<ept i="1">&lt;/c1&gt;</ept>インスタンスが割り当て解除されないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the names of <bpt i="2" x="2">&lt;c2&gt;</bpt>someInt<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>anotherInt<ept i="3">&lt;/c3&gt;</ept> are prefixed with an ampersand when they are passed to the <bpt i="4" x="4">&lt;c4&gt;</bpt>swapTwoInts(_:_:)<ept i="4">&lt;/c4&gt;</ept> function:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>someInt<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>anotherInt<ept i="3">&lt;/c3&gt;</ept>の名前が、それらが<bpt i="4" x="4">&lt;c4&gt;</bpt>swapTwoInts(_:_:)<ept i="4">&lt;/c4&gt;</ept>関数に渡される時に、アンパサンドで接頭辞を付けられるという点に注意してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the return type of this function is still <bpt i="2" x="2">&lt;c2&gt;</bpt>Int?<ept i="2">&lt;/c2&gt;</ept>, because the function returns an optional index number, not an optional value from the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数の戻り型が以前として<bpt i="2" x="2">&lt;c2&gt;</bpt>Int?<ept i="2">&lt;/c2&gt;</ept>であるという点に注意してください、なぜなら、この関数がオプショナルのインデックス番号（配列からのオプショナルの値でない）を返すからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the tuple’s members do not need to be named at the point that the tuple is returned from the function, because their names are already specified as part of the function’s return type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプルの構成要素が、タプルがその関数から返される時点で名前をつけられる必要がない点に注意してください、なぜなら、それらの名前が関数の戻り型の一部としてすでに指定されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the type of <bpt i="1" x="1">&lt;c1&gt;</bpt>customerProvider<ept i="1">&lt;/c1&gt;</ept> is not <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> but <bpt i="3" x="3">&lt;c3&gt;</bpt>() -&gt; String<ept i="3">&lt;/c3&gt;</ept>—a function with no parameters that returns a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>注意すべきは、<bpt i="1" x="1">&lt;c1&gt;</bpt>customerProvider<ept i="1">&lt;/c1&gt;</ept>の型は<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>ではなく<bpt i="3" x="3">&lt;c3&gt;</bpt>() -&gt; String<ept i="3">&lt;/c3&gt;</ept>—ある文字列を返すパラメータのない関数—であることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the type of the <bpt i="0" x="0">&lt;c0&gt;</bpt>someInts<ept i="0">&lt;/c0&gt;</ept> variable is inferred to be <bpt i="1" x="1">&lt;c1&gt;</bpt>[Int]<ept i="1">&lt;/c1&gt;</ept> from the type of the initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>someInts<ept i="0">&lt;/c0&gt;</ept>変数の型が、そのイニシャライザの型から<bpt i="1" x="1">&lt;c1&gt;</bpt>[Int]<ept i="1">&lt;/c1&gt;</ept>であると推測される点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the underlying objects aren’t changed by the casting process.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>根底にあるオブジェクトがキャスト処理によって変更されない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that this extension doesn’t define a type parameter list.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この拡張は型パラメーターリストを定義しないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that this function is distinct from the <bpt i="5" x="5">&lt;c5&gt;</bpt>greet(person:)<ept i="5">&lt;/c5&gt;</ept> function shown in an earlier section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数が前の節で見せた<bpt i="5" x="5">&lt;c5&gt;</bpt>greet(person:)<ept i="5">&lt;/c5&gt;</ept>関数と別個のものであることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that this is true even though <bpt i="0" x="0">&lt;c0&gt;</bpt>numberOfRooms<ept i="0">&lt;/c0&gt;</ept> is a nonoptional <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえ<bpt i="0" x="0">&lt;c0&gt;</bpt>numberOfRooms<ept i="0">&lt;/c0&gt;</ept>が非オプショナルの<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>であるとしても、これが当てはまることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that you can assign an explicit access level for both a getter and a setter if required.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは明示的なアクセス水準をゲッターとセッターの両方に割り当てることが、必要ならば可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that you cannot call a mutating method on a constant of structure type, because its properties cannot be changed, even if they are variable properties, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Stored Properties of Constant Structure Instances<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが定数の構造体型で可変メソッドを呼ぶことができないということに注意してください、なぜなら、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>定数構造体インスタンスの保存プロパティ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、そのプロパティは、たとえそれらが変数プロパティであるとしても変わることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that “identical to” (represented by three equals signs, or <bpt i="0" x="0">&lt;c0&gt;</bpt>===<ept i="0">&lt;/c0&gt;</ept>) does not mean the same thing as “equal to” (represented by two equals signs, or <bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「同一である」（３つの等号、つまり<bpt i="0" x="0">&lt;c0&gt;</bpt>===<ept i="0">&lt;/c0&gt;</ept>によって表されるもの）は「同等である」（２つの等号、つまり<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>によって表されるもの）と同じことを意味しないことに注意してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>覚え書き</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nothing else is required of the instance you assign to this property, except that the instance must adopt the <bpt i="4" x="4">&lt;c4&gt;</bpt>RandomNumberGenerator<ept i="4">&lt;/c4&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのインスタンスが<bpt i="4" x="4">&lt;c4&gt;</bpt>RandomNumberGenerator<ept i="4">&lt;/c4&gt;</ept>プロトコルを採用しなければならないことをのぞいては、あなたがこのプロパティに代入するインスタンスに必要とされるものは他に何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice how <bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept> can be used in a pattern to assign the value that matched the pattern to a constant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのように<bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept>がパターン内で使われて、パターンに合致した値を定数に割り当てることができるかに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice how <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> is used to distinguish the <bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept> property from the <bpt i="2" x="2">&lt;c2&gt;</bpt>name<ept i="2">&lt;/c2&gt;</ept> argument to the initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのように<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept>プロパティをイニシャライザのための<bpt i="2" x="2">&lt;c2&gt;</bpt>name<ept i="2">&lt;/c2&gt;</ept>引数と区別するために使われるかに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice how the sunrise and sunset times are extracted from the <bpt i="0" x="0">&lt;c0&gt;</bpt>ServerResponse<ept i="0">&lt;/c0&gt;</ept> value as part of matching the value against the switch cases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのように日の出と日没の時間が<bpt i="0" x="0">&lt;c0&gt;</bpt>ServerResponse<ept i="0">&lt;/c0&gt;</ept>の値から、その値をスイッチの各条件と比較することの一環として抽出されるかに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice that the initializer for the <bpt i="0" x="0">&lt;c0&gt;</bpt>EquilateralTriangle<ept i="0">&lt;/c0&gt;</ept> class has three different steps:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>EquilateralTriangle<ept i="0">&lt;/c0&gt;</ept>クラスのためのイニシャライザが３つの異なる段階を持つことに注意してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice the two ways that the <bpt i="0" x="0">&lt;c0&gt;</bpt>hearts<ept i="0">&lt;/c0&gt;</ept> case of the enumeration is referred to above: When assigning a value to the <bpt i="1" x="1">&lt;c1&gt;</bpt>hearts<ept i="1">&lt;/c1&gt;</ept> constant, the enumeration case <bpt i="2" x="2">&lt;c2&gt;</bpt>Suit.hearts<ept i="2">&lt;/c2&gt;</ept> is referred to by its full name because the constant doesn’t have an explicit type specified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上記で列挙の<bpt i="0" x="0">&lt;c0&gt;</bpt>hearts<ept i="0">&lt;/c0&gt;</ept>ケース節が参照される２つの方法に注意してください：定数の<bpt i="1" x="1">&lt;c1&gt;</bpt>hearts<ept i="1">&lt;/c1&gt;</ept>に値を代入するとき、列挙のケース節<bpt i="2" x="2">&lt;c2&gt;</bpt>Suit.hearts<ept i="2">&lt;/c2&gt;</ept>はそのフルネームによって参照されます、なぜならこの定数には明確に指定される型がないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice the use of the <bpt i="0" x="0">&lt;c0&gt;</bpt>mutating<ept i="0">&lt;/c0&gt;</ept> keyword in the declaration of <bpt i="1" x="1">&lt;c1&gt;</bpt>SimpleStructure<ept i="1">&lt;/c1&gt;</ept> to mark a method that modifies the structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>SimpleStructure<ept i="1">&lt;/c1&gt;</ept>の宣言における<bpt i="0" x="0">&lt;c0&gt;</bpt>mutating<ept i="0">&lt;/c0&gt;</ept>キーワードに注意してください、それはその構造体を修正するメソッドに印を付けるためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now that <bpt i="0" x="0">&lt;c0&gt;</bpt>moveNearerToZero<ept i="0">&lt;/c0&gt;</ept> refers to the correct function, it can be used to count to zero:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>moveNearerToZero<ept i="0">&lt;/c0&gt;</ept>が正しい関数に言及する今、それはゼロまで数えるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Now you can call the function as if it took a <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> argument instead of a closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>今やあなたはこの関数を、まるでそれがクロージャではなく<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>引数を取るかのように呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Null character (<bpt i="0" x="0">&lt;c0&gt;</bpt>\0<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>null文字（<bpt i="0" x="0">&lt;c0&gt;</bpt>\0<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Numbers can overflow in both the positive and negative direction.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数は正と負の向きの両方においてオーバフローすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Numeric Literals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数のリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Numeric Type Conversion</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数の型変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Numeric literals can contain extra formatting to make them easier to read.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数のリテラルは、それらをより簡単に読めるように書式を整える追加のものを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objects and Classes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクトとクラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Omitting Argument Labels</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数ラベルの省略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Omitting the version number indicates that the declaration is currently deprecated, without giving any information about when the deprecation occurred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バージョン番号の省略は、宣言が現れた時についてのどんな情報も与えることなく、その宣言が現在は非推奨であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a 32-bit platform, <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> is the same size as <bpt i="1" x="1">&lt;c1&gt;</bpt>Int32<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>32ビットのプラットホーム上で、<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>Int32<ept i="1">&lt;/c1&gt;</ept>と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a 32-bit platform, <bpt i="0" x="0">&lt;c0&gt;</bpt>UInt<ept i="0">&lt;/c0&gt;</ept> is the same size as <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt32<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>32ビットのプラットホーム上で、<bpt i="0" x="0">&lt;c0&gt;</bpt>UInt<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt32<ept i="1">&lt;/c1&gt;</ept>と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a 64-bit platform, <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> is the same size as <bpt i="1" x="1">&lt;c1&gt;</bpt>Int64<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>64ビットのプラットホーム上で、<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>Int64<ept i="1">&lt;/c1&gt;</ept>と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On a 64-bit platform, <bpt i="0" x="0">&lt;c0&gt;</bpt>UInt<ept i="0">&lt;/c0&gt;</ept> is the same size as <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt64<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>64ビットのプラットホーム上で、<bpt i="0" x="0">&lt;c0&gt;</bpt>UInt<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt64<ept i="1">&lt;/c1&gt;</ept>と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On each pass, the <bpt i="1" x="1">&lt;c1&gt;</bpt>for<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>in<ept i="2">&lt;/c2&gt;</ept> loop sets the <bpt i="3" x="3">&lt;c3&gt;</bpt>item<ept i="3">&lt;/c3&gt;</ept> constant to the next <bpt i="4" x="4">&lt;c4&gt;</bpt>MediaItem<ept i="4">&lt;/c4&gt;</ept> in the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各段階で、この<bpt i="1" x="1">&lt;c1&gt;</bpt>for<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>in<ept i="2">&lt;/c2&gt;</ept>ループは<bpt i="3" x="3">&lt;c3&gt;</bpt>item<ept i="3">&lt;/c3&gt;</ept>定数を次の<bpt i="4" x="4">&lt;c4&gt;</bpt>MediaItem<ept i="4">&lt;/c4&gt;</ept>に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On those occasions, you can write <bpt i="0" x="0">&lt;c0&gt;</bpt>try!<ept i="0">&lt;/c0&gt;</ept> before the expression to disable error propagation and wrap the call in a runtime assertion that no error will be thrown.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの場合には、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>try!<ept i="0">&lt;/c0&gt;</ept>をその式の前に書くことによって、エラー伝達を抑制して、エラーはスローされないという実行時表明の中にその呼び出しを包み込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once <bpt i="2" x="2">&lt;c2&gt;</bpt>directionToHead<ept i="2">&lt;/c2&gt;</ept> is declared as a <bpt i="3" x="3">&lt;c3&gt;</bpt>CompassPoint<ept i="3">&lt;/c3&gt;</ept>, you can set it to a different <bpt i="4" x="4">&lt;c4&gt;</bpt>CompassPoint<ept i="4">&lt;/c4&gt;</ept> value using a shorter dot syntax:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一旦<bpt i="2" x="2">&lt;c2&gt;</bpt>directionToHead<ept i="2">&lt;/c2&gt;</ept>が、ある<bpt i="3" x="3">&lt;c3&gt;</bpt>CompassPoint<ept i="3">&lt;/c3&gt;</ept>として宣言されるならば、あなたはそれをより短いドット構文を使って、異なる<bpt i="4" x="4">&lt;c4&gt;</bpt>CompassPoint<ept i="4">&lt;/c4&gt;</ept>値に設定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once a constant property is assigned a value, it can’t be further modified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いったん定数プロパティが値を割り当てられるならば、それはそれ以上変更されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once it completes the sorting process, the <bpt i="1" x="1">&lt;c1&gt;</bpt>sorted(by:)<ept i="1">&lt;/c1&gt;</ept> method returns a new array of the same type and size as the old one, with its elements in the correct sorted order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一旦それがソート処理を完了するならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>sorted(by:)<ept i="1">&lt;/c1&gt;</ept>メソッドは、古いものと同じ型と大きさの新しい配列を返します、そしてその要素は正しく分類された順序を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once the counter reaches zero, no more counting takes place:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとたびcounterがゼロに達するならば、それ以上数えることは起こりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一旦あらゆる保存プロパティのための最初の状態が決定されるならば、第２の段階が始まります、そして各クラスは、新しいインスタンスが使用する準備ができているとみなされる前に、さらにその保存プロパティを好みに合わせて作り変える機会を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once the superclass’s designated initializer is finished, the subclass’s designated initializer can perform additional customization (although again, it does not have to).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一旦スーパークラスの指定イニシャライザが作業をし終えるならば、サブクラスの指定イニシャライザは追加の改良を実行することができます（しかし再び、そうしなければならない訳ではない）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once the top of the chain is reached, and the final class in the chain has ensured that all of its stored properties have a value, the instance’s memory is considered to be fully initialized, and phase 1 is complete.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いったん連鎖の最上部に届き、そして連鎖の中の最終的なクラスがその保存プロパティの全てが値を持つことを確実にしたならば、インスタンスのメモリは充分に初期化されるとみなされます、そして、第１段階は完了です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once you define a type alias, you can use the alias anywhere you might use the original name:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一旦あなたがある型エイリアスを定義するならば、あなたが本来の名前を使うであろうどこにでも、あなたはそのエイリアスを使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once you specify a type parameter, you can use it to define the type of a function’s parameters (such as the <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept> parameters of the <bpt i="2" x="2">&lt;c2&gt;</bpt>swapTwoValues(_:_:)<ept i="2">&lt;/c2&gt;</ept> function), or as the function’s return type, or as a type annotation within the body of the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一旦あなたが型パラメータを指定するならば、あなたはそれを、関数のパラメータの型を定義するために（例えば、 <bpt i="2" x="2">&lt;c2&gt;</bpt>swapTwoValues(_:_:)<ept i="2">&lt;/c2&gt;</ept>関数の<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>パラメータのように）、または関数の戻り型として、あるいは関数の本文内の型注釈として使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once you’re sure that the optional <bpt i="0" x="0">&lt;e0&gt;</bpt>does<ept i="0">&lt;/e0&gt;</ept> contain a value, you can access its underlying value by adding an exclamation mark (<bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>) to the end of the optional’s name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一旦あなたがそのオプショナルが値を含んで<bpt i="0" x="0">&lt;e0&gt;</bpt>いる<ept i="0">&lt;/e0&gt;</ept>ことを確かめたなら、あなたは感嘆符（<bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>）をオプショナルの名前の終わりに加えることによって、それに内在する値にアクセスすることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once you’ve declared a constant or variable of a certain type, you can’t declare it again with the same name, or change it to store values of a different type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一旦あなたが特定の型のある定数または変数を宣言してしまったならば、あなたは同じ名前でもう一度それを宣言し直すこと、またはそれを異なる型の値を保存するように変更することは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One convenience initializer calls another convenience initializer, which in turn calls the single designated initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つの便宜イニシャライザは、別の便宜イニシャライザを呼びます、それは、今度は一つだけある指定イニシャライザを呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One example is the <bpt i="2" x="2">&lt;e2&gt;</bpt>addition assignment operator<ept i="2">&lt;/e2&gt;</ept> (<bpt i="3" x="3">&lt;c3&gt;</bpt>+=<ept i="3">&lt;/c3&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つの例は、<bpt i="2" x="2">&lt;e2&gt;</bpt>加算代入演算子<ept i="2">&lt;/e2&gt;</ept>（<bpt i="3" x="3">&lt;c3&gt;</bpt>+=<ept i="3">&lt;/c3&gt;</ept>）です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One kilometer is the same as 1,000 meters, so the <bpt i="0" x="0">&lt;c0&gt;</bpt>km<ept i="0">&lt;/c0&gt;</ept> computed property multiplies the value by <bpt i="1" x="1">&lt;c1&gt;</bpt>1_000.00<ept i="1">&lt;/c1&gt;</ept> to convert into a number expressed in meters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１キロメートルは1,000メートルと同じものですので、<bpt i="0" x="0">&lt;c0&gt;</bpt>km<ept i="0">&lt;/c0&gt;</ept>計算プロパティは<bpt i="1" x="1">&lt;c1&gt;</bpt>1_000.00<ept i="1">&lt;/c1&gt;</ept>を掛けられて、メートルで表される数に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One of the most important differences between structures and classes is that structures are always copied when they are passed around in your code, but classes are passed by reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体とクラスの間の１つの最も重要な違いは、それらがあなたのコードにおいてあちこち渡されるとき、構造体は常にコピーされるということです、それに対してクラスは参照によって渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One of these classes was defined as “internal”, and the other was defined as “private”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらのクラスのうちの１つは「内部」として定義されました、そして別のものは「非公開」として定義されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One of these two branches is always executed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの２つの分岐のうちの１つは、常に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One way is to use <bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つの方法は、<bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>を使うことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One way that a closure can escape is by being stored in a variable that is defined outside the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャが脱出出来る１つの方法は、関数の外側で定義される変数に格納されることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One way to provide the sorting closure is to write a normal function of the correct type, and to pass it in as an argument to the <bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ソート・クロージャを提供する１つの方法は、通常の関数を正しい型で記述することです、そしてそれを１つの引数として<bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept>メソッドに渡すことになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One-Sided Ranges</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>片側範囲</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One-sided ranges can be used in other contexts, not just in subscripts.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>片側範囲は、添え字とは違い、他の文脈で使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Only the compound assignment operators can be overloaded.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複合代入演算子だけが、オーバーロードされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Only throwing functions can propagate errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スロー関数だけがエラーを伝えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Open access applies only to classes and class members, and it differs from public access as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>開放アクセスはクラスとクラスメソッドのみに適用されます、そしてそれは次のように公開アクセスと異なります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Open access is the highest (least restrictive) access level and private access is the lowest (most restrictive) access level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>開放アクセスは最も高い（制限の最も少ない）アクセス水準であり、非公開アクセスは最も低い（制限の最も多い）アクセス水準です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Open class members can be overridden by subclasses within the module where they’re defined, and within any module that imports the module where they’re defined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>開放クラスメンバーは、それらが定義されたところのモジュール内部で、そしてそれらが定義されたところのモジュールをインポートする何らかのモジュール内部で、サブクラスによってオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Open classes can be subclassed within the module where they’re defined, and within any module that imports the module where they’re defined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>開放クラスは、それらが定義されたところのモジュール内部で、そしてそれらが定義されたところのモジュールをインポートする何らかのモジュール内部で、サブクラスを作成されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operator <bpt i="0" x="0">&lt;e0&gt;</bpt>associativity<ept i="0">&lt;/e0&gt;</ept> defines how operators of the same precedence are grouped together—either grouped from the left, or grouped from the right.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子<bpt i="0" x="0">&lt;e0&gt;</bpt>結合性<ept i="0">&lt;/e0&gt;</ept>は、同じ優先順位の演算子がまとめられる方法を定義します ― 左からまとめられるか右からまとめられるかのどちらか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operator <bpt i="0" x="0">&lt;e0&gt;</bpt>precedence<ept i="0">&lt;/e0&gt;</ept> gives some operators higher priority than others; these operators are applied first.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>演算子優先順位<ept i="0">&lt;/e0&gt;</ept>は、ある演算子に他のものよりも高い優先権を与えます；これらの演算子は最初に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operator Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operator Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operator functions for <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Compound Assignment Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> no longer use the <bpt i="2" x="2">&lt;c2&gt;</bpt>@assignment<ept i="2">&lt;/c2&gt;</ept> attribute when defining the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>複合代入演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>のための演算子関数は、もはや関数を定義する時に<bpt i="2" x="2">&lt;c2&gt;</bpt>@assignment<ept i="2">&lt;/c2&gt;</ept>属性を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operators are unary, binary, or ternary:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子には、単項、二項、または三項があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operators from those precedence groups can’t be used next to each other without grouping parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの優先順位グループ由来の演算子は、グループ化括弧なしで互いにすぐ隣に使われることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operators that are left-associative group left-to-right.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>左結合である演算子は、左から右へとグループにまとめられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Operators that are right-associative group right-to-left, and operators that are specified with an associativity of <bpt i="9" x="9">&lt;c9&gt;</bpt>none<ept i="9">&lt;/c9&gt;</ept> don’t associate at all.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>右結合の演算子は右から左にグループにされます、そして<bpt i="9" x="9">&lt;c9&gt;</bpt>none<ept i="9">&lt;/c9&gt;</ept>の関係性を指定される演算子は全く結合しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional Binding</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルを束縛する（定数・変数と結び付ける）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional Chaining</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional Chaining as an Alternative to Forced Unwrapping</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>強制アンラップに代わるものとしてのオプショナル連鎖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional Pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルパターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional Property Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルプロパティ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional Protocol Requirements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルのプロトコル要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional Tuple Return Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルタプルの戻り型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional binding can be used with <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept> statements to check for a value inside an optional, and to extract that value into a constant or variable, as part of a single action.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル束縛は、<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept>文と一緒に使用して、オプショナルの内部の値を確認すること、そしてその値を定数または変数に抽出することを、一回の動作で可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional chaining in Swift is similar to messaging <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> in Objective-C, but in a way that works for any type, and that can be checked for success or failure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおけるオプショナル連鎖は、どんな型のためにでも働きそして成功か失敗を確認されることができるというようなことを除いて、Objective-Cにおける<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>にメッセージを送ることに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional chaining provides an alternative way to access the value of <bpt i="0" x="0">&lt;c0&gt;</bpt>numberOfRooms<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖は、<bpt i="0" x="0">&lt;c0&gt;</bpt>numberOfRooms<ept i="0">&lt;/c0&gt;</ept>の値にアクセスする代わりの方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional patterns consist of an identifier pattern followed immediately by a question mark and appear in the same places as enumeration case patterns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルパターンは、１つの識別子パターンに直接に１つの疑問符が続くものから成ります、そして列挙ケース節パターンと同じ場所に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional requirements are available so that you can write code that interoperates with Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル要件が利用可能なことから、あなたはObjective-Cと相互運用するコードを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional requirements are prefixed by the <bpt i="1" x="1">&lt;c1&gt;</bpt>optional<ept i="1">&lt;/c1&gt;</ept> modifier as part of the protocol’s definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの要件は、そのプロトコル定義において<bpt i="1" x="1">&lt;c1&gt;</bpt>optional<ept i="1">&lt;/c1&gt;</ept>修飾子を前に置かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional syntactic categories and literals are marked by a trailing subscript, <bpt i="0" x="0">&lt;e0&gt;</bpt>opt<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>任意である統語論のカテゴリーとリテラルは後に続く下つき文字、<bpt i="0" x="0">&lt;e0&gt;</bpt>opt<ept i="0">&lt;/e0&gt;</ept>によって印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional-Chaining Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional-chaining expressions must appear within a postfix expression, and they cause the postfix expression to be evaluated in a special way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖式は、接尾辞式の中に現れなければなりません、そしてそれはその接尾辞式を特別なやり方で評価されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optionals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optionals are used to represent the absence of a value, but when an operation fails, it’s often useful to understand what caused the failure, so that your code can respond accordingly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルは、ある値の欠如を表すために使われます、しかしある操作が失敗する時、何がその失敗をもたらしたのか理解するのはしばしば役に立ちます、それであなたのコードはそれに適切に応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optionals can be checked with an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement to see if a value exists, and can be conditionally unwrapped with optional binding to access the optional’s value if it does exist.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルは、値が存在しているかどうか見るために、<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文を使って調べられることが出来ます、そしてオプショナルの持つ値にそれが存在するならばアクセスするために、オプショナル束縛を使って条件に応じてアンラップされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optionals ensure that <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> values are handled explicitly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルが、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>値が明確に取り扱われるのを確実にする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optionals of <bpt i="4" x="4">&lt;e4&gt;</bpt>any<ept i="4">&lt;/e4&gt;</ept> type can be set to <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>, not just object types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;e4&gt;</bpt>すべての<ept i="4">&lt;/e4&gt;</ept>型のオプショナルが、<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>に設定されることができます、単にオブジェクト型だけでなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optionals say either “there <bpt i="0" x="0">&lt;e0&gt;</bpt>is<ept i="0">&lt;/e0&gt;</ept> a value, and it equals <bpt i="1" x="1">&lt;e1&gt;</bpt>x<ept i="1">&lt;/e1&gt;</ept>” or “there <bpt i="2" x="2">&lt;e2&gt;</bpt>isn’t<ept i="2">&lt;/e2&gt;</ept> a value at all”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルであるものは、「ひとつの値が<bpt i="0" x="0">&lt;e0&gt;</bpt>ある<ept i="0">&lt;/e0&gt;</ept>、そしてそれは<bpt i="1" x="1">&lt;e1&gt;</bpt>x<ept i="1">&lt;/e1&gt;</ept>に等しい」または「まったく値が<bpt i="2" x="2">&lt;e2&gt;</bpt>ない<ept i="2">&lt;/e2&gt;</ept>」のどちらかを伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other named types can only inherit from or conform to a list of protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の名前付きの型は、プロトコルのリストから継承し準拠することだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other products are labeled with 2D barcodes in QR code format, which can use any ISO 8859-1 character and can encode a string up to 2,953 characters long:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>別の製品はQRコード形式の二次元バーコードでラベルをつけられます、それはどんなISO 8859-1の文字でも使うことができて、2,953文字までの長さの文字列をコード化することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other units require some conversion to be expressed as a value measured in meters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他の単位は、メートルで計られる値として表されるためにいくらかの変換を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, a runtime error is raised.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、実行時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, it evaluates the second expression and returns its value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、それは第二の式を評価して、その値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, no message is printed, and code execution continues after the <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement’s closing brace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、メッセージは出力されません、そしてコードの実行は<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文の閉じ波括弧の後に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, the <bpt i="6" x="6">&lt;c6&gt;</bpt>species<ept i="6">&lt;/c6&gt;</ept> property’s value is set, and initialization succeeds:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、<bpt i="6" x="6">&lt;c6&gt;</bpt>species<ept i="6">&lt;/c6&gt;</ept>プロパティの値は設定されて、初期化は成功します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, the error can propagate out of the containing scope, which means the error must be handled by an enclosing <bpt i="2" x="2">&lt;c2&gt;</bpt>catch<ept i="2">&lt;/c2&gt;</ept> clause or the containing function must be declared with <bpt i="3" x="3">&lt;c3&gt;</bpt>throws<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、エラーはそれを収容しているスコープの外に伝えられることができます、それが意味するのは、エラーは囲んでいる<bpt i="2" x="2">&lt;c2&gt;</bpt>catch<ept i="2">&lt;/c2&gt;</ept>節によって取り扱われなければならない、または収容している関数が<bpt i="3" x="3">&lt;c3&gt;</bpt>throws<ept i="3">&lt;/c3&gt;</ept>で宣言されなければならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, the initializer has an access level of internal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、イニシャライザは内部のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, the optional value is unwrapped and assigned to the constant after <bpt i="2" x="2">&lt;c2&gt;</bpt>let<ept i="2">&lt;/c2&gt;</ept>, which makes the unwrapped value available inside the block of code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、そのオプショナルの値は包装を取られて、<bpt i="2" x="2">&lt;c2&gt;</bpt>let<ept i="2">&lt;/c2&gt;</ept>の後の定数に代入されます、そしてそれはコードのブロックの内側で利用できる包装を取られた値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, the optional value is unwrapped, and everything after the <bpt i="5" x="5">&lt;c5&gt;</bpt>?<ept i="5">&lt;/c5&gt;</ept> acts on the unwrapped value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、オプショナルの値は包装を取られます、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>?<ept i="5">&lt;/c5&gt;</ept>の後のすべてのものは包装を取られた値に作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, the program does not perform assignment or execute the <bpt i="8" x="8">&lt;e8&gt;</bpt>statements<ept i="8">&lt;/e8&gt;</ept>, and it is finished executing the <bpt i="9" x="9">&lt;c9&gt;</bpt>for<ept i="9">&lt;/c9&gt;</ept>-<bpt i="10" x="10">&lt;c10&gt;</bpt>in<ept i="10">&lt;/c10&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、プログラムは代入を実行しませんし、<bpt i="8" x="8">&lt;e8&gt;</bpt>文<ept i="8">&lt;/e8&gt;</ept>を実行しません、そしてそれは<bpt i="9" x="9">&lt;c9&gt;</bpt>for<ept i="9">&lt;/c9&gt;</ept>-<bpt i="10" x="10">&lt;c10&gt;</bpt>in<ept i="10">&lt;/c10&gt;</ept>文の実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, the result is an optional containing the value that the function returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、結果は関数が返した値を含んでいるオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, the square’s value is <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>, and it’s a “free” square, represented by <bpt i="1" x="1">&lt;c1&gt;</bpt>○<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一方、正方形の値は<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>ならば、それは「自由」な正方形であって、<bpt i="1" x="1">&lt;c1&gt;</bpt>○<ept i="1">&lt;/c1&gt;</ept>によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, the subscript returns <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、添え字は<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, the value of <bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept> is the value that the function returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept>の値はこの関数が返す値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, the value of the optional-try expression is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、オプショナルtry式の値は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, when set to <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept> or omitted, operators in the precedence group follows the same optional chaining rules as operators that don’t perform assignment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうせずに、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>に設定するか省略する場合は、その優先順位グループの演算子は代入を実行しない演算子と同じオプショナル連鎖規則に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Our goals for Swift are ambitious.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのための私達のゴールは、野心的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Outside the context in which they appear in the grammar, they can be used as identifiers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そこにおいてそれらが文法の中に現れる文脈外では、それらは識別子として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overflow Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバフロー演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overflow addition (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバフロー加算（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overflow also occurs for signed integers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバフローはまた、符号つき整数に対しても起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overflow behavior is trapped and reported as an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバフロー挙動は、エラーとして捕まえられて報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overflow multiplication (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;*<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバフロー乗算（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;*<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overflow subtraction (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバフロー減算（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overridden properties, methods, subscripts, and designated initializers must be marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティ、メソッド、添え字、そして指定イニシャライザのオーバーライドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept>宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overriding</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overriding Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッドのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overriding Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overriding Property Getters and Setters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティゲッターとセッターのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overriding Property Observers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティオブザーバーのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overriding a Failable Initializer</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できるイニシャライザのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overriding by accident can cause unexpected behavior, and any overrides without the <bpt i="1" x="1">&lt;c1&gt;</bpt>override<ept i="1">&lt;/c1&gt;</ept> keyword are diagnosed as an error when your code is compiled.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>誤って偶然にオーバーライドすることは予想外の挙動を引き起こすことがありえます、なので、あなたのコードがコンパイルされるとき、<bpt i="1" x="1">&lt;c1&gt;</bpt>override<ept i="1">&lt;/c1&gt;</ept>キーワードのないどんなオーバーライドもエラーとして診断されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overusing autoclosures can make your code hard to understand.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自動クロージャの使いすぎは、あなたのコードを理解しにくくする可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parameter Names</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータ名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parameter Names and Argument Labels</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータ名と引数ラベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parameters can be ignored, take a variable number of values, and provide default values using the following forms:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータは、無視されること、可変の数の値をとること、そして以下の形式を使って省略時の値を提供することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parameters can provide default values to simplify function calls and can be passed as in-out parameters, which modify a passed variable once the function has completed its execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータは、関数呼び出しを単純化するために初期値を提供することができます、そしてひとたび関数がその実行を完了し終えれば渡された変数を修正するin-outパラメータとして渡されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parameters that don’t have default values are usually more important to the function’s meaning—writing them first makes it easier to recognize that the same function is being called, regardless of whether any default parameters are omitted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の値を持たないパラメータは、関数の意味するところにとって通常より重要です—それらを最初に書くことは、何らかの省略時のパラメータが省かれているかどうかに関係なく、同じ関数が呼び出されているのをよりわかり易くします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parentheses around the condition or loop variable are optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>条件またはループ変数のまわりの丸括弧は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Parenthesized Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>括弧に入れられた式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Part of the functionality of the <bpt i="0" x="0">&lt;c0&gt;</bpt>DataManager<ept i="0">&lt;/c0&gt;</ept> class is the ability to import data from a file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>DataManager<ept i="0">&lt;/c0&gt;</ept>クラスの機能性の一部は、データをファイルからインポートする能力です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Passing <bpt i="0" x="0">&lt;c0&gt;</bpt>birthdayPerson<ept i="0">&lt;/c0&gt;</ept> to the <bpt i="1" x="1">&lt;c1&gt;</bpt>beginConcert(in:)<ept i="1">&lt;/c1&gt;</ept> function is invalid because <bpt i="2" x="2">&lt;c2&gt;</bpt>Person<ept i="2">&lt;/c2&gt;</ept> isn’t a subclass of <bpt i="3" x="3">&lt;c3&gt;</bpt>Location<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>birthdayPerson<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>beginConcert(in:)<ept i="1">&lt;/c1&gt;</ept>関数に渡すことは無効です、なぜなら<bpt i="2" x="2">&lt;c2&gt;</bpt>Person<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>Location<ept i="3">&lt;/c3&gt;</ept>のサブクラスではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Patterns</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Performing Set Operations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合演算の実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Phase 1</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第１段階</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Phase 2</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第２段階</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Place parameters that don’t have default values at the beginning of a function’s parameter list, before the parameters that have default values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の値を持たないパラメータを関数のもつパラメータリストの始まりに、省略時の値を持つパラメータの前に、置いてください、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Place the capture list before a closure’s parameter list and return type if they are provided:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらが提供されるならばクロージャのパラメータ・リストと戻り型の前に、捕獲リストを置いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Platform condition</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プラットホーム条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Playground literals in plain text outside of Xcode are represented using a special literal syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Xcodeの外部のプレーンテキストの中のプレイグラウンドリテラルは、特別なリテラル構文を使って表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Playgrounds allow you to edit the code listings and see the result 
        immediately.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレイグラウンドは、あなたがコードリストを編集してすぐにその結果を見られるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pointers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Popping a value from the stack removes and returns the top value, <bpt i="0" x="0">&lt;c0&gt;</bpt>"cuatro"<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このスタックから値をボップすることは、一番上の値、<bpt i="0" x="0">&lt;c0&gt;</bpt>"cuatro"<ept i="0">&lt;/c0&gt;</ept>を削除して、返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Positive numbers are stored in exactly the same way as for unsigned integers, counting upwards from <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正の数は符号なし整数と正確に同じ方法で保存されて、<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>から上方へ数えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Postfix Expressions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接尾辞表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Postfix Self Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接尾辞self式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Postfix expressions, like prefix and binary expressions, let you build up more complex expressions using postfixes such as function calls and member access.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接尾辞式は、接頭辞や二項の式に似て、関数呼び出しやメンバー・アクセスのような接尾辞を使うことで、あなたにより複雑な式を組み立てさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Postfix operators are nonassociative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接尾辞演算子は非結合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precedence Group Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>優先順位グループ定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precedence and Associativity</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>優先順位と結合性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precedence for Custom Infix Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あつらえの接中辞演算子の優先順位</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Precedence groups related to each other using <bpt i="0" x="0">&lt;e0&gt;</bpt>lower group names<ept i="0">&lt;/e0&gt;</ept> and <bpt i="1" x="1">&lt;e1&gt;</bpt>higher group names<ept i="1">&lt;/e1&gt;</ept> must fit into a single relational hierarchy, but they <bpt i="2" x="2">&lt;e2&gt;</bpt>don’t<ept i="2">&lt;/e2&gt;</ept> have to form a linear hierarchy.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>下方グループ名<ept i="0">&lt;/e0&gt;</ept>と<bpt i="1" x="1">&lt;e1&gt;</bpt>上方グループ名<ept i="1">&lt;/e1&gt;</ept>を使って互いに関係のある優先順位グループは、単一の関係階層へはめ込まなければなりません、しかしそれらは線形階層を形作る必要は<bpt i="2" x="2">&lt;e2&gt;</bpt>ありません<ept i="2">&lt;/e2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Prefix Expressions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接頭辞式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Prefix and Postfix Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接頭辞と接尾辞演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Prefix and Suffix Equality</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接頭辞と接尾辞等式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Prefix and binary expressions let you apply operators to smaller expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接頭辞と二項式は、あなたに演算子をより小さい式に適用させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Prefix operators are nonassociative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接頭辞演算子は非結合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Prefix operators declarations don’t specify a precedence level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接頭辞演算子宣言は、優先順位レベルを指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Prefix operators take one argument, the expression that follows them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接頭辞演算子は、１つの引数（それらの後に続く式）をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Preventing Overrides</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバーライドを防ぐ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Primary Expressions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基本式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Primary expressions are conceptually the simplest kind of expression, and they provide a way to access values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基本式は、概念的に最も単純な種類の式で、それらはアクセス手段をさまざまな値に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Printing Constants and Variables</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数と変数を出力する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Printing the description of each item in the array shows that their default states have been set as expected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の各項目の説明を出力することは、予想されるようにそれらの省略時の状態が設定されたことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Private Members in Extensions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張の中の非公開メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Private members declared in the type’s declaration can be accessed from extensions, and private members declared in one extension can be accessed from other extensions and from the type’s declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型の持つ宣言において宣言される非公開メンバは拡張からアクセスできます、そして一方の拡張において宣言される非公開メンバは他方の拡張からそしてその型のもつ宣言からアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Program execution continues at the point immediately following the function or method call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プログラム実行は、関数またはメソッド呼び出しに直ちに続いている地点に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Program execution continues to the next case even if the patterns of the case label do not match the value of the <bpt i="5" x="5">&lt;c5&gt;</bpt>switch<ept i="5">&lt;/c5&gt;</ept> statement’s control expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえケース節ラベルのパターンが<bpt i="5" x="5">&lt;c5&gt;</bpt>switch<ept i="5">&lt;/c5&gt;</ept>文のもつ制御式の値にマッチしないとしても、プログラム実行は次のケース節に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Program execution does not continue or “fall through” to the next case or default case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プログラム実行は続きません、あるいは、次のケース節または省略時のケース節に「抜け落ちる」ことはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Propagating Errors Using Throwing Functions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スロー関数を使ってエラーを伝える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Propagation of Initialization Failure</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化失敗の伝播</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Properties can only be accessed, and methods can only be called, once the class instance is known to be valid at the end of the first phase.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一旦クラスインスタンスが第１段階の終わりに有効であるということを知られる場合にのみ、プロパティはアクセスされることができ、そしてメソッドは呼ばれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Properties of a structure instance can be accessed using dot (<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>) syntax, as described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Accessing Properties<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスインスタンスのプロパティにドット（<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>）構文でアクセスされることができます、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>プロパティにアクセスする<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Properties of optional type are automatically initialized with a value of <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>, indicating that the property is deliberately intended to have “no value yet” during initialization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの型のプロパティは、<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>の値で自動的に初期化されて、そのプロパティは初期化の時には「まだ無い値」を故意に持つつもりであることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Properties, methods, and initializers of an existing type can’t be overridden in an extension of that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>既存の型のプロパティ、メソッド、そしてイニシャライザは、その型の拡張においてオーバーライドされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Property Observers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティオブザーバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Property Requirements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティ要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティオブザーバーは、あるプロパティの値が設定されるたびに、たとえ新しい値がそのプロパティの現在の値と同じものであるとしても、呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Property observers aren’t called when ARC sets a weak reference to <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティオブザーバーは、ARCが弱い参照を<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>に設定するとき呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Property observers can be added to any property, regardless of whether it was originally defined as a stored or computed property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティオブザーバーは、どんなプロパティにでも加えられることができます、それが保存または計算プロパティとして元々定義されたかどうかは関係ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Property observers can be added to stored properties you define yourself, and also to properties that a subclass inherits from its superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティオブザーバーは、あなたがあなた自身で定義する保存プロパティに、そのうえにサブクラスがそのスーパークラスから継承するプロパティにも加えられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Property observers observe and respond to changes in a property’s value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティオブザーバーは、あるプロパティの値の変化を観察して、応答します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Property overriding is described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Overriding<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティをオーバーライドすることは<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オーバーライド<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Property requirements are always declared as variable properties, prefixed with the <bpt i="0" x="0">&lt;c0&gt;</bpt>var<ept i="0">&lt;/c0&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティ要件は常に変数プロパティとして宣言されます、それで<bpt i="0" x="0">&lt;c0&gt;</bpt>var<ept i="0">&lt;/c0&gt;</ept>キーワードを前に置かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol Associated Type Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル関連型宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol Composition</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル合成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol Composition Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル合成型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol Conformance</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol Extensions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol Inheritance</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol Initializer Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルイニシャライザ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol Method Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルメソッド宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol Property Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルプロパティ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol Subscript Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル添え字宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol casts are no longer limited to <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept> protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルのキャストは、もはや<bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept>プロトコルに制限されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol composition types have the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル合成型は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol composition types may be used only when specifying a type in type annotations, in generic parameter clauses, and in generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clauses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル合成型は、型注釈において、総称体パラメータ節において、そして総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節において型を指定する場合にのみ使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol compositions behave as if you defined a temporary local protocol that has the combined requirements of all protocols in the composition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル合成は、あなたが全てのプロトコルの要件を結合したものをその合成物の中に持っている一時的なローカルプロトコルを定義したかのように振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol compositions don’t define any new protocol types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル合成は、何ら新しいプロトコル型を定義しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol compositions have the form <bpt i="0" x="0">&lt;c0&gt;</bpt>SomeProtocol &amp; AnotherProtocol<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル合成は、形式<bpt i="0" x="0">&lt;c0&gt;</bpt>SomeProtocol &amp; AnotherProtocol<ept i="0">&lt;/c0&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol declarations are declared at global scope using the <bpt i="1" x="1">&lt;c1&gt;</bpt>protocol<ept i="1">&lt;/c1&gt;</ept> keyword and have the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル宣言は、グローバルなスコープでキーワード<bpt i="1" x="1">&lt;c1&gt;</bpt>protocol<ept i="1">&lt;/c1&gt;</ept>を使って宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol declarations can’t contain class, structure, enumeration, or other protocol declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル宣言は、クラス、構造体、列挙、または他のプロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol initializer declarations have the same form as initializer declarations, except they don’t include the initializer’s body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルイニシャライザ宣言は、それらがイニシャライザ本文を含めないことを除いて、イニシャライザ宣言と同じ形式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol method declarations have the same form as function declarations, with two exceptions: They don’t include a function body, and you can’t provide any default parameter values as part of the function declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルメソッド宣言は、２つの例外を除いて、関数宣言と同じ形式を持ちます：それらは関数本体を含むことができません、そして、あなたは関数宣言の一部として省略時のパラメータ値をまったく提供することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol property declarations have a special form of a variable declaration:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルプロパティ宣言は、変数宣言の特別な形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol requirements with default implementations provided by extensions are distinct from optional protocol requirements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張によって提供される省略時の実装を持つプロトコル要件は、オプショナルプロトコル要件とは異なったものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol subscript declarations have a special form of a subscript declaration:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル添え字宣言は、添え字宣言の特別な形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol types can inherit from any number of other protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル型は、いくらかの他のプロトコルから継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols and Extensions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルと拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols are named types, and thus they can appear in all the same places in your code as other named types, as discussed in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocols as Types<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは名前をつけられた型です、したがってそれらはあなたのコードにおいて他の名前をつけられた型と同じ場所の全てにおいて現れることができます、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>型としてのプロトコル<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols as Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型としてのプロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols can also declare special kinds of type aliases, called <bpt i="1" x="1">&lt;e1&gt;</bpt>associated types<ept i="1">&lt;/e1&gt;</ept>, that can specify relationships among the various declarations of the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルはまた、特別な種類の型エイリアス、そのプロトコルのいろいろな宣言の間での関係を指定することができる<bpt i="1" x="1">&lt;e1&gt;</bpt>関連型<ept i="1">&lt;/e1&gt;</ept>と呼ばれるものを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols can be extended to provide method and property implementations to conforming types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは拡張されることが可能です、それによって準拠している型にメソッドとプロパティの実装を提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols can be restricted to a certain context, as can global constants, variables, and functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは特定の前後関係に制限されることができます、グローバルな定数、変数、そして関数も同じようにされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols can define failable initializer requirements for conforming types, as defined in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Failable Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>失敗できるイニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、準拠している型に対して失敗できるイニシャライザ要件を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols can require specific initializers to be implemented by conforming types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは、準拠型によって特定のイニシャライザが実装されるように要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols can require specific instance methods and type methods to be implemented by conforming types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは、準拠型によって特定のインスタンスメソッドと型メソッドが実装されるように要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols declare associated types using the <bpt i="0" x="0">&lt;c0&gt;</bpt>associatedtype<ept i="0">&lt;/c0&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは、関連型をキーワード<bpt i="0" x="0">&lt;c0&gt;</bpt>associatedtype<ept i="0">&lt;/c0&gt;</ept>を使って宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols declare that conforming types must implement a method by including a protocol method declaration in the body of the protocol declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルが宣言するのは、準拠している型は、プロトコル宣言の本文中のプロトコルメソッド宣言を含めることによって、あるメソッドを実装する必要があるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols declare that conforming types must implement a property by including a <bpt i="0" x="0">&lt;e0&gt;</bpt>protocol property declaration<ept i="0">&lt;/e0&gt;</ept> in the body of the protocol declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは、準拠している型がそのプロトコル宣言の本文の中の<bpt i="0" x="0">&lt;e0&gt;</bpt>プロトコルプロパティ宣言<ept i="0">&lt;/e0&gt;</ept>を含めることによってプロパティを実装しなければならないことを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols declare that conforming types must implement a subscript by including a protocol subscript declaration in the body of the protocol declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは、準拠している型がそのプロトコル宣言の本文の中のプロトコル添え字宣言を含めることによって添え字を実装しなければならないと宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols declare that conforming types must implement an initializer by including a protocol initializer declaration in the body of the protocol declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは、準拠している型がそのプロトコル宣言の本文の中のプロトコルイニシャライザ宣言を含めることによってイニシャライザを実装しなければならないと宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols don’t actually implement any functionality themselves.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは、実際に少しの機能性も実装しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocols that are marked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>objc<ept i="2">&lt;/c2&gt;</ept> attribute can’t inherit from protocols that aren’t marked with this attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>objc<ept i="2">&lt;/c2&gt;</ept>属性で印されるプロトコルは、この属性で印されないプロトコルから継承できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Provide new initializers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいイニシャライザを提供する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Providing Default Implementations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の実装を提供する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Providing a value when you create a constant or variable lets the compiler infer its type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが定数または変数をつくる時に値を提供することは、コンパイラにその型を推論させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Providing error handling when values get too large or too small gives you much more flexibility when coding for boundary value conditions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値があまりに大きいかあまりに小さくなる時にエラー処理を提供することは、境界値条件のためのコードを書くとき、あなたにずっと多くの柔軟性を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Providing more detail limits which symbols are imported—you can specify a specific submodule or a specific declaration within a module or submodule.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より詳細な記述を提供することは、どのシンボルがインポートされるかを制限します ― あなたは、あるモジュールまたはサブモジュール内で、特定のサブモジュールまたは特定の宣言を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Querying and Setting Type Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型プロパティを問い合わせて、設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Range Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>範囲演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rather than a copy, a reference to the same existing instance is used instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コピーではなく、既存の同じインスタンスに対する参照が代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rather than moving the player immediately, the loop uses a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement to consider the result of the move and to determine whether the move is allowed:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>直ちにプレーヤーを動かすのではなく、ループは<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文を使うことで、移動の結果を考慮して、移動が許可されるかどうか判断します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rather than placing an exclamation mark after the optional’s name each time you use it, you place an exclamation mark after the optional’s type when you declare it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがそれを使うたびにオプショナルの名前の後に感嘆符を置くよりも、あなたがそれを宣言する時にオプショナルの型の後に感嘆符を書きたいとあなたは思うでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rather than returning an existing value, the getter actually calculates and returns a new <bpt i="4" x="4">&lt;c4&gt;</bpt>Point<ept i="4">&lt;/c4&gt;</ept> to represent the center of the square.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>既存の値を返すのではなく、このゲッターは正方形の中心を表すために実際に計算して新しい<bpt i="4" x="4">&lt;c4&gt;</bpt>Point<ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rather, it reports a compile-time error that <bpt i="4" x="4">&lt;c4&gt;</bpt>case "a":<ept i="4">&lt;/c4&gt;</ept> does not contain any executable statements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうではなく、それは<bpt i="4" x="4">&lt;c4&gt;</bpt>case "a":<ept i="4">&lt;/c4&gt;</ept>が実行可能な文を何も含まないという、コンパイル時エラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rather, their role is to ensure that <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> is fully and correctly initialized by the time that initialization ends.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>というより、それの役割は、初期化が終わるまでに<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>が完全にそして正確に初期化されることを確実にすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Raw Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Raw Values and Associated Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の値と関連値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Raw values are <bpt i="0" x="0">&lt;e0&gt;</bpt>not<ept i="0">&lt;/e0&gt;</ept> the same as associated values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の値は、関連値と同じもので<bpt i="0" x="0">&lt;e0&gt;</bpt>ない<ept i="0">&lt;/e0&gt;</ept>点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Raw values are set to prepopulated values when you first define the enumeration in your code, like the three ASCII codes above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の値は、上の３つのASCIIコードの様に、あなたがあなたのコードにおいて最初に列挙を定義するとき、あらかじめ入れられた値に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Raw values can be strings, characters, or any of the integer or floating-point number types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の値は、文字列、文字、または何らかの整数や浮動小数点数型であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Read-Only Computed Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>読み出し専用の計算プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Readability is always preferred over brevity; use parentheses where they help to make your intentions clear.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>読みやすさは、常に簡潔さよりも好まれます；それらがあなたの意図を明確にする助けとなるところに丸括弧を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Recursive Enumerations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>再帰列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reference counting allows more than one reference to a class instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照カウントは、あるクラスインスタンスに対する１つ以上の参照を許します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Reference counting only applies to instances of classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照カウントは、クラスのインスタンスに適用されるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Referring to Nested Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされた型を参照する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remainder Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>剰余演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remainder and multiplication both associate with the expression to their left.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>剰余と乗算は、両方とも式をそれらの左と結びつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remove the <bpt i="0" x="0">&lt;c0&gt;</bpt>day<ept i="0">&lt;/c0&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>day<ept i="0">&lt;/c0&gt;</ept>パラメータを取り除いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removed a duplicate description of the valid set of operator characters from <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Custom Operators<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>有効な演算子の一式の重複する説明を<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>あつらえの演算子<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>から取り除きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removed a note to the contrary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これに反する注意書きを取り除きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removed discussion of C-style <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept> loops, the <bpt i="1" x="1">&lt;c1&gt;</bpt>++<ept i="1">&lt;/c1&gt;</ept> prefix and postfix operators, and the <bpt i="2" x="2">&lt;c2&gt;</bpt>--<ept i="2">&lt;/c2&gt;</ept> prefix and postfix operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C形式<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>ループ、<bpt i="1" x="1">&lt;c1&gt;</bpt>++<ept i="1">&lt;/c1&gt;</ept>接頭辞および接尾辞演算子、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>--<ept i="2">&lt;/c2&gt;</ept>接頭辞および接尾辞演算子の議論を削除した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removed discussion of variable function arguments and the special syntax for curried functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数関数引数とカリー化関数のための特別な構文の議論を削除した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removed the Dynamic Type Expression section from the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Expressions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter, now that <bpt i="2" x="2">&lt;c2&gt;</bpt>type(of:)<ept i="2">&lt;/c2&gt;</ept> is a Swift standard library function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「動的型式」の節を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>式<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の章から削除した、今では<bpt i="2" x="2">&lt;c2&gt;</bpt>type(of:)<ept i="2">&lt;/c2&gt;</ept>はスウィフト標準ライブラリ関数であるので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removed the discussion of explicitly using <bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept> in function parameters from the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Function Declaration<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>明示的に<bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept>を関数パラメータにおいて使用することの解説を節<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>関数宣言<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>から削除した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removed the discussion of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Boolean<ept i="0">&lt;/c0&gt;</ept> protocol from the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Statements<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> chapter, now that the protocol has been removed from the Swift standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Boolean<ept i="0">&lt;/c0&gt;</ept>プロトコルの解説を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>文<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>の章から削除した、今ではこのプロトコルはスウィフト標準ライブラリから削除されてしまったので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Removed the overflow division (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;/<ept i="0">&lt;/c0&gt;</ept>) and overflow remainder (<bpt i="1" x="1">&lt;c1&gt;</bpt>&amp;%<ept i="1">&lt;/c1&gt;</ept>) operators from <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Overflow Operators<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバフロー除算（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;/<ept i="0">&lt;/c0&gt;</ept>）とオーバフロー剰余（<bpt i="1" x="1">&lt;c1&gt;</bpt>&amp;%<ept i="1">&lt;/c1&gt;</ept>）演算子を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>オーバフロー演算子<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>から削除しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Repeat-While</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>終わりに評価</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Repeat-While Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>repeat-while文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Representing and Throwing Errors</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーの表現とスロー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Required Initializers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>必須イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Requiring exhaustiveness ensures that enumeration cases are not accidentally omitted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>徹底を必要とすることは、列挙ケース節がうっかり忘れられないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Resolving Strong Reference Cycles Between Class Instances</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスインスタンス間の強い参照循環の解消</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Resolving Strong Reference Cycles for Closures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャのための強い参照循環の解消</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rethrowing Functions and Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>再スローを行う関数とメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rethrowing functions and methods must have at least one throwing function parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>再スロー関数とメソッドは、少なくとも１つのスロー関数パラメーターを持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Retrieve a value from the array by using <bpt i="0" x="0">&lt;e0&gt;</bpt>subscript syntax<ept i="0">&lt;/e0&gt;</ept>, passing the index of the value you want to retrieve within square brackets immediately after the name of the array:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>添え字構文<ept i="0">&lt;/e0&gt;</ept>を使うことで、ひとつの値をこの配列から取り出してください、あなたが取り出したい値の添え字（インデックス、指数）を、配列の名前の直後の角括弧内に入れて渡してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Return Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>復帰文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Return values can be ignored, but a function that says it will return a value must always do so.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>戻り値は無視されることができます、しかし値を返すつもりだと言う関数は、常にそうしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Revision History</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>改訂履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rewrite the closure to return zero for all odd numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このクロージャを、全ての奇数に対してゼロを返すように書き直してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rewrote the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Inheritance<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter to remove its introductory coverage of initializer overrides.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>章<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>継承<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を書き直して、それの前置きのイニシャライザのオーバーライドを扱った部分を取り除きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rule 1</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>規則１</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rule 2</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>規則２</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rule 3</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>規則３</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Safety check 1</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>安全点検１</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Safety check 2</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>安全点検２</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Safety check 3</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>安全点検３</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Safety check 4</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>安全点検４</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Scalars that have been assigned to a character typically also have a name, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>LATIN SMALL LETTER A<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>FRONT-FACING BABY CHICK<ept i="1">&lt;/c1&gt;</ept> in the examples above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字に割り当てられるスカラーは、たいてい名前を持っています、例えば以前の例での<bpt i="0" x="0">&lt;c0&gt;</bpt>LATIN SMALL LETTER A<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>FRONT-FACING BABY CHICK<ept i="1">&lt;/c1&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Second, even if <bpt i="7" x="7">&lt;c7&gt;</bpt>dataSource<ept i="7">&lt;/c7&gt;</ept> <bpt i="8" x="8">&lt;e8&gt;</bpt>does<ept i="8">&lt;/e8&gt;</ept> exist, there’s no guarantee that it implements <bpt i="9" x="9">&lt;c9&gt;</bpt>increment(forCount:)<ept i="9">&lt;/c9&gt;</ept>, because it’s an optional requirement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第２に、たとえ<bpt i="7" x="7">&lt;c7&gt;</bpt>dataSource<ept i="7">&lt;/c7&gt;</ept>が<bpt i="8" x="8">&lt;e8&gt;</bpt>存在する<ept i="8">&lt;/e8&gt;</ept>としても、それが<bpt i="9" x="9">&lt;c9&gt;</bpt>increment(forCount:)<ept i="9">&lt;/c9&gt;</ept>を実装する保証はありません、それがオプショナルの要件であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Second, the two’s complement representation also lets you shift the bits of negative numbers to the left and right like positive numbers, and still end up doubling them for every shift you make to the left, or halving them for every shift you make to the right.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第２に、２の補数表現はまた、あなたに負数のビットを左や右に正の数のようにシフトさせます、そして依然としてあなたが左へとするシフトは全てそれを２倍にすることで、またあなたが右へとするシフトは全てそれを半分にすることで終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Precedence and Associativity<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> for an explanation of how these characteristics affect an infix operator’s interaction with other infix operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>優先順位と結合性<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>をどのようにそれらの特徴が接中辞演算子の他の接中辞演算子との相互作用に影響を及ぼすかの解説として見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Special Characters in String Literals<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>文字列リテラル内の特別な文字<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Overflow Operators<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>オーバフロー演算子<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Function Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>また、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>関数宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Initializer Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>また、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>イニシャライザ宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocol Associated Type Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>また、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコル関連型宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Subscript Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>また、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>添え字宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Type Alias Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>また、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>型エイリアス宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See also <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Variable Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>また、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>変数の宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Selector Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>セレクタ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Self Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>self式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Semicolons</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>セミコロン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Separate each requirement in the list with a comma.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リストの中の各要件をコンマで区切ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Set <bpt i="13" x="13">&lt;c13&gt;</bpt>b<ept i="13">&lt;/c13&gt;</ept> and set <bpt i="14" x="14">&lt;c14&gt;</bpt>c<ept i="14">&lt;/c14&gt;</ept> are <bpt i="15" x="15">&lt;e15&gt;</bpt>disjoint<ept i="15">&lt;/e15&gt;</ept> with one another, because they share no elements in common.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合<bpt i="13" x="13">&lt;c13&gt;</bpt>b<ept i="13">&lt;/c13&gt;</ept>と集合<bpt i="14" x="14">&lt;c14&gt;</bpt>c<ept i="14">&lt;/c14&gt;</ept>は、他のものと<bpt i="15" x="15">&lt;e15&gt;</bpt>互いに素<ept i="15">&lt;/e15&gt;</ept>です（交わりを持たない）、なぜならそれらが共通の要素を共有しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Set <bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept> is a <bpt i="4" x="4">&lt;e4&gt;</bpt>superset<ept i="4">&lt;/e4&gt;</ept> of set <bpt i="5" x="5">&lt;c5&gt;</bpt>b<ept i="5">&lt;/c5&gt;</ept>, because <bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept> contains all elements in <bpt i="7" x="7">&lt;c7&gt;</bpt>b<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合<bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept>は集合<bpt i="5" x="5">&lt;c5&gt;</bpt>b<ept i="5">&lt;/c5&gt;</ept>の<bpt i="4" x="4">&lt;e4&gt;</bpt>上位集合<ept i="4">&lt;/e4&gt;</ept>です、なぜなら<bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>b<ept i="7">&lt;/c7&gt;</ept>のすべての要素を含むからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Set Membership and Equality</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合の帰属と等価性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Set Type Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Set型構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sets</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sets are unordered collections of unique values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合は、順番をつけられないそれぞれが異なった値のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Setting Initial Values for Stored Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期値を保存プロパティに設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Setting a Default Property Value with a Closure or Function</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時のプロパティ値をクロージャまたは関数を使って設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Setting the <bpt i="2" x="2">&lt;c2&gt;</bpt>center<ept i="2">&lt;/c2&gt;</ept> property calls the setter for <bpt i="3" x="3">&lt;c3&gt;</bpt>center<ept i="3">&lt;/c3&gt;</ept>, which modifies the <bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept> values of the stored <bpt i="6" x="6">&lt;c6&gt;</bpt>origin<ept i="6">&lt;/c6&gt;</ept> property, and moves the square to its new position.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>center<ept i="2">&lt;/c2&gt;</ept>プロパティを設定することは、<bpt i="3" x="3">&lt;c3&gt;</bpt>center<ept i="3">&lt;/c3&gt;</ept>のためのセッターを呼び出します、そしてそれは、保存された<bpt i="6" x="6">&lt;c6&gt;</bpt>origin<ept i="6">&lt;/c6&gt;</ept>プロパティの<bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept>値を修正して、正方形をその新しい位置へと動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Setting the value of properties that the subclass declares.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブクラスが宣言するプロパティの値を設定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Several of the <bpt i="7" x="7">&lt;c7&gt;</bpt>switch<ept i="7">&lt;/c7&gt;</ept> statement’s cases bind their matched value to a constant of the specified type to enable its value to be printed:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt>switch<ept i="7">&lt;/c7&gt;</ept>文のケース節のいくつかは、それらが適合した値を指定された型のある定数に結び付け、その値を出力できるようにします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Shifting Behavior for Signed Integers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号つき整数のためのシフト挙動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Shifting Behavior for Unsigned Integers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号なし整数のためのシフト挙動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Shifting an integer’s bits to the left by one position doubles its value, whereas shifting it to the right by one position halves its value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数のビットを位置１つだけ左へ移すことはその値を２倍にします、一方それを位置１つだけ右へ移すことはその値を半分にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Shorthand Argument Names</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>短縮形引数名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Shorthand Setter Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>短縮形セッター宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Shorthand argument names</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>短縮形引数名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Signed integers use their first bit (known as the <bpt i="0" x="0">&lt;e0&gt;</bpt>sign bit<ept i="0">&lt;/e0&gt;</ept>) to indicate whether the integer is positive or negative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号つき整数は、それらの最初のビット（<bpt i="0" x="0">&lt;e0&gt;</bpt>符号ビット<ept i="0">&lt;/e0&gt;</ept>として知られるもの）を使って、その整数が正であるか負であるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similar to an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement, you can add multiple conditional branches to test for different compilation conditions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文と同様に、あなたは複数の条件分岐を加えて、異なるコンパイル条件に対してテストすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, <bpt i="5" x="5">&lt;c5&gt;</bpt>item is Song<ept i="5">&lt;/c5&gt;</ept> checks whether the item is a <bpt i="6" x="6">&lt;c6&gt;</bpt>Song<ept i="6">&lt;/c6&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、<bpt i="5" x="5">&lt;c5&gt;</bpt>item is Song<ept i="5">&lt;/c5&gt;</ept>はその項目が<bpt i="6" x="6">&lt;c6&gt;</bpt>Song<ept i="6">&lt;/c6&gt;</ept>インスタンスであるか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, <bpt i="6" x="6">&lt;c6&gt;</bpt>0xFp-2<ept i="6">&lt;/c6&gt;</ept> represents 15 x 2<bpt i="7" x="7">&lt;s7&gt;</bpt>-2<ept i="7">&lt;/s7&gt;</ept>, which evaluates to <bpt i="8" x="8">&lt;c8&gt;</bpt>3.75<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、<bpt i="6" x="6">&lt;c6&gt;</bpt>0xFp-2<ept i="6">&lt;/c6&gt;</ept>は15 × 2<bpt i="7" x="7">&lt;s7&gt;</bpt>-2<ept i="7">&lt;/s7&gt;</ept>を表します、それは<bpt i="8" x="8">&lt;c8&gt;</bpt>3.75<ept i="8">&lt;/c8&gt;</ept>に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, <bpt i="6" x="6">&lt;c6&gt;</bpt>1.25e-2<ept i="6">&lt;/c6&gt;</ept> represents 1.25 x 10<bpt i="7" x="7">&lt;s7&gt;</bpt>-2<ept i="7">&lt;/s7&gt;</ept>, which evaluates to <bpt i="8" x="8">&lt;c8&gt;</bpt>0.0125<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、<bpt i="6" x="6">&lt;c6&gt;</bpt>1.25e-2<ept i="6">&lt;/c6&gt;</ept>は1.25 × 10<bpt i="7" x="7">&lt;s7&gt;</bpt>-2<ept i="7">&lt;/s7&gt;</ept>を表します、それは<bpt i="8" x="8">&lt;c8&gt;</bpt>0.0125<ept i="8">&lt;/c8&gt;</ept>に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, a method marked with the <bpt i="4" x="4">&lt;c4&gt;</bpt>nonobjc<ept i="4">&lt;/c4&gt;</ept> attribute can’t satisfy a protocol requirement for a method marked with the <bpt i="5" x="5">&lt;c5&gt;</bpt>objc<ept i="5">&lt;/c5&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、<bpt i="4" x="4">&lt;c4&gt;</bpt>nonobjc<ept i="4">&lt;/c4&gt;</ept>属性で印されるメソッドは、<bpt i="5" x="5">&lt;c5&gt;</bpt>objc<ept i="5">&lt;/c5&gt;</ept>属性で印されるメソッドに対するプロトコル要件を満たすことは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, a stack allows items to be removed only from the end of the collection (known as <bpt i="3" x="3">&lt;e3&gt;</bpt>popping<ept i="3">&lt;/e3&gt;</ept> a value off the stack).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、スタックは項目をコレクションの終わりからだけ取り除かれることが許されます（値をスタックから<bpt i="3" x="3">&lt;e3&gt;</bpt>ポップ<ept i="3">&lt;/e3&gt;</ept>するとして知られます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, a subclass failable initializer can delegate up to a superclass failable initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、サブクラスの失敗できるイニシャライザは、スーパークラスの失敗できるイニシャライザにさかのぼって委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, a subscript can’t be more public than either its index type or return type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、添え字はそのインデックス型や戻り型よりも公開であることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, every <bpt i="0" x="0">&lt;c0&gt;</bpt>Apartment<ept i="0">&lt;/c0&gt;</ept> instance has a <bpt i="1" x="1">&lt;c1&gt;</bpt>unit<ept i="1">&lt;/c1&gt;</ept> property of type <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> and has an optional <bpt i="3" x="3">&lt;c3&gt;</bpt>tenant<ept i="3">&lt;/c3&gt;</ept> property that is initially <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、あらゆる<bpt i="0" x="0">&lt;c0&gt;</bpt>Apartment<ept i="0">&lt;/c0&gt;</ept>インスタンスは、型<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>unit<ept i="1">&lt;/c1&gt;</ept>プロパティを持って、初期時には<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>であるオプショナルの<bpt i="3" x="3">&lt;c3&gt;</bpt>tenant<ept i="3">&lt;/c3&gt;</ept>プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, if you have multiple nested loops, it can be useful to be explicit about which loop the <bpt i="2" x="2">&lt;c2&gt;</bpt>continue<ept i="2">&lt;/c2&gt;</ept> statement should affect.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、あなたが複数の入れ子にされたループを持つならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>continue<ept i="2">&lt;/c2&gt;</ept>文が影響を及ぼさなければならないループはどれかについて明確にすることは役に立つでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, if you implement a <bpt i="0" x="0">&lt;c0&gt;</bpt>didSet<ept i="0">&lt;/c0&gt;</ept> observer, it’s passed a constant parameter containing the old property value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>didSet<ept i="0">&lt;/c0&gt;</ept>オブザーバーを実装するならば、それは古いプロパティ値を含んでいる定数パラメータを渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, if you try to create a <bpt i="0" x="0">&lt;c0&gt;</bpt>CartItem<ept i="0">&lt;/c0&gt;</ept> instance with an empty <bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept> value, the superclass <bpt i="2" x="2">&lt;c2&gt;</bpt>Product<ept i="2">&lt;/c2&gt;</ept> initializer causes initialization to fail:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>CartItem<ept i="0">&lt;/c0&gt;</ept>インスタンスを空の<bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept>値で作成することを試みるならば、スーパークラスの<bpt i="2" x="2">&lt;c2&gt;</bpt>Product<ept i="2">&lt;/c2&gt;</ept>イニシャライザは初期化が失敗する原因となります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, if you try to retrieve an <bpt i="0" x="0">&lt;c0&gt;</bpt>Int?<ept i="0">&lt;/c0&gt;</ept> value through optional chaining, an <bpt i="1" x="1">&lt;c1&gt;</bpt>Int?<ept i="1">&lt;/c1&gt;</ept> is always returned, no matter how many levels of chaining are used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、あなたがオプショナル連鎖を通して<bpt i="0" x="0">&lt;c0&gt;</bpt>Int?<ept i="0">&lt;/c0&gt;</ept>値を取り出そうと試すならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int?<ept i="1">&lt;/c1&gt;</ept>が常に返されます、どんなに多くの連鎖階層が使われようともです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、あくまでもより複雑な型の文脈内で使用するだけの有用なクラスや構造体を定義することは、便利でありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, its second case matches all lowercase English consonants.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、その第二のケース節は、小文字の英語の子音すべてにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, the <bpt i="0" x="0">&lt;c0&gt;</bpt>SnakesAndLadders<ept i="0">&lt;/c0&gt;</ept> game class can be extended to adopt and conform to the <bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept> protocol:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、<bpt i="0" x="0">&lt;c0&gt;</bpt>SnakesAndLadders<ept i="0">&lt;/c0&gt;</ept>ゲーム・クラスは、拡張されることで、<bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept>プロトコルを採用して準拠することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, the green component is obtained by performing a bitwise AND between the numbers <bpt i="0" x="0">&lt;c0&gt;</bpt>0xCC6699<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>0x00FF00<ept i="1">&lt;/c1&gt;</ept>, which gives an output value of <bpt i="2" x="2">&lt;c2&gt;</bpt>0x006600<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、緑の構成要素は数<bpt i="0" x="0">&lt;c0&gt;</bpt>0xCC6699<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>0x00FF00<ept i="1">&lt;/c1&gt;</ept>との間のビット単位の論理積を実行することによって得られます、それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>0x006600<ept i="2">&lt;/c2&gt;</ept>の出力値を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, the second case, <bpt i="9" x="9">&lt;c9&gt;</bpt>case (0, let y)<ept i="9">&lt;/c9&gt;</ept>, matches any point with an <bpt i="10" x="10">&lt;c10&gt;</bpt>x<ept i="10">&lt;/c10&gt;</ept> value of <bpt i="11" x="11">&lt;c11&gt;</bpt>0<ept i="11">&lt;/c11&gt;</ept> and assigns the point’s <bpt i="12" x="12">&lt;c12&gt;</bpt>y<ept i="12">&lt;/c12&gt;</ept> value to the temporary constant <bpt i="13" x="13">&lt;c13&gt;</bpt>y<ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、第二のケース節、<bpt i="9" x="9">&lt;c9&gt;</bpt>case (0, let y)<ept i="9">&lt;/c9&gt;</ept>は、<bpt i="11" x="11">&lt;c11&gt;</bpt>0<ept i="11">&lt;/c11&gt;</ept>の<bpt i="10" x="10">&lt;c10&gt;</bpt>x<ept i="10">&lt;/c10&gt;</ept>値をもつどんなポイントにでも適合して、そのポイントの<bpt i="12" x="12">&lt;c12&gt;</bpt>y<ept i="12">&lt;/c12&gt;</ept>値を一時的な定数<bpt i="13" x="13">&lt;c13&gt;</bpt>y<ept i="13">&lt;/c13&gt;</ept>に代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, the ternary conditional operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>a ? b : c<ept i="1">&lt;/c1&gt;</ept>) cannot be overloaded.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように三項条件演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>a ? b : c<ept i="1">&lt;/c1&gt;</ept>)は、オーバーロードされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, there are 3.28084 feet in a meter, and so the <bpt i="2" x="2">&lt;c2&gt;</bpt>ft<ept i="2">&lt;/c2&gt;</ept> computed property divides the underlying <bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept> value by <bpt i="4" x="4">&lt;c4&gt;</bpt>3.28084<ept i="4">&lt;/c4&gt;</ept>, to convert it from feet to meters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、１メートルは3.28084フィートあります、なので<bpt i="2" x="2">&lt;c2&gt;</bpt>ft<ept i="2">&lt;/c2&gt;</ept>計算プロパティは、もとの<bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept>値を<bpt i="4" x="4">&lt;c4&gt;</bpt>3.28084<ept i="4">&lt;/c4&gt;</ept>で割って、それをフィートからメートルに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, type methods on structures and enumerations can access type properties by using the type property’s name without a type name prefix.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、構造体と列挙の型メソッドは、型名前接頭辞なしで型プロパティの名前を使用することによって型プロパティにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>hasSuffix(_:)<ept i="0">&lt;/c0&gt;</ept> method to count the number of scenes that take place in or around Capulet’s mansion and Friar Lawrence’s cell:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、<bpt i="0" x="0">&lt;c0&gt;</bpt>hasSuffix(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを、キャビュレットの邸宅と修道士ローレンスの独居房の中または周囲で起こる場面の数を数えるために使用してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, you can create a dictionary to store values of any specified type, and there are no limitations on what that type can be.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、あなたはどんな指定された型の値たちでも保管する辞書を作成することができます、そしてその型が何であることができるか制限がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, you can omit part of a type when the full type can be inferred from context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、前後関係から完全に型が推論されることができるとき、あなたはある型の一部を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, you can try to set a new value through a subscript with optional chaining:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、あなたはオプショナル連鎖を使う添え字を通して、新しい値の設定を試みることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, you remove an item from the array with the <bpt i="0" x="0">&lt;c0&gt;</bpt>remove(at:)<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じように、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>remove(at:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って配列から項目を取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Simple Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単純な値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Simple statements are the most common and consist of either an expression or a declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単純な文は、もっとも普通のもので、ひとつの式もしくはひとつの宣言から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Single line comments begin with <bpt i="0" x="0">&lt;c0&gt;</bpt>//<ept i="0">&lt;/c0&gt;</ept> and continue until a line feed (U+000A) or carriage return (U+000D).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一行コメントは<bpt i="0" x="0">&lt;c0&gt;</bpt>//<ept i="0">&lt;/c0&gt;</ept>で始まります、そして行送り（U+000A）または復帰（U+000D）まで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Single quote (<bpt i="0" x="0">&lt;c0&gt;</bpt>\'<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一重引用符（<bpt i="0" x="0">&lt;c0&gt;</bpt>\'<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Single statement closures implicitly return the value of their only statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつだけの文のクロージャは、暗黙のうちにそのただ一つの文の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Single-expression closures can implicitly return the result of their single expression by omitting the <bpt i="0" x="0">&lt;c0&gt;</bpt>return<ept i="0">&lt;/c0&gt;</ept> keyword from their declaration, as in this version of the previous example:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単一の式のクロージャは、前の例のこの改作のように、<bpt i="0" x="0">&lt;c0&gt;</bpt>return<ept i="0">&lt;/c0&gt;</ept>キーワードをそれらの宣言から省略することによって、暗黙的にそれのただ一つの式の結果を返すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some declaration attributes accept arguments that specify more information about the attribute and how it applies to a particular declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>若干の宣言属性は、属性に関するより多くの情報とそれが特定の宣言に適用される方法を指定する引数を受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some operations aren’t guaranteed to always complete execution or produce a useful output.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの操作は、常に実行を完了することや役に立つ出力を生成することを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some products are labeled with 1D barcodes in UPC format, which uses the numbers <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある製品はUPC形式の一次元バーコードでラベルをつけられます、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>から<bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept>までの数字を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some squares are then set to have more specific values for the snakes and ladders.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの正方形は、それからヘビとはしごのためのより独特な値を持つように設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some users might want fewer tick marks in their UI.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>幾人かのユーザは、より少ない目盛りを彼らのUIに望むかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Something similar happens when an unsigned integer is allowed to overflow in the negative direction.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号なし整数が負の向きにおいてオーバフローを認められるときに同じようなことが起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sometimes it’s clear from a program’s structure that an optional will <bpt i="0" x="0">&lt;e0&gt;</bpt>always<ept i="0">&lt;/e0&gt;</ept> have a value, after that value is first set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>時々、プログラムの構造から、あるオプショナルが<bpt i="0" x="0">&lt;e0&gt;</bpt>必ず<ept i="0">&lt;/e0&gt;</ept>値を持つことが、その値が最初に設定される結果として、はっきりしていることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sometimes you know a throwing function or method won’t, in fact, throw an error at runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>時にはあなたはあるスロー関数またはメソッドが、実際のところ、実行時にエラーをスローすることがないのを知っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Special Characters in String Literals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列リテラル内の特別な文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Special Kinds of Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特別な種類のメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Special Kinds of Parameters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特別な種類のパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Special characters can be included in string literals of both the single-line and multiline forms using the following escape sequences:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特殊文字は、単一行および複数行形式の両方の文字列リテラルの中に以下のエスケープシーケンスを使って含められます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Specifically, if a failable initializer delegates to an initializer that fails and returns <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>, then the initializer that delegated also fails and implicitly returns <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>具体的には、失敗できるイニシャライザが、ある失敗して<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返すイニシャライザへ委任するならば、その時その委任した側のイニシャライザもまた失敗して暗黙的に<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Specifically, it declares a <bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept> property of type <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>, and an <bpt i="3" x="3">&lt;c3&gt;</bpt>init name<ept i="3">&lt;/c3&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に、それは型<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept>プロパティ、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>init name<ept i="3">&lt;/c3&gt;</ept>イニシャライザを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Specifically, it expresses whether the number is negative, zero, or positive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>具体的には、それはその数が負、ゼロ、または正かを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Specifically, it must ensure that only items of the right type are added to the container, and it must be clear about the type of the items returned by its subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>具体的には、それは正しい型の項目だけがコンテナに加えられることを確実にしなければなりません、そして、それはそれの添え字によって返される項目の型についてはっきりわかっていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Specifically, the property observer chooses a gear that is the new <bpt i="4" x="4">&lt;c4&gt;</bpt>currentSpeed<ept i="4">&lt;/c4&gt;</ept> value divided by <bpt i="5" x="5">&lt;c5&gt;</bpt>10<ept i="5">&lt;/c5&gt;</ept>, rounded down to the nearest integer, plus <bpt i="6" x="6">&lt;c6&gt;</bpt>1<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>具体的には、プロパティオブザーバーは、新しい<bpt i="4" x="4">&lt;c4&gt;</bpt>currentSpeed<ept i="4">&lt;/c4&gt;</ept>値を<bpt i="5" x="5">&lt;c5&gt;</bpt>10<ept i="5">&lt;/c5&gt;</ept>で割って、最も近い整数に丸めて、<bpt i="6" x="6">&lt;c6&gt;</bpt>1<ept i="6">&lt;/c6&gt;</ept>を加えたギアを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Specifically, the result of an optional chaining call is of the same type as the expected return value, but wrapped in an optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>具体的には、オプショナル連鎖の呼び出しの結果は、期待される戻り値と同じ型ですが、オプショナルの中にラップされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Specifying Argument Labels</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数ラベルを指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Specifying Cleanup Actions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クリーンアップ動作の指定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Square 3 contains the bottom of a ladder that moves you up to square 11.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>正方形３は、正方形11まであなたを動かすはしごの底を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Squares with a ladder base have a positive number to move you up the board, whereas squares with a snake head have a negative number to move you back down the board.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>はしごの接地面がある正方形は、あなたを盤の上方に動かすために正の番号を持ちます、一方でヘビの頭のある正方形は、あなたを逆に盤の下に動かすために負の数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Statements</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stopping execution as soon as an invalid state is detected also helps limit the damage caused by that invalid state.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無効な状態が検知されるやいなや実行を停止することはまた、その無効な状態によって起こされる被害を抑えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stored Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stored Properties and Instance Variables</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存プロパティとインスタンス変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stored Properties of Constant Structure Instances</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数構造体インスタンスの保存プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stored Variable Observers and Property Observers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存された変数オブザーバーとプロパティオブザーバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stored Variables and Stored Variable Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存変数と保存変数プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stored and computed properties are usually associated with instances of a particular type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存されるもしくは計算されるプロパティは、通常は特定の型のインスタンスに結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stored properties are constants or variables that are bundled up and stored as part of the class or structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存プロパティは、クラスまたは構造体の一部としてまとめられて保存される定数または変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stored properties are provided only by classes and structures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存プロパティは、クラスと構造体だけで提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stored properties can be either <bpt i="0" x="0">&lt;e0&gt;</bpt>variable stored properties<ept i="0">&lt;/e0&gt;</ept> (introduced by the <bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept> keyword) or <bpt i="2" x="2">&lt;e2&gt;</bpt>constant stored properties<ept i="2">&lt;/e2&gt;</ept> (introduced by the <bpt i="3" x="3">&lt;c3&gt;</bpt>let<ept i="3">&lt;/c3&gt;</ept> keyword).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存プロパティは、<bpt i="0" x="0">&lt;e0&gt;</bpt>変数保存プロパティ<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept>キーワードによって導入される）か<bpt i="2" x="2">&lt;e2&gt;</bpt>定数保存プロパティ<ept i="2">&lt;/e2&gt;</ept>（<bpt i="3" x="3">&lt;c3&gt;</bpt>let<ept i="3">&lt;/c3&gt;</ept>キーワードによって導入される）であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stored properties cannot be left in an indeterminate state.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存プロパティは、不確定な状態のままにされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存プロパティは、あるインスタンスの一部として定数と変数の値を保存します、一方で、計算プロパティは、値を（たくわえておくのではなく）計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stored type properties are lazily initialized on their first access.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存型プロパティは、それらの最初のアクセスにおいて遅延して初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stored type properties can be variables or constants.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存型プロパティは、変数または定数であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Stored variables, like stored properties, provide storage for a value of a certain type and allow that value to be set and retrieved.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存変数は、保存プロパティの様に、保管場所を特定の型のひとつの値のために用意して、その値の設定と取得を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strictly speaking, initializers do not return a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>厳密にいえば、イニシャライザは値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strictly speaking, this version of the <bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:)<ept i="0">&lt;/c0&gt;</ept> function <bpt i="1" x="1">&lt;e1&gt;</bpt>does<ept i="1">&lt;/e1&gt;</ept> still return a value, even though no return value is defined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>厳密に言って、たとえ戻り値が定義されないとしても、このバージョンの<bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:)<ept i="0">&lt;/c0&gt;</ept>関数は、まだ値を<bpt i="1" x="1">&lt;e1&gt;</bpt>返します<ept i="1">&lt;/e1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strictly speaking, you can write a custom class that conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>CounterDataSource<ept i="0">&lt;/c0&gt;</ept> without implementing <bpt i="1" x="1">&lt;e1&gt;</bpt>either<ept i="1">&lt;/e1&gt;</ept> protocol requirement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>厳密に言って、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>CounterDataSource<ept i="0">&lt;/c0&gt;</ept>に準拠する特注のクラスを書くことが<bpt i="1" x="1">&lt;e1&gt;</bpt>両方の<ept i="1">&lt;/e1&gt;</ept>プロトコル要件を満たすことなく可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String Indices</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列インデックス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String Interpolation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列補間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String Literals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String Mutability</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の可変性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String and Character Equality</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列と文字の同等性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String and character comparisons in Swift are not locale-sensitive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列および文字の比較はスウィフトではロケールに影響されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String and character equality is checked with the “equal to” operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>) and the “not equal to” operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>!=<ept i="1">&lt;/c1&gt;</ept>), as described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Comparison Operators<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列と文字の同等性は、「同等」演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>）および「不等」演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>!=<ept i="1">&lt;/c1&gt;</ept>）で調べられます、これは<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>比較演算子<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String literals can include the following special characters:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列リテラルは、以下の特別な文字を含むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String literals can’t contain an unescaped double quote (<bpt i="0" x="0">&lt;c0&gt;</bpt>"<ept i="0">&lt;/c0&gt;</ept>), an unescaped backslash (<bpt i="1" x="1">&lt;c1&gt;</bpt>\<ept i="1">&lt;/c1&gt;</ept>), a carriage return, or a line feed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列リテラルは、エスケープされない二重引用符（<bpt i="0" x="0">&lt;c0&gt;</bpt>"<ept i="0">&lt;/c0&gt;</ept>）、エスケープされないバックスラッシュ（<bpt i="1" x="1">&lt;c1&gt;</bpt>\<ept i="1">&lt;/c1&gt;</ept>）、キャリッジリターン、またはラインフィードを含むことが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>String literals that are concatenated by the <bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept> operator are concatenated at compile time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>演算子によって連結される文字列リテラルは、コンパイル時に連結されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strings Are Value Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列は値型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strings and Characters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列と文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strings, arrays, and dictionaries in Foundation are always assigned and passed around as a reference to an existing instance, rather than as a copy.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Foundationでの文字列、配列、そして辞書は、常にコピーとしてでなく既存のインスタンスへの参照として代入されてあちこちに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strong Reference Cycles Between Class Instances</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスインスタンス間の強い参照循環</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strong Reference Cycles for Closures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャのための強い参照循環</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structure Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structure and enumeration methods that modify <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> or its properties must mark the instance method as <bpt i="2" x="2">&lt;c2&gt;</bpt>mutating<ept i="2">&lt;/c2&gt;</ept>, just like mutating methods from an original implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>またはそのプロパティを修正する構造および列挙メソッドは、ちょうど最初の実施からの可変メソッドのように、そのインスタンスメソッドに<bpt i="2" x="2">&lt;c2&gt;</bpt>mutating<ept i="2">&lt;/c2&gt;</ept>として印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structure declarations are declared using the <bpt i="1" x="1">&lt;c1&gt;</bpt>struct<ept i="1">&lt;/c1&gt;</ept> keyword and have the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体宣言は、キーワード<bpt i="1" x="1">&lt;c1&gt;</bpt>struct<ept i="1">&lt;/c1&gt;</ept>を使って宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structure declarations can’t contain deinitializer or protocol declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造宣言は、デイニシャライザまたはプロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structure types automatically receive a <bpt i="0" x="0">&lt;e0&gt;</bpt>memberwise initializer<ept i="0">&lt;/e0&gt;</ept> if they do not define any of their own custom initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体型は、それが独自のあつらえのイニシャライザを何ら定義しないならば、自動的に<bpt i="0" x="0">&lt;e0&gt;</bpt>メンバー関連イニシャライザ<ept i="0">&lt;/e0&gt;</ept>を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structure types can adopt any number of protocols, but can’t inherit from classes, enumerations, or other structures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体型は、随意の数のプロトコルに準拠することができます、しかしクラス、列挙、または他の構造体から継承することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structure, enumeration, and class types can have any number of initializers, but the rules and associated behavior for class initializers are different.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体、列挙、そしてクラス型は、随意の数のイニシャライザを持つことができます、しかし、クラスイニシャライザのための規則および関連する挙動は異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structures and Enumerations Are Value Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体と列挙は値型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structures and classes both use initializer syntax for new instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体とクラスは両方とも、新しいインスタンスのためにイニシャライザ構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structures and enumerations are <bpt i="0" x="0">&lt;e0&gt;</bpt>value types<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体と列挙は、<bpt i="0" x="0">&lt;e0&gt;</bpt>値型<ept i="0">&lt;/e0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structures and enumerations are value types, not reference types, and are not stored and passed by reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造と列挙は値型であって、参照型ではありません、そして参照によって格納されたり渡されたりしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structures are always copied when they are passed around in your code, and do not use reference counting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体は、それがあなたのコードにおいてあちこち渡されるとき常にコピーされます、したがって参照カウントを使用しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structures are value types; instances of a structure are copied when assigned to variables or constants, or when passed as arguments to a function call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体は、値型です；構造体のインスタンスは、変数や定数に代入される時、または関数呼び出しの引数として渡される時にコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structures support many of the same behaviors as classes, including methods and initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体は、クラスと同じ挙動の多くを、メソッドとイニシャライザも含めてサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structures that implement it must declare the method with the <bpt i="2" x="2">&lt;c2&gt;</bpt>static<ept i="2">&lt;/c2&gt;</ept> declaration modifier instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それを実装する構造体は、その代わりに<bpt i="2" x="2">&lt;c2&gt;</bpt>static<ept i="2">&lt;/c2&gt;</ept>宣言修飾子を使ってメソッドを宣言しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subclasses can modify inherited variable properties during initialization, but can not modify inherited constant properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブクラスは、初期化の間に継承された変数プロパティを修正することできます、しかし継承された定数プロパティを変更することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subclasses can themselves be subclassed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブクラスは、それ自身サブクラスを作られることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subclasses can use a superclass expression in their implementation of members, subscripting, and initializers to make use of the implementation in their superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブクラスは、そのメンバー、添え字、そしてイニシャライザの実装においてスーパークラス式を使うことで、それらのスーバークラス内の実装を活用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subclasses include their superclass name after their class name, separated by a colon.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブクラスたちはそれらのクラス名の後に、コロンで区切られて、それらのスーパークラス名を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subclassing</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブクラスをつくる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscript Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscript Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscript Options</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字オプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscript Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字の構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscript Usage</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字の使用法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscript declarations are declared using the <bpt i="1" x="1">&lt;c1&gt;</bpt>subscript<ept i="1">&lt;/c1&gt;</ept> keyword and have the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字宣言は、キーワード<bpt i="1" x="1">&lt;c1&gt;</bpt>subscript<ept i="1">&lt;/c1&gt;</ept>を使って宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscript declarations can appear only in the context of a class, structure, enumeration, extension, or protocol declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字宣言は、クラス、構造体、列挙、拡張、またはプロトコル宣言の文脈においてだけ、現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscript declarations only declare the minimum getter and setter implementation requirements for types that conform to the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字宣言は、プロトコルに準拠する型のための最小限のゲッターとセッター実装要件を宣言するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripts</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripts are not limited to a single dimension, and you can define subscripts with multiple input parameters to suit your custom type’s needs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字は一つの次元に制限されません、なのであなたは複数の入力パラメータをもつ添え字を定義して、あなたのあつらえの型の必要を満たすことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripts are typically used as a shortcut for accessing the member elements in a collection, list, or sequence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字は、一般的に、コレクション、リスト、またはシーケンスの中のメンバー要素にアクセスするための近道として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripts can also return any type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字は、また、どんな型でも返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripts can be generic, and they can include generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clauses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字は総称体であることができます、そしてそれらは総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripts can take any number of input parameters, and these input parameters can be of any type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字は、任意の数の入力パラメータをとることができます、そしてこれらの入力パラメータはどんな型でもかまいません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripts can use variadic parameters, but they can’t use in-out parameters or provide default parameter values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字は、可変長パラメータを使うことができます、しかしそれはin-outパラメータを使うことや省略時のパラメータ値を提供することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subscripts enable you to query instances of a type by writing one or more values in square brackets after the instance name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字は、あなたにそのインスタンス名の後で角括弧の中に一つ以上の値を書くことによって、ある型のインスタンスに問い合わせることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Substring operations return an instance of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Substring<ept i="0">&lt;/c0&gt;</ept> type, instead of <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字操作が<bpt i="0" x="0">&lt;c0&gt;</bpt>Substring<ept i="0">&lt;/c0&gt;</ept>型のインスタンスを返す、<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Substrings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下位文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Substrings in Swift have most of the same methods as strings, which means you can work with substrings the same way you work with strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでの下位文字列は、文字列とほとんど同じメソッドを持ちます、それはあなたが下位文字列を、文字列を扱うのと同じ方法で扱えることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subtracting <bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept> from this binary number with the overflow operator gives a binary value of <bpt i="4" x="4">&lt;c4&gt;</bpt>01111111<ept i="4">&lt;/c4&gt;</ept>, which toggles the sign bit and gives positive <bpt i="5" x="5">&lt;c5&gt;</bpt>127<ept i="5">&lt;/c5&gt;</ept>, the maximum positive value that an <bpt i="6" x="6">&lt;c6&gt;</bpt>Int8<ept i="6">&lt;/c6&gt;</ept> can hold.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この２進数からオーバフロー演算子を使って<bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>を減ずることは、２進数の<bpt i="4" x="4">&lt;c4&gt;</bpt>01111111<ept i="4">&lt;/c4&gt;</ept>を与えます、それは符号ビットを切り替えて正の<bpt i="5" x="5">&lt;c5&gt;</bpt>127<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>Int8<ept i="6">&lt;/c6&gt;</ept>が持つことができる最大限の正の値、を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subtraction (<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>減算（<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Such properties are known as type properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのようなプロパティは、型プロパティとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Summary of the Grammar</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文法の概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Superclass Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラス式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Superclass deinitializers are always called, even if a subclass does not provide its own deinitializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラスのデイニシャライザは、たとえサブクラスがそれ自身のデイニシャライザを提供しないとしても、常に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Superclass deinitializers are inherited by their subclasses, and the superclass deinitializer is called automatically at the end of a subclass deinitializer implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラスのデイニシャライザは、それらのサブクラスたちによって継承されます、そして、スーパークラスのデイニシャライザはサブクラスのデイニシャライザ実施の終わりに自動的に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Superclass initializers <bpt i="0" x="0">&lt;e0&gt;</bpt>are<ept i="0">&lt;/e0&gt;</ept> inherited in certain circumstances, but only when it is safe and appropriate to do so.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラスのイニシャライザはある特定の状況において継承<bpt i="0" x="0">&lt;e0&gt;</bpt>されます<ept i="0">&lt;/e0&gt;</ept>、しかしそれが安全にそして適切にそうできる時だけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift also handles all memory management involved in disposing of variables when they are no longer needed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはまた、それがもはや必要とされないとき変数を処分することに関わるすべての記憶管理を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift also introduces optional types, which handle the absence of a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはまたオプショナルの型を導入します、それは値の欠如を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift also makes extensive use of variables whose values can’t changed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはまた、値が変更されることができない変数を広範囲に利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift also provides <bpt i="1" x="1">&lt;e1&gt;</bpt>unsafe<ept i="1">&lt;/e1&gt;</ept> unowned references for cases where you need to disable runtime safety checks—for example, for performance reasons.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはまた<bpt i="1" x="1">&lt;e1&gt;</bpt>unsafe<ept i="1">&lt;/e1&gt;</ept>非所有参照を、あなたが実行時安全確認を無効にする必要がある場合のために提供します — 例えば、性能上の理由のために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift also provides a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop that makes it easy to iterate over arrays, dictionaries, ranges, strings, and other sequences.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループを提供します、それは、配列、辞書、範囲、文字列、およびその他のシーケンス（連続したもの）の全体にわたって繰り返し処理するのを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift also provides an unsigned integer type, <bpt i="0" x="0">&lt;c0&gt;</bpt>UInt<ept i="0">&lt;/c0&gt;</ept>, which has the same size as the current platform’s native word size:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはまた、符号なし整数型、<bpt i="0" x="0">&lt;c0&gt;</bpt>UInt<ept i="0">&lt;/c0&gt;</ept>を提供します、そしてそれは、現在のプラットホーム固有のワードサイズと同じ大きさを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift also provides powerful versions of the three primary collection types, <bpt i="5" x="5">&lt;c5&gt;</bpt>Array<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>Set<ept i="6">&lt;/c6&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>Dictionary<ept i="7">&lt;/c7&gt;</ept>, as described in <bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>Collection Types<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはまた、３つの主要なコレクション型、<bpt i="5" x="5">&lt;c5&gt;</bpt>Array<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>Set<ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>Dictionary<ept i="7">&lt;/c7&gt;</ept>の強力なバージョンを提供します、それは<bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>「コレクション型」<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift also provides range operators that aren’t found in C, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>a..&lt;b<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>a...b<ept i="1">&lt;/c1&gt;</ept>, as a shortcut for expressing a range of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはまた、Cでは見られない範囲演算子、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>a..&lt;b<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>a...b<ept i="1">&lt;/c1&gt;</ept>を、値の範囲を表す近道として提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift also provides two <bpt i="0" x="0">&lt;e0&gt;</bpt>identity operators<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>===<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>!==<ept i="2">&lt;/c2&gt;</ept>), which you use to test whether two object references both refer to the same object instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはまた、２つの<bpt i="0" x="0">&lt;e0&gt;</bpt>同一性演算子<ept i="0">&lt;/e0&gt;</ept>を提供します（<bpt i="1" x="1">&lt;c1&gt;</bpt>===<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>!==<ept i="2">&lt;/c2&gt;</ept>）、それはあなたが２つのオブジェクト参照が両方とも同じオブジェクト・インスタンスに言及するかどうかについて調べるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift always chooses <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> (rather than <bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>) when inferring the type of floating-point numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>浮動小数点数の型を推論するとき、スウィフトは常に<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>を選びます（<bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>ではなく）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift automatically deallocates your instances when they are no longer needed, to free up resources.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは自動的に、それらがもはや必要とされない場合はあなたのインスタンスを割り当て解除して、資源を自由に使えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift automatically propagates errors out of their current scope until they’re handled by a <bpt i="0" x="0">&lt;c0&gt;</bpt>catch<ept i="0">&lt;/c0&gt;</ept> clause.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは自動的に、エラーをそれの現在のスコープの外に、それが<bpt i="0" x="0">&lt;c0&gt;</bpt>catch<ept i="0">&lt;/c0&gt;</ept>節によって取り扱われるまで伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure’s arguments by the names <bpt i="0" x="0">&lt;c0&gt;</bpt>$0<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>$1<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>$2<ept i="2">&lt;/c2&gt;</ept>, and so on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは行内クロージャに自動的に短縮形引数名を提供します、そしてそれは、名前<bpt i="0" x="0">&lt;c0&gt;</bpt>$0<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>$1<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>$2<ept i="2">&lt;/c2&gt;</ept>、などにでクロージャの引数の値に言及するために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift can therefore infer that <bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept> is the appropriate type to use as the <bpt i="4" x="4">&lt;c4&gt;</bpt>Item<ept i="4">&lt;/c4&gt;</ept> for this particular container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、したがって<bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept>が、この特定のコンテナのための<bpt i="4" x="4">&lt;c4&gt;</bpt>Item<ept i="4">&lt;/c4&gt;</ept>として使うのに適当な型であると推測することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift classes do not inherit from a universal base class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのクラスたちは、ひとつの共通の基盤クラスから継承はしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift code is compiled and optimized to get the most out of modern hardware.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコードは、モダンなハードウェアを最大限活用するようにコンパイルおよび最適化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift combines powerful type inference and pattern matching with a modern, lightweight syntax, allowing complex ideas to be expressed in a clear and concise manner.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、強力な型インターフェイスおよびパターンマッチングをモダンで、軽量な構文と結び付けて、複雑なアイデアが明瞭で簡潔な流儀で表されるようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift defines a <bpt i="0" x="0">&lt;c0&gt;</bpt>Never<ept i="0">&lt;/c0&gt;</ept> type, which indicates that a function or method doesn’t return to its caller.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは<bpt i="0" x="0">&lt;c0&gt;</bpt>Never<ept i="0">&lt;/c0&gt;</ept>型を定義します、それはある関数またはメソッドがそれの呼び出し側に帰らないことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift defines away large classes of common programming errors by adopting modern programming patterns:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、よくあるプログラミング過失のうちの主要な種類を、以下のモダンなプログラミングパターンを採用することによって遠ざけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift defines numerous precedence groups to go along with the operators provided by the standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、標準ライブラリによって提供される演算子と一緒にやっていくために、多数の優先順位グループを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift defines two kinds of initializers for class types to help ensure all stored properties receive an initial value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、クラス型のために２種類のイニシャライザを定義して、全ての保存プロパティが初期値を受け取ることを確実にするのを手伝います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift enumerations are particularly well suited to modeling a group of related error conditions, with associated values allowing for additional information about the nature of an error to be communicated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト列挙は、関連値がエラーの性質についての追加の情報と通信可能にすることを含め、関係のあるエラー状況のグループを作るのにとりわけ適します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift gives you a warning if you use an optional value where a value of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Any<ept i="1">&lt;/c1&gt;</ept> is expected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、あなたがオプショナル値を型<bpt i="1" x="1">&lt;c1&gt;</bpt>Any<ept i="1">&lt;/c1&gt;</ept>が期待されるところで使うならば警告を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift gives you the freedom to define your own custom infix, prefix, postfix, and assignment operators, with custom precedence and associativity values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、あなたに、特注の優先順位と結合性値で、あなた自身のあつらえの接中辞、接頭辞、接尾辞、そして代入演算子を定義する自由を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift handles all of the memory management of capturing for you.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、キャプチャ（その瞬間の保存）の記憶管理の全てを、あなたのために取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift handles the memory management of instances through <bpt i="0" x="0">&lt;e0&gt;</bpt>automatic reference counting<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;e1&gt;</bpt>ARC<ept i="1">&lt;/e1&gt;</ept>), as described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Automatic Reference Counting<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>自動参照カウント<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されるように、インスタンスのメモリ管理を<bpt i="0" x="0">&lt;e0&gt;</bpt>自動参照カウント<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;e1&gt;</bpt>ARC<ept i="1">&lt;/e1&gt;</ept>）を通して取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift has a basic <bpt i="0" x="0">&lt;e0&gt;</bpt>Boolean<ept i="0">&lt;/e0&gt;</ept> type, called <bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、ひとつの基本的な<bpt i="0" x="0">&lt;e0&gt;</bpt>ブール<ept i="0">&lt;/e0&gt;</ept>型を持ちます、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept>と呼ばれるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift has been years in the making, and it continues to evolve with new features and capabilities.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはその作成に幾年かを費やしています、そしてそれは新しい特徴と能力で発展し続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift has built-in support for checking API availability, which ensures that you don’t accidentally use APIs that are unavailable on a given deployment target.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、API有効性確認のための組み込みのサポートを持ちます、それはあなたが特定の開発対象で有効でないAPIをうっかり使うことがないのを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift has five control transfer statements:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、５つの制御移動文を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift has five control transfer statements: a <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept> statement, a <bpt i="1" x="1">&lt;c1&gt;</bpt>continue<ept i="1">&lt;/c1&gt;</ept> statement, a <bpt i="2" x="2">&lt;c2&gt;</bpt>fallthrough<ept i="2">&lt;/c2&gt;</ept> statement, a <bpt i="3" x="3">&lt;c3&gt;</bpt>return<ept i="3">&lt;/c3&gt;</ept> statement, and a <bpt i="4" x="4">&lt;c4&gt;</bpt>throw<ept i="4">&lt;/c4&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、５つの制御移動文を持ちます：<bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>文、<bpt i="1" x="1">&lt;c1&gt;</bpt>continue<ept i="1">&lt;/c1&gt;</ept>文、<bpt i="2" x="2">&lt;c2&gt;</bpt>fallthrough<ept i="2">&lt;/c2&gt;</ept>文、<bpt i="3" x="3">&lt;c3&gt;</bpt>return<ept i="3">&lt;/c3&gt;</ept>文、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>throw<ept i="4">&lt;/c4&gt;</ept>文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift has three branch statements: an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement, a <bpt i="1" x="1">&lt;c1&gt;</bpt>guard<ept i="1">&lt;/c1&gt;</ept> statement, and a <bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、３つの分岐文を持ちます：<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文、<bpt i="1" x="1">&lt;c1&gt;</bpt>guard<ept i="1">&lt;/c1&gt;</ept>文、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept>文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift has three loop statements: a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> statement, a <bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept> statement, and a <bpt i="3" x="3">&lt;c3&gt;</bpt>repeat<ept i="3">&lt;/c3&gt;</ept>-<bpt i="4" x="4">&lt;c4&gt;</bpt>while<ept i="4">&lt;/c4&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、３つのループ文を持ちます：<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>文、<bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept>文、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>repeat<ept i="3">&lt;/c3&gt;</ept>-<bpt i="4" x="4">&lt;c4&gt;</bpt>while<ept i="4">&lt;/c4&gt;</ept>文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift has two compiler control statements: a conditional compilation block and a line control statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、２つのコンパイラ制御文：条件コンパイルブロックと行制御文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift helps to ensure your overrides are correct by checking that the override definition has a matching superclass definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、あなたの無効化が正しいものであることを、その無効化定義がスーパークラス定義に合致するのを確認することによって確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift includes several <bpt i="0" x="0">&lt;e0&gt;</bpt>range operators<ept i="0">&lt;/e0&gt;</ept>, which are shortcuts for expressing a range of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、いくつかの<bpt i="0" x="0">&lt;e0&gt;</bpt>範囲演算子<ept i="0">&lt;/e0&gt;</ept>を含みます、それらは値の範囲を表す近道です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift is a <bpt i="0" x="0">&lt;e0&gt;</bpt>type-safe<ept i="0">&lt;/e0&gt;</ept> language, which means the language helps you to be clear about the types of values your code can work with.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは<bpt i="0" x="0">&lt;e0&gt;</bpt>型安全<ept i="0">&lt;/e0&gt;</ept>な言語です、それが意味するのは、この言語があなたを助けて、あなたのコードが扱うことができる値の型について明確であるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift is a <bpt i="0" x="0">&lt;e0&gt;</bpt>type-safe<ept i="0">&lt;/e0&gt;</ept> language.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、<bpt i="0" x="0">&lt;e0&gt;</bpt>型安全<ept i="0">&lt;/e0&gt;</ept>な言語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift is a fantastic way to write software, whether it’s for phones, desktops, servers, or anything else that runs code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはソフトウェアを記述する素晴らしい方法です、コードを実行するのが電話、デスクトップ、サーバー、または何か他のものであろうともです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、iOS、macOS、watchOS、そしてtvOSアプリ開発のための新しいプログラミング言語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift is a type-safe language, and doesn’t allow (for example) a variable of type <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept> and a variable of type <bpt i="5" x="5">&lt;c5&gt;</bpt>Double<ept i="5">&lt;/c5&gt;</ept> to swap values with each other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは型安全な言語です、それで（例えば）型<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>の変数と型<bpt i="5" x="5">&lt;c5&gt;</bpt>Double<ept i="5">&lt;/c5&gt;</ept>の変数にお互いに値を交換させることをしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift is friendly to new programmers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、新規プログラマーに好意的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift makes it easy to provide tailored implementations of these operators and to determine exactly what their behavior should be for each type you create.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、それら演算子の注文仕立ての実装を提供することについて、そしてそれらの挙動があなたがつくる各型のために正確にどういったものでなければならないかについて決定することを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift manages all value copying to ensure optimal performance, and you should not avoid assignment to try to preempt this optimization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、全ての値のコピーを管理して最適のパフォーマンスを保証します、そしてあなたは代入を避けてこの最適化を先取りしようとしてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift now has a <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Nil-Coalescing Operator<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> (<bpt i="2" x="2">&lt;c2&gt;</bpt>a ?? b<ept i="2">&lt;/c2&gt;</ept>), which unwraps an optional’s value if it exists, or returns a default value if the optional is <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは今や<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>nil合体演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>（<bpt i="2" x="2">&lt;c2&gt;</bpt>a ?? b<ept i="2">&lt;/c2&gt;</ept>）をもちます、それはあるオプショナルの値を、もしそれが存在するならばアンラップします、またはそのオプショナルが<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>ならばある省略時の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift now has a native <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept> collection type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは今では持って生まれた<bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>コレクション型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift now includes the <bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>as!<ept i="1">&lt;/c1&gt;</ept> failable downcast operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは今では失敗できるダウンキャスト演算子<bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>as!<ept i="1">&lt;/c1&gt;</ept>を含めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides a <bpt i="0" x="0">&lt;e0&gt;</bpt>default initializer<ept i="0">&lt;/e0&gt;</ept> for any structure or class that provides default values for all of its properties and does not provide at least one initializer itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、それのもつプロパティの全てに省略時の値を与えて、ともかく１つのイニシャライザもそれ自身では提供しないあらゆる構造体またはクラスのために、<bpt i="0" x="0">&lt;e0&gt;</bpt>省略時のイニシャライザ<ept i="0">&lt;/e0&gt;</ept>を用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides a variety of control flow statements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、さまざまな制御の流れ文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides an additional integer type, <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>, which has the same size as the current platform’s native word size:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは追加の整数型、<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>を提供します、そしてそれは、現在のプラットホーム固有のワードサイズと同じ大きさを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides an elegant solution to this problem, known as a <bpt i="0" x="0">&lt;e0&gt;</bpt>closure capture list<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはこの問題の洗練された解答、<bpt i="0" x="0">&lt;e0&gt;</bpt>クロージャ捕獲リスト<ept i="0">&lt;/e0&gt;</ept>として知られるものを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、回復可能なエラーのスロー、キャッチ、伝達、そして取り扱いに対してファーストクラスのサポートを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides five different <bpt i="0" x="0">&lt;e0&gt;</bpt>access levels<ept i="0">&lt;/e0&gt;</ept> for entities within your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、５つの異なる<bpt i="0" x="0">&lt;e0&gt;</bpt>アクセス水準<ept i="0">&lt;/e0&gt;</ept>をあなたのコード内の実在に対して用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides five levels of access control: open, public, internal, file private, and private.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、５つの水準のアクセス制御を提供します：公開、内部、そして非公開。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides its own versions of all fundamental C and Objective-C types, including <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> for integers, <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Float<ept i="2">&lt;/c2&gt;</ept> for floating-point values, <bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept> for Boolean values, and <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept> for textual data.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、全ての基本的なCおよびObjective-C型に関してそれ自身のバージョンを提供します、それには、整数のための<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>、浮動小数点値のための<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>Float<ept i="2">&lt;/c2&gt;</ept>、ブール値のための<bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept>、そして、文字情報データのための<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides several different ways to access Unicode representations of strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、文字列のUnicode表現にアクセスするためにいくつかの異なる方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides signed and unsigned integers in 8, 16, 32, and 64 bit forms.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、８、16、32、そして64ビット形式で、符号つきおよび符号なし整数を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides the following Interface Builder attributes: <bpt i="0" x="0">&lt;c0&gt;</bpt>IBAction<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>IBOutlet<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>IBDesignable<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>IBInspectable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、以下のインターフェイスビルダー属性を提供します：<bpt i="0" x="0">&lt;c0&gt;</bpt>IBAction<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>IBOutlet<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>IBDesignable<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>IBInspectable<ept i="3">&lt;/c3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides three arithmetic <bpt i="0" x="0">&lt;e0&gt;</bpt>overflow operators<ept i="0">&lt;/e0&gt;</ept> that opt in to the overflow behavior for integer calculations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、整数計算のためにオーバフロー挙動を選択する３つの<bpt i="0" x="0">&lt;e0&gt;</bpt>算術オーバフロー演算子<ept i="0">&lt;/e0&gt;</ept>を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides three primary <bpt i="0" x="0">&lt;e0&gt;</bpt>collection types<ept i="0">&lt;/e0&gt;</ept>, known as arrays, sets, and dictionaries, for storing collections of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは３つの主要な<bpt i="0" x="0">&lt;e0&gt;</bpt>コレクション型<ept i="0">&lt;/e0&gt;</ept>を提供します、それらは配列、集合、そして辞書として知られ、値の集まり（コレクション）をしまっておくためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides three ways to compare textual values: string and character equality, prefix equality, and suffix equality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、テキスト関連の値を比較する３つの方法を提供します：文字列および文字の等式、接頭辞等式、そして接尾辞等式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides two Boolean constant values, <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは２つのブールの定数値、<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides two kinds of <bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept> loops:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは２種類の<bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept>ループを提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides two signed floating-point number types:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、２つの符号つき浮動小数点数型を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides two special types for working with nonspecific types:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、２つの特別な型を「不特定」の型を扱うために提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides two ways to add conditional branches to your code: the <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement and the <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは条件分岐をあなたのコードに加える２つの方法：<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文と<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides two ways to resolve strong reference cycles when you work with properties of class type: weak references and unowned references.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがクラス型のプロパティを扱うとき、スウィフトは強い参照循環を解消する２つの道を提供します：弱い参照と非所有者参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift reports an error at compile time if you try to use an API that isn’t available.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、あなたが有効でないAPIを使おうと試みるならば、コンパイル時にエラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift requires you to write <bpt i="0" x="0">&lt;c0&gt;</bpt>self.someProperty<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>self.someMethod()<ept i="1">&lt;/c1&gt;</ept> (rather than just <bpt i="2" x="2">&lt;c2&gt;</bpt>someProperty<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>someMethod()<ept i="3">&lt;/c3&gt;</ept>) whenever you refer to a member of <bpt i="4" x="4">&lt;c4&gt;</bpt>self<ept i="4">&lt;/c4&gt;</ept> within a closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはあなたに<bpt i="0" x="0">&lt;c0&gt;</bpt>self.someProperty<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>self.someMethod()<ept i="1">&lt;/c1&gt;</ept>（ただ単に<bpt i="2" x="2">&lt;c2&gt;</bpt>someProperty<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>someMethod()<ept i="3">&lt;/c3&gt;</ept>ではなく）を書くことを、あなたがクロージャ内で<bpt i="4" x="4">&lt;c4&gt;</bpt>self<ept i="4">&lt;/c4&gt;</ept>のメンバーに言及するときはいつでも、要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift strings are represented by the <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの文字列は<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>型によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift supports all of the bitwise operators found in C, as described below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、下記のように、Cで見つけられるビット単位演算子の全てをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift supports all standard C <bpt i="0" x="0">&lt;e0&gt;</bpt>comparison operators<ept i="0">&lt;/e0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、標準的なC <bpt i="0" x="0">&lt;e0&gt;</bpt>比較演算子<ept i="0">&lt;/e0&gt;</ept>の全てをサポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift supports most standard C operators and improves several capabilities to eliminate common coding errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、ほとんどの標準のC演算子をサポートして、一般的なコード記述エラーを排除するためにいくつかの能力を向上させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift supports the four standard <bpt i="0" x="0">&lt;e0&gt;</bpt>arithmetic operators<ept i="0">&lt;/e0&gt;</ept> for all number types:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、４つの標準の<bpt i="0" x="0">&lt;e0&gt;</bpt>算術演算子<ept i="0">&lt;/e0&gt;</ept>を数の型すべてに対してサポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift supports the three standard logical operators found in C-based languages:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、Cに基づく言語で見られる３つの標準の論理演算子をサポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift unifies these concepts into a single property declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、これらの概念をだだ１つのプロパティ宣言に統一します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift uses <bpt i="0" x="0">&lt;e0&gt;</bpt>Automatic Reference Counting<ept i="0">&lt;/e0&gt;</ept> (ARC) to track and manage your app’s memory usage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、あなたのアプリのメモリ使用を追跡して管理するために、<bpt i="0" x="0">&lt;e0&gt;</bpt>自動参照カウント（ARC）<ept i="0">&lt;/e0&gt;</ept>を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift uses <bpt i="0" x="0">&lt;e0&gt;</bpt>capture lists<ept i="0">&lt;/e0&gt;</ept> to break these strong reference cycles.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、これらの強い参照循環を壊すために<bpt i="0" x="0">&lt;e0&gt;</bpt>捕獲リスト<ept i="0">&lt;/e0&gt;</ept>を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift uses <bpt i="0" x="0">&lt;e0&gt;</bpt>string interpolation<ept i="0">&lt;/e0&gt;</ept> to include the name of a constant or variable as a placeholder in a longer string, and to prompt Swift to replace it with the current value of that constant or variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、定数または変数の名前をより長い文字列の中にプレースホルダーとして含めるために、そしてそれをその定数または変数の現在の値と取り替えることをスウィフトに促すために、<bpt i="0" x="0">&lt;e0&gt;</bpt>文字列補間<ept i="0">&lt;/e0&gt;</ept>を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift uses type inference extensively, allowing you to omit the type or part of the type of many variables and expressions in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは広く型推論を使います、そして、あなたのコードにおいて型、または多くの変数および式の型の一部を省略できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> type already provides an <bpt i="1" x="1">&lt;c1&gt;</bpt>append(_:)<ept i="1">&lt;/c1&gt;</ept> method, a <bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept> property, and a subscript with an <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> index to retrieve its elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>型は、すでに<bpt i="1" x="1">&lt;c1&gt;</bpt>append(_:)<ept i="1">&lt;/c1&gt;</ept>メソッド、<bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept>プロパティ、そしてその要素を取り出すために<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>インデックスを使う添え字を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> type also provides an initializer for creating an array of a certain size with all of its values set to the same default value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>型はまた、その値の全てが提供された同じ初期値に設定される、特定の大きさの配列をつくるためにイニシャライザを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> type is bridged to Foundation’s <bpt i="1" x="1">&lt;c1&gt;</bpt>NSArray<ept i="1">&lt;/c1&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>型はFoundationの<bpt i="1" x="1">&lt;c1&gt;</bpt>NSArray<ept i="1">&lt;/c1&gt;</ept>クラスにブリッジ（橋渡し）されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> type now has full value semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>型は現在は完全な値意味論を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> type does not have a defined ordering.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>型は、決まった順序を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> type implements its key-value subscripting as a subscript that takes and returns an <bpt i="1" x="1">&lt;e1&gt;</bpt>optional<ept i="1">&lt;/e1&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>型は、それの「キーと値」に関する添え字を、<bpt i="1" x="1">&lt;e1&gt;</bpt>オプショナル<ept i="1">&lt;/e1&gt;</ept>型を受け取り返す添え字として実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> type is bridged to Foundation’s <bpt i="1" x="1">&lt;c1&gt;</bpt>NSDictionary<ept i="1">&lt;/c1&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>型は、Foundationの<bpt i="1" x="1">&lt;c1&gt;</bpt>NSDictionary<ept i="1">&lt;/c1&gt;</ept>クラスにブリッジ（橋渡し）します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> type has an initializer which tries to convert a <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> value into an <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>型はあるイニシャライザを持ちます、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値を<bpt i="2" x="2">&lt;c2&gt;</bpt>Int値<ept i="2">&lt;/c2&gt;</ept>に変換することを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept> type does not have a defined ordering.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>型は、決まった順番を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept> type is bridged to Foundation’s <bpt i="1" x="1">&lt;c1&gt;</bpt>NSSet<ept i="1">&lt;/c1&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>型は、Foundationの<bpt i="1" x="1">&lt;c1&gt;</bpt>NSSet<ept i="1">&lt;/c1&gt;</ept>クラスにブリッジ（橋渡し）されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept> types provide a fast, Unicode-compliant way to work with text in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept>型は、あなたのコードにおいてテキストを処理するために、ある高速な、Unicodeに対応したやり方を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> type is a <bpt i="1" x="1">&lt;e1&gt;</bpt>value type<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>型は、<bpt i="1" x="1">&lt;e1&gt;</bpt>値型<ept i="1">&lt;/e1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> type is bridged with Foundation’s <bpt i="1" x="1">&lt;c1&gt;</bpt>NSString<ept i="1">&lt;/c1&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Foundation<ept i="1">&lt;/c1&gt;</ept>のNSStringクラスを使って橋渡しをされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> is’nt the same as <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>は、Objective-Cでの<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>と同じものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement is considerably more powerful than its counterpart in many C-like languages.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文は、多くのCに似た言語において相当する物よりずっと強力です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept> types are fully Unicode-compliant, as described in this section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept>型は、この節で記述されるように、完全にUnicodeに対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> type defines its string-specific implementation of the greater-than operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;<ept i="2">&lt;/c2&gt;</ept>) as a method that has two parameters of type <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>, and returns a value of type <bpt i="4" x="4">&lt;c4&gt;</bpt>Bool<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>型は、それの文字列特有の実装の「大なり」演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;<ept i="2">&lt;/c2&gt;</ept>）をメソッドとして定義します、それは型<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>の２つのパラメータを持ち、型<bpt i="4" x="4">&lt;c4&gt;</bpt>Bool<ept i="4">&lt;/c4&gt;</ept>の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s access control model is based on the concept of modules and source files.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのアクセス制御モデルは、モジュールとソースファイルの概念に基づきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s approach prevents a situation in which a simple initializer from a superclass is inherited by a more specialized subclass and is used to create a new instance of the subclass that is not fully or correctly initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの取り組み方は、スーパークラスのもつ単純なイニシャライザがより特殊化されたサブクラスによって継承されて、充分にまたは正しく初期化されない状態の、サブクラスの新しいインスタンスをつくるのに使われる状況を防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s array, set, and dictionary types are implemented as <bpt i="0" x="0">&lt;e0&gt;</bpt>generic collections<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの配列、集合、そして辞書型は、<bpt i="0" x="0">&lt;e0&gt;</bpt>総称体のコレクション<ept i="0">&lt;/e0&gt;</ept>として実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s closure expressions have a clean, clear style, with optimizations that encourage brief, clutter-free syntax in common scenarios.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのクロージャ式は、最適化された、きれいな、明白なスタイルを持ちます、それは、通常さまざまに予想される状況において、簡潔な、混乱のない構文を助長します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s compiler performs four helpful safety-checks to make sure that two-phase initialization is completed without error:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのコンパイラは、２段階初期化がエラーなしで完了されることを確認するために４つの役に立つ安全点検を実行します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s copy-by-default <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> behavior ensures that when a function or method passes you a <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> value, it’s clear that you own that exact <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> value, regardless of where it came from.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの省略時コピーの<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>挙動は、関数またはメソッドがあなたに<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値を渡すとき、それが来たところに関係なく、あなたがその正確な写しの<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>値を所有することが明白なのを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s initialization flow is more flexible in that it lets you set custom initial values, and can cope with types for which <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> is not a valid default value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それがあなたに好みに合わせた初期値を設定させて、<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>が有効な省略時の値でない型に対処することができるという点で、スウィフトの初期化の流れはより柔軟です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s native <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> type no longer has an <bpt i="1" x="1">&lt;c1&gt;</bpt>uppercaseString<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>lowercaseString<ept i="2">&lt;/c2&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの生粋の<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>型はもはや<bpt i="1" x="1">&lt;c1&gt;</bpt>uppercaseString<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>lowercaseString<ept i="2">&lt;/c2&gt;</ept>プロパティを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s operator precedences and associativity rules are simpler and more predictable than those found in C and Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの演算子優先順位と結合性規則は、CとObjective-Cで見つけられるそれらより単純でより予測できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s optionals let you indicate the absence of a value for <bpt i="3" x="3">&lt;e3&gt;</bpt>any type at all<ept i="3">&lt;/e3&gt;</ept>, without the need for special constants.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのオプショナルは、あなたに特別な定数の必要なしに<bpt i="3" x="3">&lt;e3&gt;</bpt>あらゆる全ての型<ept i="3">&lt;/e3&gt;</ept>の値の欠如を示させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s standard library provides a method called <bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept>, which sorts an array of values of a known type, based on the output of a sorting closure that you provide.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの標準ライブラリは<bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept>と呼ばれるメソッドを提供します、それは、ある既知の型の値からなる配列の分類を、あなたが提供するあるソート（分類）を行うクロージャの出力に基づき行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s two-phase initialization process is similar to initialization in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの２段階初期化プロセスは、Objective-Cでの初期化に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s type checker is able to deduce that <bpt i="4" x="4">&lt;c4&gt;</bpt>Movie<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>Song<ept i="5">&lt;/c5&gt;</ept> have a common superclass of <bpt i="6" x="6">&lt;c6&gt;</bpt>MediaItem<ept i="6">&lt;/c6&gt;</ept>, and so it infers a type of <bpt i="7" x="7">&lt;c7&gt;</bpt>[MediaItem]<ept i="7">&lt;/c7&gt;</ept> for the <bpt i="8" x="8">&lt;c8&gt;</bpt>library<ept i="8">&lt;/c8&gt;</ept> array:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの型チェッカーは<bpt i="4" x="4">&lt;c4&gt;</bpt>Movie<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>Song<ept i="5">&lt;/c5&gt;</ept>が共通のスーパークラス<bpt i="6" x="6">&lt;c6&gt;</bpt>MediaItem<ept i="6">&lt;/c6&gt;</ept>を持つと推論することができます、なのでそれは<bpt i="8" x="8">&lt;c8&gt;</bpt>library<ept i="8">&lt;/c8&gt;</ept>配列に対して<bpt i="7" x="7">&lt;c7&gt;</bpt>[MediaItem]<ept i="7">&lt;/c7&gt;</ept>型を推論します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s type safety prevents non-Boolean values from being substituted for <bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの型安全は、非ブール値が<bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept>の代用にされるのを妨げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s unified function syntax is flexible enough to express anything from a simple C-style function with no parameter names to a complex Objective-C-style method with names and argument labels for each parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの統合された関数構文は、十分な柔軟性があり、パラメータ名を持たない単純なCスタイルの関数から、各パラメータに対して名前および引数ラベルをもつ複雑なObjective-Cスタイルのメソッドまで、何でも表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Switch</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スイッチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Switch Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スイッチ文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Switch Statements Must Be Exhaustive</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スイッチ文は徹底的でなければなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Switches support any kind of data and a wide variety of comparison operations—they aren’t limited to integers and tests for equality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スイッチ（条件分岐）は、あらゆる種類のデータおよび多種多様な比較操作をサポートします ― それは、整数および同等性に対する検査に限られていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Syntactic categories are indicated by <bpt i="0" x="0">&lt;e0&gt;</bpt>italic<ept i="0">&lt;/e0&gt;</ept> text and appear on both sides of a grammar production rule.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>統語論のカテゴリーは、<bpt i="0" x="0">&lt;e0&gt;</bpt>イタリック<ept i="0">&lt;/e0&gt;</ept>のテキストによって示されて、文法導出規則の両側に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Syntactically, a variadic parameter consists of a base type name followed immediately by three dots (<bpt i="1" x="1">&lt;c1&gt;</bpt>...<ept i="1">&lt;/c1&gt;</ept>), as in <bpt i="2" x="2">&lt;c2&gt;</bpt>Int...<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>統語的には、可変長パラメータは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Int...<ept i="2">&lt;/c2&gt;</ept>のように、基となる型名に直ちに３つの点（<bpt i="1" x="1">&lt;c1&gt;</bpt>...<ept i="1">&lt;/c1&gt;</ept>）が続くものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Syntactically, every primary expression is also a postfix expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>統語論的に、あらゆる基本式は、また、接尾辞式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Syntax for Designated and Convenience Initializers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定および便宜イニシャライザのための構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Taken together, these constraints mean that the value passed for the <bpt i="0" x="0">&lt;c0&gt;</bpt>indices<ept i="0">&lt;/c0&gt;</ept> parameter is a sequence of integers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総合すると、これらの制約が意味するのは、<bpt i="0" x="0">&lt;c0&gt;</bpt>indices<ept i="0">&lt;/c0&gt;</ept>パラメータに対して渡される値は整数からなるシーケンスであるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Terminology</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>用語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Ternary Conditional Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>三項条件演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tests can also access classes and class members that are marked with the <bpt i="3" x="3">&lt;c3&gt;</bpt>internal<ept i="3">&lt;/c3&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt>public<ept i="4">&lt;/c4&gt;</ept> access-level modifier as if they were declared with the <bpt i="5" x="5">&lt;c5&gt;</bpt>open<ept i="5">&lt;/c5&gt;</ept> access-level modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのテストはまた、<bpt i="3" x="3">&lt;c3&gt;</bpt>internal<ept i="3">&lt;/c3&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt>public<ept i="4">&lt;/c4&gt;</ept>アクセス水準修飾子で印を付けられるクラスおよびクラスメソッドにアクセスできます、まるでそれらが<bpt i="5" x="5">&lt;c5&gt;</bpt>open<ept i="5">&lt;/c5&gt;</ept>アクセス水準修飾子で宣言されたかのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Thanks to Swift’s type inference, you don’t actually need to declare a concrete <bpt i="0" x="0">&lt;c0&gt;</bpt>Item<ept i="0">&lt;/c0&gt;</ept> of <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> as part of the definition of <bpt i="2" x="2">&lt;c2&gt;</bpt>IntStack<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの型推論のおかげで、あなたは実際には<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>である具体的な<bpt i="0" x="0">&lt;c0&gt;</bpt>Item<ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>IntStack<ept i="2">&lt;/c2&gt;</ept>の定義の一部として宣言する必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Thanks to Swift’s type inference, you don’t have to write the type of the array if you’re initializing it with an array literal containing values of the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの型推論のおかげで、あなたが同じ型の値を含んでいる配列リテラルでそれを初期化しているのならば、あなたは配列の型を書く必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That branch must transfer control to exit the code block in which the <bpt i="1" x="1">&lt;c1&gt;</bpt>guard<ept i="1">&lt;/c1&gt;</ept> statement appears.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その分岐は、制御を移して、<bpt i="1" x="1">&lt;c1&gt;</bpt>guard<ept i="1">&lt;/c1&gt;</ept>文が現れているコードブロックを脱出する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That function’s caller can then <bpt i="1" x="1">&lt;e1&gt;</bpt>catch<ept i="1">&lt;/e1&gt;</ept> the error and respond appropriately.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その関数の呼び出し側はそのときそのエラーを<bpt i="1" x="1">&lt;e1&gt;</bpt>キャッチして<ept i="1">&lt;/e1&gt;</ept>（捕まえて）適切に応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, an implementation of <bpt i="5" x="5">&lt;c5&gt;</bpt>==<ept i="5">&lt;/c5&gt;</ept> must satisfy the following three conditions, for all values <bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>b<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>c<ept i="8">&lt;/c8&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="5" x="5">&lt;c5&gt;</bpt>==<ept i="5">&lt;/c5&gt;</ept>の実装は、以下の３つの条件を<bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>b<ept i="7">&lt;/c7&gt;</ept>、および<bpt i="8" x="8">&lt;c8&gt;</bpt>c<ept i="8">&lt;/c8&gt;</ept>すべての値に対して満足させなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, every possible value of the type being considered must be matched by one of the <bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept> cases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、考察されている型のすべてのあり得る値が、<bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept>ケース節のうちの１つと適合しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, it must provide a way to make itself uniquely representable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、それはそれ自身を特有に表わすことを可能にする方法を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, the code in the first <bpt i="4" x="4">&lt;c4&gt;</bpt>defer<ept i="4">&lt;/c4&gt;</ept> statement executes last, the code in the second <bpt i="5" x="5">&lt;c5&gt;</bpt>defer<ept i="5">&lt;/c5&gt;</ept> statement executes second to last, and so on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、最初の<bpt i="4" x="4">&lt;c4&gt;</bpt>defer<ept i="4">&lt;/c4&gt;</ept>文のコードが最後に実行され、２番目の<bpt i="5" x="5">&lt;c5&gt;</bpt>defer<ept i="5">&lt;/c5&gt;</ept>文のコードが最後から２番目に実行され、等々。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, the entire <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement completes its execution as soon as the first matching case is completed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、最初の適合するケース節が完了されるとすぐに、<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文の全体がその実行を完了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, the type must conform to one of the following Swift standard library protocols: <bpt i="0" x="0">&lt;c0&gt;</bpt>ExpressibleByIntegerLiteral<ept i="0">&lt;/c0&gt;</ept> for integer literals, <bpt i="1" x="1">&lt;c1&gt;</bpt>ExpressibleByFloatLiteral<ept i="1">&lt;/c1&gt;</ept> for floating-point literals, <bpt i="2" x="2">&lt;c2&gt;</bpt>ExpressibleByStringLiteral<ept i="2">&lt;/c2&gt;</ept> for string literals, <bpt i="3" x="3">&lt;c3&gt;</bpt>ExpressibleByBooleanLiteral<ept i="3">&lt;/c3&gt;</ept> for Boolean literals, <bpt i="4" x="4">&lt;c4&gt;</bpt>ExpressibleByUnicodeScalarLiteral<ept i="4">&lt;/c4&gt;</ept> for string literals that contain only a single Unicode scalar, and <bpt i="5" x="5">&lt;c5&gt;</bpt>ExpressibleByExtendedGraphemeClusterLiteral<ept i="5">&lt;/c5&gt;</ept> for string literals that contain only a single extended grapheme cluster.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、その型は以下のスウィフト標準ライブラリのプロトコルの１つに準拠しなければなりません：整数リテラルに対して<bpt i="0" x="0">&lt;c0&gt;</bpt>ExpressibleByIntegerLiteral<ept i="0">&lt;/c0&gt;</ept>、浮動小数点リテラルに対して<bpt i="1" x="1">&lt;c1&gt;</bpt>ExpressibleByFloatLiteral<ept i="1">&lt;/c1&gt;</ept>、文字列リテラルに対して<bpt i="2" x="2">&lt;c2&gt;</bpt>ExpressibleByStringLiteral<ept i="2">&lt;/c2&gt;</ept>、ブールのリテラルに対して<bpt i="3" x="3">&lt;c3&gt;</bpt>ExpressibleByBooleanLiteral<ept i="3">&lt;/c3&gt;</ept>、ただ１つのユニコードスカラーだけを含む文字列リテラルに対して<bpt i="4" x="4">&lt;c4&gt;</bpt>ExpressibleByUnicodeScalarLiteral<ept i="4">&lt;/c4&gt;</ept>、そしてただ１つの拡張書記素クラスタだけを含む文字列リテラルに対して<bpt i="5" x="5">&lt;c5&gt;</bpt>ExpressibleByExtendedGraphemeClusterLiteral<ept i="5">&lt;/c5&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That is, the type of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> in <bpt i="1" x="1">&lt;c1&gt;</bpt>var x: Int = 0<ept i="1">&lt;/c1&gt;</ept> is inferred by first checking the type of <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept> and then passing this type information up to the root (the variable <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すなわち、<bpt i="1" x="1">&lt;c1&gt;</bpt>var x: Int = 0<ept i="1">&lt;/c1&gt;</ept>の中の<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>の型は、最初に<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>の型を調べて、それからこの型情報を根（変数<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>）までさかのぼって渡すことによって推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, a nonthrowing method can override a throwing method, and a nonthrowing method can satisfy a protocol requirement for a throwing method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言え、非スローメソッドはスローメソッドをオーバーライドできます、そして非スローメソッドはスローメソッドのプロトコル要件を満たすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, a rethrowing method can override a throwing method, and a rethrowing method can satisfy a protocol requirement for a throwing method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言え、再スローメソッドはスローメソッドをオーバーライドできます、そして再スローメソッドはスローメソッド用のプロトコル要件を満たすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, because protocols don’t implement their members, most protocol members are declarations only.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言え、プロトコルがそれらのメンバーを実装しないので、大部分のプロトコル・メンバーは宣言だけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, if a constant is initialized with a class object, the object itself can change, but the binding between the constant name and the object it refers to can’t.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうは言っても、定数がクラスオブジェクトで初期化されるならば、そのオブジェクト自体は変わることができます、しかし、定数名とそれが言及するオブジェクトの間の束縛はそうすることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, if a subclass initializes all of its stored properties with default values and doesn’t define any initializers of its own, it inherits all of the superclass’s initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言え、サブクラスがそれの保存プロパティのすべてを省略時の値で初期化して、それ自身のイニシャライザを全く定義しないならば、それはそのスーパークラスのイニシャライザのすべてを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, if no initializer <bpt i="2" x="2">&lt;e2&gt;</bpt>expression<ept i="2">&lt;/e2&gt;</ept> is present, the variable declaration must include an explicit type annotation (<bpt i="3" x="3">&lt;c3&gt;</bpt>:<ept i="3">&lt;/c3&gt;</ept> <bpt i="4" x="4">&lt;e4&gt;</bpt>type<ept i="4">&lt;/e4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言え、イニシャライザ<bpt i="2" x="2">&lt;e2&gt;</bpt>式<ept i="2">&lt;/e2&gt;</ept>が存在しないならば、変数の宣言は明確な型注釈（<bpt i="3" x="3">&lt;c3&gt;</bpt>:<ept i="3">&lt;/c3&gt;</ept> <bpt i="4" x="4">&lt;e4&gt;</bpt>type<ept i="4">&lt;/e4&gt;</ept>）を含まなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, if the type you’re extending is defined in another module, an initializer declaration must delegate to an initializer already defined in that module to ensure members of that type are properly initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言え、 あなたが拡張している型が別のモジュールにおいて定義されるならば、イニシャライザ宣言はそのモジュールですでに定義されるイニシャライザに委任して、その型のメンバーが正しく初期化されることを確実にしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, if you assign a value to a variable or property within its own <bpt i="6" x="6">&lt;c6&gt;</bpt>didSet<ept i="6">&lt;/c6&gt;</ept> observer clause, that new value that you assign will replace the one that was just set and passed to the <bpt i="7" x="7">&lt;c7&gt;</bpt>willSet<ept i="7">&lt;/c7&gt;</ept> observer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言え、あなたが<bpt i="6" x="6">&lt;c6&gt;</bpt>didSet<ept i="6">&lt;/c6&gt;</ept>オブザーバー節自身の内部である値を変数またはプロパティに代入するならば、あなたが代入するその新しい値は、ちょうど設定されたばかりの<bpt i="7" x="7">&lt;c7&gt;</bpt>willSet<ept i="7">&lt;/c7&gt;</ept>オブザーバーに渡されたものを置き換えることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, if you provide a setter clause, you must also provide a getter clause.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言え、 あなたがセッター節を提供するならば、あなたはまたゲッター節も提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, if you want execution to continue from one case to the next, explicitly include a <bpt i="1" x="1">&lt;c1&gt;</bpt>fallthrough<ept i="1">&lt;/c1&gt;</ept> statement, which simply consists of the <bpt i="2" x="2">&lt;c2&gt;</bpt>fallthrough<ept i="2">&lt;/c2&gt;</ept> keyword, in the case from which you want execution to continue.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それでもやはり、あなたが実行に１つのケース節から次のものまで続いて欲しいならば、あなたが実行に続いて欲しいケース節で明示的に<bpt i="1" x="1">&lt;c1&gt;</bpt>fallthrough<ept i="1">&lt;/c1&gt;</ept>文を含めてください、それは、単にキーワード<bpt i="2" x="2">&lt;c2&gt;</bpt>fallthrough<ept i="2">&lt;/c2&gt;</ept>から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, it can’t contain any cases that are also marked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>indirect<ept i="2">&lt;/c2&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言うものの、それは<bpt i="2" x="2">&lt;c2&gt;</bpt>indirect<ept i="2">&lt;/c2&gt;</ept>修飾子でさらに印されるどんなケース節も含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, the following features are available only to Swift 4 code:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とはいえ、以下の機能はSwift 4コードでのみ利用可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, the initialization processes must end with a call to a designated initializer that ultimately initializes the class’s properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言え、 初期化プロセスは、最終的にそのクラスのプロパティを初期化する指定イニシャライザに対する呼び出しで終わらなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, you can mark these protocol member declarations with the <bpt i="0" x="0">&lt;c0&gt;</bpt>optional<ept i="0">&lt;/c0&gt;</ept> declaration modifier to specify that their implementation by a conforming type is optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言え、 あなたはこれらのプロトコルメンバー宣言を<bpt i="0" x="0">&lt;c0&gt;</bpt>optional<ept i="0">&lt;/c0&gt;</ept>宣言修飾子を使って印して、ある準拠型にとってそれらの実装が随意であると指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, you can overload a function based on whether a function <bpt i="0" x="0">&lt;e0&gt;</bpt>parameter<ept i="0">&lt;/e0&gt;</ept> can throw an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言え、あなたは関数を、ある関数<bpt i="0" x="0">&lt;e0&gt;</bpt>パラメーター<ept i="0">&lt;/e0&gt;</ept>がエラーをスローできるかどうかに基づいてオーバーロードすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That said, you can use parentheses to be explicit about the scope of the operator’s application.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言うものの、あなたは丸括弧を使って演算子の適用範囲について明確にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>"""<ept i="0">&lt;/c0&gt;</ept> that ends the literal determines the indentation: Every nonblank line in the literal must begin with exactly the same indentation that appears before the closing <bpt i="1" x="1">&lt;c1&gt;</bpt>"""<ept i="1">&lt;/c1&gt;</ept>; there’s no conversion between tabs and spaces.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リテラルの終わりの<bpt i="0" x="0">&lt;c0&gt;</bpt>"""<ept i="0">&lt;/c0&gt;</ept>はその字下げを決定します：リテラルの中のあらゆる空でない行は、閉じている<bpt i="1" x="1">&lt;c1&gt;</bpt>"""<ept i="1">&lt;/c1&gt;</ept>の前に現れるのと正確に同じ字下げで始まらなければなりません；タブと空白の間の変換はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>(404, "Not Found")<ept i="0">&lt;/c0&gt;</ept> tuple groups together an <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> and a <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> to give the HTTP status code two separate values: a number and a human-readable description.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt>(404, "Not Found")<ept i="0">&lt;/c0&gt;</ept>タプルは<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>をひとつにまとめて、HTTP状態コードに２つの別々の値：数と人間の読める説明を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept> attribute is implicitly added in fewer places.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept>属性がいくらかの場所で暗黙的に加えられる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>@optional<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>@lazy<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>@final<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>@required<ept i="3">&lt;/c3&gt;</ept> attributes are now the <bpt i="4" x="4">&lt;c4&gt;</bpt>optional<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>lazy<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>final<ept i="6">&lt;/c6&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>required<ept i="7">&lt;/c7&gt;</ept> <bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>Declaration Modifiers<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@optional<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>@lazy<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>@final<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>@required<ept i="3">&lt;/c3&gt;</ept>属性は今や<bpt i="4" x="4">&lt;c4&gt;</bpt>optional<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>lazy<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>final<ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>required<ept i="7">&lt;/c7&gt;</ept><bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>宣言修飾子です<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>@prefix<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>@postfix<ept i="1">&lt;/c1&gt;</ept> attributes for <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Prefix and Postfix Operators<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> have been replaced by <bpt i="4" x="4">&lt;c4&gt;</bpt>prefix<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>postfix<ept i="5">&lt;/c5&gt;</ept> declaration modifiers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>接頭辞および接尾辞演算子<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>のための<bpt i="0" x="0">&lt;c0&gt;</bpt>@prefix<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>@postfix<ept i="1">&lt;/c1&gt;</ept>属性は、<bpt i="4" x="4">&lt;c4&gt;</bpt>prefix<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>postfix<ept i="5">&lt;/c5&gt;</ept>宣言修飾子によって置き換えられました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Address<ept i="0">&lt;/c0&gt;</ept> class also provides a method called <bpt i="1" x="1">&lt;c1&gt;</bpt>buildingIdentifier()<ept i="1">&lt;/c1&gt;</ept>, which has a return type of <bpt i="2" x="2">&lt;c2&gt;</bpt>String?<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Address<ept i="0">&lt;/c0&gt;</ept>クラスはまた、<bpt i="1" x="1">&lt;c1&gt;</bpt>buildingIdentifier()<ept i="1">&lt;/c1&gt;</ept>と呼ばれるメソッドを提供します、それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>String?<ept i="2">&lt;/c2&gt;</ept>の戻り型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept> type represents values of any type, including optional types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept>型は、オプショナル型を含む、何らかの型の値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>AudioChannel<ept i="0">&lt;/c0&gt;</ept> structure also defines a stored instance property called <bpt i="1" x="1">&lt;c1&gt;</bpt>currentLevel<ept i="1">&lt;/c1&gt;</ept>, which represents the channel’s current audio level on a scale of <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>10<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>AudioChannel<ept i="0">&lt;/c0&gt;</ept>構造体はまた、<bpt i="1" x="1">&lt;c1&gt;</bpt>currentLevel<ept i="1">&lt;/c1&gt;</ept>と呼ばれる保存インスタンスプロパティを定義します、それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>から<bpt i="3" x="3">&lt;c3&gt;</bpt>10<ept i="3">&lt;/c3&gt;</ept>までの目盛りでチャンネルの現在の音声レベルを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>AudioChannel<ept i="0">&lt;/c0&gt;</ept> structure defines two stored type properties to support its functionality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>AudioChannel<ept i="0">&lt;/c0&gt;</ept>構造体は、その機能性を支えるために２つの保存型プロパティを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>AutomaticallyNamedDocument<ept i="0">&lt;/c0&gt;</ept> overrides its superclass’s failable <bpt i="1" x="1">&lt;c1&gt;</bpt>init?(name:)<ept i="1">&lt;/c1&gt;</ept> initializer with a nonfailable <bpt i="2" x="2">&lt;c2&gt;</bpt>init(name:)<ept i="2">&lt;/c2&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>AutomaticallyNamedDocument<ept i="0">&lt;/c0&gt;</ept>は、それのスーパークラスの失敗できる<bpt i="1" x="1">&lt;c1&gt;</bpt>init?(name:)<ept i="1">&lt;/c1&gt;</ept>イニシャライザを、失敗できない<bpt i="2" x="2">&lt;c2&gt;</bpt>init(name:)<ept i="2">&lt;/c2&gt;</ept>イニシャライザでオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Bicycle<ept i="0">&lt;/c0&gt;</ept> subclass defines a custom designated initializer, <bpt i="1" x="1">&lt;c1&gt;</bpt>init()<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bicycle<ept i="0">&lt;/c0&gt;</ept>サブクラスはあつらえの指定イニシャライザ、<bpt i="1" x="1">&lt;c1&gt;</bpt>init()<ept i="1">&lt;/c1&gt;</ept>を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>BlackjackCard<ept i="0">&lt;/c0&gt;</ept> structure itself has two properties—<bpt i="1" x="1">&lt;c1&gt;</bpt>rank<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>suit<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>BlackjackCard<ept i="0">&lt;/c0&gt;</ept>構造体は、２つのプロパティ ― <bpt i="1" x="1">&lt;c1&gt;</bpt>rank<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>suit<ept i="2">&lt;/c2&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Circle<ept i="0">&lt;/c0&gt;</ept> class implements the <bpt i="1" x="1">&lt;c1&gt;</bpt>area<ept i="1">&lt;/c1&gt;</ept> property requirement as a computed property, based on a stored <bpt i="2" x="2">&lt;c2&gt;</bpt>radius<ept i="2">&lt;/c2&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Circle<ept i="0">&lt;/c0&gt;</ept>クラスは<bpt i="1" x="1">&lt;c1&gt;</bpt>area<ept i="1">&lt;/c1&gt;</ept>プロパティ要件を、保存<bpt i="2" x="2">&lt;c2&gt;</bpt>radius<ept i="2">&lt;/c2&gt;</ept>プロパティに基づいて計算プロパティとして、満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Circle<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Country<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Animal<ept i="2">&lt;/c2&gt;</ept> classes don’t have a shared base class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Circle<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Country<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>Animal<ept i="2">&lt;/c2&gt;</ept>クラスには、共有の基盤クラスがありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept> protocol defines three required capabilities that any container must provide:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept>プロトコルは、あらゆるコンテナ（容れ物）が提供しなければならない３つの必須の能力を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept> class also declares a variable property, <bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept>, to keep track of the current counter value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept>クラスはまた、変数プロパティ、<bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept>を宣言して、現在のカウンターの値の情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept> class defines three instance methods:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept>クラスは、３つのインスタンスメソッドを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept> class stores its current value in a variable property called <bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept>クラスは、その現在の値を<bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept>と呼ばれる変数プロパティに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept> class, defined below, has an optional <bpt i="1" x="1">&lt;c1&gt;</bpt>dataSource<ept i="1">&lt;/c1&gt;</ept> property of type <bpt i="2" x="2">&lt;c2&gt;</bpt>CounterDataSource?<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下で定義される、<bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept>クラスは、型<bpt i="2" x="2">&lt;c2&gt;</bpt>CounterDataSource?<ept i="2">&lt;/c2&gt;</ept>のオプショナルの<bpt i="1" x="1">&lt;c1&gt;</bpt>dataSource<ept i="1">&lt;/c1&gt;</ept>プロパティを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>CounterDataSource<ept i="0">&lt;/c0&gt;</ept> protocol defines an optional method requirement called <bpt i="1" x="1">&lt;c1&gt;</bpt>increment(forCount:)<ept i="1">&lt;/c1&gt;</ept> and an optional property requirement called <bpt i="2" x="2">&lt;c2&gt;</bpt>fixedIncrement<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>CounterDataSource<ept i="0">&lt;/c0&gt;</ept>プロトコルは、<bpt i="1" x="1">&lt;c1&gt;</bpt>incrementForCount(_:)<ept i="1">&lt;/c1&gt;</ept>と呼ばれるオプショナルのメソッド要件と<bpt i="2" x="2">&lt;c2&gt;</bpt>fixedIncrement<ept i="2">&lt;/c2&gt;</ept>と呼ばれるオプショナルのプロパティ要件を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept> example shows a situation where one property that is allowed to be <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept> and another property that cannot be <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> have the potential to cause a strong reference cycle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept>の例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>であることを許されるあるプロパティと<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>であることができないもう１つのプロパティが強い参照循環を引き起こす可能性をもつ状況を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept> instance now has a strong reference to the <bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept> instance, and the <bpt i="2" x="2">&lt;c2&gt;</bpt>CreditCard<ept i="2">&lt;/c2&gt;</ept> instance has an unowned reference to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Customer<ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept>インスタンスは現在<bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept>インスタンスへの強い参照を持ちます、そして、<bpt i="2" x="2">&lt;c2&gt;</bpt>CreditCard<ept i="2">&lt;/c2&gt;</ept>インスタンスは<bpt i="3" x="3">&lt;c3&gt;</bpt>Customer<ept i="3">&lt;/c3&gt;</ept>インスタンスへの非所有者参照を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>DataManager<ept i="0">&lt;/c0&gt;</ept> class has a stored property called <bpt i="1" x="1">&lt;c1&gt;</bpt>data<ept i="1">&lt;/c1&gt;</ept>, which is initialized with a new, empty array of <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>DataManager<ept i="0">&lt;/c0&gt;</ept>クラスは<bpt i="1" x="1">&lt;c1&gt;</bpt>data<ept i="1">&lt;/c1&gt;</ept>と呼ばれる保存プロパティを持ちます、それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>値の、新規の、空の配列で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Dice<ept i="0">&lt;/c0&gt;</ept> class from earlier can be extended to adopt and conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以前の<bpt i="0" x="0">&lt;c0&gt;</bpt>Dice<ept i="0">&lt;/c0&gt;</ept>クラスは、拡張されることで、<bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept>を採用して準拠することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>DiceGame<ept i="0">&lt;/c0&gt;</ept> protocol is a protocol that can be adopted by any game that involves dice.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>DiceGame<ept i="0">&lt;/c0&gt;</ept>プロトコルは、さいころが関わるどんなゲームによってでも採用されることができるプロトコルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Food<ept i="0">&lt;/c0&gt;</ept> class also provides a <bpt i="1" x="1">&lt;e1&gt;</bpt>convenience<ept i="1">&lt;/e1&gt;</ept> initializer, <bpt i="2" x="2">&lt;c2&gt;</bpt>init()<ept i="2">&lt;/c2&gt;</ept>, with no arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Food<ept i="0">&lt;/c0&gt;</ept>クラスはまた、引数のない<bpt i="1" x="1">&lt;e1&gt;</bpt>便宜<ept i="1">&lt;/e1&gt;</ept>イニシャライザ、<bpt i="2" x="2">&lt;c2&gt;</bpt>init()<ept i="2">&lt;/c2&gt;</ept>を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>FullyNamed<ept i="0">&lt;/c0&gt;</ept> protocol requires a conforming type to provide a fully-qualified name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>FullyNamed<ept i="0">&lt;/c0&gt;</ept>プロトコルは、完全修飾名を提供するある準拠型を要件とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept> class defines a <bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept> property, which indicates the name of the element, such as <bpt i="2" x="2">&lt;c2&gt;</bpt>"h1"<ept i="2">&lt;/c2&gt;</ept> for a heading element, <bpt i="3" x="3">&lt;c3&gt;</bpt>"p"<ept i="3">&lt;/c3&gt;</ept> for a paragraph element, or <bpt i="4" x="4">&lt;c4&gt;</bpt>"br"<ept i="4">&lt;/c4&gt;</ept> for a line break element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept>クラスは<bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept>プロパティを定義します、それは、要素の名前を示します、例えばヘッダ要素の<bpt i="2" x="2">&lt;c2&gt;</bpt>"h1"<ept i="2">&lt;/c2&gt;</ept>、段落要素のための<bpt i="3" x="3">&lt;c3&gt;</bpt>"p"<ept i="3">&lt;/c3&gt;</ept>、またはあるいは、改行要素のための<bpt i="4" x="4">&lt;c4&gt;</bpt>"br"<ept i="4">&lt;/c4&gt;</ept>要素など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept> class provides a single initializer, which takes a <bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept> argument and (if desired) a <bpt i="2" x="2">&lt;c2&gt;</bpt>text<ept i="2">&lt;/c2&gt;</ept> argument to initialize a new element.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept>クラスは一つのイニシャライザを提供します、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept>引数と（希望する場合には）<bpt i="2" x="2">&lt;c2&gt;</bpt>text<ept i="2">&lt;/c2&gt;</ept>引数をとって新しい要素を初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>IntStack<ept i="0">&lt;/c0&gt;</ept> type implements all three of the <bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept> protocol’s requirements, and in each case wraps part of the <bpt i="2" x="2">&lt;c2&gt;</bpt>IntStack<ept i="2">&lt;/c2&gt;</ept> type’s existing functionality to satisfy these requirements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>IntStack<ept i="0">&lt;/c0&gt;</ept>型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept>プロトコルの要件の３つすべてを実装します、そしてそれぞれの場合において、これらの要件を満たすために<bpt i="2" x="2">&lt;c2&gt;</bpt>IntStack<ept i="2">&lt;/c2&gt;</ept>型がもつ既存の機能性の一部をラップしています（内部で利用して外側を包む）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>IntStack<ept i="0">&lt;/c0&gt;</ept> type shown above can only be used with <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> values, however.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、上で示される<bpt i="0" x="0">&lt;c0&gt;</bpt>IntStack<ept i="0">&lt;/c0&gt;</ept>型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値で使われることができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Item<ept i="0">&lt;/c0&gt;</ept> for <bpt i="1" x="1">&lt;c1&gt;</bpt>C1<ept i="1">&lt;/c1&gt;</ept> must be the same as the <bpt i="2" x="2">&lt;c2&gt;</bpt>Item<ept i="2">&lt;/c2&gt;</ept> for <bpt i="3" x="3">&lt;c3&gt;</bpt>C2<ept i="3">&lt;/c3&gt;</ept> (written as <bpt i="4" x="4">&lt;c4&gt;</bpt>C1.Item == C2.Item<ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>C1<ept i="1">&lt;/c1&gt;</ept>のための<bpt i="0" x="0">&lt;c0&gt;</bpt>Item<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="3" x="3">&lt;c3&gt;</bpt>C2<ept i="3">&lt;/c3&gt;</ept>のための<bpt i="2" x="2">&lt;c2&gt;</bpt>Item<ept i="2">&lt;/c2&gt;</ept>と同じものでなければなりません（<bpt i="4" x="4">&lt;c4&gt;</bpt>C1.Item == C2.Item<ept i="4">&lt;/c4&gt;</ept>のように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Item<ept i="0">&lt;/c0&gt;</ept> for <bpt i="1" x="1">&lt;c1&gt;</bpt>C1<ept i="1">&lt;/c1&gt;</ept> must conform to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept> protocol (written as <bpt i="3" x="3">&lt;c3&gt;</bpt>C1.Item: Equatable<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>C1<ept i="1">&lt;/c1&gt;</ept>のための<bpt i="0" x="0">&lt;c0&gt;</bpt>Item<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠しなければなりません（<bpt i="3" x="3">&lt;c3&gt;</bpt>C1.Item: Equatable<ept i="3">&lt;/c3&gt;</ept>のように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>LevelTracker<ept i="0">&lt;/c0&gt;</ept> structure is used with the <bpt i="1" x="1">&lt;c1&gt;</bpt>Player<ept i="1">&lt;/c1&gt;</ept> class, shown below, to track and update the progress of an individual player:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>LevelTracker<ept i="0">&lt;/c0&gt;</ept>構造体は<bpt i="1" x="1">&lt;c1&gt;</bpt>Player<ept i="1">&lt;/c1&gt;</ept>クラスとともに使用され、下で示されるように、個々のプレーヤーの進捗を追跡して更新します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>LevelTracker<ept i="0">&lt;/c0&gt;</ept> structure keeps track of the highest level that any player has unlocked.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>LevelTracker<ept i="0">&lt;/c0&gt;</ept>構造体は、プレーヤーのだれかが鍵を開けた最も高いレベルの情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>LevelTracker<ept i="0">&lt;/c0&gt;</ept> structure uses type properties and methods to keep track of which levels of the game have been unlocked.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>LevelTracker<ept i="0">&lt;/c0&gt;</ept>構造体は、そのゲームのどのレベルが鍵を開けられているかを追跡し続けるために型プロパティとメソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Matrix<ept i="0">&lt;/c0&gt;</ept> subscript’s getter and setter both contain an assertion to check that the subscript’s <bpt i="1" x="1">&lt;c1&gt;</bpt>row<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>column<ept i="2">&lt;/c2&gt;</ept> values are valid.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Matrix<ept i="0">&lt;/c0&gt;</ept>添え字のゲッターとセッターは両方とも、添え字のもつ<bpt i="1" x="1">&lt;c1&gt;</bpt>row<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>column<ept i="2">&lt;/c2&gt;</ept>値が有効なことを確認するためにひとつの表明を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>NSCopying<ept i="0">&lt;/c0&gt;</ept> attribute behaves in a way similar to the Objective-C <bpt i="1" x="1">&lt;c1&gt;</bpt>copy<ept i="1">&lt;/c1&gt;</ept> property attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSCopying<ept i="0">&lt;/c0&gt;</ept>属性は、Objective-Cの<bpt i="1" x="1">&lt;c1&gt;</bpt>copy<ept i="1">&lt;/c1&gt;</ept>プロパティ属性に似たやり方でふるまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>NSString<ept i="0">&lt;/c0&gt;</ept> <bpt i="1" x="1">&lt;c1&gt;</bpt>length<ept i="1">&lt;/c1&gt;</ept> property is now mapped onto Swift’s native <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> type as <bpt i="3" x="3">&lt;c3&gt;</bpt>utf16Count<ept i="3">&lt;/c3&gt;</ept>, not <bpt i="4" x="4">&lt;c4&gt;</bpt>utf16count<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSString<ept i="0">&lt;/c0&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>length<ept i="1">&lt;/c1&gt;</ept>プロパティは現在ではスウィフトの生粋の<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>型と<bpt i="3" x="3">&lt;c3&gt;</bpt>utf16Count<ept i="3">&lt;/c3&gt;</ept>として対応づけられます、<bpt i="4" x="4">&lt;c4&gt;</bpt>utf16count<ept i="4">&lt;/c4&gt;</ept>ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept> example shows a situation where two properties, both of which are allowed to be <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>, have the potential to cause a strong reference cycle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept>の例は、２つのプロパティ、両方とも<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>であることを許されるものが強い参照循環を引き起こす可能性をもつ状況を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> class has an initializer that sets the instance’s <bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept> property and prints a message to indicate that initialization is underway.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>クラスは、インスタンスの<bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept>プロパティを設定して、初期化が進行中であることを示すためにメッセージを出力するイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> class is defined in the same way as before:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>クラスは、前の通りに定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> instance now has a strong reference to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept> instance, and the <bpt i="2" x="2">&lt;c2&gt;</bpt>Apartment<ept i="2">&lt;/c2&gt;</ept> instance has a strong reference to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Person<ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>インスタンスは現在<bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept>インスタンスへの強い参照を持ちます、そして、<bpt i="2" x="2">&lt;c2&gt;</bpt>Apartment<ept i="2">&lt;/c2&gt;</ept>インスタンスは<bpt i="3" x="3">&lt;c3&gt;</bpt>Person<ept i="3">&lt;/c3&gt;</ept>インスタンスへの強い参照を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> instance still has a strong reference to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept> instance, but the <bpt i="2" x="2">&lt;c2&gt;</bpt>Apartment<ept i="2">&lt;/c2&gt;</ept> instance now has a <bpt i="3" x="3">&lt;e3&gt;</bpt>weak<ept i="3">&lt;/e3&gt;</ept> reference to the <bpt i="4" x="4">&lt;c4&gt;</bpt>Person<ept i="4">&lt;/c4&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>インスタンスは依然として<bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept>インスタンスへの強い参照を持ちます、しかし、<bpt i="2" x="2">&lt;c2&gt;</bpt>Apartment<ept i="2">&lt;/c2&gt;</ept>インスタンスは現在は<bpt i="4" x="4">&lt;c4&gt;</bpt>Person<ept i="4">&lt;/c4&gt;</ept>インスタンスへの<bpt i="3" x="3">&lt;e3&gt;</bpt>弱い<ept i="3">&lt;/e3&gt;</ept>参照を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept> class creates a new instance of <bpt i="1" x="1">&lt;c1&gt;</bpt>LevelTracker<ept i="1">&lt;/c1&gt;</ept> to track that player’s progress.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept>クラスは、そのプレーヤーの進捗を追うために<bpt i="1" x="1">&lt;c1&gt;</bpt>LevelTracker<ept i="1">&lt;/c1&gt;</ept>の新しいインスタンスをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept> class defines a <bpt i="1" x="1">&lt;c1&gt;</bpt>win(coins:)<ept i="1">&lt;/c1&gt;</ept> method, which retrieves a certain number of coins from the bank and adds them to the player’s purse.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept>クラスは<bpt i="1" x="1">&lt;c1&gt;</bpt>win(coins:)<ept i="1">&lt;/c1&gt;</ept>メソッドを定義します、それは、胴元からコインの特定の数を取り戻して、それらをプレーヤーの財布に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept> class describes a player in the game.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept>クラスは、ゲームにおけるプレーヤーを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Point<ept i="0">&lt;/c0&gt;</ept> structure above defines a mutating <bpt i="1" x="1">&lt;c1&gt;</bpt>moveBy(x:y:)<ept i="1">&lt;/c1&gt;</ept> method, which moves a <bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept> instance by a certain amount.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="0" x="0">&lt;c0&gt;</bpt>Point構<ept i="0">&lt;/c0&gt;</ept>造体は可変の<bpt i="1" x="1">&lt;c1&gt;</bpt>moveBy(x:y:)<ept i="1">&lt;/c1&gt;</ept>メソッドを定義します、それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept>インスタンスを特定の量だけ動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>RandomNumberGenerator<ept i="0">&lt;/c0&gt;</ept> protocol doesn’t make any assumptions about how each random number will be generated—it simply requires the generator to provide a standard way to generate a new random number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>RandomNumberGenerator<ept i="0">&lt;/c0&gt;</ept>プロトコルは、乱数それぞれが生成される方法について、全く仮定しません ― それは単に生成器に新しい乱数を生み出す標準の方法を提供することを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Rank<ept i="0">&lt;/c0&gt;</ept> enumeration describes the thirteen possible playing card ranks, together with a raw <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> value to represent their face value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Rank<ept i="0">&lt;/c0&gt;</ept>列挙は、13のあり得るトランプカードの等級を、それらの額面を表す生の<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値と共に記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>RecipeIngredient<ept i="0">&lt;/c0&gt;</ept> class has a single designated initializer, <bpt i="1" x="1">&lt;c1&gt;</bpt>init(name: String, quantity: Int)<ept i="1">&lt;/c1&gt;</ept>, which can be used to populate all of the properties of a new <bpt i="2" x="2">&lt;c2&gt;</bpt>RecipeIngredient<ept i="2">&lt;/c2&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>RecipeIngredient<ept i="0">&lt;/c0&gt;</ept>クラスは、一つの指定イニシャライザ、<bpt i="1" x="1">&lt;c1&gt;</bpt>init(name: String, quantity: Int)<ept i="1">&lt;/c1&gt;</ept>を持ちます、それは、新しい<bpt i="2" x="2">&lt;c2&gt;</bpt>RecipeIngredient<ept i="2">&lt;/c2&gt;</ept>インスタンスのプロパティの全てに何か入れるために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept> structure also provides a computed property called <bpt i="1" x="1">&lt;c1&gt;</bpt>center<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept>構造体はまた、<bpt i="1" x="1">&lt;c1&gt;</bpt>center<ept i="1">&lt;/c1&gt;</ept>（中心）と呼ばれる計算プロパティを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Residence<ept i="0">&lt;/c0&gt;</ept> class is more complex than before.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Residence<ept i="0">&lt;/c0&gt;</ept>クラスは、前より複雑です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Resolution<ept i="0">&lt;/c0&gt;</ept> structure definition and the <bpt i="1" x="1">&lt;c1&gt;</bpt>VideoMode<ept i="1">&lt;/c1&gt;</ept> class definition only describe what a <bpt i="2" x="2">&lt;c2&gt;</bpt>Resolution<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>VideoMode<ept i="3">&lt;/c3&gt;</ept> will look like.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Resolution<ept i="0">&lt;/c0&gt;</ept>構造体定義と<bpt i="1" x="1">&lt;c1&gt;</bpt>VideoMode<ept i="1">&lt;/c1&gt;</ept>クラス定義は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Resolution<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>VideoMode<ept i="3">&lt;/c3&gt;</ept>がどのようなものかについて記述するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Room<ept i="0">&lt;/c0&gt;</ept> class used for the <bpt i="1" x="1">&lt;c1&gt;</bpt>rooms<ept i="1">&lt;/c1&gt;</ept> array is a simple class with one property called <bpt i="2" x="2">&lt;c2&gt;</bpt>name<ept i="2">&lt;/c2&gt;</ept>, and an initializer to set that property to a suitable room name:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>rooms<ept i="1">&lt;/c1&gt;</ept>配列のために使用される<bpt i="0" x="0">&lt;c0&gt;</bpt>Room<ept i="0">&lt;/c0&gt;</ept>クラスは、<bpt i="2" x="2">&lt;c2&gt;</bpt>name<ept i="2">&lt;/c2&gt;</ept>と呼ばれる１つのプロパティ、そしてそのプロパティを適切な部屋名に設定するイニシャライザをもつ単純なクラスです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Size<ept i="0">&lt;/c0&gt;</ept> structure automatically receives an <bpt i="1" x="1">&lt;c1&gt;</bpt>init(width:height:)<ept i="1">&lt;/c1&gt;</ept> memberwise initializer, which you can use to initialize a new <bpt i="2" x="2">&lt;c2&gt;</bpt>Size<ept i="2">&lt;/c2&gt;</ept> instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Size<ept i="0">&lt;/c0&gt;</ept>構造体は自動的にメンバー関連イニシャライザ<bpt i="1" x="1">&lt;c1&gt;</bpt>init(width:height:)<ept i="1">&lt;/c1&gt;</ept>を受け取ります、それは、あなたが新しい<bpt i="2" x="2">&lt;c2&gt;</bpt>Size<ept i="2">&lt;/c2&gt;</ept>インスタンスを初期化するために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>SnakesAndLadders<ept i="0">&lt;/c0&gt;</ept> class can be extended to adopt and conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>PrettyTextRepresentable<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>SnakesAndLadders<ept i="0">&lt;/c0&gt;</ept>クラスは、拡張されることで<bpt i="1" x="1">&lt;c1&gt;</bpt>PrettyTextRepresentable<ept i="1">&lt;/c1&gt;</ept>を採用して準拠するようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>StepCounter<ept i="0">&lt;/c0&gt;</ept> class declares a <bpt i="1" x="1">&lt;c1&gt;</bpt>totalSteps<ept i="1">&lt;/c1&gt;</ept> property of type <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>StepCounter<ept i="0">&lt;/c0&gt;</ept>クラスは、型<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>totalSteps<ept i="1">&lt;/c1&gt;</ept>プロパティを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Suit<ept i="0">&lt;/c0&gt;</ept> enumeration describes the four common playing card suits, together with a raw <bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept> value to represent their symbol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Suit<ept i="0">&lt;/c0&gt;</ept>列挙は、トランプの４つの通常のスート（組み札）を、それらの記号を表す生の<bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept>値と共に記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>TowardsZeroSource<ept i="0">&lt;/c0&gt;</ept> class implements the optional <bpt i="1" x="1">&lt;c1&gt;</bpt>increment(forCount:)<ept i="1">&lt;/c1&gt;</ept> method from the <bpt i="2" x="2">&lt;c2&gt;</bpt>CounterDataSource<ept i="2">&lt;/c2&gt;</ept> protocol and uses the <bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept> argument value to work out which direction to count in.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>TowardsZeroSource<ept i="0">&lt;/c0&gt;</ept>クラスは、<bpt i="2" x="2">&lt;c2&gt;</bpt>CounterDataSource<ept i="2">&lt;/c2&gt;</ept>プロトコルからのオプショナルの<bpt i="1" x="1">&lt;c1&gt;</bpt>increment(forCount:)<ept i="1">&lt;/c1&gt;</ept>メソッドを実装して、どの方向に数えるべきか解決するために<bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept>引数値を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>TrackedString<ept i="0">&lt;/c0&gt;</ept> structure and the <bpt i="1" x="1">&lt;c1&gt;</bpt>value<ept i="1">&lt;/c1&gt;</ept> property don’t provide an explicit access-level modifier, and so they both receive the default access level of internal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>TrackedString<ept i="0">&lt;/c0&gt;</ept>構造体と<bpt i="1" x="1">&lt;c1&gt;</bpt>value<ept i="1">&lt;/c1&gt;</ept>プロパティは明確なアクセス水準修飾子を提供しません、なので、それらは両方とも省略時のアクセス水準である内部を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>TrackedString<ept i="0">&lt;/c0&gt;</ept> structure defines a stored string property called <bpt i="1" x="1">&lt;c1&gt;</bpt>value<ept i="1">&lt;/c1&gt;</ept>, with an initial value of <bpt i="2" x="2">&lt;c2&gt;</bpt>""<ept i="2">&lt;/c2&gt;</ept> (an empty string).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>TrackedString<ept i="0">&lt;/c0&gt;</ept>構造体は、<bpt i="1" x="1">&lt;c1&gt;</bpt>value<ept i="1">&lt;/c1&gt;</ept>と呼ばれる保存文字列プロパティを、<bpt i="2" x="2">&lt;c2&gt;</bpt>""<ept i="2">&lt;/c2&gt;</ept>（空の文字列）の初期値で定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept> base class also defines a method called <bpt i="1" x="1">&lt;c1&gt;</bpt>makeNoise<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept>クラスはまた、<bpt i="1" x="1">&lt;c1&gt;</bpt>makeNoise<ept i="1">&lt;/c1&gt;</ept>と呼ばれるメソッドを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept> class defines common characteristics for an arbitrary vehicle, but is not much use in itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept>クラスは、任意の乗物のためのありふれた特徴を定義します、しかしそれ自体では余り役に立ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept> class provides a default value for its only stored property, and does not provide any custom initializers itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept>クラスは、それの保存プロパティのためにのみ省略時の値を提供します、そしてそれ自身では何らあつらえのイニシャライザを提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>addTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept> function has the same type as the <bpt i="1" x="1">&lt;c1&gt;</bpt>mathFunction<ept i="1">&lt;/c1&gt;</ept> variable, and so this assignment is allowed by Swift’s type-checker.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>addTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数は<bpt i="1" x="1">&lt;c1&gt;</bpt>mathFunction<ept i="1">&lt;/c1&gt;</ept>変数と同じ型を持ちます、なので、この代入はスウィフトの型チェッカーによって認められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>addition<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>multiplication<ept i="1">&lt;/c1&gt;</ept> cases have associated values that are also arithmetic expressions—these associated values make it possible to nest expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>addition<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>multiplication<ept i="1">&lt;/c1&gt;</ept>ケース節は、それもまた算術式である関連値を持ちます—これらの関連値がそれを入れ子式可能なものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>airports<ept i="0">&lt;/c0&gt;</ept> dictionary is declared as a variable (with the <bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept> introducer), and not a constant (with the <bpt i="2" x="2">&lt;c2&gt;</bpt>let<ept i="2">&lt;/c2&gt;</ept> introducer), because more airports are added to the dictionary in the examples below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>airports<ept i="0">&lt;/c0&gt;</ept>辞書は、変数として（<bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept>導入子を使って）宣言されます、定数（<bpt i="2" x="2">&lt;c2&gt;</bpt>let<ept i="2">&lt;/c2&gt;</ept>導入子を使って）ではなく、なぜならより多くの空港が下記の例でこの辞書に加えられるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>airports<ept i="0">&lt;/c0&gt;</ept> dictionary is declared as having a type of <bpt i="1" x="1">&lt;c1&gt;</bpt>[String: String]<ept i="1">&lt;/c1&gt;</ept>, which means “a <bpt i="2" x="2">&lt;c2&gt;</bpt>Dictionary<ept i="2">&lt;/c2&gt;</ept> whose keys are of type <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>, and whose values are also of type <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>airports<ept i="0">&lt;/c0&gt;</ept>辞書は、<bpt i="1" x="1">&lt;c1&gt;</bpt>[String: String]<ept i="1">&lt;/c1&gt;</ept>の型を持つとして宣言されます、それは「キーが型<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>であり、値もまた型<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>である<bpt i="2" x="2">&lt;c2&gt;</bpt>Dictionary<ept i="2">&lt;/c2&gt;</ept>」を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>airports<ept i="0">&lt;/c0&gt;</ept> dictionary is initialized with a dictionary literal containing two key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>airports<ept i="0">&lt;/c0&gt;</ept>辞書は、２つの「キーと値」の対を含んでいるひとつの辞書リテラルで初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>allItemsMatch(_:_:)<ept i="0">&lt;/c0&gt;</ept> function starts by checking that both containers contain the same number of items.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>allItemsMatch(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数は、両方のコンテナが同じ数の項目を含むことを確認することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>arch(arm)<ept i="0">&lt;/c0&gt;</ept> platform condition does not return <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> for ARM 64 devices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>arch(arm)<ept i="0">&lt;/c0&gt;</ept>プラットホーム条件は、ARM 64機器に対して<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>as!<ept i="0">&lt;/c0&gt;</ept> operator performs a forced cast of the <bpt i="1" x="1">&lt;e1&gt;</bpt>expression<ept i="1">&lt;/e1&gt;</ept> to the specified <bpt i="2" x="2">&lt;e2&gt;</bpt>type<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>as!<ept i="0">&lt;/c0&gt;</ept>演算子は<bpt i="1" x="1">&lt;e1&gt;</bpt>式<ept i="1">&lt;/e1&gt;</ept>の指定された<bpt i="2" x="2">&lt;e2&gt;</bpt>型<ept i="2">&lt;/e2&gt;</ept>への強制的なキャストを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>as!<ept i="0">&lt;/c0&gt;</ept> version of the downcast operator forces the downcast to the protocol type and triggers a runtime error if the downcast doesn’t succeed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>as!<ept i="0">&lt;/c0&gt;</ept>版のダウンキャスト演算子は、そのプロトコル型へのダウンキャストを強制して、ダウンキャストが成功しなかったならば実行時エラーの引き金を引きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept> operator performs a cast when it is known at compile time that the cast always succeeds, such as upcasting or bridging.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept>演算子は、コンパイル時にそのキャストが常に成功することを知られているキャストを実行します、例えばアップキャストやブリッジなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept> pattern matches a value if the type of that value at runtime is the same as the type specified in the right-hand side of the <bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept> pattern—or a subclass of that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept>パターンは、ある値にマッチします、もしその値の実行時での型が<bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept>パターンの右側で指定される型 ― または、それの型のサブクラス ― と同じものであるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept> operator performs a conditional cast of the <bpt i="1" x="1">&lt;e1&gt;</bpt>expression<ept i="1">&lt;/e1&gt;</ept> to the specified <bpt i="2" x="2">&lt;e2&gt;</bpt>type<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>演算子は<bpt i="1" x="1">&lt;e1&gt;</bpt>式<ept i="1">&lt;/e1&gt;</ept>の指定された<bpt i="2" x="2">&lt;e2&gt;</bpt>型<ept i="2">&lt;/e2&gt;</ept>への条件付きキャストを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept> version of the downcast operator returns an optional value of the protocol’s type, and this value is <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> if the instance doesn’t conform to that protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>版のダウンキャスト演算子は、そのプロトコルの型のオプショナルの値を返します、そしてインスタンスがそのプロトコルに準拠しないならばその値は<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>asHTML<ept i="0">&lt;/c0&gt;</ept> property is declared as a lazy property, because it’s only needed if and when the element actually needs to be rendered as a string value for some HTML output target.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>asHTML<ept i="0">&lt;/c0&gt;</ept>プロパティは遅延プロパティとして宣言されます、なぜなら、要素が何らかのHTML出力対象のために実際に文字列値として解釈される必要がもしもあるときのみそれが必要なだけだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>asHTML<ept i="0">&lt;/c0&gt;</ept> property is named and used somewhat like an instance method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>asHTML<ept i="0">&lt;/c0&gt;</ept>プロパティは、いくぶんインスタンスメソッドのように名前をつけられて、使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>available<ept i="0">&lt;/c0&gt;</ept> attribute always appears with a list of two or more comma-separated attribute arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>available<ept i="0">&lt;/c0&gt;</ept>属性は、常に２つ以上のコンマで区切られた属性引数とともに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>beginConcert(in:)<ept i="0">&lt;/c0&gt;</ept> function takes a parameter of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Location &amp; Named<ept i="1">&lt;/c1&gt;</ept>, which means “any type that’s a subclass of <bpt i="2" x="2">&lt;c2&gt;</bpt>Location<ept i="2">&lt;/c2&gt;</ept> and that conforms to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Named<ept i="3">&lt;/c3&gt;</ept> protocol.” In this case, <bpt i="4" x="4">&lt;c4&gt;</bpt>City<ept i="4">&lt;/c4&gt;</ept> satisfies both requirements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>beginConcert(in:)<ept i="0">&lt;/c0&gt;</ept>関数は、型<bpt i="1" x="1">&lt;c1&gt;</bpt>Location &amp; Named<ept i="1">&lt;/c1&gt;</ept>のパラメータを１つとります、それは「<bpt i="2" x="2">&lt;c2&gt;</bpt>Location<ept i="2">&lt;/c2&gt;</ept>のサブクラスであり、<bpt i="3" x="3">&lt;c3&gt;</bpt>Named<ept i="3">&lt;/c3&gt;</ept>プロトコルに準拠する何らかの型」を意味します。この場合では、<bpt i="4" x="4">&lt;c4&gt;</bpt>City<ept i="4">&lt;/c4&gt;</ept>は両方の要件を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>block<ept i="0">&lt;/c0&gt;</ept> argument is used to indicate an Objective-C compatible block reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>block<ept i="0">&lt;/c0&gt;</ept>引数は、あるObjective-C互換プロック参照を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>boardColors<ept i="0">&lt;/c0&gt;</ept> array is initialized with a closure to set up its color values:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>boardColors<ept i="0">&lt;/c0&gt;</ept>配列は、その色値を設定するために、クロージャで初期化されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>break gameLoop<ept i="0">&lt;/c0&gt;</ept> statement transfers control to the first line of code outside of the <bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept> loop, which ends the game.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>break gameLoop<ept i="0">&lt;/c0&gt;</ept>文は、制御を<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept>ループの外側のコードの最初の行へ移します、そしてゲームを終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept> statement ends execution of an entire control flow statement immediately.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>文は、ある制御の流れに関する文まるまる全体の実行を直ちに終えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>c<ept i="0">&lt;/c0&gt;</ept> argument is used to indicate a C function reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>c<ept i="0">&lt;/c0&gt;</ept>引数は、C関数参照を示すために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>capitalCity<ept i="0">&lt;/c0&gt;</ept> property can be used and accessed like a nonoptional value once initialization is complete, while still avoiding a strong reference cycle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>capitalCity<ept i="0">&lt;/c0&gt;</ept>プロパティは、一旦初期化が終了しているならば、非オプショナルの値のように使われて、アクセスされることができます、その一方で、依然として強い参照循環を避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>case<ept i="0">&lt;/c0&gt;</ept> above has two patterns: <bpt i="1" x="1">&lt;c1&gt;</bpt>(let distance, 0)<ept i="1">&lt;/c1&gt;</ept> matches points on the x-axis and <bpt i="2" x="2">&lt;c2&gt;</bpt>(0, let distance)<ept i="2">&lt;/c2&gt;</ept> matches points on the y-axis.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="0" x="0">&lt;c0&gt;</bpt>case<ept i="0">&lt;/c0&gt;</ept>は、２つのパターンを持ちます：<bpt i="1" x="1">&lt;c1&gt;</bpt>(let distance, 0)<ept i="1">&lt;/c1&gt;</ept>はx軸上の点にマッチします、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>(0, let distance)<ept i="2">&lt;/c2&gt;</ept>はy軸上の点にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>catch<ept i="0">&lt;/c0&gt;</ept> clauses don’t have to handle every possible error that the code in its <bpt i="1" x="1">&lt;c1&gt;</bpt>do<ept i="1">&lt;/c1&gt;</ept> clause can throw.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>catch<ept i="0">&lt;/c0&gt;</ept>節は、それの<bpt i="1" x="1">&lt;c1&gt;</bpt>do<ept i="1">&lt;/c1&gt;</ept>節の中のコードがスロー可能な、すべての起こりうるエラーを処理する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>center<ept i="0">&lt;/c0&gt;</ept> property is then set to a new value of <bpt i="1" x="1">&lt;c1&gt;</bpt>(15, 15)<ept i="1">&lt;/c1&gt;</ept>, which moves the square up and to the right, to the new position shown by the orange square in the diagram below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>center<ept i="0">&lt;/c0&gt;</ept>プロパティは、それから新しい値<bpt i="1" x="1">&lt;c1&gt;</bpt>(15, 15)<ept i="1">&lt;/c1&gt;</ept>に設定されます、それは、正方形を上にそして右に、下記の図においてオレンジの正方形によって示される新しい位置へと動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>continue<ept i="0">&lt;/c0&gt;</ept> statement tells a loop to stop what it is doing and start again at the beginning of the next iteration through the loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>continue<ept i="0">&lt;/c0&gt;</ept>文は、あるループにそれがしていることを止めて、そのループの次の繰り返しの始めのところで再び始めるように言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>continue<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>break<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>fallthrough<ept i="2">&lt;/c2&gt;</ept> statements are described below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>continue<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>break<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>fallthrough<ept i="2">&lt;/c2&gt;</ept>文は、以下で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>convention<ept i="0">&lt;/c0&gt;</ept> attribute always appears with one of the attribute arguments below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>convention<ept i="0">&lt;/c0&gt;</ept>属性は、常に以下の属性引数とともに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>currentLevel<ept i="0">&lt;/c0&gt;</ept> property has a <bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept> property observer to check the value of <bpt i="2" x="2">&lt;c2&gt;</bpt>currentLevel<ept i="2">&lt;/c2&gt;</ept> whenever it is set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>currentLevel<ept i="0">&lt;/c0&gt;</ept>プロパティは<bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept>プロパティオブザーバーを持ち、<bpt i="2" x="2">&lt;c2&gt;</bpt>currentLevel<ept i="2">&lt;/c2&gt;</ept>の値をそれが設定されるときはいつでも調べるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>deprecated<ept i="0">&lt;/c0&gt;</ept> argument indicates the first version of the specified platform or language in which the declaration was deprecated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>deprecated<ept i="0">&lt;/c0&gt;</ept>引数は、そこにおいてその宣言が非推奨とされたところの、指定されたプラットホームまたは言語の最初のバージョンを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>didSet<ept i="0">&lt;/c0&gt;</ept> clause is optional when you provide a <bpt i="1" x="1">&lt;c1&gt;</bpt>willSet<ept i="1">&lt;/c1&gt;</ept> clause.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="1" x="1">&lt;c1&gt;</bpt>willSet<ept i="1">&lt;/c1&gt;</ept>節を提供するとき、<bpt i="0" x="0">&lt;c0&gt;</bpt>didSet<ept i="0">&lt;/c0&gt;</ept>節は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>didSet<ept i="0">&lt;/c0&gt;</ept> observer is called after the value of <bpt i="1" x="1">&lt;c1&gt;</bpt>totalSteps<ept i="1">&lt;/c1&gt;</ept> is updated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>didSet<ept i="0">&lt;/c0&gt;</ept>オブザーバーは、<bpt i="1" x="1">&lt;c1&gt;</bpt>totalSteps<ept i="1">&lt;/c1&gt;</ept>の値が更新された後に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>distribute(coins:)<ept i="0">&lt;/c0&gt;</ept> method checks that there are enough coins in the bank before distributing them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>distribute(coins:)<ept i="0">&lt;/c0&gt;</ept>メソッドは、十分なコインがそれらを配布する前に胴元にあることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept> statement is used to introduce a new scope and can optionally contain one or more <bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> clauses, which contain patterns that match against defined error conditions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>文は、ある新しいスコープを導入するために使われます、そして随意に１つ以上の<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>節を含むことができ、それは定義されたエラー条件にマッチするパターンを複数含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>else<ept i="0">&lt;/c0&gt;</ept> clause of a <bpt i="1" x="1">&lt;c1&gt;</bpt>guard<ept i="1">&lt;/c1&gt;</ept> statement is required, and must either call a function with the <bpt i="2" x="2">&lt;c2&gt;</bpt>Never<ept i="2">&lt;/c2&gt;</ept> return type or transfer program control outside the guard statement’s enclosing scope using one of the following statements:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>guard<ept i="1">&lt;/c1&gt;</ept>文の<bpt i="0" x="0">&lt;c0&gt;</bpt>else<ept i="0">&lt;/c0&gt;</ept>節は必ず必要です、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>Never<ept i="2">&lt;/c2&gt;</ept>戻り型を持つ関数を呼び出すか、プログラム制御をguard文の囲むスコープの外側に以下の文のうちの１つを使って移すか、どちらかをする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>fallthrough<ept i="0">&lt;/c0&gt;</ept> keyword does not check the case conditions for the <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> case that it causes execution to fall into.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>fallthrough<ept i="0">&lt;/c0&gt;</ept>キーワードは、それが実行を落としていく先の<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>ケース節のためのケース節条件を調べません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>favoriteGenres<ept i="0">&lt;/c0&gt;</ept> set is declared as a variable (with the <bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept> introducer) and not a constant (with the <bpt i="2" x="2">&lt;c2&gt;</bpt>let<ept i="2">&lt;/c2&gt;</ept> introducer) because items are added and removed in the examples below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>favoriteGenres<ept i="0">&lt;/c0&gt;</ept>集合は、定数（<bpt i="2" x="2">&lt;c2&gt;</bpt>let<ept i="2">&lt;/c2&gt;</ept>導入子を使って）ではなく変数として（<bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept>導入子を使って）宣言されます、項目が下の例で加えられたり取り除かれたりするためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>favoriteGenres<ept i="0">&lt;/c0&gt;</ept> variable is declared as “a set of <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> values”, written as <bpt i="2" x="2">&lt;c2&gt;</bpt>Set&lt;String&gt;<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>favoriteGenres<ept i="0">&lt;/c0&gt;</ept>変数は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Set&lt;String&gt;<ept i="2">&lt;/c2&gt;</ept>のように書かれ、「<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値の集合」として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>findIndex(of:in:)<ept i="0">&lt;/c0&gt;</ept> function now compiles successfully and can be used with any type that is <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>, such as <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>findIndex(of:in:)<ept i="0">&lt;/c0&gt;</ept>関数は、今やうまくコンパイルして、<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>であるどんな型とでも使われることができます、例えば<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>や<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>など：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>findIndex(ofString:in:)<ept i="0">&lt;/c0&gt;</ept> function can be used to find a string value in an array of strings:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>findIndex(ofString:in:)<ept i="0">&lt;/c0&gt;</ept>関数は、文字列の配列の中をある文字列値がないか捜すために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop is described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>For-In Loops<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループは<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>for-inループ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>gameDidStart(_:)<ept i="0">&lt;/c0&gt;</ept> method also accesses the <bpt i="1" x="1">&lt;c1&gt;</bpt>dice<ept i="1">&lt;/c1&gt;</ept> property of the passed <bpt i="2" x="2">&lt;c2&gt;</bpt>game<ept i="2">&lt;/c2&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>gameDidStart(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドはまた、渡された<bpt i="2" x="2">&lt;c2&gt;</bpt>game<ept i="2">&lt;/c2&gt;</ept>パラメータの<bpt i="1" x="1">&lt;c1&gt;</bpt>dice<ept i="1">&lt;/c1&gt;</ept>プロパティにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>generator<ept i="0">&lt;/c0&gt;</ept> property is of type <bpt i="1" x="1">&lt;c1&gt;</bpt>RandomNumberGenerator<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>generator<ept i="0">&lt;/c0&gt;</ept>プロパティは、型<bpt i="1" x="1">&lt;c1&gt;</bpt>RandomNumberGenerator<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>hasPrefix(_:)<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>hasSuffix(_:)<ept i="1">&lt;/c1&gt;</ept> methods perform a character-by-character canonical equivalence comparison between the extended grapheme clusters in each string, as described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>String and Character Equality<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>hasPrefix(_:)<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>hasSuffix(_:)<ept i="1">&lt;/c1&gt;</ept>は、各文字列の拡張書記素クラスタ間で文字ごとの正準等価比較を実行します、そのことは<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>文字列と文字の同等性<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement can provide an alternative set of statements, known as an <bpt i="1" x="1">&lt;e1&gt;</bpt>else clause<ept i="1">&lt;/e1&gt;</ept>, for situations when the <bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept> condition is <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文は、代替のひとそろいの文、<bpt i="1" x="1">&lt;e1&gt;</bpt>else節<ept i="1">&lt;/e1&gt;</ept>として知られるものを<bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept>条件が<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>の場合の状況のために提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>in<ept i="0">&lt;/c0&gt;</ept> keyword can also be omitted, because the closure expression is made up entirely of its body:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>in<ept i="0">&lt;/c0&gt;</ept>キーワードもまた、クロージャ式がもっぱらその本文から成り立つので、省略されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>increment()<ept i="0">&lt;/c0&gt;</ept> method first tries to retrieve an increment amount by looking for an implementation of the <bpt i="1" x="1">&lt;c1&gt;</bpt>increment(forCount:)<ept i="1">&lt;/c1&gt;</ept> method on its data source.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>increment()<ept i="0">&lt;/c0&gt;</ept>メソッドは、最初にそれのデータ・ソース上で<bpt i="1" x="1">&lt;c1&gt;</bpt>increment(forCount:)<ept i="1">&lt;/c1&gt;</ept>メソッドの実装を捜すことによって増加量を取り出そうと試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>increment()<ept i="0">&lt;/c0&gt;</ept> method in the example above could have been written like this:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例における<bpt i="0" x="0">&lt;c0&gt;</bpt>increment()<ept i="0">&lt;/c0&gt;</ept>メソッドは、このように記述されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>incrementer()<ept i="0">&lt;/c0&gt;</ept> function doesn’t have any parameters, and yet it refers to <bpt i="1" x="1">&lt;c1&gt;</bpt>runningTotal<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>amount<ept i="2">&lt;/c2&gt;</ept> from within its function body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>incrementer()<ept i="0">&lt;/c0&gt;</ept>関数には全くパラメータがありません、それなのに、それはその関数本文内から<bpt i="1" x="1">&lt;c1&gt;</bpt>runningTotal<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>amount<ept i="2">&lt;/c2&gt;</ept>に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>init()<ept i="0">&lt;/c0&gt;</ept> initializer for <bpt i="1" x="1">&lt;c1&gt;</bpt>Bicycle<ept i="1">&lt;/c1&gt;</ept> starts by calling <bpt i="2" x="2">&lt;c2&gt;</bpt>super.init()<ept i="2">&lt;/c2&gt;</ept>, which calls the default initializer for the <bpt i="3" x="3">&lt;c3&gt;</bpt>Bicycle<ept i="3">&lt;/c3&gt;</ept> class’s superclass, <bpt i="4" x="4">&lt;c4&gt;</bpt>Vehicle<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Bicycle<ept i="1">&lt;/c1&gt;</ept>のための<bpt i="0" x="0">&lt;c0&gt;</bpt>init()<ept i="0">&lt;/c0&gt;</ept>イニシャライザは、<bpt i="2" x="2">&lt;c2&gt;</bpt>super.init()<ept i="2">&lt;/c2&gt;</ept>を呼ぶことによって始まります、それは、<bpt i="3" x="3">&lt;c3&gt;</bpt>Bicycle<ept i="3">&lt;/c3&gt;</ept>クラスのスーパークラス、<bpt i="4" x="4">&lt;c4&gt;</bpt>Vehicle<ept i="4">&lt;/c4&gt;</ept>のための省略時のイニシャライザを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>init(center:size:)<ept i="0">&lt;/c0&gt;</ept> initializer could have assigned the new values of <bpt i="1" x="1">&lt;c1&gt;</bpt>origin<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>size<ept i="2">&lt;/c2&gt;</ept> to the appropriate properties itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>init(center:size:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザは、それ自体で<bpt i="1" x="1">&lt;c1&gt;</bpt>origin<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>size<ept i="2">&lt;/c2&gt;</ept>の新しい値を適切なプロパティに代入することができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>init(name: String)<ept i="0">&lt;/c0&gt;</ept> convenience initializer provided by <bpt i="1" x="1">&lt;c1&gt;</bpt>RecipeIngredient<ept i="1">&lt;/c1&gt;</ept> takes the same parameters as the <bpt i="2" x="2">&lt;c2&gt;</bpt>init(name: String)<ept i="2">&lt;/c2&gt;</ept> <bpt i="3" x="3">&lt;e3&gt;</bpt>designated<ept i="3">&lt;/e3&gt;</ept> initializer from <bpt i="4" x="4">&lt;c4&gt;</bpt>Food<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>RecipeIngredient<ept i="1">&lt;/c1&gt;</ept>によって提供される便宜イニシャライザ<bpt i="0" x="0">&lt;c0&gt;</bpt>init(name: String)<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt>Food<ept i="4">&lt;/c4&gt;</ept>からの<bpt i="3" x="3">&lt;e3&gt;</bpt>指定<ept i="3">&lt;/e3&gt;</ept>イニシャライザ<bpt i="2" x="2">&lt;c2&gt;</bpt>init(name: String)<ept i="2">&lt;/c2&gt;</ept>と同じパラメータを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>init(name: String)<ept i="0">&lt;/c0&gt;</ept> initializer from the <bpt i="1" x="1">&lt;c1&gt;</bpt>Food<ept i="1">&lt;/c1&gt;</ept> class is provided as a <bpt i="2" x="2">&lt;e2&gt;</bpt>designated<ept i="2">&lt;/e2&gt;</ept> initializer, because it ensures that all stored properties of a new <bpt i="3" x="3">&lt;c3&gt;</bpt>Food<ept i="3">&lt;/c3&gt;</ept> instance are fully initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Food<ept i="1">&lt;/c1&gt;</ept>クラスからの<bpt i="0" x="0">&lt;c0&gt;</bpt>init(name: String)<ept i="0">&lt;/c0&gt;</ept>イニシャライザは、<bpt i="2" x="2">&lt;e2&gt;</bpt>指定<ept i="2">&lt;/e2&gt;</ept>イニシャライザとして提供されます、なぜならそれが新しい<bpt i="3" x="3">&lt;c3&gt;</bpt>Food<ept i="3">&lt;/c3&gt;</ept>インスタンスの全ての保存プロパティが充分に初期化されることを確実にするためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>introduced<ept i="0">&lt;/c0&gt;</ept> argument indicates the first version of the specified platform or language in which the declaration was introduced.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>introduced<ept i="0">&lt;/c0&gt;</ept>引数は、そこにおいてその宣言が導入されたところの、指定されたプラットホームまたは言語の最初のバージョンを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept> operator checks at runtime whether the <bpt i="1" x="1">&lt;e1&gt;</bpt>expression<ept i="1">&lt;/e1&gt;</ept> can be cast to the specified <bpt i="2" x="2">&lt;e2&gt;</bpt>type<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept>演算子は実行時に<bpt i="1" x="1">&lt;e1&gt;</bpt>式<ept i="1">&lt;/e1&gt;</ept>が指定された<bpt i="2" x="2">&lt;e2&gt;</bpt>型<ept i="2">&lt;/e2&gt;</ept>へとキャスト可能かどうかを調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept> operator returns <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> if an instance conforms to a protocol and returns <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept> if it doesn’t.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept>演算子は、あるインスタンスがプロトコルに準拠するならば<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を返して、それがそうしないならば<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept> pattern matches a value if the type of that value at runtime is the same as the type specified in the right-hand side of the <bpt i="1" x="1">&lt;c1&gt;</bpt>is<ept i="1">&lt;/c1&gt;</ept> pattern—or a subclass of that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept>パターンは、ある値にマッチします、もしその値の実行時での型が<bpt i="1" x="1">&lt;c1&gt;</bpt>is<ept i="1">&lt;/c1&gt;</ept>パターンの右側で指定される型 ― またはそれの型のサブクラス ― と同じものであるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>john<ept i="0">&lt;/c0&gt;</ept> variable now has a strong reference to the new <bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept> instance, and the <bpt i="2" x="2">&lt;c2&gt;</bpt>unit4A<ept i="2">&lt;/c2&gt;</ept> variable has a strong reference to the new <bpt i="3" x="3">&lt;c3&gt;</bpt>Apartment<ept i="3">&lt;/c3&gt;</ept> instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>john<ept i="0">&lt;/c0&gt;</ept>変数は現在新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept>インスタンスへの強い参照を持ちます、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>unit4A<ept i="2">&lt;/c2&gt;</ept>変数は新しい<bpt i="3" x="3">&lt;c3&gt;</bpt>Apartment<ept i="3">&lt;/c3&gt;</ept>インスタンスへの強い参照を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>makeIncrementer(forIncrement:)<ept i="0">&lt;/c0&gt;</ept> function defines an integer variable called <bpt i="1" x="1">&lt;c1&gt;</bpt>runningTotal<ept i="1">&lt;/c1&gt;</ept>, to store the current running total of the incrementer that will be returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>makeIncrementer(forIncrement:)<ept i="0">&lt;/c0&gt;</ept>関数は、返されるincrementerの現在の状態での合計を保存するために、<bpt i="1" x="1">&lt;c1&gt;</bpt>runningTotal<ept i="1">&lt;/c1&gt;</ept>と呼ばれる整数変数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>makeIncrementer(forIncrement:)<ept i="0">&lt;/c0&gt;</ept> function has a single <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> parameter with an argument label of <bpt i="2" x="2">&lt;c2&gt;</bpt>forIncrement<ept i="2">&lt;/c2&gt;</ept>, and a parameter name of <bpt i="3" x="3">&lt;c3&gt;</bpt>amount<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>makeIncrementer(forIncrement:)<ept i="0">&lt;/c0&gt;</ept>関数は、<bpt i="2" x="2">&lt;c2&gt;</bpt>forIncrement<ept i="2">&lt;/c2&gt;</ept>の引数ラベル、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>amount<ept i="3">&lt;/c3&gt;</ept>のパラメータ名を持つ、ただ１つの<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>makeIterator()<ept i="0">&lt;/c0&gt;</ept> method is called on the <bpt i="1" x="1">&lt;e1&gt;</bpt>collection<ept i="1">&lt;/e1&gt;</ept> expression to obtain a value of an iterator type—that is, a type that conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>IteratorProtocol<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>makeIterator()<ept i="0">&lt;/c0&gt;</ept>メソッドが<bpt i="1" x="1">&lt;e1&gt;</bpt>collection（コレクション）<ept i="1">&lt;/e1&gt;</ept>式の上で呼ばれて、イテレータ型 ― すなわち、<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>IteratorProtocol<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠する型、に属する１つの値を取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>map(_:)<ept i="0">&lt;/c0&gt;</ept> method calls the closure expression once for each item in the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>map(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドは、配列の中の各項目に対して一度だけクロージャ式を呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>message<ept i="0">&lt;/c0&gt;</ept> argument is used to provide a textual message that’s displayed by the compiler when emitting a warning or error about the use of a deprecated or obsoleted declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>message<ept i="0">&lt;/c0&gt;</ept>引数は、非推奨または廃止された宣言の使用について警告やエラーを発するときにコンパイラによって表示されるテキストメッセージを提供するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>minMax(array:)<ept i="0">&lt;/c0&gt;</ept> function above returns a tuple containing two <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="0" x="0">&lt;c0&gt;</bpt>minMax(array:)<ept i="0">&lt;/c0&gt;</ept>関数は、２つの<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値を含んでいるタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>minMax(array:)<ept i="0">&lt;/c0&gt;</ept> function returns a tuple containing two <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>minMax(array:)<ept i="0">&lt;/c0&gt;</ept>関数は、２つの<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値を含んでいる１つのタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>number<ept i="0">&lt;/c0&gt;</ept> property of the <bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept> class is defined with a type of <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt64<ept i="2">&lt;/c2&gt;</ept> rather than <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>, to ensure that the <bpt i="4" x="4">&lt;c4&gt;</bpt>number<ept i="4">&lt;/c4&gt;</ept> property’s capacity is large enough to store a 16-digit card number on both 32-bit and 64-bit systems.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept>クラスの<bpt i="0" x="0">&lt;c0&gt;</bpt>number<ept i="0">&lt;/c0&gt;</ept>プロパティは、<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt64<ept i="2">&lt;/c2&gt;</ept>の型で定義されます、<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>ではなく、それによって<bpt i="4" x="4">&lt;c4&gt;</bpt>number<ept i="4">&lt;/c4&gt;</ept>プロパティの容量が32bitと64bitシステムの両方で16桁のカード番号を格納するのに十分に大きいことを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>number<ept i="0">&lt;/c0&gt;</ept> variable is then divided by <bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>number<ept i="0">&lt;/c0&gt;</ept>変数は、それから<bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>で割られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept> attribute is also implicitly added in the following cases:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept>属性はまた、以下の場合において暗黙的に加えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept> attribute optionally accepts a single attribute argument, which consists of an identifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept>属性は、任意にただ１つだけ属性引数を受け入れます、それはひとつの識別子から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept> attribute tells the compiler that a declaration is available to use in Objective-C code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept>属性は、コンパイラにある宣言がObjective-Cコードにおいて使われることが可能であるのを伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>objects<ept i="0">&lt;/c0&gt;</ept> array can now be iterated, and each object in the array can be checked to see if it conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>HasArea<ept i="1">&lt;/c1&gt;</ept> protocol:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>objects<ept i="0">&lt;/c0&gt;</ept>配列は、今や繰り返されることができます、そして配列の各オブジェクトはそれが<bpt i="1" x="1">&lt;c1&gt;</bpt>HasArea<ept i="1">&lt;/c1&gt;</ept>プロトコルに従うかどうかを確認されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>objects<ept i="0">&lt;/c0&gt;</ept> array is initialized with an array literal containing a <bpt i="1" x="1">&lt;c1&gt;</bpt>Circle<ept i="1">&lt;/c1&gt;</ept> instance with a radius of 2 units; a <bpt i="2" x="2">&lt;c2&gt;</bpt>Country<ept i="2">&lt;/c2&gt;</ept> instance initialized with the surface area of the United Kingdom in square kilometers; and an <bpt i="3" x="3">&lt;c3&gt;</bpt>Animal<ept i="3">&lt;/c3&gt;</ept> instance with four legs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>objects<ept i="0">&lt;/c0&gt;</ept>配列は、単位２の半径をもつ<bpt i="1" x="1">&lt;c1&gt;</bpt>Circle<ept i="1">&lt;/c1&gt;</ept>インスタンスを含んでいる配列リテラル；平方キロメートルでの英国の面積で初期化される<bpt i="2" x="2">&lt;c2&gt;</bpt>Country<ept i="2">&lt;/c2&gt;</ept>インスタンス；そして、４本脚の<bpt i="3" x="3">&lt;c3&gt;</bpt>Animal<ept i="3">&lt;/c3&gt;</ept>インスタンス；を含んでいる配列リテラルで初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>obsoleted<ept i="0">&lt;/c0&gt;</ept> argument indicates the first version of the specified platform or language in which the declaration was obsoleted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>obsoleted<ept i="0">&lt;/c0&gt;</ept>引数は、そこにおいてその宣言が廃止とされたところの、指定されたプラットホームまたは言語の最初のバージョンを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept> keyword also prompts the Swift compiler to check that your overriding class’s superclass (or one of its parents) has a declaration that matches the one you provided for the override.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept>キーワードはまた、あなたのオーバーライドしているクラスのスーパークラス（またはその親のうちの１つ）が、そのオーバーライドのためにあなたが提供するものと合致する宣言を持っていることを確認するように、スウィフトのコンパイラを促します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>paragraph<ept i="0">&lt;/c0&gt;</ept> variable above is defined as an <bpt i="1" x="1">&lt;e1&gt;</bpt>optional<ept i="1">&lt;/e1&gt;</ept> <bpt i="2" x="2">&lt;c2&gt;</bpt>HTMLElement<ept i="2">&lt;/c2&gt;</ept>, so that it can be set to <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> below to demonstrate the presence of a strong reference cycle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上記の<bpt i="0" x="0">&lt;c0&gt;</bpt>paragraph<ept i="0">&lt;/c0&gt;</ept>変数は、<bpt i="1" x="1">&lt;e1&gt;</bpt>オプショナル<ept i="1">&lt;/e1&gt;</ept>の<bpt i="2" x="2">&lt;c2&gt;</bpt>HTMLElement<ept i="2">&lt;/c2&gt;</ept>として定義されます、それでそれは下で強い参照循環の存在を例示するために<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>に設定されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>prettyTextualDescription<ept i="0">&lt;/c0&gt;</ept> property can now be used to print a pretty text description of any <bpt i="1" x="1">&lt;c1&gt;</bpt>SnakesAndLadders<ept i="1">&lt;/c1&gt;</ept> instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt>prettyTextualDescription<ept i="0">&lt;/c0&gt;</ept>プロパティは、現在あらゆる<bpt i="1" x="1">&lt;c1&gt;</bpt>SnakesAndLadders<ept i="1">&lt;/c1&gt;</ept>インスタンスのきれいなテキスト解説を出力するために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:separator:terminator:)<ept i="0">&lt;/c0&gt;</ept> function doesn’t have a label for its first argument, and its other arguments are optional because they have a default value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:separator:terminator:)<ept i="0">&lt;/c0&gt;</ept>関数は、それの最初の引数に対してラベルを持ちません、そしてそれの他の引数は任意です、それらが省略時の値を持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:separator:terminator:)<ept i="0">&lt;/c0&gt;</ept> function is a global function that prints one or more values to an appropriate output.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:separator:terminator:)<ept i="0">&lt;/c0&gt;</ept>関数は、ひとつ以上の値を適切な出力先に出力するグローバルな関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>printNumberOfRooms()<ept i="0">&lt;/c0&gt;</ept> method on the <bpt i="1" x="1">&lt;c1&gt;</bpt>Residence<ept i="1">&lt;/c1&gt;</ept> class prints the current value of <bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfRooms<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Residence<ept i="1">&lt;/c1&gt;</ept>クラス上の<bpt i="0" x="0">&lt;c0&gt;</bpt>printNumberOfRooms()<ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfRooms<ept i="2">&lt;/c2&gt;</ept>の現在の値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>receive(coins:)<ept i="0">&lt;/c0&gt;</ept> method simply adds the received number of coins back into the bank’s coin store.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>receive(coins:)<ept i="0">&lt;/c0&gt;</ept>メソッドは、単純に受け取ったコインの数を胴元のコインの蓄えに戻すよう加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>renamed<ept i="0">&lt;/c0&gt;</ept> argument is used to provide a textual message that indicates the new name for a declaration that’s been renamed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>renamed<ept i="0">&lt;/c0&gt;</ept>引数は、改名された宣言の新しい名前を指し示すテキストメッセージを提供するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>repeat<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept> loop in Swift is analogous to a <bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept> loop in other languages.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>repeat<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept>ループは、他の言語の<bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept>ループと類似したものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>repetitions(task:)<ept i="0">&lt;/c0&gt;</ept> method takes a single argument of type <bpt i="1" x="1">&lt;c1&gt;</bpt>() -&gt; Void<ept i="1">&lt;/c1&gt;</ept>, which indicates a function that has no parameters and does not return a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>repetitions(task:)<ept i="0">&lt;/c0&gt;</ept>メソッドは型<bpt i="1" x="1">&lt;c1&gt;</bpt>() -&gt; Void<ept i="1">&lt;/c1&gt;</ept>の引数をひとつだけとります、それは、パラメータを持たず、値を返さない関数であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> expression is an explicit reference to the current type or instance of the type in which it occurs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>式は、それがその中に現れているところの現在の型や型のインスタンスへの明確な参照です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> expression is used to specify scope when accessing members, providing disambiguation when there is another variable of the same name in scope, such as a function parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>式は、メンバーにアクセスする時にスコープを指定するために使われて、関数パラメータなど、同じ名前の別の変数がスコープ内にある場合に一義化を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>serve(customer:)<ept i="0">&lt;/c0&gt;</ept> function in the listing above takes an explicit closure that returns a customer’s name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上で記載される<bpt i="0" x="0">&lt;c0&gt;</bpt>serve(customer:)<ept i="0">&lt;/c0&gt;</ept>関数は、次の顧客の名前を返す、ある明示的なクロージャを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>shoppingList<ept i="0">&lt;/c0&gt;</ept> array is declared as a variable (with the <bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept> introducer) and not a constant (with the <bpt i="2" x="2">&lt;c2&gt;</bpt>let<ept i="2">&lt;/c2&gt;</ept> introducer) because more items are added to the shopping list in the examples below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>shoppingList<ept i="0">&lt;/c0&gt;</ept>配列は、変数として（<bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept>導入子を使って）宣言されます、定数（<bpt i="2" x="2">&lt;c2&gt;</bpt>let<ept i="2">&lt;/c2&gt;</ept>導入子を使って）ではなく、なぜならより多くの項目が下記の例で購入品目リストに加えられるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>shoppingList<ept i="0">&lt;/c0&gt;</ept> variable is declared as “an array of string values”, written as <bpt i="1" x="1">&lt;c1&gt;</bpt>[String]<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>shoppingList<ept i="0">&lt;/c0&gt;</ept>変数は、「String値の配列」として宣言され、<bpt i="1" x="1">&lt;c1&gt;</bpt>[String]<ept i="1">&lt;/c1&gt;</ept>のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>someFunctionWithEscapingClosure(_:)<ept i="0">&lt;/c0&gt;</ept> function takes a closure as its argument and adds it to an array that’s declared outside the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>someFunctionWithEscapingClosure(_:)<ept i="0">&lt;/c0&gt;</ept>関数は、クロージャをそれの引数として取ります、そしてそれを関数の外側で宣言される配列に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept> method accepts a closure that takes two arguments of the same type as the array’s contents, and returns a <bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept> value to say whether the first value should appear before or after the second value once the values are sorted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept>メソッドは、配列の内容物と同じ型の２つの引数をとり、そしてひとたび値が分類されるならば最初の値が第２の値の前か後のどちらに現れなければならないのかを伝える<bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept>値を返すクロージャを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept> method is being called on an array of strings, so its argument must be a function of type <bpt i="1" x="1">&lt;c1&gt;</bpt>(String, String) -&gt; Bool<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept>メソッドは文字列の配列上で呼ばれています、それでそれの引数は型<bpt i="1" x="1">&lt;c1&gt;</bpt>(String, String) -&gt; Bool<ept i="1">&lt;/c1&gt;</ept>の関数でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>square<ept i="0">&lt;/c0&gt;</ept> variable’s <bpt i="1" x="1">&lt;c1&gt;</bpt>center<ept i="1">&lt;/c1&gt;</ept> property is then accessed through dot syntax (<bpt i="2" x="2">&lt;c2&gt;</bpt>square.center<ept i="2">&lt;/c2&gt;</ept>), which causes the getter for <bpt i="3" x="3">&lt;c3&gt;</bpt>center<ept i="3">&lt;/c3&gt;</ept> to be called, to retrieve the current property value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>square<ept i="0">&lt;/c0&gt;</ept>変数の<bpt i="1" x="1">&lt;c1&gt;</bpt>center<ept i="1">&lt;/c1&gt;</ept>プロパティは、それからドット構文（<bpt i="2" x="2">&lt;c2&gt;</bpt>square.center<ept i="2">&lt;/c2&gt;</ept>）を通してアクセスされます、それによって<bpt i="3" x="3">&lt;c3&gt;</bpt>center<ept i="3">&lt;/c3&gt;</ept>のためのゲッターが呼び出されて、現在のプロパティ値を取り出すことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>startsWith(_:)<ept i="0">&lt;/c0&gt;</ept> method first makes sure that the container has at least one item, and then it checks whether the first item in the container matches the given item.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>startsWith(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドはまず、コンテナが少なくとも１つの項目を持つことを確かめます、それからそれはそのコンテナの最初の項目が与えられた項目と合致するかどうか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept> function is useful, but it can only be used with <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数は役に立ちます、しかし、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値で使われることができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept> function simply swaps the value of <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept> into <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>, and the value of <bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept> into <bpt i="4" x="4">&lt;c4&gt;</bpt>b<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数は、単に<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>の値を<bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>の中に、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept>の値を<bpt i="4" x="4">&lt;c4&gt;</bpt>b<ept i="4">&lt;/c4&gt;</ept>の中へと入れ替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept> function swaps the original value of <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept> into <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>, and the original value of <bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept> into <bpt i="4" x="4">&lt;c4&gt;</bpt>b<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数は、<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>の元々の値を<bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>の中へ、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept>の元々の値を<bpt i="4" x="4">&lt;c4&gt;</bpt>b<ept i="4">&lt;/c4&gt;</ept>の中へと交換します、そして、最初の値のにb。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts<ept i="0">&lt;/c0&gt;</ept> example above does not define a return type or return a value, but it still modifies the values of <bpt i="1" x="1">&lt;c1&gt;</bpt>someInt<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>anotherInt<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts<ept i="0">&lt;/c0&gt;</ept>例は、戻り型を定義しないし、また値を返しません、しかしそれでもそれは<bpt i="1" x="1">&lt;c1&gt;</bpt>someInt<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>anotherInt<ept i="2">&lt;/c2&gt;</ept>の値を修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoValues(_:_:)<ept i="0">&lt;/c0&gt;</ept> function and the <bpt i="1" x="1">&lt;c1&gt;</bpt>Stack<ept i="1">&lt;/c1&gt;</ept> type can work with any type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoValues(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数と<bpt i="1" x="1">&lt;c1&gt;</bpt>Stack<ept i="1">&lt;/c1&gt;</ept>型は、どんな型でも扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoValues(_:_:)<ept i="0">&lt;/c0&gt;</ept> function can now be called in the same way as <bpt i="1" x="1">&lt;c1&gt;</bpt>swapTwoInts<ept i="1">&lt;/c1&gt;</ept>, except that it can be passed two values of <bpt i="2" x="2">&lt;e2&gt;</bpt>any<ept i="2">&lt;/e2&gt;</ept> type, as long as both of those values are of the same type as each other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoValues(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数は現在<bpt i="1" x="1">&lt;c1&gt;</bpt>swapTwoInts<ept i="1">&lt;/c1&gt;</ept>と同じやり方で呼ばれることができます、しかしそれが<bpt i="2" x="2">&lt;e2&gt;</bpt>あらゆる<ept i="2">&lt;/e2&gt;</ept>型の２つの値を渡されることが、それらの値の両方が互いに同じ型である限り可能であるのを除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoValues(_:_:)<ept i="0">&lt;/c0&gt;</ept> function defined above is inspired by a generic function called <bpt i="1" x="1">&lt;c1&gt;</bpt>swap<ept i="1">&lt;/c1&gt;</ept>, which is part of the Swift standard library, and is automatically made available for you to use in your apps.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上で定義される<bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoValues(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数は<bpt i="1" x="1">&lt;c1&gt;</bpt>swap<ept i="1">&lt;/c1&gt;</ept>と呼ばれる総称体関数に着想を得たものです、それは、スウィフト標準ライブラリの一部であって、あなたのアプリにおいて自動的にあなたが使うことが可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>swift<ept i="0">&lt;/c0&gt;</ept> argument is used to indicate a Swift function reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>swift<ept i="0">&lt;/c0&gt;</ept>引数は、スウィフト関数参照を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement determines whether the point is at the origin (0, 0), on the red x-axis, on the orange y-axis, inside the blue 4-by-4 box centered on the origin, or outside of the box.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文は、そのポイントがあるのは、原点(0, 0)、赤いx-軸上、オレンジのy-軸上、原点を中心とした青の４×４の四角の内側、または四角の外側かどうかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement determines whether the point is on the green diagonal line where <bpt i="1" x="1">&lt;c1&gt;</bpt>x == y<ept i="1">&lt;/c1&gt;</ept>, on the purple diagonal line where <bpt i="2" x="2">&lt;c2&gt;</bpt>x == -y<ept i="2">&lt;/c2&gt;</ept>, or neither.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文は、そのポイントが、<bpt i="1" x="1">&lt;c1&gt;</bpt>x == y<ept i="1">&lt;/c1&gt;</ept>であるところの緑の斜線上、あるいは<bpt i="2" x="2">&lt;c2&gt;</bpt>x == -y<ept i="2">&lt;/c2&gt;</ept>であるところの紫の斜線上にあるかどうかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement determines whether the point is on the red x-axis, on the orange y-axis, or elsewhere (on neither axis).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文は、この地点が、赤のx-軸上、オレンジのy-軸上、または他のどこか（どちらの軸上でもない）かを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement’s first case matches all five lowercase vowels in the English language.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文の最初のケース節は、英語における５つの小文字の母音字すべてにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement’s first case matches the first letter of the English alphabet, <bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept>, and its second case matches the last letter, <bpt i="2" x="2">&lt;c2&gt;</bpt>z<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文の最初のケース節は、英語アルファペットの最初の文字、<bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept>にマッチします、そしてそれの２番目のケース節は最後の文字、<bpt i="2" x="2">&lt;c2&gt;</bpt>z<ept i="2">&lt;/c2&gt;</ept>にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>textualDescription<ept i="0">&lt;/c0&gt;</ept> property returns the textual description of the entire collection by concatenating the textual representation of each element in the collection into a comma-separated list, enclosed in brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>textualDescription<ept i="0">&lt;/c0&gt;</ept>プロパティは、コレクション全体の解説テキストを、コレクションの中の各要素のテキスト表現をコンマ区切りのリストへと連結して、角括弧に囲むことによって返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>things<ept i="0">&lt;/c0&gt;</ept> array contains two <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> values, two <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept> values, a <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> value, a tuple of type <bpt i="4" x="4">&lt;c4&gt;</bpt>(Double, Double)<ept i="4">&lt;/c4&gt;</ept>, the movie “Ghostbusters”, and a closure expression that takes a <bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept> value and returns another <bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>things<ept i="0">&lt;/c0&gt;</ept>配列は、２つの<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値、２つの<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>値、１つの<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>値、型<bpt i="4" x="4">&lt;c4&gt;</bpt>(Double, Double)<ept i="4">&lt;/c4&gt;</ept>のタプル、映画「ゴーストバスターズ」、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept>値をとって別の<bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>値を返す一つのクロージャ式を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>throws<ept i="0">&lt;/c0&gt;</ept> keyword is part of a function’s type, and nonthrowing functions are subtypes of throwing functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>throws<ept i="0">&lt;/c0&gt;</ept>キーワードは関数の型の一部です、そしてスローを行わない関数はスロー関数の下位型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>toggle()<ept i="0">&lt;/c0&gt;</ept> method is marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>mutating<ept i="1">&lt;/c1&gt;</ept> keyword as part of the <bpt i="2" x="2">&lt;c2&gt;</bpt>Togglable<ept i="2">&lt;/c2&gt;</ept> protocol definition, to indicate that the method is expected to mutate the state of a conforming instance when it’s called:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>toggle()<ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Togglable<ept i="2">&lt;/c2&gt;</ept>プロトコル定義の一部として<bpt i="1" x="1">&lt;c1&gt;</bpt>mutating<ept i="1">&lt;/c1&gt;</ept>キーワードで印されます、それによってそのメソッドが、それが呼ばれるとき準拠インスタンスの状態を変化させることを予期されるようにします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>topItem<ept i="0">&lt;/c0&gt;</ept> computed property can now be used with any <bpt i="1" x="1">&lt;c1&gt;</bpt>Stack<ept i="1">&lt;/c1&gt;</ept> instance to access and query its top item without removing it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>topItem<ept i="0">&lt;/c0&gt;</ept>計算プロパティは、今やあらゆる<bpt i="1" x="1">&lt;c1&gt;</bpt>Stack<ept i="1">&lt;/c1&gt;</ept>インスタンスで、それの一番上の項目にそれを取り除くことなくアクセスおよび問い合わせるために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>topItem<ept i="0">&lt;/c0&gt;</ept> property returns an optional value of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>topItem<ept i="0">&lt;/c0&gt;</ept>プロパティは型<bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>unavailable<ept i="0">&lt;/c0&gt;</ept> argument indicates that the declaration isn’t available on the specified platform.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>unavailable<ept i="0">&lt;/c0&gt;</ept>引数は、その宣言が指定されたプラットホーム上で利用可能でないことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>updateValue(_:forKey:)<ept i="0">&lt;/c0&gt;</ept> method returns an optional value of the dictionary’s value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>updateValue(_:forKey:)<ept i="0">&lt;/c0&gt;</ept>メソッドは、その辞書の値型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>userDefinedColorName<ept i="0">&lt;/c0&gt;</ept> variable is defined as an optional <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>, with a default value of <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>userDefinedColorName<ept i="0">&lt;/c0&gt;</ept>変数は、省略時の値の<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>を持つ、あるオプショナルの<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept> properties for the first three <bpt i="1" x="1">&lt;c1&gt;</bpt>UnicodeScalar<ept i="1">&lt;/c1&gt;</ept> values (<bpt i="2" x="2">&lt;c2&gt;</bpt>68<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>111<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>103<ept i="4">&lt;/c4&gt;</ept>) once again represent the characters <bpt i="5" x="5">&lt;c5&gt;</bpt>D<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>o<ept i="6">&lt;/c6&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>g<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の３つの<bpt i="1" x="1">&lt;c1&gt;</bpt>UnicodeScalar<ept i="1">&lt;/c1&gt;</ept>値（<bpt i="2" x="2">&lt;c2&gt;</bpt>68<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>111<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>103<ept i="4">&lt;/c4&gt;</ept>）のための<bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>プロパティは、またふたたび文字<bpt i="5" x="5">&lt;c5&gt;</bpt>D<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>o<ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>g<ept i="7">&lt;/c7&gt;</ept>を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept> property of the fifth and final <bpt i="1" x="1">&lt;c1&gt;</bpt>UnicodeScalar<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>128054<ept i="2">&lt;/c2&gt;</ept>, is a decimal equivalent of the hexadecimal value <bpt i="3" x="3">&lt;c3&gt;</bpt>1F436<ept i="3">&lt;/c3&gt;</ept>, which represents the Unicode scalar <bpt i="4" x="4">&lt;c4&gt;</bpt>U+1F436<ept i="4">&lt;/c4&gt;</ept> for the <bpt i="5" x="5">&lt;c5&gt;</bpt>DOG FACE<ept i="5">&lt;/c5&gt;</ept> character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>５番目で最後の<bpt i="1" x="1">&lt;c1&gt;</bpt>UnicodeScalar<ept i="1">&lt;/c1&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>プロパティ、<bpt i="2" x="2">&lt;c2&gt;</bpt>128054<ept i="2">&lt;/c2&gt;</ept>は、16進の値<bpt i="3" x="3">&lt;c3&gt;</bpt>1F436<ept i="3">&lt;/c3&gt;</ept>の10進の等価物です、そしてそれは、<bpt i="5" x="5">&lt;c5&gt;</bpt>DOG FACE<ept i="5">&lt;/c5&gt;</ept>文字のためのユニコード・スカラー<bpt i="4" x="4">&lt;c4&gt;</bpt>U+1F436<ept i="4">&lt;/c4&gt;</ept>を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>welcomeMessage<ept i="0">&lt;/c0&gt;</ept> variable can now be set to any string value without error:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>welcomeMessage<ept i="0">&lt;/c0&gt;</ept>変数は、現在エラーなしでどんな文字列値にでも設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> loop’s condition is <bpt i="1" x="1">&lt;c1&gt;</bpt>while square != finalSquare<ept i="1">&lt;/c1&gt;</ept>, to reflect that you must land exactly on square 25.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>ループの条件は、あなたが正確に正方形25に到着しなければならないことを反映する、<bpt i="1" x="1">&lt;c1&gt;</bpt>while square != finalSquare<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept> observers for <bpt i="2" x="2">&lt;c2&gt;</bpt>totalSteps<ept i="2">&lt;/c2&gt;</ept> are called whenever the property is assigned a new value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>totalSteps<ept i="2">&lt;/c2&gt;</ept>のための<bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept>オブザーバーは、プロパティが新しい値を代入されるときはいつでも呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept> observers of superclass properties are called when a property is set in a subclass initializer, after the superclass initializer has been called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラスプロパティの<bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept>オブザーバーは、スーパークラスイニシャライザが呼び出され終わった後、あるプロパティがサプクラスのイニシャライザにおいて設定される時に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept> observers provide a way to observe (and to respond appropriately) when the value of a variable or property is being set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept>オブザーバーは、変数またはプロパティの値が設定されている時に監視する（そして適切に応答する）方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>wiseWords<ept i="0">&lt;/c0&gt;</ept> constant contains two escaped double quote characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数の<bpt i="0" x="0">&lt;c0&gt;</bpt>wiseWords<ept i="0">&lt;/c0&gt;</ept>は、２つのエスケープされた二重引用符文字を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="10" x="10">&lt;c10&gt;</bpt>COMBINING ACUTE ACCENT<ept i="10">&lt;/c10&gt;</ept> scalar is graphically applied to the scalar that precedes it, turning an <bpt i="11" x="11">&lt;c11&gt;</bpt>e<ept i="11">&lt;/c11&gt;</ept> into an <bpt i="12" x="12">&lt;c12&gt;</bpt>é<ept i="12">&lt;/c12&gt;</ept> when it’s rendered by a Unicode-aware text-rendering system.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="10" x="10">&lt;c10&gt;</bpt>COMBINING ACUTE ACCENT<ept i="10">&lt;/c10&gt;</ept>スカラーは、それの前のスカラーに追加筆記され、<bpt i="11" x="11">&lt;c11&gt;</bpt>e<ept i="11">&lt;/c11&gt;</ept>を、それがユニコードに通じたテキスト描画システムによって表わされる時に、<bpt i="12" x="12">&lt;c12&gt;</bpt>é<ept i="12">&lt;/c12&gt;</ept>にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="10" x="10">&lt;c10&gt;</bpt>name<ept i="10">&lt;/c10&gt;</ept> property is automatically given a default value of <bpt i="11" x="11">&lt;c11&gt;</bpt>nil<ept i="11">&lt;/c11&gt;</ept>, or “no <bpt i="12" x="12">&lt;c12&gt;</bpt>name<ept i="12">&lt;/c12&gt;</ept> value”, because it is of an optional type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="10" x="10">&lt;c10&gt;</bpt>name<ept i="10">&lt;/c10&gt;</ept>プロパティは省略時の値の<bpt i="11" x="11">&lt;c11&gt;</bpt>nil<ept i="11">&lt;/c11&gt;</ept>、つまり「<bpt i="12" x="12">&lt;c12&gt;</bpt>name<ept i="12">&lt;/c12&gt;</ept>値なし」を自動的に与えられます、なぜならそれがオプショナル型であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>BlackjackCard<ept i="1">&lt;/c1&gt;</ept> structure contains two nested enumeration types called <bpt i="2" x="2">&lt;c2&gt;</bpt>Suit<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Rank<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>BlackjackCard<ept i="1">&lt;/c1&gt;</ept>構造体は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Suit<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>Rank<ept i="3">&lt;/c3&gt;</ept>と呼ばれる２つの入れ子にされた列挙型を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>Celsius<ept i="1">&lt;/c1&gt;</ept> structure implements two custom initializers called <bpt i="2" x="2">&lt;c2&gt;</bpt>init(fromFahrenheit:)<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>init(fromKelvin:)<ept i="3">&lt;/c3&gt;</ept>, which initialize a new instance of the structure with a value from a different temperature scale:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Celsius<ept i="1">&lt;/c1&gt;</ept>構造体は、<bpt i="2" x="2">&lt;c2&gt;</bpt>init(fromFahrenheit:)<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>init(fromKelvin:)<ept i="3">&lt;/c3&gt;</ept>と呼ばれる２つのあつらえのイニシャライザを実装します、それは、その構造体の新しいインスタンスを異なる温度尺度の値を使って初期化します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept> protocol needs to specify that any value passed to the <bpt i="2" x="2">&lt;c2&gt;</bpt>append(_:)<ept i="2">&lt;/c2&gt;</ept> method must have the same type as the container’s element type, and that the value returned by the container’s subscript will be of the same type as the container’s element type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept>プロトコルは、<bpt i="2" x="2">&lt;c2&gt;</bpt>append(_:)<ept i="2">&lt;/c2&gt;</ept>メソッドに渡されるあらゆる値がそのコンテナの要素の型と同じ型を持たなければならないこと、そしてコンテナの添え字によって返される値がコンテナの要素型と同じ型のものになることを指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>DiceGameDelegate<ept i="1">&lt;/c1&gt;</ept> protocol can be adopted by any type to track the progress of a <bpt i="2" x="2">&lt;c2&gt;</bpt>DiceGame<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>DiceGameDelegate<ept i="1">&lt;/c1&gt;</ept>プロトコルは、どんな型によってでも採用されることができて、ある<bpt i="2" x="2">&lt;c2&gt;</bpt>DiceGame<ept i="2">&lt;/c2&gt;</ept>の進歩を追いかけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>Fahrenheit<ept i="1">&lt;/c1&gt;</ept> structure has one stored property, <bpt i="2" x="2">&lt;c2&gt;</bpt>temperature<ept i="2">&lt;/c2&gt;</ept>, which is of type <bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Fahrenheit<ept i="1">&lt;/c1&gt;</ept>構造体は、１つの保存プロパティ、<bpt i="2" x="2">&lt;c2&gt;</bpt>temperature<ept i="2">&lt;/c2&gt;</ept>を持ちます、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept>型です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>Food<ept i="1">&lt;/c1&gt;</ept> class introduces a single <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> property called <bpt i="3" x="3">&lt;c3&gt;</bpt>name<ept i="3">&lt;/c3&gt;</ept> and provides two initializers for creating <bpt i="4" x="4">&lt;c4&gt;</bpt>Food<ept i="4">&lt;/c4&gt;</ept> instances:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Food<ept i="1">&lt;/c1&gt;</ept>クラスは、<bpt i="3" x="3">&lt;c3&gt;</bpt>name<ept i="3">&lt;/c3&gt;</ept>と呼ばれる一つの<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>プロパティを導入して、２つのイニシャライザを<bpt i="4" x="4">&lt;c4&gt;</bpt>Food<ept i="4">&lt;/c4&gt;</ept>インスタンスをつくるために提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>Point<ept i="1">&lt;/c1&gt;</ept> example shown above could have been written in the following way instead:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上で示される<bpt i="1" x="1">&lt;c1&gt;</bpt>Point<ept i="1">&lt;/c1&gt;</ept>の例は、その代わりに以下のようにして書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>break<ept i="1">&lt;/c1&gt;</ept> statement can be used inside a <bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept> or loop statement when you want to terminate the execution of the <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> or loop statement earlier than would otherwise be the case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>break<ept i="1">&lt;/c1&gt;</ept>文は、これを使わなかった場合よりも早く<bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept>またはループ文の実行をあなたが終了したい時に、<bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>やループ文の内側で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>continue gameLoop<ept i="1">&lt;/c1&gt;</ept> statement ends the current <bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept> loop iteration and begins the next iteration of the loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>continue gameLoop<ept i="1">&lt;/c1&gt;</ept>文は、現在の<bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept>ループ繰り返しを終えて、ループの次の繰り返しを開始します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>dollarSign<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>blackHeart<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>sparklingHeart<ept i="3">&lt;/c3&gt;</ept> constants demonstrate the Unicode scalar format:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>dollarSign<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>blackHeart<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>sparklingHeart<ept i="3">&lt;/c3&gt;</ept>定数は、Unicodeスカラーの書式を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>grid<ept i="1">&lt;/c1&gt;</ept> array for this <bpt i="2" x="2">&lt;c2&gt;</bpt>Matrix<ept i="2">&lt;/c2&gt;</ept> instance is effectively a flattened version of the matrix, as read from top left to bottom right:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="2" x="2">&lt;c2&gt;</bpt>Matrix<ept i="2">&lt;/c2&gt;</ept>インスタンスのための<bpt i="1" x="1">&lt;c1&gt;</bpt>grid<ept i="1">&lt;/c1&gt;</ept>配列は、実際にはこのMatrix 行列の、左上から右下へと読まれる、平らにされた改変板です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>let<ept i="1">&lt;/c1&gt;</ept> keyword is only used for constant properties, to indicate that their values cannot be changed once they are set as part of instance initialization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>let<ept i="1">&lt;/c1&gt;</ept>キーワードは定数プロパティのためにだけ使われます、そして一旦それがインスタンス初期化の一部として設定されるならば、その値が変わることができないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>nonobjc<ept i="1">&lt;/c1&gt;</ept> attribute tells the compiler to make the declaration unavailable in Objective-C code, even though it’s possible to represent it in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>nonobjc<ept i="1">&lt;/c1&gt;</ept>属性は、コンパイラにその宣言がObjective-Cコードにおいて利用不可にされることを伝えます、たとえそれがObjective-Cにおいて表現可能であってもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept> attribute is implicitly added to Objective-C compatible members of the class, its extensions, its subclasses, and all of the extensions of its subclasses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept>属性は、暗黙的にそのクラスのObjective-C互換メンバー、それの拡張、それのサブクラス、そしてそれのサブクラスの拡張の全てに加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>optional<ept i="1">&lt;/c1&gt;</ept> modifier can be applied only to members that are marked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>objc<ept i="2">&lt;/c2&gt;</ept> attribute, and only to members of protocols that are marked with the <bpt i="3" x="3">&lt;c3&gt;</bpt>objc<ept i="3">&lt;/c3&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>optional<ept i="1">&lt;/c1&gt;</ept>修飾子は、<bpt i="2" x="2">&lt;c2&gt;</bpt>objc<ept i="2">&lt;/c2&gt;</ept>属性で印されるメンバにだけ、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>objc<ept i="3">&lt;/c3&gt;</ept>属性で印されるプロトコルのメンバにだけ適用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>possibleIntegerValue<ept i="1">&lt;/c1&gt;</ept> variable has an implicit initial value of <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept> by virtue of being an optional type, and so the optional binding will succeed only if <bpt i="3" x="3">&lt;c3&gt;</bpt>possibleIntegerValue<ept i="3">&lt;/c3&gt;</ept> was set to an actual value by one of the <bpt i="4" x="4">&lt;c4&gt;</bpt>switch<ept i="4">&lt;/c4&gt;</ept> statement’s first four cases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>possibleIntegerValue<ept i="1">&lt;/c1&gt;</ept>変数は、オプショナル型であることの長所によって暗黙的な初期値の<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>を持ちます、そのため<bpt i="3" x="3">&lt;c3&gt;</bpt>possibleIntegerValue<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>switch<ept i="4">&lt;/c4&gt;</ept>文の最初の４つのケース節の内の１つによって実際の値に設定された場合にのみこのオプショナル束縛は成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>@escaping<ept i="2">&lt;/c2&gt;</ept> attribute is described above in <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Escaping Closures<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>@escaping<ept i="2">&lt;/c2&gt;</ept>属性は、上の<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>脱出クロージャ<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>で解説されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>AutomaticCar<ept i="2">&lt;/c2&gt;</ept> class represents a car with an automatic gearbox, which automatically selects an appropriate gear to use based on the current speed:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>AutomaticCar<ept i="2">&lt;/c2&gt;</ept>クラスはオートマチック・ギアボックスをもつ車を表します、それは、現在の速度に基づいて自動的に使用するのに適切なギアを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>AutomaticallyNamedDocument<ept i="2">&lt;/c2&gt;</ept> subclass overrides both of the designated initializers introduced by <bpt i="3" x="3">&lt;c3&gt;</bpt>Document<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>AutomaticallyNamedDocument<ept i="2">&lt;/c2&gt;</ept>サブクラスは、<bpt i="3" x="3">&lt;c3&gt;</bpt>Document<ept i="3">&lt;/c3&gt;</ept>で導入される指定イニシャライザを両方ともオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>Bank<ept i="2">&lt;/c2&gt;</ept> class manages a made-up currency, which can never have more than 10,000 coins in circulation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Bank<ept i="2">&lt;/c2&gt;</ept>クラスは、ある架空の通貨を管理します、そしてそれは、流通する10,000個以上のコインを決して持つことができません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>Car<ept i="2">&lt;/c2&gt;</ept> class introduces a new stored property called <bpt i="3" x="3">&lt;c3&gt;</bpt>gear<ept i="3">&lt;/c3&gt;</ept>, with a default integer value of <bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Car<ept i="2">&lt;/c2&gt;</ept>クラスは、<bpt i="3" x="3">&lt;c3&gt;</bpt>gear<ept i="3">&lt;/c3&gt;</ept>と呼ばれる、<bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept>の省略時の値を持つ、新しい保存プロパティを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>CartItem<ept i="2">&lt;/c2&gt;</ept> class models an item in an online shopping cart.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>CartItem<ept i="2">&lt;/c2&gt;</ept>クラスは、あるオンライン買物かごの中のひとつの項目をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>Counter<ept i="2">&lt;/c2&gt;</ept> class also defines a method called <bpt i="3" x="3">&lt;c3&gt;</bpt>increment<ept i="3">&lt;/c3&gt;</ept>, which increments the <bpt i="4" x="4">&lt;c4&gt;</bpt>count<ept i="4">&lt;/c4&gt;</ept> property every time the method is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Counter<ept i="2">&lt;/c2&gt;</ept>クラスはまた、<bpt i="3" x="3">&lt;c3&gt;</bpt>increment<ept i="3">&lt;/c3&gt;</ept>と呼ばれるメソッドを定義します、それは、メソッドが呼ばれるたびに<bpt i="4" x="4">&lt;c4&gt;</bpt>count<ept i="4">&lt;/c4&gt;</ept>プロパティを増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>Matrix<ept i="2">&lt;/c2&gt;</ept> structure’s subscript takes two integer parameters:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Matrix<ept i="2">&lt;/c2&gt;</ept>構造体の添え字は、２つの整数パラメータをとります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>Person<ept i="2">&lt;/c2&gt;</ept> class also has a deinitializer that prints a message when an instance of the class is deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Person<ept i="2">&lt;/c2&gt;</ept>クラスはまた、クラスのインスタンスが割り当て解除されるとき、メッセージを出力するデイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>Player<ept i="2">&lt;/c2&gt;</ept> class also implements a deinitializer, which is called just before a <bpt i="3" x="3">&lt;c3&gt;</bpt>Player<ept i="3">&lt;/c3&gt;</ept> instance is deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Player<ept i="2">&lt;/c2&gt;</ept>クラスはまた、デイニシャライザを実装します、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>Player<ept i="3">&lt;/c3&gt;</ept>インスタンスが割り当て解除される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>RecipeIngredient<ept i="2">&lt;/c2&gt;</ept> class models an ingredient in a cooking recipe.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>RecipeIngredient<ept i="2">&lt;/c2&gt;</ept>クラスは、料理のレシピの材料をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>ShoppingListItem<ept i="2">&lt;/c2&gt;</ept> class models a recipe ingredient as it appears in a shopping list.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>ShoppingListItem<ept i="2">&lt;/c2&gt;</ept>クラスは、それが購入品目リストに現れるように、レシピの材料をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>Values<ept i="2">&lt;/c2&gt;</ept> structure defines two properties to represent this:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Values<ept i="2">&lt;/c2&gt;</ept>構造体は、これを表すために２つのプロパティを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept> in the inner scope is initialized with the value of the <bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept> in the outer scope when the closure is created, but their values are not connected in any special way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>内側のスコープの中の<bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>は、クロージャが作成される時に外側のスコープの中の<bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept>の値で初期化されます、しかしそれらの値は何ら特別な方法で結びつけられません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>arch(i386)<ept i="2">&lt;/c2&gt;</ept> platform condition returns <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept> when code is compiled for the 32–bit iOS simulator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>arch(i386)<ept i="2">&lt;/c2&gt;</ept>プラットホーム条件は、コードが32ビットiOSシミュレーターに対してコンパイルされるとき<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>chooseStepFunction(backward:)<ept i="2">&lt;/c2&gt;</ept> function returns the <bpt i="3" x="3">&lt;c3&gt;</bpt>stepForward(_:)<ept i="3">&lt;/c3&gt;</ept> function or the <bpt i="4" x="4">&lt;c4&gt;</bpt>stepBackward(_:)<ept i="4">&lt;/c4&gt;</ept> function based on a Boolean parameter called <bpt i="5" x="5">&lt;c5&gt;</bpt>backward<ept i="5">&lt;/c5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>chooseStepFunction(backward:)<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>stepForward(_:)<ept i="3">&lt;/c3&gt;</ept>関数あるいは<bpt i="4" x="4">&lt;c4&gt;</bpt>stepBackward(_:)<ept i="4">&lt;/c4&gt;</ept>関数を、<bpt i="5" x="5">&lt;c5&gt;</bpt>backward<ept i="5">&lt;/c5&gt;</ept>と呼ばれるブールのパラメータに基づいて返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>fallthrough<ept i="2">&lt;/c2&gt;</ept> keyword simply causes code execution to move directly to the statements inside the next case (or <bpt i="3" x="3">&lt;c3&gt;</bpt>default<ept i="3">&lt;/c3&gt;</ept> case) block, as in C’s standard <bpt i="4" x="4">&lt;c4&gt;</bpt>switch<ept i="4">&lt;/c4&gt;</ept> statement behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>fallthrough<ept i="2">&lt;/c2&gt;</ept>キーワードは、Cの標準の<bpt i="4" x="4">&lt;c4&gt;</bpt>switch<ept i="4">&lt;/c4&gt;</ept>文の挙動でのように、単に次のケース節（または<bpt i="3" x="3">&lt;c3&gt;</bpt>default<ept i="3">&lt;/c3&gt;</ept>ケース節）ブロックの中の文へ、コード実行を直接に移すことを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>game<ept i="2">&lt;/c2&gt;</ept> parameter has a type of <bpt i="3" x="3">&lt;c3&gt;</bpt>DiceGame<ept i="3">&lt;/c3&gt;</ept>, not <bpt i="4" x="4">&lt;c4&gt;</bpt>SnakesAndLadders<ept i="4">&lt;/c4&gt;</ept>, and so <bpt i="5" x="5">&lt;c5&gt;</bpt>gameDidStart(_:)<ept i="5">&lt;/c5&gt;</ept> can access and use only methods and properties that are implemented as part of the <bpt i="6" x="6">&lt;c6&gt;</bpt>DiceGame<ept i="6">&lt;/c6&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>game<ept i="2">&lt;/c2&gt;</ept>パラメータは、型<bpt i="3" x="3">&lt;c3&gt;</bpt>DiceGame<ept i="3">&lt;/c3&gt;</ept>を持ちます、<bpt i="4" x="4">&lt;c4&gt;</bpt>SnakesAndLadders<ept i="4">&lt;/c4&gt;</ept>ではありません、なので、<bpt i="5" x="5">&lt;c5&gt;</bpt>gameDidStart(_:)<ept i="5">&lt;/c5&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt>DiceGame<ept i="6">&lt;/c6&gt;</ept>プロトコルの一部として実施されるメソッドとプロパティだけにアクセスして使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>increment()<ept i="2">&lt;/c2&gt;</ept> method uses optional chaining to try to call <bpt i="3" x="3">&lt;c3&gt;</bpt>increment(forCount:)<ept i="3">&lt;/c3&gt;</ept>, and passes the current <bpt i="4" x="4">&lt;c4&gt;</bpt>count<ept i="4">&lt;/c4&gt;</ept> value as the method’s single argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>increment()<ept i="2">&lt;/c2&gt;</ept>メソッドは、オプショナル連鎖を使って<bpt i="3" x="3">&lt;c3&gt;</bpt>increment(forCount:)<ept i="3">&lt;/c3&gt;</ept>を呼ぶことを試みます、そしてメソッドのもつただ１つの引数として現在の<bpt i="4" x="4">&lt;c4&gt;</bpt>count<ept i="4">&lt;/c4&gt;</ept>値を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>is<ept i="2">&lt;/c2&gt;</ept> pattern appears only in <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> statement case labels.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>is<ept i="2">&lt;/c2&gt;</ept>パターンは、<bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>文のケース節ラベルだけで見かけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>is<ept i="2">&lt;/c2&gt;</ept> pattern behaves like the <bpt i="3" x="3">&lt;c3&gt;</bpt>is<ept i="3">&lt;/c3&gt;</ept> operator in that they both perform a type cast but discard the returned type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>is<ept i="2">&lt;/c2&gt;</ept>パターンは、それらが両方とも型キャストを実行するが返された型を捨てるという点において、<bpt i="3" x="3">&lt;c3&gt;</bpt>is<ept i="3">&lt;/c3&gt;</ept>演算子のようにふるまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>lowerThan<ept i="2">&lt;/c2&gt;</ept> precedence group attribute may only be used to refer to precedence groups declared outside of the current module.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>lowerThan<ept i="2">&lt;/c2&gt;</ept>優先順位グループ属性は、現在のモジュールの外側で宣言される優先順位グループを参照するのに使われるだけでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>makeIterator()<ept i="2">&lt;/c2&gt;</ept> function provides access to a container’s iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>makeIterator()<ept i="2">&lt;/c2&gt;</ept>関数は、コンテナの持つイテレータに対するアクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>mutating<ept i="2">&lt;/c2&gt;</ept> keyword is only used by structures and enumerations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>mutating<ept i="2">&lt;/c2&gt;</ept>キーワードは、構造体と列挙によって使われるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>objcMembers<ept i="2">&lt;/c2&gt;</ept> attribute is a convenience for libraries that make heavy use of the introspection facilities of the Objective-C runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>objcMembers<ept i="2">&lt;/c2&gt;</ept>属性は、Objective-Cランタイムの自己観察便宜の重度の使用を生じさせるライブラリにとって好都合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>separator<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>terminator<ept i="3">&lt;/c3&gt;</ept> parameter have default values, so you can omit them when you call this function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>separator<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>terminator<ept i="3">&lt;/c3&gt;</ept>パラメータは省略時の値を持ちます、それであなたはそれらを省略することが、この関数をあなたが呼び出す時に可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>someContainer<ept i="2">&lt;/c2&gt;</ept> argument is of type <bpt i="3" x="3">&lt;c3&gt;</bpt>C1<ept i="3">&lt;/c3&gt;</ept>, and the <bpt i="4" x="4">&lt;c4&gt;</bpt>anotherContainer<ept i="4">&lt;/c4&gt;</ept> argument is of type <bpt i="5" x="5">&lt;c5&gt;</bpt>C2<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>someContainer<ept i="2">&lt;/c2&gt;</ept>引数は型<bpt i="3" x="3">&lt;c3&gt;</bpt>C1<ept i="3">&lt;/c3&gt;</ept>です、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>anotherContainer<ept i="4">&lt;/c4&gt;</ept>引数は型<bpt i="5" x="5">&lt;c5&gt;</bpt>C2<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>square<ept i="2">&lt;/c2&gt;</ept> variable is initialized with an origin point of <bpt i="3" x="3">&lt;c3&gt;</bpt>(0, 0)<ept i="3">&lt;/c3&gt;</ept>, and a width and height of <bpt i="4" x="4">&lt;c4&gt;</bpt>10<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>square<ept i="2">&lt;/c2&gt;</ept>変数は、<bpt i="3" x="3">&lt;c3&gt;</bpt>(0, 0)<ept i="3">&lt;/c3&gt;</ept>の原点、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>10<ept i="4">&lt;/c4&gt;</ept>の幅と高さで初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>stepForward(_:)<ept i="2">&lt;/c2&gt;</ept> function returns a value one more than its input value, and the <bpt i="3" x="3">&lt;c3&gt;</bpt>stepBackward(_:)<ept i="3">&lt;/c3&gt;</ept> function returns a value one less than its input value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>stepForward(_:)<ept i="2">&lt;/c2&gt;</ept>関数は、その入力された値より１大きい値を返します、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>stepBackward(_:)<ept i="3">&lt;/c3&gt;</ept>関数はその入力された値より１小さい値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept> statement determines which branch should be selected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept>文は、どの分岐が選ばれるべきか決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>throws<ept i="2">&lt;/c2&gt;</ept> keyword is part of a function’s type, and nonthrowing functions are subtypes of throwing functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>throws<ept i="2">&lt;/c2&gt;</ept>キーワードは関数の型の一部です、そしてスローを行わない関数はスロー関数の下位型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept> loop has a statement label called <bpt i="3" x="3">&lt;c3&gt;</bpt>gameLoop<ept i="3">&lt;/c3&gt;</ept> to indicate that it is the main game loop for the Snakes and Ladders game.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept>ループは、<bpt i="3" x="3">&lt;c3&gt;</bpt>gameLoop<ept i="3">&lt;/c3&gt;</ept>と呼ばれる文ラベルを持ち、それが「ヘビとはしご」ゲームのための主なゲーム・ループであることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>Address<ept i="3">&lt;/c3&gt;</ept> class type for this property is defined below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティのための<bpt i="3" x="3">&lt;c3&gt;</bpt>Address<ept i="3">&lt;/c3&gt;</ept>クラス型は、下で定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>Aged<ept i="3">&lt;/c3&gt;</ept> protocol has a single requirement for a gettable <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept> property called <bpt i="5" x="5">&lt;c5&gt;</bpt>age<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>Aged<ept i="3">&lt;/c3&gt;</ept>プロトコルは、取得可能な<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>プロパティで<bpt i="5" x="5">&lt;c5&gt;</bpt>age<ept i="5">&lt;/c5&gt;</ept>と呼ばれるものに対するただ一つの要件を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>Animal<ept i="3">&lt;/c3&gt;</ept> structure also defines a failable initializer with a single parameter called <bpt i="4" x="4">&lt;c4&gt;</bpt>species<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>Animal<ept i="3">&lt;/c3&gt;</ept>構造体はまた、<bpt i="4" x="4">&lt;c4&gt;</bpt>species<ept i="4">&lt;/c4&gt;</ept>と呼ばれるただ一つのパラメータを持つ、失敗できるイニシャライザを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>Country<ept i="3">&lt;/c3&gt;</ept> class implements the <bpt i="4" x="4">&lt;c4&gt;</bpt>area<ept i="4">&lt;/c4&gt;</ept> requirement directly as a stored property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>Country<ept i="3">&lt;/c3&gt;</ept>クラスは、<bpt i="4" x="4">&lt;c4&gt;</bpt>area<ept i="4">&lt;/c4&gt;</ept>要件を保存プロパティとして直接に満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept> protocol requires any conforming implementation of <bpt i="4" x="4">&lt;c4&gt;</bpt>==<ept i="4">&lt;/c4&gt;</ept> to be an equivalence relation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>プロトコルは、<bpt i="4" x="4">&lt;c4&gt;</bpt>==<ept i="4">&lt;/c4&gt;</ept>のどんな準拠実装もひとつの同等性関係であることを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>Tandem<ept i="3">&lt;/c3&gt;</ept> subclass also adds a new stored property called <bpt i="4" x="4">&lt;c4&gt;</bpt>currentNumberOfPassengers<ept i="4">&lt;/c4&gt;</ept>, with a default value of <bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>Tandem<ept i="3">&lt;/c3&gt;</ept>サブクラスはまた、<bpt i="4" x="4">&lt;c4&gt;</bpt>currentNumberOfPassengers<ept i="4">&lt;/c4&gt;</ept>と呼ばれる新しい保存プロパティを、<bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>の省略時の値を使って追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>as!<ept i="3">&lt;/c3&gt;</ept> operator returns a value of the specified <bpt i="4" x="4">&lt;e4&gt;</bpt>type<ept i="4">&lt;/e4&gt;</ept>, not an optional type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>as!<ept i="3">&lt;/c3&gt;</ept>演算子は指定された<bpt i="4" x="4">&lt;e4&gt;</bpt>型<ept i="4">&lt;/e4&gt;</ept>の値を返します、オプショナル型ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>as?<ept i="3">&lt;/c3&gt;</ept> operator returns an optional of the specified <bpt i="4" x="4">&lt;e4&gt;</bpt>type<ept i="4">&lt;/e4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>as?<ept i="3">&lt;/c3&gt;</ept>演算子は、指定された<bpt i="4" x="4">&lt;e4&gt;</bpt>型<ept i="4">&lt;/e4&gt;</ept>のオプショナルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>didSet<ept i="3">&lt;/c3&gt;</ept> observer does not provide a custom parameter name for the old value, and the default name of <bpt i="4" x="4">&lt;c4&gt;</bpt>oldValue<ept i="4">&lt;/c4&gt;</ept> is used instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>didSet<ept i="3">&lt;/c3&gt;</ept>オブザーバーはあつらえのパラメータ名を古い値のために用意しません、そして省略時の名前の<bpt i="4" x="4">&lt;c4&gt;</bpt>oldValue<ept i="4">&lt;/c4&gt;</ept>がその代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>didSet<ept i="3">&lt;/c3&gt;</ept> observer is called immediately after the new value is set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>didSet<ept i="3">&lt;/c3&gt;</ept>オブザーバーは、新しい値が設定された直後に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>endIndex<ept i="3">&lt;/c3&gt;</ept> property is the position after the last character in a <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>endIndex<ept i="3">&lt;/c3&gt;</ept>プロパティは、ある<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>の最後の文字の後の位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>findIndex(ofString:in:)<ept i="3">&lt;/c3&gt;</ept> function returns an optional <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept> value, which will be the index of the first matching string in the array if it’s found, or <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept> if the string can’t be found:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>findIndex(ofString:in:)<ept i="3">&lt;/c3&gt;</ept>関数は、オプショナルの<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>値を返します、それは、それが見つけられるならば配列での最初の合致している文字列のインデックスです、または文字列が見つけられることができないならば<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>init()<ept i="3">&lt;/c3&gt;</ept> initializer provides a default placeholder name for a new food by delegating across to the <bpt i="4" x="4">&lt;c4&gt;</bpt>Food<ept i="4">&lt;/c4&gt;</ept> class’s <bpt i="5" x="5">&lt;c5&gt;</bpt>init(name: String)<ept i="5">&lt;/c5&gt;</ept> with a <bpt i="6" x="6">&lt;c6&gt;</bpt>name<ept i="6">&lt;/c6&gt;</ept> value of <bpt i="7" x="7">&lt;c7&gt;</bpt>[Unnamed]<ept i="7">&lt;/c7&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>init()<ept i="3">&lt;/c3&gt;</ept>イニシャライザは、<bpt i="4" x="4">&lt;c4&gt;</bpt>Food<ept i="4">&lt;/c4&gt;</ept>クラスの<bpt i="5" x="5">&lt;c5&gt;</bpt>init(name: String)<ept i="5">&lt;/c5&gt;</ept>に<bpt i="7" x="7">&lt;c7&gt;</bpt>[Unnamed]<ept i="7">&lt;/c7&gt;</ept>の<bpt i="6" x="6">&lt;c6&gt;</bpt>name<ept i="6">&lt;/c6&gt;</ept>値を使って横に委任することで、省略時のプレースホルダ名を新しい食物のために用意します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>mutating<ept i="3">&lt;/c3&gt;</ept> keyword is added to its definition to enable it to modify its properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>mutating<ept i="3">&lt;/c3&gt;</ept>キーワードがその定義に加えられ、それにそのプロパティを修正するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>objectWithArea<ept i="3">&lt;/c3&gt;</ept> constant is known to be of type <bpt i="4" x="4">&lt;c4&gt;</bpt>HasArea<ept i="4">&lt;/c4&gt;</ept>, and so its <bpt i="5" x="5">&lt;c5&gt;</bpt>area<ept i="5">&lt;/c5&gt;</ept> property can be accessed and printed in a type-safe way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数の<bpt i="3" x="3">&lt;c3&gt;</bpt>objectWithArea<ept i="3">&lt;/c3&gt;</ept>は、型<bpt i="4" x="4">&lt;c4&gt;</bpt>HasArea<ept i="4">&lt;/c4&gt;</ept>であるということを知られています、なので、その<bpt i="5" x="5">&lt;c5&gt;</bpt>area<ept i="5">&lt;/c5&gt;</ept>プロパティは型安全な方法でアクセスされて出力されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>return<ept i="3">&lt;/c3&gt;</ept> statement is described in <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Functions<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>, and the <bpt i="6" x="6">&lt;c6&gt;</bpt>throw<ept i="6">&lt;/c6&gt;</ept> statement is described in <bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>Propagating Errors Using Throwing Functions<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>return<ept i="3">&lt;/c3&gt;</ept>文は<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>関数<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>において、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>throw<ept i="6">&lt;/c6&gt;</ept>文は<bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>スロー関数を使ってエラーを伝える<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>において記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> statement is better suited to more complex conditions with multiple possible permutations and is useful in situations where pattern matching can help select an appropriate code branch to execute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>文は、複数の可能な起こりうる組み合わせを伴うさらに複雑な状況によりよく適します、そして、パターンマッチングが適切なコード分岐を選択して実行する助けとなり得る状況において役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>*<ept i="4">&lt;/c4&gt;</ept> argument is required and specifies that on any other platform, the body of the code block guarded by the availability condition executes on the minimum deployment target specified by your target.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>*<ept i="4">&lt;/c4&gt;</ept>引数は必須であらゆる他のプラットホーム上を指定します、有効性条件によって保護されたコード・ブロックの本文はあなたのターゲットによって指定される最小の開発ターゲット上で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>Car<ept i="4">&lt;/c4&gt;</ept> class’s version of <bpt i="5" x="5">&lt;c5&gt;</bpt>description<ept i="5">&lt;/c5&gt;</ept> then adds some extra text onto the end of this description to provide information about the current gear.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Car<ept i="4">&lt;/c4&gt;</ept>クラス版の<bpt i="5" x="5">&lt;c5&gt;</bpt>description<ept i="5">&lt;/c5&gt;</ept>は、それからこの説明の最後に現在のギアーについての情報を提供するために追加のテキストを加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>Dictionary<ept i="4">&lt;/c4&gt;</ept> type uses an optional subscript type to model the fact that not every key will have a value, and to give a way to delete a value for a key by assigning a <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept> value for that key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Dictionary<ept i="4">&lt;/c4&gt;</ept>型は、すべてのキーに値があるというわけでないという事実をモデル化するために、そしてあるキーに対する値を削除する方法をそのキーに対して<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>の値を代入することで提供するために、オプショナルの添え字型を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>Food<ept i="4">&lt;/c4&gt;</ept> class does not have a superclass, and so the <bpt i="5" x="5">&lt;c5&gt;</bpt>init(name: String)<ept i="5">&lt;/c5&gt;</ept> initializer does not need to call <bpt i="6" x="6">&lt;c6&gt;</bpt>super.init()<ept i="6">&lt;/c6&gt;</ept> to complete its initialization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Food<ept i="4">&lt;/c4&gt;</ept>クラスには、スーパークラスがありません、なので、<bpt i="5" x="5">&lt;c5&gt;</bpt>init(name: String)<ept i="5">&lt;/c5&gt;</ept>イニシャライザはその初期化を完了するために<bpt i="6" x="6">&lt;c6&gt;</bpt>super.init()<ept i="6">&lt;/c6&gt;</ept>を呼ぶ必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>advance(to:)<ept i="4">&lt;/c4&gt;</ept> method returns a Boolean value to indicate whether or not it was actually able to set <bpt i="5" x="5">&lt;c5&gt;</bpt>currentLevel<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>advance(to:)<ept i="4">&lt;/c4&gt;</ept>メソッドは、それが実際に<bpt i="5" x="5">&lt;c5&gt;</bpt>currentLevel<ept i="5">&lt;/c5&gt;</ept>を設定することができたかどうか示すためにブールの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>asHTML<ept i="4">&lt;/c4&gt;</ept> property is of type <bpt i="5" x="5">&lt;c5&gt;</bpt>() -&gt; String<ept i="5">&lt;/c5&gt;</ept>, or “a function that takes no parameters, and returns a <bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept> value”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>asHTML<ept i="4">&lt;/c4&gt;</ept>プロパティは型<bpt i="5" x="5">&lt;c5&gt;</bpt>() -&gt; String<ept i="5">&lt;/c5&gt;</ept>です、あるいは「パラメータをとらなくて、<bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>値を返す関数」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>currentSpeed<ept i="4">&lt;/c4&gt;</ept> property’s value is used by a read-only computed <bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept> property called <bpt i="6" x="6">&lt;c6&gt;</bpt>description<ept i="6">&lt;/c6&gt;</ept> to create a description of the vehicle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>currentSpeed<ept i="4">&lt;/c4&gt;</ept>プロパティの値は、<bpt i="6" x="6">&lt;c6&gt;</bpt>description<ept i="6">&lt;/c6&gt;</ept>と呼ばれる読み込み専用の計算<bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept>プロパティによってその乗り物の解説を作成するために使用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>fullName<ept i="4">&lt;/c4&gt;</ept> property uses the <bpt i="5" x="5">&lt;c5&gt;</bpt>prefix<ept i="5">&lt;/c5&gt;</ept> value if it exists, and prepends it to the beginning of <bpt i="6" x="6">&lt;c6&gt;</bpt>name<ept i="6">&lt;/c6&gt;</ept> to create a full name for the starship.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>fullName<ept i="4">&lt;/c4&gt;</ept>プロパティは、<bpt i="5" x="5">&lt;c5&gt;</bpt>prefix<ept i="5">&lt;/c5&gt;</ept>値を、それが存在するならば使います、そしてそれを<bpt i="6" x="6">&lt;c6&gt;</bpt>name<ept i="6">&lt;/c6&gt;</ept>の始めに付けて、その宇宙船の完全な名前をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>is<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>as<ept i="5">&lt;/c5&gt;</ept> patterns have the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>is<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>as<ept i="5">&lt;/c5&gt;</ept>パターンは以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>numberOfWheels<ept i="4">&lt;/c4&gt;</ept> property is used by a computed property called <bpt i="5" x="5">&lt;c5&gt;</bpt>description<ept i="5">&lt;/c5&gt;</ept> to create a <bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept> description of the vehicle’s characteristics:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>numberOfWheels<ept i="4">&lt;/c4&gt;</ept>プロパティは<bpt i="5" x="5">&lt;c5&gt;</bpt>description<ept i="5">&lt;/c5&gt;</ept>と呼ばれる計算プロパティによって使用されて、この乗り物の特徴のある<bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>の解説を作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="5" x="5">&lt;c5&gt;</bpt>Car<ept i="5">&lt;/c5&gt;</ept> class also overrides the <bpt i="6" x="6">&lt;c6&gt;</bpt>description<ept i="6">&lt;/c6&gt;</ept> property it inherits from <bpt i="7" x="7">&lt;c7&gt;</bpt>Vehicle<ept i="7">&lt;/c7&gt;</ept>, to provide a custom description that includes the current gear:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>Car<ept i="5">&lt;/c5&gt;</ept>クラスはまた、それが<bpt i="7" x="7">&lt;c7&gt;</bpt>Vehicle<ept i="7">&lt;/c7&gt;</ept>から継承する<bpt i="6" x="6">&lt;c6&gt;</bpt>description<ept i="6">&lt;/c6&gt;</ept>プロパティをオーバーライドして、現在のギアーを示すあつらえの説明を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="5" x="5">&lt;c5&gt;</bpt>apartment<ept i="5">&lt;/c5&gt;</ept> property is optional, because a person may not always have an apartment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>人は必ずしもアパートを持つわけではないので、<bpt i="5" x="5">&lt;c5&gt;</bpt>apartment<ept i="5">&lt;/c5&gt;</ept>プロパティはオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="5" x="5">&lt;c5&gt;</bpt>makeIncrementer<ept i="5">&lt;/c5&gt;</ept> function defines a nested function called <bpt i="6" x="6">&lt;c6&gt;</bpt>incrementer<ept i="6">&lt;/c6&gt;</ept>, which performs the actual incrementing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>makeIncrementer<ept i="5">&lt;/c5&gt;</ept>関数は<bpt i="6" x="6">&lt;c6&gt;</bpt>incrementer<ept i="6">&lt;/c6&gt;</ept>と呼ばれる入れ子にされた関数を定義します、それは、実際に増やすことを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="5" x="5">&lt;c5&gt;</bpt>switch<ept i="5">&lt;/c5&gt;</ept> case matches the current value of <bpt i="6" x="6">&lt;c6&gt;</bpt>point<ept i="6">&lt;/c6&gt;</ept> only if the <bpt i="7" x="7">&lt;c7&gt;</bpt>where<ept i="7">&lt;/c7&gt;</ept> clause’s condition evaluates to <bpt i="8" x="8">&lt;c8&gt;</bpt>true<ept i="8">&lt;/c8&gt;</ept> for that value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="5" x="5">&lt;c5&gt;</bpt>switch<ept i="5">&lt;/c5&gt;</ept>ケース節は、<bpt i="6" x="6">&lt;c6&gt;</bpt>point<ept i="6">&lt;/c6&gt;</ept>の現在の値に、<bpt i="7" x="7">&lt;c7&gt;</bpt>where<ept i="7">&lt;/c7&gt;</ept>節の条件が<bpt i="8" x="8">&lt;c8&gt;</bpt>true<ept i="8">&lt;/c8&gt;</ept>に評価する場合にのみ適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="6" x="6">&lt;c6&gt;</bpt>description<ept i="6">&lt;/c6&gt;</ept> property uses optional binding to check whether there is a second value to display, and if so, inserts additional description detail for that second value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>description<ept i="6">&lt;/c6&gt;</ept>プロパティは、オプショナル束縛を使って、表示する第２の値があるかどうか調べます、そしてもしそうなら、その第２の値に関する追加の記述詳細を差し込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="6" x="6">&lt;c6&gt;</bpt>fixedIncrement<ept i="6">&lt;/c6&gt;</ept> property is also an optional requirement, so its value is an optional <bpt i="7" x="7">&lt;c7&gt;</bpt>Int<ept i="7">&lt;/c7&gt;</ept> value, even though <bpt i="8" x="8">&lt;c8&gt;</bpt>fixedIncrement<ept i="8">&lt;/c8&gt;</ept> is defined as a nonoptional <bpt i="9" x="9">&lt;c9&gt;</bpt>Int<ept i="9">&lt;/c9&gt;</ept> property as part of the <bpt i="10" x="10">&lt;c10&gt;</bpt>CounterDataSource<ept i="10">&lt;/c10&gt;</ept> protocol definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>fixedIncrement<ept i="6">&lt;/c6&gt;</ept>プロパティもまたオプショナルの要件です、なのでその値はオプショナルの<bpt i="7" x="7">&lt;c7&gt;</bpt>Int<ept i="7">&lt;/c7&gt;</ept>値です、たとえ<bpt i="8" x="8">&lt;c8&gt;</bpt>fixedIncrement<ept i="8">&lt;/c8&gt;</ept>が<bpt i="10" x="10">&lt;c10&gt;</bpt>CounterDataSource<ept i="10">&lt;/c10&gt;</ept>プロトコル定義の部分では非オプショナルの<bpt i="9" x="9">&lt;c9&gt;</bpt>Int<ept i="9">&lt;/c9&gt;</ept>プロパティであると定義されるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="8" x="8">&lt;c8&gt;</bpt>Country<ept i="8">&lt;/c8&gt;</ept> initializer can therefore pass <bpt i="9" x="9">&lt;c9&gt;</bpt>self<ept i="9">&lt;/c9&gt;</ept> as one of the parameters for the <bpt i="10" x="10">&lt;c10&gt;</bpt>City<ept i="10">&lt;/c10&gt;</ept> initializer when the <bpt i="11" x="11">&lt;c11&gt;</bpt>Country<ept i="11">&lt;/c11&gt;</ept> initializer is setting its own <bpt i="12" x="12">&lt;c12&gt;</bpt>capitalCity<ept i="12">&lt;/c12&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt>Country<ept i="8">&lt;/c8&gt;</ept>イニシャライザはしたがって、<bpt i="9" x="9">&lt;c9&gt;</bpt>self<ept i="9">&lt;/c9&gt;</ept>を<bpt i="10" x="10">&lt;c10&gt;</bpt>City<ept i="10">&lt;/c10&gt;</ept>イニシャライザのパラメータの１つとして渡すことが、<bpt i="11" x="11">&lt;c11&gt;</bpt>Country<ept i="11">&lt;/c11&gt;</ept>イニシャライザが自身の<bpt i="12" x="12">&lt;c12&gt;</bpt>capitalCity<ept i="12">&lt;/c12&gt;</ept>プロパティを設定しているときに可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="8" x="8">&lt;c8&gt;</bpt>default<ept i="8">&lt;/c8&gt;</ept> case adds some extra text to the end of the description, and the <bpt i="9" x="9">&lt;c9&gt;</bpt>switch<ept i="9">&lt;/c9&gt;</ept> statement is complete.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt>default<ept i="8">&lt;/c8&gt;</ept>ケース節はこの解説（description）の終わりに追加の若干のテキストを加えます、そして<bpt i="9" x="9">&lt;c9&gt;</bpt>switch<ept i="9">&lt;/c9&gt;</ept>文は終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>Snakes and Ladders<ept i="0">&lt;/e0&gt;</ept> game board setup takes place within the class’s <bpt i="1" x="1">&lt;c1&gt;</bpt>init()<ept i="1">&lt;/c1&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ヘビとはしご<ept i="0">&lt;/e0&gt;</ept>ゲーム盤設定は、このクラスの<bpt i="1" x="1">&lt;c1&gt;</bpt>init()<ept i="1">&lt;/c1&gt;</ept>イニシャライザ内で行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>assignment operator<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>a = b<ept i="1">&lt;/c1&gt;</ept>) initializes or updates the value of <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept> with the value of <bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>代入演算子<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>a = b<ept i="1">&lt;/c1&gt;</ept>）は、<bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>の値を<bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>の値で初期化または更新します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>assignment operator<ept i="0">&lt;/e0&gt;</ept> sets a new value for a given expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>代入演算子<ept i="0">&lt;/e0&gt;</ept>は、指定された式に対してある新しい値を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>assignment<ept i="0">&lt;/e0&gt;</ept> of a precedence group specifies the precedence of an operator when used in an operation that includes optional chaining.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある優先順位グループの<bpt i="0" x="0">&lt;e0&gt;</bpt>assignment<ept i="0">&lt;/e0&gt;</ept>は、オプショナル連鎖を含む演算において使われる場合はある演算子の優先順位を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>associativity<ept i="0">&lt;/e0&gt;</ept> of an operator specifies how a sequence of operators with the same precedence level are grouped together in the absence of grouping parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子の<bpt i="0" x="0">&lt;e0&gt;</bpt>結合性<ept i="0">&lt;/e0&gt;</ept>は、グループ括弧がない場合に同じ優先順位レベルを持つひと連なりの演算子がどのようにまとめられるかを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>bitwise AND operator<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>&amp;<ept i="1">&lt;/c1&gt;</ept>) combines the bits of two numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ビット単位の論理積演算子<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>&amp;<ept i="1">&lt;/c1&gt;</ept>）は、２つの数のビットを結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>bitwise NOT operator<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>~<ept i="1">&lt;/c1&gt;</ept>) inverts all bits in a number:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ビット単位の論理否定演算子<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>~<ept i="1">&lt;/c1&gt;</ept>）は、ある数の中の全てのビットを逆にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>bitwise OR operator<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>|<ept i="1">&lt;/c1&gt;</ept>) compares the bits of two numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ビット単位<ept i="0">&lt;/e0&gt;</ept>の論理和演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>|<ept i="1">&lt;/c1&gt;</ept>）は、２つの数のビットを比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>bitwise XOR operator<ept i="0">&lt;/e0&gt;</ept>, or “exclusive OR operator” (<bpt i="1" x="1">&lt;c1&gt;</bpt>^<ept i="1">&lt;/c1&gt;</ept>), compares the bits of two numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ビット単位の排他的論理和（XOR）演算子<ept i="0">&lt;/e0&gt;</ept>、あるいは「排他的論理和演算子」（<bpt i="1" x="1">&lt;c1&gt;</bpt>^<ept i="1">&lt;/c1&gt;</ept>）は、２つの数のビットを比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>bitwise left shift operator<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;&lt;<ept i="1">&lt;/c1&gt;</ept>) and <bpt i="2" x="2">&lt;e2&gt;</bpt>bitwise right shift operator<ept i="2">&lt;/e2&gt;</ept> (<bpt i="3" x="3">&lt;c3&gt;</bpt>&gt;&gt;<ept i="3">&lt;/c3&gt;</ept>) move all bits in a number to the left or the right by a certain number of places, according to the rules defined below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ビット単位の左シフト演算子<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;&lt;<ept i="1">&lt;/c1&gt;</ept>）と<bpt i="2" x="2">&lt;e2&gt;</bpt>ビット単位の右シフト演算子<ept i="2">&lt;/e2&gt;</ept>（<bpt i="3" x="3">&lt;c3&gt;</bpt>&gt;&gt;<ept i="3">&lt;/c3&gt;</ept>）は、下で定義される規則に従ってある数の中の全てのビットを左または右に特定の桁数だけ移動します。（シフト：移す、ずらす）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>closed range operator<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>a...b<ept i="1">&lt;/c1&gt;</ept>) defines a range that runs from <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>, and includes the values <bpt i="4" x="4">&lt;c4&gt;</bpt>a<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>b<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>完結範囲演算子<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>a...b<ept i="1">&lt;/c1&gt;</ept>）は、<bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>から<bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>まで続く範囲を定義します、それは<bpt i="4" x="4">&lt;c4&gt;</bpt>a<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>b<ept i="5">&lt;/c5&gt;</ept>の値を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>compilation condition<ept i="0">&lt;/e0&gt;</ept> can include the <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept> Boolean literals, an identifier used with the <bpt i="3" x="3">&lt;c3&gt;</bpt>-D<ept i="3">&lt;/c3&gt;</ept> command line flag, or any of the platform conditions listed in the table below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>compilation condition<ept i="0">&lt;/e0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>のブールのリテラル、<bpt i="3" x="3">&lt;c3&gt;</bpt>-D<ept i="3">&lt;/c3&gt;</ept>コマンドラインフラグと共に使われる識別子、もしくは以下の表で列記されるプラットホーム条件を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>condition<ept i="0">&lt;/e0&gt;</ept> is evaluated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>条件<ept i="0">&lt;/e0&gt;</ept>が評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>constraint<ept i="0">&lt;/e0&gt;</ept> specifies that a type parameter inherits from a specific class or conforms to a protocol or protocol composition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>制約<ept i="0">&lt;/e0&gt;</ept>は、型パラメータが特定のクラスから継承する、もしくはあるプロトコルまたはプロトコル合成に準拠することを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>control expression<ept i="0">&lt;/e0&gt;</ept> of the <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement is evaluated and then compared with the patterns specified in each case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文の<bpt i="0" x="0">&lt;e0&gt;</bpt>制御式<ept i="0">&lt;/e0&gt;</ept>は、評価されて、それからそれぞれのケース節（case）で指定されるパターンと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>fixity<ept i="0">&lt;/e0&gt;</ept> of an operator specifies the relative position of an operator to its operands.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子の<bpt i="0" x="0">&lt;e0&gt;</bpt>定着性<ept i="0">&lt;/e0&gt;</ept>は、その演算子の演算数に対する相対位置を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>function name<ept i="0">&lt;/e0&gt;</ept> can be any expression whose value is of a function type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>関数名<ept i="0">&lt;/e0&gt;</ept>は、値がその関数型であるどんな式でもかまいません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>generic argument list<ept i="0">&lt;/e0&gt;</ept> is a comma-separated list of type arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>総称体引数リスト<ept i="0">&lt;/e0&gt;</ept>は、型引数のコンマで区切られたリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>generic parameter list<ept i="0">&lt;/e0&gt;</ept> is a comma-separated list of generic parameters, each of which has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>総称体パラメータリスト<ept i="0">&lt;/e0&gt;</ept>は、コンマで区切られた総称体パラメータのリストです、そしてそのそれぞれは以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>half-open range operator<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>a..&lt;b<ept i="1">&lt;/c1&gt;</ept>) defines a range that runs from <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>, but doesn’t include <bpt i="4" x="4">&lt;c4&gt;</bpt>b<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>半開範囲演算子<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>a..&lt;b<ept i="1">&lt;/c1&gt;</ept>）は、<bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>から<bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>まで続く範囲を定義します、しかし<bpt i="4" x="4">&lt;c4&gt;</bpt>b<ept i="4">&lt;/c4&gt;</ept>の値を含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>lexical structure<ept i="0">&lt;/e0&gt;</ept> of Swift describes what sequence of characters form valid tokens of the language.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;e0&gt;</bpt>語彙の構造<ept i="0">&lt;/e0&gt;</ept>は、どんな文字の連なりがこの言語の公式のトークン（個々の語、最少単位の語）を作り上げるかについて述べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>logical AND operator<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>a &amp;&amp; b<ept i="1">&lt;/c1&gt;</ept>) creates logical expressions where both values must be <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept> for the overall expression to also be <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>論理積演算子<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>a &amp;&amp; b<ept i="1">&lt;/c1&gt;</ept>）は、論理式をつくります、そこにおいて全体的な式もまた<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>になるためには、両方の値が<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>logical NOT operator<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>!a<ept i="1">&lt;/c1&gt;</ept>) inverts a Boolean value so that <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept> becomes <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept> becomes <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>論理否定演算子<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>!a<ept i="1">&lt;/c1&gt;</ept>）は１つのブール値を逆にします、それで<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>に、<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>logical OR operator<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>a || b<ept i="1">&lt;/c1&gt;</ept>) is an infix operator made from two adjacent pipe characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>論理和演算子<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>a || b<ept i="1">&lt;/c1&gt;</ept>）は、２つの隣接したパイプ文字から作られる接中辞演算子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>lower group names<ept i="0">&lt;/e0&gt;</ept> and <bpt i="1" x="1">&lt;e1&gt;</bpt>higher group names<ept i="1">&lt;/e1&gt;</ept> lists specify the new precedence group’s relation to existing precedence groups.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>下方グループ名<ept i="0">&lt;/e0&gt;</ept>および<bpt i="1" x="1">&lt;e1&gt;</bpt>上方グループ名<ept i="1">&lt;/e1&gt;</ept>リストは、新しい優先順位グループのもつ関係を既存の優先順位グループに対して指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>message<ept i="0">&lt;/e0&gt;</ept> consists of a string literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>message<ept i="0">&lt;/e0&gt;</ept>は、文字列リテラルから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>method name<ept i="0">&lt;/e0&gt;</ept> and <bpt i="1" x="1">&lt;e1&gt;</bpt>property name<ept i="1">&lt;/e1&gt;</ept> must be a reference to a method or a property that is available in the Objective-C runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>method name<ept i="0">&lt;/e0&gt;</ept>と<bpt i="1" x="1">&lt;e1&gt;</bpt>property name<ept i="1">&lt;/e1&gt;</ept>は、あるメソッドおよびプロパティへの参照で、それはObjective-Cランタイムにおいて利用可能なものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>method name<ept i="0">&lt;/e0&gt;</ept> can contain parentheses for grouping, as well the <bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept> operator to disambiguate between methods that share a name but have different type signatures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>method name<ept i="0">&lt;/e0&gt;</ept>は、グループにまとめるための丸括弧、その上に、名前を共有するが異なる型シグネチャを持つメソッド間の違いを明確にするために<bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept>演算子を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>new name<ept i="0">&lt;/e0&gt;</ept> consists of a string literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>新しい名前<ept i="0">&lt;/e0&gt;</ept>は文字列リテラルからなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>nil-coalescing operator<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>a ?? b<ept i="1">&lt;/c1&gt;</ept>) unwraps an optional <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept> if it contains a value, or returns a default value <bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept> if <bpt i="4" x="4">&lt;c4&gt;</bpt>a<ept i="4">&lt;/c4&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>nil合体演算子<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>a ?? b<ept i="1">&lt;/c1&gt;</ept>）は、それが値を持つならばオプショナルの<bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>をアンラップします、または<bpt i="4" x="4">&lt;c4&gt;</bpt>a<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>ならば省略時の値の<bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>parameter type<ept i="0">&lt;/e0&gt;</ept> is comma-separated list of types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>parameter type<ept i="0">&lt;/e0&gt;</ept>コンマ区切りの型のリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>parameters<ept i="0">&lt;/e0&gt;</ept> have the same form as the parameters in a function declaration, as described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Function Declaration<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>パラメータ<ept i="0">&lt;/e0&gt;</ept>は、関数宣言で記述されるように、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>関数宣言でのパラメータ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>と同じ形式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>parameters<ept i="0">&lt;/e0&gt;</ept> in closure expression syntax can be in-out parameters, but they can’t have a default value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャ式構文中の<bpt i="0" x="0">&lt;e0&gt;</bpt>parameters<ept i="0">&lt;/e0&gt;</ept>はin-outパラメータであることができます、しかしそれらは省略時の値を持つことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>parameters<ept i="0">&lt;/e0&gt;</ept> specify one or more indexes used to access elements of the corresponding type in a subscript expression (for example, the <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept> in the expression <bpt i="2" x="2">&lt;c2&gt;</bpt>object[i]<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>パラメータ<ept i="0">&lt;/e0&gt;</ept>は、対応する型の要素にアクセスするために添え字式において使用する一種類以上のインデックスを指定します（例えば、式<bpt i="2" x="2">&lt;c2&gt;</bpt>object[i]<ept i="2">&lt;/c2&gt;</ept>における<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>など）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>property name<ept i="0">&lt;/e0&gt;</ept> must be a reference to a property that is available in the Objective-C runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>property name<ept i="0">&lt;/e0&gt;</ept>は、Objective-Cランタイムにおいて利用可能であるプロパティへの参照でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>property names<ept i="0">&lt;/e0&gt;</ept> can contain multiple property names, separated by periods, which lets you access a property of the given property’s value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>property names<ept i="0">&lt;/e0&gt;</ept>は、複数のプロパティ名を、ピリオドで隔てて含むことができます、それはあなたに指定プロパティ値のプロパティにアクセスさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>property names<ept i="0">&lt;/e0&gt;</ept> must be a reference to a property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>property names<ept i="0">&lt;/e0&gt;</ept>は、あるプロパティを参照する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>remainder operator<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>a % b<ept i="1">&lt;/c1&gt;</ept>) works out how many multiples of <bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept> will fit inside <bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept> and returns the value that is left over (known as the <bpt i="4" x="4">&lt;e4&gt;</bpt>remainder<ept i="4">&lt;/e4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>剰余演算子<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>a % b<ept i="1">&lt;/c1&gt;</ept>）は、どのくらい多くの<bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept>の倍数が<bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept>の内部に収まるかを計算して、残された値（<bpt i="4" x="4">&lt;e4&gt;</bpt>余り<ept i="4">&lt;/e4&gt;</ept>として知られるもの）を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>requirements<ept i="0">&lt;/e0&gt;</ept> in a generic <bpt i="1" x="1">&lt;c1&gt;</bpt>where<ept i="1">&lt;/c1&gt;</ept> clause specify that a type parameter inherits from a class or conforms to a protocol or protocol composition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体<bpt i="1" x="1">&lt;c1&gt;</bpt>where<ept i="1">&lt;/c1&gt;</ept>節の中の<bpt i="0" x="0">&lt;e0&gt;</bpt>要件<ept i="0">&lt;/e0&gt;</ept>が指定するのは、型パラメータがクラスから継承するかまたはプロトコルやプロトコル合成に準拠するということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>setter name<ept i="0">&lt;/e0&gt;</ept> and enclosing parentheses are optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>セッター名<ept i="0">&lt;/e0&gt;</ept>と囲んでいる括弧は、任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>setter name<ept i="0">&lt;/e0&gt;</ept> and enclosing parentheses in the <bpt i="1" x="1">&lt;c1&gt;</bpt>willSet<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>didSet<ept i="2">&lt;/c2&gt;</ept> clauses are optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>willSet<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>didSet<ept i="2">&lt;/c2&gt;</ept>節の中の<bpt i="0" x="0">&lt;e0&gt;</bpt>セッター名<ept i="0">&lt;/e0&gt;</ept>と囲んでいる丸括弧は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>setter name<ept i="0">&lt;/e0&gt;</ept> and enclosing parentheses is optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>セッター名<ept i="0">&lt;/e0&gt;</ept>、そして囲んでいる丸括弧は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>statements<ept i="0">&lt;/e0&gt;</ept> inside a code block include declarations, expressions, and other kinds of statements and are executed in order of their appearance in source code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コード・ブロックの内側の<bpt i="0" x="0">&lt;e0&gt;</bpt>文<ept i="0">&lt;/e0&gt;</ept>は、宣言、式、そして他の種類の文を含みます、そしてソース・コードにおいてそれらの現れる順に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>ternary conditional operator<ept i="0">&lt;/e0&gt;</ept> evaluates to one of two given values based on the value of a condition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>三項条件演算子<ept i="0">&lt;/e0&gt;</ept>は、ある条件の値に基づいて、２つの与えられた値のうちの１つへと評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>ternary conditional operator<ept i="0">&lt;/e0&gt;</ept> is a special operator with three parts, which takes the form <bpt i="1" x="1">&lt;c1&gt;</bpt>question ? answer1 : answer2<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>三項条件演算子<ept i="0">&lt;/e0&gt;</ept>は３つの部分をもつ特別な演算子です、それは形式<bpt i="1" x="1">&lt;c1&gt;</bpt>question ? answer1 : answer2<ept i="1">&lt;/c1&gt;</ept>をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>type name<ept i="0">&lt;/e0&gt;</ept> can be omitted in contexts where type inference can determine the implied type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>type name<ept i="0">&lt;/e0&gt;</ept>は、型推論が暗黙の型を判定できるところの文脈では省略できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>unary plus operator<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>) simply returns the value it operates on, without any change:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>単項プラス演算子<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>）は、それが作用する値を、どんな変更もせずに、ただ単純に返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>version number<ept i="0">&lt;/e0&gt;</ept> consists of one to three positive integers, separated by periods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>バージョン番号<ept i="0">&lt;/e0&gt;</ept>は、ビリオドで区切られた、１つから３つの正の整数から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;e1&gt;</bpt>superclass<ept i="1">&lt;/e1&gt;</ept> appears first after the <bpt i="2" x="2">&lt;e2&gt;</bpt>class name<ept i="2">&lt;/e2&gt;</ept> and colon, followed by any <bpt i="3" x="3">&lt;e3&gt;</bpt>adopted protocols<ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;e1&gt;</bpt>スーパークラス<ept i="1">&lt;/e1&gt;</ept>がまず<bpt i="2" x="2">&lt;e2&gt;</bpt>クラス名<ept i="2">&lt;/e2&gt;</ept>とコロンの後に現れ、続いて随意の<bpt i="3" x="3">&lt;e3&gt;</bpt>準拠するプロトコル<ept i="3">&lt;/e3&gt;</ept>が続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;e1&gt;</bpt>type<ept i="1">&lt;/e1&gt;</ept> annotation is optional when the type can be inferred from the initializer <bpt i="2" x="2">&lt;e2&gt;</bpt>expression<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;e1&gt;</bpt>型<ept i="1">&lt;/e1&gt;</ept>注釈は、その型が初期化<bpt i="2" x="2">&lt;e2&gt;</bpt>式<ept i="2">&lt;/e2&gt;</ept>から推論されることができる場合は随意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;e2&gt;</bpt>existing type<ept i="2">&lt;/e2&gt;</ept> can be a named type or a compound type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;e2&gt;</bpt>既存の型<ept i="2">&lt;/e2&gt;</ept>は、名前付きの型または複合の型でありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;e2&gt;</bpt>line number<ept i="2">&lt;/e2&gt;</ept> changes the value of <bpt i="3" x="3">&lt;c3&gt;</bpt>#line<ept i="3">&lt;/c3&gt;</ept> and is any integer literal greater than zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;e2&gt;</bpt>line number（行番号）<ept i="2">&lt;/e2&gt;</ept>は、<bpt i="3" x="3">&lt;c3&gt;</bpt>#line<ept i="3">&lt;/c3&gt;</ept>の値を変更します、そして0より大きい何らかの整数リテラルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;e2&gt;</bpt>protocol member declarations<ept i="2">&lt;/e2&gt;</ept> are discussed in detail below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;e2&gt;</bpt>プロトコルメンバー宣言<ept i="2">&lt;/e2&gt;</ept>は、詳細に下で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;e3&gt;</bpt>return type<ept i="3">&lt;/e3&gt;</ept> specifies the type of the element being accessed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;e3&gt;</bpt>戻り型<ept i="3">&lt;/e3&gt;</ept>は、アクセスされている要素の型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;e4&gt;</bpt>filename<ept i="4">&lt;/e4&gt;</ept> changes the value of <bpt i="5" x="5">&lt;c5&gt;</bpt>#file<ept i="5">&lt;/c5&gt;</ept> and is a string literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;e4&gt;</bpt>filename（ファイル名）<ept i="4">&lt;/e4&gt;</ept>は、<bpt i="5" x="5">&lt;c5&gt;</bpt>#file<ept i="5">&lt;/c5&gt;</ept>の値を変更します、そしてひとつの文字列リテラルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Basics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The CSS color value <bpt i="2" x="2">&lt;c2&gt;</bpt>#CC6699<ept i="2">&lt;/c2&gt;</ept> is written as <bpt i="3" x="3">&lt;c3&gt;</bpt>0xCC6699<ept i="3">&lt;/c3&gt;</ept> in Swift’s hexadecimal number representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>CSS色値<bpt i="2" x="2">&lt;c2&gt;</bpt>#CC6699<ept i="2">&lt;/c2&gt;</ept>は、スウィフトの16進数表現では<bpt i="3" x="3">&lt;c3&gt;</bpt>0xCC6699<ept i="3">&lt;/c3&gt;</ept>のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Problem That Generics Solve</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体が解決する問題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Sorted Method</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>分類メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift language defines the postfix <bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept> as syntactic sugar for the named type <bpt i="1" x="1">&lt;c1&gt;</bpt>Optional&lt;Wrapped&gt;<ept i="1">&lt;/c1&gt;</ept>, which is defined in the Swift standard library, with the additional behavior that it’s automatically unwrapped when it’s accessed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト言語は、接尾辞<bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept>を構文糖衣としてスウィフト標準ライブラリで定義される名前付きの型<bpt i="1" x="1">&lt;c1&gt;</bpt>Optional&lt;Wrapped&gt;<ept i="1">&lt;/c1&gt;</ept>に対して定義します、それはそれがアクセスされるとき自動的にアンラップされるという追加の挙動を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift language defines the postfix <bpt i="0" x="0">&lt;c0&gt;</bpt>?<ept i="0">&lt;/c0&gt;</ept> as syntactic sugar for the named type <bpt i="1" x="1">&lt;c1&gt;</bpt>Optional&lt;Wrapped&gt;<ept i="1">&lt;/c1&gt;</ept>, which is defined in the Swift standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト言語は、接尾辞<bpt i="0" x="0">&lt;c0&gt;</bpt>?<ept i="0">&lt;/c0&gt;</ept>を構文糖衣として名前付きの型<bpt i="1" x="1">&lt;c1&gt;</bpt>Optional&lt;Wrapped&gt;<ept i="1">&lt;/c1&gt;</ept>に対して定義します、それは、スウィフト標準ライブラリで定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift language is relatively small, because many common types, functions, and operators that appear virtually everywhere in Swift code are actually defined in the Swift standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト言語は比較的小さいです、スウィフトのコードのほとんど至る所で見かける多くの通常の型、関数、そして演算子がスウィフト標準ライブラリで実際には定義されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift language provides the following syntactic sugar for the Swift standard library <bpt i="0" x="0">&lt;c0&gt;</bpt>Array&lt;Element&gt;<ept i="0">&lt;/c0&gt;</ept> type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト言語は、スウィフト標準ライブラリの<bpt i="0" x="0">&lt;c0&gt;</bpt>Array&lt;Element&gt;<ept i="0">&lt;/c0&gt;</ept>型のために以下の構文糖衣を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift language provides the following syntactic sugar for the Swift standard library <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary&lt;Key, Value&gt;<ept i="0">&lt;/c0&gt;</ept> type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト言語は、以下の構文糖衣をスウィフト標準ライブラリ<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary&lt;Key, Value&gt;<ept i="0">&lt;/c0&gt;</ept>型に提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift logical operators <bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&amp;<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>||<ept i="1">&lt;/c1&gt;</ept> are left-associative, meaning that compound expressions with multiple logical operators evaluate the leftmost subexpression first.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの論理演算子<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&amp;<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>||<ept i="1">&lt;/c1&gt;</ept>は、左結合です、複数の論理演算子を持つ複合式が最も左の下位の式を最初に評価することを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift standard library also defines a <bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept> type, which represents a 32-bit floating-point number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト標準ライブラリはまた<bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>型も定義します、それは、32ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift standard library also defines types for various sizes of signed and unsigned integers, as described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Integers<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>整数<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述されるように、スウィフト標準ライブラリはまた、さまざまな大きさの符号つきおよび符号なし整数のために、いろいろな型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift standard library defines a number of operators for your use, many of which are discussed in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Basic Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Advanced Operators<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト標準ライブラリは、いくつかの演算子をあなたが使うために定義します、その多くは<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>基本の演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>先進の演算子<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift standard library defines a protocol called <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>, which requires any conforming type to implement the equal to operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>) and the not equal to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>) to compare any two values of that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト標準ライブラリは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>と呼ばれるプロトコルを定義します、それは、それに準拠している全ての型に対してその型のあらゆる２つの値を比較するために同等演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>）と不等演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>）を実装することを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift standard library includes tuple comparison operators for tuples with fewer than seven elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト標準ライブラリは、いくらかのタプル比較演算子を、７要素より少数でのタプルに対して含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The above example implements an “equal to” operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>) to check if two <bpt i="1" x="1">&lt;c1&gt;</bpt>Vector2D<ept i="1">&lt;/c1&gt;</ept> instances have equivalent values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上記の例は、ある「同等」演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>）を実装して、２つの<bpt i="1" x="1">&lt;c1&gt;</bpt>Vector2D<ept i="1">&lt;/c1&gt;</ept>インスタンスが同じ値を持つかどうか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The above example uses a <bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept> statement to ensure that the <bpt i="1" x="1">&lt;c1&gt;</bpt>open(_:)<ept i="1">&lt;/c1&gt;</ept> function has a corresponding call to <bpt i="2" x="2">&lt;c2&gt;</bpt>close(_:)<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept>文を使って、<bpt i="1" x="1">&lt;c1&gt;</bpt>open(_:)<ept i="1">&lt;/c1&gt;</ept>関数がそれと対応する<bpt i="2" x="2">&lt;c2&gt;</bpt>close(_:)<ept i="2">&lt;/c2&gt;</ept>への呼び出しを持つことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The access control level of a type also affects the default access level of that type’s <bpt i="0" x="0">&lt;e0&gt;</bpt>members<ept i="0">&lt;/e0&gt;</ept> (its properties, methods, initializers, and subscripts).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型のアクセス制御水準はまた、その型の<bpt i="0" x="0">&lt;e0&gt;</bpt>メンバー<ept i="0">&lt;/e0&gt;</ept>（それのプロパティ、メソッド、イニシャライザ、そして添え字）の省略時のアクセス水準に影響を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The access level for a function type is calculated as the most restrictive access level of the function’s parameter types and return type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数型のためのアクセス水準は、その関数のパラメータ型と戻り型での最も制限の多いアクセス水準と同じに算出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The access level for a generic type or generic function is the minimum of the access level of the generic type or function itself and the access level of any type constraints on its type parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体型または総称体関数のためのアクセス水準は、総称体型または関数自身のアクセス水準およびその型パラメータ上のあらゆる型制約のアクセス水準の最少のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The access level for a tuple type is the most restrictive access level of all types used in that tuple.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプル型のためのアクセス水準は、そのタプルで使われる全ての型での最も制限的なアクセス水準です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The access level of each requirement within a protocol definition is automatically set to the same access level as the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル定義内の各要件のアクセス水準は、自動的にプロトコルと同じアクセス水準に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The actual type to use for that associated type isn’t specified until the protocol is adopted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その関連型のために使われる実際の型は、プロトコルが採用されるまでは指定されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The actual type to use in place of <bpt i="12" x="12">&lt;c12&gt;</bpt>T<ept i="12">&lt;/c12&gt;</ept> is determined each time the <bpt i="13" x="13">&lt;c13&gt;</bpt>swapTwoValues(_:_:)<ept i="13">&lt;/c13&gt;</ept> function is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="12" x="12">&lt;c12&gt;</bpt>T<ept i="12">&lt;/c12&gt;</ept>の代わりに実際に使われる型は、<bpt i="13" x="13">&lt;c13&gt;</bpt>swapTwoValues(_:_:)<ept i="13">&lt;/c13&gt;</ept>関数が呼ばれるたびに決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The addition operator is also supported for <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> concatenation:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加算演算子は、また、<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>連結に対してもサポートされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The appropriate choice of weak or unowned depends on the relationships between the different parts of your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>弱いまたは非所有者の適切な選択は、あなたのコードの異なる部分間の関係に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The appropriate floating-point type to use depends on the nature and range of values you need to work with in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>使うのに適切な浮動小数点型は、あなたのコードにおいて扱わなければならない値の種別と幅に依ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The appropriate form to use depends on the scope at which the variable is declared and the kind of variable you intend to declare.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>使用するのに適切な形式は、その変数が宣言されるスコープとあなたが宣言するつもりである変数の種類に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The argument is automatically converted to a closure, because the <bpt i="4" x="4">&lt;c4&gt;</bpt>customerProvider<ept i="4">&lt;/c4&gt;</ept> parameter’s type is marked with the <bpt i="5" x="5">&lt;c5&gt;</bpt>@autoclosure<ept i="5">&lt;/c5&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数は、自動的にクロージャに変換されます、なぜなら<bpt i="4" x="4">&lt;c4&gt;</bpt>customerProvider<ept i="4">&lt;/c4&gt;</ept>パラメータの型は<bpt i="5" x="5">&lt;c5&gt;</bpt>@autoclosure<ept i="5">&lt;/c5&gt;</ept>属性で印されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The argument label is used when calling the function; each argument is written in the function call with its argument label before it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数ラベルは、関数を呼び出すときに使われます；各引数は、関数呼び出しにおいてそれの前のそれの引数ラベルとともに書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The argument value passed to this parameter specifies how much <bpt i="4" x="4">&lt;c4&gt;</bpt>runningTotal<ept i="4">&lt;/c4&gt;</ept> should be incremented by each time the returned incrementer function is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このパラメータに渡された引き数の値は、返されたインクリメンタ関数（漸増器関数）が呼ばれるたびに、どのくらい<bpt i="4" x="4">&lt;c4&gt;</bpt>runningTotal<ept i="4">&lt;/c4&gt;</ept>が増やされなければならないかについて指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The arguments to the initializer are passed like a function call when you create an instance of the class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザに対する引数は、あなたがクラスのインスタンスをつくるときに関数呼び出しのように渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The arithmetic addition operator is a <bpt i="1" x="1">&lt;e1&gt;</bpt>binary operator<ept i="1">&lt;/e1&gt;</ept> because it operates on two targets and is said to be <bpt i="2" x="2">&lt;e2&gt;</bpt>infix<ept i="2">&lt;/e2&gt;</ept> because it appears in between those two targets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>算術加算演算子は、それが２つの目標に作用するので<bpt i="1" x="1">&lt;e1&gt;</bpt>二項演算子<ept i="1">&lt;/e1&gt;</ept>です、そして、それがそれらの２つの目標の間に現れるので<bpt i="2" x="2">&lt;e2&gt;</bpt>接中辞<ept i="2">&lt;/e2&gt;</ept>と言われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The array <bpt i="3" x="3">&lt;c3&gt;</bpt>[16, 58, 510]<ept i="3">&lt;/c3&gt;</ept> is used to create the new array <bpt i="4" x="4">&lt;c4&gt;</bpt>["OneSix", "FiveEight", "FiveOneZero"]<ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列<bpt i="3" x="3">&lt;c3&gt;</bpt>[16, 58, 510]<ept i="3">&lt;/c3&gt;</ept>は、新しい配列<bpt i="4" x="4">&lt;c4&gt;</bpt>["OneSix", "FiveEight", "FiveOneZero"]<ept i="4">&lt;/c4&gt;</ept>をつくるために使われます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The array is declared outside the scope of the function, which means the closures in the array can be executed after the function returns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この配列は関数のスコープの外側で宣言されます、それは配列の中のクロージャが関数が戻った後で実行されることができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The assignment is part of the optional chaining, which means none of the code on the right-hand side of the <bpt i="0" x="0">&lt;c0&gt;</bpt>=<ept i="0">&lt;/c0&gt;</ept> operator is evaluated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この代入はオプショナル連鎖の一部です、それが意味するのは、<bpt i="0" x="0">&lt;c0&gt;</bpt>=<ept i="0">&lt;/c0&gt;</ept>演算子の右手側で評価されるコードは何もないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The assignment operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>=<ept i="0">&lt;/c0&gt;</ept>) doesn’t return a value, to prevent it from being mistakenly used when the equal to operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>) is intended.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代入演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>=<ept i="0">&lt;/c0&gt;</ept>）は値を返しません、同等演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>）が意図される時にそれが誤って使われるのを防ぐためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The assignment operator does not return any value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代入演算子は、少しの値も返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The audio channels described above are represented by instances of the <bpt i="0" x="0">&lt;c0&gt;</bpt>AudioChannel<ept i="0">&lt;/c0&gt;</ept> structure:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上で記述される音声のチャンネルは、<bpt i="0" x="0">&lt;c0&gt;</bpt>AudioChannel<ept i="0">&lt;/c0&gt;</ept>構造体のインスタンスによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The availability condition above specifies that in iOS, the body of the <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement executes only in iOS 10 and later; in macOS, only in macOS 10.12 and later.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の有効性条件が指定するのは、iOS上では、<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>の本文はiOS 10以降でのみ；macOS上では、macOS 10.12以降でのみ実行することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The availability condition takes a comma-separated list of platform names and versions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>有効性条件は、プラットホーム名とバージョンのコンマ区切りのリストを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The backticks aren’t considered part of the identifier; <bpt i="3" x="3">&lt;c3&gt;</bpt>`x`<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept> have the same meaning.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッククォートは、識別子の一部とみなされません；<bpt i="3" x="3">&lt;c3&gt;</bpt>`x`<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>は、同じ意味を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The barcode example in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Associated Values<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> shows how cases of an enumeration can declare that they store associated values of different types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>関連値<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>におけるバーコード例は、それらが異なる型の関連値を格納することを、ある列挙のケース節たちがどのように宣言可能かを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The base class in the hierarchy is called <bpt i="0" x="0">&lt;c0&gt;</bpt>Food<ept i="0">&lt;/c0&gt;</ept>, which is a simple class to encapsulate the name of a foodstuff.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この階層構造における基盤クラスは<bpt i="0" x="0">&lt;c0&gt;</bpt>Food<ept i="0">&lt;/c0&gt;</ept>と呼ばれています、それは、食品の名前をカプセル化する単純なクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The basic form imports the entire module; it consists of the <bpt i="1" x="1">&lt;c1&gt;</bpt>import<ept i="1">&lt;/c1&gt;</ept> keyword followed by a module name:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基本の形式は、そのモジュール全体をインポートします；それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>import<ept i="1">&lt;/c1&gt;</ept>キーワードとそれに続くモジュール名から成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The basic syntax for type constraints on a generic function is shown below (although the syntax is the same for generic types):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体関数に関する型制約のための基本の構文は、下で示されます（とはいえ構文は総称体型と同じものです）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The behavior of <bpt i="5" x="5">&lt;c5&gt;</bpt>x as! T<ept i="5">&lt;/c5&gt;</ept> is the same as the behavior of <bpt i="6" x="6">&lt;c6&gt;</bpt>(x as? T)!<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>x as! T<ept i="5">&lt;/c5&gt;</ept>の挙動は、<bpt i="6" x="6">&lt;c6&gt;</bpt>(x as? T)!<ept i="6">&lt;/c6&gt;</ept>の挙動と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The behavior you see in your code will always be as if a copy took place.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあなたのコードにおいて見るこの挙動は、常にコピーが起こったかのようです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bit-shifting behavior for unsigned integers is as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号なし整数のためのビットシフト挙動は、次の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bitwise AND operator combines them to make the number <bpt i="3" x="3">&lt;c3&gt;</bpt>00111100<ept i="3">&lt;/c3&gt;</ept>, which is equal to an unsigned decimal value of <bpt i="4" x="4">&lt;c4&gt;</bpt>60<ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の論理積演算子は、それらを結合して、数<bpt i="3" x="3">&lt;c3&gt;</bpt>00111100<ept i="3">&lt;/c3&gt;</ept>をつくります、それは、符号なしの10進数の<bpt i="4" x="4">&lt;c4&gt;</bpt>60<ept i="4">&lt;/c4&gt;</ept>と等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bitwise NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の論理否定演算子は、接頭辞演算子で、少しの空白なしで、それが作用する値の直前に現れまます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bitwise NOT operator is then used to create a new constant called <bpt i="0" x="0">&lt;c0&gt;</bpt>invertedBits<ept i="0">&lt;/c0&gt;</ept>, which is equal to <bpt i="1" x="1">&lt;c1&gt;</bpt>initialBits<ept i="1">&lt;/c1&gt;</ept>, but with all of the bits inverted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の論理否定演算子は、それから<bpt i="0" x="0">&lt;c0&gt;</bpt>invertedBits<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しい定数をつくるために使われます、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>initialBits<ept i="1">&lt;/c1&gt;</ept>と等しいです、しかし全てのビットは逆にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bitwise OR operator combines them to make the number <bpt i="3" x="3">&lt;c3&gt;</bpt>11111110<ept i="3">&lt;/c3&gt;</ept>, which equals an unsigned decimal of <bpt i="4" x="4">&lt;c4&gt;</bpt>254<ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の論理和演算子は、それらを結合して、数<bpt i="3" x="3">&lt;c3&gt;</bpt>11111110<ept i="3">&lt;/c3&gt;</ept>を作ります、それは、符号なしの10進数の<bpt i="4" x="4">&lt;c4&gt;</bpt>254<ept i="4">&lt;/c4&gt;</ept>と等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The bitwise XOR operator sets both of these bits to <bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept> in its output value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビット単位の排他的論理和演算子は、これらのビットの両方ともその出力値において<bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The board has 25 squares, and the aim is to land on or beyond square 25.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この盤には25の正方形があります、そして目ざすのは正方形25の上に乗るまたは越える事です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The body of a class contains zero or more <bpt i="0" x="0">&lt;e0&gt;</bpt>declarations<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスの本文は、０個以上の<bpt i="0" x="0">&lt;e0&gt;</bpt>宣言<ept i="0">&lt;/e0&gt;</ept>を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The body of a protocol contains zero or more <bpt i="0" x="0">&lt;e0&gt;</bpt>protocol member declarations<ept i="0">&lt;/e0&gt;</ept>, which describe the conformance requirements that any type adopting the protocol must fulfill.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルの本文は０以上の<bpt i="0" x="0">&lt;e0&gt;</bpt>プロトコルメンバー宣言<ept i="0">&lt;/e0&gt;</ept>を含みます、それは、プロトコルを採用しているすべての型が満たさなければならない準拠要件を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The body of a structure contains zero or more <bpt i="0" x="0">&lt;e0&gt;</bpt>declarations<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造の本文は、０以上の<bpt i="0" x="0">&lt;e0&gt;</bpt>宣言<ept i="0">&lt;/e0&gt;</ept>を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The body of an enumeration declared using either form contains zero or more values—called <bpt i="1" x="1">&lt;e1&gt;</bpt>enumeration cases<ept i="1">&lt;/e1&gt;</ept>—and any number of declarations, including computed properties, instance methods, type methods, initializers, type aliases, and even other enumeration, structure, and class declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どちらの形式を使って宣言される列挙宣言の本文でも、０以上の値 ― <bpt i="1" x="1">&lt;e1&gt;</bpt>列挙ケース節<ept i="1">&lt;/e1&gt;</ept>と呼ばれるもの ― および任意の数の宣言から成っていて、計算プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、型エイリアス、そして他の列挙、構造体、およびクラス宣言さえも含められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The body of an extension declaration contains zero or more <bpt i="0" x="0">&lt;e0&gt;</bpt>declarations<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張宣言の本文は、０個以上の<bpt i="0" x="0">&lt;e0&gt;</bpt>宣言<ept i="0">&lt;/e0&gt;</ept>を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The body of each case <bpt i="0" x="0">&lt;e0&gt;</bpt>must<ept i="0">&lt;/e0&gt;</ept> contain at least one executable statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれのケース節の本文は、少なくとも１つの実行可能な文を含んでいることが<bpt i="0" x="0">&lt;e0&gt;</bpt>必要です<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The body of the <bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:)<ept i="0">&lt;/c0&gt;</ept> function starts by defining a new <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> constant called <bpt i="2" x="2">&lt;c2&gt;</bpt>greeting<ept i="2">&lt;/c2&gt;</ept> and setting it to a simple greeting message.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:)<ept i="0">&lt;/c0&gt;</ept>関数の本文は、<bpt i="2" x="2">&lt;c2&gt;</bpt>greeting<ept i="2">&lt;/c2&gt;</ept>と呼ばれる新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>定数を定義してそれを単純な挨拶メッセージに設定することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The body of the <bpt i="0" x="0">&lt;c0&gt;</bpt>minMax(array:)<ept i="0">&lt;/c0&gt;</ept> function starts by setting two working variables called <bpt i="1" x="1">&lt;c1&gt;</bpt>currentMin<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>currentMax<ept i="2">&lt;/c2&gt;</ept> to the value of the first integer in the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>minMax(array:)<ept i="0">&lt;/c0&gt;</ept>の本文は、<bpt i="1" x="1">&lt;c1&gt;</bpt>currentMin<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>currentMax<ept i="2">&lt;/c2&gt;</ept>と呼ばれる２つの作業用の変数を配列の最初の整数に設定することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The body of the <bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoValues(_:_:)<ept i="0">&lt;/c0&gt;</ept> function is identical to the body of the <bpt i="1" x="1">&lt;c1&gt;</bpt>swapTwoInts(_:_:)<ept i="1">&lt;/c1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoValues(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数の本文は、<bpt i="1" x="1">&lt;c1&gt;</bpt>swapTwoInts(_:_:)<ept i="1">&lt;/c1&gt;</ept>関数の本文と同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The brackets tell Swift that <bpt i="3" x="3">&lt;c3&gt;</bpt>T<ept i="3">&lt;/c3&gt;</ept> is a placeholder type name within the <bpt i="4" x="4">&lt;c4&gt;</bpt>swapTwoValues(_:_:)<ept i="4">&lt;/c4&gt;</ept> function definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この括弧は、<bpt i="3" x="3">&lt;c3&gt;</bpt>T<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>swapTwoValues(_:_:)<ept i="4">&lt;/c4&gt;</ept>関数定義内のプレースホルダ型名であるとスウィフトに教えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The call to <bpt i="11" x="11">&lt;c11&gt;</bpt>increment(forCount:)<ept i="11">&lt;/c11&gt;</ept> happens only if <bpt i="12" x="12">&lt;c12&gt;</bpt>increment(forCount:)<ept i="12">&lt;/c12&gt;</ept> exists—that is, if it isn’t <bpt i="13" x="13">&lt;c13&gt;</bpt>nil<ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="11" x="11">&lt;c11&gt;</bpt>increment(forCount:)<ept i="11">&lt;/c11&gt;</ept>への呼び出しは、<bpt i="12" x="12">&lt;c12&gt;</bpt>increment(forCount:)<ept i="12">&lt;/c12&gt;</ept>が存在する場合にのみ起こります ― すなわち、それが<bpt i="13" x="13">&lt;c13&gt;</bpt>nil<ept i="13">&lt;/c13&gt;</ept>でない場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The call to the <bpt i="0" x="0">&lt;c0&gt;</bpt>digitNames<ept i="0">&lt;/c0&gt;</ept> dictionary’s subscript is followed by an exclamation mark (<bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>), because dictionary subscripts return an optional value to indicate that the dictionary lookup can fail if the key does not exist.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>digitNames<ept i="0">&lt;/c0&gt;</ept>辞書への呼び出しの添え字の後に感嘆符（<bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>）が続きます、なぜなら、キーが存在しない場合は辞書検索が失敗し得ることを意味するために、辞書添え字がオプショナルの値を返すからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The capabilities described above for computing and observing properties are also available to <bpt i="0" x="0">&lt;e0&gt;</bpt>global variables<ept i="0">&lt;/e0&gt;</ept> and <bpt i="1" x="1">&lt;e1&gt;</bpt>local variables<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算するそして監視するプロパティに対して上で記述される可能なことは、また、<bpt i="0" x="0">&lt;e0&gt;</bpt>グローバル変数<ept i="0">&lt;/e0&gt;</ept>と<bpt i="1" x="1">&lt;e1&gt;</bpt>ローカル変数<ept i="1">&lt;/e1&gt;</ept>に対して利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The case values of an enumeration are actual values, not just another way of writing their raw values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある列挙に属するケース節の値は実際の値です、単にそれらの生の値を別のやり方で書くことではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The chapter’s example of <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Overriding Property Getters and Setters<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> has been rewritten to show how to override a <bpt i="4" x="4">&lt;c4&gt;</bpt>description<ept i="4">&lt;/c4&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この章の<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>プロパティゲッターとセッターのオーバーライド<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の例は書き直されて、<bpt i="4" x="4">&lt;c4&gt;</bpt>description<ept i="4">&lt;/c4&gt;</ept>プロパティをオーバーライドする方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The characters are visually similar, but don’t have the same linguistic meaning:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの文字は視覚的には同じ形です、しかし同じ言語的意味を持ちません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The class also defines a deinitializer, which prints a message to show when an <bpt i="3" x="3">&lt;c3&gt;</bpt>HTMLElement<ept i="3">&lt;/c3&gt;</ept> instance is deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスもデイニシャライザを定義します、それは、<bpt i="3" x="3">&lt;c3&gt;</bpt>HTMLElement<ept i="3">&lt;/c3&gt;</ept>インスタンスが割り当て解除される場合に示すメッセージを出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The class instance is not fully valid until the first phase ends.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第１段階が終わるまで、クラスインスタンスは充分に有効ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The class is assumed to take a nontrivial amount of time to initialize.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（このクラスは、瑣末でない量の時間が初期化にかかると仮定されます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The closed range operator has an alternative form for ranges that continue as far as possible in one direction—for example, a range that includes all the elements of an array from index 2 to the end of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>完結範囲演算子は、一方向に可能な限り続く範囲 — 例えば、インデックス２から配列の最後までの配列のすべての要素を含む範囲、などに対する代替の形式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The closed range operator is useful when iterating over a range in which you want all of the values to be used, such as with a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>完結範囲演算子は、あなたがその値の全てが使われることを望む、ある範囲全体に渡って繰り返すときに役に立ちます、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループで：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The closure can be used to create a string representation of any integer greater than zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このクロージャは、ゼロより大きいあらゆる整数の文字列表現を作るために使われることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The closure can then refer to and modify the values of those constants and variables from within its body, even if the original scope that defined the constants and variables no longer exists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャはそれから、その本文内からそれらの定数と変数の値に言及することや修正することができます、たとえその定数と変数を定義した本来のスコープがもはや存在しないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The closure expression also specifies a return type of <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>, to indicate the type that will be stored in the mapped output array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャ式はまた、<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>の戻り型を指定します、それによってマップされた出力配列の中に格納されることになる型を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The closure expression builds a string called <bpt i="0" x="0">&lt;c0&gt;</bpt>output<ept i="0">&lt;/c0&gt;</ept> each time it is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャ式は、それが呼ばれるたびに、<bpt i="0" x="0">&lt;c0&gt;</bpt>output<ept i="0">&lt;/c0&gt;</ept>と呼ばれる文字列をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The closure expression examples below illustrate these optimizations by refining a single example of the <bpt i="1" x="1">&lt;c1&gt;</bpt>sorted(by:)<ept i="1">&lt;/c1&gt;</ept> method over several iterations, each of which expresses the same functionality in a more succinct way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のクロージャ式の例は、これらの最適化を一つの例の<bpt i="1" x="1">&lt;c1&gt;</bpt>sorted(by:)<ept i="1">&lt;/c1&gt;</ept>メソッドの改良をいくどか繰り返していくことで解説します、そして、そのそれぞれは同じ機能性をより簡潔な方法で表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The closure expression examples below use the <bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept> method to sort an array of <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> values in reverse alphabetical order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下のクロージャ式の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使用して<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値からなる配列を逆アルファベット順に分類します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The closure in the example above calculates and sets the appropriate color for each square on the board in a temporary array called <bpt i="2" x="2">&lt;c2&gt;</bpt>temporaryBoard<ept i="2">&lt;/c2&gt;</ept>, and returns this temporary array as the closure’s return value once its setup is complete.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例でのクロージャは<bpt i="2" x="2">&lt;c2&gt;</bpt>temporaryBoard<ept i="2">&lt;/c2&gt;</ept>と呼ばれる一時的な配列の中の板上の各正方形に対して適切な色を計算して設定します、そしてひとたびその準備が完了されたならば、この一時的な配列をクロージャの戻り値として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The closure is called once for each item in the array, and returns an alternative mapped value (possibly of some other type) for that item.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャは、配列の中の各項目に対して一度だけ呼ばれて、その項目のための代わりの対応付けされた（おそらく何か他の型の）値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code above calls the <bpt i="0" x="0">&lt;c0&gt;</bpt>continue<ept i="0">&lt;/c0&gt;</ept> keyword whenever it matches a vowel or a space, causing the current iteration of the loop to end immediately and to jump straight to the start of the next iteration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上のコードは、それが母音または空白と合致するたびに<bpt i="0" x="0">&lt;c0&gt;</bpt>continue<ept i="0">&lt;/c0&gt;</ept>キーワードを呼んで、ループの現在の繰り返しを直ちに終わって、次の繰り返しのスタートへまっすぐポンと飛ぶようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code above creates a dictionary of mappings between the integer digits and English-language versions of their names.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上のコードは、整数桁とそれらの名前の英語版の間で対応付けをする辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code above creates a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept> instance; sets its data source to be a new <bpt i="1" x="1">&lt;c1&gt;</bpt>ThreeSource<ept i="1">&lt;/c1&gt;</ept> instance; and calls the counter’s <bpt i="2" x="2">&lt;c2&gt;</bpt>increment()<ept i="2">&lt;/c2&gt;</ept> method four times.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上のコードは、新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept>インスタンスをつくり；それのデータ・ソースを新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>ThreeSource<ept i="1">&lt;/c1&gt;</ept>インスタンスであるように設定します；そして、counterの<bpt i="2" x="2">&lt;c2&gt;</bpt>increment()<ept i="2">&lt;/c2&gt;</ept>メソッドを４回呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code above succeeds when <bpt i="0" x="0">&lt;c0&gt;</bpt>john.residence<ept i="0">&lt;/c0&gt;</ept> has a non-<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> value and will set <bpt i="2" x="2">&lt;c2&gt;</bpt>roomCount<ept i="2">&lt;/c2&gt;</ept> to an <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> value containing the appropriate number of rooms.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>john.residence<ept i="0">&lt;/c0&gt;</ept>が非<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>値を持って、<bpt i="2" x="2">&lt;c2&gt;</bpt>roomCount<ept i="2">&lt;/c2&gt;</ept>を部屋の適当な数を含んでいる<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>値に設定するとき、上のコードは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code above uses the ternary conditional operator and forced unwrapping (<bpt i="0" x="0">&lt;c0&gt;</bpt>a!<ept i="0">&lt;/c0&gt;</ept>) to access the value wrapped inside <bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept> when <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept> is not <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>, and to return <bpt i="4" x="4">&lt;c4&gt;</bpt>b<ept i="4">&lt;/c4&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上のコードは、三項条件演算子と強制アンラップ（<bpt i="0" x="0">&lt;c0&gt;</bpt>a!<ept i="0">&lt;/c0&gt;</ept>）を使って、<bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>でないならば<bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept>内部にラップされた値にアクセスします、それ以外では<bpt i="4" x="4">&lt;c4&gt;</bpt>b<ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code below shows four examples of these special characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のコードは、これらの特殊文字の４つの例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code below shows how a closure delays evaluation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下のコードは、どのようにクロージャが評価を遅らすかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code below shows the <bpt i="3" x="3">&lt;c3&gt;</bpt>ArithmeticExpression<ept i="3">&lt;/c3&gt;</ept> recursive enumeration being created for <bpt i="4" x="4">&lt;c4&gt;</bpt>(5 + 4) * 2<ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のコードは、<bpt i="4" x="4">&lt;c4&gt;</bpt>(5 + 4) * 2<ept i="4">&lt;/c4&gt;</ept>に対して作成されている再帰列挙<bpt i="3" x="3">&lt;c3&gt;</bpt>ArithmeticExpression<ept i="3">&lt;/c3&gt;</ept>を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code in a closure has access to things like variables and functions that were available in the scope where the closure was created, even if the closure is in a different scope when it is executed—you saw an example of this already with nested functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクロージャの中のコードは、そのクロージャが作成されたところのスコープ内で利用可能だった変数や関数といったものにアクセスをします、たとえそのクロージャが実行されるときに異なるスコープの中にあってもです ― あなたはこの例を入れ子にされた関数で既に見ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code is executed regardless of whether the function throws an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのコードは、関数がエラーをスローするかどうかに関係なく実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code snippets below define four model classes for use in several subsequent examples, including examples of multilevel optional chaining.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下のコード切れっぱしは、複数階層のオプショナル連鎖の例を含む以降のいくつかの例のために、４つのモデル・クラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code within a default case is executed only if no other cases match the control expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他のいかなるケース節も制御式にマッチしない場合だけ、省略時のケース節内のコードは実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code you provide is run any time the value changes outside of an initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが提供したコードは、その値がイニシャライザの外側で変化する時はいつでも実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The colon in the declaration means “…of type…,” so the code above can be read as:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>宣言でのコロンは「…の型の…」を意味します、それで上のコードは次のように読まれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The column number in which it begins.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが開始するコラム番号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The compiler also detects methods with <bpt i="2" x="2">&lt;c2&gt;</bpt>override<ept i="2">&lt;/c2&gt;</ept> that don’t actually override any method in the superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラはまた、実際にはスーパークラスにおけるメソッドを少しもオーバーライドしない<bpt i="2" x="2">&lt;c2&gt;</bpt>override<ept i="2">&lt;/c2&gt;</ept>をもつメソッドも検出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The compiler assumes that preconditions are always true, and it optimizes your code accordingly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラは、その前提条件が常にtrueであるとみなします、そしてそれはあなたのコードをそれを受けて最適化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The compiler implicitly adds the <bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept> attribute to subclasses of any class defined in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラは、Objective-Cにおいて定義されたあらゆるクラスのサブクラスに暗黙的に<bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept>属性を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The compiler is optimized for performance and the language is optimized for development, without compromising on either.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラはパフォーマンスのために最適化され言語は開発のために最適化されます、どちらについても妥協することなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The compiler uses availability information in the SDK to verify that all of the APIs used in your code are available on the deployment target specified by your project.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラは、SDKの中の有効性情報を使って、あなたのコードの中で使用されるAPIの全てがあなたのプロジェクトで指定される開発対象で有効であることを確かめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The compiler uses the information from the availability condition when it verifies that the APIs in that block of code are available.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラは、有効性条件からの情報を、それがそのブロックの中のAPIが利用可能であることを確かめる時に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The compound assignment operators don’t return a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複合代入演算子は、値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The computed <bpt i="3" x="3">&lt;c3&gt;</bpt>numberOfRooms<ept i="3">&lt;/c3&gt;</ept> property simply returns the value of the <bpt i="4" x="4">&lt;c4&gt;</bpt>count<ept i="4">&lt;/c4&gt;</ept> property from the <bpt i="5" x="5">&lt;c5&gt;</bpt>rooms<ept i="5">&lt;/c5&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>計算<bpt i="3" x="3">&lt;c3&gt;</bpt>numberOfRooms<ept i="3">&lt;/c3&gt;</ept>プロパティは、単に<bpt i="5" x="5">&lt;c5&gt;</bpt>rooms<ept i="5">&lt;/c5&gt;</ept>配列から<bpt i="4" x="4">&lt;c4&gt;</bpt>count<ept i="4">&lt;/c4&gt;</ept>プロパティの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The computed type property examples above are for read-only computed type properties, but you can also define read-write computed type properties with the same syntax as for computed instance properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の計算型プロパティの例は、読み出し専用の計算型プロパティのためのものです、しかしあなたはまた、計算インスタンスプロパティについては同じ構文をつかって読み書き両用の計算型プロパティを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The concept of a stack is used by the <bpt i="0" x="0">&lt;c0&gt;</bpt>UINavigationController<ept i="0">&lt;/c0&gt;</ept> class to model the view controllers in its navigation hierarchy.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スタックの概念は、<bpt i="0" x="0">&lt;c0&gt;</bpt>UINavigationController<ept i="0">&lt;/c0&gt;</ept>クラスで使用されて、そのナビゲーション階層においてビュー・コントローラをモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The concept of optionals doesn’t exist in C or Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの概念は、CまたはObjective-Cの中に存在しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The condition can also be an optional binding declaration, as discussed in <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Optional Binding<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>条件はまた、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>オプショナル束縛<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>で議論される、オプショナル束縛宣言であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The condition of a loop can be at the end instead, ensuring that the loop is run at least once.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループの条件は終わりに置くことができます、その場合にはループが少なくとも一回は実行されることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The conditional form, <bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>, returns an optional value of the type you are trying to downcast to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>条件（仮定）形式<bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>は、あなたがダウンキャストしようとしている型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The contents of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> are inherently unordered, and iterating over them does not guarantee the order in which they will be retrieved.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>の内容は本質的に順序付けされません、そしてそれらに繰り返すことはそれらが取り出される順番を保証しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The contents of a <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept> can be accessed in various ways, including as a collection of <bpt i="5" x="5">&lt;c5&gt;</bpt>Character<ept i="5">&lt;/c5&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>の内容は、いくつかのやり方でアクセスされることができます、それには<bpt i="5" x="5">&lt;c5&gt;</bpt>Character<ept i="5">&lt;/c5&gt;</ept>値からなるひとつのコレクションとしてを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The contents of this expression are also considered when performing type inference on the surrounding expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この式の内容はまた、型推論を実行する時に周囲の式上にあると見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The context and function name should make it clear that evaluation is being deferred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文脈と関数名は、評価が猶予されていることを明確にしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The context in which a type conforms to a particular protocol is the minimum of the type’s access level and the protocol’s access level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型が特定のプロトコルに準拠するところの前後関係は、その型のアクセス水準とプロトコルのアクセス水準の最も低いものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The convenience initializer must call one of the two designated initializers, because it can only call another initializer from the same class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>便宜イニシャライザは、２つの指定イニシャライザのうちの１つを呼ぶに違いありません、なぜなら、それが同じクラスから別のイニシャライザを呼ぶことができるだけだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The corresponding argument must have no label in function or method calls.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対応する引数には、関数またはメソッドの呼び出しにおいてラベルがあってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The corresponding argument must use the given argument label in function or method calls.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対応する引数は、この引数ラベルを関数またはメソッドの呼び出しにおいて使わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The corresponding implementation for <bpt i="0" x="0">&lt;c0&gt;</bpt>Vector2D<ept i="0">&lt;/c0&gt;</ept> instances performs this operation on both the <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>y<ept i="2">&lt;/c2&gt;</ept> properties:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Vector2D<ept i="0">&lt;/c0&gt;</ept>インスタンス対応の実装は、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>y<ept i="2">&lt;/c2&gt;</ept>プロパティ両方の上でこの操作を実行します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The corresponding section in <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Strings and Characters<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> has been removed, and various code examples have been updated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>文字列と文字<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>の中の関連する節は削除されました、そしてさまざまなコード例が更新されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The count of the characters returned by the <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> property isn’t always the same as the <bpt i="1" x="1">&lt;c1&gt;</bpt>length<ept i="1">&lt;/c1&gt;</ept> property of an <bpt i="2" x="2">&lt;c2&gt;</bpt>NSString<ept i="2">&lt;/c2&gt;</ept> that contains the same characters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>プロパティによって返される文字の総数は、同じ文字を含む<bpt i="2" x="2">&lt;c2&gt;</bpt>NSString<ept i="2">&lt;/c2&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>length<ept i="1">&lt;/c1&gt;</ept>プロパティと常に同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The current <bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> loop execution then ends, and the loop’s condition is checked to see if the loop should be executed again.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>現在の<bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>ループ実行はそれから終了します、そしてループが再び実行されなければならないかどうか見るためにループの条件が調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The current center position of a <bpt i="2" x="2">&lt;c2&gt;</bpt>Rect<ept i="2">&lt;/c2&gt;</ept> can always be determined from its <bpt i="3" x="3">&lt;c3&gt;</bpt>origin<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>size<ept i="4">&lt;/c4&gt;</ept>, and so you don’t need to store the center point as an explicit <bpt i="5" x="5">&lt;c5&gt;</bpt>Point<ept i="5">&lt;/c5&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Rect<ept i="2">&lt;/c2&gt;</ept>の現在の中心位置は常にその<bpt i="3" x="3">&lt;c3&gt;</bpt>origin<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>size<ept i="4">&lt;/c4&gt;</ept>から決定されることができます、なのであなたは中心点をわざわざ<bpt i="5" x="5">&lt;c5&gt;</bpt>Point<ept i="5">&lt;/c5&gt;</ept>値として保存する必要ばありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The current login attempt counter is declared as a variable, because this value must be incremented after each failed login attempt.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>現在のログイン試行の計数は、この値が失敗したログインの試みそれぞれの後で増加する必要があるので、変数として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The current loop execution then ends.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>現在のループ実行はそれで終わりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The decimal fraction consists of a decimal point (<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>) followed by a sequence of decimal digits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>小数部は、小数点（<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>）に続く一連の10進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The declaration has the <bpt i="0" x="0">&lt;c0&gt;</bpt>IBAction<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>IBOutlet<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>IBDesignable<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>IBInspectable<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>NSManaged<ept i="4">&lt;/c4&gt;</ept>, or <bpt i="5" x="5">&lt;c5&gt;</bpt>GKInspectable<ept i="5">&lt;/c5&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その宣言は、<bpt i="0" x="0">&lt;c0&gt;</bpt>IBAction<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>IBOutlet<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>IBDesignable<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>IBInspectable<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>NSManaged<ept i="4">&lt;/c4&gt;</ept>、または<bpt i="5" x="5">&lt;c5&gt;</bpt>GKInspectable<ept i="5">&lt;/c5&gt;</ept>を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The declaration is an override in a subclass, and the superclass’s declaration has the <bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その宣言は、サブクラスの中のオーバーライドである、そしてそのサブクラスの宣言が<bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept>属性を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The declaration of <bpt i="2" x="2">&lt;c2&gt;</bpt>SimpleClass<ept i="2">&lt;/c2&gt;</ept> doesn’t need any of its methods marked as mutating because methods on a class can always modify the class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>SimpleClass<ept i="2">&lt;/c2&gt;</ept>の宣言はそのメソッドのどれも変化するとして印される必要はありません、なぜならあるクラスに属するメソッドは常にそのクラスを修正できるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The declaration satisfies a requirement from a protocol that has the <bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その宣言は、<bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept>属性を持つあるプロトコルからの要件を満たす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The declaration that the <bpt i="1" x="1">&lt;c1&gt;</bpt>available<ept i="1">&lt;/c1&gt;</ept> attribute applies to is ignored if the attribute specifies a platform or language version that doesn’t match the current target.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>available<ept i="1">&lt;/c1&gt;</ept>属性を適用される宣言は、その属性が現在の対象と合致しないプラットホームまたは言語バージョンを指定するならば無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default access level of internal already matches this requirement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時のアクセス水準である内部は、既にこの要件に合致しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default inferred type of a string literal is <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期状態で推論されるリテラル文字列の型は、<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default initializer (when available) is always a designated initializer for a class, and can be used to create a new <bpt i="3" x="3">&lt;c3&gt;</bpt>Vehicle<ept i="3">&lt;/c3&gt;</ept> instance with a <bpt i="4" x="4">&lt;c4&gt;</bpt>numberOfWheels<ept i="4">&lt;/c4&gt;</ept> of <bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時のイニシャライザは（利用可能な場合は）、常にクラスのための指定イニシャライザです、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>の<bpt i="4" x="4">&lt;c4&gt;</bpt>numberOfWheels<ept i="4">&lt;/c4&gt;</ept>をもつ新しい<bpt i="3" x="3">&lt;c3&gt;</bpt>Vehicle<ept i="3">&lt;/c3&gt;</ept>インスタンスを作成するために使用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default initializer simply creates a new instance with all of its properties set to their default values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時のイニシャライザは、単に新しいインスタンスを、そのプロパティの全てをそれらの省略時の値に設定することで作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default memberwise initializer for a structure type is considered private if any of the structure’s stored properties are private.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体型のための省略時のメンバー関連イニシャライザは、その構造体の保存プロパティのいずれかが非公開ならば、非公開であるとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default types are <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept> for integer literals, <bpt i="5" x="5">&lt;c5&gt;</bpt>Double<ept i="5">&lt;/c5&gt;</ept> for floating-point literals, <bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept> for string literals, and <bpt i="7" x="7">&lt;c7&gt;</bpt>Bool<ept i="7">&lt;/c7&gt;</ept> for Boolean literals.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の型は、整数リテラルのための<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>、浮動小数点リテラルのための<bpt i="5" x="5">&lt;c5&gt;</bpt>Double<ept i="5">&lt;/c5&gt;</ept>、文字列リテラルのための<bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>、そしてブールのリテラルのための<bpt i="7" x="7">&lt;c7&gt;</bpt>Bool<ept i="7">&lt;/c7&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default value also makes it easier for you to take advantage of default initializers and initializer inheritance, as described later in this chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時の値はまた、あなたが省略時のイニシャライザとイニシャライザ継承を活用することをより簡単にします、そのことはこの章の後で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The deferred statements may not contain any code that would transfer control out of the statements, such as a <bpt i="2" x="2">&lt;c2&gt;</bpt>break<ept i="2">&lt;/c2&gt;</ept> or a <bpt i="3" x="3">&lt;c3&gt;</bpt>return<ept i="3">&lt;/c3&gt;</ept> statement, or by throwing an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>延期される文は、制御をその文の外に、例えば<bpt i="2" x="2">&lt;c2&gt;</bpt>break<ept i="2">&lt;/c2&gt;</ept>や<bpt i="3" x="3">&lt;c3&gt;</bpt>return<ept i="3">&lt;/c3&gt;</ept>文、またはエラーをスローすることによって移すいかなるコードも含まない方が良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The definition describes what the function does, what it expects to receive, and what it returns when it is done.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定義は、関数が何をするか、それが何を受け取るのを予想するか、そしてそれが実行し終わったとき、それが何を返すかを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The definition makes it easy for the function to be called unambiguously from elsewhere in your code:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定義は、関数があなたのコードのどこか他の場所から誤解の余地なく呼び出されることを簡単にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The definition of <bpt i="4" x="4">&lt;c4&gt;</bpt>typealias Item = Int<ept i="4">&lt;/c4&gt;</ept> turns the abstract type of <bpt i="5" x="5">&lt;c5&gt;</bpt>Item<ept i="5">&lt;/c5&gt;</ept> into a concrete type of <bpt i="6" x="6">&lt;c6&gt;</bpt>Int<ept i="6">&lt;/c6&gt;</ept> for this implementation of the <bpt i="7" x="7">&lt;c7&gt;</bpt>Container<ept i="7">&lt;/c7&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定義<bpt i="4" x="4">&lt;c4&gt;</bpt>typealias Item = Int<ept i="4">&lt;/c4&gt;</ept>は、抽象的な型<bpt i="5" x="5">&lt;c5&gt;</bpt>Item<ept i="5">&lt;/c5&gt;</ept>を具体的な型<bpt i="6" x="6">&lt;c6&gt;</bpt>Int<ept i="6">&lt;/c6&gt;</ept>へと、<bpt i="7" x="7">&lt;c7&gt;</bpt>Container<ept i="7">&lt;/c7&gt;</ept>プロトコルのこの実装のために転向します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The definition of this convenience initializer makes <bpt i="5" x="5">&lt;c5&gt;</bpt>RecipeIngredient<ept i="5">&lt;/c5&gt;</ept> instances quicker and more convenient to create, and avoids code duplication when creating several single-quantity <bpt i="6" x="6">&lt;c6&gt;</bpt>RecipeIngredient<ept i="6">&lt;/c6&gt;</ept> instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この便宜イニシャライザの定義は、<bpt i="5" x="5">&lt;c5&gt;</bpt>RecipeIngredient<ept i="5">&lt;/c5&gt;</ept>インスタンスを素早くより便利に作成されるようにします、そして数量１の<bpt i="6" x="6">&lt;c6&gt;</bpt>RecipeIngredient<ept i="6">&lt;/c6&gt;</ept>インスタンスをいくつか作成する時にコードの繰り返しを防止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The deinitializer does not take any parameters and is written without parentheses:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>デイニシャライザは、まったくパラメータを取りません、したがって丸括弧なしで書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The description above refers to the “copying” of strings, arrays, and dictionaries.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の記述は、文字列、配列、そして辞書の「コピー」について言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定イニシャライザは、そのスーパークラスのイニシャライザに、それ自身の保存プロパティに対して同じ作業を実行するように任せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The designated initializer makes sure that all of the subclass’s properties have a value, as per safety check 1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定イニシャライザは、安全検査１のように、サブクラスのプロパティの全てが値を持つことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The designated initializer of a class must initialize all of the class’s declared properties and it must do so before calling any of its superclass’s designated initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラスの指定イニシャライザは、そのクラスの指定するプロパティのすべてを初期化しなければ成りません、そしてそれは何であれそれのスーパークラスの指定イニシャライザを呼ぶ前にそうしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The dice is rolled at the start of each loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さいころは、各ループの始まりで振られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The difference between assertions and preconditions is in when they’re checked: Assertions are checked only in debug builds, but preconditions are checked in both debug and production builds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>表明と前提条件の間の違いは、それらが調べられる時にあります：表明はデバッグビルドにおいてのみ調べられます、しかし前提条件はデバッグおよび製品（プロダクション）ビルドの両方において調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The difference between open and public access is described below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>開放と公開アクセスの間の違いは下で解説されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The difference between strings and substrings is that, as a performance optimization, a substring can reuse part of the memory that’s used to store the original string, or part of the memory that’s used to store another substring.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列と下位文字列の違いは、性能最適化として、下位文字列はオリジナルの文字列を格納するために使われるメモリについての、または別の下位文字列を格納するために使われるメモリの一部についての再利用ができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The different barcode types can be checked using a switch statement, as before.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>異なるバーコード型は、前の通り、スイッチ文を使って調べられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements of a tuple can be referred to either by name or by number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるタプルの要素たちは、名前または番号で言及されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The elements of an array can be accessed through subscripting by specifying a valid index value in square brackets: <bpt i="1" x="1">&lt;c1&gt;</bpt>someArray[0]<ept i="1">&lt;/c1&gt;</ept> refers to the element at index 0, <bpt i="2" x="2">&lt;c2&gt;</bpt>"Alex"<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の要素は、角括弧の中に有効なインデックス値を指定することによる添え字指定を通してアクセスされることができます：<bpt i="1" x="1">&lt;c1&gt;</bpt>someArray[0]]<ept i="1">&lt;/c1&gt;</ept>は、インデックス0での要素、<bpt i="2" x="2">&lt;c2&gt;</bpt>"Alex"<ept i="2">&lt;/c2&gt;</ept>に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The else clause of an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement can contain another <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept> statement to test more than one condition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文のelse節は、複数の条件をテストするために別の<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>文を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The end result is the same, but the default value ties the property’s initialization more closely to its declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最終的な結果は同じものです、しかし省略時の値は、プロパティの初期化をより密接にその宣言に結び付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The end result is two completely separate instances, which just happened to contain the same numeric values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最終的な結果は２つの完全に別々のインスタンスです、そしてそれらは、たまたま同じ数値を含むということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The end result of calling this alternative version of the method will be exactly the same as for calling the earlier version.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッドのこの代替版を呼ぶ最終結果は、以前の版を呼ぶことと正確に同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The entire expression <bpt i="4" x="4">&lt;c4&gt;</bpt>c?.property.performAction()<ept i="4">&lt;/c4&gt;</ept> has a value of an optional type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>式<bpt i="4" x="4">&lt;c4&gt;</bpt>c?.property.performAction()<ept i="4">&lt;/c4&gt;</ept>の全体がオプショナル型の値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The entries in the capture list are initialized when the closure is created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キャプチャリストの中の登録項目は、クロージャが作成されるときに初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The enumeration below is a refinement of the earlier <bpt i="0" x="0">&lt;c0&gt;</bpt>CompassPoint<ept i="0">&lt;/c0&gt;</ept> enumeration, with string raw values to represent each direction’s name:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の列挙は、前の<bpt i="0" x="0">&lt;c0&gt;</bpt>CompassPoint<ept i="0">&lt;/c0&gt;</ept>列挙の改良版で、各方位の名前を表す文字列の生の値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The enumeration below is a refinement of the earlier <bpt i="0" x="0">&lt;c0&gt;</bpt>Planet<ept i="0">&lt;/c0&gt;</ept> enumeration, with integer raw values to represent each planet’s order from the sun:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の列挙は、以前の<bpt i="0" x="0">&lt;c0&gt;</bpt>Planet<ept i="0">&lt;/c0&gt;</ept>列挙の改良で、太陽からの各惑星の順番を表す整数の生の値をもちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The enumeration cases <bpt i="1" x="1">&lt;c1&gt;</bpt>north<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>south<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>east<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>west<ept i="4">&lt;/c4&gt;</ept> therefore also have an access level of “public”:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この列挙のケース節<bpt i="1" x="1">&lt;c1&gt;</bpt>north<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>south<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>east<ept i="3">&lt;/c3&gt;</ept>、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>west<ept i="4">&lt;/c4&gt;</ept>はしたがってまた「公開」のアクセス水準を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The enumeration type is pattern-matched against the enumeration case patterns in the case blocks of the <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> statement, as described in <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Enumeration Case Pattern<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙型は、<bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>文のケース節ブロックにおいて、列挙ケース節パターンに対してパターンのマッチされます、<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>列挙ケース節パターン<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The enumeration’s <bpt i="3" x="3">&lt;c3&gt;</bpt>toggle<ept i="3">&lt;/c3&gt;</ept> implementation is marked as <bpt i="4" x="4">&lt;c4&gt;</bpt>mutating<ept i="4">&lt;/c4&gt;</ept>, to match the <bpt i="5" x="5">&lt;c5&gt;</bpt>Togglable<ept i="5">&lt;/c5&gt;</ept> protocol’s requirements:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙の<bpt i="3" x="3">&lt;c3&gt;</bpt>toggle<ept i="3">&lt;/c3&gt;</ept>実装は、<bpt i="5" x="5">&lt;c5&gt;</bpt>Togglable<ept i="5">&lt;/c5&gt;</ept>プロトコルの要件に適合するように、<bpt i="4" x="4">&lt;c4&gt;</bpt>mutating<ept i="4">&lt;/c4&gt;</ept>として印されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The error that’s thrown continues to propagate until it’s handled by a <bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> clause of a <bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スローされたエラーは、それが<bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept>文の<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>節によって処理されるまで伝達を続けていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The escaped special characters <bpt i="0" x="0">&lt;c0&gt;</bpt>\0<ept i="0">&lt;/c0&gt;</ept> (null character), <bpt i="1" x="1">&lt;c1&gt;</bpt>\\<ept i="1">&lt;/c1&gt;</ept> (backslash), <bpt i="2" x="2">&lt;c2&gt;</bpt>\t<ept i="2">&lt;/c2&gt;</ept> (horizontal tab), <bpt i="3" x="3">&lt;c3&gt;</bpt>\n<ept i="3">&lt;/c3&gt;</ept> (line feed), <bpt i="4" x="4">&lt;c4&gt;</bpt>\r<ept i="4">&lt;/c4&gt;</ept> (carriage return), <bpt i="5" x="5">&lt;c5&gt;</bpt>\"<ept i="5">&lt;/c5&gt;</ept> (double quote) and <bpt i="6" x="6">&lt;c6&gt;</bpt>\'<ept i="6">&lt;/c6&gt;</ept> (single quote)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エスケープされた特殊文字の<bpt i="0" x="0">&lt;c0&gt;</bpt>\0<ept i="0">&lt;/c0&gt;</ept>（ヌル文字）、<bpt i="1" x="1">&lt;c1&gt;</bpt>\\<ept i="1">&lt;/c1&gt;</ept>（バックスラッシュ）、<bpt i="2" x="2">&lt;c2&gt;</bpt>\t<ept i="2">&lt;/c2&gt;</ept>（水平タブ）、<bpt i="3" x="3">&lt;c3&gt;</bpt>\n<ept i="3">&lt;/c3&gt;</ept>（ラインフィード）、<bpt i="4" x="4">&lt;c4&gt;</bpt>\r<ept i="4">&lt;/c4&gt;</ept>（キャリッジリターン）、<bpt i="5" x="5">&lt;c5&gt;</bpt>\"<ept i="5">&lt;/c5&gt;</ept>（二重引用符）と<bpt i="6" x="6">&lt;c6&gt;</bpt>\'<ept i="6">&lt;/c6&gt;</ept>（一重引用符）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The exact meaning of “subscript” depends on the context in which it is used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「添え字」の正確な意味は、それが使われる前後関係に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example above also defines a new class called <bpt i="0" x="0">&lt;c0&gt;</bpt>VideoMode<ept i="0">&lt;/c0&gt;</ept>, to describe a specific video mode for video display.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は、また、ビデオ・ディスプレイのために特定のビデオ・モードを記述するために、<bpt i="0" x="0">&lt;c0&gt;</bpt>VideoMode<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しいクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example above calculates the value of one number to the power of another (in this case, <bpt i="0" x="0">&lt;c0&gt;</bpt>3<ept i="0">&lt;/c0&gt;</ept> to the power of <bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は、ある数を他のもので乗算した値を計算します（この場合、<bpt i="0" x="0">&lt;c0&gt;</bpt>3<ept i="0">&lt;/c0&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>乗）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example above checks whether the temperature is less than or equal to 32 degrees Fahrenheit (the freezing point of water).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は、温度が華氏32度（水の氷点）以下かどうか確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example above creates a <bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept> instance to store <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> values, and pushes three strings onto the stack.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept>インスタンスをつくって<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値を保存します、そしてスタック上へ３つの文字列をプッシュします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example above defines a dictionary called <bpt i="0" x="0">&lt;c0&gt;</bpt>testScores<ept i="0">&lt;/c0&gt;</ept>, which contains two key-value pairs that map a <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> key to an array of <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>testScores<ept i="0">&lt;/c0&gt;</ept>と呼ばれる辞書型を定義します、それは、２つの「キーと値」対を含んでいて、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>キーを<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>値を持つ配列と関連づけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example above defines a new prefix operator called <bpt i="0" x="0">&lt;c0&gt;</bpt>+++<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>+++<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しい接頭辞演算子を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example above defines a new structure called <bpt i="0" x="0">&lt;c0&gt;</bpt>Resolution<ept i="0">&lt;/c0&gt;</ept>, to describe a pixel-based display resolution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は、ピクセルに基づくディスプレイ解像度を記述するために、<bpt i="0" x="0">&lt;c0&gt;</bpt>Resolution<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しい構造体を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example above defines a variable called <bpt i="0" x="0">&lt;c0&gt;</bpt>numberOfLegs<ept i="0">&lt;/c0&gt;</ept> and initializes it with a dictionary literal containing three key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>numberOfLegs<ept i="0">&lt;/c0&gt;</ept>と呼ばれる変数を定義して、３つの「キーと値」の対を含んでいる辞書リテラルでそれを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example above implements the unary minus operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>-a<ept i="0">&lt;/c0&gt;</ept>) for <bpt i="1" x="1">&lt;c1&gt;</bpt>Vector2D<ept i="1">&lt;/c1&gt;</ept> instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Vector2D<ept i="1">&lt;/c1&gt;</ept>インスタンスのための単項マイナス演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>-a<ept i="0">&lt;/c0&gt;</ept>）を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example above in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Accessing Properties Through Optional Chaining<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> attempts to set an <bpt i="2" x="2">&lt;c2&gt;</bpt>address<ept i="2">&lt;/c2&gt;</ept> value for <bpt i="3" x="3">&lt;c3&gt;</bpt>john.residence<ept i="3">&lt;/c3&gt;</ept>, even though the <bpt i="4" x="4">&lt;c4&gt;</bpt>residence<ept i="4">&lt;/c4&gt;</ept> property is <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オプショナル連鎖を通してプロパティにアクセスする<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>での前の例は、ある<bpt i="2" x="2">&lt;c2&gt;</bpt>address<ept i="2">&lt;/c2&gt;</ept>値を<bpt i="3" x="3">&lt;c3&gt;</bpt>john.residence<ept i="3">&lt;/c3&gt;</ept>に対して設定することを試みます、たとえ<bpt i="4" x="4">&lt;c4&gt;</bpt>residence<ept i="4">&lt;/c4&gt;</ept>プロパティが<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example above shows that the original values of <bpt i="0" x="0">&lt;c0&gt;</bpt>someInt<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>anotherInt<ept i="1">&lt;/c1&gt;</ept> are modified by the <bpt i="2" x="2">&lt;c2&gt;</bpt>swapTwoInts(_:_:)<ept i="2">&lt;/c2&gt;</ept> function, even though they were originally defined outside of the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>someInt<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>anotherInt<ept i="1">&lt;/c1&gt;</ept>の本来の値が、たとえそれらが元々は関数の外側で定義されたとしても、<bpt i="2" x="2">&lt;c2&gt;</bpt>swapTwoInts(_:_:)<ept i="2">&lt;/c2&gt;</ept>関数によって修正されることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example above shows what happens if it is called with an input value of <bpt i="1" x="1">&lt;c1&gt;</bpt>"Anna"<ept i="1">&lt;/c1&gt;</ept>, and an input value of <bpt i="2" x="2">&lt;c2&gt;</bpt>"Brian"<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は、それが<bpt i="1" x="1">&lt;c1&gt;</bpt>"Anna"<ept i="1">&lt;/c1&gt;</ept>の入力値、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>"Brian"<ept i="2">&lt;/c2&gt;</ept>の入力値で呼ばれるならば、何が起こるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example above uses a very simple approach to dice rolling.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は、さいころ振りに対する非常に単純なアプローチを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example above uses the default initializer for the <bpt i="5" x="5">&lt;c5&gt;</bpt>ShoppingListItem<ept i="5">&lt;/c5&gt;</ept> class to create a new instance of the class with initializer syntax, written as <bpt i="6" x="6">&lt;c6&gt;</bpt>ShoppingListItem()<ept i="6">&lt;/c6&gt;</ept>, and assigns this new instance to a variable called <bpt i="7" x="7">&lt;c7&gt;</bpt>item<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は、<bpt i="5" x="5">&lt;c5&gt;</bpt>ShoppingListItem<ept i="5">&lt;/c5&gt;</ept>クラスのための省略時のイニシャライザを使って、このクラスの新しいインスタンスを作成します、<bpt i="6" x="6">&lt;c6&gt;</bpt>ShoppingListItem()<ept i="6">&lt;/c6&gt;</ept>のように書かれる、イニシャライザ構文の所です、そしてこの新しいインスタンスを<bpt i="7" x="7">&lt;c7&gt;</bpt>item<ept i="7">&lt;/c7&gt;</ept>と呼ばれる変数に代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example also creates an <bpt i="2" x="2">&lt;c2&gt;</bpt>Array<ept i="2">&lt;/c2&gt;</ept> instance initialized with an array literal containing the same three strings as the stack.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例はまた、このスタックと同じ３つの文字列を含む配列リテラルで初期化される<bpt i="2" x="2">&lt;c2&gt;</bpt>Array<ept i="2">&lt;/c2&gt;</ept>インスタンスをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example also defines a <bpt i="0" x="0">&lt;c0&gt;</bpt>wishHappyBirthday(to:)<ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例はまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>wishHappyBirthday(to:)<ept i="0">&lt;/c0&gt;</ept>関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example also defines two supporting structures called <bpt i="1" x="1">&lt;c1&gt;</bpt>Size<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept>, both of which provide default values of <bpt i="3" x="3">&lt;c3&gt;</bpt>0.0<ept i="3">&lt;/c3&gt;</ept> for all of their properties:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例はまた、<bpt i="1" x="1">&lt;c1&gt;</bpt>Size<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept>と呼ばれる２つの支援の構造体を定義します、その両方はそれらのプロパティの全てに<bpt i="3" x="3">&lt;c3&gt;</bpt>0.0<ept i="3">&lt;/c3&gt;</ept>の省略時の値を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example also implements the “not equal to” operator (<bpt i="5" x="5">&lt;c5&gt;</bpt>!=<ept i="5">&lt;/c5&gt;</ept>), which simply returns the inverse of the result of the “equal to” operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、また「不等」演算子（<bpt i="5" x="5">&lt;c5&gt;</bpt>!=<ept i="5">&lt;/c5&gt;</ept>）も実装します、それは、単純に「同等」演算子の結果の逆を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below adds a new mutating method called <bpt i="0" x="0">&lt;c0&gt;</bpt>square<ept i="0">&lt;/c0&gt;</ept> to Swift’s <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> type, which squares the original value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>square<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しい可変メソッドをスウィフトの<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>型に加えます、それは、もとの値を二乗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below calculates the <bpt i="0" x="0">&lt;e0&gt;</bpt>arithmetic mean<ept i="0">&lt;/e0&gt;</ept> (also known as the <bpt i="1" x="1">&lt;e1&gt;</bpt>average<ept i="1">&lt;/e1&gt;</ept>) for a list of numbers of any length:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、どんな長さの数のリストに対しても、<bpt i="0" x="0">&lt;e0&gt;</bpt>算術平均<ept i="0">&lt;/e0&gt;</ept>（また<bpt i="1" x="1">&lt;e1&gt;</bpt>平均<ept i="1">&lt;/e1&gt;</ept>としても知られるもの）を計算します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below calls the <bpt i="0" x="0">&lt;c0&gt;</bpt>Address<ept i="0">&lt;/c0&gt;</ept> class’s <bpt i="1" x="1">&lt;c1&gt;</bpt>buildingIdentifier()<ept i="1">&lt;/c1&gt;</ept> method through optional chaining.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、オプショナル連鎖を通して<bpt i="0" x="0">&lt;c0&gt;</bpt>Address<ept i="0">&lt;/c0&gt;</ept>クラスの<bpt i="1" x="1">&lt;c1&gt;</bpt>buildingIdentifier()<ept i="1">&lt;/c1&gt;</ept>メソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below categorizes an (x, y) point on the following graph:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、続くグラフ上でポイント(x, y)を分類します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below creates a dictionary to store the names of international airports.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、国際空港の名前を格納するための辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below creates a set called <bpt i="0" x="0">&lt;c0&gt;</bpt>favoriteGenres<ept i="0">&lt;/c0&gt;</ept> to store <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> values:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>favoriteGenres<ept i="0">&lt;/c0&gt;</ept>と呼ばれる集合を<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値を格納するために作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below creates an array called <bpt i="0" x="0">&lt;c0&gt;</bpt>shoppingList<ept i="0">&lt;/c0&gt;</ept> to store <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> values:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値を保存する<bpt i="0" x="0">&lt;c0&gt;</bpt>shoppingList<ept i="0">&lt;/c0&gt;</ept>と呼ばれる配列をつくります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a base class called <bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept>と呼ばれる基盤クラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a class called <bpt i="0" x="0">&lt;c0&gt;</bpt>Document<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Document<ept i="0">&lt;/c0&gt;</ept>と呼ばれるクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a custom <bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept> structure to represent a geometric rectangle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、幾何学の長方形を表すためにあつらえの<bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept>構造体を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a function called <bpt i="0" x="0">&lt;c0&gt;</bpt>minMax(array:)<ept i="0">&lt;/c0&gt;</ept>, which finds the smallest and largest numbers in an array of <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> values:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>minMax(array:)<ept i="0">&lt;/c0&gt;</ept>と呼ばれる関数を定義します、それは、ある<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値の配列の中で最小および最大の数を見つけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a generic function called <bpt i="0" x="0">&lt;c0&gt;</bpt>allItemsMatch<ept i="0">&lt;/c0&gt;</ept>, which checks to see if two <bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept> instances contain the same items in the same order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>allItemsMatch<ept i="0">&lt;/c0&gt;</ept>と呼ばれる総称体関数を定義します、それは、２つの<bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept>インスタンスが同じ順序で同じ項目を含むかどうか見るために調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a global function called <bpt i="0" x="0">&lt;c0&gt;</bpt>someFunction()<ept i="0">&lt;/c0&gt;</ept>, without providing a specific access-level modifier for the function itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、その関数自身に特定のアクセス水準修飾子を提供することなく、<bpt i="0" x="0">&lt;c0&gt;</bpt>someFunction()<ept i="0">&lt;/c0&gt;</ept>と呼ばれるグローバル関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a new class called <bpt i="2" x="2">&lt;c2&gt;</bpt>StepCounter<ept i="2">&lt;/c2&gt;</ept>, which tracks the total number of steps that a person takes while walking.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>StepCounter<ept i="2">&lt;/c2&gt;</ept>と呼ばれる新しいクラスを定義します、それは、ある人が歩いている間にとる総歩数を追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a new structure called <bpt i="0" x="0">&lt;c0&gt;</bpt>Fahrenheit<ept i="0">&lt;/c0&gt;</ept> to store temperatures expressed in the Fahrenheit scale.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Fahrenheit<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しい構造体を定義して、華氏尺度で表される温度を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a protocol called <bpt i="0" x="0">&lt;c0&gt;</bpt>Togglable<ept i="0">&lt;/c0&gt;</ept>, which defines a single instance method requirement called <bpt i="1" x="1">&lt;c1&gt;</bpt>toggle<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Togglable<ept i="0">&lt;/c0&gt;</ept>と呼ばれるプロトコルを定義します、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>toggle<ept i="1">&lt;/c1&gt;</ept>と呼ばれる１つのインスタンスメソッド要件を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a structure called <bpt i="0" x="0">&lt;c0&gt;</bpt>Animal<ept i="0">&lt;/c0&gt;</ept>, with a constant <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> property called <bpt i="2" x="2">&lt;c2&gt;</bpt>species<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Animal<ept i="0">&lt;/c0&gt;</ept>と呼ばれるある構造体を、<bpt i="2" x="2">&lt;c2&gt;</bpt>species<ept i="2">&lt;/c2&gt;</ept>と呼ばれる定数<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>プロパティを使って定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a structure called <bpt i="0" x="0">&lt;c0&gt;</bpt>BlackjackCard<ept i="0">&lt;/c0&gt;</ept>, which models a playing card as used in the game of Blackjack.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下記の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>BlackjackCard<ept i="0">&lt;/c0&gt;</ept>と呼ばれる構造体を定義します、それは、「ブラックジャック」ゲームにおいて使われるときの遊戯カード、トランプカードをモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a structure called <bpt i="0" x="0">&lt;c0&gt;</bpt>Chessboard<ept i="0">&lt;/c0&gt;</ept>, which models a board for the game of chess.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>Chessboard<ept i="0">&lt;/c0&gt;</ept>と呼ばれる構造体を定義します、それは、「チェス」ゲーム用の盤をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a structure called <bpt i="0" x="0">&lt;c0&gt;</bpt>FixedLengthRange<ept i="0">&lt;/c0&gt;</ept>, which describes a range of integers whose range length cannot be changed after it is created:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>FixedLengthRange<ept i="0">&lt;/c0&gt;</ept>と呼ばれる構造体を定義します、それは、それが作成された後に範囲長が変更されることが出来ない、整数からなるある範囲を記述します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a structure called <bpt i="0" x="0">&lt;c0&gt;</bpt>LevelTracker<ept i="0">&lt;/c0&gt;</ept>, which tracks a player’s progress through the different levels or stages of a game.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>LevelTracker<ept i="0">&lt;/c0&gt;</ept>と呼ばれる構造体を定義します、それは、プレイヤーの進み具合をゲームの異なるレベルまたはステージを通して追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a structure called <bpt i="0" x="0">&lt;c0&gt;</bpt>Size<ept i="0">&lt;/c0&gt;</ept> with two properties called <bpt i="1" x="1">&lt;c1&gt;</bpt>width<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>height<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="1" x="1">&lt;c1&gt;</bpt>width<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>height<ept i="2">&lt;/c2&gt;</ept>と呼ばれる２つのプロパティをもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Size<ept i="0">&lt;/c0&gt;</ept>と呼ばれる構造体を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a structure called <bpt i="0" x="0">&lt;c0&gt;</bpt>TrackedString<ept i="0">&lt;/c0&gt;</ept>, which keeps track of the number of times a string property is modified:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>TrackedString<ept i="0">&lt;/c0&gt;</ept>と呼ばれる構造体を定義します、それは、ある文字列プロパティが修正される回数を追跡します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines a subclass of <bpt i="0" x="0">&lt;c0&gt;</bpt>Product<ept i="0">&lt;/c0&gt;</ept> called <bpt i="1" x="1">&lt;c1&gt;</bpt>CartItem<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="1" x="1">&lt;c1&gt;</bpt>CartItem<ept i="1">&lt;/c1&gt;</ept>と呼ばれる<bpt i="0" x="0">&lt;c0&gt;</bpt>Product<ept i="0">&lt;/c0&gt;</ept>のサブクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines an enumeration called <bpt i="0" x="0">&lt;c0&gt;</bpt>OnOffSwitch<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>OnOffSwitch<ept i="0">&lt;/c0&gt;</ept>と呼ばれる列挙を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines an enumeration called <bpt i="0" x="0">&lt;c0&gt;</bpt>TemperatureUnit<ept i="0">&lt;/c0&gt;</ept>, with three possible states (<bpt i="1" x="1">&lt;c1&gt;</bpt>kelvin<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>celsius<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>fahrenheit<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、３つの可能な状態（<bpt i="1" x="1">&lt;c1&gt;</bpt>kelvin<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>celsius<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>fahrenheit<ept i="3">&lt;/c3&gt;</ept>）を持つ、<bpt i="0" x="0">&lt;c0&gt;</bpt>TemperatureUnit<ept i="0">&lt;/c0&gt;</ept>と呼ばれる列挙を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines two classes, <bpt i="0" x="0">&lt;c0&gt;</bpt>Country<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>City<ept i="1">&lt;/c1&gt;</ept>, each of which stores an instance of the other class as a property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は２つのクラス、<bpt i="0" x="0">&lt;c0&gt;</bpt>Country<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>City<ept i="1">&lt;/c1&gt;</ept>を定義します、そして、そのそれぞれは他のクラスのインスタンスをプロパティとして格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines two protocols for use with dice-based board games:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、さいころに基づく様々なボードゲームで使うために、２つのプロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below defines two variables, <bpt i="0" x="0">&lt;c0&gt;</bpt>movieCount<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>songCount<ept i="1">&lt;/c1&gt;</ept>, which count the number of <bpt i="2" x="2">&lt;c2&gt;</bpt>Movie<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Song<ept i="3">&lt;/c3&gt;</ept> instances in the <bpt i="4" x="4">&lt;c4&gt;</bpt>library<ept i="4">&lt;/c4&gt;</ept> array:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は２つの変数、<bpt i="0" x="0">&lt;c0&gt;</bpt>movieCount<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>songCountを<ept i="1">&lt;/c1&gt;</ept>定義します、それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Movie<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>Song<ept i="3">&lt;/c3&gt;</ept>インスタンスの数を<bpt i="4" x="4">&lt;c4&gt;</bpt>library<ept i="4">&lt;/c4&gt;</ept>配列において数えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below exposes the getter for the <bpt i="5" x="5">&lt;c5&gt;</bpt>enabled<ept i="5">&lt;/c5&gt;</ept> property of the <bpt i="6" x="6">&lt;c6&gt;</bpt>ExampleClass<ept i="6">&lt;/c6&gt;</ept> to Objective-C code as <bpt i="7" x="7">&lt;c7&gt;</bpt>isEnabled<ept i="7">&lt;/c7&gt;</ept> rather than just as the name of the property itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="6" x="6">&lt;c6&gt;</bpt>ExampleClass<ept i="6">&lt;/c6&gt;</ept>の<bpt i="5" x="5">&lt;c5&gt;</bpt>enabled<ept i="5">&lt;/c5&gt;</ept>プロパティのためのゲッターをObjective-Cコードに、ただプロパティそれ自身の名前ではなく<bpt i="7" x="7">&lt;c7&gt;</bpt>isEnabled<ept i="7">&lt;/c7&gt;</ept>として露出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below extends the <bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept> protocol from the previous examples to add a <bpt i="2" x="2">&lt;c2&gt;</bpt>startsWith(_:)<ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、以前の例の<bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept>プロトコルを拡張して、<bpt i="2" x="2">&lt;c2&gt;</bpt>startsWith(_:)<ept i="2">&lt;/c2&gt;</ept>メソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below extends the generic <bpt i="1" x="1">&lt;c1&gt;</bpt>Stack<ept i="1">&lt;/c1&gt;</ept> structure from the previous examples to add an <bpt i="2" x="2">&lt;c2&gt;</bpt>isTop(_:)<ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、以前の例の総称体<bpt i="1" x="1">&lt;c1&gt;</bpt>Stack<ept i="1">&lt;/c1&gt;</ept>構造体を拡張して、<bpt i="2" x="2">&lt;c2&gt;</bpt>isTop(_:)<ept i="2">&lt;/c2&gt;</ept>メソッドを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below implements an addition assignment operator method for <bpt i="0" x="0">&lt;c0&gt;</bpt>Vector2D<ept i="0">&lt;/c0&gt;</ept> instances:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Vector2D<ept i="0">&lt;/c0&gt;</ept>インスタンスのために追加代入演算子メソッドを実装します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below is identical to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept> example from above, with one important difference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、上記の<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept>例に同一ですが、１つの重要な違いがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below iterates over each <bpt i="0" x="0">&lt;c0&gt;</bpt>MediaItem<ept i="0">&lt;/c0&gt;</ept> in <bpt i="1" x="1">&lt;c1&gt;</bpt>library<ept i="1">&lt;/c1&gt;</ept>, and prints an appropriate description for each item.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、上に<bpt i="1" x="1">&lt;c1&gt;</bpt>library<ept i="1">&lt;/c1&gt;</ept>の中の各々の<bpt i="0" x="0">&lt;c0&gt;</bpt>MediaItem<ept i="0">&lt;/c0&gt;</ept>すべてに繰り返して、各項目の適切な説明を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below iterates over the items in the <bpt i="5" x="5">&lt;c5&gt;</bpt>things<ept i="5">&lt;/c5&gt;</ept> array and queries the type of each item with a <bpt i="6" x="6">&lt;c6&gt;</bpt>switch<ept i="6">&lt;/c6&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="5" x="5">&lt;c5&gt;</bpt>things<ept i="5">&lt;/c5&gt;</ept>配列の中の項目のすべてに渡って繰り返して、<bpt i="6" x="6">&lt;c6&gt;</bpt>switch<ept i="6">&lt;/c6&gt;</ept>文を使って各項目の型について問い合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows a closure expression version of the <bpt i="0" x="0">&lt;c0&gt;</bpt>backward(_:_:)<ept i="0">&lt;/c0&gt;</ept> function from earlier:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下記の例は、以前の<bpt i="0" x="0">&lt;c0&gt;</bpt>backward(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数のクロージャ式版を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows a simplified version of the Swift standard library’s generic dictionary type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、スウィフト標準ライブラリの総称体辞書型の簡略版を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows a version of the <bpt i="0" x="0">&lt;c0&gt;</bpt>TrackedString<ept i="0">&lt;/c0&gt;</ept> structure in which the structure is defined with an explicit access level of public.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>TrackedString<ept i="0">&lt;/c0&gt;</ept>構造体のある改作を示します、そこにおいてこの構造体は公開の明示的なアクセス水準を使って定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows an <bpt i="3" x="3">&lt;c3&gt;</bpt>init?<ept i="3">&lt;/c3&gt;</ept> failable initializer that produces an optional instance of a structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、ある構造体のオプショナルインスタンスを生成する、失敗できるイニシャライザ<bpt i="3" x="3">&lt;c3&gt;</bpt>init?<ept i="3">&lt;/c3&gt;</ept>を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows how to implement the arithmetic addition operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>) for a custom structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、あつらえの構造体のために算術加算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>）を実装する方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows how you can create a strong reference cycle when using a closure that references <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>に参照をつけるクロージャを使うとき、あなたがどのように強い参照循環をつくることができるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows the syntax for stored and computed type properties:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、保存型プロパティおよび計算型プロパティのための構文を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below takes an (x, y) point, expressed as a simple tuple of type <bpt i="0" x="0">&lt;c0&gt;</bpt>(Int, Int)<ept i="0">&lt;/c0&gt;</ept>, and categorizes it on the graph that follows the example.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、ポイント(x, y)、型<bpt i="0" x="0">&lt;c0&gt;</bpt>(Int, Int)<ept i="0">&lt;/c0&gt;</ept>の単純なタプルとして表されるもの、をとって、その例に続くグラフ上でそれを分類します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below takes an (x, y) point, expressed as a tuple of type <bpt i="0" x="0">&lt;c0&gt;</bpt>(Int, Int)<ept i="0">&lt;/c0&gt;</ept>, and categorizes it on the graph that follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下記の例は、ポイント(x, y)をとって、型<bpt i="0" x="0">&lt;c0&gt;</bpt>(Int, Int)<ept i="0">&lt;/c0&gt;</ept>のタプルとして表し、それをあとに続くグラフに分類します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below tries to access the <bpt i="0" x="0">&lt;c0&gt;</bpt>street<ept i="0">&lt;/c0&gt;</ept> property of the <bpt i="1" x="1">&lt;c1&gt;</bpt>address<ept i="1">&lt;/c1&gt;</ept> property of the <bpt i="2" x="2">&lt;c2&gt;</bpt>residence<ept i="2">&lt;/c2&gt;</ept> property of <bpt i="3" x="3">&lt;c3&gt;</bpt>john<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="3" x="3">&lt;c3&gt;</bpt>john<ept i="3">&lt;/c3&gt;</ept>の<bpt i="2" x="2">&lt;c2&gt;</bpt>residence<ept i="2">&lt;/c2&gt;</ept>プロパティの<bpt i="1" x="1">&lt;c1&gt;</bpt>address<ept i="1">&lt;/c1&gt;</ept>プロパティの<bpt i="0" x="0">&lt;c0&gt;</bpt>street<ept i="0">&lt;/c0&gt;</ept>プロパティにアクセスしようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below tries to retrieve the name of the first room in the <bpt i="0" x="0">&lt;c0&gt;</bpt>rooms<ept i="0">&lt;/c0&gt;</ept> array of the <bpt i="1" x="1">&lt;c1&gt;</bpt>john.residence<ept i="1">&lt;/c1&gt;</ept> property using the subscript defined on the <bpt i="2" x="2">&lt;c2&gt;</bpt>Residence<ept i="2">&lt;/c2&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Residence<ept i="2">&lt;/c2&gt;</ept>クラス上で定義される添え字を使って、<bpt i="1" x="1">&lt;c1&gt;</bpt>john.residence<ept i="1">&lt;/c1&gt;</ept>プロパティの<bpt i="0" x="0">&lt;c0&gt;</bpt>rooms<ept i="0">&lt;/c0&gt;</ept>配列での最初の部屋の名前を取り出そうとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below uses <bpt i="1" x="1">&lt;c1&gt;</bpt>fallthrough<ept i="1">&lt;/c1&gt;</ept> to create a textual description of a number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、<bpt i="1" x="1">&lt;c1&gt;</bpt>fallthrough<ept i="1">&lt;/c1&gt;</ept>をある数の文章での説明をつくるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below uses a lazy stored property to avoid unnecessary initialization of a complex class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、ある複雑なクラスの必要でない初期化を避けるために遅延保存プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below uses the initializer to try to convert a <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> into an <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、このイニシャライザを使用して<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>に変えることを試みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below uses the nil-coalescing operator to choose between a default color name and an optional user-defined color name:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、nil合体演算子を、省略時の色の名前とオプショナルの利用者定義の色の名前とで選択するために使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example can be read as:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example creates an array called <bpt i="1" x="1">&lt;c1&gt;</bpt>things<ept i="1">&lt;/c1&gt;</ept>, which can store values of type <bpt i="2" x="2">&lt;c2&gt;</bpt>Any<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は<bpt i="1" x="1">&lt;c1&gt;</bpt>things<ept i="1">&lt;/c1&gt;</ept>と呼ばれる配列をつくります、それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Any<ept i="2">&lt;/c2&gt;</ept>型の値を格納することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example defines a <bpt i="0" x="0">&lt;c0&gt;</bpt>Vector2D<ept i="0">&lt;/c0&gt;</ept> structure for a two-dimensional position vector <bpt i="1" x="1">&lt;c1&gt;</bpt>(x, y)<ept i="1">&lt;/c1&gt;</ept>, followed by a definition of an <bpt i="2" x="2">&lt;e2&gt;</bpt>operator method<ept i="2">&lt;/e2&gt;</ept> to add together instances of the <bpt i="3" x="3">&lt;c3&gt;</bpt>Vector2D<ept i="3">&lt;/c3&gt;</ept> structure:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例は、２次元の位置ベクトル<bpt i="1" x="1">&lt;c1&gt;</bpt>(x, y)<ept i="1">&lt;/c1&gt;</ept>のための<bpt i="0" x="0">&lt;c0&gt;</bpt>Vector2D<ept i="0">&lt;/c0&gt;</ept>構造体を定義します。そして、<bpt i="3" x="3">&lt;c3&gt;</bpt>Vector2D<ept i="3">&lt;/c3&gt;</ept>構造体のインスタンスたちを１つに加えるための<bpt i="2" x="2">&lt;e2&gt;</bpt>演算子メソッド<ept i="2">&lt;/e2&gt;</ept>の定義が続きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example requires two supporting structures called <bpt i="1" x="1">&lt;c1&gt;</bpt>Size<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept>, both of which provide default values of <bpt i="3" x="3">&lt;c3&gt;</bpt>0.0<ept i="3">&lt;/c3&gt;</ept> for all of their properties:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Size<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept>と呼ばれる２つの補助する構造体を必要とします、その両方はそれらのプロパティすべてに<bpt i="3" x="3">&lt;c3&gt;</bpt>0.0<ept i="3">&lt;/c3&gt;</ept>の省略時の値を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example shown above demonstrates a custom implementation of a binary infix operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上で示される例は、二項接中辞演算子のあつらえの実装を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example starts by trying to downcast the current <bpt i="0" x="0">&lt;c0&gt;</bpt>item<ept i="0">&lt;/c0&gt;</ept> as a <bpt i="1" x="1">&lt;c1&gt;</bpt>Movie<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例は、現在の<bpt i="0" x="0">&lt;c0&gt;</bpt>item<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>Movie<ept i="1">&lt;/c1&gt;</ept>としてダウンキャストすることを試みることによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example then creates a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> instance called <bpt i="1" x="1">&lt;c1&gt;</bpt>birthdayPerson<ept i="1">&lt;/c1&gt;</ept> and passes this new instance to the <bpt i="2" x="2">&lt;c2&gt;</bpt>wishHappyBirthday(to:)<ept i="2">&lt;/c2&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、それから<bpt i="1" x="1">&lt;c1&gt;</bpt>birthdayPerson<ept i="1">&lt;/c1&gt;</ept>と呼ばれる新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>インスタンスをつくって、この新しいインスタンスを<bpt i="2" x="2">&lt;c2&gt;</bpt>wishHappyBirthday(to:)<ept i="2">&lt;/c2&gt;</ept>関数に渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example uses optional chaining to set the first item in the <bpt i="3" x="3">&lt;c3&gt;</bpt>"Dave"<ept i="3">&lt;/c3&gt;</ept> array to <bpt i="4" x="4">&lt;c4&gt;</bpt>91<ept i="4">&lt;/c4&gt;</ept>; to increment the first item in the <bpt i="5" x="5">&lt;c5&gt;</bpt>"Bev"<ept i="5">&lt;/c5&gt;</ept> array by <bpt i="6" x="6">&lt;c6&gt;</bpt>1<ept i="6">&lt;/c6&gt;</ept>; and to try to set the first item in an array for a key of <bpt i="7" x="7">&lt;c7&gt;</bpt>"Brian"<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、オプショナル連鎖を使って<bpt i="3" x="3">&lt;c3&gt;</bpt>"Dave"<ept i="3">&lt;/c3&gt;</ept>配列の最初の項目を<bpt i="4" x="4">&lt;c4&gt;</bpt>91<ept i="4">&lt;/c4&gt;</ept>に設定します；それから<bpt i="5" x="5">&lt;c5&gt;</bpt>"Bev"<ept i="5">&lt;/c5&gt;</ept>配列の最初の項目を<bpt i="6" x="6">&lt;c6&gt;</bpt>1<ept i="6">&lt;/c6&gt;</ept>だけ増加します；そしてそれから<bpt i="7" x="7">&lt;c7&gt;</bpt>"Brian"<ept i="7">&lt;/c7&gt;</ept>のキーに対応する配列の最初の項目を設定することを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The examples above show how to use <bpt i="0" x="0">&lt;e0&gt;</bpt>safe<ept i="0">&lt;/e0&gt;</ept> unowned references.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例は、どのように<bpt i="0" x="0">&lt;e0&gt;</bpt>safe<ept i="0">&lt;/e0&gt;</ept>非所有参照を使うかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The examples below consider an array of strings representing the scene locations from the first two acts of Shakespeare’s <bpt i="0" x="0">&lt;e0&gt;</bpt>Romeo and Juliet<ept i="0">&lt;/e0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、シェークスピアの<bpt i="0" x="0">&lt;e0&gt;</bpt>ロミオとジュリエット<ept i="0">&lt;/e0&gt;</ept>の最初の２幕から、場面場所を表している文字列の配列を考えてみます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The examples for weak and unowned references above cover two of the more common scenarios in which it’s necessary to break a strong reference cycle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の弱いおよび非所有者参照のための例は、強い参照循環を壊すために不可欠なよくある筋書きのうちの２つを扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The examples in the previous section show how the cases of an enumeration are a defined (and typed) value in their own right.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前の節での例は、列挙のケース節がどのように自分だけで定義された（そして型付けされた）値であるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The examples that follow use two stored type properties as part of a structure that models an audio level meter for a number of audio channels.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あとに続く例は、いくつかのオーディオ・チャンネル用のオーディオ・レベルをモデル化する構造体の一部として、２つの保存型プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The exclamation mark effectively says, “I know that this optional definitely has a value; please use it.” This is known as <bpt i="2" x="2">&lt;e2&gt;</bpt>forced unwrapping<ept i="2">&lt;/e2&gt;</ept> of the optional’s value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>感嘆符は、実際上こう言っています、「私はこのオプショナルが間違いなくひとつの値を持つことを知っています；どうぞそれを使ってください」。これは、そのオプショナルの所有する値の<bpt i="2" x="2">&lt;e2&gt;</bpt>強制アンラップ<ept i="2">&lt;/e2&gt;</ept>として知られます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The exponent consists of an upper- or lowercase <bpt i="1" x="1">&lt;c1&gt;</bpt>e<ept i="1">&lt;/c1&gt;</ept> prefix followed by a sequence of decimal digits that indicates what power of 10 the value preceding the <bpt i="2" x="2">&lt;c2&gt;</bpt>e<ept i="2">&lt;/c2&gt;</ept> is multiplied by.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指数は、大文字または小文字の接頭辞<bpt i="1" x="1">&lt;c1&gt;</bpt>e<ept i="1">&lt;/c1&gt;</ept>、それに続けて<bpt i="2" x="2">&lt;c2&gt;</bpt>e<ept i="2">&lt;/c2&gt;</ept>の前の値が10の何乗を掛けられるかを示す一連の10進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The exponent consists of an upper- or lowercase <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept> prefix followed by a sequence of decimal digits that indicates what power of 2 the value preceding the <bpt i="2" x="2">&lt;c2&gt;</bpt>p<ept i="2">&lt;/c2&gt;</ept> is multiplied by.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指数は、大文字または小文字の<bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>接頭辞、それに続けて<bpt i="2" x="2">&lt;c2&gt;</bpt>p<ept i="2">&lt;/c2&gt;</ept>の前の値が２の何乗を掛けられるかを示す一連の10進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The expression <bpt i="0" x="0">&lt;c0&gt;</bpt>a += 2<ept i="0">&lt;/c0&gt;</ept> is shorthand for <bpt i="1" x="1">&lt;c1&gt;</bpt>a = a + 2<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>式<bpt i="0" x="0">&lt;c0&gt;</bpt>a += 2<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>a = a + 2<ept i="1">&lt;/c1&gt;</ept>の簡略な表現です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The expression <bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept> is always of an optional type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept>の式は常にオプショナル型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The expression <bpt i="7" x="7">&lt;c7&gt;</bpt>b<ept i="7">&lt;/c7&gt;</ept> must match the type that is stored inside <bpt i="8" x="8">&lt;c8&gt;</bpt>a<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt>b<ept i="7">&lt;/c7&gt;</ept>の式は<bpt i="8" x="8">&lt;c8&gt;</bpt>a<ept i="8">&lt;/c8&gt;</ept>の中に格納される型に合致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The expression is evaluated when the closure is created, and the value is captured with the specified strength.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その式は、クロージャが作成される時に評価されます、そしてその値は、指定された強さでキャプチャされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The expression represented by the expression pattern is compared with the value of an input expression using the Swift standard library <bpt i="0" x="0">&lt;c0&gt;</bpt>~=<ept i="0">&lt;/c0&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>式パターンによって表される式は、入力された式の値とスウィフト標準ライブラリ<bpt i="0" x="0">&lt;c0&gt;</bpt>~=<ept i="0">&lt;/c0&gt;</ept>演算子を使って比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The expressions you write inside parentheses within an interpolated string can’t contain an unescaped backslash (<bpt i="0" x="0">&lt;c0&gt;</bpt>\<ept i="0">&lt;/c0&gt;</ept>), a carriage return, or a line feed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>補間文字列においてあなたが丸括弧内に記述する式は、エスケープされないバックスラッシュ（<bpt i="0" x="0">&lt;c0&gt;</bpt>\<ept i="0">&lt;/c0&gt;</ept>）、キャリッジリターン、またはラインフィードを含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The fact that <bpt i="1" x="1">&lt;c1&gt;</bpt>asHTML<ept i="1">&lt;/c1&gt;</ept> is a lazy property means that you can refer to <bpt i="2" x="2">&lt;c2&gt;</bpt>self<ept i="2">&lt;/c2&gt;</ept> within the default closure, because the lazy property will not be accessed until after initialization has been completed and <bpt i="3" x="3">&lt;c3&gt;</bpt>self<ept i="3">&lt;/c3&gt;</ept> is known to exist.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>asHTML<ept i="1">&lt;/c1&gt;</ept>が遅延プロパティだという事実は、あなたが省略時のクロージャ内で<bpt i="2" x="2">&lt;c2&gt;</bpt>self<ept i="2">&lt;/c2&gt;</ept>に言及することができることを意味します、なぜなら、遅延プロパティは、初期化が完了されてしまって<bpt i="3" x="3">&lt;c3&gt;</bpt>self<ept i="3">&lt;/c3&gt;</ept>が存在することを知られる後までアクセスされることはないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The fact that it is queried through an optional chain means that the call to <bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfRooms<ept i="2">&lt;/c2&gt;</ept> will always return an <bpt i="3" x="3">&lt;c3&gt;</bpt>Int?<ept i="3">&lt;/c3&gt;</ept> instead of an <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それがオプショナル連鎖によって問い合わせられるという事実は、<bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfRooms<ept i="2">&lt;/c2&gt;</ept>への呼び出しが常に<bpt i="3" x="3">&lt;c3&gt;</bpt>Int?<ept i="3">&lt;/c3&gt;</ept>を返すことを意味します、<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The fact that structures and enumerations can define methods in Swift is a major difference from C and Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体と列挙がスウィフトにおいてはメソッドを定義することができるという事実は、CやObjective-Cとの重大な違いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The failable initializer for <bpt i="0" x="0">&lt;c0&gt;</bpt>CartItem<ept i="0">&lt;/c0&gt;</ept> starts by validating that it has received a <bpt i="1" x="1">&lt;c1&gt;</bpt>quantity<ept i="1">&lt;/c1&gt;</ept> value of <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept> or more.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>CartItem<ept i="0">&lt;/c0&gt;</ept>のための失敗できるイニシャライザは、それが<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>以上の<bpt i="1" x="1">&lt;c1&gt;</bpt>quantity<ept i="1">&lt;/c1&gt;</ept>値を受け取ったことを検証することによって始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The fifth and sixth <bpt i="0" x="0">&lt;c0&gt;</bpt>codeUnit<ept i="0">&lt;/c0&gt;</ept> values (<bpt i="1" x="1">&lt;c1&gt;</bpt>55357<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>56374<ept i="2">&lt;/c2&gt;</ept>) are a UTF-16 surrogate pair representation of the <bpt i="3" x="3">&lt;c3&gt;</bpt>DOG FACE<ept i="3">&lt;/c3&gt;</ept> character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>５番目と６番目の<bpt i="0" x="0">&lt;c0&gt;</bpt>codeUnit<ept i="0">&lt;/c0&gt;</ept>値（<bpt i="1" x="1">&lt;c1&gt;</bpt>55357<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>56374<ept i="2">&lt;/c2&gt;</ept>）は、<bpt i="3" x="3">&lt;c3&gt;</bpt>DOG FACE<ept i="3">&lt;/c3&gt;</ept>文字のUTF-16代用対叙述です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The figure below illustrates how two of these audio channels can be combined to model a stereo audio level meter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の図は、これらの音声のチャンネルのうちの２つがステレオ音声のレベル・メーターをモデル化するために結合されることができる方法を図示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The figure below shows a more complex class hierarchy for four classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の図は、４つのクラスのためのより複雑なクラス階層を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The figure below shows the initializer chain for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Food<ept i="0">&lt;/c0&gt;</ept> class:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の図は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Food<ept i="0">&lt;/c0&gt;</ept>クラスのためのイニシャライザ連鎖を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The figure below shows the initializer chain for the <bpt i="0" x="0">&lt;c0&gt;</bpt>RecipeIngredient<ept i="0">&lt;/c0&gt;</ept> class:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の図は、<bpt i="0" x="0">&lt;c0&gt;</bpt>RecipeIngredient<ept i="0">&lt;/c0&gt;</ept>クラスのためのイニシャライザ連鎖を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The figure below shows the overall initializer chain for all three classes:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の図は、３つのクラス全てのために全体的なイニシャライザ連鎖を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The figure below shows these relationships:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の図は、それらの関係を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The final <bpt i="0" x="0">&lt;c0&gt;</bpt>else<ept i="0">&lt;/c0&gt;</ept> clause is optional, however, and can be excluded if the set of conditions does not need to be complete.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、最後の<bpt i="0" x="0">&lt;c0&gt;</bpt>else<ept i="0">&lt;/c0&gt;</ept>節は任意です、そして条件の集合が完全である必要がないならば、除外されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The final <bpt i="1" x="1">&lt;c1&gt;</bpt>else<ept i="1">&lt;/c1&gt;</ept> clause remains, and it prints a response for any temperatures that are neither too warm nor too cold.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後の<bpt i="1" x="1">&lt;c1&gt;</bpt>else<ept i="1">&lt;/c1&gt;</ept>節は同じままです、そしてそれはあまり暖かくもなくあまり寒くもないすべての気温に対しての応答を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The final case, <bpt i="2" x="2">&lt;c2&gt;</bpt>case let (x, y)<ept i="2">&lt;/c2&gt;</ept>, declares a tuple of two placeholder constants that can match any value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後のケース節、<bpt i="2" x="2">&lt;c2&gt;</bpt>case let (x, y)<ept i="2">&lt;/c2&gt;</ept>は、どんな値にでも適合することができるプレースホルダ定数を２つもつタプルを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The final class in this model is called <bpt i="0" x="0">&lt;c0&gt;</bpt>Address<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このモデルの中の最後のクラスは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Address<ept i="0">&lt;/c0&gt;</ept>と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The final code snippet above shows that the deinitializers for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept> instance and <bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept> instance both print their “deinitialized” messages after the <bpt i="2" x="2">&lt;c2&gt;</bpt>john<ept i="2">&lt;/c2&gt;</ept> variable is set to <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の最後のコード断片は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept>インスタンスと<bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept>インスタンスのためのデイニシャライザが両方ともそれらの「デイニシャライズされた」メッセージを、<bpt i="2" x="2">&lt;c2&gt;</bpt>john<ept i="2">&lt;/c2&gt;</ept>変数が<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>に設定された後に出力することを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The final snippet creates a constant array called <bpt i="0" x="0">&lt;c0&gt;</bpt>library<ept i="0">&lt;/c0&gt;</ept>, which contains two <bpt i="1" x="1">&lt;c1&gt;</bpt>Movie<ept i="1">&lt;/c1&gt;</ept> instances and three <bpt i="2" x="2">&lt;c2&gt;</bpt>Song<ept i="2">&lt;/c2&gt;</ept> instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最終的な断片は<bpt i="0" x="0">&lt;c0&gt;</bpt>library<ept i="0">&lt;/c0&gt;</ept>と呼ばれる定数の配列をつくります、それは、２つの<bpt i="1" x="1">&lt;c1&gt;</bpt>Movie<ept i="1">&lt;/c1&gt;</ept>インスタンスと３つの<bpt i="2" x="2">&lt;c2&gt;</bpt>Song<ept i="2">&lt;/c2&gt;</ept>インスタンスを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first <bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept> initializer, <bpt i="1" x="1">&lt;c1&gt;</bpt>init()<ept i="1">&lt;/c1&gt;</ept>, is functionally the same as the default initializer that the structure would have received if it did not have its own custom initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の<bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept>イニシャライザ、<bpt i="1" x="1">&lt;c1&gt;</bpt>init()<ept i="1">&lt;/c1&gt;</ept>は、構造体が独自のあつらえのイニシャライザを持たない場合に受け取る省略時のイニシャライザと機能的に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first and second requirements are defined in the function’s type parameter list, and the third and fourth requirements are defined in the function’s generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clause.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初と２番目の要件は関数のもつ型パラメータリストにおいて定義されます、そして３番目と４番目の要件は関数のもつ総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節において定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first case, <bpt i="4" x="4">&lt;c4&gt;</bpt>case (let x, 0)<ept i="4">&lt;/c4&gt;</ept>, matches any point with a <bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept> value of <bpt i="6" x="6">&lt;c6&gt;</bpt>0<ept i="6">&lt;/c6&gt;</ept> and assigns the point’s <bpt i="7" x="7">&lt;c7&gt;</bpt>x<ept i="7">&lt;/c7&gt;</ept> value to the temporary constant <bpt i="8" x="8">&lt;c8&gt;</bpt>x<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初のケース節、<bpt i="4" x="4">&lt;c4&gt;</bpt>case (let x, 0)<ept i="4">&lt;/c4&gt;</ept>は、<bpt i="6" x="6">&lt;c6&gt;</bpt>0<ept i="6">&lt;/c6&gt;</ept>の<bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept>値をもつどんなポイントにでも適合して、そのポイントの<bpt i="7" x="7">&lt;c7&gt;</bpt>x<ept i="7">&lt;/c7&gt;</ept>値を一時的な定数<bpt i="8" x="8">&lt;c8&gt;</bpt>x<ept i="8">&lt;/c8&gt;</ept>に代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first example’s use of the ternary conditional operator means that <bpt i="0" x="0">&lt;c0&gt;</bpt>rowHeight<ept i="0">&lt;/c0&gt;</ept> can be set to the correct value on a single line of code, which is more concise than the code used in the second example.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の例の三項条件演算子の使用は、<bpt i="0" x="0">&lt;c0&gt;</bpt>rowHeight<ept i="0">&lt;/c0&gt;</ept>がただ１行のコードで正しい値に設定されることができるのを意味します、それは２番目の例において使われるコードより簡潔です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first form allows code to be executed only when a condition is true and has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の形式は、条件が真である時にだけコードが実行されるようにし、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first form evaluates to the value of the <bpt i="0" x="0">&lt;e0&gt;</bpt>expression<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の形式は、<bpt i="0" x="0">&lt;e0&gt;</bpt>式<ept i="0">&lt;/e0&gt;</ept>の値に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first form is used to access a member of the superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の形式は、スーパークラスのメンバーにアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first form of a line control statement changes the values of the <bpt i="0" x="0">&lt;c0&gt;</bpt>#line<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>#file<ept i="1">&lt;/c1&gt;</ept> literal expressions, beginning with the line of code following the line control statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の形式の行制御文は、<bpt i="0" x="0">&lt;c0&gt;</bpt>#line<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>#file<ept i="1">&lt;/c1&gt;</ept>リテラル式の値を変更して、行制御文の後に続くコードの行で始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first function, <bpt i="0" x="0">&lt;c0&gt;</bpt>printAndCount(string:)<ept i="0">&lt;/c0&gt;</ept>, prints a string, and then returns its character count as an <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の関数、<bpt i="0" x="0">&lt;c0&gt;</bpt>printAndCount(string:)<ept i="0">&lt;/c0&gt;</ept>は、ある文字列を出力して、それからその文字数を<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first initializer has a single initialization parameter with an argument label of <bpt i="0" x="0">&lt;c0&gt;</bpt>fromFahrenheit<ept i="0">&lt;/c0&gt;</ept> and a parameter name of <bpt i="1" x="1">&lt;c1&gt;</bpt>fahrenheit<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初のイニシャライザは、<bpt i="0" x="0">&lt;c0&gt;</bpt>fromFahrenheit<ept i="0">&lt;/c0&gt;</ept>の引数ラベルと<bpt i="1" x="1">&lt;c1&gt;</bpt>fahrenheit<ept i="1">&lt;/c1&gt;</ept>のパラメータ名を使うただ１つの初期化パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first is a type function called <bpt i="2" x="2">&lt;c2&gt;</bpt>unlock(_:)<ept i="2">&lt;/c2&gt;</ept>, which updates the value of <bpt i="3" x="3">&lt;c3&gt;</bpt>highestUnlockedLevel<ept i="3">&lt;/c3&gt;</ept> whenever a new level is unlocked.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第一は、<bpt i="2" x="2">&lt;c2&gt;</bpt>unlock(_:)<ept i="2">&lt;/c2&gt;</ept>と呼ばれる型関数です、それは、新しいレベルが錠を開けられるときはいつでも、<bpt i="3" x="3">&lt;c3&gt;</bpt>highestUnlockedLevel<ept i="3">&lt;/c3&gt;</ept>の値を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first item in the array has an index of <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>, not <bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列での最初の項目が、<bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>ではなく、<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>のインデックスを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first item in the array represents the top left square on the board and the last item in the array represents the bottom right square on the board.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の最初の項目は盤上の一番左上の正方形を表わします、そして配列の最後の項目は盤上の一番右下の正方形を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first kind of pattern is used for destructuring values in simple variable, constant, and optional bindings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の種類のパターンは、単純な変数、定数、およびオプショナル束縛での非構成の値に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first letter of the case name is capitalized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ケース節の最初の文字は大文字で書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first pair has a key of <bpt i="1" x="1">&lt;c1&gt;</bpt>"YYZ"<ept i="1">&lt;/c1&gt;</ept> and a value of <bpt i="2" x="2">&lt;c2&gt;</bpt>"Toronto Pearson"<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の組みは、<bpt i="1" x="1">&lt;c1&gt;</bpt>"YYZ"<ept i="1">&lt;/c1&gt;</ept>のキーと<bpt i="2" x="2">&lt;c2&gt;</bpt>"Toronto Pearson"<ept i="2">&lt;/c2&gt;</ept>の値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first parameter is called <bpt i="1" x="1">&lt;c1&gt;</bpt>mathFunction<ept i="1">&lt;/c1&gt;</ept>, and is of type <bpt i="2" x="2">&lt;c2&gt;</bpt>(Int, Int) -&gt; Int<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初のパラメータは<bpt i="1" x="1">&lt;c1&gt;</bpt>mathFunction<ept i="1">&lt;/c1&gt;</ept>と呼ばれていて、型<bpt i="2" x="2">&lt;c2&gt;</bpt>(Int, Int) -&gt; Int<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first snippet defines a new base class called <bpt i="0" x="0">&lt;c0&gt;</bpt>MediaItem<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の断片は、<bpt i="0" x="0">&lt;c0&gt;</bpt>MediaItem<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しい基盤クラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first subclass, <bpt i="1" x="1">&lt;c1&gt;</bpt>Movie<ept i="1">&lt;/c1&gt;</ept>, encapsulates additional information about a movie or film.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初のサブクラス<bpt i="1" x="1">&lt;c1&gt;</bpt>Movie<ept i="1">&lt;/c1&gt;</ept>は、映画またはフィルムに関する追加の情報をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first two calls succeed, because the <bpt i="8" x="8">&lt;c8&gt;</bpt>testScores<ept i="8">&lt;/c8&gt;</ept> dictionary contains keys for <bpt i="9" x="9">&lt;c9&gt;</bpt>"Dave"<ept i="9">&lt;/c9&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt>"Bev"<ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の２つの呼び出しは成功します、なぜなら、<bpt i="8" x="8">&lt;c8&gt;</bpt>testScores<ept i="8">&lt;/c8&gt;</ept>辞書は<bpt i="9" x="9">&lt;c9&gt;</bpt>"Dave"<ept i="9">&lt;/c9&gt;</ept>と<bpt i="10" x="10">&lt;c10&gt;</bpt>"Bev"<ept i="10">&lt;/c10&gt;</ept>のキーを含んでいるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first two properties, <bpt i="2" x="2">&lt;c2&gt;</bpt>buildingName<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>buildingNumber<ept i="3">&lt;/c3&gt;</ept>, are alternative ways to identify a particular building as part of an address.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の２つのプロパティ、<bpt i="2" x="2">&lt;c2&gt;</bpt>buildingName<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>buildingNumber<ept i="3">&lt;/c3&gt;</ept>は、アドレスの一部として特定の建物を同定するそれぞれ代替の方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first type parameter, <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>, has a type constraint that requires <bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept> to be a subclass of <bpt i="2" x="2">&lt;c2&gt;</bpt>SomeClass<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の型パラメータ<bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>に<bpt i="2" x="2">&lt;c2&gt;</bpt>SomeClass<ept i="2">&lt;/c2&gt;</ept>のサブクラスであることを要求する型制約を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first, <bpt i="1" x="1">&lt;c1&gt;</bpt>resolution<ept i="1">&lt;/c1&gt;</ept>, is initialized with a new <bpt i="2" x="2">&lt;c2&gt;</bpt>Resolution<ept i="2">&lt;/c2&gt;</ept> structure instance, which infers a property type of <bpt i="3" x="3">&lt;c3&gt;</bpt>Resolution<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一番目、<bpt i="1" x="1">&lt;c1&gt;</bpt>resolution<ept i="1">&lt;/c1&gt;</ept>は、新しい<bpt i="2" x="2">&lt;c2&gt;</bpt>Resolution<ept i="2">&lt;/c2&gt;</ept>構造体インスタンスで初期化されます、そしてそれは、<bpt i="3" x="3">&lt;c3&gt;</bpt>Resolution<ept i="3">&lt;/c3&gt;</ept>のプロパティ型を暗に意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first, <bpt i="1" x="1">&lt;c1&gt;</bpt>thresholdLevel<ept i="1">&lt;/c1&gt;</ept>, defines the maximum threshold value an audio level can take.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その一番目、<bpt i="1" x="1">&lt;c1&gt;</bpt>thresholdLevel<ept i="1">&lt;/c1&gt;</ept>は、音声レベルがとることができる最大の限界値を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The fixity of the operator is specified by marking the operator declaration with the <bpt i="0" x="0">&lt;c0&gt;</bpt>infix<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>prefix<ept i="1">&lt;/c1&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt>postfix<ept i="2">&lt;/c2&gt;</ept> declaration modifier before the <bpt i="3" x="3">&lt;c3&gt;</bpt>operator<ept i="3">&lt;/c3&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子の定着性は、演算子定義を<bpt i="3" x="3">&lt;c3&gt;</bpt>operator<ept i="3">&lt;/c3&gt;</ept>キーワードの前に<bpt i="0" x="0">&lt;c0&gt;</bpt>infix<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>prefix<ept i="1">&lt;/c1&gt;</ept>、または<bpt i="2" x="2">&lt;c2&gt;</bpt>postfix<ept i="2">&lt;/c2&gt;</ept>宣言修飾子を使って印することによって指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following <bpt i="5" x="5">&lt;c5&gt;</bpt>if<ept i="5">&lt;/c5&gt;</ept> statements are equivalent:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の<bpt i="5" x="5">&lt;c5&gt;</bpt>if<ept i="5">&lt;/c5&gt;</ept>文は同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following approaches are equivalent:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の各取り組みは同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following are examples of literals:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下はリテラルの例です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following characters are considered whitespace: space (U+0020), line feed (U+000A), carriage return (U+000D), horizontal tab (U+0009), vertical tab (U+000B), form feed (U+000C) and null (U+0000).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の文字は、空白とみなされます：空白（U+0020）、行送り（U+000A）、復帰（U+000D）、水平タブ（U+0009）、垂直タブ（U+000B）、改ページ（U+000C）およびヌル（U+0000）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following closure expressions are equivalent:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のクロージャ式は、等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example adds a new instance method called <bpt i="0" x="0">&lt;c0&gt;</bpt>repetitions<ept i="0">&lt;/c0&gt;</ept> to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>repetitions<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しいインスタンスメソッドを<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>型に加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines a <bpt i="0" x="0">&lt;c0&gt;</bpt>Matrix<ept i="0">&lt;/c0&gt;</ept> structure, which represents a two-dimensional matrix of <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>Matrix<ept i="0">&lt;/c0&gt;</ept>構造体を定義します、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>値からなる２次元行列を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines a class called <bpt i="0" x="0">&lt;c0&gt;</bpt>SurveyQuestion<ept i="0">&lt;/c0&gt;</ept>, with an optional <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> property called <bpt i="2" x="2">&lt;c2&gt;</bpt>response<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>response<ept i="2">&lt;/c2&gt;</ept>と呼ばれるオプショナルの<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>プロパティで、<bpt i="0" x="0">&lt;c0&gt;</bpt>SurveyQuestion<ept i="0">&lt;/c0&gt;</ept>と呼ばれるクラスを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines a custom <bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept> structure to represent a geometric rectangle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、あつらえの<bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept>構造体を定義して、幾何学的な長方形を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines a new class called <bpt i="0" x="0">&lt;c0&gt;</bpt>AutomaticCar<ept i="0">&lt;/c0&gt;</ept>, which is a subclass of <bpt i="1" x="1">&lt;c1&gt;</bpt>Car<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>AutomaticCar<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しいクラスを定義します、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Car<ept i="1">&lt;/c1&gt;</ept>のサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines a new class called <bpt i="0" x="0">&lt;c0&gt;</bpt>Car<ept i="0">&lt;/c0&gt;</ept>, which is a subclass of <bpt i="1" x="1">&lt;c1&gt;</bpt>Vehicle<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Car<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しいクラスを定義します、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Vehicle<ept i="1">&lt;/c1&gt;</ept>のサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines a new custom infix operator called <bpt i="0" x="0">&lt;c0&gt;</bpt>+-<ept i="0">&lt;/c0&gt;</ept>, which belongs to the precedence group <bpt i="1" x="1">&lt;c1&gt;</bpt>AdditionPrecedence<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>+-<ept i="0">&lt;/c0&gt;</ept>と呼びれる新しいあつらえの接中辞演算子を定義します、それは優先順位グループ<bpt i="1" x="1">&lt;c1&gt;</bpt>AdditionPrecedence<ept i="1">&lt;/c1&gt;</ept>に属します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines a new subclass of <bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept> called <bpt i="1" x="1">&lt;c1&gt;</bpt>Train<ept i="1">&lt;/c1&gt;</ept>, which overrides the <bpt i="2" x="2">&lt;c2&gt;</bpt>makeNoise()<ept i="2">&lt;/c2&gt;</ept> method that <bpt i="3" x="3">&lt;c3&gt;</bpt>Train<ept i="3">&lt;/c3&gt;</ept> inherits from <bpt i="4" x="4">&lt;c4&gt;</bpt>Vehicle<ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Train<ept i="1">&lt;/c1&gt;</ept>と呼ばれる<bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept>の新しいサブクラスを定義します、それは、<bpt i="3" x="3">&lt;c3&gt;</bpt>Train<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>Vehicle<ept i="4">&lt;/c4&gt;</ept>から受け継ぐ<bpt i="2" x="2">&lt;c2&gt;</bpt>makeNoise()<ept i="2">&lt;/c2&gt;</ept>メソッドをオーバーライドします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines a protocol with a single instance method requirement:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、１つのインスタンスメソッド要件で、プロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines a structure called <bpt i="0" x="0">&lt;c0&gt;</bpt>Celsius<ept i="0">&lt;/c0&gt;</ept>, which stores temperatures expressed in degrees Celsius.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Celsius<ept i="0">&lt;/c0&gt;</ept>と呼ばれる構造体を定義します、それは、摂氏度数で表される温度を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines a structure called <bpt i="0" x="0">&lt;c0&gt;</bpt>Color<ept i="0">&lt;/c0&gt;</ept>, with three constant properties called <bpt i="1" x="1">&lt;c1&gt;</bpt>red<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>green<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>blue<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>Color<ept i="0">&lt;/c0&gt;</ept>と呼ばれる構造体を定義します、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>red<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>green<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>blue<ept i="3">&lt;/c3&gt;</ept>と呼ばれる３つの定数プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines a subclass called <bpt i="0" x="0">&lt;c0&gt;</bpt>Bicycle<ept i="0">&lt;/c0&gt;</ept>, with a superclass of <bpt i="1" x="1">&lt;c1&gt;</bpt>Vehicle<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Vehicle<ept i="1">&lt;/c1&gt;</ept>のスーパークラスを持つ、<bpt i="0" x="0">&lt;c0&gt;</bpt>Bicycle<ept i="0">&lt;/c0&gt;</ept>と呼ばれるサブクラスを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines an integer-counting class called <bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept>, which uses an external data source to provide its increment amount.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept>と呼ばれる整数計数クラスを定義します、それは、その増加量を提供するために外部のデータ・ソースを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example defines two classes, <bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept>, which model a bank customer and a possible credit card for that customer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は２つのクラス、<bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept>を定義します、それは、銀行顧客とその顧客のために可能なクレジットカードをモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example extends the generic <bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept> type to add a read-only computed property called <bpt i="1" x="1">&lt;c1&gt;</bpt>topItem<ept i="1">&lt;/c1&gt;</ept>, which returns the top item on the stack without popping it from the stack:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept>型を拡張して、<bpt i="1" x="1">&lt;c1&gt;</bpt>topItem<ept i="1">&lt;/c1&gt;</ept>と呼ばれる読み出し専用の計算プロパティを加えます、それは、スタックの一番上の項目をスタックからそれをポップすることなく返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example removes all vowels and spaces from a lowercase string to create a cryptic puzzle phrase:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、秘密の謎の語句をつくるために、小文字の文字列から全ての母音と空白を削除します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example replaces <bpt i="0" x="0">&lt;c0&gt;</bpt>"Chocolate Spread"<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>"Cheese"<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>"Butter"<ept i="2">&lt;/c2&gt;</ept> with <bpt i="3" x="3">&lt;c3&gt;</bpt>"Bananas"<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>"Apples"<ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>"Chocolate Spread"<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>"Cheese"<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>"Butter"<ept i="2">&lt;/c2&gt;</ept>を、<bpt i="3" x="3">&lt;c3&gt;</bpt>"Bananas"<ept i="3">&lt;/c3&gt;</ept>および<bpt i="4" x="4">&lt;c4&gt;</bpt>"Apples"<ept i="4">&lt;/c4&gt;</ept>と取り替えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example reports a compile-time error:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、コンパイル時エラーを報告します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows designated initializers, convenience initializers, and automatic initializer inheritance in action.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、指定イニシャライザ、便宜イニシャライザ、そして自動的なイニシャライザ継承の動作を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows the behavior of the example above without using optional chaining.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、オプショナル連鎖を使うことなく上の例の挙動を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example shows the difference in behavior between an optional string and an implicitly unwrapped optional string when accessing their wrapped value as an explicit <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、オプショナルの文字列と、暗黙的にアンラップされるオプショナルの文字列の間での、明示的な<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>としてラップされるそれらにアクセスする場合での、挙動の違いを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example switches on a <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> value and determines whether it represents a number symbol in one of four languages.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、ある<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>値に基づいて切り替えて、それが数字シンボルを４つの言語のうちの一つで表わすかどうかを明らかにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>continue<ept i="1">&lt;/c1&gt;</ept> statements with a labeled <bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept> loop for an adapted version of the <bpt i="3" x="3">&lt;e3&gt;</bpt>Snakes and Ladders<ept i="3">&lt;/e3&gt;</ept> game that you saw earlier in this chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>continue<ept i="1">&lt;/c1&gt;</ept>文をラベルが付いた<bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept>ループと一緒に、あなたがこの章で以前に見た<bpt i="3" x="3">&lt;e3&gt;</bpt>「ヘビとはしご」<ept i="3">&lt;/e3&gt;</ept>ゲームの改作板のために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following form declares a computed variable or computed property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の形式は、計算変数または計算プロパティを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following form declares a new infix operator:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の形式は、新しい接中辞演算子を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following form declares a new postfix operator:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の形式は、新しい接尾辞演算子を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following form declares a new prefix operator:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の形式は、新しい接頭辞演算子を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following form declares a stored variable or stored variable property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の形式は、保存変数または保存変数プロパティを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following form declares an enumeration type that contains enumeration cases of any type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の形式は、随意の型の列挙ケース節を含む列挙型を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following form declares an enumeration type that contains enumeration cases of the same basic type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の形式は、同じ基本の型をもつ列挙ケース節たちを含む列挙型を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following form declares initializers for structures, enumerations, and designated initializers of classes:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の形式は、構造体、列挙のイニシャライザ、そしてクラスの指定イニシャライザを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following function calls are equivalent:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の関数呼び出しは、等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following keywords are reserved and can’t be used as identifiers, unless they’re escaped with backticks, as described above in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Identifiers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>識別子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、以下のキーワードは予約済で、それらがバッククォートでエスケープされない限り、識別子として使われることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following requirements are placed on the function’s two type parameters:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の要件は、この関数の持つ２つの型パラメータ上に置かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following statement is not valid:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の文は、有効ではありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following tokens are reserved as punctuation and can’t be used as custom operators: <bpt i="0" x="0">&lt;c0&gt;</bpt>(<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>)<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>{<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>}<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>[<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>]<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>.<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>,<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>:<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>;<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>=<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>@<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>#<ept i="12">&lt;/c12&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt>&amp;<ept i="13">&lt;/c13&gt;</ept> (as a prefix operator), <bpt i="14" x="14">&lt;c14&gt;</bpt>-&gt;<ept i="14">&lt;/c14&gt;</ept>, <bpt i="15" x="15">&lt;c15&gt;</bpt>`<ept i="15">&lt;/c15&gt;</ept>, <bpt i="16" x="16">&lt;c16&gt;</bpt>?<ept i="16">&lt;/c16&gt;</ept>, and <bpt i="17" x="17">&lt;c17&gt;</bpt>!<ept i="17">&lt;/c17&gt;</ept> (as a postfix operator).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のトークンは、句読点として予約されます、そしてあつらえの演算子として使われることができません：<bpt i="0" x="0">&lt;c0&gt;</bpt>(<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>)<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>{<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>}<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>[<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>]<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>.<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>,<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>:<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>;<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>=<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>@<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>#<ept i="12">&lt;/c12&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt>&amp;<ept i="13">&lt;/c13&gt;</ept>（接頭辞演算子として）, <bpt i="14" x="14">&lt;c14&gt;</bpt>-&gt;<ept i="14">&lt;/c14&gt;</ept>, <bpt i="15" x="15">&lt;c15&gt;</bpt>`<ept i="15">&lt;/c15&gt;</ept>, <bpt i="16" x="16">&lt;c16&gt;</bpt>?<ept i="16">&lt;/c16&gt;</ept>, そして<bpt i="17" x="17">&lt;c17&gt;</bpt>!<ept i="17">&lt;/c17&gt;</ept>（接尾辞演算子として）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The forced form, <bpt i="1" x="1">&lt;c1&gt;</bpt>as!<ept i="1">&lt;/c1&gt;</ept>, attempts the downcast and force-unwraps the result as a single compound action.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>強制形式<bpt i="1" x="1">&lt;c1&gt;</bpt>as!<ept i="1">&lt;/c1&gt;</ept>は、一回の複合動作として、ダウンキャストとその結果の強制アンラップを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The fourth <bpt i="0" x="0">&lt;c0&gt;</bpt>codeUnit<ept i="0">&lt;/c0&gt;</ept> value (<bpt i="1" x="1">&lt;c1&gt;</bpt>8252<ept i="1">&lt;/c1&gt;</ept>) is a decimal equivalent of the hexadecimal value <bpt i="2" x="2">&lt;c2&gt;</bpt>203C<ept i="2">&lt;/c2&gt;</ept>, which represents the Unicode scalar <bpt i="3" x="3">&lt;c3&gt;</bpt>U+203C<ept i="3">&lt;/c3&gt;</ept> for the <bpt i="4" x="4">&lt;c4&gt;</bpt>DOUBLE EXCLAMATION MARK<ept i="4">&lt;/c4&gt;</ept> character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>４番目の<bpt i="0" x="0">&lt;c0&gt;</bpt>codeUnit<ept i="0">&lt;/c0&gt;</ept>値（<bpt i="1" x="1">&lt;c1&gt;</bpt>8252<ept i="1">&lt;/c1&gt;</ept>）は、16進数の値<bpt i="2" x="2">&lt;c2&gt;</bpt>203C<ept i="2">&lt;/c2&gt;</ept>です、それは、<bpt i="4" x="4">&lt;c4&gt;</bpt>DOUBLE EXCLAMATION MARK<ept i="4">&lt;/c4&gt;</ept>文字に対するユニコード・スカラー<bpt i="3" x="3">&lt;c3&gt;</bpt>U+203C<ept i="3">&lt;/c3&gt;</ept>を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The fourth <bpt i="0" x="0">&lt;c0&gt;</bpt>codeUnit<ept i="0">&lt;/c0&gt;</ept> value (<bpt i="1" x="1">&lt;c1&gt;</bpt>8252<ept i="1">&lt;/c1&gt;</ept>) is again a decimal equivalent of the hexadecimal value <bpt i="2" x="2">&lt;c2&gt;</bpt>203C<ept i="2">&lt;/c2&gt;</ept>, which represents the Unicode scalar <bpt i="3" x="3">&lt;c3&gt;</bpt>U+203C<ept i="3">&lt;/c3&gt;</ept> for the <bpt i="4" x="4">&lt;c4&gt;</bpt>DOUBLE EXCLAMATION MARK<ept i="4">&lt;/c4&gt;</ept> character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>４番目の<bpt i="0" x="0">&lt;c0&gt;</bpt>codeUnit<ept i="0">&lt;/c0&gt;</ept>値（<bpt i="1" x="1">&lt;c1&gt;</bpt>8252<ept i="1">&lt;/c1&gt;</ept>）は、ふたたび16進数値<bpt i="2" x="2">&lt;c2&gt;</bpt>203C<ept i="2">&lt;/c2&gt;</ept>の10進の等価物です、それは、<bpt i="4" x="4">&lt;c4&gt;</bpt>DOUBLE EXCLAMATION MARK<ept i="4">&lt;/c4&gt;</ept>文字に対するユニコード・スカラー<bpt i="3" x="3">&lt;c3&gt;</bpt>U+203C<ept i="3">&lt;/c3&gt;</ept>を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function definition still needs parentheses after the function’s name, even though it does not take any parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえそれが全くパラメータをとらないとしても、関数定義は依然として関数の名前の後に丸括弧を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function in the example below is called <bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:)<ept i="0">&lt;/c0&gt;</ept>, because that’s what it does—it takes a person’s name as input and returns a greeting for that person.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下記の例の関数は、それがすることから、<bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:)<ept i="0">&lt;/c0&gt;</ept>と呼ばれます ― それは、入力としてある人の名前をとって、その人のために挨拶を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function it returns has no parameters, and returns an <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> value each time it is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが返す関数は、パラメータを持たず、それが呼ばれるたびに<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function name is also followed by an empty pair of parentheses when the function is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その関数が呼ばれるとき、関数名の後にまた空の丸括弧の対が続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function performs this swap by storing the value of <bpt i="5" x="5">&lt;c5&gt;</bpt>a<ept i="5">&lt;/c5&gt;</ept> in a temporary constant called <bpt i="6" x="6">&lt;c6&gt;</bpt>temporaryA<ept i="6">&lt;/c6&gt;</ept>, assigning the value of <bpt i="7" x="7">&lt;c7&gt;</bpt>b<ept i="7">&lt;/c7&gt;</ept> to <bpt i="8" x="8">&lt;c8&gt;</bpt>a<ept i="8">&lt;/c8&gt;</ept>, and then assigning <bpt i="9" x="9">&lt;c9&gt;</bpt>temporaryA<ept i="9">&lt;/c9&gt;</ept> to <bpt i="10" x="10">&lt;c10&gt;</bpt>b<ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数はこの交換を、<bpt i="5" x="5">&lt;c5&gt;</bpt>a<ept i="5">&lt;/c5&gt;</ept>の値を<bpt i="6" x="6">&lt;c6&gt;</bpt>temporaryA<ept i="6">&lt;/c6&gt;</ept>と呼ばれる一時的な定数の中に保存して、<bpt i="7" x="7">&lt;c7&gt;</bpt>b<ept i="7">&lt;/c7&gt;</ept>の値を<bpt i="8" x="8">&lt;c8&gt;</bpt>a<ept i="8">&lt;/c8&gt;</ept>に代入して、それから<bpt i="9" x="9">&lt;c9&gt;</bpt>temporaryA<ept i="9">&lt;/c9&gt;</ept>を<bpt i="10" x="10">&lt;c10&gt;</bpt>b<ept i="10">&lt;/c10&gt;</ept>に代入することによって実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function prints “Function was called” before returning a value, which lets you see whether the right-hand side of the <bpt i="2" x="2">&lt;c2&gt;</bpt>=<ept i="2">&lt;/c2&gt;</ept> operator was evaluated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、値を返す前に「Function was called（関数は呼び出された）」を出力します、それはあなたに<bpt i="2" x="2">&lt;c2&gt;</bpt>=<ept i="2">&lt;/c2&gt;</ept>演算子の右手側が評価されたかどうかを確かめさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function returns a Boolean value of <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept> if all items match and a value of <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept> if they don’t.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は全ての項目が合致するならばブール値の<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>を、それらがそうしないならば<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function returns a tailored greeting in each case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は、それぞれの状況に合った挨拶を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function returns after it starts the operation, but the closure isn’t called until the operation is completed—the closure needs to escape, to be called later.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は、それが演算を開始した後に戻ります、しかしクロージャはその演算が完了されるまで呼び出されません—このクロージャは脱出する、後で呼び出される、必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function then considers the value of <bpt i="2" x="2">&lt;c2&gt;</bpt>integerToDescribe<ept i="2">&lt;/c2&gt;</ept> using a <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数は、それから<bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>文を使って<bpt i="2" x="2">&lt;c2&gt;</bpt>integerToDescribe<ept i="2">&lt;/c2&gt;</ept>の値を考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function then iterates over the remaining values in the array and checks each value to see if it is smaller or larger than the values of <bpt i="3" x="3">&lt;c3&gt;</bpt>currentMin<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>currentMax<ept i="4">&lt;/c4&gt;</ept> respectively.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数はそれから、配列の残りの値すべてに渡って繰り返します、そして各値をそれが<bpt i="3" x="3">&lt;c3&gt;</bpt>currentMin<ept i="3">&lt;/c3&gt;</ept>および<bpt i="4" x="4">&lt;c4&gt;</bpt>currentMax<ept i="4">&lt;/c4&gt;</ept>の値より小さいかより大きいかそれぞれについて調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function value carries no context and uses the C calling convention.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数値は、コンテキストを持ち運ばず、C呼出規約を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function value is represented as a reference to the block object, which is an <bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept>-compatible Objective-C object that embeds its invocation function within the object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数値はそのプロックオブジェクトへの参照として表現されます、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept>互換Objective-Cオブジェクトで、それの呼出関数がそのオブジェクト内部に埋め込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The function’s return type is a tuple type composed from two of the custom classes defined above in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Custom Types<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数の戻り型は、上の<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>あつらえの型<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で定義されるあつらえのクラスのうちの２つから作られるタプル型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The game board is represented by an array of <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゲーム盤は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>値の配列によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The game board is the same as before.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゲーム盤は、前と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clause in the example above requires <bpt i="1" x="1">&lt;c1&gt;</bpt>Item<ept i="1">&lt;/c1&gt;</ept> to conform to a protocol, but you can also write a generic <bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept> clauses that require <bpt i="3" x="3">&lt;c3&gt;</bpt>Item<ept i="3">&lt;/c3&gt;</ept> to be a specific type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例の総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Item<ept i="1">&lt;/c1&gt;</ept>に要求してあるプロトコルに準拠させます、しかしあなたはまた<bpt i="3" x="3">&lt;c3&gt;</bpt>Item<ept i="3">&lt;/c3&gt;</ept>に特定の型であることを要求する総称体<bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept>節を書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clause on <bpt i="1" x="1">&lt;c1&gt;</bpt>Iterator<ept i="1">&lt;/c1&gt;</ept> requires that the iterator must traverse over elements of the same item type as the container’s items, regardless of the iterator’s type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節が<bpt i="1" x="1">&lt;c1&gt;</bpt>Iterator<ept i="1">&lt;/c1&gt;</ept>上で要求するのは、そのイテレータがコンテナのもつ要素と同じ項目型の要素に対して見ていくことです、そのイテレータの持つ型に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clause requires that the iterator for the sequence must traverse over elements of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節が要求するのは、このシーケンスのためのイテレータが型<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>の要素について見ていかなければなければならないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The generic parameter <bpt i="0" x="0">&lt;c0&gt;</bpt>Indices<ept i="0">&lt;/c0&gt;</ept> in angle brackets has to be a type that conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept> protocol from the standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>山括弧の中の総称体パラメータ<bpt i="0" x="0">&lt;c0&gt;</bpt>Indices<ept i="0">&lt;/c0&gt;</ept>は、それは標準ライブラリからの<bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠する型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The generic version of the function uses a <bpt i="0" x="0">&lt;e0&gt;</bpt>placeholder<ept i="0">&lt;/e0&gt;</ept> type name (called <bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>, in this case) instead of an <bpt i="2" x="2">&lt;e2&gt;</bpt>actual<ept i="2">&lt;/e2&gt;</ept> type name (such as <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>, or <bpt i="5" x="5">&lt;c5&gt;</bpt>Double<ept i="5">&lt;/c5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数の総称体版は、<bpt i="0" x="0">&lt;e0&gt;</bpt>プレースホルダ<ept i="0">&lt;/e0&gt;</ept>型名（この場合、<bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>と呼ばれるもの）を<bpt i="2" x="2">&lt;e2&gt;</bpt>実際の<ept i="2">&lt;/e2&gt;</ept>型名（例えば<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>、または<bpt i="5" x="5">&lt;c5&gt;</bpt>Double<ept i="5">&lt;/c5&gt;</ept>）の代わりに使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The getter and setter requirements can be satisfied by a conforming type in a variety of ways.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゲッターとセッター要件は、準拠している型によっていろいろなやり方で満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The getter is used to read the value, and the setter is used to write the value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゲッターが値を読むために使われます、そしてセッターが値を書くために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The given expression is evaluated when the function is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられた式は、関数が呼び出される時に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The global and local variables you have encountered in previous chapters have all been <bpt i="0" x="0">&lt;e0&gt;</bpt>stored variables<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが前の章において遭遇したグローバルおよびローカル変数は、すべて<bpt i="0" x="0">&lt;e0&gt;</bpt>保存変数<ept i="0">&lt;/e0&gt;</ept>でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The grammar described here is intended to help you understand the language in more detail, rather than to allow you to directly implement a parser or compiler.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここで記述される文法は、あなたが更に詳細に言語を理解するのを手伝うつもりのもので、あなたに直ちにパーサーまたはコンパイラを実装させるようにするものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The grammar production above is equivalent to the following two productions, where the alternatives are spelled out explicitly:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の文法導出は以下の２つの導出に等しいです、そこでは代替物がそれぞれ分けて書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The half-open range operator also has a one-sided form that’s written with only its final value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>半開範囲演算子もまた、それの最後の値のみで記述される、片側形式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The hexadecimal fraction consists of a decimal point followed by a sequence of hexadecimal digits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>16進の小数部は、小数点に続く一連の16進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The hypothetical function above has two type parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の仮定の関数は、２つの型パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The identifier specifies the name to be exposed to Objective-C for the entity that the <bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept> attribute applies to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この識別子は、Objective-Cへと暴露される名前を<bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept>属性を適用される存在に対して指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The illustration below depicts three sets—<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>c<ept i="2">&lt;/c2&gt;</ept>—with overlapping regions representing elements shared among sets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の図は３つの集合—<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>c<ept i="2">&lt;/c2&gt;</ept>—を集合間で共有される要素を表している重なり合う領域とともに描写します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The illustration below depicts two sets—<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>—with the results of various set operations represented by the shaded regions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の図は、２つの集合—<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>—を網掛けの領域で表される様々な集合演算の結果とともに描写します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The illustration below shows the push and pop behavior for a stack:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下のイラストは、あるスタックのプッシュおよびポップ挙動を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The illustration below shows the results of <bpt i="0" x="0">&lt;c0&gt;</bpt>11111111 &lt;&lt; 1<ept i="0">&lt;/c0&gt;</ept> (which is <bpt i="1" x="1">&lt;c1&gt;</bpt>11111111<ept i="1">&lt;/c1&gt;</ept> shifted to the left by <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept> place), and <bpt i="3" x="3">&lt;c3&gt;</bpt>11111111 &gt;&gt; 1<ept i="3">&lt;/c3&gt;</ept> (which is <bpt i="4" x="4">&lt;c4&gt;</bpt>11111111<ept i="4">&lt;/c4&gt;</ept> shifted to the right by <bpt i="5" x="5">&lt;c5&gt;</bpt>1<ept i="5">&lt;/c5&gt;</ept> place).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下のイラストは、<bpt i="0" x="0">&lt;c0&gt;</bpt>11111111 &lt;&lt; 1<ept i="0">&lt;/c0&gt;</ept>（それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>桁だけ左へシフトされる<bpt i="1" x="1">&lt;c1&gt;</bpt>11111111<ept i="1">&lt;/c1&gt;</ept>です）、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>11111111 &gt;&gt; 1<ept i="3">&lt;/c3&gt;</ept>（それは、<bpt i="5" x="5">&lt;c5&gt;</bpt>1<ept i="5">&lt;/c5&gt;</ept>桁だけ右へシフトされる<bpt i="4" x="4">&lt;c4&gt;</bpt>11111111<ept i="4">&lt;/c4&gt;</ept>です）の結果を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The implementation of <bpt i="0" x="0">&lt;c0&gt;</bpt>gameDidStart(_:)<ept i="0">&lt;/c0&gt;</ept> shown above uses the <bpt i="1" x="1">&lt;c1&gt;</bpt>game<ept i="1">&lt;/c1&gt;</ept> parameter to print some introductory information about the game that is about to be played.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上で示される<bpt i="0" x="0">&lt;c0&gt;</bpt>gameDidStart(_:)<ept i="0">&lt;/c0&gt;</ept>の実装は、<bpt i="1" x="1">&lt;c1&gt;</bpt>game<ept i="1">&lt;/c1&gt;</ept>パラメータを使って、プレイされようとしているゲームに関する若干の紹介の情報を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The implementation of the <bpt i="0" x="0">&lt;c0&gt;</bpt>vend(itemNamed:)<ept i="0">&lt;/c0&gt;</ept> method uses <bpt i="1" x="1">&lt;c1&gt;</bpt>guard<ept i="1">&lt;/c1&gt;</ept> statements to exit the method early and throw appropriate errors if any of the requirements for purchasing a snack aren’t met.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>vend(itemNamed:)<ept i="0">&lt;/c0&gt;</ept>メソッドの実装は<bpt i="1" x="1">&lt;c1&gt;</bpt>guard<ept i="1">&lt;/c1&gt;</ept>文を使って、購入スナックに必要な何かが満たされないならば早めにそのメソッドを終了して対応するエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The individual cases of an enumeration automatically receive the same access level as the enumeration they belong to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある列挙の個々のケース節は、自動的にそれらが属している列挙と同じアクセス水準を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The information about <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Accessing Properties Through Optional Chaining<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> has been updated accordingly, and the examples of checking for method call success in <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Calling Methods Through Optional Chaining<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> have been expanded to show how to check for property setting success.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>オプショナル連鎖を通してプロパティにアクセスする<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>についての情報はそれを受けて更新されました、そして<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>オプショナル連鎖を通してメソッドを呼び出す<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>の中のメソッド呼び出しがうまくいったかを確認する例は拡張されて、プロパティの設定がうまくいったかを確認する方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The inherited version of <bpt i="4" x="4">&lt;c4&gt;</bpt>init()<ept i="4">&lt;/c4&gt;</ept> functions in exactly the same way as the <bpt i="5" x="5">&lt;c5&gt;</bpt>Food<ept i="5">&lt;/c5&gt;</ept> version, except that it delegates to the <bpt i="6" x="6">&lt;c6&gt;</bpt>RecipeIngredient<ept i="6">&lt;/c6&gt;</ept> version of <bpt i="7" x="7">&lt;c7&gt;</bpt>init(name: String)<ept i="7">&lt;/c7&gt;</ept> rather than the <bpt i="8" x="8">&lt;c8&gt;</bpt>Food<ept i="8">&lt;/c8&gt;</ept> version.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>init()<ept i="4">&lt;/c4&gt;</ept>の継承された改変板は、<bpt i="5" x="5">&lt;c5&gt;</bpt>Food<ept i="5">&lt;/c5&gt;</ept>版と同じ正確に方法で機能しますが、それが<bpt i="8" x="8">&lt;c8&gt;</bpt>Food<ept i="8">&lt;/c8&gt;</ept>板ではなく<bpt i="6" x="6">&lt;c6&gt;</bpt>RecipeIngredient<ept i="6">&lt;/c6&gt;</ept>版の<bpt i="7" x="7">&lt;c7&gt;</bpt>init(name: String)<ept i="7">&lt;/c7&gt;</ept>に委任することを除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The init! Failable Initializer</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>init!失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The initialization of <bpt i="0" x="0">&lt;c0&gt;</bpt>airports<ept i="0">&lt;/c0&gt;</ept> could have been written in a shorter form instead:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>airports<ept i="0">&lt;/c0&gt;</ept>の初期化は、代わりにより短い形式で書かれることもできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The initialization of <bpt i="0" x="0">&lt;c0&gt;</bpt>shoppingList<ept i="0">&lt;/c0&gt;</ept> could have been written in a shorter form instead:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>shoppingList<ept i="0">&lt;/c0&gt;</ept>の初期化は、前の代わりにより短い形式に書かれることもできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The initialization of <bpt i="1" x="1">&lt;c1&gt;</bpt>favoriteGenres<ept i="1">&lt;/c1&gt;</ept> could have been written in a shorter form instead:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>favoriteGenres<ept i="1">&lt;/c1&gt;</ept>の初期化は、代わりに次のような短い形式で書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The initializer <bpt i="0" x="0">&lt;e0&gt;</bpt>expression<ept i="0">&lt;/e0&gt;</ept> can’t be present in a protocol declaration, but in all other contexts, the initializer <bpt i="1" x="1">&lt;e1&gt;</bpt>expression<ept i="1">&lt;/e1&gt;</ept> is optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ<bpt i="0" x="0">&lt;e0&gt;</bpt>式<ept i="0">&lt;/e0&gt;</ept>はプロトコル宣言に含まれることはできません、しかし全ての他の文脈ではそうではありません、イニシャライザ<bpt i="1" x="1">&lt;e1&gt;</bpt>式<ept i="1">&lt;/e1&gt;</ept>は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The initializer <bpt i="0" x="0">&lt;e0&gt;</bpt>expression<ept i="0">&lt;/e0&gt;</ept> is optional in the context of a class or structure declaration, but required elsewhere.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ<bpt i="0" x="0">&lt;e0&gt;</bpt>式<ept i="0">&lt;/e0&gt;</ept>は、クラスまたは構造体宣言の文脈では任意です、しかしその他では必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The initializer call <bpt i="0" x="0">&lt;c0&gt;</bpt>Celsius(37.0)<ept i="0">&lt;/c0&gt;</ept> is clear in its intent without the need for an argument label.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ呼び出し<bpt i="0" x="0">&lt;c0&gt;</bpt>Celsius(37.0)<ept i="0">&lt;/c0&gt;</ept>は、引数ラベルを必要としなくともその意図は明快です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The initializer can then fail if the provided parameters do not match an appropriate enumeration case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、提供されたパラメータが適切な列挙ケース節に適合しないならばその時に失敗できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The initializer for <bpt i="0" x="0">&lt;c0&gt;</bpt>City<ept i="0">&lt;/c0&gt;</ept> is called from within the initializer for <bpt i="1" x="1">&lt;c1&gt;</bpt>Country<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>City<ept i="0">&lt;/c0&gt;</ept>のためのイニシャライザは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Country<ept i="1">&lt;/c1&gt;</ept>のためにイニシャライザの内部から呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The initializer then calls the structure’s automatic memberwise initializer <bpt i="2" x="2">&lt;c2&gt;</bpt>init(origin:size:)<ept i="2">&lt;/c2&gt;</ept>, which stores the new origin and size values in the appropriate properties:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザはそれから、構造体の自動的なメンバー関連イニシャライザ<bpt i="2" x="2">&lt;c2&gt;</bpt>init(origin:size:)<ept i="2">&lt;/c2&gt;</ept>を呼びます、それは、新しい原点とサイズ値を適切なプロパティに保管します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The instances can then refer to each other without creating a strong reference cycle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスは、そのあと強い参照循環をつくることなくお互いに言及することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The instance’s <bpt i="0" x="0">&lt;c0&gt;</bpt>asHTML<ept i="0">&lt;/c0&gt;</ept> property holds a strong reference to its closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインスタンスの<bpt i="0" x="0">&lt;c0&gt;</bpt>asHTML<ept i="0">&lt;/c0&gt;</ept>プロパティは、それのクロージャに対する強い参照を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The integers start at zero and count up by one for each item; if you enumerate over a whole array, these integers match the items’ indices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その整数はゼロから始めて各項目に対して１ずつ数えていきます；あなたが配列全体をすべて列挙するならば、それらの整数はそれら項目のもつインデックスと一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The interpolated expression can contain a string literal, but can’t contain an unescaped backslash, a carriage return, or a line feed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>差し込まれた式は、文字列リテラルを含むことができます、しかしエスケープされないバックスラッシュ、キャリッジリターン、またはラインフィードを含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The invocation function uses the C calling convention.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この呼出関数はC呼出規約を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The items in <bpt i="0" x="0">&lt;c0&gt;</bpt>someContainer<ept i="0">&lt;/c0&gt;</ept> can be checked with the not equal operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>!=<ept i="1">&lt;/c1&gt;</ept>) to see if they’re different from each other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>someContainer<ept i="0">&lt;/c0&gt;</ept>の中の項目は、それらがお互いと異なるかどうか見るために不等演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>!=<ept i="1">&lt;/c1&gt;</ept>）を使って確認されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The items stored in <bpt i="0" x="0">&lt;c0&gt;</bpt>library<ept i="0">&lt;/c0&gt;</ept> are still <bpt i="1" x="1">&lt;c1&gt;</bpt>Movie<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Song<ept i="2">&lt;/c2&gt;</ept> instances behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>library<ept i="0">&lt;/c0&gt;</ept>に保存される項目は、依然として舞台裏では<bpt i="1" x="1">&lt;c1&gt;</bpt>Movie<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>Song<ept i="2">&lt;/c2&gt;</ept>インスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key type of a dictionary must conform to the Swift standard library <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある辞書のキーの型は、スウィフト標準ライブラリ<bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The key-value pairs are written as a list, separated by commas, surrounded by a pair of square brackets:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「キーと値」の対はリストとして書かれます、それはコンマで区切られ、一対の角括弧に囲まれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The largest valid index in an array is <bpt i="1" x="1">&lt;c1&gt;</bpt>count - 1<ept i="1">&lt;/c1&gt;</ept> because arrays are indexed from zero—however, when <bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept> (meaning the array is empty), there are no valid indexes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある配列の中の最も大きい有効なインデックスは<bpt i="1" x="1">&lt;c1&gt;</bpt>count - 1<ept i="1">&lt;/c1&gt;</ept>です、なぜなら配列はゼロからインデックスをつけられるからです — しかしながら、<bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>である時（配列がからであるのを意味しています）、有効なインデックスは全然ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The last <bpt i="6" x="6">&lt;c6&gt;</bpt>defer<ept i="6">&lt;/c6&gt;</ept> statement in source code order executes first.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ソースコード順序での最後の<bpt i="6" x="6">&lt;c6&gt;</bpt>defer<ept i="6">&lt;/c6&gt;</ept>文は最初に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The last argument, <bpt i="1" x="1">&lt;c1&gt;</bpt>*<ept i="1">&lt;/c1&gt;</ept>, is required and specifies that on any other platform, the body of the <bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept> executes on the minimum deployment target specified by your target.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後の引数<bpt i="1" x="1">&lt;c1&gt;</bpt>*<ept i="1">&lt;/c1&gt;</ept>は、必要で、あらゆる他のプラットホーム上を指定します、<bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept>の本文は、あなたの対象で指定される、最小の開発対象で実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The last expression in the array can be followed by an optional comma.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の最後の式の後に、１つの任意のコンマが続くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The last expression in the dictionary can be followed by an optional comma.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の最後の式の後に、１つの任意のコンマが続くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The last four <bpt i="12" x="12">&lt;c12&gt;</bpt>codeUnit<ept i="12">&lt;/c12&gt;</ept> values (<bpt i="13" x="13">&lt;c13&gt;</bpt>240<ept i="13">&lt;/c13&gt;</ept>, <bpt i="14" x="14">&lt;c14&gt;</bpt>159<ept i="14">&lt;/c14&gt;</ept>, <bpt i="15" x="15">&lt;c15&gt;</bpt>144<ept i="15">&lt;/c15&gt;</ept>, <bpt i="16" x="16">&lt;c16&gt;</bpt>182<ept i="16">&lt;/c16&gt;</ept>) are a four-byte UTF-8 representation of the <bpt i="17" x="17">&lt;c17&gt;</bpt>DOG FACE<ept i="17">&lt;/c17&gt;</ept> character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後の４つの<bpt i="12" x="12">&lt;c12&gt;</bpt>codeUnit<ept i="12">&lt;/c12&gt;</ept>値（<bpt i="13" x="13">&lt;c13&gt;</bpt>240<ept i="13">&lt;/c13&gt;</ept>、<bpt i="14" x="14">&lt;c14&gt;</bpt>159<ept i="14">&lt;/c14&gt;</ept>、<bpt i="15" x="15">&lt;c15&gt;</bpt>144<ept i="15">&lt;/c15&gt;</ept>、<bpt i="16" x="16">&lt;c16&gt;</bpt>182<ept i="16">&lt;/c16&gt;</ept>）は、<bpt i="17" x="17">&lt;c17&gt;</bpt>DOG FACE<ept i="17">&lt;/c17&gt;</ept>文字の４バイトUTF-８叙述です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The length of an <bpt i="3" x="3">&lt;c3&gt;</bpt>NSString<ept i="3">&lt;/c3&gt;</ept> is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="3" x="3">&lt;c3&gt;</bpt>NSString<ept i="3">&lt;/c3&gt;</ept>の長さは、その文字列のUTF-16表現内の16ビットコード単位の数に基づきます、その文字列内のユニコード拡張書記素クラスタの数ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The letter <bpt i="0" x="0">&lt;c0&gt;</bpt>é<ept i="0">&lt;/c0&gt;</ept> can be represented as the single Unicode scalar <bpt i="1" x="1">&lt;c1&gt;</bpt>é<ept i="1">&lt;/c1&gt;</ept> (<bpt i="2" x="2">&lt;c2&gt;</bpt>LATIN SMALL LETTER E WITH ACUTE<ept i="2">&lt;/c2&gt;</ept>, or <bpt i="3" x="3">&lt;c3&gt;</bpt>U+00E9<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字<bpt i="0" x="0">&lt;c0&gt;</bpt>é<ept i="0">&lt;/c0&gt;</ept>は、単一のユニコード・スカラー<bpt i="1" x="1">&lt;c1&gt;</bpt>é<ept i="1">&lt;/c1&gt;</ept>（<bpt i="2" x="2">&lt;c2&gt;</bpt>LATIN SMALL LETTER E WITH ACUTE<ept i="2">&lt;/c2&gt;</ept>、または<bpt i="3" x="3">&lt;c3&gt;</bpt>U+00E9<ept i="3">&lt;/c3&gt;</ept>）として表わされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The line break after the <bpt i="0" x="0">&lt;c0&gt;</bpt>"""<ept i="0">&lt;/c0&gt;</ept> that begins the multiline string literal is not part of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行文字列リテラルを開始する<bpt i="0" x="0">&lt;c0&gt;</bpt>"""<ept i="0">&lt;/c0&gt;</ept>の後のラインブレークは、その文字列の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The line break before the <bpt i="1" x="1">&lt;c1&gt;</bpt>"""<ept i="1">&lt;/c1&gt;</ept> that ends the literal is also not part of the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リテラルの終わりの<bpt i="1" x="1">&lt;c1&gt;</bpt>"""<ept i="1">&lt;/c1&gt;</ept>の前のキャリッジリターンまたはラインフィードもまた、その文字列の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The line number on which it appears.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが現れる行番号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The listing below does the same assignment, but it uses a function to create the address.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下でのコード出力は、同じ代入を行います、しかしそれはある関数を使ってアドレスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The literal value <bpt i="0" x="0">&lt;c0&gt;</bpt>3<ept i="0">&lt;/c0&gt;</ept> can be added directly to the literal value <bpt i="1" x="1">&lt;c1&gt;</bpt>0.14159<ept i="1">&lt;/c1&gt;</ept>, because number literals don’t have an explicit type in and of themselves.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リテラル値<bpt i="0" x="0">&lt;c0&gt;</bpt>3<ept i="0">&lt;/c0&gt;</ept>は、直接にリテラル値<bpt i="1" x="1">&lt;c1&gt;</bpt>0.14159<ept i="1">&lt;/c1&gt;</ept>に加えられることができます、なぜなら数リテラルがそれら自身において明確な型を持たないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The literal value of <bpt i="0" x="0">&lt;c0&gt;</bpt>3<ept i="0">&lt;/c0&gt;</ept> has no explicit type in and of itself, and so an appropriate output type of <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept> is inferred from the presence of a floating-point literal as part of the addition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リテラル値<bpt i="0" x="0">&lt;c0&gt;</bpt>3<ept i="0">&lt;/c0&gt;</ept>は明確な型をそれ自体は持ちません、それで適切な出力の<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>型は、加算部分の浮動小数点リテラルの存在から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The logical NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>論理否定演算子は接頭辞演算子です、そして全く空白なしで、それが作用する値の直前に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The loop then ends, and control returns to the <bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept> condition to decide whether another turn is required.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループはそれから終わります、そして制御はもう一つの回が必要かどうか決めるために<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept>条件に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The loop’s condition (<bpt i="0" x="0">&lt;c0&gt;</bpt>while square &lt; finalSquare<ept i="0">&lt;/c0&gt;</ept>) is the same as before, but this time it’s not evaluated until the <bpt i="1" x="1">&lt;e1&gt;</bpt>end<ept i="1">&lt;/e1&gt;</ept> of the first run through the loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループの条件（<bpt i="0" x="0">&lt;c0&gt;</bpt>while square &lt; finalSquare<ept i="0">&lt;/c0&gt;</ept>）は前と同じものです、しかし今回それは最初のループ通り抜けの<bpt i="1" x="1">&lt;e1&gt;</bpt>終わり<ept i="1">&lt;/e1&gt;</ept>まで評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The main difference is that during phase 1, Objective-C assigns zero or null values (such as <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>) to every property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>主な違いは、段階１の間に、Objective-Cがゼロまたは無効な値（例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>）をあらゆるプロパティに代入するということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The main difference is that optional chaining fails gracefully when the optional is <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>, whereas forced unwrapping triggers a runtime error when the optional is <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>大きな違いは、オプショナル連鎖はそのオプショナルが<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>であるとき潔く失敗します、だけれども強制アンラップはそのオプショナルが<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>であるとき実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The main exception to this rule occurs when a parameter name for an instance method has the same name as a property of that instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この規則に対する主な例外は、インスタンスメソッドのパラメータ名がそのインスタンスのプロパティと同じ名前を持つ時に起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The matches succeeds if the <bpt i="1" x="1">&lt;c1&gt;</bpt>~=<ept i="1">&lt;/c1&gt;</ept> operator returns <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>~=<ept i="1">&lt;/c1&gt;</ept>演算子が<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>を返すならば、マッチは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The members of a module access the top-level declarations of that module.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>モジュールのメンバーは、そのモジュールのトップレベルの宣言にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The members of a named type are named as part of the type’s declaration or extension.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>名前付きの型に属するメンバーは、型の宣言または拡張の一部として命名されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The members of a tuple are implicitly named using integers in the order they appear, starting from zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプルのメンバーは、整数を使って、それらが現れる順序で、ゼロから始めて、暗黙のうちに名前をつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memberwise initializer is a shorthand way to initialize the member properties of new structure instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メンバー関連イニシャライザは、新しい構造体インスタンスのメンバープロパティを初期化するための略記方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory for these stored properties is now initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの保存プロパティに対するメモリは、今や初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The memory is not yet initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのメモリは、まだ初期化されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The metatype of a class, structure, or enumeration type is the name of that type followed by <bpt i="0" x="0">&lt;c0&gt;</bpt>.Type<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラス、構造体、または列挙型のメタタイプは、その型の名前に<bpt i="0" x="0">&lt;c0&gt;</bpt>.Type<ept i="0">&lt;/c0&gt;</ept>が続くものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The metatype of a protocol type—not the concrete type that conforms to the protocol at runtime—is the name of that protocol followed by <bpt i="1" x="1">&lt;c1&gt;</bpt>.Protocol<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコル型 ― 実行時にそのプロトコルに準拠する具体的な型ではない ― のメタタイプは、そのプロトコルの名前に<bpt i="1" x="1">&lt;c1&gt;</bpt>.Protocol<ept i="1">&lt;/c1&gt;</ept>が続くものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The method can also assign a completely new instance to its implicit <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> property, and this new instance will replace the existing one when the method ends.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドはまた、完全に新しいインスタンスをその暗黙の<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>プロパティに代入することができます、そして、そのメソッドが終了するとき、この新しいインスタンスは既存のものを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The method can then mutate (that is, change) its properties from within the method, and any changes that it makes are written back to the original structure when the method ends.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドはそれからそれのプロパティをメソッド内部から変化させること（すなわち変更）ができます、そして、そのメソッドが終了するとき、それが行ったどんな変更も本来の構造体へ書き込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The method returns a new <bpt i="4" x="4">&lt;c4&gt;</bpt>Vector2D<ept i="4">&lt;/c4&gt;</ept> instance, whose <bpt i="5" x="5">&lt;c5&gt;</bpt>x<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>y<ept i="6">&lt;/c6&gt;</ept> properties are initialized with the sum of the <bpt i="7" x="7">&lt;c7&gt;</bpt>x<ept i="7">&lt;/c7&gt;</ept> and <bpt i="8" x="8">&lt;c8&gt;</bpt>y<ept i="8">&lt;/c8&gt;</ept> properties from the two <bpt i="9" x="9">&lt;c9&gt;</bpt>Vector2D<ept i="9">&lt;/c9&gt;</ept> instances that are added together.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッドは、新しい<bpt i="4" x="4">&lt;c4&gt;</bpt>Vector2D<ept i="4">&lt;/c4&gt;</ept>インスタンスを返します、それは<bpt i="5" x="5">&lt;c5&gt;</bpt>x<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>y<ept i="6">&lt;/c6&gt;</ept>プロパティが一緒に加えられる２つの<bpt i="9" x="9">&lt;c9&gt;</bpt>Vector2D<ept i="9">&lt;/c9&gt;</ept>インスタンスからの<bpt i="7" x="7">&lt;c7&gt;</bpt>x<ept i="7">&lt;/c7&gt;</ept>と<bpt i="8" x="8">&lt;c8&gt;</bpt>y<ept i="8">&lt;/c8&gt;</ept>プロパティの合計で初期化されるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The middle line has more indentation than the closing quotes, so it starts with that extra four-space indentation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>真ん中の行は終了引用符よりもっと字下げされます、なのでそれは追加の４つの空白の字下げで始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The minimum value that a <bpt i="0" x="0">&lt;c0&gt;</bpt>UInt8<ept i="0">&lt;/c0&gt;</ept> can hold is zero, or <bpt i="1" x="1">&lt;c1&gt;</bpt>00000000<ept i="1">&lt;/c1&gt;</ept> in binary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>UInt8<ept i="0">&lt;/c0&gt;</ept>が持つことができる最小限の値は、０、または２進数では<bpt i="1" x="1">&lt;c1&gt;</bpt>00000000<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The minimum value that an <bpt i="0" x="0">&lt;c0&gt;</bpt>Int8<ept i="0">&lt;/c0&gt;</ept> can hold is <bpt i="1" x="1">&lt;c1&gt;</bpt>-128<ept i="1">&lt;/c1&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt>10000000<ept i="2">&lt;/c2&gt;</ept> in binary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int8<ept i="0">&lt;/c0&gt;</ept>が持つことができる最小限の数は、<bpt i="1" x="1">&lt;c1&gt;</bpt>-128<ept i="1">&lt;/c1&gt;</ept>、または２進数での<bpt i="2" x="2">&lt;c2&gt;</bpt>10000000<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The name of a class</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラスの名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The name of a protocol</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコルの名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The name of each case must be unique.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各ケース節の名前は、固有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The name of the declaration in which it appears.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが現れる宣言の名前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The name of the file in which it appears.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それが現れるファイルの名前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The nature of the mapping and the type of the returned value is left up to the closure to specify.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>マッピング（対応付け）の性質と返される値の型は、指定するクロージャに委ねられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The nearest thing in Objective-C is the ability to return <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> from a method that would otherwise return an object, with <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> meaning “the absence of a valid object.” However, this only works for objects—it doesn’t work for structures, basic C types, or enumeration values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cにおいて最も近いものは、オブジェクトを返すメソッドからそうできない場合に<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返す能力です、そのとき<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>は「有効なオブジェクトの欠如」を意味しています。しかし、それは単にオブジェクトのためだけに働きます ― それは構造体、基本的なC型、または列挙値のために働きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The nested <bpt i="2" x="2">&lt;c2&gt;</bpt>incrementer()<ept i="2">&lt;/c2&gt;</ept> function captures two values, <bpt i="3" x="3">&lt;c3&gt;</bpt>runningTotal<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>amount<ept i="4">&lt;/c4&gt;</ept>, from its surrounding context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされた<bpt i="2" x="2">&lt;c2&gt;</bpt>incrementer()<ept i="2">&lt;/c2&gt;</ept>関数は、それを取り囲む前後関係から２つの値、<bpt i="3" x="3">&lt;c3&gt;</bpt>runningTotal<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>amount<ept i="4">&lt;/c4&gt;</ept>を捕獲します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The nested enumeration can now be used with any <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされた列挙は今やあらゆる<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>値で使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new <bpt i="0" x="0">&lt;c0&gt;</bpt>Bicycle<ept i="0">&lt;/c0&gt;</ept> class automatically gains all of the characteristics of <bpt i="1" x="1">&lt;c1&gt;</bpt>Vehicle<ept i="1">&lt;/c1&gt;</ept>, such as its <bpt i="2" x="2">&lt;c2&gt;</bpt>currentSpeed<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>description<ept i="3">&lt;/c3&gt;</ept> properties and its <bpt i="4" x="4">&lt;c4&gt;</bpt>makeNoise()<ept i="4">&lt;/c4&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Bicycle<ept i="0">&lt;/c0&gt;</ept>クラスは、自動的に<bpt i="1" x="1">&lt;c1&gt;</bpt>Vehicle<ept i="1">&lt;/c1&gt;</ept>のすべての特徴を獲得します、例えばそれの<bpt i="2" x="2">&lt;c2&gt;</bpt>currentSpeed<ept i="2">&lt;/c2&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt>description<ept i="3">&lt;/c3&gt;</ept>プロパティやそれの<bpt i="4" x="4">&lt;c4&gt;</bpt>makeNoise()<ept i="4">&lt;/c4&gt;</ept>メソッドなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new array’s type is inferred from the type of the two arrays you add together:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい配列の型は、あなたが一緒に加える２つの配列の型から推論されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new name is displayed by the compiler when emitting an error about the use of a renamed declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい名前は、改名された宣言の使用についてのエラーを発するときにコンパイラによって表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new type can then be used wherever its access level permits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その新しい型はそれから、そのアクセス水準が許すところどこででも使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The new value is passed to the <bpt i="1" x="1">&lt;c1&gt;</bpt>willSet<ept i="1">&lt;/c1&gt;</ept> observer as a constant, and therefore it can’t be changed in the implementation of the <bpt i="2" x="2">&lt;c2&gt;</bpt>willSet<ept i="2">&lt;/c2&gt;</ept> clause.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい値は、定数として<bpt i="1" x="1">&lt;c1&gt;</bpt>willSet<ept i="1">&lt;/c1&gt;</ept>オブザーバーに渡されます、したがって、それ<bpt i="2" x="2">&lt;c2&gt;</bpt>はwillSet<ept i="2">&lt;/c2&gt;</ept>節の実装の中で変更されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next code snippet defines three variables of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Person?<ept i="0">&lt;/c0&gt;</ept>, which are used to set up multiple references to a new <bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept> instance in subsequent code snippets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次のコード断片は、型<bpt i="0" x="0">&lt;c0&gt;</bpt>Person?<ept i="0">&lt;/c0&gt;</ept>の３つの変数を定義します、それは、以降のコード断片の中のある１つの新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept>インスタンスへの複数の参照を準備するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next example creates a subclass of <bpt i="0" x="0">&lt;c0&gt;</bpt>Bicycle<ept i="0">&lt;/c0&gt;</ept> for a two-seater bicycle known as a “tandem”:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は、「タンデム」として知られる２座席自転車のために、<bpt i="0" x="0">&lt;c0&gt;</bpt>Bicycle<ept i="0">&lt;/c0&gt;</ept>のサブクラスを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next example defines a subclass of <bpt i="0" x="0">&lt;c0&gt;</bpt>Document<ept i="0">&lt;/c0&gt;</ept> called <bpt i="1" x="1">&lt;c1&gt;</bpt>AutomaticallyNamedDocument<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は、<bpt i="1" x="1">&lt;c1&gt;</bpt>AutomaticallyNamedDocument<ept i="1">&lt;/c1&gt;</ept>とよばれる<bpt i="0" x="0">&lt;c0&gt;</bpt>Document<ept i="0">&lt;/c0&gt;</ept>のサブクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next example defines a subclass of <bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept> called <bpt i="1" x="1">&lt;c1&gt;</bpt>Bicycle<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Bicycle<ept i="1">&lt;/c1&gt;</ept>と呼ばれる<bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept>のサブクラスを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next example defines two simple functions called <bpt i="0" x="0">&lt;c0&gt;</bpt>stepForward(_:)<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>stepBackward(_:)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>stepForward(_:)<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>stepBackward(_:)<ept i="1">&lt;/c1&gt;</ept>と呼ばれる２つの単純な関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next several code snippets demonstrate how optional chaining differs from forced unwrapping and enables you to check for success.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次のいくつかのコード切れっぱしは、どのようにオプショナル連鎖が強制アンラップと異なるか、そして成功をどのようにあなたが確認できるかを例示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next snippet defines two subclasses of <bpt i="0" x="0">&lt;c0&gt;</bpt>MediaItem<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の断片は、<bpt i="0" x="0">&lt;c0&gt;</bpt>MediaItem<ept i="0">&lt;/c0&gt;</ept>の２つのサブクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next subscript index to the right refers to the element at that index in the array that’s nested one level in.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の右の添え字インデックスは、１段階内側の入れ子にされた配列の中のそのインデックスでの要素に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The next three decimal <bpt i="7" x="7">&lt;c7&gt;</bpt>codeUnit<ept i="7">&lt;/c7&gt;</ept> values (<bpt i="8" x="8">&lt;c8&gt;</bpt>226<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>128<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>188<ept i="10">&lt;/c10&gt;</ept>) are a three-byte UTF-8 representation of the <bpt i="11" x="11">&lt;c11&gt;</bpt>DOUBLE EXCLAMATION MARK<ept i="11">&lt;/c11&gt;</ept> character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次の３つの10進の<bpt i="7" x="7">&lt;c7&gt;</bpt>codeUnit<ept i="7">&lt;/c7&gt;</ept>値（<bpt i="8" x="8">&lt;c8&gt;</bpt>226<ept i="8">&lt;/c8&gt;</ept>、<bpt i="9" x="9">&lt;c9&gt;</bpt>128<ept i="9">&lt;/c9&gt;</ept>、<bpt i="10" x="10">&lt;c10&gt;</bpt>188<ept i="10">&lt;/c10&gt;</ept>）は、<bpt i="11" x="11">&lt;c11&gt;</bpt>DOUBLE EXCLAMATION MARK<ept i="11">&lt;/c11&gt;</ept>文字の３バイトUTF-8叙述です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The nil-coalescing operator is shorthand for the code below:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>nil合体演算子は、以下のコードに対する簡略形です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The nil-coalescing operator provides a more elegant way to encapsulate this conditional checking and unwrapping in a concise and readable form.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>nil合体演算子は、この条件検査およびアンラップを簡潔で判読しやすい形式にカプセル化するより洗練された方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The notation used to describe the formal grammar of the Swift programming language follows a few conventions:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトプログラミング言語の形式文法を記述するために使用される表記法は、２、３の規則に従います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The observers are not called when the variable or property is first initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブザーバーは、変数またはプロパティが最初に初期化されるときには呼ばれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The only difference is the type of the values that they accept (<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>Double<ept i="5">&lt;/c5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>唯一の違いは、それらが受け入れる値の型（<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>Double<ept i="5">&lt;/c5&gt;</ept>）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The only exception is for required initializers (as defined in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Required Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>唯一の例外は、必須イニシャライザに対してです（<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>必須イニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で定義されるように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The only remaining strong reference to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Apartment<ept i="0">&lt;/c0&gt;</ept> instance is from the <bpt i="1" x="1">&lt;c1&gt;</bpt>unit4A<ept i="1">&lt;/c1&gt;</ept> variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Apartment<ept i="0">&lt;/c0&gt;</ept>インスタンスへの唯一の残っている強い参照は、<bpt i="1" x="1">&lt;c1&gt;</bpt>unit4A<ept i="1">&lt;/c1&gt;</ept>変数からです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The operator method is defined as a type method on <bpt i="0" x="0">&lt;c0&gt;</bpt>Vector2D<ept i="0">&lt;/c0&gt;</ept>, with a method name that matches the operator to be overloaded (<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算子メソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Vector2D<ept i="0">&lt;/c0&gt;</ept>上で型メソッドとして定義され、オーバーロードされる演算子と一致するメソッド名を持ちます（<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The operator returns a new number whose bits are set to <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept> if the bits are equal to <bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept> in <bpt i="4" x="4">&lt;e4&gt;</bpt>either<ept i="4">&lt;/e4&gt;</ept> input number:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算子は、<bpt i="4" x="4">&lt;e4&gt;</bpt>どちらかの<ept i="4">&lt;/e4&gt;</ept>入力数においてビットが<bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>と等しいならばビットが<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>に設定される、ある新しい数を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The operator returns a new number whose bits are set to <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept> where the input bits are different and are set to <bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept> where the input bits are the same:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算子は、入力ビットたちが異なっている所で<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>に設定され、入力ビットたちが同じである所で<bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>に設定される、ある新しい数を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The optimized behavior is known as <bpt i="0" x="0">&lt;e0&gt;</bpt>call by reference<ept i="0">&lt;/e0&gt;</ept>; it satisfies all of the requirements of the copy-in copy-out model while removing the overhead of copying.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この最適化挙動は、<bpt i="0" x="0">&lt;e0&gt;</bpt>参照呼び出し<ept i="0">&lt;/e0&gt;</ept>として知られます；それはコピーイン・コピーアウトモデルの要件の全てを満足させる一方でコピーすることのオーバーヘッド（間接的経費）を取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The optional <bpt i="8" x="8">&lt;c8&gt;</bpt>Int<ept i="8">&lt;/c8&gt;</ept> is accessed through optional binding to unwrap the integer and assign the nonoptional value to the <bpt i="9" x="9">&lt;c9&gt;</bpt>roomCount<ept i="9">&lt;/c9&gt;</ept> variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの<bpt i="8" x="8">&lt;c8&gt;</bpt>Int<ept i="8">&lt;/c8&gt;</ept>は、オプショナル束縛を通してアクセスされることで、整数をアンラップして取り出して、その非オプショナル値を<bpt i="9" x="9">&lt;c9&gt;</bpt>roomCount<ept i="9">&lt;/c9&gt;</ept>変数へ割り当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The optional <bpt i="0" x="0">&lt;e0&gt;</bpt>version number<ept i="0">&lt;/e0&gt;</ept> consists of one to three positive integers, separated by periods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>随意の<bpt i="0" x="0">&lt;e0&gt;</bpt>バージョン番号<ept i="0">&lt;/e0&gt;</ept>は、ビリオドで区切られた、１つから３つの正の整数から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The optional chaining question mark always follows immediately after the part of the expression that is optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖の疑問符は、常にオプショナルである式部分の直後に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The optional chaining question mark in this subscript call is placed immediately after <bpt i="0" x="0">&lt;c0&gt;</bpt>john.residence<ept i="0">&lt;/c0&gt;</ept>, before the subscript brackets, because <bpt i="1" x="1">&lt;c1&gt;</bpt>john.residence<ept i="1">&lt;/c1&gt;</ept> is the optional value on which optional chaining is being attempted.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この添え字呼び出しでのオプショナル連鎖の疑問符は、<bpt i="0" x="0">&lt;c0&gt;</bpt>john.residence<ept i="0">&lt;/c0&gt;</ept>の直後、添え字の角括弧の前に置かれます、なぜなら、<bpt i="1" x="1">&lt;c1&gt;</bpt>john.residence<ept i="1">&lt;/c1&gt;</ept>がオプショナル連鎖が試みられているオプショナルの値であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The optional lets you track whether there is currently a player in the game.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルは、プレーヤーが現在ゲーム中かどうかあなたに追跡させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The optional pattern provides a convenient way to iterate over an array of optional values in a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> statement, executing the body of the loop only for non-<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルパターンは、<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>文においてオプショナルの値がはいった配列の全体にわたって、ループの本文を非<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>の要素のみに実行して、繰り返すための便利な方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The order in which modifiers are specified when defining <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Custom Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> has changed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>あつらえの演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を定義する時に修飾子が指定される順番は変更されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The order of arguments in a function call must match the order of parameters in the function’s declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数呼び出しにおける引数の順序は、関数の宣言におけるパラメータの順番と一致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The original array is not modified by the <bpt i="2" x="2">&lt;c2&gt;</bpt>sorted(by:)<ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>元の配列は、<bpt i="2" x="2">&lt;c2&gt;</bpt>sorted(by:)<ept i="2">&lt;/c2&gt;</ept>メソッドによって修正されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The other difference between a generic function and a nongeneric function is that the generic function’s name (<bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoValues(_:_:)<ept i="0">&lt;/c0&gt;</ept>) is followed by the placeholder type name (<bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>) inside angle brackets (<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;T&gt;<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体関数と非総称体関数の間の他の違いは、総称体関数の名前（<bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoValues(_:_:)<ept i="0">&lt;/c0&gt;</ept>）は、後ろにプレースホルダ型名（<bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>）が山形括弧内部（<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;T&gt;<ept i="2">&lt;/c2&gt;</ept>）で続くということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The other variation of the <bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> loop, known as the <bpt i="1" x="1">&lt;c1&gt;</bpt>repeat<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept> loop, performs a single pass through the loop block first, <bpt i="3" x="3">&lt;e3&gt;</bpt>before<ept i="3">&lt;/e3&gt;</ept> considering the loop’s condition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>ループのもう一方の変種、<bpt i="1" x="1">&lt;c1&gt;</bpt>repeat<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>while<ept i="2">&lt;/c2&gt;</ept>ループとして知られるものは、ループの条件を考慮する<bpt i="3" x="3">&lt;e3&gt;</bpt>前<ept i="3">&lt;/e3&gt;</ept>に、最初に一度だけループ・ブロックの通り抜けを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The output constant (<bpt i="1" x="1">&lt;c1&gt;</bpt>twoThousandAndOne<ept i="1">&lt;/c1&gt;</ept>) is inferred to be of type <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt16<ept i="2">&lt;/c2&gt;</ept>, because it’s the sum of two <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt16<ept i="3">&lt;/c3&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>出力された定数（<bpt i="1" x="1">&lt;c1&gt;</bpt>twoThousandAndOne<ept i="1">&lt;/c1&gt;</ept>）は、型<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt16<ept i="2">&lt;/c2&gt;</ept>であると推測されます、それが２つの<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt16値<ept i="3">&lt;/c3&gt;</ept>の合計であるので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The output of the compound expression doesn’t change, but the overall intention is clearer to the reader.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複合式の出力は変わりません、しかし全体的な意図は読者にとってより明らかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The override of the <bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> property starts by calling <bpt i="1" x="1">&lt;c1&gt;</bpt>super.description<ept i="1">&lt;/c1&gt;</ept>, which returns the <bpt i="2" x="2">&lt;c2&gt;</bpt>Vehicle<ept i="2">&lt;/c2&gt;</ept> class’s <bpt i="3" x="3">&lt;c3&gt;</bpt>description<ept i="3">&lt;/c3&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept>プロパティのオーバーライドは、<bpt i="1" x="1">&lt;c1&gt;</bpt>super.description<ept i="1">&lt;/c1&gt;</ept>を呼び出すことで始まります、それは<bpt i="2" x="2">&lt;c2&gt;</bpt>Vehicle<ept i="2">&lt;/c2&gt;</ept>クラスの<bpt i="3" x="3">&lt;c3&gt;</bpt>description<ept i="3">&lt;/c3&gt;</ept>プロパティを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The parameter name is used in the implementation of the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータ名は、関数の実装内において使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The parentheses around a tuple pattern that contains a single element have no effect.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ただ１つだけの要素を含むタプルパターンのまわりの丸括弧には、効果がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The parentheses make it clear that the first two values are considered as part of a separate possible state in the overall logic.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>丸括弧は、最初の２つの値が全体的な論理の中で１つの隔てられたあり得る状態の部分として考慮されることを明白にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pattern matches values of that single element’s type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パターンは、そのただ１つの要素の型の値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The patterns can be written over multiple lines if the list is long.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのパターンは、そのリストが長いならば、複数行にわたって書かれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The phrase <bpt i="0" x="0">&lt;c0&gt;</bpt>if !allowedEntry<ept i="0">&lt;/c0&gt;</ept> can be read as “if not allowed entry.” The subsequent line is only executed if “not allowed entry” is true; that is, if <bpt i="1" x="1">&lt;c1&gt;</bpt>allowedEntry<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>語句<bpt i="0" x="0">&lt;c0&gt;</bpt>if !allowedEntry<ept i="0">&lt;/c0&gt;</ept>は、「許されたエントリでないならば」と読まれることができます。続く行は「許されたエントリでない」が真である場合；すなわち、<bpt i="1" x="1">&lt;c1&gt;</bpt>allowedEntry<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>である場合に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The phrase “of type <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>” means “can store any <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> value.” Think of it as meaning “the type of thing” (or “the kind of thing”) that can be stored.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>フレーズ「型<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>の」は、「どんな<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値でも保存することができる」ことを意味します。それを、保存されることができる「物の型」（または「物の種類」）の意味と思ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The placeholder type name doesn’t say anything about what <bpt i="6" x="6">&lt;c6&gt;</bpt>T<ept i="6">&lt;/c6&gt;</ept> must be, but it <bpt i="7" x="7">&lt;e7&gt;</bpt>does<ept i="7">&lt;/e7&gt;</ept> say that both <bpt i="8" x="8">&lt;c8&gt;</bpt>a<ept i="8">&lt;/c8&gt;</ept> and <bpt i="9" x="9">&lt;c9&gt;</bpt>b<ept i="9">&lt;/c9&gt;</ept> must be of the same type <bpt i="10" x="10">&lt;c10&gt;</bpt>T<ept i="10">&lt;/c10&gt;</ept>, whatever <bpt i="11" x="11">&lt;c11&gt;</bpt>T<ept i="11">&lt;/c11&gt;</ept> represents.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレースホルダ型名は<bpt i="6" x="6">&lt;c6&gt;</bpt>T<ept i="6">&lt;/c6&gt;</ept>が何でなければならないかについて何も言いません、しかし、<bpt i="8" x="8">&lt;c8&gt;</bpt>a<ept i="8">&lt;/c8&gt;</ept>と<bpt i="9" x="9">&lt;c9&gt;</bpt>b<ept i="9">&lt;/c9&gt;</ept>の両方ともが同じ型<bpt i="10" x="10">&lt;c10&gt;</bpt>T<ept i="10">&lt;/c10&gt;</ept>でなければならないと<bpt i="7" x="7">&lt;e7&gt;</bpt>述べます<ept i="7">&lt;/e7&gt;</ept>、<bpt i="11" x="11">&lt;c11&gt;</bpt>T<ept i="11">&lt;/c11&gt;</ept>が表わすものが何であれ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The player has now left the game.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレーヤーは、現在ゲームから離れました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The player moves forward by <bpt i="0" x="0">&lt;c0&gt;</bpt>diceRoll<ept i="0">&lt;/c0&gt;</ept> squares, and the game logic checks for any snakes and ladders.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレーヤーは<bpt i="0" x="0">&lt;c0&gt;</bpt>diceRoll<ept i="0">&lt;/c0&gt;</ept>分の正方形を前進します、そして、ゲーム論理はあらゆるヘビとはしごについて調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The player’s purse now contains 2,100 coins, and the bank has only 7,900 coins left.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレーヤーの財布は現在2,100個のコインを含みます、そして、胴元は7,900個のコインだけが残っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The player’s starting square is “square zero”, which is just off the bottom-left corner of the board.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プレーヤーの出発する正方形は「正方形ゼロ」です、それは、盤の左下の角からちょっと離れています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The point (0, 0) would match <bpt i="2" x="2">&lt;c2&gt;</bpt>case (0, 0)<ept i="2">&lt;/c2&gt;</ept> first, and so all other matching cases would be ignored.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>点(0, 0)は最初の<bpt i="2" x="2">&lt;c2&gt;</bpt>case (0, 0)<ept i="2">&lt;/c2&gt;</ept>に合います、それで他の適合するケース節すべては無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The postfix <bpt i="0" x="0">&lt;c0&gt;</bpt>?<ept i="0">&lt;/c0&gt;</ept> operator makes an optional-chaining expression from an expression without changing the expression’s value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>接尾辞<bpt i="0" x="0">&lt;c0&gt;</bpt>?<ept i="0">&lt;/c0&gt;</ept>演算子は、オプショナル連鎖式をある式から、その式の値を変更することなく作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The precedence of an operator specifies how tightly the operator binds to its operands, in the absence of grouping parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある演算子の優先順位は、どのくらいきつくその演算子をそれの演算数に束縛するかを、グループ化の丸括弧がないところで指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The preceding example creates a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Matrix<ept i="0">&lt;/c0&gt;</ept> instance with two rows and two columns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前の例は、２つの行と２つの列で新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Matrix<ept i="0">&lt;/c0&gt;</ept>インスタンスをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The preceding example creates a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept> variable called <bpt i="1" x="1">&lt;c1&gt;</bpt>square<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前の例は、<bpt i="1" x="1">&lt;c1&gt;</bpt>square<ept i="1">&lt;/c1&gt;</ept>と呼ばれる新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept>変数をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The preceding example determines whether a positive or negative step is needed to move a variable called <bpt i="0" x="0">&lt;c0&gt;</bpt>currentValue<ept i="0">&lt;/c0&gt;</ept> progressively closer to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>currentValue<ept i="0">&lt;/c0&gt;</ept>と呼ばれる変数を次第にゼロにより近く動かすために正と負の一歩のどちらが必要とされるかを確定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The preceding example is shorthand for the code below:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前の例は、下のコードの短縮形です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The present section describes which characters can be used to define custom operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この前の節は、どの文字があつらえの演算子を定義するために使用できるかを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The previous example shows how to retrieve the value of a property of optional type through optional chaining.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前の例は、オプショナル連鎖を通してオプショナルの型のプロパティの値を取り出す方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The primary use of implicitly unwrapped optionals in Swift is during class initialization, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Unowned References and Implicitly Unwrapped Optional Properties<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでの暗黙的にアンラップされるオプショナルの主要な利用法は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>非所有参照と暗黙的にアンラップされるオプショナルのプロパティ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、クラス初期化の間にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The principle of finding the index of a value in an array isn’t useful only for strings, however.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、配列の中の値のインデックスを見つける原理は、文字列のためにだけ役立つわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The problem lies with the equality check, “<bpt i="0" x="0">&lt;c0&gt;</bpt>if value == valueToFind<ept i="0">&lt;/c0&gt;</ept>”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>問題は、同等性検査<bpt i="0" x="0">&lt;c0&gt;</bpt>if value == valueToFind<ept i="0">&lt;/c0&gt;</ept>に横たわります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The process is repeated until <bpt i="0" x="0">&lt;c0&gt;</bpt>number<ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>, at which point the <bpt i="2" x="2">&lt;c2&gt;</bpt>output<ept i="2">&lt;/c2&gt;</ept> string is returned by the closure, and is added to the output array by the <bpt i="3" x="3">&lt;c3&gt;</bpt>map(_:)<ept i="3">&lt;/c3&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この処理は<bpt i="0" x="0">&lt;c0&gt;</bpt>number<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>に等しくなるまで繰り返されます、その時点で<bpt i="2" x="2">&lt;c2&gt;</bpt>output<ept i="2">&lt;/c2&gt;</ept>文字列がクロージャによって返されて、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>map(_:)<ept i="3">&lt;/c3&gt;</ept>メソッドによって出力配列に加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The process of defining your own implementations of the “equal to” and “not equal to” operators is described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Equivalence Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「同等」および「不等」演算子のあなた独自の実施を定義する過程は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>同等演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The process of initializing a structure’s declared properties is described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Initialization<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある構造体の宣言されたプロパティを初期化する過程は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>初期化<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The program begins executing a loop by calling the <bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept> method on the iterator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プログラムは、そのイテレータ上で<bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept>メソッドを呼ぶことによってループの実行を始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The program executes the <bpt i="0" x="0">&lt;e0&gt;</bpt>statements<ept i="0">&lt;/e0&gt;</ept>, and execution continues to step 2.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プログラムが<bpt i="0" x="0">&lt;e0&gt;</bpt>文<ept i="0">&lt;/e0&gt;</ept>を実行します、そして実行はステップ２に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The program executes the <bpt i="0" x="0">&lt;e0&gt;</bpt>statements<ept i="0">&lt;/e0&gt;</ept>, and execution returns to step 1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プログラムは<bpt i="0" x="0">&lt;e0&gt;</bpt>文<ept i="0">&lt;/e0&gt;</ept>を実行します、そして実行はステップ１に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The protocol also specifies whether each property must be gettable or gettable <bpt i="0" x="0">&lt;e0&gt;</bpt>and<ept i="0">&lt;/e0&gt;</ept> settable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルはまた、各プロパティが取得可能または取得可能<bpt i="0" x="0">&lt;e0&gt;</bpt>かつまた<ept i="0">&lt;/e0&gt;</ept>設定可能でなければならないかどうか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The protocol can then be <bpt i="1" x="1">&lt;e1&gt;</bpt>adopted<ept i="1">&lt;/e1&gt;</ept> by a class, structure, or enumeration to provide an actual implementation of those requirements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのプロトコルは、それから、クラス、構造体、または列挙によって<bpt i="1" x="1">&lt;e1&gt;</bpt>採用される<ept i="1">&lt;/e1&gt;</ept>ことで、それらの要件の実際の実装を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The protocol doesn’t define what <bpt i="3" x="3">&lt;c3&gt;</bpt>Item<ept i="3">&lt;/c3&gt;</ept> is—that information is left for any conforming type to provide.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロトコルは、<bpt i="3" x="3">&lt;c3&gt;</bpt>Item<ept i="3">&lt;/c3&gt;</ept>が何であるかを定義しません ― その情報は、何であれそれに準拠する型が提供するようにそのままにされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The protocol doesn’t specify anything else about the nature of the conforming type—it only specifies that the type must be able to provide a full name for itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロトコルは、その準拠型の性質について何ら指定しません ― それはただその型がそれ自身のフルネームを提供できなければならないことだけを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The protocol doesn’t specify whether the property should be a stored property or a computed property—it only specifies the required property name and type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは、そのプロパティが保存プロパティまたは計算プロパティでなければならないかどうかは指定しません ― それは、必要なプロパティ名と型を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The protocol name is provided after the type name, separated by a colon, and an implementation of all requirements of the protocol is provided within the extension’s curly braces.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル名は、型名の後にコロンで区切られて提供されます、そして、プロトコルの全ての要件の実装は、拡張の波括弧内で提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The protocol only specifies the three bits of functionality that any type must provide in order to be considered a <bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは、どんな型でも<bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept>とみなされるためには提供しなければならない小さな３つの機能性を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The protocol states that any <bpt i="1" x="1">&lt;c1&gt;</bpt>FullyNamed<ept i="1">&lt;/c1&gt;</ept> type must have a gettable instance property called <bpt i="2" x="2">&lt;c2&gt;</bpt>fullName<ept i="2">&lt;/c2&gt;</ept>, which is of type <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロトコルは、あらゆる<bpt i="1" x="1">&lt;c1&gt;</bpt>FullyNamed<ept i="1">&lt;/c1&gt;</ept>型は<bpt i="2" x="2">&lt;c2&gt;</bpt>fullName<ept i="2">&lt;/c2&gt;</ept>と呼ばれる、<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>型である、取得可能なインスタンスプロパティを持たなければならないことを述べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The question mark indicates that the value it contains is optional, meaning that it might contain <bpt i="6" x="6">&lt;e6&gt;</bpt>some<ept i="6">&lt;/e6&gt;</ept> <bpt i="7" x="7">&lt;c7&gt;</bpt>Int<ept i="7">&lt;/c7&gt;</ept> value, or it might contain <bpt i="8" x="8">&lt;e8&gt;</bpt>no value at all<ept i="8">&lt;/e8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>疑問符はそれが含む値がオプショナルであることを示します、そしてそれが<bpt i="6" x="6">&lt;e6&gt;</bpt>何かの<ept i="6">&lt;/e6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>Int<ept i="7">&lt;/c7&gt;</ept>値を含むかもしれない、あるいはそれが<bpt i="8" x="8">&lt;e8&gt;</bpt>まったく値を含まない<ept i="8">&lt;/e8&gt;</ept>かもしれないことを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The range of numbers that can be stored in an integer constant or variable is different for each numeric type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>整数の定数または変数に保存されることができる数の範囲は、それぞれの数の型で異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The raw value for a particular enumeration case is always the same.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特定の列挙ケース節のための生の値は、常に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The raw value initializer is a failable initializer, because not every raw value will return an enumeration case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生の値のイニシャライザは、失敗できるイニシャライザです、なぜなら、すべての生の値が列挙ケース節を返すわけではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The red component is obtained by performing a bitwise AND between the numbers <bpt i="0" x="0">&lt;c0&gt;</bpt>0xCC6699<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>0xFF0000<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>赤の構成要素は、数<bpt i="0" x="0">&lt;c0&gt;</bpt>0xCC6699<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>0xFF0000<ept i="1">&lt;/c1&gt;</ept>との間のビット単位の論理積を実行することによって得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The reference is called a “strong” reference because it keeps a firm hold on that instance, and does not allow it to be deallocated for as long as that strong reference remains.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この参照が「強い」参照と呼ばれるのはそれがそのインスタンスに対する堅い支配力を保つからです、そしてその強い参照が残る限りは、そのインスタンスがメモリ割り当て解除されるのを許しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The relationship between <bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept> is slightly different from the relationship between <bpt i="2" x="2">&lt;c2&gt;</bpt>Apartment<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Person<ept i="3">&lt;/c3&gt;</ept> seen in the weak reference example above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept>の関係は、上の弱い参照の例で見られる<bpt i="2" x="2">&lt;c2&gt;</bpt>Apartment<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>Person<ept i="3">&lt;/c3&gt;</ept>の関係と少しばかり異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The remainder is treated the same way and may be split again.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>剰余は、同じ方法で扱われて、そして再び分割されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The remainder operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>%<ept i="0">&lt;/c0&gt;</ept>) is also known as a <bpt i="1" x="1">&lt;e1&gt;</bpt>modulo operator<ept i="1">&lt;/e1&gt;</ept> in other languages.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>剰余演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>%<ept i="0">&lt;/c0&gt;</ept>）は、また、他の言語では<bpt i="1" x="1">&lt;e1&gt;</bpt>モジュロ演算子<ept i="1">&lt;/e1&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The remaining arguments can appear in any order and specify additional information about the declaration’s lifecycle, including important milestones.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのままの引数は、任意の順番で現れることができます、そして重要なマイルストーンを含む、その宣言のライフサイクルについての追加の情報を指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The remaining bits (known as the <bpt i="0" x="0">&lt;e0&gt;</bpt>value bits<ept i="0">&lt;/e0&gt;</ept>) store the actual value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>残っているビット（<bpt i="0" x="0">&lt;e0&gt;</bpt>値ビット<ept i="0">&lt;/e0&gt;</ept>として知られるもの）は、実際の値を保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The response to a survey question cannot be known until it is asked, and so the <bpt i="0" x="0">&lt;c0&gt;</bpt>response<ept i="0">&lt;/c0&gt;</ept> property is declared with a type of <bpt i="1" x="1">&lt;c1&gt;</bpt>String?<ept i="1">&lt;/c1&gt;</ept>, or “optional <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>意識調査への回答は、それが尋ねられるまでは知られることができません、なので<bpt i="0" x="0">&lt;c0&gt;</bpt>response<ept i="0">&lt;/c0&gt;</ept>プロパティは<bpt i="1" x="1">&lt;c1&gt;</bpt>String?<ept i="1">&lt;/c1&gt;</ept>の型、すなわち「オプショナルの<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>」を使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result is a sequence of <bpt i="6" x="6">&lt;c6&gt;</bpt>diceRoll<ept i="6">&lt;/c6&gt;</ept> values that is always <bpt i="7" x="7">&lt;c7&gt;</bpt>1<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>2<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>3<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>4<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>5<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>6<ept i="12">&lt;/c12&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt>1<ept i="13">&lt;/c13&gt;</ept>, <bpt i="14" x="14">&lt;c14&gt;</bpt>2<ept i="14">&lt;/c14&gt;</ept> and so on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果は一連の<bpt i="6" x="6">&lt;c6&gt;</bpt>diceRoll<ept i="6">&lt;/c6&gt;</ept>値で、それは常に<bpt i="7" x="7">&lt;c7&gt;</bpt>1<ept i="7">&lt;/c7&gt;</ept>、<bpt i="8" x="8">&lt;c8&gt;</bpt>2<ept i="8">&lt;/c8&gt;</ept>、<bpt i="9" x="9">&lt;c9&gt;</bpt>3<ept i="9">&lt;/c9&gt;</ept>、<bpt i="10" x="10">&lt;c10&gt;</bpt>4<ept i="10">&lt;/c10&gt;</ept>、<bpt i="11" x="11">&lt;c11&gt;</bpt>5<ept i="11">&lt;/c11&gt;</ept>、<bpt i="12" x="12">&lt;c12&gt;</bpt>6<ept i="12">&lt;/c12&gt;</ept>、<bpt i="13" x="13">&lt;c13&gt;</bpt>1<ept i="13">&lt;/c13&gt;</ept>、<bpt i="14" x="14">&lt;c14&gt;</bpt>2<ept i="14">&lt;/c14&gt;</ept>など、となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result is a specialized version of that generic type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果は、その総称体型の特殊化版です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result is exactly the same as if you place an exclamation mark after a normal optional that doesn’t contain a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その結果は、あなたが値を含まない通常のオプショナルの後に感嘆符を置いた場合と正確に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result of <bpt i="10" x="10">&lt;c10&gt;</bpt>item as? Movie<ept i="10">&lt;/c10&gt;</ept> is of type <bpt i="11" x="11">&lt;c11&gt;</bpt>Movie?<ept i="11">&lt;/c11&gt;</ept>, or “optional <bpt i="12" x="12">&lt;c12&gt;</bpt>Movie<ept i="12">&lt;/c12&gt;</ept>”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="10" x="10">&lt;c10&gt;</bpt>item as? Movie<ept i="10">&lt;/c10&gt;</ept>の結果は、<bpt i="11" x="11">&lt;c11&gt;</bpt>Movie?<ept i="11">&lt;/c11&gt;</ept>型、すなわち「オプショナルの<bpt i="12" x="12">&lt;c12&gt;</bpt>Movie<ept i="12">&lt;/c12&gt;</ept>」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The result of the <bpt i="0" x="0">&lt;c0&gt;</bpt>i == 1<ept i="0">&lt;/c0&gt;</ept> comparison is of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept>, and so this second example passes the type-check.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i == 1<ept i="0">&lt;/c0&gt;</ept>の比較の結果は型<bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept>です、それでこの第二の例は型チェックを通ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return type of <bpt i="0" x="0">&lt;c0&gt;</bpt>makeIncrementer<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>() -&gt; Int<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>makeIncrementer<ept i="0">&lt;/c0&gt;</ept>の戻り型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>() -&gt; Intで<ept i="1">&lt;/c1&gt;</ept>す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return value of <bpt i="2" x="2">&lt;c2&gt;</bpt>john.residence?.address?.street<ept i="2">&lt;/c2&gt;</ept> is therefore also <bpt i="3" x="3">&lt;c3&gt;</bpt>String?<ept i="3">&lt;/c3&gt;</ept>, even though two levels of optional chaining are applied in addition to the underlying optional type of the property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>john.residence?.address?.street<ept i="2">&lt;/c2&gt;</ept>の戻り値は、したがってまた、<bpt i="3" x="3">&lt;c3&gt;</bpt>String?<ept i="3">&lt;/c3&gt;</ept>です、その下のプロパティのオプショナル型に加えて２つのオプショナル連鎖の階層が適用されるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The return value of a function can be ignored when it is called:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数の戻り値は、それが呼ばれるとき無視されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The returned array value is stored in <bpt i="3" x="3">&lt;c3&gt;</bpt>boardColors<ept i="3">&lt;/c3&gt;</ept> and can be queried with the <bpt i="4" x="4">&lt;c4&gt;</bpt>squareIsBlackAt(row:column:)<ept i="4">&lt;/c4&gt;</ept> utility function:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>返された配列値は、<bpt i="3" x="3">&lt;c3&gt;</bpt>boardColors<ept i="3">&lt;/c3&gt;</ept>に保存されて、便利な支援関数の<bpt i="4" x="4">&lt;c4&gt;</bpt>squareIsBlackAt(row:column:)<ept i="4">&lt;/c4&gt;</ept>で問い合わされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The role of <bpt i="0" x="0">&lt;c0&gt;</bpt>printMathResult(_:_:_:)<ept i="0">&lt;/c0&gt;</ept> is to print the result of a call to a math function of an appropriate type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>printMathResult(_:_:_:)<ept i="0">&lt;/c0&gt;</ept>の役割は、適切な型の数学関数に対する呼び出しの結果を出力することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The row height should be 50 points taller than the content height if the row has a header, and 20 points taller if the row doesn’t have a header:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列の高さは、列にヘッダがあるならば内容の高さより50ポイント高く、列にヘッダがないならば20ポイント高くなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The rules for combining numeric constants and variables are different from the rules for numeric literals.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数の定数や変数を結合することに対する規則は、数のリテラルに対する規則と異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The rules for how initializer delegation works, and for what forms of delegation are allowed, are different for value types and class types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのようにイニシャライザ委任が働くか、そしてどんな委任の形式が許されるかの規則は、値型とクラス型で異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The rules of the game are as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゲームの規則は、次の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The rules only affect how you write the implementation of the class’s initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの規則は、あなたがクラスのイニシャライザの実装を書く方法に影響を及ぼすだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The same behavior applies to enumerations:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じ挙動は、列挙にもあてはまります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The same is not true for classes, which are <bpt i="0" x="0">&lt;e0&gt;</bpt>reference types<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じことはクラスにはあてはまりません、それは<bpt i="0" x="0">&lt;e0&gt;</bpt>参照型<ept i="0">&lt;/e0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The same is true for method parameters, because methods are just functions that are associated with a type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じことはメソッドパラメータにもあてはまります、なぜならメソッドは、あるひとつの型に結び付けられた単なる関数だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The same is true if you attempt to set a property through optional chaining.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じことは、あなたがプロパティをオプショナル連鎖を通して設定しようと試みる場合にも当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The same method is applied when calculating the remainder for a negative value of <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じメソッドが、負の値の<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>のための余りを計算するとき適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The same product can be assigned a different type of barcode:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じ製品は、異なる型のバーコードを代入されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The same value can appear in an array multiple times at different positions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じ値は、ひとつの配列の中で複数回異なる位置で現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The scope of a labeled statement is the entire statement following the statement label.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ラベルをつけられた文のスコープは、文ラベルに続いている文全体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The scope of each case can’t be empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれのケース節のスコープは、空であることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second <bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept> initializer, <bpt i="1" x="1">&lt;c1&gt;</bpt>init(origin:size:)<ept i="1">&lt;/c1&gt;</ept>, is functionally the same as the memberwise initializer that the structure would have received if it did not have its own custom initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第２の<bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept>イニシャライザ、<bpt i="1" x="1">&lt;c1&gt;</bpt>init(origin:size:)<ept i="1">&lt;/c1&gt;</ept>は、構造体が独自のあつらえのイニシャライザを持たない場合に受け取る省略時のメンバー関連イニシャライザと機能的に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second and third parameters are called <bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>b<ept i="4">&lt;/c4&gt;</ept>, and are both of type <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２番目と３番目のパラメータは<bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>b<ept i="4">&lt;/c4&gt;</ept>と呼ばれます、そして両方とも<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second block is then closed, followed by the first block:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第二のブロックはそれから閉じられます、そして最初のブロックが続きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second class in the hierarchy is a subclass of <bpt i="0" x="0">&lt;c0&gt;</bpt>Food<ept i="0">&lt;/c0&gt;</ept> called <bpt i="1" x="1">&lt;c1&gt;</bpt>RecipeIngredient<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この階層構造における第二のクラスは、<bpt i="1" x="1">&lt;c1&gt;</bpt>RecipeIngredient<ept i="1">&lt;/c1&gt;</ept>と呼ばれる<bpt i="0" x="0">&lt;c0&gt;</bpt>Food<ept i="0">&lt;/c0&gt;</ept>のサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second form evaluates to the value of the <bpt i="0" x="0">&lt;e0&gt;</bpt>type<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第二の形式は、<bpt i="0" x="0">&lt;e0&gt;</bpt>型<ept i="0">&lt;/e0&gt;</ept>の値に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second form is used to access the superclass’s subscript implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第２の形式は、スーパークラスの添え字実装にアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second form of a line control statement, <bpt i="0" x="0">&lt;c0&gt;</bpt>#sourceLocation()<ept i="0">&lt;/c0&gt;</ept>, resets the source code location back to the default line numbering and filename.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２番目の形式の行制御文、<bpt i="0" x="0">&lt;c0&gt;</bpt>#sourceLocation()<ept i="0">&lt;/c0&gt;</ept>はソースコード位置を再設定して、初期状態の行番号振りとファイル名に戻します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second form of an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement provides an additional <bpt i="1" x="1">&lt;e1&gt;</bpt>else clause<ept i="1">&lt;/e1&gt;</ept> (introduced by the <bpt i="2" x="2">&lt;c2&gt;</bpt>else<ept i="2">&lt;/c2&gt;</ept> keyword) and is used for executing one part of code when the condition is true and another part of code when the same condition is false.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文の２番目の形式は、追加の<bpt i="1" x="1">&lt;e1&gt;</bpt>else節<ept i="1">&lt;/e1&gt;</ept>（代わりの節）を提供します（<bpt i="2" x="2">&lt;c2&gt;</bpt>else<ept i="2">&lt;/c2&gt;</ept>キーワードで導入されます）、そして条件が真である場合はあるコード部分を、そして同じ条件が偽である場合は別のコード部分を実行するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second function, <bpt i="2" x="2">&lt;c2&gt;</bpt>printWithoutCounting(string:)<ept i="2">&lt;/c2&gt;</ept>, calls the first function, but ignores its return value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第二の関数、<bpt i="2" x="2">&lt;c2&gt;</bpt>printWithoutCounting(string:)<ept i="2">&lt;/c2&gt;</ept>は、最初の関数を呼びます、しかしその戻り値を無視します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second initializer has a single initialization parameter with an argument label of <bpt i="2" x="2">&lt;c2&gt;</bpt>fromKelvin<ept i="2">&lt;/c2&gt;</ept> and a parameter name of <bpt i="3" x="3">&lt;c3&gt;</bpt>kelvin<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第二のイニシャライザは、<bpt i="2" x="2">&lt;c2&gt;</bpt>fromKelvin<ept i="2">&lt;/c2&gt;</ept>の引数ラベルと<bpt i="3" x="3">&lt;c3&gt;</bpt>kelvin<ept i="3">&lt;/c3&gt;</ept>のパラメータ名を使うただ１つの初期化パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second is a convenience type function called <bpt i="4" x="4">&lt;c4&gt;</bpt>isUnlocked(_:)<ept i="4">&lt;/c4&gt;</ept>, which returns <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept> if a particular level number is already unlocked.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第二は、<bpt i="4" x="4">&lt;c4&gt;</bpt>isUnlocked(_:)<ept i="4">&lt;/c4&gt;</ept>と呼ばれる便利な型関数です、それは、特定のレベル番号がすでに錠を開けられるならば、<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second kind of pattern is used for full pattern matching, where the values you’re trying to match against may not be there at runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>2番目の種類のパターンは、完全なパターンマッチングのために使われます、そこにおいてあなたがマッチを試みている対象である値は実行時にそこにないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second pair has a key of <bpt i="3" x="3">&lt;c3&gt;</bpt>"DUB"<ept i="3">&lt;/c3&gt;</ept> and a value of <bpt i="4" x="4">&lt;c4&gt;</bpt>"Dublin"<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２番目の組みは、<bpt i="3" x="3">&lt;c3&gt;</bpt>"DUB"<ept i="3">&lt;/c3&gt;</ept>のキーと<bpt i="4" x="4">&lt;c4&gt;</bpt>"Dublin"<ept i="4">&lt;/c4&gt;</ept>の値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second subclass, <bpt i="4" x="4">&lt;c4&gt;</bpt>Song<ept i="4">&lt;/c4&gt;</ept>, adds an <bpt i="5" x="5">&lt;c5&gt;</bpt>artist<ept i="5">&lt;/c5&gt;</ept> property and initializer on top of the base class:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第二のサブクラス<bpt i="4" x="4">&lt;c4&gt;</bpt>Song<ept i="4">&lt;/c4&gt;</ept>は、基盤クラスの上に<bpt i="5" x="5">&lt;c5&gt;</bpt>artist<ept i="5">&lt;/c5&gt;</ept>プロパティとイニシャライザを加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second type parameter, <bpt i="3" x="3">&lt;c3&gt;</bpt>U<ept i="3">&lt;/c3&gt;</ept>, has a type constraint that requires <bpt i="4" x="4">&lt;c4&gt;</bpt>U<ept i="4">&lt;/c4&gt;</ept> to conform to the protocol <bpt i="5" x="5">&lt;c5&gt;</bpt>SomeProtocol<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２番目の型パラメータ<bpt i="3" x="3">&lt;c3&gt;</bpt>U<ept i="3">&lt;/c3&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt>U<ept i="4">&lt;/c4&gt;</ept>にプロトコル<bpt i="5" x="5">&lt;c5&gt;</bpt>SomeProtocol<ept i="5">&lt;/c5&gt;</ept>に準拠することを要求する型制約を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second type property is a variable stored property called <bpt i="0" x="0">&lt;c0&gt;</bpt>maxInputLevelForAllChannels<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第二の型プロパティは、<bpt i="0" x="0">&lt;c0&gt;</bpt>maxInputLevelForAllChannels<ept i="0">&lt;/c0&gt;</ept>と呼ばれる変数保存プロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The self Property</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>selfプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sequence being iterated over is a range of numbers from <bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>5<ept i="1">&lt;/c1&gt;</ept>, inclusive, as indicated by the use of the closed range operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>...<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それに対して繰り返しを行われている連続物（シーケンス）は、完結範囲演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>...<ept i="2">&lt;/c2&gt;</ept>）の使用によって示されるように、<bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>から<bpt i="1" x="1">&lt;c1&gt;</bpt>5<ept i="1">&lt;/c1&gt;</ept>までを含める数からなる範囲です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The server either responds with the requested information, or it responds with a description of what went wrong.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのサーバーは要請された情報で応答するか、またはそれは何がうまくいかなかったかの説明で応答するかのどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The setter clause is optional, and when only a getter is needed, you can omit both clauses and simply return the requested value directly, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Read-Only Computed Properties<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>セッター節は任意です、そして、ゲッターだけが必要なとき、あなたは両方の節を省略することができます、そして<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>読み出し専用の計算プロパティ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、単に直接に要請された値を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The setter clause is optional, and when only a getter is needed, you can omit both clauses and simply return the requested value directly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>セッター節は任意です、そしてゲッターだけが必要なとき、あなたは両方の節を省略して、単に直接要請された値を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The shifting behavior is more complex for signed integers than for unsigned integers, because of the way signed integers are represented in binary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シフト挙動は、符号つき整数では符号なし整数よりももっと複雑です、なぜなら、符号つき整数が２進数において表される方法のためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The shorthand syntax for <bpt i="0" x="0">&lt;c0&gt;</bpt>available<ept i="0">&lt;/c0&gt;</ept> attributes allows for availability for multiple platforms to be expressed concisely.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>available<ept i="0">&lt;/c0&gt;</ept>属性のための略記構文は、複数のプラットホームに対する有効性を許可して簡略に表されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sign bit is <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept> (meaning “positive”), and the seven value bits are just the number <bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept>, written in binary notation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号ビットは<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>です（「正」を意味します）、そして７つの値ビットはちょうど、２進数表記法で書かれる数<bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sign of <bpt i="0" x="0">&lt;c0&gt;</bpt>b<ept i="0">&lt;/c0&gt;</ept> is ignored for negative values of <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>b<ept i="0">&lt;/c0&gt;</ept>の符号は、負の値の<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>のために無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sign of a numeric value can be toggled using a prefixed <bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>, known as the <bpt i="1" x="1">&lt;e1&gt;</bpt>unary minus operator<ept i="1">&lt;/e1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数の値の符号は、<bpt i="1" x="1">&lt;e1&gt;</bpt>単項マイナス演算子<ept i="1">&lt;/e1&gt;</ept>として知られる、接頭辞<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>を使うことによって切り換えられることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The simplest entry in a parameter list has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パラメータ・リストの中の最も単純な項目は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The simplest form of initializer syntax uses the type name of the class or structure followed by empty parentheses, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>Resolution()<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>VideoMode()<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ構文の最も単純な形式は、クラスまたは構造体の型名を使用して、それに空の丸括弧を続けます、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>Resolution()<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>VideoMode()<ept i="1">&lt;/c1&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The single type parameter for <bpt i="0" x="0">&lt;c0&gt;</bpt>findIndex(of:in:)<ept i="0">&lt;/c0&gt;</ept> is written as <bpt i="1" x="1">&lt;c1&gt;</bpt>T: Equatable<ept i="1">&lt;/c1&gt;</ept>, which means “any type <bpt i="2" x="2">&lt;c2&gt;</bpt>T<ept i="2">&lt;/c2&gt;</ept> that conforms to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept> protocol.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>findIndex(of:in:)<ept i="0">&lt;/c0&gt;</ept>のただ一つの型パラメータは、<bpt i="1" x="1">&lt;c1&gt;</bpt>T: Equatable<ept i="1">&lt;/c1&gt;</ept>として書かれます、それは、「<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠するあらゆる型<bpt i="3" x="3">&lt;c3&gt;</bpt>T<ept i="3">&lt;/c3&gt;</ept>」を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The size of a geometric shape, perhaps encapsulating a <bpt i="0" x="0">&lt;c0&gt;</bpt>width<ept i="0">&lt;/c0&gt;</ept> property and a <bpt i="1" x="1">&lt;c1&gt;</bpt>height<ept i="1">&lt;/c1&gt;</ept> property, both of type <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>幾何学図形のサイズ、おそらくは<bpt i="0" x="0">&lt;c0&gt;</bpt>width<ept i="0">&lt;/c0&gt;</ept>プロパティと<bpt i="1" x="1">&lt;c1&gt;</bpt>height<ept i="1">&lt;/c1&gt;</ept>プロパティ（両方とも<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>型）をカプセル化する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The sorting closure needs to return <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept> if the first value should appear <bpt i="3" x="3">&lt;e3&gt;</bpt>before<ept i="3">&lt;/e3&gt;</ept> the second value, and <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このソートを行うクロージャは、最初の値が第２の値の<bpt i="3" x="3">&lt;e3&gt;</bpt>前に<ept i="3">&lt;/e3&gt;</ept>現れるべきならば<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>を、そうでないならば<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>を返す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The specialized version of the generic <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> type, <bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary&lt;String, Int&gt;<ept i="1">&lt;/c1&gt;</ept> is formed by replacing the generic parameters <bpt i="2" x="2">&lt;c2&gt;</bpt>Key: Hashable<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Value<ept i="3">&lt;/c3&gt;</ept> with the concrete type arguments <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>型の特殊化版、<bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary&lt;String, Int&gt;<ept i="1">&lt;/c1&gt;</ept>は、総称体パラメータ<bpt i="2" x="2">&lt;c2&gt;</bpt>Key: Hashable<ept i="2">&lt;/c2&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt>Value<ept i="3">&lt;/c3&gt;</ept>を具体的な型引数<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>および<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>と置き換えて作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The specific implications of this guiding principle for different aspects of the language are covered in detail below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この言語の異なる面に対する、この原理指針の特定の影響は、詳細に下で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The stack now holds four values, with the most recent one at the top.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スタックは現在は４つの値を持ちます、最も最近のものは一番上にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The start of the closure’s body is introduced by the <bpt i="0" x="0">&lt;c0&gt;</bpt>in<ept i="0">&lt;/c0&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャのもつ本文の始まりは、<bpt i="0" x="0">&lt;c0&gt;</bpt>in<ept i="0">&lt;/c0&gt;</ept>キーワードで紹介されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The statement <bpt i="1" x="1">&lt;c1&gt;</bpt>if let somePlanet = Planet(rawValue: 11)<ept i="1">&lt;/c1&gt;</ept> creates an optional <bpt i="2" x="2">&lt;c2&gt;</bpt>Planet<ept i="2">&lt;/c2&gt;</ept>, and sets <bpt i="3" x="3">&lt;c3&gt;</bpt>somePlanet<ept i="3">&lt;/c3&gt;</ept> to the value of that optional <bpt i="4" x="4">&lt;c4&gt;</bpt>Planet<ept i="4">&lt;/c4&gt;</ept> if it can be retrieved.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文<bpt i="1" x="1">&lt;c1&gt;</bpt>if let somePlanet = Planet(rawValue: 11)<ept i="1">&lt;/c1&gt;</ept>は、オプショナルの<bpt i="2" x="2">&lt;c2&gt;</bpt>Planet<ept i="2">&lt;/c2&gt;</ept>を作成して、それが取り出されることができるならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>somePlanet<ept i="3">&lt;/c3&gt;</ept>をそのオプショナルの<bpt i="4" x="4">&lt;c4&gt;</bpt>Planet<ept i="4">&lt;/c4&gt;</ept>のもつ値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The statements in the <bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept> statement can’t transfer program control outside of the <bpt i="1" x="1">&lt;c1&gt;</bpt>defer<ept i="1">&lt;/c1&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept>文の中の文は、プログラムの制御を<bpt i="1" x="1">&lt;c1&gt;</bpt>defer<ept i="1">&lt;/c1&gt;</ept>文の外側に移すことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The statements within the <bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept> statement are executed no matter how program control is transferred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept>文内の文は、どのようにプログラム制御が移されようと関係なく実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The static method is a member of one of the types whose values the operator takes as an argument—for example, an operator that multiplies a <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> by an <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> is implemented as a static method on either the <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この静的メソッドは、その演算子が引数としてとる値の型のうちの１つに属するあるメンバーです、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>に<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>を掛ける演算子は静的メソッドとして<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> 構造体のどちらかで実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The stored or computed nature of an inherited property is not known by a subclass—it only knows that the inherited property has a certain name and type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>継承されたプロパティの保存または計算の種別は、サブクラスには知られません ― それは、継承されたプロパティが特定の名前と型を持つということを知っているだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string <bpt i="3" x="3">&lt;c3&gt;</bpt>"123"<ept i="3">&lt;/c3&gt;</ept> can be converted into the numeric value <bpt i="4" x="4">&lt;c4&gt;</bpt>123<ept i="4">&lt;/c4&gt;</ept>, but the string <bpt i="5" x="5">&lt;c5&gt;</bpt>"hello, world"<ept i="5">&lt;/c5&gt;</ept> doesn’t have an obvious numeric value to convert to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列<bpt i="3" x="3">&lt;c3&gt;</bpt>"123"<ept i="3">&lt;/c3&gt;</ept>は数の値<bpt i="4" x="4">&lt;c4&gt;</bpt>123<ept i="4">&lt;/c4&gt;</ept>に変えられることができます、しかし文字列<bpt i="5" x="5">&lt;c5&gt;</bpt>"hello, world"<ept i="5">&lt;/c5&gt;</ept>には変えるための明らかな数の値がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string begins on the first line after the opening quotes (<bpt i="0" x="0">&lt;c0&gt;</bpt>"""<ept i="0">&lt;/c0&gt;</ept>) and ends on the line before the closing quotes, which means that neither of the strings below start or end with a line break:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列は、開始引用符（<bpt i="0" x="0">&lt;c0&gt;</bpt>"""<ept i="0">&lt;/c0&gt;</ept>）の後の最初の行で始まって終了引用符の前の行で終わります、それが意味するのは下の文字列のどちらも改行で始まったり終わったりしないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string retrieved from the <bpt i="0" x="0">&lt;c0&gt;</bpt>digitNames<ept i="0">&lt;/c0&gt;</ept> dictionary is added to the <bpt i="1" x="1">&lt;e1&gt;</bpt>front<ept i="1">&lt;/e1&gt;</ept> of <bpt i="2" x="2">&lt;c2&gt;</bpt>output<ept i="2">&lt;/c2&gt;</ept>, effectively building a string version of the number in reverse.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>digitNames<ept i="0">&lt;/c0&gt;</ept>辞書から取り出される文字列は<bpt i="2" x="2">&lt;c2&gt;</bpt>output<ept i="2">&lt;/c2&gt;</ept>の<bpt i="1" x="1">&lt;e1&gt;</bpt>前方<ept i="1">&lt;/e1&gt;</ept>に加えられて、うまい具合に数の文字列版を逆の順序で造ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string-sorting closure from the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Closure Expression Syntax<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section above can be written outside of the <bpt i="2" x="2">&lt;c2&gt;</bpt>sorted(by:)<ept i="2">&lt;/c2&gt;</ept> method’s parentheses as a trailing closure:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>クロージャ式構文<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節の文字列を分類するクロージャは、後付クロージャとして<bpt i="2" x="2">&lt;c2&gt;</bpt>sorted(by:)<ept i="2">&lt;/c2&gt;</ept>関数の括弧の外側に書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The strong reference cycle prevents the <bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Apartment<ept i="2">&lt;/c2&gt;</ept> instances from ever being deallocated, causing a memory leak in your app.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>強い参照循環は<bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>Apartment<ept i="2">&lt;/c2&gt;</ept>インスタンスがともかく割り当て解除されるのを妨げます。そして、あなたのアプリのメモリリークを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The strong references between the <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> instance and the <bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept> instance remain and cannot be broken.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>インスタンスと<bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept>インスタンスの間の強い参照は、残っていて、壊されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The strong references from the two variables (<bpt i="0" x="0">&lt;c0&gt;</bpt>john<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>unit4A<ept i="1">&lt;/c1&gt;</ept>) and the links between the two instances are created as before:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの変数（<bpt i="0" x="0">&lt;c0&gt;</bpt>john<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>unit4A<ept i="1">&lt;/c1&gt;</ept>）からの強い参照と２つのインスタンスの繋がりは、前の通り作成されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The structure also defines a stored integer property called <bpt i="3" x="3">&lt;c3&gt;</bpt>numberOfEdits<ept i="3">&lt;/c3&gt;</ept>, which is used to track the number of times that <bpt i="4" x="4">&lt;c4&gt;</bpt>value<ept i="4">&lt;/c4&gt;</ept> is modified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この構造体はまた、<bpt i="3" x="3">&lt;c3&gt;</bpt>numberOfEdits<ept i="3">&lt;/c3&gt;</ept>と呼ばれる保存整数プロパティを定義します、それは、<bpt i="4" x="4">&lt;c4&gt;</bpt>value<ept i="4">&lt;/c4&gt;</ept>が修正される回数を追跡するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The structure defines a single initializer, <bpt i="0" x="0">&lt;c0&gt;</bpt>init<ept i="0">&lt;/c0&gt;</ept>, with no parameters, which initializes the stored temperature with a value of <bpt i="1" x="1">&lt;c1&gt;</bpt>32.0<ept i="1">&lt;/c1&gt;</ept> (the freezing point of water in degrees Fahrenheit).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この構造体は、パラメータのないただ一つのイニシャライザ、<bpt i="0" x="0">&lt;c0&gt;</bpt>init<ept i="0">&lt;/c0&gt;</ept>を定義します、それは格納された温度を値<bpt i="1" x="1">&lt;c1&gt;</bpt>32.0<ept i="1">&lt;/c1&gt;</ept>（華氏度数での水の氷点）で初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The structure does not need to inherit properties or behavior from another existing type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その構造体が、既存の別の型からプロパティまたは挙動を受け継ぐ必要がない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The structure of the <bpt i="2" x="2">&lt;c2&gt;</bpt>repeat<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept> loop is better suited to this game than the <bpt i="4" x="4">&lt;c4&gt;</bpt>while<ept i="4">&lt;/c4&gt;</ept> loop in the previous example.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>repeat<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept>ループの構造は、前の例での<bpt i="4" x="4">&lt;c4&gt;</bpt>while<ept i="4">&lt;/c4&gt;</ept>ループよりも更に良くこのゲームに適しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The structure’s members (including the <bpt i="1" x="1">&lt;c1&gt;</bpt>numberOfEdits<ept i="1">&lt;/c1&gt;</ept> property) therefore have an internal access level by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体のメンバー（<bpt i="1" x="1">&lt;c1&gt;</bpt>numberOfEdits<ept i="1">&lt;/c1&gt;</ept>プロパティを含む）は、したがって特に何もしなければ内部のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The structure’s primary purpose is to encapsulate a few relatively simple data values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その構造体の主要な目的は、比較的単純な２、３のデータ値をカプセル化することである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The subclass in this figure has two designated initializers and one convenience initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この図の中のサブクラスは、２つの指定イニシャライザと１つの便宜イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The subclass inherits characteristics from the existing class, which you can then refine.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブクラスは既存のクラスから特徴を受け継ぎます、あなたはそのとき改良することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The subclass object is not deallocated until all deinitializers in its inheritance chain have finished executing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>サブクラスオブジェクトは、その継承連鎖の中の全てのデイニシャライザが実行を終えるまで、割り当て解除されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The subclass’s implementation of that initializer must also be marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザのサブクラスでの実装はまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept>修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The subclass’s implementation of that initializer must also be marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>required<ept i="1">&lt;/c1&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのイニシャライザのサブクラスの実装もまた、<bpt i="1" x="1">&lt;c1&gt;</bpt>required<ept i="1">&lt;/c1&gt;</ept>宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The subscript returns an optional value of the dictionary’s value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字は辞書のもつ値型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The subscript takes a single parameter, <bpt i="0" x="0">&lt;c0&gt;</bpt>indices<ept i="0">&lt;/c0&gt;</ept>, which is an instance of that <bpt i="1" x="1">&lt;c1&gt;</bpt>Indices<ept i="1">&lt;/c1&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この添え字は、ただ１つだけのパラメータ、<bpt i="0" x="0">&lt;c0&gt;</bpt>indices<ept i="0">&lt;/c0&gt;</ept>をとります、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>Indices<ept i="1">&lt;/c1&gt;</ept>型のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The superclass does not itself have a further superclass, and so rule 1 does not apply.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このスーパークラスにはそれ自身には更にスーパークラスをもちません、なので規則１は適用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The superclass’s designated initializer makes sure that all of the superclass properties have a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラスの指定イニシャライザは、スーパークラスのプロパティの全てが値を持つことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The superclass’s designated initializer now has an opportunity to customize the instance further (although it does not have to).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スーパークラスの指定イニシャライザは、現在、さらにインスタンスを好みに合わせて作り返る機会があります（しかしながら、それはそうしなければならない訳ではない）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The switch cycles between three different power states (<bpt i="0" x="0">&lt;c0&gt;</bpt>off<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>low<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>high<ept i="2">&lt;/c2&gt;</ept>) every time its <bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept> method is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この切替えは、３つの異なる出力状態（<bpt i="0" x="0">&lt;c0&gt;</bpt>off<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>low<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>high<ept i="2">&lt;/c2&gt;</ept>）の間を、それの<bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept>メソッドが呼ばれるたびに循環します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The syntax and standard library have been designed based on the guiding principle that the obvious way to write your code should also perform the best.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構文と標準ライブラリは、明確なやり方であなたのコードを書くことが常に最良を成すべきだという指針に基づいて設計されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The syntax for creating instances is very similar for both structures and classes:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスをつくるための構文は、構造体とクラスの両方で非常に類似しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The syntax for protocol inheritance is similar to the syntax for class inheritance, but with the option to list multiple inherited protocols, separated by commas:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル継承のための構文は、クラス継承のための構文に似ています、しかし複数の継承されたプロトコルをコンマで区切って列記する選択肢を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The syntax for string creation and manipulation is lightweight and readable, with a string literal syntax that is similar to C. String concatenation is as simple as combining two strings with the <bpt i="2" x="2">&lt;c2&gt;</bpt>+<ept i="2">&lt;/c2&gt;</ept> operator, and string mutability is managed by choosing between a constant or a variable, just like any other value in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列の作成と操作のための構文は、軽量で、読みやすく、Cに類似した文字列リテラル構文をもちます。文字列の連結は、２つの文字列を<bpt i="2" x="2">&lt;c2&gt;</bpt>+<ept i="2">&lt;/c2&gt;</ept>演算子を使って繋ぎ合わせるくらい単純です、そして、文字列が変更可能かどうかは、スウィフトの他あらゆる値と同じように、定数または変数のどちらかを選ぶことによって管理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The tenant property is optional because an apartment may not always have a tenant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アパートには常に賃借人がいるわけではないので、tenant（テナント、賃借人）プロパティはオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The ternary conditional operator is shorthand for the code below:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>三項条件演算子は、下のコードの短縮形です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The ternary conditional operator provides an efficient shorthand for deciding which of two expressions to consider.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>三項条件演算子は、２つの式のどちらを考慮するべきか決定することについての効果的な短縮形を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The third <bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept> initializer, <bpt i="1" x="1">&lt;c1&gt;</bpt>init(center:size:)<ept i="1">&lt;/c1&gt;</ept>, is slightly more complex.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第３の<bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept>イニシャライザ、<bpt i="1" x="1">&lt;c1&gt;</bpt>init(center:size:)<ept i="1">&lt;/c1&gt;</ept>は、わずかにより複雑です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The third and final class in the hierarchy is a subclass of <bpt i="0" x="0">&lt;c0&gt;</bpt>RecipeIngredient<ept i="0">&lt;/c0&gt;</ept> called <bpt i="1" x="1">&lt;c1&gt;</bpt>ShoppingListItem<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この階層構造の中の３番目の最後のクラスは、<bpt i="1" x="1">&lt;c1&gt;</bpt>ShoppingListItem<ept i="1">&lt;/c1&gt;</ept>と呼ばれる<bpt i="0" x="0">&lt;c0&gt;</bpt>RecipeIngredient<ept i="0">&lt;/c0&gt;</ept>のサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The third and fourth requirements combine to mean that the items in <bpt i="0" x="0">&lt;c0&gt;</bpt>anotherContainer<ept i="0">&lt;/c0&gt;</ept> can <bpt i="1" x="1">&lt;e1&gt;</bpt>also<ept i="1">&lt;/e1&gt;</ept> be checked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept> operator, because they’re exactly the same type as the items in <bpt i="3" x="3">&lt;c3&gt;</bpt>someContainer<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>３番目と４番目の要件は組み合わされて、<bpt i="0" x="0">&lt;c0&gt;</bpt>anotherContainer<ept i="0">&lt;/c0&gt;</ept>の中の項目が<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>演算子を使って確認されることが<bpt i="1" x="1">&lt;e1&gt;</bpt>同様に<ept i="1">&lt;/e1&gt;</ept>可能なことを意味します、なぜなら、それらは<bpt i="3" x="3">&lt;c3&gt;</bpt>someContainer<ept i="3">&lt;/c3&gt;</ept>の中の項目と同じ正確に型であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The third call fails, because the <bpt i="11" x="11">&lt;c11&gt;</bpt>testScores<ept i="11">&lt;/c11&gt;</ept> dictionary does not contain a key for <bpt i="12" x="12">&lt;c12&gt;</bpt>"Brian"<ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>３番目の呼び出しは失敗します、なぜなら、<bpt i="11" x="11">&lt;c11&gt;</bpt>testScores<ept i="11">&lt;/c11&gt;</ept>辞書は<bpt i="12" x="12">&lt;c12&gt;</bpt>"Brian"<ept i="12">&lt;/c12&gt;</ept>のキーを含んでいないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The third form is used to access an initializer of the superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第３の形式は、スーパークラスのイニシャライザにアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The third property, <bpt i="4" x="4">&lt;c4&gt;</bpt>street<ept i="4">&lt;/c4&gt;</ept>, is used to name the street for that address:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第３のプロパティ、<bpt i="4" x="4">&lt;c4&gt;</bpt>street<ept i="4">&lt;/c4&gt;</ept>は、そのアドレスの通りのために使われます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The three <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> cases declare placeholder constants <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>y<ept i="2">&lt;/c2&gt;</ept>, which temporarily take on one or both tuple values from <bpt i="3" x="3">&lt;c3&gt;</bpt>anotherPoint<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>３つの<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>ケース節はプレースホルダ定数<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>y<ept i="2">&lt;/c2&gt;</ept>を宣言します、それは、一時的に<bpt i="3" x="3">&lt;c3&gt;</bpt>anotherPoint<ept i="3">&lt;/c3&gt;</ept>から１つまたは両方のタプル値を引き受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The three <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> cases declare placeholder constants <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>y<ept i="2">&lt;/c2&gt;</ept>, which temporarily take on the two tuple values from <bpt i="3" x="3">&lt;c3&gt;</bpt>yetAnotherPoint<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>３つの<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>ケース節はプレースホルダ定数<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>y<ept i="2">&lt;/c2&gt;</ept>とを宣言します、それは、一時的に２つタプル値を<bpt i="3" x="3">&lt;c3&gt;</bpt>yetAnotherPoint<ept i="3">&lt;/c3&gt;</ept>から引き受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The three code snippets below define a hierarchy of classes and an array containing instances of those classes, for use in an example of type casting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の３つのコードの断片は、型キャストの例で使うために、あるクラス階層とそれらのクラスのインスタンスを含んでいる配列を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The tokens <bpt i="0" x="0">&lt;c0&gt;</bpt>=<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>-&gt;<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>//<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>/*<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>*/<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept>, the prefix operators <bpt i="6" x="6">&lt;c6&gt;</bpt>&lt;<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>&amp;<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>?<ept i="8">&lt;/c8&gt;</ept>, the infix operator <bpt i="9" x="9">&lt;c9&gt;</bpt>?<ept i="9">&lt;/c9&gt;</ept>, and the postfix operators <bpt i="10" x="10">&lt;c10&gt;</bpt>&gt;<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>!<ept i="11">&lt;/c11&gt;</ept>, and <bpt i="12" x="12">&lt;c12&gt;</bpt>?<ept i="12">&lt;/c12&gt;</ept> are reserved.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>トークン<bpt i="0" x="0">&lt;c0&gt;</bpt>=<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>-&gt;<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>//<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>/*<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>*/<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept>、接頭辞演算子<bpt i="6" x="6">&lt;c6&gt;</bpt>&lt;<ept i="6">&lt;/c6&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>&amp;<ept i="7">&lt;/c7&gt;</ept>、および<bpt i="8" x="8">&lt;c8&gt;</bpt>?<ept i="8">&lt;/c8&gt;</ept>、そして接中辞演算子<bpt i="9" x="9">&lt;c9&gt;</bpt>?<ept i="9">&lt;/c9&gt;</ept>、そして接尾辞演算子<bpt i="10" x="10">&lt;c10&gt;</bpt>&gt;<ept i="10">&lt;/c10&gt;</ept>、<bpt i="11" x="11">&lt;c11&gt;</bpt>!<ept i="11">&lt;/c11&gt;</ept>、および<bpt i="12" x="12">&lt;c12&gt;</bpt>?<ept i="12">&lt;/c12&gt;</ept>は予約されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The top item in the stack is popped.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スタックでの一番上の項目がポンと取り出され（ポップされ）ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The top-level code in a Swift source file consists of zero or more statements, declarations, and expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるスウィフトソースコードにおけるトップレベル・コードは、０個以上の文、宣言、そして式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The trailing closure is understood as an argument to the function, added after the last parenthesized argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後付クロージャは関数に対する引数として理解されます、そして、最後に括弧に入れた引数の後に加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The two containers to be checked don’t have to be the same type of container (although they can be), but they do have to hold the same type of items.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>調べられる２つのコンテナは、同じ型のコンテナである必要はありません（とは言えそうでもよい）、しかしそれらは同じ型の項目を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type <bpt i="0" x="0">&lt;c0&gt;</bpt>Optional&lt;Wrapped&gt;<ept i="0">&lt;/c0&gt;</ept> is an enumeration with two cases, <bpt i="1" x="1">&lt;c1&gt;</bpt>none<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>some(Wrapped)<ept i="2">&lt;/c2&gt;</ept>, which are used to represent values that may or may not be present.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt>Optional&lt;Wrapped&gt;<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>none<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>some(Wrapped)<ept i="2">&lt;/c2&gt;</ept>、２つのケース節をもつ列挙です、それは、存在しているかもしれないししていないかもしれない値を表わすために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type alias can provide concrete types for some or all of the generic parameters of the existing type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型エイリアスは、既存の型の総称体パラメータの一部またはすべてに具体的な型を提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type annotation (<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept> <bpt i="1" x="1">&lt;e1&gt;</bpt>type<ept i="1">&lt;/e1&gt;</ept>) is optional in a constant declaration when the type of the <bpt i="2" x="2">&lt;e2&gt;</bpt>constant name<ept i="2">&lt;/e2&gt;</ept> can be inferred, as described in <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Type Inference<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;e2&gt;</bpt>定数名<ept i="2">&lt;/e2&gt;</ept>の型が推論されることができるとき、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>型推論<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>で記述されるように、型注釈（<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept> <bpt i="1" x="1">&lt;e1&gt;</bpt>type<ept i="1">&lt;/e1&gt;</ept>）は定数宣言において任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type arguments are instead inferred from the type of the arguments passed to the function or initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型引数は、その代わりに関数またはイニシャライザに渡される引数の型から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type check operator returns <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept> if the instance is of that subclass type and <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept> if it is not.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型確認演算子はそのインスタンスがそのサブクラス型ならば<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>を、それがそうでないならば<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type method can be used as an infix operator between existing <bpt i="0" x="0">&lt;c0&gt;</bpt>Vector2D<ept i="0">&lt;/c0&gt;</ept> instances:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型メソッドは既存の<bpt i="0" x="0">&lt;c0&gt;</bpt>Vector2D<ept i="0">&lt;/c0&gt;</ept>インスタンスの間で接中辞演算子として使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of <bpt i="0" x="0">&lt;c0&gt;</bpt>directionToHead<ept i="0">&lt;/c0&gt;</ept> is already known, and so you can drop the type when setting its value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>directionToHead<ept i="0">&lt;/c0&gt;</ept>の型はすでに知られています、それでその値を設定するとき、あなたは型を省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of <bpt i="0" x="0">&lt;c0&gt;</bpt>directionToHead<ept i="0">&lt;/c0&gt;</ept> is inferred when it is initialized with one of the possible values of <bpt i="1" x="1">&lt;c1&gt;</bpt>CompassPoint<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>directionToHead<ept i="0">&lt;/c0&gt;</ept>の型は、それが<bpt i="1" x="1">&lt;c1&gt;</bpt>CompassPoint<ept i="1">&lt;/c1&gt;</ept>の可能な値のうちの１つで初期化されるとき、推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of <bpt i="0" x="0">&lt;c0&gt;</bpt>newValue<ept i="0">&lt;/c0&gt;</ept> is the same as the return value of the subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>newValue<ept i="0">&lt;/c0&gt;</ept>の型は、添え字の戻り値と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of a Swift array is written in full as <bpt i="0" x="0">&lt;c0&gt;</bpt>Array&lt;Element&gt;<ept i="0">&lt;/c0&gt;</ept>, where <bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> is the type of values the array is allowed to store.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト配列の型は、完全には<bpt i="0" x="0">&lt;c0&gt;</bpt>Array&lt;Element&gt;<ept i="0">&lt;/c0&gt;</ept>のように書かれます、そこにおいて<bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>はその配列が保存するのを許される値の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of a Swift dictionary is written in full as <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary&lt;Key, Value&gt;<ept i="0">&lt;/c0&gt;</ept>, where <bpt i="1" x="1">&lt;c1&gt;</bpt>Key<ept i="1">&lt;/c1&gt;</ept> is the type of value that can be used as a dictionary key, and <bpt i="2" x="2">&lt;c2&gt;</bpt>Value<ept i="2">&lt;/c2&gt;</ept> is the type of value that the dictionary stores for those keys.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの辞書型は、完全には<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary&lt;Key, Value&gt;<ept i="0">&lt;/c0&gt;</ept>のように書かれます、ここで<bpt i="1" x="1">&lt;c1&gt;</bpt>Key<ept i="1">&lt;/c1&gt;</ept>は辞書キーとして使われることができる値の型です、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>Value<ept i="2">&lt;/c2&gt;</ept>は辞書がそれらのキーに対してたくわえる値の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of a Swift set is written as <bpt i="0" x="0">&lt;c0&gt;</bpt>Set&lt;Element&gt;<ept i="0">&lt;/c0&gt;</ept>, where <bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> is the type that the set is allowed to store.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるスウィフト集合の型は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Set&lt;Element&gt;<ept i="0">&lt;/c0&gt;</ept>のように書かれます、そこにおいて<bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>はその集合が格納することを許される型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of both of these functions is <bpt i="0" x="0">&lt;c0&gt;</bpt>(Int, Int) -&gt; Int<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの関数の型は両方とも、<bpt i="0" x="0">&lt;c0&gt;</bpt>(Int, Int) -&gt; Int<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of each parameter must be included—it can’t be inferred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各パラメータの型は、含められなければなりません ― それは、推論されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of the <bpt i="0" x="0">&lt;c0&gt;</bpt>letters<ept i="0">&lt;/c0&gt;</ept> variable is inferred to be <bpt i="1" x="1">&lt;c1&gt;</bpt>Set&lt;Character&gt;<ept i="1">&lt;/c1&gt;</ept>, from the type of the initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>letters<ept i="0">&lt;/c0&gt;</ept>変数の型は、そのイニシャライザの型から、<bpt i="1" x="1">&lt;c1&gt;</bpt>Set&lt;Character&gt;<ept i="1">&lt;/c1&gt;</ept>と推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of the <bpt i="1" x="1">&lt;c1&gt;</bpt>celebrator<ept i="1">&lt;/c1&gt;</ept> parameter is <bpt i="2" x="2">&lt;c2&gt;</bpt>Named &amp; Aged<ept i="2">&lt;/c2&gt;</ept>, which means “any type that conforms to both the <bpt i="3" x="3">&lt;c3&gt;</bpt>Named<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Aged<ept i="4">&lt;/c4&gt;</ept> protocols.” It doesn’t matter which specific type is passed to the function, as long as it conforms to both of the required protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>celebrator<ept i="1">&lt;/c1&gt;</ept>パラメータの型は<bpt i="2" x="2">&lt;c2&gt;</bpt>Named &amp; Aged<ept i="2">&lt;/c2&gt;</ept>です、それは「<bpt i="3" x="3">&lt;c3&gt;</bpt>Named<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>Aged<ept i="4">&lt;/c4&gt;</ept>プロトコルの両方に準拠する何らかの型」を意味します。どのような具体的な型が関数へ渡されるかは問題ではありません、それが必須プロトコルの両方に準拠する限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of the <bpt i="1" x="1">&lt;c1&gt;</bpt>numberOfLegs<ept i="1">&lt;/c1&gt;</ept> dictionary is inferred to be <bpt i="2" x="2">&lt;c2&gt;</bpt>[String: Int]<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>numberOfLegs<ept i="1">&lt;/c1&gt;</ept>辞書の型は、<bpt i="2" x="2">&lt;c2&gt;</bpt>[String: Int]<ept i="2">&lt;/c2&gt;</ept>であると推測されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of the <bpt i="3" x="3">&lt;c3&gt;</bpt>library<ept i="3">&lt;/c3&gt;</ept> array is inferred by initializing it with the contents of an array literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>library<ept i="3">&lt;/c3&gt;</ept>配列の型は、ある配列リテラルの内容でそれを初期化することから推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of the <bpt i="2" x="2">&lt;e2&gt;</bpt>setter name<ept i="2">&lt;/e2&gt;</ept> must be the same as the <bpt i="3" x="3">&lt;e3&gt;</bpt>return type<ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;e2&gt;</bpt>セッター名<ept i="2">&lt;/e2&gt;</ept>の型は、<bpt i="3" x="3">&lt;e3&gt;</bpt>戻り型<ept i="3">&lt;/e3&gt;</ept>と同じものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of the array is inferred to be <bpt i="2" x="2">&lt;c2&gt;</bpt>[ShoppingListItem]<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の型は、<bpt i="2" x="2">&lt;c2&gt;</bpt>[ShoppingListItem]<ept i="2">&lt;/c2&gt;</ept>であると推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of the property must conform to the <bpt i="2" x="2">&lt;c2&gt;</bpt>NSCopying<ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティの型は、<bpt i="2" x="2">&lt;c2&gt;</bpt>NSCopying<ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of the variable or property must be an optional class type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この変数またはプロパティの型はまた、オプショナルクラス型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of these values is specified in the <bpt i="2" x="2">&lt;e2&gt;</bpt>raw-value type<ept i="2">&lt;/e2&gt;</ept> and must represent an integer, floating-point number, string, or single character.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの値の型は、<bpt i="2" x="2">&lt;e2&gt;</bpt>生の値型<ept i="2">&lt;/e2&gt;</ept>において指定されて、整数、浮動小数点数、文字列または単一の文字を表さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of this function is <bpt i="0" x="0">&lt;c0&gt;</bpt>() -&gt; Void<ept i="0">&lt;/c0&gt;</ept>, or “a function that has no parameters, and returns <bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept>.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数の型は<bpt i="0" x="0">&lt;c0&gt;</bpt>() -&gt; Void<ept i="0">&lt;/c0&gt;</ept>です、あるいは「パラメータを持たず、<bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept>を返す関数」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of this property is <bpt i="1" x="1">&lt;c1&gt;</bpt>String?<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティの型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>String?<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The types of <bpt i="0" x="0">&lt;c0&gt;</bpt>orangesAreOrange<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>turnipsAreDelicious<ept i="1">&lt;/c1&gt;</ept> have been inferred as <bpt i="2" x="2">&lt;c2&gt;</bpt>Bool<ept i="2">&lt;/c2&gt;</ept> from the fact that they were initialized with Boolean literal values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>orangesAreOrange<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>turnipsAreDelicious<ept i="1">&lt;/c1&gt;</ept>の型は、それらがブールのリテラル値で初期化されたという事実から、<bpt i="2" x="2">&lt;c2&gt;</bpt>Bool<ept i="2">&lt;/c2&gt;</ept>として推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The types used for any raw values or associated values in an enumeration definition must have an access level at least as high as the enumeration’s access level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙定義の中のあらゆる生の値または関連値のために使われる型は、少なくとも列挙のアクセス水準と同じの高さのアクセス水準を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The unary minus operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>) is prepended directly before the value it operates on, without any white space.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単項マイナス演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>）は、それが作用する値の前に、全く空白なしで、直接に先頭に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The unary minus operator is a prefix operator, and so this method has to be qualified with the <bpt i="2" x="2">&lt;c2&gt;</bpt>prefix<ept i="2">&lt;/c2&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この単項マイナス演算子は、接頭辞演算子です、なのでこのメソッドは<bpt i="2" x="2">&lt;c2&gt;</bpt>prefix<ept i="2">&lt;/c2&gt;</ept>修飾子で修飾されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The underlying instance remains the same; it is simply treated and accessed as an instance of the type to which it has been cast.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>根底にあるインスタンスは、同じもののままです；それは単に、それがキャストされた型のインスタンスとして扱われ、アクセスされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The underscore character (<bpt i="8" x="8">&lt;c8&gt;</bpt>_<ept i="8">&lt;/c8&gt;</ept>) used in place of a loop variable causes the individual values to be ignored and does not provide access to the current value during each iteration of the loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループ変数の代わりに使われるアンダースコア文字（<bpt i="8" x="8">&lt;c8&gt;</bpt>_<ept i="8">&lt;/c8&gt;</ept>）は、その個別の値を無視されるようにして、ループの各繰り返しのときにその現在の値へのアクセスを提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The unused expression is not evaluated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>使っていない式は、評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The unwrapped value of a forced-value expression can be modified, either by mutating the value itself, or by assigning to one of the value’s members.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>強制された値式のアンラップされた値は、値それ自体を変化させることによって、またはその値のメンバーの１つに代入することによってのどちらでも、修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The unwrapped value of an optional-chaining expression can be modified, either by mutating the value itself, or by assigning to one of the value’s members.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖のアンラップされた値は、その値自体を変化させることによって、またはその値のメンバーの１つに値に代入することによってのどちらでも修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The use of a two-phase initialization process makes initialization safe, while still giving complete flexibility to each class in a class hierarchy.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２段階初期化処理の使用は初期化を安全にします、その一方でさらに、クラス階層において各クラスに完全な柔軟性を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The use of argument labels can allow a function to be called in an expressive, sentence-like manner, while still providing a function body that is readable and clear in intent.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>引数ラベルの使用は、関数が、表現が豊かな、文章のようなやり方で呼び出されることを可能にします、その一方で、依然として読みやすくて意図が明白な関数本文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The use of the <bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept> modifier ensures that you provide an explicit or inherited implementation of the initializer requirement on all subclasses of the conforming class, such that they also conform to the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept>修飾子の使用は、あなたがある明確なもしくは継承されたイニシャライザ要件の実装を準拠クラスの全てのサブクラス上で、それらもまたそのプロトコルに準拠するように、提供することを確かなものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The use of trailing closure syntax in the example above neatly encapsulates the closure’s functionality immediately after the function that closure supports, without needing to wrap the entire closure within the <bpt i="0" x="0">&lt;c0&gt;</bpt>map(_:)<ept i="0">&lt;/c0&gt;</ept> method’s outer parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例での後付クロージャ構文の使用は、クロージャの機能性をクロージャが手助けする関数の直後に手際よく要約していて、クロージャ全体を<bpt i="0" x="0">&lt;c0&gt;</bpt>map(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドの持つ外側の丸括弧の内部に包む必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of <bpt i="0" x="0">&lt;c0&gt;</bpt>john.residence<ept i="0">&lt;/c0&gt;</ept> currently contains a valid <bpt i="1" x="1">&lt;c1&gt;</bpt>Residence<ept i="1">&lt;/c1&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>john.residence<ept i="0">&lt;/c0&gt;</ept>の値は、現在は有効な<bpt i="1" x="1">&lt;c1&gt;</bpt>Residence<ept i="1">&lt;/c1&gt;</ept>インスタンスを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of <bpt i="0" x="0">&lt;c0&gt;</bpt>multiplier<ept i="0">&lt;/c0&gt;</ept> is also part of a larger expression later in the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>multiplier<ept i="0">&lt;/c0&gt;</ept>の値は、また、文字列の後半のより大きな式の一部でもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of <bpt i="2" x="2">&lt;c2&gt;</bpt>invertedBits<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>11110000<ept i="3">&lt;/c3&gt;</ept>, which is equal to an unsigned decimal value of <bpt i="4" x="4">&lt;c4&gt;</bpt>240<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>invertedBits<ept i="2">&lt;/c2&gt;</ept>の値は<bpt i="3" x="3">&lt;c3&gt;</bpt>11110000<ept i="3">&lt;/c3&gt;</ept>です、それは、符号なし10進の値の<bpt i="4" x="4">&lt;c4&gt;</bpt>240<ept i="4">&lt;/c4&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of <bpt i="3" x="3">&lt;c3&gt;</bpt>index<ept i="3">&lt;/c3&gt;</ept> is set to the first number in the range (<bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept>), and the statements inside the loop are executed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>index<ept i="3">&lt;/c3&gt;</ept>の値は、この範囲の最初の数（<bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept>）に設定されます、そしてループの内側の文が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of <bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept> must not be greater than <bpt i="7" x="7">&lt;c7&gt;</bpt>b<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept>の値は<bpt i="7" x="7">&lt;c7&gt;</bpt>b<ept i="7">&lt;/c7&gt;</ept>より大きくてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of a <bpt i="4" x="4">&lt;e4&gt;</bpt>constant<ept i="4">&lt;/e4&gt;</ept> can’t be changed once it’s set, whereas a <bpt i="5" x="5">&lt;e5&gt;</bpt>variable<ept i="5">&lt;/e5&gt;</ept> can be set to a different value in the future.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;e4&gt;</bpt>定数<ept i="4">&lt;/e4&gt;</ept>の値は、一旦それが設定されるならば変わることができません、一方で<bpt i="5" x="5">&lt;e5&gt;</bpt>変数<ept i="5">&lt;/e5&gt;</ept>は将来異なる値に設定されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of a constant doesn’t need to be known at compile time, but you must assign it a value exactly once.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数の値はコンパイル時に知られている必要はありません、しかしあなたはそれに値を厳密に一度だけ代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of a dictionary literal has type <bpt i="0" x="0">&lt;c0&gt;</bpt>[Key: Value]<ept i="0">&lt;/c0&gt;</ept>, where <bpt i="1" x="1">&lt;c1&gt;</bpt>Key<ept i="1">&lt;/c1&gt;</ept> is the type of its key expressions and <bpt i="2" x="2">&lt;c2&gt;</bpt>Value<ept i="2">&lt;/c2&gt;</ept> is the type of its value expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書リテラルの値は、型<bpt i="0" x="0">&lt;c0&gt;</bpt>[Key: Value]<ept i="0">&lt;/c0&gt;</ept>を持ちます、そこで、<bpt i="1" x="1">&lt;c1&gt;</bpt>Key<ept i="1">&lt;/c1&gt;</ept>はそのキーの式の型です、そして、<bpt i="2" x="2">&lt;c2&gt;</bpt>Value<ept i="2">&lt;/c2&gt;</ept>はその値の式の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of a selector expression is an instance of the <bpt i="2" x="2">&lt;c2&gt;</bpt>Selector<ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>セレクタ式の値は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Selector<ept i="2">&lt;/c2&gt;</ept>型のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of an array literal has type <bpt i="0" x="0">&lt;c0&gt;</bpt>[T]<ept i="0">&lt;/c0&gt;</ept>, where <bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept> is the type of the expressions inside it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列リテラルの値は型<bpt i="0" x="0">&lt;c0&gt;</bpt>[T]<ept i="0">&lt;/c0&gt;</ept>を持ちます、そこで、<bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>はそれの内部の式の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of an expression can be inserted into a string literal by placing the expression in parentheses after a backslash (<bpt i="0" x="0">&lt;c0&gt;</bpt>\<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>式の値は、バックスラッシュ（<bpt i="0" x="0">&lt;c0&gt;</bpt>\<ept i="0">&lt;/c0&gt;</ept>）の後の丸括弧の中にその式を置くことによってリテラル文字列に差し込まれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of any condition in a <bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept> statement must be of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept> or a type bridged to <bpt i="2" x="2">&lt;c2&gt;</bpt>Bool<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept>文の中のあらゆる条件の値は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept>型または<bpt i="2" x="2">&lt;c2&gt;</bpt>Bool<ept i="2">&lt;/c2&gt;</ept>にブリッジされる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of any condition in an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement must be of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept> or a type bridged to <bpt i="2" x="2">&lt;c2&gt;</bpt>Bool<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文の中のあらゆる条件の値は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept>型または<bpt i="2" x="2">&lt;c2&gt;</bpt>Bool<ept i="2">&lt;/c2&gt;</ept>にブリッジされる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of the <bpt i="0" x="0">&lt;e0&gt;</bpt>condition<ept i="0">&lt;/e0&gt;</ept> must be of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept> or a type bridged to <bpt i="2" x="2">&lt;c2&gt;</bpt>Bool<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>condition<ept i="0">&lt;/e0&gt;</ept>の値は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept>型または<bpt i="2" x="2">&lt;c2&gt;</bpt>Bool<ept i="2">&lt;/c2&gt;</ept>にブリッジされる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of the <bpt i="0" x="0">&lt;e0&gt;</bpt>control expression<ept i="0">&lt;/e0&gt;</ept> can even be matched to the value of a case in an enumeration and checked for inclusion in a specified range of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>制御式<ept i="0">&lt;/e0&gt;</ept>の値は、列挙でのケース節の値にさえマッチすることや、指定された範囲の値に包含されるかについて調べさえすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of the <bpt i="0" x="0">&lt;e0&gt;</bpt>expression<ept i="0">&lt;/e0&gt;</ept> is set to the value obtained by evaluating the <bpt i="1" x="1">&lt;e1&gt;</bpt>value<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>式<ept i="0">&lt;/e0&gt;</ept>の値は、<bpt i="1" x="1">&lt;e1&gt;</bpt>値<ept i="1">&lt;/e1&gt;</ept>を評価することによって得られる値に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of the <bpt i="0" x="0">&lt;e0&gt;</bpt>expression<ept i="0">&lt;/e0&gt;</ept> must have a type that conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Error<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>expression（式）<ept i="0">&lt;/e0&gt;</ept>の値は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Error<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠する型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value of these properties cannot be set, and so it is not appropriate to provide a <bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept> implementation as part of an override.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのプロパティの値は設定されることができません、なのでオーバーライドの一部として<bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept>の実装を提供することは適切ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value returned by a type’s <bpt i="4" x="4">&lt;c4&gt;</bpt>hashValue<ept i="4">&lt;/c4&gt;</ept> property is not required to be the same across different executions of the same program, or in different programs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型の<bpt i="4" x="4">&lt;c4&gt;</bpt>hashValue<ept i="4">&lt;/c4&gt;</ept>プロパティによって返される値は、同じプログラムの、または異なるプログラムでの、異なる実行にまたがって同じであることを要求されません、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The value that remains within the bounds of the <bpt i="7" x="7">&lt;c7&gt;</bpt>UInt8<ept i="7">&lt;/c7&gt;</ept> after the overflow addition is <bpt i="8" x="8">&lt;c8&gt;</bpt>00000000<ept i="8">&lt;/c8&gt;</ept>, or zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバフロー加算の後で<bpt i="7" x="7">&lt;c7&gt;</bpt>UInt8<ept i="7">&lt;/c7&gt;</ept>の領域内に残る値は、<bpt i="8" x="8">&lt;c8&gt;</bpt>00000000<ept i="8">&lt;/c8&gt;</ept>、またはゼロです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The values defined in an enumeration (such as <bpt i="0" x="0">&lt;c0&gt;</bpt>north<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>south<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>east<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>west<ept i="3">&lt;/c3&gt;</ept>) are its <bpt i="4" x="4">&lt;e4&gt;</bpt>enumeration cases<ept i="4">&lt;/e4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙で定義される値（例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>north<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>south<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>east<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>west<ept i="3">&lt;/c3&gt;</ept>）は、それの<bpt i="4" x="4">&lt;e4&gt;</bpt>列挙ケース節<ept i="4">&lt;/e4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The values of <bpt i="0" x="0">&lt;c0&gt;</bpt>finalSquare<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>board<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>square<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>diceRoll<ept i="3">&lt;/c3&gt;</ept> are initialized in the same way as before:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>finalSquare<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>board<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>square<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>diceRoll<ept i="3">&lt;/c3&gt;</ept>の値は、前と同じように初期化されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The values of <bpt i="4" x="4">&lt;c4&gt;</bpt>finalSquare<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>board<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>square<ept i="6">&lt;/c6&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>diceRoll<ept i="7">&lt;/c7&gt;</ept> are initialized in exactly the same way as with a <bpt i="8" x="8">&lt;c8&gt;</bpt>while<ept i="8">&lt;/c8&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>finalSquare<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>board<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>square<ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>diceRoll<ept i="7">&lt;/c7&gt;</ept>の値は、正確に<bpt i="8" x="8">&lt;c8&gt;</bpt>while<ept i="8">&lt;/c8&gt;</ept>ループと同じやり方で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The values of a dictionary can be accessed through subscripting by specifying the corresponding key in square brackets: <bpt i="0" x="0">&lt;c0&gt;</bpt>someDictionary["Alex"]<ept i="0">&lt;/c0&gt;</ept> refers to the value associated with the key <bpt i="1" x="1">&lt;c1&gt;</bpt>"Alex"<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書の値は、角括弧の中に対応するキーを指定することによる添え字指定を通してアクセスされることができます：<bpt i="0" x="0">&lt;c0&gt;</bpt>someDictionary["Alex"]<ept i="0">&lt;/c0&gt;</ept>はキー<bpt i="1" x="1">&lt;c1&gt;</bpt>"Alex"<ept i="1">&lt;/c1&gt;</ept>と結び付けられた値に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The values of expressions your code can branch on are very flexible.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコードが分岐することができる式の値は、非常に柔軟です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The values of the conditions specified in a branch statement control how the program branches and, therefore, what block of code is executed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>分岐文において指定される条件の値は、プログラムがどのように分岐するか、したがって、コードのどのブロックが実行されるかについて制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The values of these properties are of the appropriate-sized number type (such as <bpt i="0" x="0">&lt;c0&gt;</bpt>UInt8<ept i="0">&lt;/c0&gt;</ept> in the example above) and can therefore be used in expressions alongside other values of the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのプロパティの値は、適切なサイズの数の型（例えば上の例での<bpt i="0" x="0">&lt;c0&gt;</bpt>UInt8<ept i="0">&lt;/c0&gt;</ept>）であり、したがって、式の中で同じ型の他の値と並べて使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The values passed to a variadic parameter are made available within the function’s body as an array of the appropriate type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変長パラメータに渡される値は、適切な型の配列として、関数の本文内で利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The values that operators affect are <bpt i="0" x="0">&lt;e0&gt;</bpt>operands<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子が影響を及ぼす値は、<bpt i="0" x="0">&lt;e0&gt;</bpt>演算数<ept i="0">&lt;/e0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The values within a tuple can be of any type and don’t have to be of the same type as each other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプルの内部の値は、どんな型でもかまいません、そして互いに同じ型である必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The variable <bpt i="0" x="0">&lt;c0&gt;</bpt>unsignedOverflow<ept i="0">&lt;/c0&gt;</ept> is initialized with the maximum value a <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept> can hold (<bpt i="2" x="2">&lt;c2&gt;</bpt>255<ept i="2">&lt;/c2&gt;</ept>, or <bpt i="3" x="3">&lt;c3&gt;</bpt>11111111<ept i="3">&lt;/c3&gt;</ept> in binary).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数<bpt i="0" x="0">&lt;c0&gt;</bpt>unsignedOverflow<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>が持つことができる最大限の値で初期化されます（<bpt i="2" x="2">&lt;c2&gt;</bpt>255<ept i="2">&lt;/c2&gt;</ept>、または２進数での<bpt i="3" x="3">&lt;c3&gt;</bpt>11111111<ept i="3">&lt;/c3&gt;</ept>）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The various aspects of your code that can have access control applied to them (properties, types, functions, and so on) are referred to as “entities” in the sections below, for brevity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらに適用可能なアクセス制御を持つあなたのコードのさまざまな面（プロパティ、型、関数、その他）は、簡潔さのために、下記の節において「実在」として言及されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The version number for the <bpt i="0" x="0">&lt;c0&gt;</bpt>swift()<ept i="0">&lt;/c0&gt;</ept> platform condition consists of a major number, optional minor number, optional patch number, and so on, with a dot (<bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept>) separating each part of the version number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>swift()<ept i="0">&lt;/c0&gt;</ept>プラットホーム条件のためのバージョン番号は、メジャー番号、オプショナルのマイナー番号、オプショナルのパッチ番号、その他と、バージョン番号の各部を区切っているドット（<bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept>）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The version of <bpt i="1" x="1">&lt;c1&gt;</bpt>serve(customer:)<ept i="1">&lt;/c1&gt;</ept> below performs the same operation but, instead of taking an explicit closure, it takes an autoclosure by marking its parameter’s type with the <bpt i="2" x="2">&lt;c2&gt;</bpt>@autoclosure<ept i="2">&lt;/c2&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下のバージョンの<bpt i="1" x="1">&lt;c1&gt;</bpt>serve(customer:)<ept i="1">&lt;/c1&gt;</ept>は同じ演算を実行します、しかし明示的なクロージャを取るのではなく、それは自動クロージャを、それのパラメータの型を<bpt i="2" x="2">&lt;c2&gt;</bpt>@autoclosure<ept i="2">&lt;/c2&gt;</ept>属性で記することによって取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The video mode is assigned a copy of the HD resolution of <bpt i="2" x="2">&lt;c2&gt;</bpt>1920<ept i="2">&lt;/c2&gt;</ept> by <bpt i="3" x="3">&lt;c3&gt;</bpt>1080<ept i="3">&lt;/c3&gt;</ept> from before.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビデオ・モードは、以前にHD解像度<bpt i="2" x="2">&lt;c2&gt;</bpt>1920<ept i="2">&lt;/c2&gt;</ept>×<bpt i="3" x="3">&lt;c3&gt;</bpt>1080<ept i="3">&lt;/c3&gt;</ept>のコピーを代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The whitespace around an operator is used to determine whether an operator is used as a prefix operator, a postfix operator, or a binary operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子のまわりの空白は、演算子が接頭辞演算子か、接尾辞演算子か、または二項演算子として使われるかを決定するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The whitespace before the closing quotes (<bpt i="0" x="0">&lt;c0&gt;</bpt>"""<ept i="0">&lt;/c0&gt;</ept>) tells Swift what whitespace to ignore before all of the other lines.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>閉じ引用符（<bpt i="0" x="0">&lt;c0&gt;</bpt>"""<ept i="0">&lt;/c0&gt;</ept>）の前の空白文字は、他の行すべての前でどの空白文字を無視するかスウィフトに教えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The zeros in <bpt i="2" x="2">&lt;c2&gt;</bpt>0xFF0000<ept i="2">&lt;/c2&gt;</ept> effectively “mask” the second and third bytes of <bpt i="3" x="3">&lt;c3&gt;</bpt>0xCC6699<ept i="3">&lt;/c3&gt;</ept>, causing the <bpt i="4" x="4">&lt;c4&gt;</bpt>6699<ept i="4">&lt;/c4&gt;</ept> to be ignored and leaving <bpt i="5" x="5">&lt;c5&gt;</bpt>0xCC0000<ept i="5">&lt;/c5&gt;</ept> as the result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>0xFF0000<ept i="2">&lt;/c2&gt;</ept>のゼロは、<bpt i="3" x="3">&lt;c3&gt;</bpt>0xCC6699<ept i="3">&lt;/c3&gt;</ept>の２番目と３番目のバイトを効果的に「マスク」します（隠して消します）、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>6699<ept i="4">&lt;/c4&gt;</ept>が無視されるようになって、結果として<bpt i="5" x="5">&lt;c5&gt;</bpt>0xCC0000<ept i="5">&lt;/c5&gt;</ept>が残ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Their primary role is to ensure that new instances of a type are correctly initialized before they are used for the first time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの主要な役割は、ある型の新しいインスタンスが、それらが初めて使われる前に正しく初期化されることを保証することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Their return value is of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>, and can be used within mathematical calculations wherever a <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept> is accepted:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの戻り値は<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>型です、そして数学計算内の<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>が受け入れられるあらゆるところで使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Their syntax is similar to both instance method syntax and computed property syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの構文は、インスタンスメソッド構文と計算プロパティ構文に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Their type is inferred only at the point that they’re evaluated by the compiler.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの型は、それらがコンパイラによって評価される時点においてのみ、推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Then, declare a new variable called <bpt i="2" x="2">&lt;c2&gt;</bpt>currentLoginAttempt<ept i="2">&lt;/c2&gt;</ept>, and give it an initial value of <bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その後で、<bpt i="2" x="2">&lt;c2&gt;</bpt>currentLoginAttempt<ept i="2">&lt;/c2&gt;</ept>と呼ばれる新しい変数を宣言して、それに<bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>の初期値を与える。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are <bpt i="4" x="4">&lt;e4&gt;</bpt>two<ept i="4">&lt;/e4&gt;</ept> levels of optional chaining in use here, to chain through the <bpt i="5" x="5">&lt;c5&gt;</bpt>residence<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>address<ept i="6">&lt;/c6&gt;</ept> properties, both of which are of optional type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここで使用されるオプショナル連鎖の<bpt i="4" x="4">&lt;e4&gt;</bpt>２つの<ept i="4">&lt;/e4&gt;</ept>階層があります、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>residence<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>addressプ<ept i="6">&lt;/c6&gt;</ept>ロパティを通り抜けて繋げます、その両方ともオプショナル型です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are a number of ways this task can fail, including the file not existing at the specified path, the file not having read permissions, or the file not being encoded in a compatible format.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この作業が失敗するたくさんの道筋があります、そのファイルが指定したパスで存在しない、ファイルが読み出し権限を持っていない、またはファイルが互換性のある形式で符号化されていないことを含めて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are currently three values on the stack.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>現在は３つの値がこのスタックにはあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are four type-casting operators: the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept> operator, the <bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept> operator, the <bpt i="2" x="2">&lt;c2&gt;</bpt>as?<ept i="2">&lt;/c2&gt;</ept> operator, and the <bpt i="3" x="3">&lt;c3&gt;</bpt>as!<ept i="3">&lt;/c3&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>４つの型キャスト演算子、<bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept>演算子、<bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept>演算子、<bpt i="2" x="2">&lt;c2&gt;</bpt>as?<ept i="2">&lt;/c2&gt;</ept>演算子、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>as!<ept i="3">&lt;/c3&gt;</ept>演算子があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are four ways to handle errors in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>４つの方法がエラーを取り扱うためにスウィフトにはあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are no further superclasses to initialize, and so no further delegation is needed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化するための更なるスーパークラスはありません、なので、更なる委任は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are now <bpt i="0" x="0">&lt;e0&gt;</bpt>three<ept i="0">&lt;/e0&gt;</ept> strong references to this single <bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>現在この一つの<bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept>インスタンスへの<bpt i="0" x="0">&lt;e0&gt;</bpt>３つ<ept i="0">&lt;/e0&gt;</ept>の強い参照があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are several special forms that allow closures to be written more concisely:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャをより簡潔に書かれるようにする特別ないくつかの形式があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are several types of control flow statements in Swift, including loop statements, branch statements, and control transfer statements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの種類の制御の流れ文が、スウィフトにあります、それはループ文、分岐文、そして制御移動文を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are several ways to handle errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの方法がエラーを取り扱うためにはあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are three basic forms of an operator declaration, one for each fixity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子宣言の基本の書式は、各定着性に対して１つずつ、３つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are three ways to create an instance of a previously declared structure:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以前に宣言された構造体のインスタンスを作成するには３つの方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are two basic forms of an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文の２つの基本の書式があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are two cases in which a type identifier doesn’t refer to a type with the same name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型識別子がある型に同じ名前で言及しない２つの場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are two compound types: function types and tuple types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの複合の型：関数型とタプル型があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are two different things named <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>, the variable in the surrounding scope and the constant in the closure’s scope, but only one variable named <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>と名前をつけられる２つの異なるものがあります、囲んでいるスコープにおける変数とクロージャのスコープにおける定数、しかし<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>と名前をつけられる変数はただひとつのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are two kinds of attributes in Swift, those that apply to declarations and those that apply to types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトには２種類の属性があります、宣言に適用されるもの、そして型に適用されるもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are two type-casting patterns, the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept> pattern and the <bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept> pattern.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの型キャスト・パターン、<bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept>パターンと<bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept>パターンがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are two ways to create an instance of a previously declared class:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以前に宣言されたクラスのインスタンスをつくるには２つの方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There can only ever be one <bpt i="3" x="3">&lt;c3&gt;</bpt>Bank<ept i="3">&lt;/c3&gt;</ept> in the game, and so the <bpt i="4" x="4">&lt;c4&gt;</bpt>Bank<ept i="4">&lt;/c4&gt;</ept> is implemented as a class with type properties and methods to store and manage its current state:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つの<bpt i="3" x="3">&lt;c3&gt;</bpt>Bank<ept i="3">&lt;/c3&gt;</ept>だけがゲームにおいて存在することができます、なので<bpt i="4" x="4">&lt;c4&gt;</bpt>Bank<ept i="4">&lt;/c4&gt;</ept>は型プロパティと型メソッドをもつクラスとして実装されて、その現在の状態を保存および管理します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is also a new <bpt i="1" x="1">&lt;c1&gt;</bpt>@noescape<ept i="1">&lt;/c1&gt;</ept> parameter declaration attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>また新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>@noescape<ept i="1">&lt;/c1&gt;</ept>パラメーター宣言属性もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is no requirement for classes to subclass any standard root class, so you can include or omit a superclass as needed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの標準となるルートクラスのサブクラスであることは、クラスにとって必要条件ではありません、そのためあなたは必要に応じてスーパークラスを含めたり省略したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is only one loop in the game, and therefore no ambiguity as to which loop the <bpt i="2" x="2">&lt;c2&gt;</bpt>continue<ept i="2">&lt;/c2&gt;</ept> statement will affect.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このゲームにはただ一つのループしかありません、それゆえに<bpt i="2" x="2">&lt;c2&gt;</bpt>continue<ept i="2">&lt;/c2&gt;</ept>文が影響を及ぼすループはどれかについての曖昧さもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There must not be whitespace between <bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;=<ept i="2">&lt;/c2&gt;</ept> and the version number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;=<ept i="2">&lt;/c2&gt;</ept>とバージョン番号の間に空白があってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There will only ever be one copy of these properties, no matter how many instances of that type you create.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらのプロパティのコピーはただ１つだけ存在することになります、あなたが作るその型のインスタンスがいくらあろうとも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Thereafter, the game instantiator has the option to set the property to a suitable delegate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その後は、このゲームのイニシャライザは、このプロパティを適当な委任先に設定する選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, <bpt i="3" x="3">&lt;c3&gt;</bpt>RecipeIngredient<ept i="3">&lt;/c3&gt;</ept> automatically inherits all of its superclass’s convenience initializers too.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、<bpt i="3" x="3">&lt;c3&gt;</bpt>RecipeIngredient<ept i="3">&lt;/c3&gt;</ept>は自動的にそのスーパークラスの便宜イニシャライザの全てもまた継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, ARC automatically sets a weak reference to <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> when the instance that it refers to is deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、ARCは自動的に、弱い参照をそれが言及するインスタンスが割り当て解除されるとき<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, it is sometimes useful to be explicit about which loop or conditional statement you want a <bpt i="1" x="1">&lt;c1&gt;</bpt>break<ept i="1">&lt;/c1&gt;</ept> statement to terminate.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、あなたが<bpt i="1" x="1">&lt;c1&gt;</bpt>break<ept i="1">&lt;/c1&gt;</ept>文に終了して欲しいループまたは条件文はどれかについて明白にすることは、しばしば役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, it’s safe to check for a snake or a ladder as the first action in the loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、ループでの最初の活動として、ヘビまたははしごについて調べるのは差し支えありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, the names and types of an initializer’s parameters play a particularly important role in identifying which initializer should be called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、イニシャライザのパラメータの名前と型は、どのイニシャライザが呼ばれなければならないか識別することにおいて特に重要な役割を演じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, the overall access level of the compound tuple type is “private” (the minimum access level of the tuple’s constituent types).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、この複合タプル型の全体としてのアクセス水準は「非公開」です（このタプルの構成要素の型の内の最小のアクセス水準）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, when you break the strong references held by the <bpt i="4" x="4">&lt;c4&gt;</bpt>john<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>unit4A<ept i="5">&lt;/c5&gt;</ept> variables, the reference counts do not drop to zero, and the instances are not deallocated by ARC:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、あなたが<bpt i="4" x="4">&lt;c4&gt;</bpt>john<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>unit4A<ept i="5">&lt;/c5&gt;</ept>変数によって保持される強い参照を壊すとき、参照総数はゼロに落ちません、なのでインスタンスはARCによって割り当て解除されません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, you can set it to an instance of <bpt i="2" x="2">&lt;e2&gt;</bpt>any<ept i="2">&lt;/e2&gt;</ept> type that adopts the <bpt i="3" x="3">&lt;c3&gt;</bpt>RandomNumberGenerator<ept i="3">&lt;/c3&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、あなたはそれを<bpt i="3" x="3">&lt;c3&gt;</bpt>RandomNumberGenerator<ept i="3">&lt;/c3&gt;</ept>プロトコルを採用する<bpt i="2" x="2">&lt;e2&gt;</bpt>あらゆる<ept i="2">&lt;/e2&gt;</ept>型のインスタンスに設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, you can simply pass in the greater-than operator, and Swift will infer that you want to use its string-specific implementation:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、あなたはただ単に「大なり」演算子を渡すことができます、そしてスウィフトはあなたがその文字列特有の実装を使いたいのだと推測します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, you don’t need to specify a custom access level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、あなたはあつらえのアクセス水準を指定する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, you must write the <bpt i="1" x="1">&lt;c1&gt;</bpt>override<ept i="1">&lt;/c1&gt;</ept> modifier before the subclass’s initializer definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>override<ept i="1">&lt;/c1&gt;</ept>修飾子をそのサブクラスのイニシャライザ定義の前に書かなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, your subclass is not (strictly speaking) providing an override of the superclass initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それゆえに、あなたのサブクラスはスーパークラスのイニシャライザのオーバーライドを（厳密に言えば）提供していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There’s actually an even <bpt i="0" x="0">&lt;e0&gt;</bpt>shorter<ept i="0">&lt;/e0&gt;</ept> way to write the closure expression above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらに<bpt i="0" x="0">&lt;e0&gt;</bpt>より短い<ept i="0">&lt;/e0&gt;</ept>方法が上のクロージャ式を書くために実際にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There’s an even simpler way to include values in strings: Write the value in parentheses, and write a backslash (<bpt i="0" x="0">&lt;c0&gt;</bpt>\<ept i="0">&lt;/c0&gt;</ept>) before the parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いろいろな値を文字列の中に含めるさらに単純な方法があります：その値を丸括弧の中に書いてください、そして丸括弧の前にバックスラッシュ（<bpt i="0" x="0">&lt;c0&gt;</bpt>\<ept i="0">&lt;/c0&gt;</ept>）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There’s no need to shift this to the right, as <bpt i="3" x="3">&lt;c3&gt;</bpt>0x000099<ept i="3">&lt;/c3&gt;</ept> already equals <bpt i="4" x="4">&lt;c4&gt;</bpt>0x99<ept i="4">&lt;/c4&gt;</ept>, which has a decimal value of <bpt i="5" x="5">&lt;c5&gt;</bpt>153<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>0x000099<ept i="3">&lt;/c3&gt;</ept>がすでに<bpt i="4" x="4">&lt;c4&gt;</bpt>0x99<ept i="4">&lt;/c4&gt;</ept>に等しいので、これを右へシフトする必要はありません、それは10進の値の<bpt i="5" x="5">&lt;c5&gt;</bpt>153<ept i="5">&lt;/c5&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There’s nothing stopping you from having a tuple of type <bpt i="0" x="0">&lt;c0&gt;</bpt>(Int, Int, Int)<ept i="0">&lt;/c0&gt;</ept>, or <bpt i="1" x="1">&lt;c1&gt;</bpt>(String, Bool)<ept i="1">&lt;/c1&gt;</ept>, or indeed any other permutation you require.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>(Int, Int, Int)<ept i="0">&lt;/c0&gt;</ept>の型のタプル、または<bpt i="1" x="1">&lt;c1&gt;</bpt>(String, Bool)<ept i="1">&lt;/c1&gt;</ept>、またはあなたが実際に必要とするあらゆる他の順列を持つのを止めるものは何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There’s one caveat to the rules above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つのただし書きが、上の規則にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These <bpt i="0" x="0">&lt;e0&gt;</bpt>attribute arguments<ept i="0">&lt;/e0&gt;</ept> are enclosed in parentheses, and their format is defined by the attribute they belong to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの<bpt i="0" x="0">&lt;e0&gt;</bpt>属性引数<ept i="0">&lt;/e0&gt;</ept>は丸括弧に囲まれます、そして、それらの形式はそれらが属している属性によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These <bpt i="1" x="1">&lt;e1&gt;</bpt>declarations<ept i="1">&lt;/e1&gt;</ept> can include both stored and computed properties, instance methods, type methods, initializers, a single deinitializer, subscripts, type aliases, and even other class, structure, and enumeration declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの<bpt i="1" x="1">&lt;e1&gt;</bpt>宣言<ept i="1">&lt;/e1&gt;</ept>は、保存または計算プロパティの双方、インスタンスメソッド、型メソッド、イニシャライザ、一つだけのデイニシャライザ、添え字、型エイリアス、そして他のクラス、構造体、および列挙宣言さえも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These <bpt i="1" x="1">&lt;e1&gt;</bpt>declarations<ept i="1">&lt;/e1&gt;</ept> can include both stored and computed properties, type properties, instance methods, type methods, initializers, subscripts, type aliases, and even other structure, class, and enumeration declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの<bpt i="1" x="1">&lt;e1&gt;</bpt>宣言<ept i="1">&lt;/e1&gt;</ept>は、保存または計算プロパティの双方、型プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、添え字、型エイリアス、そして他の構造体、クラス、および列挙宣言さえも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These <bpt i="1" x="1">&lt;e1&gt;</bpt>declarations<ept i="1">&lt;/e1&gt;</ept> can include computed properties, computed type properties, instance methods, type methods, initializers, subscript declarations, and even class, structure, and enumeration declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの<bpt i="1" x="1">&lt;e1&gt;</bpt>宣言<ept i="1">&lt;/e1&gt;</ept>は、計算プロパティ、計算型プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、添え字宣言、そしてクラス、構造体、そして列挙宣言さえも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These access levels are relative to the source file in which an entity is defined, and also relative to the module that source file belongs to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのアクセス水準は、ある実在が定義されているソースファイルと関連しています、そのうえに、ソースファイルが属しているモジュールとも関連しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These actions are described in the following sections.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの行いは、以下の節で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These are custom classes, structures, and enumerations that can work with <bpt i="1" x="1">&lt;e1&gt;</bpt>any<ept i="1">&lt;/e1&gt;</ept> type, in a similar way to <bpt i="2" x="2">&lt;c2&gt;</bpt>Array<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらは、<bpt i="1" x="1">&lt;e1&gt;</bpt>Array<ept i="1">&lt;/e1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>Dictionary<ept i="2">&lt;/c2&gt;</ept>に類似した方法で、<bpt i="3" x="3">&lt;c3&gt;</bpt>あらゆる<ept i="3">&lt;/c3&gt;</ept>型で扱うことができる特注のクラス、構造体、そして列挙があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These are followed by a “check” digit to verify that the code has been scanned correctly:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの後にコードが正しくスキャンされたことを確認するための一つの「チェック」桁が続きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These are known as constants, and are much more powerful than constants in C. Constants are used throughout Swift to make code safer and clearer in intent when you work with values that don’t need to change.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらは定数として知られています、そしてCにおける定数よりずっと強力です。定数は、変わる必要がない値をあなたが扱う時、コードをより安全により明白にする意図でスウィフトを通して使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These are known as designated initializers and convenience initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらは、指定イニシャライザと便宜イニシャライザとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These are used as the two input values for the provided math function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらは提供された数学関数のための２つの入力値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These arguments begin with one of the following platform or language names:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの引数は、以下のプラットホームまたは言語名の１つで始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These attributes are conceptually the same as their Objective-C counterparts.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの属性は、概念的にそれらのObjective-Cでの対応物と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These classes expand upon the <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Residence<ept i="1">&lt;/c1&gt;</ept> model from above by adding a <bpt i="2" x="2">&lt;c2&gt;</bpt>Room<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Address<ept i="3">&lt;/c3&gt;</ept> class, with associated properties, methods, and subscripts.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのクラスは、関連するプロパティ、メソッド、そして添え字とともに<bpt i="2" x="2">&lt;c2&gt;</bpt>Room<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>Address<ept i="3">&lt;/c3&gt;</ept>クラスを加えることによって、上記の<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Residence<ept i="1">&lt;/c1&gt;</ept>モデルを拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These computed properties express that a <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> value should be considered as a certain unit of length.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの計算プロパティは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>値が長さの特定の単位とみなされなければならないことを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These constants (or variables) can then be referenced in a corresponding <bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept> clause and throughout the rest of the code within the scope of the case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの定数（または変数）は、それから対応する<bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept>節の中で、そしてそのケース節のスコープ内のその他のコードのいたるところで参照されることができます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These constants are used as part of a <bpt i="4" x="4">&lt;c4&gt;</bpt>where<ept i="4">&lt;/c4&gt;</ept> clause, to create a dynamic filter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの定数は、<bpt i="4" x="4">&lt;c4&gt;</bpt>where<ept i="4">&lt;/c4&gt;</ept>節の一部として動的なフィルタを作成するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These functions and methods are known as <bpt i="1" x="1">&lt;e1&gt;</bpt>rethrowing functions<ept i="1">&lt;/e1&gt;</ept> and <bpt i="2" x="2">&lt;e2&gt;</bpt>rethrowing methods<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの関数とメソッドは、<bpt i="1" x="1">&lt;e1&gt;</bpt>再スロー関数<ept i="1">&lt;/e1&gt;</ept>と<bpt i="2" x="2">&lt;e2&gt;</bpt>再スローメソッド<ept i="2">&lt;/e2&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These functions and methods are known as <bpt i="1" x="1">&lt;e1&gt;</bpt>throwing functions<ept i="1">&lt;/e1&gt;</ept> and <bpt i="2" x="2">&lt;e2&gt;</bpt>throwing methods<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの関数とメソッドは<bpt i="1" x="1">&lt;e1&gt;</bpt>スロー関数<ept i="1">&lt;/e1&gt;</ept>および<bpt i="2" x="2">&lt;e2&gt;</bpt>スローメソッド<ept i="2">&lt;/e2&gt;</ept>として知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These functions each take two <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> values, and return an <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> value, which is the result of performing an appropriate mathematical operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの関数は、各々２つの<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>値をとって、１つの<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>値を返します、そしてそれは、適切な数値演算の実行の結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These include <bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> loops to perform a task multiple times; <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>guard<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> statements to execute different branches of code based on certain conditions; and statements such as <bpt i="4" x="4">&lt;c4&gt;</bpt>break<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>continue<ept i="5">&lt;/c5&gt;</ept> to transfer the flow of execution to another point in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらは、ある作業を複数回実行する<bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>ループ；特定の条件に基づいてコードの異なる分岐を実行する<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>guard<ept i="2">&lt;/c2&gt;</ept>、および<bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>文；そして実行の流れをあなたのコードの別の地点に移す、<bpt i="4" x="4">&lt;c4&gt;</bpt>break<ept i="4">&lt;/c4&gt;</ept>および<bpt i="5" x="5">&lt;c5&gt;</bpt>continue<ept i="5">&lt;/c5&gt;</ept>のような文を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらは、あなたがCとObjective-Cからお馴染みの、ビット単位およびビットシフト演算子の全てを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These include enumeration case patterns, optional patterns, expression patterns, and type-casting patterns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらは、列挙ケース節パターン、オプショナルパターン、式パターン、および型キャストパターンを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These include the UTF-8 encoding form (which encodes a string as 8-bit code units), the UTF-16 encoding form (which encodes a string as 16-bit code units), and the UTF-32 encoding form (which encodes a string as 32-bit code units).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらは、UTF-８符号化方式（それは、８ビット符号単位として文字列を符号化します）、UTF-16符号化方式（それは、16ビット符号単位として文字列を符号化します）、そしてUTF-32符号化方式（それは、32ビット符号単位として文字列を符号化します）を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These include wildcard patterns, identifier patterns, and any value binding or tuple patterns containing them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらはワイルドカード・パターン、識別子パターン、そしてそれらを含むあらゆる値束縛やタプルパターンを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These initialization options are represented by three custom initializers that are part of the <bpt i="3" x="3">&lt;c3&gt;</bpt>Rect<ept i="3">&lt;/c3&gt;</ept> structure’s definition:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの初期化オプションは、<bpt i="3" x="3">&lt;c3&gt;</bpt>Rect<ept i="3">&lt;/c3&gt;</ept>構造体の定義の一部である３つのあつらえのイニシャライザによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These initializers can be used to create new <bpt i="3" x="3">&lt;c3&gt;</bpt>Rect<ept i="3">&lt;/c3&gt;</ept> instances:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのイニシャライザが、新しい<bpt i="3" x="3">&lt;c3&gt;</bpt>Rect<ept i="3">&lt;/c3&gt;</ept>例をつくるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These integers follow a naming convention similar to C, in that an 8-bit unsigned integer is of type <bpt i="0" x="0">&lt;c0&gt;</bpt>UInt8<ept i="0">&lt;/c0&gt;</ept>, and a 32-bit signed integer is of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Int32<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの整数は、８ビットの符号なし整数が型<bpt i="0" x="0">&lt;c0&gt;</bpt>UInt8<ept i="0">&lt;/c0&gt;</ept>である、そして32ビットの符号つき整数が型<bpt i="1" x="1">&lt;c1&gt;</bpt>Int32<ept i="1">&lt;/c1&gt;</ept>であるという点で、Cに似ている命名規則に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These keywords are described in the sections below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのキーワードは、以下の節で解説されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These kinds of closures or functions typically create a temporary value of the same type as the property, tailor that value to represent the desired initial state, and then return that temporary value to be used as the property’s default value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの種類のクロージャまたは関数は、概してプロパティと同じ型の一時的な値をつくって、望み通りの初期状態を表すようにその値を仕立てて、それからその一時的な値がプロパティの省略時の値として使われるように返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These kinds of loops are best used when the number of iterations is not known before the first iteration begins.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの種類のループが最も使われるのは、繰り返しの回数が最初の繰り返しが始まる前にはわからないときです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These kinds of methods are called <bpt i="0" x="0">&lt;e0&gt;</bpt>type methods<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの種類のメソッドは、<bpt i="0" x="0">&lt;e0&gt;</bpt>型メソッド<ept i="0">&lt;/e0&gt;</ept>と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These kinds of optionals are defined as <bpt i="0" x="0">&lt;e0&gt;</bpt>implicitly unwrapped optionals<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの種類のオプショナルは、<bpt i="0" x="0">&lt;e0&gt;</bpt>暗黙的にアンラップされるオプショナル<ept i="0">&lt;/e0&gt;</ept>として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These kinds of properties are called <bpt i="0" x="0">&lt;e0&gt;</bpt>type properties<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの種類のプロパティは、<bpt i="0" x="0">&lt;e0&gt;</bpt>型プロパティ<ept i="0">&lt;/e0&gt;</ept>と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These methods are marked as <bpt i="5" x="5">&lt;c5&gt;</bpt>mutating<ept i="5">&lt;/c5&gt;</ept>, because they need to modify (or <bpt i="6" x="6">&lt;e6&gt;</bpt>mutate<ept i="6">&lt;/e6&gt;</ept>) the structure’s <bpt i="7" x="7">&lt;c7&gt;</bpt>items<ept i="7">&lt;/c7&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのメソッドは<bpt i="5" x="5">&lt;c5&gt;</bpt>mutating<ept i="5">&lt;/c5&gt;</ept>として印されます、なぜなら、それらが構造体の<bpt i="7" x="7">&lt;c7&gt;</bpt>items<ept i="7">&lt;/c7&gt;</ept>配列を修正する（または<bpt i="6" x="6">&lt;e6&gt;</bpt>変化させる<ept i="6">&lt;/e6&gt;</ept>）必要があるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These methods are written as part of the protocol’s definition in exactly the same way as for normal instance and type methods, but without curly braces or a method body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのメソッドは、プロトコルの定義の一部として普通のインスタンスおよび型メソッドと正確に同じ方法で書かれます、しかし波括弧またはメソッド本文はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These names are valid identifiers within the scope of the closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの名前は、クロージャのスコープ内で有効な識別子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These operators all begin with an ampersand (<bpt i="1" x="1">&lt;c1&gt;</bpt>&amp;<ept i="1">&lt;/c1&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの演算子は、全てアンパサンド（<bpt i="1" x="1">&lt;c1&gt;</bpt>&amp;<ept i="1">&lt;/c1&gt;</ept>）で始まります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These operators are now used only with <bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの演算子は今では<bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>値でのみ使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These operators can be used and adopted in your code like any of the predefined operators, and you can even extend existing types to support the custom operators you define.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの演算子は、あらかじめ定義された演算子のどれとも同じように、使用されることができ、あなたのコードにおいて取り入れられることができます、そして、あなたはあなたが定義するカスタム演算子をサポートするように既存の型を拡張することさえ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These operators can contain additional dots.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの演算子は、さらなるドットを含むことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These optimizations include:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの最適化は、以下を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These options are described later in this chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの選択肢は、この章の後刻に記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These overrides ensure that an <bpt i="4" x="4">&lt;c4&gt;</bpt>AutomaticallyNamedDocument<ept i="4">&lt;/c4&gt;</ept> instance has an initial <bpt i="5" x="5">&lt;c5&gt;</bpt>name<ept i="5">&lt;/c5&gt;</ept> value of <bpt i="6" x="6">&lt;c6&gt;</bpt>"[Untitled]"<ept i="6">&lt;/c6&gt;</ept> if the instance is initialized without a name, or if an empty string is passed to the <bpt i="7" x="7">&lt;c7&gt;</bpt>init(name:)<ept i="7">&lt;/c7&gt;</ept> initializer:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのオーバーライドは、<bpt i="4" x="4">&lt;c4&gt;</bpt>AutomaticallyNamedDocument<ept i="4">&lt;/c4&gt;</ept>インスタンスが、そのインスタンスが名前なしで初期化されたならば、または空の文字列が<bpt i="7" x="7">&lt;c7&gt;</bpt>init(name:)<ept i="7">&lt;/c7&gt;</ept>イニシャライザに渡されたならば、初期<bpt i="5" x="5">&lt;c5&gt;</bpt>name<ept i="5">&lt;/c5&gt;</ept>値の<bpt i="6" x="6">&lt;c6&gt;</bpt>"[Untitled]"<ept i="6">&lt;/c6&gt;</ept>を持つことを確実にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These pairings are written within a pair of square braces, separated by commas.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの組合せは、一対の角括弧内に書かれて、コンマで区切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These properties are read-only computed properties, and so they are expressed without the <bpt i="0" x="0">&lt;c0&gt;</bpt>get<ept i="0">&lt;/c0&gt;</ept> keyword, for brevity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのプロパティは、読み出し専用の計算プロパティです、それでそれらは簡潔さのために、<bpt i="0" x="0">&lt;c0&gt;</bpt>get<ept i="0">&lt;/c0&gt;</ept>キーワードなしで表わされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These properties store a value between <bpt i="4" x="4">&lt;c4&gt;</bpt>0.0<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>1.0<ept i="5">&lt;/c5&gt;</ept> to indicate the amount of red, green, and blue in the color.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのプロパティは、<bpt i="4" x="4">&lt;c4&gt;</bpt>0.0<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>1.0<ept i="5">&lt;/c5&gt;</ept>の間の値を格納して、その色における赤、緑、および青の量を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These requirements define two different ways for data sources to provide an appropriate increment amount for a <bpt i="3" x="3">&lt;c3&gt;</bpt>Counter<ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの要件は、データ・ソースのために<bpt i="3" x="3">&lt;c3&gt;</bpt>Counter<ept i="3">&lt;/c3&gt;</ept>インスタンスに適切な増加量を用意する２つの異なる方法を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These requirements enable the <bpt i="0" x="0">&lt;c0&gt;</bpt>allItemsMatch(_:_:)<ept i="0">&lt;/c0&gt;</ept> function to compare the two containers, even if they’re of a different container type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの要件は、<bpt i="0" x="0">&lt;c0&gt;</bpt>allItemsMatch(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数に２つのコンテナを比較するのを可能にします、たとえそれらが異なるコンテナ型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These requirements mean:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの要件が意味するのは：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These responsibilities are described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Class Inheritance and Initialization<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの責任は、下記の<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>クラス継承と初期化<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These rules apply even if your subclass adds further convenience initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの規則は、たとえあなたのサブクラスが更なる便宜イニシャライザを加えるとしてもあてはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These rules are illustrated in the figure below:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの規則は、下の図で説明されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These rules don’t affect how users of your classes <bpt i="0" x="0">&lt;e0&gt;</bpt>create<ept i="0">&lt;/e0&gt;</ept> instances of each class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの規則は、あなたのクラスのユーザーが各クラスのインスタンスを<bpt i="0" x="0">&lt;e0&gt;</bpt>作成する<ept i="0">&lt;/e0&gt;</ept>方法に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These statements are indicated by the <bpt i="4" x="4">&lt;c4&gt;</bpt>else<ept i="4">&lt;/c4&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの文は、<bpt i="4" x="4">&lt;c4&gt;</bpt>else<ept i="4">&lt;/c4&gt;</ept>キーワードによって指し示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These three capabilities match the requirements of the <bpt i="4" x="4">&lt;c4&gt;</bpt>Container<ept i="4">&lt;/c4&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの３つの能力は、<bpt i="4" x="4">&lt;c4&gt;</bpt>Container<ept i="4">&lt;/c4&gt;</ept>プロトコルの要件に合致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These three methods have been incorporated into the game logic within the <bpt i="1" x="1">&lt;c1&gt;</bpt>play()<ept i="1">&lt;/c1&gt;</ept> method above, and are called when a new game starts, a new turn begins, or the game ends.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの３つのメソッドは、上の<bpt i="1" x="1">&lt;c1&gt;</bpt>play()<ept i="1">&lt;/c1&gt;</ept>メソッド内のゲーム論理に組み込まれています、そして、新しいゲームが始まるとき、新しいターンを開始するとき、あるいはこのゲームが終わるとき、呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These tokens can’t be overloaded, nor can they be used as custom operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのトークンは、オーバーロードされることができませんし、それらはあつらえの演算子として使われることもできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These two classes each store an instance of the other class as a property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの２つのクラスは、それぞれ他のクラスのインスタンスをプロパティとして格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These two operators provide a simple and expressive way to check the type of a value or cast a value to a different type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの２つの演算子は、値の型を調べたり、値を異なる型にキャストする（配役する、投げ込む）ための単純で表現豊かな方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These two properties are inferred to be of type <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> by setting them to an initial integer value of <bpt i="4" x="4">&lt;c4&gt;</bpt>0<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの２つのプロパティは、それらを最初の整数値<bpt i="4" x="4">&lt;c4&gt;</bpt>0<ept i="4">&lt;/c4&gt;</ept>に設定することによって型<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>であると推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These two statements call the subscript’s setter to set a value of <bpt i="0" x="0">&lt;c0&gt;</bpt>1.5<ept i="0">&lt;/c0&gt;</ept> in the top right position of the matrix (where <bpt i="1" x="1">&lt;c1&gt;</bpt>row<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>column<ept i="3">&lt;/c3&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept>), and <bpt i="5" x="5">&lt;c5&gt;</bpt>3.2<ept i="5">&lt;/c5&gt;</ept> in the bottom left position (where <bpt i="6" x="6">&lt;c6&gt;</bpt>row<ept i="6">&lt;/c6&gt;</ept> is <bpt i="7" x="7">&lt;c7&gt;</bpt>1<ept i="7">&lt;/c7&gt;</ept> and <bpt i="8" x="8">&lt;c8&gt;</bpt>column<ept i="8">&lt;/c8&gt;</ept> is <bpt i="9" x="9">&lt;c9&gt;</bpt>0<ept i="9">&lt;/c9&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの２つの文は、添え字のセッターを呼び出して、この行列の右上位置（<bpt i="1" x="1">&lt;c1&gt;</bpt>row<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>で<bpt i="3" x="3">&lt;c3&gt;</bpt>column<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept>のところ）に<bpt i="0" x="0">&lt;c0&gt;</bpt>1.5<ept i="0">&lt;/c0&gt;</ept>の値を、そして左下位置（<bpt i="6" x="6">&lt;c6&gt;</bpt>row<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>1<ept i="7">&lt;/c7&gt;</ept>で<bpt i="8" x="8">&lt;c8&gt;</bpt>column<ept i="8">&lt;/c8&gt;</ept>が<bpt i="9" x="9">&lt;c9&gt;</bpt>0<ept i="9">&lt;/c9&gt;</ept>のところ）に<bpt i="5" x="5">&lt;c5&gt;</bpt>3.2<ept i="5">&lt;/c5&gt;</ept>を設定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These type parameters act as placeholders that are replaced by actual concrete type arguments when an instance of a generic type is created or a generic function or initializer is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの型パラメータは、総称体型のインスタンスがつくられる、あるいは、総称体の関数やイニシャライザが呼ばれるとき、実際の具体的な型引数と取り替えられるプレースホルダの働きをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These types are not the same as <bpt i="8" x="8">&lt;c8&gt;</bpt>() -&gt; ()<ept i="8">&lt;/c8&gt;</ept>—a function that takes no arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの型は、<bpt i="8" x="8">&lt;c8&gt;</bpt>() -&gt; ()<ept i="8">&lt;/c8&gt;</ept> — 引数を取らない関数、と同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These types are specified in the <bpt i="1" x="1">&lt;e1&gt;</bpt>associated value types<ept i="1">&lt;/e1&gt;</ept> tuple, immediately following the name of the case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの型は、ケース節の名前の直後に、それら<bpt i="1" x="1">&lt;e1&gt;</bpt>関連値型<ept i="1">&lt;/e1&gt;</ept>のタプルを使って指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These valid tokens form the lowest-level building blocks of the language and are used to describe the rest of the language in subsequent chapters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの公式のトークンは、言語の最も基本的な建物ブロックを形成して、以降の章において言語の残りの部分を記述するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These values are a high-surrogate value of <bpt i="4" x="4">&lt;c4&gt;</bpt>U+D83D<ept i="4">&lt;/c4&gt;</ept> (decimal value <bpt i="5" x="5">&lt;c5&gt;</bpt>55357<ept i="5">&lt;/c5&gt;</ept>) and a low-surrogate value of <bpt i="6" x="6">&lt;c6&gt;</bpt>U+DC36<ept i="6">&lt;/c6&gt;</ept> (decimal value <bpt i="7" x="7">&lt;c7&gt;</bpt>56374<ept i="7">&lt;/c7&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの値は、前半代用値の<bpt i="4" x="4">&lt;c4&gt;</bpt>U+D83D<ept i="4">&lt;/c4&gt;</ept>（10進の値<bpt i="5" x="5">&lt;c5&gt;</bpt>55357<ept i="5">&lt;/c5&gt;</ept>）と後半代用値の<bpt i="6" x="6">&lt;c6&gt;</bpt>U+DC36<ept i="6">&lt;/c6&gt;</ept>（10進の値<bpt i="7" x="7">&lt;c7&gt;</bpt>56374<ept i="7">&lt;/c7&gt;</ept>）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These values are labeled <bpt i="2" x="2">&lt;c2&gt;</bpt>min<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>max<ept i="3">&lt;/c3&gt;</ept> so that they can be accessed by name when querying the function’s return value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの値は、<bpt i="2" x="2">&lt;c2&gt;</bpt>min<ept i="2">&lt;/c2&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt>max<ept i="3">&lt;/c3&gt;</ept>とラベルをつけられます、なのでそれらはこの関数の戻り値について問い合わせるときに名前によってアクセスされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These values are represented as optionals.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このような値は、オプショナルであるとして表現されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These variations on function syntax are discussed below in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Function Argument Labels and Parameter Names<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> and <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Default Parameter Values<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数構文上のこれらの差異は、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>関数の引数ラベルとパラメータ名<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>と<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>省略時のパラメータ値<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>の下で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration’s current value, and instance methods to provide functionality related to the values the enumeration represents.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらはクラスによってのみ伝統的に支えられる多くの特徴を採用します、例えば列挙の現在の値に関する追加の情報を提供する計算プロパティ、そして、列挙が表す値に関連した機能性を提供するインスタンスメソッドなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They are <bpt i="1" x="1">&lt;e1&gt;</bpt>prefix<ept i="1">&lt;/e1&gt;</ept> if they precede their target (such as <bpt i="2" x="2">&lt;c2&gt;</bpt>-a<ept i="2">&lt;/c2&gt;</ept>) and <bpt i="3" x="3">&lt;e3&gt;</bpt>postfix<ept i="3">&lt;/e3&gt;</ept> operators if they follow their target (such as <bpt i="4" x="4">&lt;c4&gt;</bpt>b!<ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは、それがその目標に先行するならば<bpt i="1" x="1">&lt;e1&gt;</bpt>接頭辞<ept i="1">&lt;/e1&gt;</ept>（例えば<bpt i="2" x="2">&lt;c2&gt;</bpt>-a<ept i="2">&lt;/c2&gt;</ept>）、それがその目標の後に続くならば<bpt i="3" x="3">&lt;e3&gt;</bpt>接尾辞<ept i="3">&lt;/e3&gt;</ept>演算子です（例えば<bpt i="4" x="4">&lt;c4&gt;</bpt>b!<ept i="4">&lt;/c4&gt;</ept>）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They are guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they do not need to be marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>lazy<ept i="0">&lt;/c0&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは、ただ１度だけ初期化されることを保証されます、複数のスレッドによって同時にアクセスされる場合でさえもです、そしてそれらは<bpt i="0" x="0">&lt;c0&gt;</bpt>lazy<ept i="0">&lt;/c0&gt;</ept>修飾子で印されることを必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They are not called while a class is setting its own properties, before the superclass initializer has been called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは、スーパークラスイニシャライザが呼び出され終わる前、あるクラスがそれ自身のプロパティを設定している間には呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They are often used in low-level programming, such as graphics programming and device driver creation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらが、低階層のプログラミング、例えばグラフィックス・プログラミングやデバイスドライバー作成において、しばしば使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They are stored by subtracting their absolute value from <bpt i="0" x="0">&lt;c0&gt;</bpt>2<ept i="0">&lt;/c0&gt;</ept> to the power of <bpt i="1" x="1">&lt;c1&gt;</bpt>n<ept i="1">&lt;/c1&gt;</ept>, where <bpt i="2" x="2">&lt;c2&gt;</bpt>n<ept i="2">&lt;/c2&gt;</ept> is the number of value bits.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは、<bpt i="0" x="0">&lt;c0&gt;</bpt>2<ept i="0">&lt;/c0&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>n<ept i="1">&lt;/c1&gt;</ept>乗からそれらの絶対値を減ずることによって保存されます、そこで、<bpt i="2" x="2">&lt;c2&gt;</bpt>n<ept i="2">&lt;/c2&gt;</ept>は値ビットの数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They can be used as expressions on their own, and they can be combined with other tokens to make prefix expressions, binary expressions, and postfix expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらはそれら自身で式として使われることができます、そしてそれらは接頭辞式、二項式、そして接尾辞式を作るために別のトークンと組み合わされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They can’t be added together directly, because they’re not of the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは直接にひとつに加算されることができません、それらが同じ型でないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They can’t be adopted by structures or enumerations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは構造体や列挙によって採用されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They continue to be a <bpt i="0" x="0">&lt;c0&gt;</bpt>Circle<ept i="0">&lt;/c0&gt;</ept>, a <bpt i="1" x="1">&lt;c1&gt;</bpt>Country<ept i="1">&lt;/c1&gt;</ept> and an <bpt i="2" x="2">&lt;c2&gt;</bpt>Animal<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Circle<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Country<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>Animal<ept i="2">&lt;/c2&gt;</ept>であり続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They could prefer one mark every <bpt i="0" x="0">&lt;c0&gt;</bpt>5<ept i="0">&lt;/c0&gt;</ept> minutes instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>彼らは、代わりに<bpt i="0" x="0">&lt;c0&gt;</bpt>5<ept i="0">&lt;/c0&gt;</ept>分毎に１つの印を選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They have the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらは以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They must always explicitly declare their adoption of the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは、常に明示的にそのプロトコルについてそれらが採用することを宣言しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They must always have a number (or hexadecimal number) on both sides of the decimal point.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは、常に小数点の両側で数（または16進の数）を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They must have a set value before first use.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは最初に使用される前に値を設定される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They support the functionality of those instances, either by providing ways to access and modify instance properties, or by providing functionality related to the instance’s purpose.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、そういったもののインスタンスの機能性を、インスタンスプロパティにアクセスしたり修正したりする方法を提供することで、またはインスタンスの目的と関連がある機能性を提供することでのどちらかで支えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They themselves do not describe a specific resolution or video mode.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらはそれら自体で、特定の解像度またはビデオ・モードを記述しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They’re both optional, after all.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結局、それらは両方ともオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>They’re not suited to the creation of complex data structures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらは、複雑なデータ構造物の作成には適していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Think of it as meaning “they associate with the expression to their left,” or “they associate with the expression to their right.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは「それらは、式をそれらの左と結びつける」あるいは「それらは、式をそれらの右と結びつける」を意味すると考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Think of this as adding implicit parentheses around these parts of the expression, starting from their left:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを、これらの式部分のまわりに、暗黙の括弧をそれらの左から開始して加えることと考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement does not have a <bpt i="1" x="1">&lt;c1&gt;</bpt>default<ept i="1">&lt;/c1&gt;</ept> case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文には<bpt i="1" x="1">&lt;c1&gt;</bpt>default<ept i="1">&lt;/c1&gt;</ept>ケース節がない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This <bpt i="1" x="1">&lt;c1&gt;</bpt>Player<ept i="1">&lt;/c1&gt;</ept> instance is stored in an optional <bpt i="2" x="2">&lt;c2&gt;</bpt>Player<ept i="2">&lt;/c2&gt;</ept> variable called <bpt i="3" x="3">&lt;c3&gt;</bpt>playerOne<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="1" x="1">&lt;c1&gt;</bpt>Player<ept i="1">&lt;/c1&gt;</ept>インスタンスは、<bpt i="3" x="3">&lt;c3&gt;</bpt>playerOne<ept i="3">&lt;/c3&gt;</ept>と呼ばれるオプショナルの<bpt i="2" x="2">&lt;c2&gt;</bpt>Player<ept i="2">&lt;/c2&gt;</ept>変数に保存されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This <bpt i="2" x="2">&lt;c2&gt;</bpt>default<ept i="2">&lt;/c2&gt;</ept> case does not need to perform any action, and so it is written with a single <bpt i="3" x="3">&lt;c3&gt;</bpt>break<ept i="3">&lt;/c3&gt;</ept> statement as its body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="2" x="2">&lt;c2&gt;</bpt>default<ept i="2">&lt;/c2&gt;</ept>ケース節はいかなる動作も実行する必要がありません、なのでそれはその本文として<bpt i="3" x="3">&lt;c3&gt;</bpt>break<ept i="3">&lt;/c3&gt;</ept>文ひとつだけを書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This action ensures that signed integers have the same sign after they are shifted to the right, and is known as an <bpt i="0" x="0">&lt;e0&gt;</bpt>arithmetic shift<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この動作は、符号つき整数が、それが右へシフトされた後に同じサインを持つことを確実にします、そして<bpt i="0" x="0">&lt;e0&gt;</bpt>算術シフト<ept i="0">&lt;/e0&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This aids code consistency and interoperability.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、コードの整合性と相互運用性を支援します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This allows you to define behavior on protocols themselves, rather than in each type’s individual conformance or in a global function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはあなたに、それぞれの型の個々の準拠においてまたはグローバル関数においてではなく、プロトコルそれ自体に振る舞いを定義することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This also means that if you assign a closure to two different constants or variables, both of those constants or variables will refer to the same closure:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはまた、あなたがクロージャを２つの異なる定数または変数に代入するならば、それらの定数または変数の両方とも同じクロージャに言及することを意味します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This approach assumes that the method’s caller knows there’s a special value to test against and remembers to check for it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このアプローチは、メソッドの呼び出し側が試験するべき特別な値があるのを知っていて、それについて調べるのを忘れないでいると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This approach avoids accidental fallthrough from one case to another and makes for safer code that is clearer in its intent.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この取り組み方は、１つのケース節から他のものへの思いがけない抜け落ちを防止してより安全なコード、その意図するところがより明白であること、に寄与します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This approach avoids confusion about how the value is accessed in different contexts and simplifies the property’s declaration into a single, definitive statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この取り組み方は、値が異なる文脈においてアクセスされる方法についての混乱を避け、プロパティの宣言をただ１つの、決定的な文に単純化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This approach is different from string mutation in Objective-C and Cocoa, where you choose between two classes (<bpt i="0" x="0">&lt;c0&gt;</bpt>NSString<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NSMutableString<ept i="1">&lt;/c1&gt;</ept>) to indicate whether a string can be mutated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この取り組みは、Objective-Cとココアでの文字列変化と異なります、そこでは、あなたは文字列が変化することができるかどうか示すために、２つのクラス（<bpt i="0" x="0">&lt;c0&gt;</bpt>NSString<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>NSMutableString<ept i="1">&lt;/c1&gt;</ept>）のどちらかを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This approach is known as a <bpt i="0" x="0">&lt;e0&gt;</bpt>logical shift<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このやり方は、<bpt i="0" x="0">&lt;e0&gt;</bpt>論理シフト<ept i="0">&lt;/e0&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This argument can’t be used when specifying Swift version availability.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この引数は、スウィフトバージョン利用可能性を指定する時に使われることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This assumption is demonstrated by the use of <bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept> (rather than <bpt i="3" x="3">&lt;c3&gt;</bpt>self.count<ept i="3">&lt;/c3&gt;</ept>) inside the three instance methods for <bpt i="4" x="4">&lt;c4&gt;</bpt>Counter<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この仮定は、<bpt i="4" x="4">&lt;c4&gt;</bpt>Counter<ept i="4">&lt;/c4&gt;</ept>のための３つのインスタンスメソッド内部での（<bpt i="3" x="3">&lt;c3&gt;</bpt>self.count<ept i="3">&lt;/c3&gt;</ept>ではなく）<bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept>の使用によって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This attribute causes the property’s setter to be synthesized with a <bpt i="0" x="0">&lt;e0&gt;</bpt>copy<ept i="0">&lt;/e0&gt;</ept> of the property’s value—returned by the <bpt i="1" x="1">&lt;c1&gt;</bpt>copyWithZone(_:)<ept i="1">&lt;/c1&gt;</ept> method—instead of the value of the property itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性は、プロパティのセッターがそのプロパティの値の<bpt i="0" x="0">&lt;e0&gt;</bpt>コピー<ept i="0">&lt;/e0&gt;</ept> ― <bpt i="1" x="1">&lt;c1&gt;</bpt>copyWithZone(_:)<ept i="1">&lt;/c1&gt;</ept>メソッドによって返されるもの ― を使って合成されるようにします、プロパティそれ自体の値ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This attribute is used to delay the evaluation of an expression by automatically wrapping that expression in a closure with no arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性は、ある式の評価を、自動的にその式を引数のないクロージャの中に包み込むことによって延期するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This base class declares a stored property called <bpt i="1" x="1">&lt;c1&gt;</bpt>numberOfWheels<ept i="1">&lt;/c1&gt;</ept>, with a default <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> value of <bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この基盤クラスは<bpt i="1" x="1">&lt;c1&gt;</bpt>numberOfWheels<ept i="1">&lt;/c1&gt;</ept>と呼ばれる保存プロパティを、省略時の値として<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>値<bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>を使って、宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This base class defines a stored property called <bpt i="1" x="1">&lt;c1&gt;</bpt>currentSpeed<ept i="1">&lt;/c1&gt;</ept>, with a default value of <bpt i="2" x="2">&lt;c2&gt;</bpt>0.0<ept i="2">&lt;/c2&gt;</ept> (inferring a property type of <bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この基盤クラスは、<bpt i="1" x="1">&lt;c1&gt;</bpt>currentSpeed<ept i="1">&lt;/c1&gt;</ept>と呼ばれる保存プロパティを定義します、それは<bpt i="2" x="2">&lt;c2&gt;</bpt>0.0<ept i="2">&lt;/c2&gt;</ept>の省略時の値を持ちます（<bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept>の型のプロパティと推論されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This behavior can be used to match and ignore one or more cases in a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挙動は、<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文の一つ以上のケース節を適合してから無視することのために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This behavior gives extra safety when you work with numbers that are too large or too small.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挙動は、あまりに大きいかあまりに小さい数をあなたが扱うとき、追加の安全を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This behavior is communicated by a getter and setter in the same way as for computed properties:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挙動は、計算プロパティに関してと同様に、ゲッターとセッターによって伝えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This behavior is different from Foundation: <bpt i="0" x="0">&lt;c0&gt;</bpt>NSString<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>NSArray<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>NSDictionary<ept i="2">&lt;/c2&gt;</ept> are implemented as classes, not structures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挙動は、Foundationとは異なります：<bpt i="0" x="0">&lt;c0&gt;</bpt>NSString<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>NSArray<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>NSDictionary<ept i="2">&lt;/c2&gt;</ept>は、構造体ではなくクラスとして実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This behavior is different from other types, where a public type definition implies an access level of internal for the type’s members.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挙動は他の型とは異なります、そこにおいて、公開型定義は、その型のメンバーに対して内部アクセス水準を暗黙的に意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This behavior is due to structures being <bpt i="0" x="0">&lt;e0&gt;</bpt>value types<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挙動は、この構造体が<bpt i="0" x="0">&lt;e0&gt;</bpt>値型<ept i="0">&lt;/e0&gt;</ept>であるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This behavior is known as <bpt i="0" x="0">&lt;e0&gt;</bpt>copy-in copy-out<ept i="0">&lt;/e0&gt;</ept> or <bpt i="1" x="1">&lt;e1&gt;</bpt>call by value result<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挙動は、<bpt i="0" x="0">&lt;e0&gt;</bpt>コピーイン・コピーアウト<ept i="0">&lt;/e0&gt;</ept>または<bpt i="1" x="1">&lt;e1&gt;</bpt>結果値による呼び出し<ept i="1">&lt;/e1&gt;</ept>として知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This behavior is known as <bpt i="1" x="1">&lt;e1&gt;</bpt>value binding<ept i="1">&lt;/e1&gt;</ept>, because the values are bound to temporary constants or variables within the case’s body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挙動は<bpt i="1" x="1">&lt;e1&gt;</bpt>値束縛<ept i="1">&lt;/e1&gt;</ept>として知られています、なぜなら値がそのケース節の本文内の一時的な定数または変数に束縛（バインド）されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This behavior is referred to as <bpt i="0" x="0">&lt;e0&gt;</bpt>longest match<ept i="0">&lt;/e0&gt;</ept> or <bpt i="1" x="1">&lt;e1&gt;</bpt>maximal munch<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挙動は、<bpt i="0" x="0">&lt;e0&gt;</bpt>最長マッチ<ept i="0">&lt;/e0&gt;</ept>または<bpt i="1" x="1">&lt;e1&gt;</bpt>欲張り捕獲<ept i="1">&lt;/e1&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This behavior is summarized in the following rules:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挙動は、以下の規則において要約されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This behavior means you can use extensions in the same way to organize your code, whether or not your types have private entities.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挙動は、あなたの型が非公開な実在を持つかどうかにかかわらず、あなたが拡張を同じ方法で使ってあなたのコードを編成できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This behavior prevents the reference from becoming part of a strong reference cycle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挙動は、参照が強い参照循環の一部になるのを妨げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This behavior removes the need for the array bounds check seen in the <bpt i="11" x="11">&lt;c11&gt;</bpt>while<ept i="11">&lt;/c11&gt;</ept> loop version of the game described earlier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挙動は、前に記述された<bpt i="11" x="11">&lt;c11&gt;</bpt>while<ept i="11">&lt;/c11&gt;</ept>ループ版のゲームで見られた配列の境界検査の必要を取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This book describes Swift 4.0, the default version of Swift that’s included in Xcode 9.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この本はSwift 4.0、Xcode 9に含まれるスウィフトの省略時のバージョンを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This calculation yields the final answer of <bpt i="0" x="0">&lt;c0&gt;</bpt>17<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この計算は、最終的な答えの<bpt i="0" x="0">&lt;c0&gt;</bpt>17<ept i="0">&lt;/c0&gt;</ept>を生みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This call to the <bpt i="0" x="0">&lt;c0&gt;</bpt>insert(_:at:)<ept i="0">&lt;/c0&gt;</ept> method inserts a new item with a value of <bpt i="1" x="1">&lt;c1&gt;</bpt>"Maple Syrup"<ept i="1">&lt;/c1&gt;</ept> at the very beginning of the shopping list, indicated by an index of <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>insert(_:at:)<ept i="0">&lt;/c0&gt;</ept>メソッドへのこの呼び出しは、<bpt i="1" x="1">&lt;c1&gt;</bpt>"Maple Syrup"<ept i="1">&lt;/c1&gt;</ept>の値をもつ新しい項目を、<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>のインデックスによって指し示される、買い物リストのまさしくその開始位置で差し入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This can be read as:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This can happen if two class instances hold a strong reference to each other, such that each instance keeps the other alive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのクラスインスタンスが強い参照にお互いを守らせるならば、これは起こることができます、各インスタンスが他を生かしておくようなものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This capture might occur because the closure’s body accesses a property of the instance, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>self.someProperty<ept i="0">&lt;/c0&gt;</ept>, or because the closure calls a method on the instance, such as <bpt i="1" x="1">&lt;c1&gt;</bpt>self.someMethod()<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この捕獲は、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>self.someProperty<ept i="0">&lt;/c0&gt;</ept>のようにクロージャの本文がインスタンスのプロパティにアクセスするために、または例えば<bpt i="1" x="1">&lt;c1&gt;</bpt>self.someMethod()<ept i="1">&lt;/c1&gt;</ept>のようにクロージャがインスタンスのメソッドを呼ぶために起こるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This chapter describes parameters and arguments for generic types, functions, and initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この章は、総称体の型、関数、そしてイニシャライザに対するパラメータと引数を記載します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This chapter describes the common operators in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この章は、スウィフトの通常の演算子を記載します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This chapter describes those situations and shows how you enable ARC to manage all of your app’s memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この章は、それらの状況を記載して、あなたがどのようにARCにあなたのアプリのメモリの全てを管理させるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This chapter discusses the types defined in the Swift language itself and describes the type inference behavior of Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この章は、スウィフト言語それ自身によって定義される型を議論して、スウィフトの型推論挙動を記載します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This chapter now focuses more on the addition of new functionality in a subclass, and the modification of existing functionality with overrides.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この章は、今やサブクラスにおける追加された新しい機能性、そしてオーバーライドを使った既存の機能性の変更にもっと焦点を当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This character can be represented as a single code unit in UTF-16.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この文字は、UTF-16において単一の符号単位で表わされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This check ensures that your overriding definition is correct.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この調査は、あなたのオーバーライドの定義が正しいことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This class has four variable stored properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このクラスは、４つの変数の保存プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This class has three optional properties of type <bpt i="1" x="1">&lt;c1&gt;</bpt>String?<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このクラスは、型<bpt i="1" x="1">&lt;c1&gt;</bpt>String?<ept i="1">&lt;/c1&gt;</ept>の３つのオプショナルのプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This class implements a pseudorandom number generator algorithm known as a <bpt i="1" x="1">&lt;e1&gt;</bpt>linear congruential generator<ept i="1">&lt;/e1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このクラスは、<bpt i="1" x="1">&lt;e1&gt;</bpt>線形合同法生成器<ept i="1">&lt;/e1&gt;</ept>として知られている擬似乱数生成器アルゴリズムを実装します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This class implements the <bpt i="0" x="0">&lt;c0&gt;</bpt>fullName<ept i="0">&lt;/c0&gt;</ept> property requirement as a computed read-only property for a starship.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このクラスは、<bpt i="0" x="0">&lt;c0&gt;</bpt>fullName<ept i="0">&lt;/c0&gt;</ept>プロパティ要件をある宇宙船のための読み出し専用の計算プロパティとして実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This class might be used with input data from a pedometer or other step counter to keep track of a person’s exercise during their daily routine.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このクラスは、万歩計または他の歩数計からの入力データとともに、ある個人の日課の運動の経過を追うために使われるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This class models a document that can be initialized with a <bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept> property that is either a nonempty string value or <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>, but cannot be an empty string:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このクラスはある書類をモデル化します、それは空でない文字列か<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>のどちらかである<bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept>プロパティで初期化されることができます、しかし空の文字列であることはできません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This class provides basic functionality for any kind of item that appears in a digital media library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このクラスは、基本の機能性をデジタル・メディア図書館に現れるあらゆる種類の項目のために用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This code can be read as:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このコードは、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This color is then decomposed into its red (<bpt i="4" x="4">&lt;c4&gt;</bpt>CC<ept i="4">&lt;/c4&gt;</ept>), green (<bpt i="5" x="5">&lt;c5&gt;</bpt>66<ept i="5">&lt;/c5&gt;</ept>), and blue (<bpt i="6" x="6">&lt;c6&gt;</bpt>99<ept i="6">&lt;/c6&gt;</ept>) components by the bitwise AND operator (<bpt i="7" x="7">&lt;c7&gt;</bpt>&amp;<ept i="7">&lt;/c7&gt;</ept>) and the bitwise right shift operator (<bpt i="8" x="8">&lt;c8&gt;</bpt>&gt;&gt;<ept i="8">&lt;/c8&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この色はそれから、ビット単位の論理積演算子（<bpt i="7" x="7">&lt;c7&gt;</bpt>&amp;<ept i="7">&lt;/c7&gt;</ept>）とビット単位の右シフト演算子（<bpt i="8" x="8">&lt;c8&gt;</bpt>&gt;&gt;<ept i="8">&lt;/c8&gt;</ept>）によって、それの赤（<bpt i="4" x="4">&lt;c4&gt;</bpt>CC<ept i="4">&lt;/c4&gt;</ept>）、緑（<bpt i="5" x="5">&lt;c5&gt;</bpt>66<ept i="5">&lt;/c5&gt;</ept>）、そして青（<bpt i="6" x="6">&lt;c6&gt;</bpt>99<ept i="6">&lt;/c6&gt;</ept>）の構成要素に分解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This computed property considers the rank of the card and initializes a new <bpt i="3" x="3">&lt;c3&gt;</bpt>Values<ept i="3">&lt;/c3&gt;</ept> instance with appropriate values based on its rank.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この計算プロパティは、カードの等級を考慮して、その等級に基づいた適切な値で新しい<bpt i="3" x="3">&lt;c3&gt;</bpt>Values<ept i="3">&lt;/c3&gt;</ept>インスタンスを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This confirms that initialization has taken place.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、初期化が起こったことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This constraint ensures that each element of the sequence is equatable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この制約はシーケンスの各要素が同等比較可能であることを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This constraint prevents a situation in which additional essential setup provided in a more complex initializer is accidentally circumvented by someone using one of the automatic initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この制約は、あるより複雑なイニシャライザにおいて提供される追加の重要な準備が、自動的なイニシャライザのうちの１つを使う何かによって図らずも回避される状況を防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This continues up the class inheritance chain until the top of the chain is reached.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、クラス継承連鎖を上って、その連鎖の最上部に着くまで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This convenience initializer assumes a quantity of <bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept> for any <bpt i="4" x="4">&lt;c4&gt;</bpt>RecipeIngredient<ept i="4">&lt;/c4&gt;</ept> instance that is created without an explicit quantity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この便宜イニシャライザは、はっきりした量なしで作成されるあらゆる<bpt i="4" x="4">&lt;c4&gt;</bpt>RecipeIngredient<ept i="4">&lt;/c4&gt;</ept>インスタンスに対して数量<bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>を仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This convenience initializer cannot yet modify any properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この便宜イニシャライザは、まだどのプロパティも修正することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This convenience initializer simply delegates across to the class’s designated initializer, passing in a <bpt i="7" x="7">&lt;c7&gt;</bpt>quantity<ept i="7">&lt;/c7&gt;</ept> value of <bpt i="8" x="8">&lt;c8&gt;</bpt>1<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この便宜イニシャライザはそのクラスの指定イニシャライザに、単純に<bpt i="7" x="7">&lt;c7&gt;</bpt>quantity<ept i="7">&lt;/c7&gt;</ept>に値<bpt i="8" x="8">&lt;c8&gt;</bpt>1<ept i="8">&lt;/c8&gt;</ept>を渡して横に委任します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This creates a new instance of the class or structure, with any properties initialized to their default values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、クラスまたは構造体の新しいインスタンスをつくり、どんなプロパティでもそれらの省略時の値に初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This data source is defined by the <bpt i="1" x="1">&lt;c1&gt;</bpt>CounterDataSource<ept i="1">&lt;/c1&gt;</ept> protocol, which has two optional requirements:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このデータ・ソースは<bpt i="1" x="1">&lt;c1&gt;</bpt>CounterDataSource<ept i="1">&lt;/c1&gt;</ept>プロトコルによって定義されます、それは、２つのオプショナルの要件を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This default case is indicated by the <bpt i="3" x="3">&lt;c3&gt;</bpt>default<ept i="3">&lt;/c3&gt;</ept> keyword, and must always appear last.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>defaultケース節は、キーワード<bpt i="3" x="3">&lt;c3&gt;</bpt>default<ept i="3">&lt;/c3&gt;</ept>によって示されて、常に最後に現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This definition does not provide any actual <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> values—it just defines the <bpt i="2" x="2">&lt;e2&gt;</bpt>type<ept i="2">&lt;/e2&gt;</ept> of associated values that <bpt i="3" x="3">&lt;c3&gt;</bpt>Barcode<ept i="3">&lt;/c3&gt;</ept> constants and variables can store when they are equal to <bpt i="4" x="4">&lt;c4&gt;</bpt>Barcode.upc<ept i="4">&lt;/c4&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>Barcode.qrCode<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この定義は、何ら実際の<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値を提供しません ― それは、ただ単に関連値の<bpt i="2" x="2">&lt;e2&gt;</bpt>型<ept i="2">&lt;/e2&gt;</ept>を定義します、それは、<bpt i="3" x="3">&lt;c3&gt;</bpt>Barcode<ept i="3">&lt;/c3&gt;</ept>定数と変数が<bpt i="4" x="4">&lt;c4&gt;</bpt>Barcode.upc<ept i="4">&lt;/c4&gt;</ept>もしくは<bpt i="5" x="5">&lt;c5&gt;</bpt>Barcode.qrCode<ept i="5">&lt;/c5&gt;</ept>に等しいときに格納できる型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This definition indicates that a getter-setter block can consist of a getter clause followed by an optional setter clause, enclosed in braces, <bpt i="0" x="0">&lt;e0&gt;</bpt>or<ept i="0">&lt;/e0&gt;</ept> a setter clause followed by a getter clause, enclosed in braces.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この定義は、１つのゲッターセッター・ブロックが、１つのゲッター節とそれに続く任意の１つのセッター節、それを波括弧でくくったもの、<bpt i="0" x="0">&lt;e0&gt;</bpt>または<ept i="0">&lt;/e0&gt;</ept>、１つのゲッター節に１つのセッター節を続けて波括弧でくくったものから成ることができることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This definition of multiple subscripts is known as <bpt i="0" x="0">&lt;e0&gt;</bpt>subscript overloading<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この複数の添え字の定義は、<bpt i="0" x="0">&lt;e0&gt;</bpt>添え字オーバーロード<ept i="0">&lt;/e0&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This design pattern is implemented by defining a protocol that encapsulates the delegated responsibilities, such that a conforming type (known as a delegate) is guaranteed to provide the functionality that has been delegated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このデザイン・パターンは、委任された責務をカプセル化するプロトコルを定義することによって実装されます、例えば、委任プロトコルに拠準する型が（代表、委任先として知られるものが）その委任されている機能性を提供する責任を負わされるといったこと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This designated initializer matches a designated initializer from the superclass of <bpt i="2" x="2">&lt;c2&gt;</bpt>Bicycle<ept i="2">&lt;/c2&gt;</ept>, and so the <bpt i="3" x="3">&lt;c3&gt;</bpt>Bicycle<ept i="3">&lt;/c3&gt;</ept> version of this initializer is marked with the <bpt i="4" x="4">&lt;c4&gt;</bpt>override<ept i="4">&lt;/c4&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この指定イニシャライザは<bpt i="2" x="2">&lt;c2&gt;</bpt>Bicycle<ept i="2">&lt;/c2&gt;</ept>のスーパークラスでのある指定イニシャライザと一致します、なのでこのイニシャライザの<bpt i="3" x="3">&lt;c3&gt;</bpt>Bicycle<ept i="3">&lt;/c3&gt;</ept>改変板は<bpt i="4" x="4">&lt;c4&gt;</bpt>override<ept i="4">&lt;/c4&gt;</ept>修飾子で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This dictionary literal contains two <bpt i="0" x="0">&lt;c0&gt;</bpt>String: String<ept i="0">&lt;/c0&gt;</ept> pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この辞書リテラルは、<bpt i="0" x="0">&lt;c0&gt;</bpt>String: String<ept i="0">&lt;/c0&gt;</ept>の組みを２つ含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This distinction is not visible when the captured variable’s type has reference semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この相違は、キャプチャされた変数の型が参照意味論を持つ場合には見られません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This documentation contains preliminary information about an API or technology in development.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This does not, however, cause the observer to be called again.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、しかし、このオブザーバーが再び呼び出されるようにしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This empty protocol indicates that a type can be used for error handling.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この空のプロトコルは、ある型がエラー処理のために使われることができるのを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables <bpt i="1" x="1">&lt;c1&gt;</bpt>printMathResult(_:_:_:)<ept i="1">&lt;/c1&gt;</ept> to hand off some of its functionality to the caller of the function in a type-safe way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="1" x="1">&lt;c1&gt;</bpt>printMathResult(_:_:_:)<ept i="1">&lt;/c1&gt;</ept>にその機能性の一部をその関数の呼び出し手に、ある型安全な方法で、手渡すことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables <bpt i="5" x="5">&lt;c5&gt;</bpt>TrackedString<ept i="5">&lt;/c5&gt;</ept> to modify the <bpt i="6" x="6">&lt;c6&gt;</bpt>numberOfEdits<ept i="6">&lt;/c6&gt;</ept> property internally, but to present the property as a read-only property when it’s used outside the structure’s definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これが<bpt i="5" x="5">&lt;c5&gt;</bpt>TrackedString<ept i="5">&lt;/c5&gt;</ept>に可能にするのは、<bpt i="6" x="6">&lt;c6&gt;</bpt>numberOfEdits<ept i="6">&lt;/c6&gt;</ept>プロパティを内部のように修正すること、しかしそのプロパティをそれが構造体の定義の外側で使われる時は読み出し専用プロパティとして提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables both properties to be accessed directly (without optional unwrapping) once initialization is complete, while still avoiding a reference cycle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、一旦初期化が終了しているならば、両方のプロパティが直接にアクセスされるのを（オプショナルをアンラップすることなく）可能にします、その一方で、依然として参照循環を避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables structures and enumerations to adopt the protocol and satisfy that method requirement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、構造体と列挙に、そのプロトコルを採用してメソッド要件を満たすのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables you to be notified when the value of an inherited property changes, regardless of how that property was originally implemented.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはあなたに、そのプロパティが元々どのように実装されるかに関係なく、継承されたプロパティの値が変わるとき通知されることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables you to catch and fix errors as early as possible in the development process.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたに開発過程においてエラーをできるだけ早く捕えて修復するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables you to check for a successful downcast.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたに成功したダウンキャストについて調べるのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables you to check for their existence within the closure’s body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはあなたに、クロージャの本文内でそれらの存在について調べることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables you to check whether or not an update took place.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはあなたに、更新が起こったかどうか、確認することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables you to create protocols that can only be adopted within a certain access context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたに特定のアクセス文脈内で採用されることだけができるプロトコルを作成するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables you to define a subclass for which initialization cannot fail, even though initialization of the superclass is allowed to fail.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはあなたに、それに対しての初期化が失敗することが出来ないサブクラスを定義することを可能にします、たとえスーパークラスの初期化が失敗することが許されるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables you to drill down into subproperties within complex models of interrelated types, and to check whether it is possible to access properties, methods, and subscripts on those subproperties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはあなたに、相互に関係づけられた型である複雑なモデルの内部の下位情報に掘り下げていくこと、そしてそれらの下位情報上でプロパティ、メソッド、そして添え字にアクセスすることが可能であるかどうか確認することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables you to extend other types to accept your own custom types as initializer parameters, or to provide additional initialization options that were not included as part of the type’s original implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたに別の型を拡張してあなた独自のあつらえの型をイニシャライザパラメータとして受け入れるようにすること、またはその型の最初の実装の一部として含まれなかった追加の初期化選択肢を提供することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables you to leave some aspects of a function’s implementation for the function’s caller to provide when the function is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはあなたに、ある関数の実装のいくつかの側面をその関数の呼び出し側のために、その関数が呼ばれるとき提供する目的で、取っておくことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables you to see whether instances of <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept> are being deallocated as expected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたに期待されるように<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept>のインスタンスが割り当て解除されているかどうか知ることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables you to store additional custom information along with the case value, and permits this information to vary each time you use that case in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはあなたに、ケース節値とともに追加の特注の情報を格納するのを可能にして、あなたがあなたのコードにおいてそのケース節を使うたびにこの情報が変化するのを許します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enables you to use an <bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept> statement to check whether it was possible to call the <bpt i="3" x="3">&lt;c3&gt;</bpt>printNumberOfRooms()<ept i="3">&lt;/c3&gt;</ept> method, even though the method does not itself define a return value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはあなたに<bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept>文を<bpt i="3" x="3">&lt;c3&gt;</bpt>printNumberOfRooms()<ept i="3">&lt;/c3&gt;</ept>メソッドを呼び出すことが可能か調べるために使うことを可能にします、たとえそのメソッドがそれ自身では戻り値を定義しないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This encoding for negative numbers is known as a <bpt i="0" x="0">&lt;e0&gt;</bpt>two’s complement<ept i="0">&lt;/e0&gt;</ept> representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この負数のための符号化は、<bpt i="0" x="0">&lt;e0&gt;</bpt>２の補数<ept i="0">&lt;/e0&gt;</ept>表現として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This ensures that a <bpt i="5" x="5">&lt;c5&gt;</bpt>CreditCard<ept i="5">&lt;/c5&gt;</ept> instance always has a <bpt i="6" x="6">&lt;c6&gt;</bpt>customer<ept i="6">&lt;/c6&gt;</ept> instance associated with it when the <bpt i="7" x="7">&lt;c7&gt;</bpt>CreditCard<ept i="7">&lt;/c7&gt;</ept> instance is created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="5" x="5">&lt;c5&gt;</bpt>CreditCard<ept i="5">&lt;/c5&gt;</ept>インスタンスがつくられるとき、<bpt i="7" x="7">&lt;c7&gt;</bpt>CreditCard<ept i="7">&lt;/c7&gt;</ept>インスタンスが常にそれと結びつけられる<bpt i="6" x="6">&lt;c6&gt;</bpt>Customer<ept i="6">&lt;/c6&gt;</ept>インスタンスを持つことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This ensures that all of the protocol’s requirements will be visible on any type that adopts the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、プロトコルを採用するあらゆる型上で、プロトコルのもつ要件の全てが見えることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This ensures that class instances do not take up space in memory when they are no longer needed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、クラスインスタンスが、それらがもはや必要でない時に、メモリ上で場所を取らないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This ensures that the <bpt i="5" x="5">&lt;c5&gt;</bpt>numberOfWheels<ept i="5">&lt;/c5&gt;</ept> inherited property is initialized by <bpt i="6" x="6">&lt;c6&gt;</bpt>Vehicle<ept i="6">&lt;/c6&gt;</ept> before <bpt i="7" x="7">&lt;c7&gt;</bpt>Bicycle<ept i="7">&lt;/c7&gt;</ept> has the opportunity to modify the property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは継承されたプロパティ<bpt i="5" x="5">&lt;c5&gt;</bpt>numberOfWheels<ept i="5">&lt;/c5&gt;</ept>が、<bpt i="7" x="7">&lt;c7&gt;</bpt>Bicycle<ept i="7">&lt;/c7&gt;</ept>がそのプロパティを変更する機会を得る前に、<bpt i="6" x="6">&lt;c6&gt;</bpt>Vehicle<ept i="6">&lt;/c6&gt;</ept>によってイニシャライズされることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This ensures that the indices in the sequence are the same type as the indices used for a container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、このシーケンスのインデックスがコンテナに対して使われるインデックスと同じ型であるのを保証することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This ensures that, no matter which part of the compound case matched, the code in the body of the case can always access a value for the bindings and that the value always has the same type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、たとえ複合ケース節のどの部分がマッチしたとしても、ケース節の本文のコードが常に束縛のための値にアクセスできること、そしてその値が常に同じ型を持つことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enumeration can store three kinds of arithmetic expressions: a plain number, the addition of two expressions, and the multiplication of two expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この列挙は、３種類の算術式：普通の数字、２つの式の加算、そして２つの式の乗算を格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enumeration toggles between two states, indicated by the enumeration cases <bpt i="1" x="1">&lt;c1&gt;</bpt>on<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>off<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この列挙は、列挙のケース節<bpt i="1" x="1">&lt;c1&gt;</bpt>on<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>off<ept i="2">&lt;/c2&gt;</ept>で示される、２つの状態の間で切替えをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This enumeration, called <bpt i="1" x="1">&lt;c1&gt;</bpt>Kind<ept i="1">&lt;/c1&gt;</ept>, expresses the kind of number that a particular integer represents.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この列挙は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Kind<ept i="1">&lt;/c1&gt;</ept>と呼ばれ、特定の整数を表わす数の種類を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This exactly matches the method type needed by the <bpt i="5" x="5">&lt;c5&gt;</bpt>sorted(by:)<ept i="5">&lt;/c5&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="5" x="5">&lt;c5&gt;</bpt>sorted(by:)<ept i="5">&lt;/c5&gt;</ept>メソッドによって必要とされるメソッド型に正確に適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example adds a new nested enumeration to <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、新しい入れ子にされた列挙を<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example adds an <bpt i="0" x="0">&lt;c0&gt;</bpt>average()<ept i="0">&lt;/c0&gt;</ept> method to containers whose <bpt i="1" x="1">&lt;c1&gt;</bpt>Item<ept i="1">&lt;/c1&gt;</ept> type is <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>average()<ept i="0">&lt;/c0&gt;</ept>メソッドを、<bpt i="1" x="1">&lt;c1&gt;</bpt>Item<ept i="1">&lt;/c1&gt;</ept>型が<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>であるコンテナに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example adds an integer subscript to Swift’s built-in <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、整数添え字をスウィフトの組み込みの<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>型に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example adds five computed instance properties to Swift’s built-in <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> type, to provide basic support for working with distance units:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、５つの計算インスタンスプロパティをスウィフトの組み込みの<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>型に加えて、距離単位を扱うための基本的な支持を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example adds together the vectors <bpt i="0" x="0">&lt;c0&gt;</bpt>(3.0, 1.0)<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>(2.0, 4.0)<ept i="1">&lt;/c1&gt;</ept> to make the vector <bpt i="2" x="2">&lt;c2&gt;</bpt>(5.0, 5.0)<ept i="2">&lt;/c2&gt;</ept>, as illustrated below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、下で図示されるように、ベクトル<bpt i="0" x="0">&lt;c0&gt;</bpt>(3.0、1.0)<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>(2.0、4.0)<ept i="1">&lt;/c1&gt;</ept>を一緒に加えて、ベクトル<bpt i="2" x="2">&lt;c2&gt;</bpt>(5.0, 5.0)<ept i="2">&lt;/c2&gt;</ept>を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example also adds a new computed instance property to <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>, called <bpt i="1" x="1">&lt;c1&gt;</bpt>kind<ept i="1">&lt;/c1&gt;</ept>, which returns the appropriate <bpt i="2" x="2">&lt;c2&gt;</bpt>Kind<ept i="2">&lt;/c2&gt;</ept> enumeration case for that integer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例はまた、新しい計算インスタンスプロパティを<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>に加えます、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>kind<ept i="1">&lt;/c1&gt;</ept>と呼ばれ、その整数に対する適切な<bpt i="2" x="2">&lt;c2&gt;</bpt>Kind<ept i="2">&lt;/c2&gt;</ept>列挙ケース節を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example checks <bpt i="0" x="0">&lt;c0&gt;</bpt>numberSymbol<ept i="0">&lt;/c0&gt;</ept> to determine whether it is a Latin, Arabic, Chinese, or Thai symbol for the numbers <bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept> to <bpt i="2" x="2">&lt;c2&gt;</bpt>4<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>numberSymbol<ept i="0">&lt;/c0&gt;</ept>を、それが<bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt>4<ept i="2">&lt;/c2&gt;</ept>のラテン、アラビア語、中国語、またはタイ語であるかどうか明らかにするために調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example considers two <bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept> values and only allows access if both values are <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、２つの<bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept>値を考慮して、両方の値が<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>の場合にのみアクセスを許します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example creates a new variable called <bpt i="0" x="0">&lt;c0&gt;</bpt>productBarcode<ept i="0">&lt;/c0&gt;</ept> and assigns it a value of <bpt i="1" x="1">&lt;c1&gt;</bpt>Barcode.upc<ept i="1">&lt;/c1&gt;</ept> with an associated tuple value of <bpt i="2" x="2">&lt;c2&gt;</bpt>(8, 85909, 51226, 3)<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>productBarcode<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しい変数をつくって、それにあるひとつの<bpt i="1" x="1">&lt;c1&gt;</bpt>Barcode.upc<ept i="1">&lt;/c1&gt;</ept>の値を関連したタプル値<bpt i="2" x="2">&lt;c2&gt;</bpt>(8, 85909, 51226, 3)<ept i="2">&lt;/c2&gt;</ept>とともに代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example creates an array of <bpt i="2" x="2">&lt;c2&gt;</bpt>TextRepresentable<ept i="2">&lt;/c2&gt;</ept> things:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>TextRepresentable<ept i="2">&lt;/c2&gt;</ept>なものの配列をつくります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example creates an empty dictionary of type <bpt i="0" x="0">&lt;c0&gt;</bpt>[Int: String]<ept i="0">&lt;/c0&gt;</ept> to store human-readable names of integer values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、型<bpt i="0" x="0">&lt;c0&gt;</bpt>[Int: String]<ept i="0">&lt;/c0&gt;</ept>の空の辞書を、整数値の人間の読み込み可能な名前を格納するために作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example declares a constant called <bpt i="0" x="0">&lt;c0&gt;</bpt>hd<ept i="0">&lt;/c0&gt;</ept> and sets it to a <bpt i="1" x="1">&lt;c1&gt;</bpt>Resolution<ept i="1">&lt;/c1&gt;</ept> instance initialized with the width and height of full HD video (<bpt i="2" x="2">&lt;c2&gt;</bpt>1920<ept i="2">&lt;/c2&gt;</ept> pixels wide by <bpt i="3" x="3">&lt;c3&gt;</bpt>1080<ept i="3">&lt;/c3&gt;</ept> pixels high).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>hd<ept i="0">&lt;/c0&gt;</ept>と呼ばれる定数を宣言して、それをフルHDビデオの幅と高さ（<bpt i="2" x="2">&lt;c2&gt;</bpt>1920<ept i="2">&lt;/c2&gt;</ept>ピクセル幅の広さで<bpt i="3" x="3">&lt;c3&gt;</bpt>1080<ept i="3">&lt;/c3&gt;</ept>ピクセルの高さがある）で初期化される<bpt i="1" x="1">&lt;c1&gt;</bpt>Resolution<ept i="1">&lt;/c1&gt;</ept>インスタンスに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example declares a new <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> variable called <bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept> and assigns it an initial value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept>と呼ばれる新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>変数を宣言して、それに最初の値を代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example declares a new constant called <bpt i="0" x="0">&lt;c0&gt;</bpt>tenEighty<ept i="0">&lt;/c0&gt;</ept> and sets it to refer to a new instance of the <bpt i="1" x="1">&lt;c1&gt;</bpt>VideoMode<ept i="1">&lt;/c1&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>tenEighty<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しい定数を宣言して、それを<bpt i="1" x="1">&lt;c1&gt;</bpt>VideoMode<ept i="1">&lt;/c1&gt;</ept>クラスの新しいインスタンスに言及するように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines a class called <bpt i="0" x="0">&lt;c0&gt;</bpt>ShoppingListItem<ept i="0">&lt;/c0&gt;</ept>, which encapsulates the name, quantity, and purchase state of an item in a shopping list:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は<bpt i="0" x="0">&lt;c0&gt;</bpt>ShoppingListItem<ept i="0">&lt;/c0&gt;</ept>と呼ばれるクラスを定義します、それは、ある購入品目リストにおける名前、量、そしてある項目の購入状態といったものをカプセル化します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines a class called <bpt i="1" x="1">&lt;c1&gt;</bpt>HTMLElement<ept i="1">&lt;/c1&gt;</ept>, which provides a simple model for an individual element within an HTML document:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は<bpt i="1" x="1">&lt;c1&gt;</bpt>HTMLElement<ept i="1">&lt;/c1&gt;</ept>と呼ばれるクラスを定義します、それは、HTML文書内個々の要素に対する単純なモデルを用意します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines a function called <bpt i="0" x="0">&lt;c0&gt;</bpt>printMathResult(_:_:_:)<ept i="0">&lt;/c0&gt;</ept>, which has three parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は<bpt i="0" x="0">&lt;c0&gt;</bpt>printMathResult(_:_:_:)<ept i="0">&lt;/c0&gt;</ept>と呼ばれる関数を定義します、それは３つのパラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines a hierarchy of three classes called <bpt i="0" x="0">&lt;c0&gt;</bpt>Food<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>RecipeIngredient<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>ShoppingListItem<ept i="2">&lt;/c2&gt;</ept>, and demonstrates how their initializers interact.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Food<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>RecipeIngredient<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>ShoppingListItem<ept i="2">&lt;/c2&gt;</ept>と呼ばれる３つのクラスの階層を定義して、それらのイニシャライザが相互に作用する方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines a new class called <bpt i="0" x="0">&lt;c0&gt;</bpt>Dice<ept i="0">&lt;/c0&gt;</ept>, which represents an <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>-sided dice for use in a board game.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は<bpt i="0" x="0">&lt;c0&gt;</bpt>Dice<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しいクラスを定義します、それは、ボードゲームで使うのために<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>面のさいころを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines a new protocol, <bpt i="0" x="0">&lt;c0&gt;</bpt>PrettyTextRepresentable<ept i="0">&lt;/c0&gt;</ept>, which inherits from <bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ある新しいプロトコル、<bpt i="0" x="0">&lt;c0&gt;</bpt>PrettyTextRepresentable<ept i="0">&lt;/c0&gt;</ept>を定義します、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>TextRepresentable<ept i="1">&lt;/c1&gt;</ept>から継承を受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines a new structure called <bpt i="0" x="0">&lt;c0&gt;</bpt>Cuboid<ept i="0">&lt;/c0&gt;</ept>, which represents a 3D rectangular box with <bpt i="1" x="1">&lt;c1&gt;</bpt>width<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>height<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>depth<ept i="3">&lt;/c3&gt;</ept> properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は<bpt i="0" x="0">&lt;c0&gt;</bpt>Cuboid<ept i="0">&lt;/c0&gt;</ept>と呼ばれる新しい構造体を定義します、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>width<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>height<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>depth<ept i="3">&lt;/c3&gt;</ept>プロパティで3D矩形の箱を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines a protocol called <bpt i="0" x="0">&lt;c0&gt;</bpt>HasArea<ept i="0">&lt;/c0&gt;</ept>, with a single property requirement of a gettable <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept> property called <bpt i="2" x="2">&lt;c2&gt;</bpt>area<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>area<ept i="2">&lt;/c2&gt;</ept>と呼ばれる取得可能な<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>プロパティである１つだけのプロパティ要件をもつ、<bpt i="0" x="0">&lt;c0&gt;</bpt>HasArea<ept i="0">&lt;/c0&gt;</ept>と呼ばれるプロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines a structure called <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>, which represents a specific named person.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>と呼ばれる構造体を定義します、それは、特定の名前の人物を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines an enumeration for a three-state switch.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、３つの状態を切り替えるために、ある列挙を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines three structures for working with geometric shapes:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、幾何学形を扱うために３つの構造体を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines two classes called <bpt i="0" x="0">&lt;c0&gt;</bpt>DataImporter<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>DataManager<ept i="1">&lt;/c1&gt;</ept>, neither of which is shown in full:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>DataImporter<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>DataManager<ept i="1">&lt;/c1&gt;</ept>と呼ばれる２つのクラスを定義します、そのどちらも全部は示されません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines two classes called <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept>, which model a block of apartments and its residents:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept>と呼ばれる２つのクラスを定義します、それは、アパートの１区画とその居住者をモデル化します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines two new types, <bpt i="0" x="0">&lt;c0&gt;</bpt>Bank<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Player<ept i="1">&lt;/c1&gt;</ept>, for a simple game.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、２つの新しい型<bpt i="0" x="0">&lt;c0&gt;</bpt>Bank<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Player<ept i="1">&lt;/c1&gt;</ept>を、単純なゲームのために定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example defines two simple mathematical functions called <bpt i="0" x="0">&lt;c0&gt;</bpt>addTwoInts<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>multiplyTwoInts<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>addTwoInts<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>multiplyTwoInts<ept i="1">&lt;/c1&gt;</ept>と呼ばれる２つの単純な数学的な関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example identifies Uranus from its raw value of <bpt i="0" x="0">&lt;c0&gt;</bpt>7<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、その生の値の<bpt i="0" x="0">&lt;c0&gt;</bpt>7<ept i="0">&lt;/c0&gt;</ept>からUranus（天王星）を特定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example initializes a <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept> integer with the binary value <bpt i="4" x="4">&lt;c4&gt;</bpt>00001111<ept i="4">&lt;/c4&gt;</ept>, which has its first four bits set to <bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>, and its second four bits set to <bpt i="6" x="6">&lt;c6&gt;</bpt>1<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept>整数を２進数の値<bpt i="4" x="4">&lt;c4&gt;</bpt>00001111<ept i="4">&lt;/c4&gt;</ept>で初期化します、それは、その最初の４つのビットを<bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>に設定して、次の４つのビットを<bpt i="6" x="6">&lt;c6&gt;</bpt>1<ept i="6">&lt;/c6&gt;</ept>に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example is sorting an array of <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> values, and so the sorting closure needs to be a function of type <bpt i="1" x="1">&lt;c1&gt;</bpt>(String, String) -&gt; Bool<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>値の配列を分類しています、なのでソート・クロージャは型<bpt i="1" x="1">&lt;c1&gt;</bpt>(String, String) -&gt; Bool<ept i="1">&lt;/c1&gt;</ept>の関数である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example iterates through all items in the <bpt i="0" x="0">&lt;c0&gt;</bpt>library<ept i="0">&lt;/c0&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>library<ept i="0">&lt;/c0&gt;</ept>配列の中の全ての項目の端が端まで繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example plays a simple game of <bpt i="0" x="0">&lt;e0&gt;</bpt>Snakes and Ladders<ept i="0">&lt;/e0&gt;</ept> (also known as <bpt i="1" x="1">&lt;e1&gt;</bpt>Chutes and Ladders<ept i="1">&lt;/e1&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、単純なゲームの<bpt i="0" x="0">&lt;e0&gt;</bpt>「ヘビとはしご」<ept i="0">&lt;/e0&gt;</ept>（また、<bpt i="1" x="1">&lt;e1&gt;</bpt>「荷すべらしとはしご」<ept i="1">&lt;/e1&gt;</ept>として知られます）で遊びます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example prints the first few entries in a five-times table:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、九九の５の段の表の最初のいくつかの項を出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example provides a type annotation for a variable called <bpt i="0" x="0">&lt;c0&gt;</bpt>welcomeMessage<ept i="0">&lt;/c0&gt;</ept>, to indicate that the variable can store <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> values:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>welcomeMessage<ept i="0">&lt;/c0&gt;</ept>と呼ばれる変数に対して、その変数は<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値を保存できることを示すために型注釈を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example sets a constant called <bpt i="0" x="0">&lt;c0&gt;</bpt>incrementByTen<ept i="0">&lt;/c0&gt;</ept> to refer to an incrementer function that adds <bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept> to its <bpt i="2" x="2">&lt;c2&gt;</bpt>runningTotal<ept i="2">&lt;/c2&gt;</ept> variable each time it is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>incrementByTen<ept i="0">&lt;/c0&gt;</ept>と呼ばれる定数を、それが呼ばれるたびに<bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>をその<bpt i="2" x="2">&lt;c2&gt;</bpt>runningTotal<ept i="2">&lt;/c2&gt;</ept>変数に加えるあるインクリメンタ関数に言及するように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example starts with a simple class called <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>, which defines a stored constant property called <bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>と呼ばれる単純なクラスから始めます、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept>と呼ばれる保存定数プロパティを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example uses a <bpt i="0" x="0">&lt;c0&gt;</bpt>UInt32<ept i="0">&lt;/c0&gt;</ept> constant called <bpt i="1" x="1">&lt;c1&gt;</bpt>pink<ept i="1">&lt;/c1&gt;</ept> to store a Cascading Style Sheets color value for the color pink.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、ピンク色のカスケーディング・スタイル・シートの色値を保存するために、<bpt i="1" x="1">&lt;c1&gt;</bpt>pink<ept i="1">&lt;/c1&gt;</ept>と呼ばれる<bpt i="0" x="0">&lt;c0&gt;</bpt>UInt32<ept i="0">&lt;/c0&gt;</ept>定数を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example uses a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop to iterate over the items in an array:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループを使って、ある配列の中の項目すべてにわたって繰り返していきます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example uses a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement to consider a single lowercase character called <bpt i="1" x="1">&lt;c1&gt;</bpt>someCharacter<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文を一つの小文字の文字、<bpt i="1" x="1">&lt;c1&gt;</bpt>someCharacter<ept i="1">&lt;/c1&gt;</ept>と呼ばれるものについて考察するために使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example uses multiple <bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&amp;<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>||<ept i="1">&lt;/c1&gt;</ept> operators to create a longer compound expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、より長く複雑な式をつくるために複数の<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&amp;<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>||<ept i="1">&lt;/c1&gt;</ept>演算子を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example uses number intervals to provide a natural-language count for numbers of any size:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、自然言語の数え方をどんな大きさの数にも用意するために、数の区間を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example uses optional binding to try to access a planet with a raw value of <bpt i="0" x="0">&lt;c0&gt;</bpt>11<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>11<ept i="0">&lt;/c0&gt;</ept>の生の値で惑星にアクセスすることを試みるためにオプショナル束縛を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example’s <bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept> observer uses a custom parameter name of <bpt i="1" x="1">&lt;c1&gt;</bpt>newTotalSteps<ept i="1">&lt;/c1&gt;</ept> for the upcoming new value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例の<bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept>オブザーバーは、来るべき新しい値のためにあつらえのパラメータ名<bpt i="1" x="1">&lt;c1&gt;</bpt>newTotalSteps<ept i="1">&lt;/c1&gt;</ept>を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This exception ensures that an older compiler doesn’t attempt to parse syntax introduced in a newer version of Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例外は、古いコンパイラがより新しいバージョンのスウィフトで導入される構文の解析を試みないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This expression calculates the value of <bpt i="1" x="1">&lt;c1&gt;</bpt>Double(multiplier) * 2.5<ept i="1">&lt;/c1&gt;</ept> and inserts the result (<bpt i="2" x="2">&lt;c2&gt;</bpt>7.5<ept i="2">&lt;/c2&gt;</ept>) into the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この式は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Double(multiplier) * 2.5<ept i="1">&lt;/c1&gt;</ept>の値を計算して、結果（<bpt i="2" x="2">&lt;c2&gt;</bpt>7.5<ept i="2">&lt;/c2&gt;</ept>）を文字列に差し込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This extension adopts the new protocol in exactly the same way as if <bpt i="0" x="0">&lt;c0&gt;</bpt>Dice<ept i="0">&lt;/c0&gt;</ept> had provided it in its original implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この拡張は、まるで<bpt i="0" x="0">&lt;c0&gt;</bpt>Dice<ept i="0">&lt;/c0&gt;</ept>がその最初の実装においてそれを提供したかのように、正確に同じふうに新しいプロトコルを採用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This extension states that it adopts the <bpt i="0" x="0">&lt;c0&gt;</bpt>PrettyTextRepresentable<ept i="0">&lt;/c0&gt;</ept> protocol and provides an implementation of the <bpt i="1" x="1">&lt;c1&gt;</bpt>prettyTextualDescription<ept i="1">&lt;/c1&gt;</ept> property for the <bpt i="2" x="2">&lt;c2&gt;</bpt>SnakesAndLadders<ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この拡張が述べるのは、それが<bpt i="0" x="0">&lt;c0&gt;</bpt>PrettyTextRepresentable<ept i="0">&lt;/c0&gt;</ept>プロトコルを採用して<bpt i="1" x="1">&lt;c1&gt;</bpt>prettyTextualDescription<ept i="1">&lt;/c1&gt;</ept>プロパティの実装を<bpt i="2" x="2">&lt;c2&gt;</bpt>SnakesAndLadders<ept i="2">&lt;/c2&gt;</ept>型に提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This extension to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept> protocol adds a subscript that takes a sequence of indices and returns an array containing the items at each given index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept>プロトコルに対する拡張は、ある添え字を追加します、それはインデックスのシーケンスをとって、与えられたインデックスそれぞれでの項目を含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This failure might be triggered by invalid initialization parameter values, the absence of a required external resource, or some other condition that prevents initialization from succeeding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この失敗は、無効な初期化パラメータ、必須の外部リソースの欠如、または初期化がうまくいくのを妨げる何か他の状況によって引き起こされるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この特徴によってあなたは、あなたのコードの実施詳細を隠すこと、そしてそれを通してそのコードがアクセスされ使用されることができる好ましいインタフェースを指定することが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This feature is represented by a structure called <bpt i="0" x="0">&lt;c0&gt;</bpt>Values<ept i="0">&lt;/c0&gt;</ept>, which is nested within the <bpt i="1" x="1">&lt;c1&gt;</bpt>Rank<ept i="1">&lt;/c1&gt;</ept> enumeration:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この特徴は<bpt i="0" x="0">&lt;c0&gt;</bpt>Values<ept i="0">&lt;/c0&gt;</ept>と呼ばれる構造体で表されます、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Rank<ept i="1">&lt;/c1&gt;</ept>列挙の内部で入れ子にされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This feature prevents the assignment operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>=<ept i="0">&lt;/c0&gt;</ept>) from being used by accident when the equal to operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>) is actually intended.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この特徴は、実際には同等演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>）が意図されるときに、偶然に代入演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>=<ept i="0">&lt;/c0&gt;</ept>）が使われるのを防止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This form of the operator will always return an optional value, and the value will be <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> if the downcast was not possible.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子のこの形式は、常にオプショナルの値を返します、そしてダウンキャストが可能でなかったならばその値は<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This form of the operator will trigger a runtime error if you try to downcast to an incorrect class type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子のこの形式は、あなたが適切でないクラス型へのダウンキャストをためすならば、実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function doesn’t compile as written above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、上記のように書かれるとしてもコンパイルしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function evaluates a plain number by simply returning the associated value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、普通の数字を単に関連値を返すことによって評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function makes use of in-out parameters to swap the values of <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>, as described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>In-Out Parameters<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、値<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>を交換するためにin-outパラメータの利用を行います、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>In-Outパラメータ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function simply adds <bpt i="7" x="7">&lt;c7&gt;</bpt>amount<ept i="7">&lt;/c7&gt;</ept> to <bpt i="8" x="8">&lt;c8&gt;</bpt>runningTotal<ept i="8">&lt;/c8&gt;</ept>, and returns the result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、単に<bpt i="7" x="7">&lt;c7&gt;</bpt>amount<ept i="7">&lt;/c7&gt;</ept>を<bpt i="8" x="8">&lt;c8&gt;</bpt>runningTotal<ept i="8">&lt;/c8&gt;</ept>に加えて、結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function takes a person’s name and whether they have already been greeted as input, and returns an appropriate greeting for that person:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、人物の名前と彼らがすでに挨拶されたかどうかを入力として取って、ふさわしい挨拶をその人物に対して返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function takes two arguments called <bpt i="0" x="0">&lt;c0&gt;</bpt>someContainer<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>anotherContainer<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数は、<bpt i="0" x="0">&lt;c0&gt;</bpt>someContainer<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>anotherContainer<ept i="1">&lt;/c1&gt;</ept>と呼ばれる２つの引数をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This function, <bpt i="0" x="0">&lt;c0&gt;</bpt>printIntegerKinds(_:)<ept i="0">&lt;/c0&gt;</ept>, takes an input array of <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> values and iterates over those values in turn.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数、<bpt i="0" x="0">&lt;c0&gt;</bpt>printIntegerKinds(_:)<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値の配列の入力を取り、それらの値に最初から終わりまで順番に繰り返していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This functionality is provided by the <bpt i="1" x="1">&lt;c1&gt;</bpt>DataImporter<ept i="1">&lt;/c1&gt;</ept> class, which is assumed to take a nontrivial amount of time to initialize.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この機能性は<bpt i="1" x="1">&lt;c1&gt;</bpt>DataImporter<ept i="1">&lt;/c1&gt;</ept>クラスによって提供されます、それは、初期化するために瑣末でない量の時間がかかると仮定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This future type can be referred to as <bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> anywhere within the structure’s definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この将来の型は、構造体の定義の範囲内のどこででも「<bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>」として参照されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This generic subscript is constrained as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この総称体添え字は、以下のように制約されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This gives a reverse alphabetical sort, with <bpt i="10" x="10">&lt;c10&gt;</bpt>"Barry"<ept i="10">&lt;/c10&gt;</ept> being placed before <bpt i="11" x="11">&lt;c11&gt;</bpt>"Alex"<ept i="11">&lt;/c11&gt;</ept>, and so on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="10" x="10">&lt;c10&gt;</bpt>"Barry"<ept i="10">&lt;/c10&gt;</ept>が<bpt i="11" x="11">&lt;c11&gt;</bpt>"Alex"<ept i="11">&lt;/c11&gt;</ept>の前に置かれるなどの、逆アルファベット順の分類を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This greeting is then passed back out of the function using the <bpt i="3" x="3">&lt;c3&gt;</bpt>return<ept i="3">&lt;/c3&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この挨拶は、それから<bpt i="3" x="3">&lt;c3&gt;</bpt>return<ept i="3">&lt;/c3&gt;</ept>キーワードを使用して逆に関数の外に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This helps you remember that it’s possible to capture <bpt i="5" x="5">&lt;c5&gt;</bpt>self<ept i="5">&lt;/c5&gt;</ept> by accident.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、偶然に<bpt i="5" x="5">&lt;c5&gt;</bpt>self<ept i="5">&lt;/c5&gt;</ept>を捕らえることは可能であるのをあなたが忘れないことを手助けします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This illustrates that the overall call to the <bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept> method has remained the same.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="0" x="0">&lt;c0&gt;</bpt>sorted(by:)<ept i="0">&lt;/c0&gt;</ept>メソッドへの呼び出し全体が、同じもののままだったことを図解します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This implementation of <bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept> is identical to the previous implementation, apart from the addition of a capture list within the <bpt i="1" x="1">&lt;c1&gt;</bpt>asHTML<ept i="1">&lt;/c1&gt;</ept> closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept>のこの実装は、<bpt i="1" x="1">&lt;c1&gt;</bpt>asHTML<ept i="1">&lt;/c1&gt;</ept>クロージャ内の捕獲リストの追加は別として、前の実装と同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This includes <bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept>, as shown here, as well as collection types such as <bpt i="6" x="6">&lt;c6&gt;</bpt>Array<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>Dictionary<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>Set<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、ここで示すように<bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept>を、それだけでなく<bpt i="6" x="6">&lt;c6&gt;</bpt>Array<ept i="6">&lt;/c6&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>Dictionary<ept i="7">&lt;/c7&gt;</ept>、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>Set<ept i="8">&lt;/c8&gt;</ept>といったコレクション型も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This includes <bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>, as shown here, as well as collection types such as <bpt i="7" x="7">&lt;c7&gt;</bpt>Array<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>Dictionary<ept i="8">&lt;/c8&gt;</ept>, and <bpt i="9" x="9">&lt;c9&gt;</bpt>Set<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、ここで示すように<bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>を、それだけでなく<bpt i="7" x="7">&lt;c7&gt;</bpt>Array<ept i="7">&lt;/c7&gt;</ept>、<bpt i="8" x="8">&lt;c8&gt;</bpt>Dictionary<ept i="8">&lt;/c8&gt;</ept>、そして<bpt i="9" x="9">&lt;c9&gt;</bpt>Set<ept i="9">&lt;/c9&gt;</ept>といったコレクション型も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This includes a protocol with an associated type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、関連型を使うプロトコルを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This includes the ability to extend types for which you do not have access to the original source code (known as <bpt i="1" x="1">&lt;e1&gt;</bpt>retroactive modeling<ept i="1">&lt;/e1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたが元々のソース・コードにアクセスをしないで型を拡張する能力を含みます（<bpt i="1" x="1">&lt;e1&gt;</bpt>遡及モデリング<ept i="1">&lt;/e1&gt;</ept>として知られます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer can be used to create a new <bpt i="2" x="2">&lt;c2&gt;</bpt>Food<ept i="2">&lt;/c2&gt;</ept> instance with a specific name:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザが、ある特定の名前を使って新しい<bpt i="2" x="2">&lt;c2&gt;</bpt>Food<ept i="2">&lt;/c2&gt;</ept>インスタンスをつくるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer checks if the <bpt i="5" x="5">&lt;c5&gt;</bpt>species<ept i="5">&lt;/c5&gt;</ept> value passed to the initializer is an empty string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、イニシャライザに渡される<bpt i="5" x="5">&lt;c5&gt;</bpt>species<ept i="5">&lt;/c5&gt;</ept>値が空の文字列かどうか検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer has a parameter called <bpt i="1" x="1">&lt;c1&gt;</bpt>generator<ept i="1">&lt;/c1&gt;</ept>, which is also of type <bpt i="2" x="2">&lt;c2&gt;</bpt>RandomNumberGenerator<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、<bpt i="1" x="1">&lt;c1&gt;</bpt>generator<ept i="1">&lt;/c1&gt;</ept>と呼ばれるパラメータを持ちます、それもまた、型<bpt i="2" x="2">&lt;c2&gt;</bpt>RandomNumberGenerator<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer has an empty body, represented by an empty pair of curly braces <bpt i="2" x="2">&lt;c2&gt;</bpt>{}<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、一対の空の波括弧<bpt i="2" x="2">&lt;c2&gt;</bpt>{}<ept i="2">&lt;/c2&gt;</ept>によって表される空の本文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer is described in more detail in <bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>Creating an Array with a Default Value<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、更に詳細に<bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>配列を１つの初期値で作成する<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer is therefore inherited by <bpt i="3" x="3">&lt;c3&gt;</bpt>RecipeIngredient<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、したがって、<bpt i="3" x="3">&lt;c3&gt;</bpt>RecipeIngredient<ept i="3">&lt;/c3&gt;</ept>によって継承されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer simply assigns the <bpt i="2" x="2">&lt;c2&gt;</bpt>origin<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>size<ept i="3">&lt;/c3&gt;</ept> argument values to the appropriate stored properties:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、単に引数値<bpt i="2" x="2">&lt;c2&gt;</bpt>origin<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>size<ept i="3">&lt;/c3&gt;</ept>を適切な保存プロパティに代入します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This initializer starts by assigning the passed <bpt i="3" x="3">&lt;c3&gt;</bpt>quantity<ept i="3">&lt;/c3&gt;</ept> argument to the <bpt i="4" x="4">&lt;c4&gt;</bpt>quantity<ept i="4">&lt;/c4&gt;</ept> property, which is the only new property introduced by <bpt i="5" x="5">&lt;c5&gt;</bpt>RecipeIngredient<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このイニシャライザは、渡された<bpt i="3" x="3">&lt;c3&gt;</bpt>quantity<ept i="3">&lt;/c3&gt;</ept>引数を<bpt i="4" x="4">&lt;c4&gt;</bpt>quantity<ept i="4">&lt;/c4&gt;</ept>プロパティに代入することによって始めます、それは、<bpt i="5" x="5">&lt;c5&gt;</bpt>RecipeIngredient<ept i="5">&lt;/c5&gt;</ept>によって導入される唯一の新しいプロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is a constant value of <bpt i="2" x="2">&lt;c2&gt;</bpt>10<ept i="2">&lt;/c2&gt;</ept> for all <bpt i="3" x="3">&lt;c3&gt;</bpt>AudioChannel<ept i="3">&lt;/c3&gt;</ept> instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、定数値で、全ての<bpt i="3" x="3">&lt;c3&gt;</bpt>AudioChannel<ept i="3">&lt;/c3&gt;</ept>インスタンスのために<bpt i="2" x="2">&lt;c2&gt;</bpt>10<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is a stored property with <bpt i="3" x="3">&lt;c3&gt;</bpt>willSet<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>didSet<ept i="4">&lt;/c4&gt;</ept> observers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="3" x="3">&lt;c3&gt;</bpt>willSet<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>didSet<ept i="4">&lt;/c4&gt;</ept>オブザーバーを持つ保存プロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is also a comment</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（これもコメントです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is because functions and closures are <bpt i="3" x="3">&lt;e3&gt;</bpt>reference types<ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、関数とクロージャが<bpt i="3" x="3">&lt;e3&gt;</bpt>参照型<ept i="3">&lt;/e3&gt;</ept>であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is because of the copy-in copy-out memory model for in-out parameters: The value is always written back to the property at the end of the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、in-outパラメータのための「コピーイン、コピーアウト」メモリーモデルが理由です：値は常に、その関数の終わりでプロパティへと書き込まれて戻されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、型それ自身には初期化時に値を保存型プロパティに代入することができるイニシャライザがないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is equivalent to a decimal value of <bpt i="7" x="7">&lt;c7&gt;</bpt>15<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、10進の値の<bpt i="7" x="7">&lt;c7&gt;</bpt>15<ept i="7">&lt;/c7&gt;</ept>に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is indicated by passing a value of <bpt i="1" x="1">&lt;c1&gt;</bpt>3<ept i="1">&lt;/c1&gt;</ept> to the structure’s <bpt i="2" x="2">&lt;c2&gt;</bpt>initializer<ept i="2">&lt;/c2&gt;</ept> as the value to use for the instance’s <bpt i="3" x="3">&lt;c3&gt;</bpt>multiplier<ept i="3">&lt;/c3&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、値<bpt i="1" x="1">&lt;c1&gt;</bpt>3<ept i="1">&lt;/c1&gt;</ept>をこの構造体の<bpt i="2" x="2">&lt;c2&gt;</bpt>initializer<ept i="2">&lt;/c2&gt;</ept>にインスタンスの<bpt i="3" x="3">&lt;c3&gt;</bpt>multiplier<ept i="3">&lt;/c3&gt;</ept>パラメータのために使う値として渡すことによって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is indicated by setting the optional <bpt i="0" x="0">&lt;c0&gt;</bpt>playerOne<ept i="0">&lt;/c0&gt;</ept> variable to <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>, meaning “no <bpt i="2" x="2">&lt;c2&gt;</bpt>Player<ept i="2">&lt;/c2&gt;</ept> instance.” At the point that this happens, the <bpt i="3" x="3">&lt;c3&gt;</bpt>playerOne<ept i="3">&lt;/c3&gt;</ept> variable’s reference to the <bpt i="4" x="4">&lt;c4&gt;</bpt>Player<ept i="4">&lt;/c4&gt;</ept> instance is broken.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはオプショナルの<bpt i="0" x="0">&lt;c0&gt;</bpt>playerOne<ept i="0">&lt;/c0&gt;</ept>変数に、「<bpt i="2" x="2">&lt;c2&gt;</bpt>Player<ept i="2">&lt;/c2&gt;</ept>インスタンスがない」ことを意味する、<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を設定することによって示されます。これが起こる時点で、<bpt i="3" x="3">&lt;c3&gt;</bpt>playerOne<ept i="3">&lt;/c3&gt;</ept>変数のもつ<bpt i="4" x="4">&lt;c4&gt;</bpt>Player<ept i="4">&lt;/c4&gt;</ept>インスタンスへの参照は壊れています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is known as <bpt i="0" x="0">&lt;e0&gt;</bpt>closing over<ept i="0">&lt;/e0&gt;</ept> those constants and variables.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、そのような定数や変数を<bpt i="0" x="0">&lt;e0&gt;</bpt>すっかりクローズする（閉じ込める）<ept i="0">&lt;/e0&gt;</ept>こととして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is known as <bpt i="0" x="0">&lt;e0&gt;</bpt>overloading<ept i="0">&lt;/e0&gt;</ept> the existing operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>既存の演算子の<bpt i="0" x="0">&lt;e0&gt;</bpt>オーバーロード<ept i="0">&lt;/e0&gt;</ept>としてこれは知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is known as <bpt i="0" x="0">&lt;e0&gt;</bpt>overriding<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="0" x="0">&lt;e0&gt;</bpt>オーバーライド<ept i="0">&lt;/e0&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is known as <bpt i="3" x="3">&lt;e3&gt;</bpt>short-circuit evaluation<ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは<bpt i="3" x="3">&lt;e3&gt;</bpt>短絡評価<ept i="3">&lt;/e3&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is known as <bpt i="5" x="5">&lt;e5&gt;</bpt>short-circuit evaluation<ept i="5">&lt;/e5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは<bpt i="5" x="5">&lt;e5&gt;</bpt>短絡評価<ept i="5">&lt;/e5&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is known as a <bpt i="1" x="1">&lt;e1&gt;</bpt>strong reference cycle<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="1" x="1">&lt;e1&gt;</bpt>強い参照循環<ept i="1">&lt;/e1&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is necessary in order for it to be able to access the <bpt i="5" x="5">&lt;c5&gt;</bpt>director<ept i="5">&lt;/c5&gt;</ept> or <bpt i="6" x="6">&lt;c6&gt;</bpt>artist<ept i="6">&lt;/c6&gt;</ept> property of a <bpt i="7" x="7">&lt;c7&gt;</bpt>Movie<ept i="7">&lt;/c7&gt;</ept> or <bpt i="8" x="8">&lt;c8&gt;</bpt>Song<ept i="8">&lt;/c8&gt;</ept> for use in the description.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、それがその説明で使う目的で<bpt i="7" x="7">&lt;c7&gt;</bpt>Movie<ept i="7">&lt;/c7&gt;</ept>または<bpt i="8" x="8">&lt;c8&gt;</bpt>Song<ept i="8">&lt;/c8&gt;</ept>のもつ<bpt i="5" x="5">&lt;c5&gt;</bpt>director<ept i="5">&lt;/c5&gt;</ept>または<bpt i="6" x="6">&lt;c6&gt;</bpt>artist<ept i="6">&lt;/c6&gt;</ept>プロパティにアクセス可能になるために必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is often done by assigning a <bpt i="0" x="0">&lt;e0&gt;</bpt>literal value<ept i="0">&lt;/e0&gt;</ept> (or <bpt i="1" x="1">&lt;e1&gt;</bpt>literal<ept i="1">&lt;/e1&gt;</ept>) to the constant or variable at the point that you declare it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="0" x="0">&lt;e0&gt;</bpt>リテラル値<ept i="0">&lt;/e0&gt;</ept>（または<bpt i="1" x="1">&lt;e1&gt;</bpt>リテラル<ept i="1">&lt;/e1&gt;</ept>）を定数または変数に、あなたがそれを宣言する時点で代入することによって、しばしば行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is particularly true when you work with functions or methods that take functions as one or more of their arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つ以上のそれの引数として関数をとる関数またはメソッドをあなたが扱うとき、これは特に当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is represented by the player’s <bpt i="1" x="1">&lt;c1&gt;</bpt>coinsInPurse<ept i="1">&lt;/c1&gt;</ept> property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、プレーヤーの<bpt i="1" x="1">&lt;c1&gt;</bpt>coinsInPurse<ept i="1">&lt;/c1&gt;</ept>プロパティによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is simply an empty tuple, which is written as <bpt i="3" x="3">&lt;c3&gt;</bpt>()<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは単に空のタプルです、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>()<ept i="3">&lt;/c3&gt;</ept>のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the end of the first multiline comment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（最初の複数行コメントの終わり。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the same as <bpt i="3" x="3">&lt;c3&gt;</bpt>0xCC<ept i="3">&lt;/c3&gt;</ept>, which has a decimal value of <bpt i="4" x="4">&lt;c4&gt;</bpt>204<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは<bpt i="3" x="3">&lt;c3&gt;</bpt>0xCC<ept i="3">&lt;/c3&gt;</ept>と同じものです、それは、10進の値の<bpt i="4" x="4">&lt;c4&gt;</bpt>204<ept i="4">&lt;/c4&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the second, nested multiline comment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（第二の入れ子の複数行コメント。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the standard calling convention for function values in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、スウィフトにおける関数値のための標準的な呼出規約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is the start of the first multiline comment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（最初の複数行コメントの始まり。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is true even for constant stored properties, as described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Assigning Constant Properties During Initialization<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>初期化の間に定数プロパティを割り当てる<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されるように、これは定数保存プロパティにさえあてはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is true even if the new value is the same as the current value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、たとえ新しい値が現在の値と同じものであるとしても当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is true even if you are overriding an automatically provided default initializer, as described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Default Initializers<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>省略時のイニシャライザ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されるように、あなたが自動的に提供される省略時のイニシャライザをオーバーライドしている場合にさえもあてはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is true even though <bpt i="3" x="3">&lt;c3&gt;</bpt>increment(forCount:)<ept i="3">&lt;/c3&gt;</ept> is defined as returning a nonoptional <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept> value in the definition of <bpt i="5" x="5">&lt;c5&gt;</bpt>CounterDataSource<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえ<bpt i="3" x="3">&lt;c3&gt;</bpt>increment(forCount:)<ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>CounterDataSource<ept i="5">&lt;/c5&gt;</ept>の定義の中で非オプショナルの<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>値を返すように定義されるとしても、これは当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is true even though type method requirements are prefixed with the <bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>static<ept i="2">&lt;/c2&gt;</ept> keyword when implemented by a class:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえ型メソッド要件がクラスによって実装されるとき<bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>static<ept i="2">&lt;/c2&gt;</ept>キーワードを前に置かれるとしても、これは当てはまります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is very similar to placing an exclamation mark (<bpt i="2" x="2">&lt;c2&gt;</bpt>!<ept i="2">&lt;/c2&gt;</ept>) after an optional value to force the unwrapping of its value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、その値を強制アンラップするためにオプショナルの値の後に感嘆符（<bpt i="2" x="2">&lt;c2&gt;</bpt>!<ept i="2">&lt;/c2&gt;</ept>）を置くことに非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is why <bpt i="14" x="14">&lt;c14&gt;</bpt>increment(forCount:)<ept i="14">&lt;/c14&gt;</ept> is also written with a question mark after its name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これが、<bpt i="14" x="14">&lt;c14&gt;</bpt>increment(forCount:)<ept i="14">&lt;/c14&gt;</ept>もまたその名前の後に疑問符を書かれる理由です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is why the <bpt i="2" x="2">&lt;c2&gt;</bpt>m<ept i="2">&lt;/c2&gt;</ept> computed property returns <bpt i="3" x="3">&lt;c3&gt;</bpt>self<ept i="3">&lt;/c3&gt;</ept>—the expression <bpt i="4" x="4">&lt;c4&gt;</bpt>1.m<ept i="4">&lt;/c4&gt;</ept> is considered to calculate a <bpt i="5" x="5">&lt;c5&gt;</bpt>Double<ept i="5">&lt;/c5&gt;</ept> value of <bpt i="6" x="6">&lt;c6&gt;</bpt>1.0<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これが<bpt i="2" x="2">&lt;c2&gt;</bpt>m<ept i="2">&lt;/c2&gt;</ept>計算プロパティが<bpt i="3" x="3">&lt;c3&gt;</bpt>self<ept i="3">&lt;/c3&gt;</ept>を返す理由です ― 式<bpt i="4" x="4">&lt;c4&gt;</bpt>1.m<ept i="4">&lt;/c4&gt;</ept>は、<bpt i="6" x="6">&lt;c6&gt;</bpt>1.0<ept i="6">&lt;/c6&gt;</ept>の<bpt i="5" x="5">&lt;c5&gt;</bpt>Double<ept i="5">&lt;/c5&gt;</ept>値を計算するものと考えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This keeps track of the maximum input value that has been received by <bpt i="1" x="1">&lt;e1&gt;</bpt>any<ept i="1">&lt;/e1&gt;</ept> <bpt i="2" x="2">&lt;c2&gt;</bpt>AudioChannel<ept i="2">&lt;/c2&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="1" x="1">&lt;e1&gt;</bpt>あらゆる<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>AudioChannel<ept i="2">&lt;/c2&gt;</ept>インスタンスによって受け取られた最大入力値の情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This key-value type matches the type of the <bpt i="1" x="1">&lt;c1&gt;</bpt>airports<ept i="1">&lt;/c1&gt;</ept> variable declaration (a dictionary with only <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> keys, and only <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> values), and so the assignment of the dictionary literal is permitted as a way to initialize the <bpt i="4" x="4">&lt;c4&gt;</bpt>airports<ept i="4">&lt;/c4&gt;</ept> dictionary with two initial items.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この「キーと値」型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>airports<ept i="1">&lt;/c1&gt;</ept>変数の宣言の型（<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>のキーのみ、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>の値のみをもつ辞書）に合致します、なのでこの辞書リテラルを代入することは、２つの最初の項目で<bpt i="4" x="4">&lt;c4&gt;</bpt>airports<ept i="4">&lt;/c4&gt;</ept>辞書を初期化する方法として許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This keyword indicates that the definition of the closure’s parameters and return type has finished, and the body of the closure is about to begin.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このキーワードはクロージャのパラメータと戻り型の定義が終わったことを示します、そして、クロージャの本文はまさに開始しようとしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This kind of function call expression has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この種類の関数呼び出し式は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This kind of function is known as a <bpt i="0" x="0">&lt;e0&gt;</bpt>nested function<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この種類の関数は、<bpt i="0" x="0">&lt;e0&gt;</bpt>入れ子にされた関数<ept i="0">&lt;/e0&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This kind of range is called a <bpt i="0" x="0">&lt;e0&gt;</bpt>one-sided range<ept i="0">&lt;/e0&gt;</ept> because the operator has a value on only one side.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この種類の範囲は、<bpt i="0" x="0">&lt;e0&gt;</bpt>片側範囲<ept i="0">&lt;/e0&gt;</ept>と呼ばれます、なぜならこの演算子は一方の側でのみ値を持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This lets you call the throwing function inside a <bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>catch<ept i="3">&lt;/c3&gt;</ept> block and handle errors in the <bpt i="4" x="4">&lt;c4&gt;</bpt>catch<ept i="4">&lt;/c4&gt;</ept> clause by throwing a different error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたにスロー関数を<bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>catch<ept i="3">&lt;/c3&gt;</ept>プロックの内部で呼び出させ、その<bpt i="4" x="4">&lt;c4&gt;</bpt>catch<ept i="4">&lt;/c4&gt;</ept>節において異なるエラーをスローすることによって、エラーを取り扱わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This list is transformed into a tree by applying operator precedence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このリストは、演算子優先順位を適用することによって、ツリー（木構造）に変えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This makes for highly readable code when working with explicitly typed enumeration values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、明示的に型指定された列挙値を扱う場合に、非常に可読性の高いコードにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This makes it easy to create custom string values for display, storage, and printing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、表示、保存、そして出力するために個々の注文に応じた文字列値をつくることを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This makes the <bpt i="5" x="5">&lt;c5&gt;</bpt>switch<ept i="5">&lt;/c5&gt;</ept> statement safer and easier to use than the one in C and avoids executing more than one <bpt i="6" x="6">&lt;c6&gt;</bpt>switch<ept i="6">&lt;/c6&gt;</ept> case by mistake.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="5" x="5">&lt;c5&gt;</bpt>switch<ept i="5">&lt;/c5&gt;</ept>文をCのものよりも安全で使いやすくして、誤って複数の<bpt i="6" x="6">&lt;c6&gt;</bpt>switch<ept i="6">&lt;/c6&gt;</ept>ケース節を実行することを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This matches the single requirement of the <bpt i="3" x="3">&lt;c3&gt;</bpt>FullyNamed<ept i="3">&lt;/c3&gt;</ept> protocol, and means that <bpt i="4" x="4">&lt;c4&gt;</bpt>Person<ept i="4">&lt;/c4&gt;</ept> has correctly conformed to the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="3" x="3">&lt;c3&gt;</bpt>FullyNamed<ept i="3">&lt;/c3&gt;</ept>プロトコルの唯一の要件に適合します、したがってその<bpt i="4" x="4">&lt;c4&gt;</bpt>Person<ept i="4">&lt;/c4&gt;</ept>が正しくそのプロトコルに従ったことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This matches the type of the <bpt i="1" x="1">&lt;c1&gt;</bpt>shoppingList<ept i="1">&lt;/c1&gt;</ept> variable’s declaration (an array that can only contain <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> values), and so the assignment of the array literal is permitted as a way to initialize <bpt i="3" x="3">&lt;c3&gt;</bpt>shoppingList<ept i="3">&lt;/c3&gt;</ept> with two initial items.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは<bpt i="1" x="1">&lt;c1&gt;</bpt>shoppingList<ept i="1">&lt;/c1&gt;</ept>変数の宣言（<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>値を含むことだけができる配列）の型に合致します、それでこの配列リテラルの代入は、２つの最初の項目で<bpt i="3" x="3">&lt;c3&gt;</bpt>shoppingList<ept i="3">&lt;/c3&gt;</ept>を初期化するためのやり方として認められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means it is possible to have precedence groups with undefined relative precedence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これが意味するのは、未定義の関係優先順位による優先順位グループを持つことは可能だということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that <bpt i="0" x="0">&lt;c0&gt;</bpt>4.75<ept i="0">&lt;/c0&gt;</ept> becomes <bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>-3.9<ept i="2">&lt;/c2&gt;</ept> becomes <bpt i="3" x="3">&lt;c3&gt;</bpt>-3<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="0" x="0">&lt;c0&gt;</bpt>4.75<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept>に、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>-3.9<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>-3<ept i="3">&lt;/c3&gt;</ept>になることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that <bpt i="2" x="2">&lt;c2&gt;</bpt>SomeInternalClass<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>someInternalConstant<ept i="3">&lt;/c3&gt;</ept> can be written without an explicit access-level modifier, and will still have an access level of internal:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="2" x="2">&lt;c2&gt;</bpt>SomeInternalClass<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>someInternalConstant<ept i="3">&lt;/c3&gt;</ept>が明示的なアクセス水準修飾子なしで書かれることができ、それでもまだ内部のアクセス水準を持つことを意味します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that <bpt i="2" x="2">&lt;c2&gt;</bpt>a % b<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>a % -b<ept i="3">&lt;/c3&gt;</ept> always give the same answer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="2" x="2">&lt;c2&gt;</bpt>a % b<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>a % -b<ept i="3">&lt;/c3&gt;</ept>が常に同じ答えを与えることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that a <bpt i="1" x="1">&lt;c1&gt;</bpt>defer<ept i="1">&lt;/c1&gt;</ept> statement can be used, for example, to perform manual resource management such as closing file descriptors, and to perform actions that need to happen even if an error is thrown.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは<bpt i="1" x="1">&lt;c1&gt;</bpt>defer<ept i="1">&lt;/c1&gt;</ept>文が、例えば、ファイル記述子を閉じることなどの手動リソース管理を実行するために、そしてたとえエラーがスローされるとしても起こることが必要な動作を実行するために使われることができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that a change to the value of <bpt i="4" x="4">&lt;c4&gt;</bpt>a<ept i="4">&lt;/c4&gt;</ept> in the outer scope does not affect the value of <bpt i="5" x="5">&lt;c5&gt;</bpt>a<ept i="5">&lt;/c5&gt;</ept> in the inner scope, nor does a change to <bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept> inside the closure affect the value of <bpt i="7" x="7">&lt;c7&gt;</bpt>a<ept i="7">&lt;/c7&gt;</ept> outside the closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これが意味するのは、外側のスコープの<bpt i="4" x="4">&lt;c4&gt;</bpt>a<ept i="4">&lt;/c4&gt;</ept>の値に対する変更は内側のスコープの<bpt i="5" x="5">&lt;c5&gt;</bpt>a<ept i="5">&lt;/c5&gt;</ept>の値に影響を及ぼさない、そしてまたクロージャ内部の<bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept>に対する変更はクロージャ外部の<bpt i="7" x="7">&lt;c7&gt;</bpt>a<ept i="7">&lt;/c7&gt;</ept>に影響を及ぼさないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that a function can return another function as its value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、ある関数が別の関数をその値として返すことができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that all of the information needed to infer an omitted type or part of a type in an expression must be accessible from type-checking the expression or one of its subexpressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、ある式における省略される型や型の一部分を推論するために必要とされる情報のすべては、型を調べているその式またはそれの下位式の１つからアクセス可能でなければならないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that any structure and enumeration instances you create—and any value types they have as properties—are always copied when they are passed around in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたがつくるあらゆる構造体や列挙のインスタンス ― そして、それらがプロパティとして持つあらゆる値型 ― は、あなたのコードの中であちこち渡される時に常にコピーされることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that classes have additional responsibilities for ensuring that all stored properties they inherit are assigned a suitable value during initialization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、クラスが、それが継承する全ての保存プロパティが初期化の間に適切な値を代入されることを確実にすることに対する追加の責任を持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that code that would otherwise run immediately after the call is never executed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これが意味するのは、そうでなければ呼び出しの直後に動作するコードは、決して実行されないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that data such as strings, arrays, and dictionaries are copied when they are assigned to a new constant or variable, or when they are passed to a function or method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、文字列、配列、および辞書などのデータが、それらが新しい定数や変数に代入される時に、またはそれらが関数やメソッドに渡される時に、コピーされることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that different characters—and different representations of the same character—can require different amounts of memory to store.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは異なる文字—さらに同じ文字の異なる表現—が、保存するために異なる量のメモリを必要とすることがあるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that in the example above, <bpt i="0" x="0">&lt;c0&gt;</bpt>array3D[0]<ept i="0">&lt;/c0&gt;</ept> refers to <bpt i="1" x="1">&lt;c1&gt;</bpt>[[1, 2], [3, 4]]<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>array3D[0][1]<ept i="2">&lt;/c2&gt;</ept> refers to <bpt i="3" x="3">&lt;c3&gt;</bpt>[3, 4]<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>array3D[0][1][1]<ept i="4">&lt;/c4&gt;</ept> refers to the value 4.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、上の例で、<bpt i="0" x="0">&lt;c0&gt;</bpt>array3D[0]<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>[[1, 2], [3, 4]]<ept i="1">&lt;/c1&gt;</ept>に言及し、<bpt i="2" x="2">&lt;c2&gt;</bpt>array3D[0][1]<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>[3, 4]<ept i="3">&lt;/c3&gt;</ept>に言及し、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>array3D[0][1][1]<ept i="4">&lt;/c4&gt;</ept>は値４に言及することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that it returns a <bpt i="2" x="2">&lt;e2&gt;</bpt>function<ept i="2">&lt;/e2&gt;</ept>, rather than a simple value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、それが<bpt i="2" x="2">&lt;e2&gt;</bpt>関数<ept i="2">&lt;/e2&gt;</ept>を返すことを意味します、単純なひとつの値ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that the <bpt i="2" x="2">&lt;c2&gt;</bpt>(String, String)<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept> types do not need to be written as part of the closure expression’s definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="2" x="2">&lt;c2&gt;</bpt>(String, String)<ept i="2">&lt;/c2&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept>型が、クロージャ式の定義の一部として書かれる必要がないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that the <bpt i="3" x="3">&lt;c3&gt;</bpt>capitalCity<ept i="3">&lt;/c3&gt;</ept> property has a default value of <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>, like any other optional, but can be accessed without the need to unwrap its value as described in <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Implicitly Unwrapped Optionals<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>暗黙的にアンラップされるオプショナル<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>で記述されるように、<bpt i="3" x="3">&lt;c3&gt;</bpt>capitalCity<ept i="3">&lt;/c3&gt;</ept>プロパティが、オプショナルの他のものの様に、<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>の省略時の値を持つが、アンラップする必要なしでその値にアクセスされることができることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that the <bpt i="5" x="5">&lt;c5&gt;</bpt>Country<ept i="5">&lt;/c5&gt;</ept> initializer can start to reference and pass around the implicit <bpt i="6" x="6">&lt;c6&gt;</bpt>self<ept i="6">&lt;/c6&gt;</ept> property as soon as the <bpt i="7" x="7">&lt;c7&gt;</bpt>name<ept i="7">&lt;/c7&gt;</ept> property is set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは<bpt i="5" x="5">&lt;c5&gt;</bpt>Country<ept i="5">&lt;/c5&gt;</ept>イニシャライザが、<bpt i="7" x="7">&lt;c7&gt;</bpt>name<ept i="7">&lt;/c7&gt;</ept>プロパティが設定されるとすぐに、暗黙の<bpt i="6" x="6">&lt;c6&gt;</bpt>self<ept i="6">&lt;/c6&gt;</ept>プロパティに基づいて参照したり渡したりを可能であるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that the letter <bpt i="6" x="6">&lt;c6&gt;</bpt>"B"<ept i="6">&lt;/c6&gt;</ept> is “greater than” the letter <bpt i="7" x="7">&lt;c7&gt;</bpt>"A"<ept i="7">&lt;/c7&gt;</ept>, and the string <bpt i="8" x="8">&lt;c8&gt;</bpt>"Tom"<ept i="8">&lt;/c8&gt;</ept> is greater than the string <bpt i="9" x="9">&lt;c9&gt;</bpt>"Tim"<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは文字<bpt i="6" x="6">&lt;c6&gt;</bpt>"B"<ept i="6">&lt;/c6&gt;</ept>は文字<bpt i="7" x="7">&lt;c7&gt;</bpt>"A"<ept i="7">&lt;/c7&gt;</ept>「より大きい」こと、そして文字列<bpt i="8" x="8">&lt;c8&gt;</bpt>"Tom"<ept i="8">&lt;/c8&gt;</ept>は文字列<bpt i="9" x="9">&lt;c9&gt;</bpt>"Tim"<ept i="9">&lt;/c9&gt;</ept>よりも大きいことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that the value is allowed to outlive the lifetime of the call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、その値が呼び出しのライフタイムより長生きするのを許されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that they are suited to different kinds of tasks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、それらが異なる種類の作業に適していることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that they return a value of <bpt i="3" x="3">&lt;c3&gt;</bpt>()<ept i="3">&lt;/c3&gt;</ept>, or an empty tuple.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、それらが値<bpt i="3" x="3">&lt;c3&gt;</bpt>()<ept i="3">&lt;/c3&gt;</ept>、または空のタプルを返すことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that when you break the strong reference held by the <bpt i="5" x="5">&lt;c5&gt;</bpt>john<ept i="5">&lt;/c5&gt;</ept> variable by setting it to <bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept>, there are no more strong references to the <bpt i="7" x="7">&lt;c7&gt;</bpt>Person<ept i="7">&lt;/c7&gt;</ept> instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたが<bpt i="5" x="5">&lt;c5&gt;</bpt>john<ept i="5">&lt;/c5&gt;</ept>変数によって保持される強い参照を、それを<bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept>に設定することによって壊すとき、<bpt i="7" x="7">&lt;c7&gt;</bpt>Person<ept i="7">&lt;/c7&gt;</ept>インスタンスへの強い参照がもうそれ以上ないことを意味します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that you can change (or <bpt i="1" x="1">&lt;e1&gt;</bpt>mutate<ept i="1">&lt;/e1&gt;</ept>) the collection after it’s created by adding, removing, or changing items in the collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたがコレクションを変更する（または<bpt i="1" x="1">&lt;e1&gt;</bpt>変化させる<ept i="1">&lt;/e1&gt;</ept>）ことが、それが作成された後にそのコレクション中の項目を追加、削除、または変更することによって可能なのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that you can extend <bpt i="5" x="5">&lt;c5&gt;</bpt>Array<ept i="5">&lt;/c5&gt;</ept> to conform to the <bpt i="6" x="6">&lt;c6&gt;</bpt>Container<ept i="6">&lt;/c6&gt;</ept> protocol simply by declaring that <bpt i="7" x="7">&lt;c7&gt;</bpt>Array<ept i="7">&lt;/c7&gt;</ept> adopts the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたが<bpt i="5" x="5">&lt;c5&gt;</bpt>Array<ept i="5">&lt;/c5&gt;</ept>を拡張して<bpt i="6" x="6">&lt;c6&gt;</bpt>Container<ept i="6">&lt;/c6&gt;</ept>プロトコルに準拠することが、<bpt i="7" x="7">&lt;c7&gt;</bpt>Array<ept i="7">&lt;/c7&gt;</ept>がそのプロトコルを採用すると宣言することによって可能であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that you can use <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> to disambiguate between type properties and type method parameters, just as you do for instance properties and instance method parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはあなたが型プロパティと型メソッドパラメータの間で曖昧さをなくすために<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>を使うことができることを意味します、ちょうどあなたがインスタンスプロパティとインスタンスメソッドパラメータでするように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that you cannot access any other property values from within your closure, even if those properties have default values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、たとえそれらのプロパティには省略時の値があるとしても、あなたがあなたのクロージャ内から他のどのプロパティ値にもアクセスすることができないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that you cannot insert a value of the wrong type into a collection by mistake.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたが間違った型の値を誤ってあるコレクションの中に入れることが不可能なことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that you can’t accidentally access methods or properties that the class implements in addition to its protocol conformance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、クラスがそれのプロトコル準拠にさらに加えて実装するメソッドやプロパティにあなたが偶然にアクセスすることができないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that you can’t change the value of a parameter by mistake.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたが誤ってパラメータの値を変えることができないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means you always get great performance when working with strings as value types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、値型として文字列を扱うとき、あなたは常に非常に大きいパフォーマンスを得ることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means you can use as many assertions as you want during your development process, without impacting performance in production.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これが意味するのは、あなたは多くの表明をあなたが望むだけあなたの開発過程の間に使用できる、製品での性能に影響を与えることなしに、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means you can use constants to name a value that you determine once but use in many places.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたが一度だけ決定するが多くの場所で使用する値に対して名前をつけるために定数を利用できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means, if you have a large project that’s divided into multiple frameworks, you can migrate your code from Swift 3 to Swift 4 one framework at a time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたが複数のフレームワークへと分割される巨大なプロジェクトを持つならば、あなたはあなたのコードをSwift 3からSwift 4へと一度に１フレームワークずつ移行できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means, if you import Foundation, you can access those <bpt i="4" x="4">&lt;c4&gt;</bpt>NSString<ept i="4">&lt;/c4&gt;</ept> methods on <bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept> without casting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これが意味するのは、あなたがFoundationをインポートするならば、あなたはそれら<bpt i="4" x="4">&lt;c4&gt;</bpt>NSString<ept i="4">&lt;/c4&gt;</ept>メソッドに<bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept>上でキャストなしでアクセスできるという事です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This memory holds information about the type of the instance, together with the values of any stored properties associated with that instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメモリは、インスタンスの型に関する情報を、そのインスタンスと結びつけられるあらゆる保存プロパティの値と共に持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method calls the generator’s <bpt i="2" x="2">&lt;c2&gt;</bpt>random()<ept i="2">&lt;/c2&gt;</ept> method to create a new random number between <bpt i="3" x="3">&lt;c3&gt;</bpt>0.0<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>1.0<ept i="4">&lt;/c4&gt;</ept>, and uses this random number to create a dice roll value within the correct range.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、<bpt i="3" x="3">&lt;c3&gt;</bpt>0.0<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>1.0<ept i="4">&lt;/c4&gt;</ept>の間で新しい乱数をつくるgeneratorの<bpt i="2" x="2">&lt;c2&gt;</bpt>random()<ept i="2">&lt;/c2&gt;</ept>メソッドを呼んで、この乱数を正しい範囲内でさいころを振った値をつくるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method checks the properties of the address and returns <bpt i="3" x="3">&lt;c3&gt;</bpt>buildingName<ept i="3">&lt;/c3&gt;</ept> if it has a value, or <bpt i="4" x="4">&lt;c4&gt;</bpt>buildingNumber<ept i="4">&lt;/c4&gt;</ept> concatenated with <bpt i="5" x="5">&lt;c5&gt;</bpt>street<ept i="5">&lt;/c5&gt;</ept> if both have values, or <bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、アドレスのプロパティを調べて、それが値を持つならば<bpt i="3" x="3">&lt;c3&gt;</bpt>buildingName<ept i="3">&lt;/c3&gt;</ept>を、または両方とも値を持つならば<bpt i="4" x="4">&lt;c4&gt;</bpt>buildingNumber<ept i="4">&lt;/c4&gt;</ept>に繋げて<bpt i="5" x="5">&lt;c5&gt;</bpt>street<ept i="5">&lt;/c5&gt;</ept>を、またはそれ以外では<bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method does not actually do anything for a base <bpt i="2" x="2">&lt;c2&gt;</bpt>Vehicle<ept i="2">&lt;/c2&gt;</ept> instance, but will be customized by subclasses of <bpt i="3" x="3">&lt;c3&gt;</bpt>Vehicle<ept i="3">&lt;/c3&gt;</ept> later on:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは実際に何かを基盤<bpt i="2" x="2">&lt;c2&gt;</bpt>Vehicle<ept i="2">&lt;/c2&gt;</ept>インスタンスのために行うわけではありません、しかし後で<bpt i="3" x="3">&lt;c3&gt;</bpt>Vehicle<ept i="3">&lt;/c3&gt;</ept>のサブクラスによって目的に合わせて作り変えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method does not specify a return type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、戻り型を指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method removes the item at the specified index and returns the removed item (although you can ignore the returned value if you do not need it):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、指定されたインデックスでの項目を取り除いて、取り除かれた項目を返します（けれども、あなたがそれを必要としないならば、返された値を無視することができます）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method removes the key-value pair if it exists and returns the removed value, or returns <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> if no value existed:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、それが存在するならば「キーと値」の対を削除して、削除された値を返します、または値が存在しないならば<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method returns a value of type <bpt i="2" x="2">&lt;c2&gt;</bpt>String?<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、型<bpt i="2" x="2">&lt;c2&gt;</bpt>String?<ept i="2">&lt;/c2&gt;</ept>の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This method unlocks the next level for all players and updates the player’s progress to move them to the next level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドは、全てのプレーヤーたちのために次のレベルの錠をあけて、プレーヤーの進捗をかれらを次のレベルへ移動するために更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This might be a description of itself, or a text version of its current state:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、それ自身の説明、またはテキスト版のそれの現在の状態であるかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This might be because a <bpt i="2" x="2">&lt;c2&gt;</bpt>DataImporter<ept i="2">&lt;/c2&gt;</ept> instance needs to open a file and read its contents into memory when the <bpt i="3" x="3">&lt;c3&gt;</bpt>DataImporter<ept i="3">&lt;/c3&gt;</ept> instance is initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、<bpt i="2" x="2">&lt;c2&gt;</bpt>DataImporter<ept i="2">&lt;/c2&gt;</ept>インスタンスが初期化されるとき、<bpt i="3" x="3">&lt;c3&gt;</bpt>DataImporter<ept i="3">&lt;/c3&gt;</ept>インスタンスがファイルを開いてメモリーにその内容を読む必要があるからでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This modification tracking is implemented with a <bpt i="5" x="5">&lt;c5&gt;</bpt>didSet<ept i="5">&lt;/c5&gt;</ept> property observer on the <bpt i="6" x="6">&lt;c6&gt;</bpt>value<ept i="6">&lt;/c6&gt;</ept> property, which increments <bpt i="7" x="7">&lt;c7&gt;</bpt>numberOfEdits<ept i="7">&lt;/c7&gt;</ept> every time the <bpt i="8" x="8">&lt;c8&gt;</bpt>value<ept i="8">&lt;/c8&gt;</ept> property is set to a new value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この修正追跡は、<bpt i="5" x="5">&lt;c5&gt;</bpt>didSet<ept i="5">&lt;/c5&gt;</ept>プロパティオブザーバーとして<bpt i="6" x="6">&lt;c6&gt;</bpt>value<ept i="6">&lt;/c6&gt;</ept>プロパティ上で実行されます、それは、<bpt i="7" x="7">&lt;c7&gt;</bpt>numberOfEdits<ept i="7">&lt;/c7&gt;</ept>を<bpt i="8" x="8">&lt;c8&gt;</bpt>value<ept i="8">&lt;/c8&gt;</ept>プロパティが新しい値に設定されるたびに増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This new <bpt i="0" x="0">&lt;c0&gt;</bpt>isTop(_:)<ept i="0">&lt;/c0&gt;</ept> method first checks that the stack isn’t empty, and then compares the given item against the stack’s topmost item.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>isTop(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドは、まずスタックが空でないことを確認します、それから与えられた項目をスタックの持つ最も上の項目と比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This new <bpt i="1" x="1">&lt;c1&gt;</bpt>startsWith(_:)<ept i="1">&lt;/c1&gt;</ept> method can be used with any type that conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Container<ept i="2">&lt;/c2&gt;</ept> protocol, including the stacks and arrays used above, as long as the container’s items are equatable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>startsWith(_:)<ept i="1">&lt;/c1&gt;</ept>メソッドは<bpt i="2" x="2">&lt;c2&gt;</bpt>Container<ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠するあらゆる型で使われることができます、上で使われるスタックと配列を含めて、コンテナの持つ項目が同等評価可能である限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This new default can still be overridden within the extension for individual type members.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この新しい省略時設定はさらに、個々の型メンバーのために拡張内でオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This new initializer starts by calculating an appropriate origin point based on the provided <bpt i="0" x="0">&lt;c0&gt;</bpt>center<ept i="0">&lt;/c0&gt;</ept> point and <bpt i="1" x="1">&lt;c1&gt;</bpt>size<ept i="1">&lt;/c1&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この新しいイニシャライザは、提供された<bpt i="0" x="0">&lt;c0&gt;</bpt>center<ept i="0">&lt;/c0&gt;</ept>点と<bpt i="1" x="1">&lt;c1&gt;</bpt>size<ept i="1">&lt;/c1&gt;</ept>値に基づいて適切な起源点を計算することによって始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This next code snippet defines an optional <bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept> variable called <bpt i="1" x="1">&lt;c1&gt;</bpt>john<ept i="1">&lt;/c1&gt;</ept>, which will be used to store a reference to a specific customer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>次のコード断片は、<bpt i="1" x="1">&lt;c1&gt;</bpt>john<ept i="1">&lt;/c1&gt;</ept>と呼ばれる、オプショナルの<bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept>変数を定義します。それは、特定の顧客への参照を保存するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This next code snippet defines two variables of optional type called <bpt i="0" x="0">&lt;c0&gt;</bpt>john<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>unit4A<ept i="1">&lt;/c1&gt;</ept>, which will be set to a specific <bpt i="2" x="2">&lt;c2&gt;</bpt>Apartment<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Person<ept i="3">&lt;/c3&gt;</ept> instance below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この次のコード断片は<bpt i="0" x="0">&lt;c0&gt;</bpt>john<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>unit4A<ept i="1">&lt;/c1&gt;</ept>と呼ばれるオプショナルの型の２つの変数を定義します、それは、特定の<bpt i="2" x="2">&lt;c2&gt;</bpt>Apartment<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>Person<ept i="3">&lt;/c3&gt;</ept>インスタンスに以降で設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This next example shows a class called <bpt i="0" x="0">&lt;c0&gt;</bpt>DiceGameTracker<ept i="0">&lt;/c0&gt;</ept>, which adopts the <bpt i="1" x="1">&lt;c1&gt;</bpt>DiceGameDelegate<ept i="1">&lt;/c1&gt;</ept> protocol:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この次の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>DiceGameTracker<ept i="0">&lt;/c0&gt;</ept>と呼ばれるクラスを示します、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>DiceGameDelegate<ept i="1">&lt;/c1&gt;</ept>プロトコルを採用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This number is then shifted 16 places to the right (<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;&gt; 16<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この数は、それから右に16桁シフトされます（<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;&gt; 16<ept i="0">&lt;/c0&gt;</ept>）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This observer performs two checks:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このオブザーバーは、２つのチェックをします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This operator adds together the <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> values of two vectors, and subtracts the <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept> value of the second vector from the first.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算子は、２つのベクトルの<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>値を一緒に加えて、第二のベクトルの<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>値を最初のものから減じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This operator does not have an existing meaning in Swift, and so it is given its own custom meaning below in the specific context of working with <bpt i="1" x="1">&lt;c1&gt;</bpt>Vector2D<ept i="1">&lt;/c1&gt;</ept> instances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この演算子は、スウィフトにおいて既存の意味を持ちません、なので、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>Vector2D<ept i="1">&lt;/c1&gt;</ept>インスタンスを扱う特定の文脈の下で、独自のあつらえの意味を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This opt-in approach prevents hidden conversion errors and helps make type conversion intentions explicit in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このオプトインの（個々に決めていく）取り組み方は、隠された変換エラーを防いで、あなたのコードにおいて型変換の意図を明確にするのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This optional binding is written “<bpt i="3" x="3">&lt;c3&gt;</bpt>if let movie = item as? Movie<ept i="3">&lt;/c3&gt;</ept>”, which can be read as:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このオプショナル束縛は「<bpt i="3" x="3">&lt;c3&gt;</bpt>if let movie = item as? Movie<ept i="3">&lt;/c3&gt;</ept>」のように書かれます、それは、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This optional value contains the old value for that key if one existed before the update, or <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept> if no value existed:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このオプショナルの値は、それが更新の前に存在するならばそのキーに対する古い値を、値が存在しないならば<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This output value is then shifted eight places to the right, giving a value of <bpt i="3" x="3">&lt;c3&gt;</bpt>0x66<ept i="3">&lt;/c3&gt;</ept>, which has a decimal value of <bpt i="4" x="4">&lt;c4&gt;</bpt>102<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この出力値は、それから８桁右にシフトされて、<bpt i="3" x="3">&lt;c3&gt;</bpt>0x66<ept i="3">&lt;/c3&gt;</ept>の値を与えます、それは10進の値の<bpt i="4" x="4">&lt;c4&gt;</bpt>102<ept i="4">&lt;/c4&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This part of the book describes the formal grammar of the Swift programming language.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>本のこの部分は、スウィフトプログラミング言語の形式文法を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This performance optimization means you don’t have to pay the performance cost of copying memory until you modify either the string or substring.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この性能最適化が意味するのは、あなたがメモリをコピーする性能経費を、あなたが文字列か下位文字列のどちらかを修正するまでは払う必要がないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This placeholder is replaced with the actual value of <bpt i="2" x="2">&lt;c2&gt;</bpt>multiplier<ept i="2">&lt;/c2&gt;</ept> when the string interpolation is evaluated to create an actual string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプレースホルダーは、文字列補間が実際の文字列を作成するために評価されるとき、<bpt i="2" x="2">&lt;c2&gt;</bpt>multiplier<ept i="2">&lt;/c2&gt;</ept>の実際の値と取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This procedure is known as <bpt i="3" x="3">&lt;e3&gt;</bpt>switching<ept i="3">&lt;/e3&gt;</ept> on the value that is being considered.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この手順は、考察されている値での<bpt i="3" x="3">&lt;e3&gt;</bpt>切り替え（スイッチング）<ept i="3">&lt;/e3&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This process continues until the end of the range is reached.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この過程は、範囲の終わりに達するまで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that is required before the new instance is ready for use.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この過程は、そのインスタンスの保存プロパティそれぞれに初期値を設定すること、および新しいインスタンスの使用準備が整う前に必要とされる他のあらゆる設定や初期化を行うことを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This process is described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Resolving Strong Reference Cycles Between Class Instances<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この過程は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>クラスインスタンス間の強い参照循環の解消<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This process is described in <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Modifying Value Types from Within Instance Methods<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この過程は、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>値型をインスタンスメソッド内から修正する<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This process is described in <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Working with Characters<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このやり方は<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>文字を扱う<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This process satisfies safety check 1 from <bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>Two-Phase Initialization<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept> above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この過程は、上記の<bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>２段階初期化<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>の安全点検１を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This process transforms it into the tree (2 + (3 * 5)).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この処理は、それをツリー(2 + (3 * 5))に変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This process, known as <bpt i="0" x="0">&lt;e0&gt;</bpt>initializer delegation<ept i="0">&lt;/e0&gt;</ept>, avoids duplicating code across multiple initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この処理、<bpt i="0" x="0">&lt;e0&gt;</bpt>イニシャライザ委任<ept i="0">&lt;/e0&gt;</ept>として知られるものは、複数のイニシャライザにまたがってコードを繰り返し複製することを避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This property is of type <bpt i="2" x="2">&lt;c2&gt;</bpt>String.UTF16View<ept i="2">&lt;/c2&gt;</ept>, which is a collection of unsigned 16-bit (<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt16<ept i="3">&lt;/c3&gt;</ept>) values, one for each 16-bit code unit in the string’s UTF-16 representation:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティは型<bpt i="2" x="2">&lt;c2&gt;</bpt>String.UTF16View<ept i="2">&lt;/c2&gt;</ept>です、そしてそれは、符号なし16ビット（<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt16<ept i="3">&lt;/c3&gt;</ept>）の値の集まりで、そのひとつがその文字列のUTF-16叙述における各16ビット符号単位です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This property is of type <bpt i="2" x="2">&lt;c2&gt;</bpt>String.UTF8View<ept i="2">&lt;/c2&gt;</ept>, which is a collection of unsigned 8-bit (<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept>) values, one for each byte in the string’s UTF-8 representation:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティは型<bpt i="2" x="2">&lt;c2&gt;</bpt>String.UTF8View<ept i="2">&lt;/c2&gt;</ept>です、そしてそれは、符号なし８ビット（<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept>）の値の集まりで、それぞれがその文字列のUTF-８叙述における各バイトです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This property is of type <bpt i="2" x="2">&lt;c2&gt;</bpt>UnicodeScalarView<ept i="2">&lt;/c2&gt;</ept>, which is a collection of values of type <bpt i="3" x="3">&lt;c3&gt;</bpt>UnicodeScalar<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティは型<bpt i="2" x="2">&lt;c2&gt;</bpt>UnicodeScalarView<ept i="2">&lt;/c2&gt;</ept>です、そしてそれは、<bpt i="3" x="3">&lt;c3&gt;</bpt>UnicodeScalar<ept i="3">&lt;/c3&gt;</ept>型の値の集まりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This property references a closure that combines <bpt i="2" x="2">&lt;c2&gt;</bpt>name<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>text<ept i="3">&lt;/c3&gt;</ept> into an HTML string fragment.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロパティは、<bpt i="2" x="2">&lt;c2&gt;</bpt>name<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>text<ept i="3">&lt;/c3&gt;</ept>をHTML文字列断片に結合するクロージャに参照をつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This protocol doesn’t specify how the items in the container should be stored or what type they’re allowed to be.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロトコルは、コンテナの中の項目が格納されなければならない方法やそれらが許される型が何であるかを指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This protocol, <bpt i="0" x="0">&lt;c0&gt;</bpt>RandomNumberGenerator<ept i="0">&lt;/c0&gt;</ept>, requires any conforming type to have an instance method called <bpt i="1" x="1">&lt;c1&gt;</bpt>random<ept i="1">&lt;/c1&gt;</ept>, which returns a <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept> value whenever it’s called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロトコル、<bpt i="0" x="0">&lt;c0&gt;</bpt>RandomNumberGenerator<ept i="0">&lt;/c0&gt;</ept>は、あらゆる準拠型に<bpt i="1" x="1">&lt;c1&gt;</bpt>random<ept i="1">&lt;/c1&gt;</ept>と呼ばれるインスタンスメソッドを持つことを要求します、それは、それが呼ばれた時はいつでもある<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This provides a syntactically convenient way to defer the evaluation of an expression without needing to write an explicit closure when you call the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたがその関数を呼び出す時に明示的なクロージャを書く必要なしに、ある式の評価を延期する統語的に便利な方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This provision ensures that the <bpt i="8" x="8">&lt;c8&gt;</bpt>switch<ept i="8">&lt;/c8&gt;</ept> statement is exhaustive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この条項は、<bpt i="8" x="8">&lt;c8&gt;</bpt>switch<ept i="8">&lt;/c8&gt;</ept>文が徹底的であることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This public-facing interface is the application programming interface (or API) for the framework.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この公開向けインタフェースは、フレームワークのためのアプリケーション・プログラミング・インタフェース（またはAPI）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This pushes its binary representation just over the size that a <bpt i="6" x="6">&lt;c6&gt;</bpt>UInt8<ept i="6">&lt;/c6&gt;</ept> can hold, causing it to overflow beyond its bounds, as shown in the diagram below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、そのバイナリの表現をちょうど<bpt i="6" x="6">&lt;c6&gt;</bpt>UInt8<ept i="6">&lt;/c6&gt;</ept>が持つことができる大きさ以上に押し広げて、それを、下の図で示すように、その境界を越えてあふれさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This relationship has the potential to create a strong reference cycle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関係は、強い参照循環をつくる可能性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This requests the sixth entry in the three-times-table, which returns a value of <bpt i="2" x="2">&lt;c2&gt;</bpt>18<ept i="2">&lt;/c2&gt;</ept>, or <bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept> times <bpt i="4" x="4">&lt;c4&gt;</bpt>6<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは九九の３の段において６番目の部分を要請します、それは値<bpt i="2" x="2">&lt;c2&gt;</bpt>18<ept i="2">&lt;/c2&gt;</ept>、つまり<bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept>掛ける<bpt i="4" x="4">&lt;c4&gt;</bpt>6<ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This requirement ensures that the public-facing API for a type is something you opt in to publishing, and avoids presenting the internal workings of a type as public API by mistake.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この要件は、ある型のための公開向けAPIがあなたが公開するように選ぶ何かであることを確実にして、ある型の内部の働きを誤って公開のAPIとして公表することを避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This requirement is enforced by a type constraint on the key type for <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>, which specifies that the key type must conform to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> protocol, a special protocol defined in the Swift standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この要件は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>のためのキー型に関する型制約によって強制されます、それは、キー型がスウィフト標準ライブラリで定義される特別なプロトコル、<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠しなければならないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This requirement is expressed through a combination of type constraints and a generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clause:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この要件は、型制約と総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節の組合せによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This restriction protects the implementation details of the <bpt i="2" x="2">&lt;c2&gt;</bpt>TrackedString<ept i="2">&lt;/c2&gt;</ept> edit-tracking functionality, while still providing convenient access to an aspect of that functionality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この制限は、<bpt i="2" x="2">&lt;c2&gt;</bpt>TrackedString<ept i="2">&lt;/c2&gt;</ept>編集追跡機能性の実装詳細を保護します、その一方でその機能性の一面への便利なアクセスを依然として提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This rule also applies to type aliases for associated types used to satisfy protocol conformances.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この規則はまた、プロトコル準拠を満たすために使われる関連型のための型エイリアスにも適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This rule applies to stored properties as well as computed properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この規則は、保存プロパティに、それだけでなく計算プロパティにも適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This rule pertains even though type property requirements can be prefixed with the <bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>static<ept i="2">&lt;/c2&gt;</ept> keyword when implemented by a class:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえ型プロパティ要件がクラスによって実装されるとき<bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>static<ept i="2">&lt;/c2&gt;</ept>キーワードを前に置かれるとしても、この規則は当てはまります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This satisfies rules 2 and 3 from above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、上記の規則２と３を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This scenario is best resolved with a weak reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この筋書きは、弱い参照で最もよく解消されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This scenario is best resolved with an unowned reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この筋書きは、非所有者参照で最もよく解消されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This section shows you how to set up such a relationship.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この節は、あなたにそのような関係を設定する方法を教えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This section shows you how to write a generic collection type called <bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この節は、あなたに<bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept>と呼ばれる総称体コレクション型を書く方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This square is represented by the blue square in the diagram below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この正方形は、下の図において青い正方形で表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This statement consists of the <bpt i="1" x="1">&lt;c1&gt;</bpt>defer<ept i="1">&lt;/c1&gt;</ept> keyword and the statements to be executed later.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この文は、<bpt i="1" x="1">&lt;c1&gt;</bpt>defer<ept i="1">&lt;/c1&gt;</ept>キーワードと後で実行される文から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This statement lets you do any necessary cleanup that should be performed regardless of <bpt i="1" x="1">&lt;e1&gt;</bpt>how<ept i="1">&lt;/e1&gt;</ept> execution leaves the current block of code—whether it leaves because an error was thrown or because of a statement such as <bpt i="2" x="2">&lt;c2&gt;</bpt>return<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>break<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この文は、あなたに何らかの不可欠なクリーンアップを行わせます、それは<bpt i="1" x="1">&lt;e1&gt;</bpt>どうやって<ept i="1">&lt;/e1&gt;</ept>実行が現在のコードプロックから離れるか ― それがエラーがスローされたためにまたは<bpt i="2" x="2">&lt;c2&gt;</bpt>return<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>break<ept i="3">&lt;/c3&gt;</ept>のような文を理由に離れるかどうかに関係なく実行されるべきものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This strong reference cycle occurs because closures, like classes, are <bpt i="0" x="0">&lt;e0&gt;</bpt>reference types<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この強い参照循環は、クロージャが、クラスの様に<bpt i="0" x="0">&lt;e0&gt;</bpt>参照型<ept i="0">&lt;/e0&gt;</ept>であるために起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This structure also has a read-only computed property called <bpt i="4" x="4">&lt;c4&gt;</bpt>volume<ept i="4">&lt;/c4&gt;</ept>, which calculates and returns the current volume of the cuboid.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この構造体はまた、<bpt i="4" x="4">&lt;c4&gt;</bpt>volume<ept i="4">&lt;/c4&gt;</ept>と呼ばれる読み出し専用の計算プロパティを持ちます、それは、現在の立方体の体積を計算して、返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This structure encapsulates the fact that most cards have one value, but the Ace card has two values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この構造体は、大部分のカードが１つの値を持つという事実をカプセル化します、しかし「エース」カードは２つの値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This structure has two stored properties called <bpt i="1" x="1">&lt;c1&gt;</bpt>width<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>height<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この構造体は、２つの保存プロパティ、<bpt i="1" x="1">&lt;c1&gt;</bpt>width<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>height<ept i="2">&lt;/c2&gt;</ept>と呼ばれるものを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This structure uses an <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> property called <bpt i="1" x="1">&lt;c1&gt;</bpt>items<ept i="1">&lt;/c1&gt;</ept> to store the values in the stack.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この構造体は、<bpt i="1" x="1">&lt;c1&gt;</bpt>items<ept i="1">&lt;/c1&gt;</ept>と呼ばれる<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>プロパティを使って値をスタックに保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This subscript <bpt i="1" x="1">&lt;c1&gt;</bpt>[n]<ept i="1">&lt;/c1&gt;</ept> returns the decimal digit <bpt i="2" x="2">&lt;c2&gt;</bpt>n<ept i="2">&lt;/c2&gt;</ept> places in from the right of the number:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この添え字<bpt i="1" x="1">&lt;c1&gt;</bpt>[n]<ept i="1">&lt;/c1&gt;</ept>は、右の数からの10進桁<bpt i="2" x="2">&lt;c2&gt;</bpt>n<ept i="2">&lt;/c2&gt;</ept>位置を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This subscript setting attempt also fails, because <bpt i="0" x="0">&lt;c0&gt;</bpt>residence<ept i="0">&lt;/c0&gt;</ept> is currently <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この添え字設定の試みはまた失敗します、なぜなら<bpt i="0" x="0">&lt;c0&gt;</bpt>residence<ept i="0">&lt;/c0&gt;</ept>が現在<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This syntactic convenience lets you omit braces around a function’s parameter by writing a normal expression instead of an explicit closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この統語上の便宜は、明示的なクロージャの代わりに通常の関数を書くことによって、あなたに関数のパラメータのまわりの波括弧を省略させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This table describes the changes to <bpt i="0" x="0">&lt;e0&gt;</bpt>The Swift Programming Language<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この表は<bpt i="0" x="0">&lt;e0&gt;</bpt>「スウィフトプログラミング言語」<ept i="0">&lt;/e0&gt;</ept>に対する変更点を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This tag contains the optional <bpt i="1" x="1">&lt;c1&gt;</bpt>text<ept i="1">&lt;/c1&gt;</ept> value if it exists, or no text content if <bpt i="2" x="2">&lt;c2&gt;</bpt>text<ept i="2">&lt;/c2&gt;</ept> does not exist.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このタグは、それが存在するならばオプショナルの<bpt i="1" x="1">&lt;c1&gt;</bpt>text<ept i="1">&lt;/c1&gt;</ept>値を、あるいは<bpt i="2" x="2">&lt;c2&gt;</bpt>text<ept i="2">&lt;/c2&gt;</ept>が存在しないならば、無いテキスト内容を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This tells Swift to execute the closure immediately.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、スウィフトにこのクロージャを直ちに実行するように言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This tells Swift to “chain” on the optional <bpt i="0" x="0">&lt;c0&gt;</bpt>residence<ept i="0">&lt;/c0&gt;</ept> property and to retrieve the value of <bpt i="1" x="1">&lt;c1&gt;</bpt>numberOfRooms<ept i="1">&lt;/c1&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt>residence<ept i="2">&lt;/c2&gt;</ept> exists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これはスウィフトに、オプショナルの<bpt i="0" x="0">&lt;c0&gt;</bpt>residence<ept i="0">&lt;/c0&gt;</ept>プロパティの上に「繋げて」、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>residence<ept i="2">&lt;/c2&gt;</ept>が存在するならば<bpt i="1" x="1">&lt;c1&gt;</bpt>numberOfRooms<ept i="1">&lt;/c1&gt;</ept>の値を取り出すように言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This time around, the <bpt i="2" x="2">&lt;c2&gt;</bpt>Apartment<ept i="2">&lt;/c2&gt;</ept> type’s <bpt i="3" x="3">&lt;c3&gt;</bpt>tenant<ept i="3">&lt;/c3&gt;</ept> property is declared as a weak reference:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>今度は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Apartment<ept i="2">&lt;/c2&gt;</ept>型の<bpt i="3" x="3">&lt;c3&gt;</bpt>tenant<ept i="3">&lt;/c3&gt;</ept>プロパティは、弱い参照として宣言されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This time around, the game has an extra rule:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このたびは、このゲームは特別な規則を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This time, however, the associated values can be extracted as part of the switch statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この場合ではしかし、関連値がスイッチ文の一部として抽出されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This time, the <bpt i="1" x="1">&lt;c1&gt;</bpt>Residence<ept i="1">&lt;/c1&gt;</ept> class defines a variable property called <bpt i="2" x="2">&lt;c2&gt;</bpt>rooms<ept i="2">&lt;/c2&gt;</ept>, which is initialized with an empty array of type <bpt i="3" x="3">&lt;c3&gt;</bpt>[Room]<ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>今度は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Residence<ept i="1">&lt;/c1&gt;</ept>クラスは<bpt i="2" x="2">&lt;c2&gt;</bpt>rooms<ept i="2">&lt;/c2&gt;</ept>と呼ばれる変数プロパティを定義します、それは、型<bpt i="3" x="3">&lt;c3&gt;</bpt>[Room]<ept i="3">&lt;/c3&gt;</ept>の空の配列で初期化されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This time, the capture of <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> by the closure is an unowned reference, and does not keep a strong hold on the <bpt i="1" x="1">&lt;c1&gt;</bpt>HTMLElement<ept i="1">&lt;/c1&gt;</ept> instance it has captured.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>今度は、クロージャによる<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>の捕獲は非所有者参照であって、それが捕獲している<bpt i="1" x="1">&lt;c1&gt;</bpt>HTMLElement<ept i="1">&lt;/c1&gt;</ept>インスタンスに対する強い支配力を保ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This time, the sign bit is <bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept> (meaning “negative”), and the seven value bits have a binary value of <bpt i="1" x="1">&lt;c1&gt;</bpt>124<ept i="1">&lt;/c1&gt;</ept> (which is <bpt i="2" x="2">&lt;c2&gt;</bpt>128 - 4<ept i="2">&lt;/c2&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>今度は、符号ビットは<bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>です（「負」を意味します）、そして、７つの値ビットは２進数の値の<bpt i="1" x="1">&lt;c1&gt;</bpt>124<ept i="1">&lt;/c1&gt;</ept>を持ちます（それは、<bpt i="2" x="2">&lt;c2&gt;</bpt>128 - 4<ept i="2">&lt;/c2&gt;</ept>です）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This time, the type parameter <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> is used as the type of the <bpt i="1" x="1">&lt;c1&gt;</bpt>append(_:)<ept i="1">&lt;/c1&gt;</ept> method’s <bpt i="2" x="2">&lt;c2&gt;</bpt>item<ept i="2">&lt;/c2&gt;</ept> parameter and the return type of the subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>今度は、型パラメータ<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が、<bpt i="1" x="1">&lt;c1&gt;</bpt>append(_:)<ept i="1">&lt;/c1&gt;</ept>メソッドの<bpt i="2" x="2">&lt;c2&gt;</bpt>item<ept i="2">&lt;/c2&gt;</ept>パラメータの型および添え字の戻り型として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This tour gives you enough information to start writing code in Swift by showing you how to accomplish a variety of programming tasks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このツアーはあなたにスウィフトでコードを書き始めるのに十分な情報を、どうやって様々なプログラミング作業を達成するかをあなたに示すことによって提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This type parameter is written within a pair of angle brackets (<bpt i="3" x="3">&lt;c3&gt;</bpt>&lt;Element&gt;<ept i="3">&lt;/c3&gt;</ept>) immediately after the structure’s name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型パラメータは、構造体の名前の直後に一対の山形括弧の内部で（<bpt i="3" x="3">&lt;c3&gt;</bpt>&lt;Element&gt;<ept i="3">&lt;/c3&gt;</ept>）書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This value is stored in a type property called <bpt i="1" x="1">&lt;c1&gt;</bpt>highestUnlockedLevel<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この値は、<bpt i="1" x="1">&lt;c1&gt;</bpt>highestUnlockedLevel<ept i="1">&lt;/c1&gt;</ept>と呼ばれる型プロパティに保管されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This variable has an initial value of nil, by virtue of being optional:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルであるおかげで、この変数はnilの初期値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This variable is initialized with a value of <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この変数は、値<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This version is adapted to use a <bpt i="3" x="3">&lt;c3&gt;</bpt>Dice<ept i="3">&lt;/c3&gt;</ept> instance for its dice-rolls; to adopt the <bpt i="4" x="4">&lt;c4&gt;</bpt>DiceGame<ept i="4">&lt;/c4&gt;</ept> protocol; and to notify a <bpt i="5" x="5">&lt;c5&gt;</bpt>DiceGameDelegate<ept i="5">&lt;/c5&gt;</ept> about its progress:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この版は改変され、それにより、それのさいころ振りに<bpt i="3" x="3">&lt;c3&gt;</bpt>Dice<ept i="3">&lt;/c3&gt;</ept>インスタンスを使用します；<bpt i="4" x="4">&lt;c4&gt;</bpt>DiceGame<ept i="4">&lt;/c4&gt;</ept>プロトコルを採用します；そして、その進歩について<bpt i="5" x="5">&lt;c5&gt;</bpt>DiceGameDelegate<ept i="5">&lt;/c5&gt;</ept>に通知します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This version of <bpt i="0" x="0">&lt;c0&gt;</bpt>Residence<ept i="0">&lt;/c0&gt;</ept> also provides a method called <bpt i="1" x="1">&lt;c1&gt;</bpt>printNumberOfRooms<ept i="1">&lt;/c1&gt;</ept>, which simply prints the number of rooms in the residence.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Residence<ept i="0">&lt;/c0&gt;</ept>のこの版も<bpt i="1" x="1">&lt;c1&gt;</bpt>printNumberOfRooms<ept i="1">&lt;/c1&gt;</ept>と呼ばれるメソッドを提供します、それは、単にその住居の部屋数を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This version of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Shape<ept i="0">&lt;/c0&gt;</ept> class is missing something important: an initializer to set up the class when an instance is created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Shape<ept i="0">&lt;/c0&gt;</ept>クラスのこの版は、重要なあるもの：インスタンスが作られるときにクラスを設定準備するイニシャライザ（初期化子）、が欠けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This version of the game is wrapped up as a class called <bpt i="0" x="0">&lt;c0&gt;</bpt>SnakesAndLadders<ept i="0">&lt;/c0&gt;</ept>, which adopts the <bpt i="1" x="1">&lt;c1&gt;</bpt>DiceGame<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゲームのこの改作は、<bpt i="0" x="0">&lt;c0&gt;</bpt>SnakesAndLadders<ept i="0">&lt;/c0&gt;</ept>と呼ばれるクラスで包まれます、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>DiceGame<ept i="1">&lt;/c1&gt;</ept>プロトコルを採用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This version of the game uses a <bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> loop and a <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement to implement the game’s logic.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゲームのこの改変板は、このゲームの論理を実装するために<bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>ループと<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This version of the mutating <bpt i="0" x="0">&lt;c0&gt;</bpt>moveBy(x:y:)<ept i="0">&lt;/c0&gt;</ept> method creates a brand new structure whose <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>y<ept i="2">&lt;/c2&gt;</ept> values are set to the target location.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変の<bpt i="0" x="0">&lt;c0&gt;</bpt>moveBy(x:y:)<ept i="0">&lt;/c0&gt;</ept>メソッドのこの改作は、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>y<ept i="2">&lt;/c2&gt;</ept>の値が目標場所に設定される、あるまっさらな構造体を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This would not be the case if you had written the initializer as part of the value type’s original implementation, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Initializer Delegation for Value Types<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>値型のためのイニシャライザ委任<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、あなたがイニシャライザをその値型の最初の実装の一部として書いたならば、それはこの場合にはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Those two values are compared, and the result of that comparison determines the overall result of the tuple comparison.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのような２つの値が比較されます、するとその比較の結果がタプル比較の結果全体を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Throw Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>throw文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Throwing Functions and Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スローを行う関数とメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Throwing an error lets you indicate that something unexpected happened and the normal flow of execution can’t continue.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーのスローがあなたに示すのは、何か予期せぬことが起こった、そして通常の実行の流れは続けることができないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Throwing and rethrowing functions are described in <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Throwing Functions and Methods<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> and <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Rethrowing Functions and Methods<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スローおよび再スロー関数は、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>スロー関数とメソッド<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>と<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>再スロー関数とメソッド<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>において記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Throwing and rethrowing functions can transfer program control to an appropriate <bpt i="3" x="3">&lt;c3&gt;</bpt>catch<ept i="3">&lt;/c3&gt;</ept> block, even when they are nonreturning.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スローおよび再スロー関数は、制御を適切な<bpt i="3" x="3">&lt;c3&gt;</bpt>catch<ept i="3">&lt;/c3&gt;</ept>プロックに移すことができます、それらが非復帰である場合でさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Throwing initializers can propagate errors in the same way as throwing functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スローするイニシャライザは、スローする関数と同じ方法でエラーを伝達できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Throwing, catching, and propagating errors is covered in greater detail in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Error Handling<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーのスロー、キャッチ、そして伝達は、詳細に<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>エラー処理<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>において扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To access an index farther away from the given index, you can use the <bpt i="3" x="3">&lt;c3&gt;</bpt>index(_:offsetBy:)<ept i="3">&lt;/c3&gt;</ept> method instead of calling one of these methods multiple times.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>与えられたインデックスからもっと遠く離れたインデックスにアクセスするには、あなたはこれらのメソッドのうちの１つを複数回呼び出すことの代わりに<bpt i="3" x="3">&lt;c3&gt;</bpt>index(_:offsetBy:)<ept i="3">&lt;/c3&gt;</ept>メソッドを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To accomplish this, Swift enables you to define <bpt i="0" x="0">&lt;e0&gt;</bpt>nested types<ept i="0">&lt;/e0&gt;</ept>, whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを達成するために、スウィフトはあなたに<bpt i="0" x="0">&lt;e0&gt;</bpt>入れ子にされた型<ept i="0">&lt;/e0&gt;</ept>を定義するのを可能にします、それによってあなたは、補助の列挙、クラス、そして構造体をそれらが支援をする型の定義の範囲内で入れ子にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To accomplish this, you define one input parameter—a <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> value called <bpt i="2" x="2">&lt;c2&gt;</bpt>person<ept i="2">&lt;/c2&gt;</ept>—and a return type of <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>, which will contain a greeting for that person:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを達成するために、あなたは１つの入力パラメータ ― <bpt i="2" x="2">&lt;c2&gt;</bpt>person<ept i="2">&lt;/c2&gt;</ept>と呼ばれる<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値 ― そしてその人のための挨拶を含むことになる、<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>の戻り型を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To achieve these aims, you can mark a loop statement or conditional statement with a <bpt i="0" x="0">&lt;e0&gt;</bpt>statement label<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの狙いを達成するために、あなたはループ文または条件文に<bpt i="0" x="0">&lt;e0&gt;</bpt>文ラベル<ept i="0">&lt;/e0&gt;</ept>で印をつけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To achieve this, an extra rule is used when signed integers are shifted to the right: When you shift signed integers to the right, apply the same rules as for unsigned integers, but fill any empty bits on the left with the <bpt i="0" x="0">&lt;e0&gt;</bpt>sign bit<ept i="0">&lt;/e0&gt;</ept>, rather than with a zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを達成するために、符号つき整数が右へシフトされるとき、特別な規則が使われます：あなたが符号つき整数を右にシフトする時は、符号なし整数と同じ規則を適用してください、しかし、その左のあらゆる空のビットを、ゼロではなく<bpt i="0" x="0">&lt;e0&gt;</bpt>符号ビット<ept i="0">&lt;/e0&gt;</ept>で満たしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To achieve this, the <bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept> protocol declares an associated type called <bpt i="1" x="1">&lt;c1&gt;</bpt>Item<ept i="1">&lt;/c1&gt;</ept>, written as <bpt i="2" x="2">&lt;c2&gt;</bpt>associatedtype Item<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを達成するために、<bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept>プロトコルは<bpt i="1" x="1">&lt;c1&gt;</bpt>Item<ept i="1">&lt;/c1&gt;</ept>と呼ばれる関連型を宣言します、それは<bpt i="2" x="2">&lt;c2&gt;</bpt>associatedtype Item<ept i="2">&lt;/c2&gt;</ept>のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To achieve this, the array’s size, and an initial cell value of <bpt i="6" x="6">&lt;c6&gt;</bpt>0.0<ept i="6">&lt;/c6&gt;</ept>, are passed to an array initializer that creates and initializes a new array of the correct size.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを達成するために、この配列の大きさ、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>0.0<ept i="6">&lt;/c6&gt;</ept>の初期セル値は、正しいサイズの新しい配列をつくって初期化する配列イニシャライザに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To add protocol conformance, you write the protocol names the same way as you write them for a class or structure:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル準拠を加えるには、あなたはそれらプロトコル名を、あなたがそれらをクラスや構造体に対して書くのと同じ方法で記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To align the values and statements, the unary plus operator (<bpt i="5" x="5">&lt;c5&gt;</bpt>+i<ept i="5">&lt;/c5&gt;</ept>) is explicitly used with the unary minus operator (<bpt i="6" x="6">&lt;c6&gt;</bpt>-i<ept i="6">&lt;/c6&gt;</ept>) and numbers lower than <bpt i="7" x="7">&lt;c7&gt;</bpt>10<ept i="7">&lt;/c7&gt;</ept> are padded with zeros.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値と文を整列するために、単項プラス演算子（<bpt i="5" x="5">&lt;c5&gt;</bpt>+i<ept i="5">&lt;/c5&gt;</ept>）が明示的に単項マイナス演算子（<bpt i="6" x="6">&lt;c6&gt;</bpt>-i<ept i="6">&lt;/c6&gt;</ept>)とともに使われます、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>10<ept i="7">&lt;/c7&gt;</ept>より低い数はゼロを詰められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To assist with these assertions, <bpt i="3" x="3">&lt;c3&gt;</bpt>Matrix<ept i="3">&lt;/c3&gt;</ept> includes a convenience method called <bpt i="4" x="4">&lt;c4&gt;</bpt>indexIsValid(row:column:)<ept i="4">&lt;/c4&gt;</ept>, which checks whether the requested <bpt i="5" x="5">&lt;c5&gt;</bpt>row<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>column<ept i="6">&lt;/c6&gt;</ept> are inside the bounds of the matrix:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの表明を手伝うために、<bpt i="3" x="3">&lt;c3&gt;</bpt>Matrix<ept i="3">&lt;/c3&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>indexIsValid(row:column:)<ept i="4">&lt;/c4&gt;</ept>と呼ばれるある便利なメソッドを含みます、それは要請された<bpt i="5" x="5">&lt;c5&gt;</bpt>row<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>column<ept i="6">&lt;/c6&gt;</ept>が行列の境界の内側にあるかどうか確認します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To calculate <bpt i="0" x="0">&lt;c0&gt;</bpt>9 % 4<ept i="0">&lt;/c0&gt;</ept>, you first work out how many <bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept>s will fit inside <bpt i="2" x="2">&lt;c2&gt;</bpt>9<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>9 % 4<ept i="0">&lt;/c0&gt;</ept>を計算するために、あなたは最初にどれくらい多くの<bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>9<ept i="2">&lt;/c2&gt;</ept>の中に収まるかを考え出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To check the values of enumeration cases, use a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement, as shown in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Matching Enumeration Values with a Switch Statement<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙ケース節の値を調べるために、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>スイッチ文で列挙値を照合する<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で示されるように、<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To check whether a set contains a particular item, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>contains(_:)<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある集合が特定の項目を含むかどうか調べるために、<bpt i="0" x="0">&lt;c0&gt;</bpt>contains(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To check whether a string has a particular string prefix or suffix, call the string’s <bpt i="0" x="0">&lt;c0&gt;</bpt>hasPrefix(_:)<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>hasSuffix(_:)<ept i="1">&lt;/c1&gt;</ept> methods, both of which take a single argument of type <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> and return a Boolean value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列が特定の文字列接頭辞または接尾辞を持つかどうか調べるために、文字列の<bpt i="0" x="0">&lt;c0&gt;</bpt>hasPrefix(_:)<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>hasSuffix(_:)<ept i="1">&lt;/c1&gt;</ept>メソッドを呼んでください、それらの両方ともただ一つの<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>型の引数をとって、ブールの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To compare tuples with seven or more elements, you must implement the comparison operators yourself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>７つまたはそれより多い要素のタプルを比較するには、あなたは比較演算子をあなた自身で実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To conform to this version of <bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept>, the container’s <bpt i="1" x="1">&lt;c1&gt;</bpt>Item<ept i="1">&lt;/c1&gt;</ept> type has to conform to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このバージョンの<bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept>に準拠するには、コンテナのもつ<bpt i="1" x="1">&lt;c1&gt;</bpt>Item<ept i="1">&lt;/c1&gt;</ept>型は<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To convert one specific number type to another, you initialize a new number of the desired type with the existing value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つの特定の数の型を他のものに変換するために、あなたは望む型の新しい数を既存の値で初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To cope with initialization conditions that can fail, define one or more failable initializers as part of a class, structure, or enumeration definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗の可能性がある初期化状況にうまく対処するために、一つ以上の失敗可能なイニシャライザをクラス、構造体、または列挙定義の一部として定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To cope with this requirement, you declare the <bpt i="0" x="0">&lt;c0&gt;</bpt>capitalCity<ept i="0">&lt;/c0&gt;</ept> property of <bpt i="1" x="1">&lt;c1&gt;</bpt>Country<ept i="1">&lt;/c1&gt;</ept> as an implicitly unwrapped optional property, indicated by the exclamation mark at the end of its type annotation (<bpt i="2" x="2">&lt;c2&gt;</bpt>City!<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この必要条件に対処するために、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>Country<ept i="1">&lt;/c1&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>capitalCity<ept i="0">&lt;/c0&gt;</ept>プロパティを、暗黙的にアンラップされるオプショナルのプロパティとして、その型注釈の終わりに感嘆符で示して宣言します（<bpt i="2" x="2">&lt;c2&gt;</bpt>City!<ept i="2">&lt;/c2&gt;</ept>）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To cope with this scenario, the code checks that <bpt i="1" x="1">&lt;c1&gt;</bpt>square<ept i="1">&lt;/c1&gt;</ept> is less than the <bpt i="2" x="2">&lt;c2&gt;</bpt>board<ept i="2">&lt;/c2&gt;</ept> array’s <bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この事態に対処するために、コードは、<bpt i="1" x="1">&lt;c1&gt;</bpt>square<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>board<ept i="2">&lt;/c2&gt;</ept>配列の<bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept>プロパティより少ないことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To cope with this, the example above uses optional binding to check whether the optional <bpt i="2" x="2">&lt;c2&gt;</bpt>Movie<ept i="2">&lt;/c2&gt;</ept> actually contains a value (that is, to find out whether the downcast succeeded.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これに対処するために、上の例は、オプショナル束縛を使って、オプショナルの<bpt i="2" x="2">&lt;c2&gt;</bpt>Movie<ept i="2">&lt;/c2&gt;</ept>が実際に値を含むかどうか調べます（すなわち、ダウンキャストが成功したかどうか探り出します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To create a property called <bpt i="0" x="0">&lt;c0&gt;</bpt>items<ept i="0">&lt;/c0&gt;</ept>, which is initialized with an empty array of values of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>items<ept i="0">&lt;/c0&gt;</ept>と呼ばれるプロパティをつくる所で、それは、型<bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>の値が入る空の配列で初期化されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To create an empty <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> value as the starting point for building a longer string, either assign an empty string literal to a variable, or initialize a new <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> instance with initializer syntax:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より長い文字列をつくるための出発点として空の<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>値を作成するために、変数に空のリテラル文字列を代入するか、イニシャライザ構文で新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>インスタンスを初期化してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To create an empty array or dictionary, use the initializer syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の配列または辞書を作成するために、初期化構文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To declare a class or static method requirement in a protocol declaration, mark the method declaration with the <bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスまたは静的メソッド要件をあるプロトコル宣言において宣言するために、そのメソッド宣言を<bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept>宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To declare a constant type property, mark the declaration with the <bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数型プロパティを宣言するために、宣言に<bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept>宣言修飾子で印をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To declare a failable initializer that produces an implicitly unwrapped optional instance, append an exclamation mark instead (<bpt i="2" x="2">&lt;c2&gt;</bpt>init!<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的にアンラップされるオプショナルインスタンスを生成する失敗できるイニシャライザを宣言するために、代わりに感嘆符を加えてください（<bpt i="2" x="2">&lt;c2&gt;</bpt>init!<ept i="2">&lt;/c2&gt;</ept>）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To declare a failable initializer that produces an optional instance, append a question mark to the <bpt i="0" x="0">&lt;c0&gt;</bpt>init<ept i="0">&lt;/c0&gt;</ept> keyword in the initializer declaration (<bpt i="1" x="1">&lt;c1&gt;</bpt>init?<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルインスタンスを生成する失敗できるイニシャライザを宣言するために、イニシャライザ宣言において疑問符を<bpt i="0" x="0">&lt;c0&gt;</bpt>init<ept i="0">&lt;/c0&gt;</ept>キーワードに加えてください（<bpt i="1" x="1">&lt;c1&gt;</bpt>init?<ept i="1">&lt;/c1&gt;</ept>）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To declare a type variable property, mark the declaration with the <bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型変数プロパティを宣言するために、宣言に<bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept>宣言修飾子で印をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To declare convenience initializers for a class, mark the initializer declaration with the <bpt i="0" x="0">&lt;c0&gt;</bpt>convenience<ept i="0">&lt;/c0&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラスの便宜イニシャライザを宣言するために、そのイニシャライザ宣言を<bpt i="0" x="0">&lt;c0&gt;</bpt>convenience<ept i="0">&lt;/c0&gt;</ept>宣言修飾子を使って印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To define these requirements, the <bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept> protocol needs a way to refer to the type of the elements that a container will hold, without knowing what that type is for a specific container.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの要件を定義するために、<bpt i="0" x="0">&lt;c0&gt;</bpt>Container<ept i="0">&lt;/c0&gt;</ept>プロトコルは、あるコンテナが保持することになる要素の型を参照する方法を必要とします、その型がどんなコンテナのためのものか知ることなしにです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To determine the answer for <bpt i="0" x="0">&lt;c0&gt;</bpt>a % b<ept i="0">&lt;/c0&gt;</ept>, the <bpt i="1" x="1">&lt;c1&gt;</bpt>%<ept i="1">&lt;/c1&gt;</ept> operator calculates the following equation and returns <bpt i="2" x="2">&lt;c2&gt;</bpt>remainder<ept i="2">&lt;/c2&gt;</ept> as its output:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a % b<ept i="0">&lt;/c0&gt;</ept>に対する答えを決定するために、<bpt i="1" x="1">&lt;c1&gt;</bpt>%<ept i="1">&lt;/c1&gt;</ept>演算子は以下の等式を計算します、そしてその出力として<bpt i="2" x="2">&lt;c2&gt;</bpt>余り<ept i="2">&lt;/c2&gt;</ept>を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To discover the specific type of a constant or variable that is known only to be of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>AnyObject<ept i="1">&lt;/c1&gt;</ept>, you can use an <bpt i="2" x="2">&lt;c2&gt;</bpt>is<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>as<ept i="3">&lt;/c3&gt;</ept> pattern in a <bpt i="4" x="4">&lt;c4&gt;</bpt>switch<ept i="4">&lt;/c4&gt;</ept> statement’s cases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>AnyObject<ept i="1">&lt;/c1&gt;</ept>のものであることだけが知られている定数や変数の具体的な型を見つけるために、あなたは<bpt i="2" x="2">&lt;c2&gt;</bpt>is<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>as<ept i="3">&lt;/c3&gt;</ept>パターンを<bpt i="4" x="4">&lt;c4&gt;</bpt>switch<ept i="4">&lt;/c4&gt;</ept>文のケース節の中で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To distinguish between methods or initializers whose names differ only by the names of their arguments, include the argument names in parentheses, with each argument name followed by a colon (<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>名前がそれらの引数の名前でだけ異なるものであるメソッド間またはイニシャライザ間で識別を行うために、丸括弧の中に引数名を、各引数名にコロン（<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>）を続けることで含めて下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To distinguish between overloaded methods, use a type annotation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバーロードされたメソッド間で識別を行うには、型注釈を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To do that, you need to create an instance of the structure or class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それをするために、あなたは構造体またはクラスのインスタンスをつくる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To do this, it needs to access each item as a true <bpt i="2" x="2">&lt;c2&gt;</bpt>Movie<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>Song<ept i="3">&lt;/c3&gt;</ept>, and not just as a <bpt i="4" x="4">&lt;c4&gt;</bpt>MediaItem<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これをするために、それは、ただ<bpt i="4" x="4">&lt;c4&gt;</bpt>MediaItem<ept i="4">&lt;/c4&gt;</ept>としてではなく、本当の<bpt i="2" x="2">&lt;c2&gt;</bpt>Movie<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>Song<ept i="3">&lt;/c3&gt;</ept>として各項目にアクセスする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To do this, you make parts of your code <bpt i="0" x="0">&lt;e0&gt;</bpt>conditional<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これをするために、あなたは、あなたのコードの一部を<bpt i="0" x="0">&lt;e0&gt;</bpt>条件つき<ept i="0">&lt;/e0&gt;</ept>にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To enable indirection for a particular enumeration case, mark it with the <bpt i="0" x="0">&lt;c0&gt;</bpt>indirect<ept i="0">&lt;/c0&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある特定の列挙ケース節に対して間接参照を可能にするには、それを<bpt i="0" x="0">&lt;c0&gt;</bpt>indirect<ept i="0">&lt;/c0&gt;</ept>宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To enable indirection for all the cases of an enumeration, mark the entire enumeration with the <bpt i="0" x="0">&lt;c0&gt;</bpt>indirect<ept i="0">&lt;/c0&gt;</ept> modifier—this is convenient when the enumeration contains many cases that would each need to be marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>indirect<ept i="1">&lt;/c1&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある列挙の中のすべてのケース節に対して間接参照を可能にするには、その列挙全体を<bpt i="0" x="0">&lt;c0&gt;</bpt>indirect<ept i="0">&lt;/c0&gt;</ept>修飾子で印してください—これはその列挙がそのそれぞれが<bpt i="1" x="1">&lt;c1&gt;</bpt>indirect<ept i="1">&lt;/c1&gt;</ept>修飾子で印される必要がある多くのケース節を含んでいる時に適します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To enable this, Swift provides two identity operators:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを可能にするために、スウィフトは２つの同一性演算子を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To ensure conversion between numeric types maintains the value exactly, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>init(exactly:)<ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数値型の間の変換がその値を正確に維持するのを保証するために、<bpt i="0" x="0">&lt;c0&gt;</bpt>init(exactly:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To ensure that an error is handled, use a <bpt i="0" x="0">&lt;c0&gt;</bpt>catch<ept i="0">&lt;/c0&gt;</ept> clause with a pattern that matches all errors, such as a wildcard pattern (<bpt i="1" x="1">&lt;c1&gt;</bpt>_<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーが処理されることが保証されるように、あるひとつの<bpt i="0" x="0">&lt;c0&gt;</bpt>catch<ept i="0">&lt;/c0&gt;</ept>節をどんなエラーにもマッチするパターンとともに使ってください、例えばワイルドカードパターン（<bpt i="1" x="1">&lt;c1&gt;</bpt>_<ept i="1">&lt;/c1&gt;</ept>）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To evaluate the value of a subscript expression, the subscript getter for the <bpt i="0" x="0">&lt;e0&gt;</bpt>expression<ept i="0">&lt;/e0&gt;</ept>’s type is called with the <bpt i="1" x="1">&lt;e1&gt;</bpt>index expressions<ept i="1">&lt;/e1&gt;</ept> passed as the subscript parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字式の値を評価するために、この<bpt i="0" x="0">&lt;e0&gt;</bpt>式<ept i="0">&lt;/e0&gt;</ept>のもつ型のための添え字ゲッターが、添え字パラメータとして渡される<bpt i="1" x="1">&lt;e1&gt;</bpt>インデックス式<ept i="1">&lt;/e1&gt;</ept>を使って呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To explicitly fall through at the end of a particular <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> case, use the <bpt i="1" x="1">&lt;c1&gt;</bpt>fallthrough<ept i="1">&lt;/c1&gt;</ept> keyword, as described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Fallthrough<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある特定の<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>ケース節の終わりで明示的に抜け落ちるには、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>フォールスルー<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されるように、<bpt i="1" x="1">&lt;c1&gt;</bpt>fallthrough<ept i="1">&lt;/c1&gt;</ept>キーワードを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To express this fact, you write a type constraint of <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept> as part of the type parameter’s definition when you define the function:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この事実を表すために、あなたは<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>の型制約を型パラメータの定義の一部として、あなたが関数を定義する時に書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To find out the number of items in a set, check its read-only <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合の中の項目数を知るために、それの読み出し専用の<bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>プロパティを調べてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To find out the number of items in an array, check its read-only <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある配列の中の項目の数を知るために、その読み出し専用の<bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>プロパティを調べてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To handle an empty array safely, write the <bpt i="0" x="0">&lt;c0&gt;</bpt>minMax(array:)<ept i="0">&lt;/c0&gt;</ept> function with an optional tuple return type and return a value of <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> when the array is empty:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空の配列を安全に取り扱うために、<bpt i="0" x="0">&lt;c0&gt;</bpt>minMax(array:)<ept i="0">&lt;/c0&gt;</ept>関数をオプショナルタプルの戻り型を使って書いて、配列が空の時に<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>の値を返してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To help manage the <bpt i="0" x="0">&lt;c0&gt;</bpt>currentLevel<ept i="0">&lt;/c0&gt;</ept> property, <bpt i="1" x="1">&lt;c1&gt;</bpt>LevelTracker<ept i="1">&lt;/c1&gt;</ept> defines an instance method called <bpt i="2" x="2">&lt;c2&gt;</bpt>advance(to:)<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>currentLevel<ept i="0">&lt;/c0&gt;</ept>プロパティを管理するのを手伝うために、<bpt i="1" x="1">&lt;c1&gt;</bpt>LevelTracker<ept i="1">&lt;/c1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>advance(to:)<ept i="2">&lt;/c2&gt;</ept>と呼ばれるインスタンスメソッドを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To identify these places in your code, write the <bpt i="0" x="0">&lt;c0&gt;</bpt>try<ept i="0">&lt;/c0&gt;</ept> keyword—or the <bpt i="1" x="1">&lt;c1&gt;</bpt>try?<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>try!<ept i="2">&lt;/c2&gt;</ept> variation—before a piece of code that calls a function, method, or initializer that can throw an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの場所をあなたのコードの中で識別するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>try<ept i="0">&lt;/c0&gt;</ept>キーワードを ― またはその変種<bpt i="1" x="1">&lt;c1&gt;</bpt>try?<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>try!<ept i="2">&lt;/c2&gt;</ept>を ― エラーをスローできる関数、メソッド、またはイニシャライザを呼び出すコードの前の場所に書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To implement the <bpt i="6" x="6">&lt;c6&gt;</bpt>+++<ept i="6">&lt;/c6&gt;</ept> operator, you add a type method called <bpt i="7" x="7">&lt;c7&gt;</bpt>+++<ept i="7">&lt;/c7&gt;</ept> to <bpt i="8" x="8">&lt;c8&gt;</bpt>Vector2D<ept i="8">&lt;/c8&gt;</ept> as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>+++<ept i="6">&lt;/c6&gt;</ept>演算子を実装するには、あなたは<bpt i="7" x="7">&lt;c7&gt;</bpt>+++<ept i="7">&lt;/c7&gt;</ept>と呼ばれる型メソッドを次のように<bpt i="8" x="8">&lt;c8&gt;</bpt>Vector2D<ept i="8">&lt;/c8&gt;</ept>に加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To include the text <bpt i="1" x="1">&lt;c1&gt;</bpt>"""<ept i="1">&lt;/c1&gt;</ept> in a multiline string, escape at least one of the quotation marks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>テキスト<bpt i="1" x="1">&lt;c1&gt;</bpt>"""<ept i="1">&lt;/c1&gt;</ept>を複数行文字列の中に含めるには、少なくとも１つの引用符記号の１つをエスケープしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To indicate that a function, method, or initializer can throw an error, you write the <bpt i="0" x="0">&lt;c0&gt;</bpt>throws<ept i="0">&lt;/c0&gt;</ept> keyword in the function’s declaration after its parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーをスローすることのできる関数、メソッド、またはイニシャライザを指し示すために、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>throws<ept i="0">&lt;/c0&gt;</ept>キーワードを関数の定義においてそれのパラメータの後に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To indicate that a subclass has a superclass, write the subclass name before the superclass name, separated by a colon:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるサブクラスがあるスーパークラスを持つことを表わすには、サブクラスの名前をスーパークラスの名前の前に、コロンで区切って書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To insert a single character into a string at a specified index, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>insert(_:at:)<ept i="0">&lt;/c0&gt;</ept> method, and to insert the contents of another string at a specified index, use the <bpt i="1" x="1">&lt;c1&gt;</bpt>insert(contentsOf:at:)<ept i="1">&lt;/c1&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある単一の文字をある文字列中へ特定のインデックスで差し込むには、<bpt i="0" x="0">&lt;c0&gt;</bpt>insert(_:at:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使ってください、そして別の文字列の内容を特定のインデックスで差し込むには、<bpt i="1" x="1">&lt;c1&gt;</bpt>insert(contentsOf:at:)<ept i="1">&lt;/c1&gt;</ept>メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To insert an item into the array at a specified index, call the array’s <bpt i="0" x="0">&lt;c0&gt;</bpt>insert(_:at:)<ept i="0">&lt;/c0&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある項目を配列の中へ指定されたインデックスで差し入れるために、配列の<bpt i="0" x="0">&lt;c0&gt;</bpt>insert(_:at:)<ept i="0">&lt;/c0&gt;</ept>メソッドを呼んでください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To iterate over the keys or values of a dictionary in a specific order, use the <bpt i="1" x="1">&lt;c1&gt;</bpt>sorted()<ept i="1">&lt;/c1&gt;</ept> method on its <bpt i="2" x="2">&lt;c2&gt;</bpt>keys<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>values<ept i="3">&lt;/c3&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書のキーまたは値に特定の順序で繰り返していくために、<bpt i="1" x="1">&lt;c1&gt;</bpt>sorted()<ept i="1">&lt;/c1&gt;</ept>メソッドを<bpt i="2" x="2">&lt;c2&gt;</bpt>keys<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>values<ept i="3">&lt;/c3&gt;</ept>プロパティ上で使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To iterate over the values of a set in a specific order, use the <bpt i="1" x="1">&lt;c1&gt;</bpt>sorted()<ept i="1">&lt;/c1&gt;</ept> method, which returns the set’s elements as an array sorted using the <bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;<ept i="2">&lt;/c2&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合の中の値に特定の順番で繰り返すには、<bpt i="1" x="1">&lt;c1&gt;</bpt>sorted()<ept i="1">&lt;/c1&gt;</ept>メソッドを使ってください、それは集合の要素を<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;<ept i="2">&lt;/c2&gt;</ept>演算子を使って格納される配列として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To learn how functions can return other functions, see <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Function Types as Return Types<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数が他の関数を返すことができる方法を学ぶために、<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>戻り型としての関数型<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To learn how to define new, custom operators, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Custom Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Operator Declaration<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい、あつらえの演算子を定義する方法を学ぶために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>あつらえの演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>演算子宣言<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To learn how to overload existing operators, see <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Operator Methods<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>既存の演算子にオーバーロードする方法を学ぶために、<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>演算子メソッド<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> with a single case that matches both <bpt i="1" x="1">&lt;c1&gt;</bpt>"a"<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>"A"<ept i="2">&lt;/c2&gt;</ept>, combine the two values into a compound case, separating the values with commas.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ただ１つだけのケース節を持つある<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>"a"<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>"A"<ept i="2">&lt;/c2&gt;</ept>の両方にマッチするようにするには、２つの値をひとつの複合ケース節へと、コンマで値を隔てて結合してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make a multiline string literal that begins or ends with a line feed, write a blank line as its first or last line.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ラインフィードで始まるまたは終わる複数行文字列リテラルを作るには、空の行をそれの最初または最後の行に書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make a multiline string literal that begins or ends with a line feed, write a blank line as the first or last line.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ラインフィードで始まるまたは終わる複数行文字列リテラルを作るには、空の行を最初または最後の行として記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make it more useful, you need to refine it to describe more specific kinds of vehicles.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それをより役に立つようにするために、あなたはそれを改良してより具体的な乗物の種類を記述する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make sure that instances don’t disappear while they are still needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それがまだ必要な間にインスタンスが消えないことを確実にするために、ARCは、どれくらいのプロパティ、定数、および変数が目下のところ各クラスインスタンスに言及しているかを追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make the body of this function shorter, you can combine the message creation and the return statement into one line:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この関数の本文をより短くするために、あなたはメッセージ作成と返しの文を１行に結合することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make this possible, whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a <bpt i="0" x="0">&lt;e0&gt;</bpt>strong reference<ept i="0">&lt;/e0&gt;</ept> to the instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを可能にするために、あなたがクラスインスタンスをプロパティ、定数、または変数に代入するときはいつでも、そのプロパティ、定数、または変数はそのインスタンスへの<bpt i="0" x="0">&lt;e0&gt;</bpt>強い参照<ept i="0">&lt;/e0&gt;</ept>を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To model this restriction, the failable initializer triggers an initialization failure if an empty string is found.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この制約条件をモデル化するために、失敗できるイニシャライザは空の文字列が見つけられるならば初期化失敗を引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To nest a type within another type, write its definition within the outer braces of the type it supports.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型を別の型の内部で入れ子にするために、その定義をそれが支援する型の外側の波括弧の範囲内で書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To opt in to overflow behavior, use Swift’s second set of arithmetic operators that overflow by default, such as the overflow addition operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オーバフロー挙動を選ぶために、初期状態でオーバフローするスウィフトの算術演算子の第二集合を使ってください、例えばオーバフロー加算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+<ept i="0">&lt;/c0&gt;</ept>）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To override a characteristic that would otherwise be inherited, you prefix your overriding definition with the <bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうしなければ継承される特徴をオーバーライドするために、あなたは、あなたのオーバーライド定義の前に<bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept>キーワードを置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To print a value without a line break after it, pass an empty string as the terminator—for example, <bpt i="4" x="4">&lt;c4&gt;</bpt>print(someValue, terminator: "")<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値をそれの後に改行なしで出力するには、空の文字列を終端子（ターミネータ）として渡してください ― 例えば、<bpt i="4" x="4">&lt;c4&gt;</bpt>print(someValue, terminator:"")<ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To put it another way:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>言い換えれば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To reference the case of an enumeration type, use dot (<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>) syntax, as in <bpt i="1" x="1">&lt;c1&gt;</bpt>EnumerationType.enumerationCase<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙型のケース節に言及するために、<bpt i="1" x="1">&lt;c1&gt;</bpt>EnumerationType.enumerationCase<ept i="1">&lt;/c1&gt;</ept>のように、ドット（<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>）構文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To reflect the fact that optional chaining can be called on a <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> value, the result of an optional chaining call is always an optional value, even if the property, method, or subscript you are querying returns a nonoptional value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖は<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>値上で呼ばれることができるという事実を反映するために、オプショナル連鎖呼び出しの結果は、たとえあなたが問い合わせているプロパティ、メソッド、または添え字が非オプショナルの値を返すとしても、常にオプショナルの値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To remove a single character from a string at a specified index, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>remove(at:)<ept i="0">&lt;/c0&gt;</ept> method, and to remove a substring at a specified range, use the <bpt i="1" x="1">&lt;c1&gt;</bpt>removeSubrange(_:)<ept i="1">&lt;/c1&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある単一の文字をある文字列から特定のインデックスで削除するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>remove(at:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使ってください、そして部分文字列を特定の範囲で削除するには、<bpt i="1" x="1">&lt;c1&gt;</bpt>removeSubrange(_:)<ept i="1">&lt;/c1&gt;</ept>メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To represent this fact, <bpt i="0" x="0">&lt;c0&gt;</bpt>ShoppingListItem<ept i="0">&lt;/c0&gt;</ept> introduces a Boolean property called <bpt i="1" x="1">&lt;c1&gt;</bpt>purchased<ept i="1">&lt;/c1&gt;</ept>, with a default value of <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この事実を表すために、<bpt i="0" x="0">&lt;c0&gt;</bpt>ShoppingListItem<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>の省略時の値で、<bpt i="1" x="1">&lt;c1&gt;</bpt>purchased<ept i="1">&lt;/c1&gt;</ept>と呼ばれるブールのプロパティを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To represent this game board, the <bpt i="0" x="0">&lt;c0&gt;</bpt>Chessboard<ept i="0">&lt;/c0&gt;</ept> structure has a single property called <bpt i="1" x="1">&lt;c1&gt;</bpt>boardColors<ept i="1">&lt;/c1&gt;</ept>, which is an array of 64 <bpt i="2" x="2">&lt;c2&gt;</bpt>Bool<ept i="2">&lt;/c2&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このゲーム板を表すために、<bpt i="0" x="0">&lt;c0&gt;</bpt>Chessboard<ept i="0">&lt;/c0&gt;</ept>構造体は<bpt i="1" x="1">&lt;c1&gt;</bpt>boardColors<ept i="1">&lt;/c1&gt;</ept>と呼ばれる１つのプロパティだけを持ちます、それは64個の<bpt i="2" x="2">&lt;c2&gt;</bpt>Bool<ept i="2">&lt;/c2&gt;</ept>値の配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To represent this, <bpt i="0" x="0">&lt;c0&gt;</bpt>board[03]<ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="1" x="1">&lt;c1&gt;</bpt>+08<ept i="1">&lt;/c1&gt;</ept>, which is equivalent to an integer value of <bpt i="2" x="2">&lt;c2&gt;</bpt>8<ept i="2">&lt;/c2&gt;</ept> (the difference between <bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>11<ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを表すために、<bpt i="0" x="0">&lt;c0&gt;</bpt>board[03]<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>+08<ept i="1">&lt;/c1&gt;</ept>と等しいです、そしてそれは、整数値の<bpt i="2" x="2">&lt;c2&gt;</bpt>８<ept i="2">&lt;/c2&gt;</ept>（<bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>11<ept i="4">&lt;/c4&gt;</ept>の差）に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To represent this, the <bpt i="2" x="2">&lt;c2&gt;</bpt>Country<ept i="2">&lt;/c2&gt;</ept> class has a <bpt i="3" x="3">&lt;c3&gt;</bpt>capitalCity<ept i="3">&lt;/c3&gt;</ept> property, and the <bpt i="4" x="4">&lt;c4&gt;</bpt>City<ept i="4">&lt;/c4&gt;</ept> class has a <bpt i="5" x="5">&lt;c5&gt;</bpt>country<ept i="5">&lt;/c5&gt;</ept> property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを表すために、<bpt i="2" x="2">&lt;c2&gt;</bpt>Country<ept i="2">&lt;/c2&gt;</ept>クラスは<bpt i="3" x="3">&lt;c3&gt;</bpt>capitalCity<ept i="3">&lt;/c3&gt;</ept>プロパティを持ちます、そして、<bpt i="4" x="4">&lt;c4&gt;</bpt>City<ept i="4">&lt;/c4&gt;</ept>クラスは<bpt i="5" x="5">&lt;c5&gt;</bpt>country<ept i="5">&lt;/c5&gt;</ept>プロパティを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To represent this, the <bpt i="7" x="7">&lt;c7&gt;</bpt>Customer<ept i="7">&lt;/c7&gt;</ept> class has an optional <bpt i="8" x="8">&lt;c8&gt;</bpt>card<ept i="8">&lt;/c8&gt;</ept> property, but the <bpt i="9" x="9">&lt;c9&gt;</bpt>CreditCard<ept i="9">&lt;/c9&gt;</ept> class has an unowned (and nonoptional) <bpt i="10" x="10">&lt;c10&gt;</bpt>customer<ept i="10">&lt;/c10&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを表すために、<bpt i="7" x="7">&lt;c7&gt;</bpt>Customer<ept i="7">&lt;/c7&gt;</ept>クラスはオプショナルの<bpt i="8" x="8">&lt;c8&gt;</bpt>カード<ept i="8">&lt;/c8&gt;</ept>プロパティを持ちます、しかし、<bpt i="9" x="9">&lt;c9&gt;</bpt>CreditCard<ept i="9">&lt;/c9&gt;</ept>クラスは非オプショナルの<bpt i="10" x="10">&lt;c10&gt;</bpt>customer<ept i="10">&lt;/c10&gt;</ept>プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To require that subclasses implement a superclass’s initializer, mark the superclass’s initializer with the <bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるスーパークラスの持つイニシャライザをそのサブクラスたちが実装することを要求するために、そのスーパークラスのイニシャライザを<bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept>宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To restrict the adoption of a protocol to class types only, include the <bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept> protocol in the <bpt i="1" x="1">&lt;e1&gt;</bpt>inherited protocols<ept i="1">&lt;/e1&gt;</ept> list after the colon.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコルの採用をクラス型のみに制約するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept>プロトコルを<bpt i="1" x="1">&lt;e1&gt;</bpt>継承されたプロトコル<ept i="1">&lt;/e1&gt;</ept>のリストの中にコロンの後で加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To retrieve a count of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> values in a string, use the <bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept> property of the string:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある文字列の中の<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>値の総数を取り出すために、その文字列の<bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept>プロパティを使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To see an example of how to create and implement a new operator, see <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Custom Operators<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい演算子の作成と実装の方法の例を見るには、<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>あつらえの演算子<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To see an example of how to use a <bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept> statement with several <bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> clauses, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Handling Errors<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>文を複数の<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>節とともに使う方法の例を見るために、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>エラーを処理する<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To see examples of initializers in various type declarations, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Initialization<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いろいろな型宣言におけるイニシャライザの例を見るために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>初期化<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To set its value, the subscript setter is called in the same way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その値を設定するために、添え字セッターが同様に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To set up the interdependency between the two classes, the initializer for <bpt i="0" x="0">&lt;c0&gt;</bpt>City<ept i="0">&lt;/c0&gt;</ept> takes a <bpt i="1" x="1">&lt;c1&gt;</bpt>Country<ept i="1">&lt;/c1&gt;</ept> instance, and stores this instance in its <bpt i="2" x="2">&lt;c2&gt;</bpt>country<ept i="2">&lt;/c2&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つのクラスの間で相互依存を設定するために、<bpt i="0" x="0">&lt;c0&gt;</bpt>City<ept i="0">&lt;/c0&gt;</ept>のためのイニシャライザは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Country<ept i="1">&lt;/c1&gt;</ept>インスタンスをとって、このインスタンスをそれの<bpt i="2" x="2">&lt;c2&gt;</bpt>country<ept i="2">&lt;/c2&gt;</ept>プロパティに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To simplify the relationships between designated and convenience initializers, Swift applies the following three rules for delegation calls between initializers:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>指定と便宜イニシャライザの間の関係を単純化するために、スウィフトは以下の３つの規則をイニシャライザ間の委任呼び出しに対して適用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To specify an in-out parameter, prefix the parameter type with the <bpt i="0" x="0">&lt;c0&gt;</bpt>inout<ept i="0">&lt;/c0&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>in-outパラメータを指定するために、<bpt i="0" x="0">&lt;c0&gt;</bpt>inout<ept i="0">&lt;/c0&gt;</ept>キーワードをそのパラメータ型の前に置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To specify that the <bpt i="0" x="0">&lt;c0&gt;</bpt>push(_:)<ept i="0">&lt;/c0&gt;</ept> method has a single parameter called <bpt i="1" x="1">&lt;c1&gt;</bpt>item<ept i="1">&lt;/c1&gt;</ept>, which must be of type <bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>push(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドが一つのパラメータ、<bpt i="1" x="1">&lt;c1&gt;</bpt>item<ept i="1">&lt;/c1&gt;</ept>と呼ばれるものを持つことを指定する所で、それは、型<bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>でなければなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To specify that the value returned by the <bpt i="0" x="0">&lt;c0&gt;</bpt>pop()<ept i="0">&lt;/c0&gt;</ept> method will be a value of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>pop()<ept i="0">&lt;/c0&gt;</ept>メソッドによって返される値が型<bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>の値であることを示す所で</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To support recursion, the compiler must insert a layer of indirection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>再帰をサポートするために、コンパイラは間接参照の階層を差し入れる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To use a function, you “call” that function with its name and pass it input values (known as <bpt i="1" x="1">&lt;e1&gt;</bpt>arguments<ept i="1">&lt;/e1&gt;</ept>) that match the types of the function’s parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある関数を使うためには、あなたはその関数をそれの名前を使って「呼び出し」、それにその関数のパラメータの型に適合する入力値（<bpt i="1" x="1">&lt;e1&gt;</bpt>引数<ept i="1">&lt;/e1&gt;</ept>として知られます）を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To use a nested type outside of its definition context, prefix its name with the name of the type it is nested within:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされた型をその定義の文脈外で使うために、その名前にそれが入れ子にされている型の名前で接頭辞を付けてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To use a reserved word as an identifier, put a backtick (<bpt i="0" x="0">&lt;c0&gt;</bpt>`<ept i="0">&lt;/c0&gt;</ept>) before and after it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>識別子として予約語を使用するために、それの前後にバッククォート（<bpt i="0" x="0">&lt;c0&gt;</bpt>`<ept i="0">&lt;/c0&gt;</ept>）を置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To use it in the ternary conditional (<bpt i="3" x="3">&lt;c3&gt;</bpt>?<ept i="3">&lt;/c3&gt;</ept> <bpt i="4" x="4">&lt;c4&gt;</bpt>:<ept i="4">&lt;/c4&gt;</ept>) operator, it must have whitespace around both sides.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それを三項条件（<bpt i="3" x="3">&lt;c3&gt;</bpt>?<ept i="3">&lt;/c3&gt;</ept> <bpt i="4" x="4">&lt;c4&gt;</bpt>:<ept i="4">&lt;/c4&gt;</ept>）において使うためには、それは両側に空白を持ってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To use optional chaining, use a question mark in place of the exclamation mark:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナル連鎖を使用するために、感嘆符の代わりに疑問符を使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To use the <bpt i="2" x="2">&lt;c2&gt;</bpt>?<ept i="2">&lt;/c2&gt;</ept> as the optional-chaining operator, it must not have whitespace on the left.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>?<ept i="2">&lt;/c2&gt;</ept>をオプショナル連鎖演算子として使うには、それは左側に空白を持ってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To use the equivalence operators to check for equivalence of your own custom type, provide an implementation of the operators in the same way as for other infix operators:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなた独自のあつらえの型の同等について調べるために同等演算子を使用するには、他の接中辞演算子と同じやり方でこれらの演算子の実装を提供してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To win, you must land <bpt i="0" x="0">&lt;e0&gt;</bpt>exactly<ept i="0">&lt;/e0&gt;</ept> on square 25.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>勝つために、あなたは<bpt i="0" x="0">&lt;e0&gt;</bpt>ぴったり<ept i="0">&lt;/e0&gt;</ept>正方形25に到着しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To work out the exact evaluation order to use, you also need to consider their associativity.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>使用する的確な評価順序を解き明かすには、あなたはまたそれらの結合性を考慮する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Top-Level Code</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>トップレベル・コード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tradition suggests that the first program in a new language should print the words “Hello, world!” on the screen.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>伝統は、新しい言語において最初のプログラムが画面上に語句「Hello, world!」を出力しなければならないことを示唆します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Trailing Closures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後付クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Trailing closure syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>後付クロージャ構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Trailing closures are most useful when the closure is sufficiently long that it is not possible to write it inline on a single line.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャがそれをただ一つの行の行内に書くことが可能でないほど長いとき、後付クロージャは最も役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Try Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>try演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Try removing the conversion to <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> from the last line.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後の行から<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>への転換を取り除いてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Try removing the default case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何れにも当てはまらない場合の部分（default: の部分）を取り除いてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Trying to change the value of a function parameter from within the body of that function results in a compile-time error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その関数の本文内部から関数パラメータの値を変えようとすることは、コンパイル時エラーに終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Trying to set an <bpt i="3" x="3">&lt;c3&gt;</bpt>Int16<ept i="3">&lt;/c3&gt;</ept> constant or variable to a number outside of this range causes an error:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>Int16<ept i="3">&lt;/c3&gt;</ept>定数または変数をこの範囲の外側の数に設定する試みは、エラーを引き起こします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Trying to use <bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept> to access a nonexistent optional value triggers a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>存在しないオプショナルの値にアクセスするために<bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept>を使うことを試みることは、実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tuple Pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプルパターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tuple Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tuple Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tuple patterns match values of corresponding tuple types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプルパターンは、対応するタプル型の値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tuple types don’t have a standalone definition in the way that classes, structures, enumerations, and functions do.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプル型には、クラス、構造体、列挙、そして関数が行う方法での、独立した定義がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tuples</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tuples are compared from left to right, one value at a time, until the comparison finds two values that aren’t equal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプルは、左から右へと、一度に１つの値を、比較が等しくない２つの値を見つけるまで、比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tuples are particularly useful as the return values of functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプルは、特に関数の戻り値として便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tuples are useful for temporary groups of related values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプルは、関連した値の一時的なグループに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tuples can also be used as parameter types and return types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプルもまた、パラメータ型および戻り型として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tuples enable you to create and pass around groupings of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプルは、あなたに値のグループをつくってあちこち渡すことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Two <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> values (or two <bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept> values) are considered equal if their extended grapheme clusters are <bpt i="2" x="2">&lt;e2&gt;</bpt>canonically equivalent<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>値（または２つの<bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept>）は、それらの拡張書記素クラスタたちが<bpt i="2" x="2">&lt;e2&gt;</bpt>正準等価<ept i="2">&lt;/e2&gt;</ept>ならば、等しいとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Two-Phase Initialization</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２段階初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Two-phase initialization prevents property values from being accessed before they are initialized, and prevents property values from being set to a different value by another initializer unexpectedly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２段階初期化は、プロパティ値が初期化される前にアクセスされるのを妨げます、それによってプロパティ値が思いもよらず別のイニシャライザによって異なる値に設定されるのを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Alias Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型エイリアス宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Aliases</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型エイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Annotation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型注釈</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Annotations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さまざまな型注釈</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Attributes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Casting</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型キャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Casting for Any and AnyObject</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>AnyおよびAnyObjectに対する型キャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Constraint Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型制約構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Constraints</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型制約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Constraints in Action</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型制約の動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Identifier</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型識別子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Inference</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型推論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Inheritance Clause</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型継承節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Parameters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Property Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型プロパティ構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Safety and Type Inference</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型安全と型推論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type Variable Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型変数プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type alias declarations are declared using the <bpt i="1" x="1">&lt;c1&gt;</bpt>typealias<ept i="1">&lt;/c1&gt;</ept> keyword and have the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型エイリアス宣言は、キーワード<bpt i="1" x="1">&lt;c1&gt;</bpt>typealias<ept i="1">&lt;/c1&gt;</ept>を使って宣言されます、そして以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type aliases are useful when you want to refer to an existing type by a name that is contextually more appropriate, such as when working with data of a specific size from an external source:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型エイリアスは、あなたがより文脈上適切な名前で既存の型に言及したいとき役に立ちます、たとえば外部ソースからの特定の大きさのデータを扱う時など：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type aliases do not create new types; they simply allow a name to refer to an existing type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型エイリアスは、新しい型を作成しません；それらは、単にある名前が既存の型に言及できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type annotations begin with a colon (<bpt i="1" x="1">&lt;c1&gt;</bpt>:<ept i="1">&lt;/c1&gt;</ept>) and end with a type, as the following examples show:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型注釈は、以下の例が示すように、コロン（<bpt i="1" x="1">&lt;c1&gt;</bpt>:<ept i="1">&lt;/c1&gt;</ept>）で始まりひとつの型で終わります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type annotations can contain an optional list of type attributes before the type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型注釈は、型の前に任意の型属性のリストを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type casting enables you to check and interpret the type of a class instance at runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型キャストは、あなたにクラスインスタンスの型を実行時に調べて解釈することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type casting in Swift is implemented with the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept> operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでの型キャストは、<bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept>演算子を使って実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type casts that can fail at runtime now use the <bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>as!<ept i="1">&lt;/c1&gt;</ept> operator, and type casts that are guaranteed not to fail use the <bpt i="2" x="2">&lt;c2&gt;</bpt>as<ept i="2">&lt;/c2&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実行時に失敗できる型キャストは、今では<bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>as!<ept i="1">&lt;/c1&gt;</ept>演算子を使います、そして失敗しないことを保証される型キャストは<bpt i="2" x="2">&lt;c2&gt;</bpt>as<ept i="2">&lt;/c2&gt;</ept>演算子を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type constraints specify that a type parameter must inherit from a specific class, or conform to a particular protocol or protocol composition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型制約は、型パラメータが特定のクラスから継承しなければならない、もしくはある特定のプロトコルまたはプロトコル合成に準拠しなければならないことを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type constraints, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Type Constraints<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, enable you to define requirements on the type parameters associated with a generic function, subscript, or type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型制約は、「<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>型制約<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>」で記述されるように、総称体の関数、添え字、または型と関連した型パラメータに要件を定義することをあなたに可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type inference enables a compiler to deduce the type of a particular expression automatically when it compiles your code, simply by examining the values you provide.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型推論は、コンパイラに自動的に特定の式の型を演繹することを、それがあなたのコードをコンパイルする時に、単純にあなたが提供する値を調べることによって、可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type inference helps make Swift code more concise and readable when it initializes constants or variables with other values whose type is already known.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型推論は、スウィフトのコードを、それが定数または変数を型がすでに知られている他の値で初期化するとき、より簡潔で読みやすくするのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type inference in Swift operates at the level of a single expression or statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの型推論は、単一の式や文の水準で働きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type inference is particularly useful when you declare a constant or variable with an initial value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが最初の値で定数または変数を宣言するとき、型推論は特に役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type methods and properties now use the <bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept> keyword as a declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッドとプロパティは今では<bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept>キーワードを宣言修飾子として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type methods are called with dot syntax, like instance methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型メソッドは、インスタンスメソッドの様に、ドット構文で呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type methods are similar to class methods in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型メソッドは、Objective-Cにおけるクラスメソッドに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type parameters specify and name a placeholder type, and are written immediately after the function’s name, between a pair of matching angle brackets (such as <bpt i="3" x="3">&lt;c3&gt;</bpt>&lt;T&gt;<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型パラメータは、プレースホルダ型を指定して命名します、そして関数の名前の直後に一対の山形括弧の間で書かれます（例えば<bpt i="3" x="3">&lt;c3&gt;</bpt>&lt;T&gt;<ept i="3">&lt;/c3&gt;</ept>）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type properties are discussed in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Type Properties<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型プロパティは、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>型プロパティ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type properties are discussed in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Type Properties<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型プロパティは、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>型プロパティ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type properties are queried and set with dot syntax, just like instance properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型プロパティは、インスタンスプロパティのように、ドット構文で問い合わせられ設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type properties are useful for defining values that are universal to <bpt i="0" x="0">&lt;e0&gt;</bpt>all<ept i="0">&lt;/e0&gt;</ept> instances of a particular type, such as a constant property that all instances can use (like a static constant in C), or a variable property that stores a value that is global to all instances of that type (like a static variable in C).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型プロパティは、特定の型の<bpt i="0" x="0">&lt;e0&gt;</bpt>全ての<ept i="0">&lt;/e0&gt;</ept>インスタンスに共通なさまざまな値を定義することに役立ちます、例えば、全てのインスタンスが使うことができる定数プロパティ（Cでの静的定数のように）、またはその型の全てのインスタンスにグローバルである値を保存する変数プロパティ（Cでの静的変数のように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type safety helps you catch and fix errors as early as possible in the development process.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型安全は、あなたが開発プロセスにおいて可能な限り早期にエラーを捕まえて修復するのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type-Casting Operators</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型キャスト演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type-Casting Patterns</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型キャスト・パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Type-checking helps you avoid errors when you’re working with different types of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型をチェックすることは、あなたが異なる種類の値を扱っているとき、あなたがエラーを避ける手助けをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types can be nested to as many levels as are required.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型は、必要とされるだけ多くの階層に入れ子にされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types don’t automatically adopt a protocol just by satisfying its requirements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型は、単にその要件を満たすことだけによっては自動的にあるプロトコルを採用しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types that conform to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> protocol must provide a gettable <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> property called <bpt i="3" x="3">&lt;c3&gt;</bpt>hashValue<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>プロトコルに適合する型は、取得可能な<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>プロパティ、<bpt i="3" x="3">&lt;c3&gt;</bpt>hashValue<ept i="3">&lt;/c3&gt;</ept>と呼ばれるものを提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typically you don’t need to perform manual cleanup when your instances are deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>概して、あなたのインスタンスが割り当て解除されるとき、あなたが手動で掃除をする必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typically, you use the <bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept> statement to evaluate simple conditions with only a few possible outcomes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一般的に、あなたは<bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept>文をほんの２、３の起こりうる結果だけを持つ単純な状況を評価するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>UInt</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>符号なし整数（Unsigned Integer）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>UTF-16 Representation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-16表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>UTF-8 Representation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>UTF-8表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unary <bpt i="2" x="2">&lt;e2&gt;</bpt>prefix<ept i="2">&lt;/e2&gt;</ept> operators appear immediately before their target (such as <bpt i="3" x="3">&lt;c3&gt;</bpt>!b<ept i="3">&lt;/c3&gt;</ept>), and unary <bpt i="4" x="4">&lt;e4&gt;</bpt>postfix<ept i="4">&lt;/e4&gt;</ept> operators appear immediately after their target (such as <bpt i="5" x="5">&lt;c5&gt;</bpt>c!<ept i="5">&lt;/c5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単項<bpt i="2" x="2">&lt;e2&gt;</bpt>接頭辞<ept i="2">&lt;/e2&gt;</ept>演算子はそれらの目標の直前に現れます（例えば<bpt i="3" x="3">&lt;c3&gt;</bpt>!b<ept i="3">&lt;/c3&gt;</ept>のように）、そして単項<bpt i="4" x="4">&lt;e4&gt;</bpt>接尾辞<ept i="4">&lt;/e4&gt;</ept>演算子はそれらの目標の直後に現れます（例えば<bpt i="5" x="5">&lt;c5&gt;</bpt>c!<ept i="5">&lt;/c5&gt;</ept>のように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unary Minus Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単項マイナス演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unary Plus Operator</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単項プラス演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unary operators operate on a single target.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単項演算子は、一つの目標に作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Underscores (<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>) are allowed between digits for readability, but are ignored and therefore don’t affect the value of the literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アンダースコア（<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>）は、可読性のために桁の間で認められます、しかし無視されることから、リテラルの値に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Underscores (<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>) are allowed between digits for readability, but they’re ignored and therefore don’t affect the value of the literal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アンダースコア（<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>）は、可読性のために桁の間で認められます、しかしそれらは無視されて、それゆえにリテラルの値に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unfortunately, linking these two instances creates a strong reference cycle between them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>残念なことに、これらの２つのインスタンスを結ぶことは、それらの間で強い参照循環をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unfortunately, the <bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept> class, as written above, creates a strong reference cycle between an <bpt i="1" x="1">&lt;c1&gt;</bpt>HTMLElement<ept i="1">&lt;/c1&gt;</ept> instance and the closure used for its default <bpt i="2" x="2">&lt;c2&gt;</bpt>asHTML<ept i="2">&lt;/c2&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>残念なことに、この<bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept>クラスは、上で書かれるように、<bpt i="1" x="1">&lt;c1&gt;</bpt>HTMLElement<ept i="1">&lt;/c1&gt;</ept>インスタンスとその省略時の<bpt i="2" x="2">&lt;c2&gt;</bpt>asHTML<ept i="2">&lt;/c2&gt;</ept>値のために使われるクロージャとの間に強い参照循環をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unicode</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unicode Representations of Strings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列のユニコード表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unicode Scalar Representation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコード・スカラー表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unicode Scalars</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコード・スカラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unicode scalar (<bpt i="0" x="0">&lt;c0&gt;</bpt>\u{<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>}<ept i="2">&lt;/c2&gt;</ept>), where <bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept> is a hexadecimal number that has one to eight digits</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコード・スカラー（<bpt i="0" x="0">&lt;c0&gt;</bpt>\u{<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>}<ept i="2">&lt;/c2&gt;</ept>）、ここで<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>は16進数で１から８桁を持ちます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unicode scalars don’t include the Unicode <bpt i="5" x="5">&lt;e5&gt;</bpt>surrogate pair<ept i="5">&lt;/e5&gt;</ept> code points, which are the code points in the range <bpt i="6" x="6">&lt;c6&gt;</bpt>U+D800<ept i="6">&lt;/c6&gt;</ept> to <bpt i="7" x="7">&lt;c7&gt;</bpt>U+DFFF<ept i="7">&lt;/c7&gt;</ept> inclusive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ユニコード・スカラーは、ユニコードの<bpt i="5" x="5">&lt;e5&gt;</bpt>サロゲート・ペア<ept i="5">&lt;/e5&gt;</ept>のコードポイントを含みません、それは、範囲<bpt i="6" x="6">&lt;c6&gt;</bpt>U+D800<ept i="6">&lt;/c6&gt;</ept>から<bpt i="7" x="7">&lt;c7&gt;</bpt>U+DFFF<ept i="7">&lt;/c7&gt;</ept>を含めてまでのコードポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unicode scalars for regional indicator symbols can be combined in pairs to make a single <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> value, such as this combination of <bpt i="1" x="1">&lt;c1&gt;</bpt>REGIONAL INDICATOR SYMBOL LETTER U<ept i="1">&lt;/c1&gt;</ept> (<bpt i="2" x="2">&lt;c2&gt;</bpt>U+1F1FA<ept i="2">&lt;/c2&gt;</ept>) and <bpt i="3" x="3">&lt;c3&gt;</bpt>REGIONAL INDICATOR SYMBOL LETTER S<ept i="3">&lt;/c3&gt;</ept> (<bpt i="4" x="4">&lt;c4&gt;</bpt>U+1F1F8<ept i="4">&lt;/c4&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>地域標識記号のためのユニコード・スカラーは、単一の<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>値を作るために２つ一組で組み合わされることが出来ます、例えば<bpt i="1" x="1">&lt;c1&gt;</bpt>REGIONAL INDICATOR SYMBOL LETTER U<ept i="1">&lt;/c1&gt;</ept>（<bpt i="2" x="2">&lt;c2&gt;</bpt>U+1F1FA<ept i="2">&lt;/c2&gt;</ept>）と<bpt i="3" x="3">&lt;c3&gt;</bpt>REGIONAL INDICATOR SYMBOL LETTER S<ept i="3">&lt;/c3&gt;</ept>（<bpt i="4" x="4">&lt;c4&gt;</bpt>U+1F1F8<ept i="4">&lt;/c4&gt;</ept>）の組み合わせのように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unless otherwise specified, the default access level is internal, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Default Access Levels<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に明記しない限り、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>省略時のアクセス水準<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、省略時のアクセス水準は内部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unless otherwise specified, the default inferred type of a floating-point literal is the Swift standard library type <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>, which represents a 64-bit floating-point number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に明記しない限り、初期状態で推論されるリテラル浮動小数点の型は、スウィフト標準ライブラリ型<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>です、それは、64ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unless otherwise specified, the default inferred type of an integer literal is the Swift standard library type <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に明記しない限り、初期状態で推論されるリテラル整数の型は、スウィフト標準ライブラリ型<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unless the value of <bpt i="0" x="0">&lt;c0&gt;</bpt>integerToDescribe<ept i="0">&lt;/c0&gt;</ept> is in the list of known prime numbers, it is not matched by the first <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> case at all.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>integerToDescribe<ept i="0">&lt;/c0&gt;</ept>の値が知っている素数のリストの中にある場合を除いて、それは最初の<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>ケース節に適合することはまったくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unless you need to add backward compatibility with existing archives, use the <bpt i="2" x="2">&lt;c2&gt;</bpt>objc<ept i="2">&lt;/c2&gt;</ept> attribute instead to specify an Objective-C name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが既存のアーカイブとの後方互換性を加えるのでない限り、Objective-C名を指定するのではなく<bpt i="2" x="2">&lt;c2&gt;</bpt>objc<ept i="2">&lt;/c2&gt;</ept>属性を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unless you need to work with a specific size of integer, always use <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> for integer values in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが整数の特定のサイズを扱う必要がない限り、常に、あなたのコードの整数値のために<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike Boolean conditions, you can’t combine availability conditions using logical operators such as <bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&amp;<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>||<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブール条件と違って、あなたは論理演算子例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&amp;<ept i="0">&lt;/c0&gt;</ept>や<bpt i="1" x="1">&lt;c1&gt;</bpt>||<ept i="1">&lt;/c1&gt;</ept>などを使って有効性条件を連結することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike C and Objective-C, Swift enumeration cases are not assigned a default integer value when they are created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>CおよびObjective-Cとは異なり、スウィフト列挙ケース節は、それらがつくられるとき省略時の整数値を代入されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike C, Swift allows multiple <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> cases to consider the same value or values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cと違って、スウィフトは複数の<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>ケース節に、同じ値または複数の値について考慮させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike Objective-C initializers, Swift initializers do not return a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cのイニシャライザと違って、スウィフトのイニシャライザは値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike Objective-C, Swift enables you to set sub-properties of a structure property directly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cと違って、スウィフトはあなたに直接ある構造体プロパティの下位プロパティを設定するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement in C, this <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement does not match both <bpt i="2" x="2">&lt;c2&gt;</bpt>"a"<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>"A"<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cでの<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文と違って、この<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文は<bpt i="2" x="2">&lt;c2&gt;</bpt>"a"<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>"A"<ept i="3">&lt;/c3&gt;</ept>の両方に合うものを見つけるわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike a default initializer, the structure receives a memberwise initializer even if it has stored properties that do not have default values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時のイニシャライザと違って、構造体はメンバー関連イニシャライザを、たとえその構造体が省略時の値を持たない保存プロパティを持つとしても、受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike a single-line string literal, a multiline string literal can contain unescaped double quotes (<bpt i="0" x="0">&lt;c0&gt;</bpt>"<ept i="0">&lt;/c0&gt;</ept>), carriage returns, and line feeds.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単一行の文字列リテラルと違い、複数行の文字列リテラルはエスケープされていない二重引用符（<bpt i="0" x="0">&lt;c0&gt;</bpt>"<ept i="0">&lt;/c0&gt;</ept>）、キャリッジリターン、そしてラインフィードを含むことが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike a subscript, however, the <bpt i="2" x="2">&lt;c2&gt;</bpt>updateValue(_:forKey:)<ept i="2">&lt;/c2&gt;</ept> method returns the <bpt i="3" x="3">&lt;e3&gt;</bpt>old<ept i="3">&lt;/e3&gt;</ept> value after performing an update.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、添え字とは違い、<bpt i="2" x="2">&lt;c2&gt;</bpt>updateValue(_:forKey:)<ept i="2">&lt;/c2&gt;</ept>メソッドは更新を実行した後に<bpt i="3" x="3">&lt;e3&gt;</bpt>古い<ept i="3">&lt;/e3&gt;</ept>値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike a variable, the value of a constant can’t be changed once it’s set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数とは異なり、一旦それが設定されるならば、定数の値は変わることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、弱い参照とは違い、非所有参照は他のインスタンスが同じ生涯またはより長い生涯を持つ場合に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike an <bpt i="4" x="4">&lt;c4&gt;</bpt>if<ept i="4">&lt;/c4&gt;</ept> statement, a <bpt i="5" x="5">&lt;c5&gt;</bpt>guard<ept i="5">&lt;/c5&gt;</ept> statement always has an <bpt i="6" x="6">&lt;c6&gt;</bpt>else<ept i="6">&lt;/c6&gt;</ept> clause—the code inside the <bpt i="7" x="7">&lt;c7&gt;</bpt>else<ept i="7">&lt;/c7&gt;</ept> clause is executed if the condition is not true.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>if<ept i="4">&lt;/c4&gt;</ept>文と違って、<bpt i="5" x="5">&lt;c5&gt;</bpt>guard<ept i="5">&lt;/c5&gt;</ept>文は常に<bpt i="6" x="6">&lt;c6&gt;</bpt>else<ept i="6">&lt;/c6&gt;</ept>節を持ちます—<bpt i="7" x="7">&lt;c7&gt;</bpt>else<ept i="7">&lt;/c7&gt;</ept>節の内部のコードはその条件が真でないならば実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike arithmetic operators in C, arithmetic operators in Swift do not overflow by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cでの算術演算子と違って、スウィフトの算術演算子は、初期状態ではオーバフローしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike arrays, sets do not have an equivalent shorthand form.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列とは違い、集合は相当する短縮形を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike classes and structures, enumeration types do not have an implicitly provided default initializer; all initializers must be declared explicitly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスや構造体と違って、列挙型には、暗黙のうちに提供される省略時のイニシャライザがありません；全てのイニシャライザは、明確に宣言されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike exception handling in many languages—including Objective-C—error handling in Swift does not involve unwinding the call stack, a process that can be computationally expensive.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>多くの言語 ― Objective-Cを含めて ― での例外処理と違い、スウィフトにおけるエラー処理はコールスタック、計算的に高くつく可能性がある処理、の巻き戻し（アンワインド）を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike instance methods, subscripts can be read-write or read-only.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスメソッドと違って、添え字は読み書き用であるか読み出し専用であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike items in an array, items in a dictionary do not have a specified order.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列の中の項目と違って、辞書の中の項目には、指定された順番がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike lazy stored properties, global constants and variables do not need to be marked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>lazy<ept i="2">&lt;/c2&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延保存プロパティと違って、グローバルな定数と変数は<bpt i="2" x="2">&lt;c2&gt;</bpt>lazy<ept i="2">&lt;/c2&gt;</ept>修飾子で印付けされる必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike many other languages, Swift doesn’t require you to write a semicolon (<bpt i="0" x="0">&lt;c0&gt;</bpt>;<ept i="0">&lt;/c0&gt;</ept>) after each statement in your code, although you can do so if you wish.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>多くの他の言語とは異なり、スウィフトはあなたにあなたのコードにおいて各文の後にセミコロン（<bpt i="0" x="0">&lt;c0&gt;</bpt>;<ept i="0">&lt;/c0&gt;</ept>）を書くことを要求しません、けれどもあなたが望むならば、あなたはそうできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike multiline comments in C, multiline comments in Swift can be nested inside other multiline comments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cでの複数行コメントと違って、スウィフトの複数行コメントは他の複数行コメント内部に入れ子にされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike other programming languages, Swift does not require you to create separate interface and implementation files for custom classes and structures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他のプログラミング言語と違って、スウィフトはあなたにカスタム・クラスおよび構造体のために別々のインタフェースおよび実装ファイルを作成することを要求しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike stored instance properties, you must always give stored type properties a default value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存インスタンスプロパティと違って、あなたは保存型プロパティに省略時の値を常に与えなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike stored named values and stored variable properties, the value of a computed named value or a computed property is not stored in memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>保存される名前を付けられた値および保存変数プロパティと違って、計算される名前を付けられた値または計算プロパティの値は、メモリに保存されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike structures and enumerations, classes have two kinds of initializers: designated initializers and convenience initializers, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Initialization<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体や列挙と違って、クラスは２種類のイニシャライザを持ちます：指定イニシャライザと便宜イニシャライザ、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>初期化<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike structures, class instances do not receive a default memberwise initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体と違って、クラスインスタンスは、自動生成のメンバー関連イニシャライザを授けられません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike subclasses in Objective-C, Swift subclasses do not inherit their superclass initializers by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでのサブクラスとは異なり、スウィフトのサブクラスは、特に何もしなくてもそれらのスーパークラスのイニシャライザを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike the arithmetic operators in C and Objective-C, the Swift arithmetic operators don’t allow values to overflow by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>CとObjective-Cの算術演算子と違って、スウィフトの算術演算子は、値がオーバフローするのを初期状態では許しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike the assignment operator in C and Objective-C, the assignment operator in Swift does not itself return a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>CとObjective-Cの代入演算子と違って、スウィフトの代入演算子は、それ自身で値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike the cases in the first form, each case has an underlying value, called a <bpt i="1" x="1">&lt;e1&gt;</bpt>raw value<ept i="1">&lt;/e1&gt;</ept>, of the same basic type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の形式でのケース節と違って、それぞれのケース節は、同じ基本の型の、もととなる値、<bpt i="1" x="1">&lt;e1&gt;</bpt>生の値<ept i="1">&lt;/e1&gt;</ept>と呼ばれるものを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike the condition of an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement, the <bpt i="1" x="1">&lt;e1&gt;</bpt>compilation condition<ept i="1">&lt;/e1&gt;</ept> is evaluated at compile time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文の条件とは違い、<bpt i="1" x="1">&lt;e1&gt;</bpt>compilation condition（コンパイル条件）<ept i="1">&lt;/e1&gt;</ept>はコンパイル時に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike the error conditions discussed in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Error Handling<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> above, assertions and preconditions aren’t used for recoverable or expected errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>エラー処理<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で議論されるエラー条件とは違い、表明と前提条件は回復できるまたは予想されたエラーに対して使われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike value types, <bpt i="0" x="0">&lt;e0&gt;</bpt>reference types<ept i="0">&lt;/e0&gt;</ept> are <bpt i="1" x="1">&lt;e1&gt;</bpt>not<ept i="1">&lt;/e1&gt;</ept> copied when they are assigned to a variable or constant, or when they are passed to a function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型とは異なり、<bpt i="0" x="0">&lt;e0&gt;</bpt>参照型<ept i="0">&lt;/e0&gt;</ept>は、それが変数や定数に代入される時に、あるいはそれが関数に渡される時に、コピーされ<bpt i="1" x="1">&lt;e1&gt;</bpt>ません<ept i="1">&lt;/e1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unowned References</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非所有者参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unowned References and Implicitly Unwrapped Optional Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非所有者参照と暗黙的にアンラップされるオプショナルのプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Upcasting lets you use an expression as an instance of its type’s supertype, without using an intermediate variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アップキャストは、あなたにある式をそれのスーパータイプのインスタンスとして使用させます、中間生成物の変数の使用なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Closures Are Reference Types<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> to clarify the capturing rules for variables.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>クロージャは参照型です<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を新しくして、変数に対するキャプチャ規則を明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Defining a Capture List<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> to clarify the syntax for weak and unowned references in closure capture lists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>捕獲リストの定義<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を新しくして、クロージャ捕獲リスト内の弱いおよび非所有参照に対する構文を明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> to explicitly mention examples of supported characters for custom operators, such as those in the Mathematical Operators, Miscellaneous Symbols, and Dingbats Unicode blocks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を更新して、あつらえの演算子のためにサポートされる文字の例にはっきりと言及するようにしました、例えばMathematical Operators、Miscellaneous Symbols、そしてDingbatsユニコードブロックにおけるそれら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocol Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> to clarify protocol declaration scope and members.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコル宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を新しくして、プロトコル宣言スコープおよびメンバーを明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Range Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> to note that a half-open range with the same start and end index will be empty.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>範囲演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を新しくして、同じ開始および終止インデックスを持つ半開範囲が空になることを記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Value Overflow<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> to clarify the overflow behavior of signed and unsigned integers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>値オーバフロー<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を新しくして、符号つき及び符号なし整数のオーバフロー挙動を明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated a note in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Property Observers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to clarify the behavior of <bpt i="2" x="2">&lt;c2&gt;</bpt>willSet<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>didSet<ept i="3">&lt;/c3&gt;</ept> observers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロパティオブザーバー<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>willSet<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>didSetオ<ept i="3">&lt;/c3&gt;</ept>ブザーバーの挙動を理解しやすくするために更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated a note in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Type Properties<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to mention that stored type properties are lazily initialized.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>型プロパティ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節の注を更新して、保存型プロパティが遅延して初期化されることに言及した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated and expanded the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Comparing Strings<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to reflect and demonstrate that string and character comparison and prefix / suffix comparison are now based on Unicode canonical equivalence of extended grapheme clusters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>文字列を比較する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を更新および拡張して、文字列および文字比較と接頭辞／接尾辞比較が今では拡張書記クラスタのユニコード正準等価に基づかれることを反映し例示しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated attribute arguments to use a colon in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Attributes<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>属性引数をコロンを使うように章<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>属性<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated discussion throughout to use macOS instead of OS X, <bpt i="0" x="0">&lt;c0&gt;</bpt>Error<ept i="0">&lt;/c0&gt;</ept> instead of <bpt i="1" x="1">&lt;c1&gt;</bpt>ErrorProtocol<ept i="1">&lt;/c1&gt;</ept>, and protocol names such as <bpt i="2" x="2">&lt;c2&gt;</bpt>ExpressibleByStringLiteral<ept i="2">&lt;/c2&gt;</ept> instead of <bpt i="3" x="3">&lt;c3&gt;</bpt>StringLiteralConvertible<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>解説を隅から隅まで更新してmacOSをOS Xの代わりに、, <bpt i="0" x="0">&lt;c0&gt;</bpt>Error<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>ErrorProtocol<ept i="1">&lt;/c1&gt;</ept>の代わりに、<bpt i="2" x="2">&lt;c2&gt;</bpt>ExpressibleByStringLiteral<ept i="2">&lt;/c2&gt;</ept>のようなプロトコル名を<bpt i="3" x="3">&lt;c3&gt;</bpt>StringLiteralConvertible<ept i="3">&lt;/c3&gt;</ept>の代わりに使うようにした</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated figures in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Weak References<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to show the deallocation process more clearly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>弱い参照<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節の図を更新して、デアロケーション過程をより明瞭に見せるようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 1.1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 1.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 1.2.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 1.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 2.0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 2.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 2.1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 2.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 2.2.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 2.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 3.0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 3.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 3.0.1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 3.0.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 3.1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 3.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated information about initializers that return <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> before the instance is fully initialized in the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Failable Initializers<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンスが完全に初期化される前に<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返すイニシャライザについての情報を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>失敗できるイニシャライザ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Accessing Properties Through Optional Chaining<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to clarify how assignment through optional chaining behaves.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オプショナル連鎖を通してプロパティにアクセスする<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を更新して、オプショナル連鎖をを通した割り当てがどのように振る舞うかを明確にした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Accessing and Modifying a Dictionary<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to note that <bpt i="2" x="2">&lt;c2&gt;</bpt>Dictionary<ept i="2">&lt;/c2&gt;</ept> now has a Boolean <bpt i="3" x="3">&lt;c3&gt;</bpt>isEmpty<ept i="3">&lt;/c3&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>辞書へのアクセスと修正<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を更新して<bpt i="2" x="2">&lt;c2&gt;</bpt>Dictionary<ept i="2">&lt;/c2&gt;</ept>が今やブールの<bpt i="3" x="3">&lt;c3&gt;</bpt>isEmpty<ept i="3">&lt;/c3&gt;</ept>プロパティを持つことを記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Accessing and Modifying an Array<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to note that you can no longer append a single item to an array with the <bpt i="2" x="2">&lt;c2&gt;</bpt>+=<ept i="2">&lt;/c2&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>配列へのアクセスと変更<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を更新して、あなたがもはや単一の項目を<bpt i="2" x="2">&lt;c2&gt;</bpt>+=<ept i="2">&lt;/c2&gt;</ept>演算子を使って配列に加えることが出来ないことを注記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Attributes<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter to note that the <bpt i="2" x="2">&lt;c2&gt;</bpt>@IBAction<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>@IBOutlet<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>@NSManaged<ept i="4">&lt;/c4&gt;</ept> attributes imply the <bpt i="5" x="5">&lt;c5&gt;</bpt>@objc<ept i="5">&lt;/c5&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>属性<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の章を更新して、<bpt i="2" x="2">&lt;c2&gt;</bpt>@IBAction<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>@IBOutlet<ept i="3">&lt;/c3&gt;</ept>、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>@NSManaged<ept i="4">&lt;/c4&gt;</ept>属性が<bpt i="5" x="5">&lt;c5&gt;</bpt>@objc<ept i="5">&lt;/c5&gt;</ept>属性を暗示することを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Break Statement<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about labeled break statements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ブレーク文<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>をラベルをつけられたブレーク文についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Capturing Values<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to clarify how variables and constants are captured in closures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>値を捕獲する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を更新してどのように変数と定数がクロージャにキャプチャされるかをわかりやすくした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Concatenating Strings and Characters<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to reflect the fact that <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Character<ept i="3">&lt;/c3&gt;</ept> values can no longer be combined with the addition operator (<bpt i="4" x="4">&lt;c4&gt;</bpt>+<ept i="4">&lt;/c4&gt;</ept>) or addition assignment operator (<bpt i="5" x="5">&lt;c5&gt;</bpt>+=<ept i="5">&lt;/c5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>文字列と文字の連結<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>Character<ept i="3">&lt;/c3&gt;</ept>値はもはや加算演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt>+<ept i="4">&lt;/c4&gt;</ept>）または加算代入演算子（<bpt i="5" x="5">&lt;c5&gt;</bpt>+=<ept i="5">&lt;/c5&gt;</ept>）を使って結合されることができないという事実を反映するために更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Declaration Attributes<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Conditional Compilation Block<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> sections with information about tvOS.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>宣言属性<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>条件コンパイルプロック<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>節をtvOSについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Declaration Attributes<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to describe when you can apply the <bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept> attribute to classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>宣言属性<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を更新してあなたが<bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept>属性をクラスへ適用できる場合を記述した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Declaration Attributes<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about the <bpt i="2" x="2">&lt;c2&gt;</bpt>@available<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>@warn_unused_result<ept i="3">&lt;/c3&gt;</ept> attributes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>宣言属性<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>@available<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>@warn_unused_result<ept i="3">&lt;/c3&gt;</ept>属性についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Expressions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter to separate the discussion of parenthesized expressions and tuple expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>式<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の章を更新して、括弧で囲まれた式とタプル式の解説を分離した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Initializer Inheritance and Overriding<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to note that overrides of a designated initializer must now be marked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>override<ept i="2">&lt;/c2&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>イニシャライザの継承とオーバーライド<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を更新して、指定イニシャライザのオーバーライドは今や<bpt i="2" x="2">&lt;c2&gt;</bpt>override<ept i="2">&lt;/c2&gt;</ept>修飾子で印付けされなければならないことを注記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with discussion of custom operators that contain a dot.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節をドットを含むカスタム演算子の議論で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Repeat-While<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about the <bpt i="2" x="2">&lt;c2&gt;</bpt>repeat<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>この間繰り返す<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>repeat<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept>ループについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Representing and Throwing Errors<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section, now that all types can conform to the <bpt i="2" x="2">&lt;c2&gt;</bpt>ErrorType<ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>エラーの表現とスロー<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を更新した、現在ではすべての型が<bpt i="2" x="2">&lt;c2&gt;</bpt>ErrorType<ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Required Initializers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to note that the <bpt i="2" x="2">&lt;c2&gt;</bpt>required<ept i="2">&lt;/c2&gt;</ept> modifier is now written before every subclass implementation of a required initializer, and that the requirements for required initializers can now be satisfied by automatically inherited initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>必須イニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を更新して、<bpt i="2" x="2">&lt;c2&gt;</bpt>required<ept i="2">&lt;/c2&gt;</ept>修飾子が今やすべてのサブクラス実装の必須イニシャライザの前に書かれること、そして必須イニシャライザのための必要条件は今や自動的に継承されるイニシャライザで満たされることが出来るのを注記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Special Characters in String Literals<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with a more precise definition of Unicode scalars.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>文字列リテラル内の特別な文字<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>をユニコードスカラーのより精密な定義づけで更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>String Interpolation<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>String Literals<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> sections now that string interpolations can contain string literals.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>文字列補間<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>文字列リテラル<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>節を更新した、今では文字列補間は文字列リテラルを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>String Literals<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to note that Unicode scalars inside string literals are now written as <bpt i="2" x="2">&lt;c2&gt;</bpt>\u{n}<ept i="2">&lt;/c2&gt;</ept>, where <bpt i="3" x="3">&lt;c3&gt;</bpt>n<ept i="3">&lt;/c3&gt;</ept> is a hexadecimal number between 0 and 10FFFF, the range of Unicode’s codespace.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>文字列リテラル<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を更新して文字列内部のユニコード・スカラーが今や<bpt i="2" x="2">&lt;c2&gt;</bpt>\u{n}<ept i="2">&lt;/c2&gt;</ept>のように書かれることを記しました、ここで<bpt i="3" x="3">&lt;c3&gt;</bpt>n<ept i="3">&lt;/c3&gt;</ept>は０から10FFFまでの16進数、ユニコードの符号空間です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Strings and Characters<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter to reflect the fact that Swift’s <bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept> type now represents a single Unicode extended grapheme cluster.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>文字列と文字<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の章を、スウィフトの<bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept>型が今や単一のユニコード拡張書記素クラスタを表わすという事実を反映するために更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Strings and Characters<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter, now that <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> no longer conforms to the <bpt i="3" x="3">&lt;c3&gt;</bpt>CollectionType<ept i="3">&lt;/c3&gt;</ept> protocol from the Swift standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>文字列と文字<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を更新した、現在では<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>はもはやスウィフト標準ライブラリ由来の<bpt i="3" x="3">&lt;c3&gt;</bpt>CollectionType<ept i="3">&lt;/c3&gt;</ept>プロトコルに準拠しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Type Annotations<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to note that multiple related variables can be defined on a single line with one type annotation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>型注釈<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を更新して複数の関連する変数が１行だけで１つの型注釈で定義されることが出来ることを記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Type Attributes<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about the <bpt i="2" x="2">&lt;c2&gt;</bpt>@convention<ept i="2">&lt;/c2&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>型属性<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>@convention<ept i="2">&lt;/c2&gt;</ept>属性についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Type Properties<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about stored and computed type properties for classes, structures, and enumerations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>型プロパティ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>をクラス、構造体、そして列挙のための保存および計算型プロパティについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Variadic Parameters<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section, now that variadic parameters can be declared in any position in a function’s parameter list.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>可変長パラメータ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を更新した、現在では可変長パラメータは関数のパラメータリストの中のあらゆる位置で宣言されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Operators<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> reference to describe the revised rules.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>改められた規則を記述するために<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>演算子<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>リファレンスを更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the definition of Unicode scalars in string literals.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列リテラルの中のユニコードスカラーの定義を新しくしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion about default parameters in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Default Parameter Values<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section, now that they can’t be reordered in function calls.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>省略時のパラメータについての議論を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>省略時のパラメータ値<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節で更新した、今ではそれらは関数呼び出しにおいて再配列されることが出来ないので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Functions that Never Return<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> to use the new <bpt i="2" x="2">&lt;c2&gt;</bpt>Never<ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>決して返らない関数<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>での議論を更新して新しい<bpt i="2" x="2">&lt;c2&gt;</bpt>Never<ept i="2">&lt;/c2&gt;</ept>型を使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Escaping Closures<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section, now that closures are nonescaping by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>クロージャを脱出する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節において議論を更新した、今ではクロージャは初期状態で非脱出です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Function Type<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to note that argument labels are not allowed when writing a function type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>関数型<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節での議論を更新して、属性ラベルは関数型を書いている時に許可されないことを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Function Type<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section, now that Swift distinguishes between functions that take multiple parameters and functions that take a single parameter of a tuple type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>関数型<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節での議論を更新した、今ではスウィフトは複数のパラメータを取る関数とただ１つのタプル型のパラメータを取る関数の間の区別をするので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Generic Where Clauses<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section of the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Generics<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter and in the <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Generic Parameters and Arguments<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> chapter, now that generic <bpt i="6" x="6">&lt;c6&gt;</bpt>where<ept i="6">&lt;/c6&gt;</ept> clauses are written at the end of a declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>総称体<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章の<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>総称体where節<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節および<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>総称体パラメータと引数<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>の章において議論を更新した、今では総称体<bpt i="6" x="6">&lt;c6&gt;</bpt>where<ept i="6">&lt;/c6&gt;</ept>節は宣言の最後に書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>In-Out Parameters<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to note that only nonescaping closures can capture in-out parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>in-outパラメータ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節において解説を更新して、非脱出クロージャのみがin-outパラメータをキャプチャできることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Optional Binding<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section of the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>The Basics<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter and the <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>While Statement<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> section of the <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Statements<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept> chapter, now that <bpt i="8" x="8">&lt;c8&gt;</bpt>if<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>while<ept i="9">&lt;/c9&gt;</ept>, and <bpt i="10" x="10">&lt;c10&gt;</bpt>guard<ept i="10">&lt;/c10&gt;</ept> statements use a comma-separated list of conditions without <bpt i="11" x="11">&lt;c11&gt;</bpt>where<ept i="11">&lt;/c11&gt;</ept> clauses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>基本<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章の<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オプショナルを束縛する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節と<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>文<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>の章の<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>while文<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>の節での議論を更新した、今では<bpt i="8" x="8">&lt;c8&gt;</bpt>if<ept i="8">&lt;/c8&gt;</ept>、<bpt i="9" x="9">&lt;c9&gt;</bpt>while<ept i="9">&lt;/c9&gt;</ept>、そして<bpt i="10" x="10">&lt;c10&gt;</bpt>guard<ept i="10">&lt;/c10&gt;</ept>文は<bpt i="11" x="11">&lt;c11&gt;</bpt>where<ept i="11">&lt;/c11&gt;</ept>節なしでコンマで区切られた条件リストを使うからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocol Composition<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section of the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Protocols<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter, and in the <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Protocol Composition Type<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> section of the <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Types<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept> chapter, now that protocol composition types can contain a superclass requirement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>議論を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>プロトコル<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章の<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコル合成<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節において、そして<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>型<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>の章の<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>プロトコル合成型<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>の節において更新した、今ではプロトコル合成型はスーパークラス要件を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in the Dynamic Type Expression section to use the new <bpt i="0" x="0">&lt;c0&gt;</bpt>type(of:)<ept i="0">&lt;/c0&gt;</ept> syntax for dynamic type expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「動的型式」の節において議論を更新して、 新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>type(of:)<ept i="0">&lt;/c0&gt;</ept>構文を動的型式に使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of <bpt i="0" x="0">&lt;c0&gt;</bpt>inout<ept i="0">&lt;/c0&gt;</ept> in the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Function Declaration<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section to note that it appears in front of a parameter’s type instead of in front of a parameter’s name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>inout<ept i="0">&lt;/c0&gt;</ept>の議論を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>関数定義<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>の節において更新して、それが現れるのはパラメータの持つ型の前で、バラメータの名前の前でないことを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of Swift language version numbers in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Conditional Compilation Block<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section, now that an optional patch number is allowed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト言語バージョン番号の議論を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>条件比較ブロック<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節において更新した、今では随意のパッチ番号が許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of associated types to use the <bpt i="0" x="0">&lt;c0&gt;</bpt>associatedtype<ept i="0">&lt;/c0&gt;</ept> keyword in the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Associated Types<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> and <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Protocol Associated Type Declaration<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> sections.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連型の議論を<bpt i="0" x="0">&lt;c0&gt;</bpt>associatedtype<ept i="0">&lt;/c0&gt;</ept>キーワードを使うように<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>関連型<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>と<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>プロトコル関連型宣言<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>の節で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of function types in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Function Type<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section now that function argument labels are no longer part of a function’s type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数型の解説を節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>関数型<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>において更新した、今では関数引数ラベルはもはや関数の型の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of function types in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Function Type<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to note that parentheses around the parameter types are required.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数型の解説を節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>関数型<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>において更新して、パラメータ型の周りの丸括弧は必要とされることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of functions in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Functions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter and the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Function Declaration<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> section to note that all parameters get an argument label by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数の解説を章<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>関数<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>と節<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>関数宣言<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>において更新して、すべてのパラメータが引数ラベルを初期状態で受け取ることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of line control statements to use the <bpt i="0" x="0">&lt;c0&gt;</bpt>#sourceLocation(file:line:)<ept i="0">&lt;/c0&gt;</ept> syntax in the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Line Control Statement<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行制御文の解説を<bpt i="0" x="0">&lt;c0&gt;</bpt>#sourceLocation(file:line:)<ept i="0">&lt;/c0&gt;</ept>構文を使うように<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>行制御文<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>の節において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of operators in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Advanced Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter, now that you implement them as type methods instead of as global functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>演算子の議論を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>先進の演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の章において更新した、今ではあなたはそれらをグローバル関数としてではなく型メソッドとして実装するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of optional protocol requirements in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Optional Protocol Requirements<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to clarify that they are used only in code that interoperates with Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルプロトコル要件の解説を節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オプショナルのプロトコル要件<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>において更新して、それらがObjective-Cと相互運用するコードにおいてのみ使用されることを明確にした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of protocol composition types in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocol Composition<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section of the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Protocols<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter and in the <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Protocol Composition Type<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> section of the <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Types<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept> chapter to use the new <bpt i="8" x="8">&lt;c8&gt;</bpt>Protocol1 &amp; Protocol2<ept i="8">&lt;/c8&gt;</ept> syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル合成型の議論を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>プロトコル<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章の<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコル合成<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節において、そして<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>型<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>の章の<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>プロトコル合成型<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>の節において更新して、新しい<bpt i="8" x="8">&lt;c8&gt;</bpt>Protocol1 &amp; Protocol2<ept i="8">&lt;/c8&gt;</ept>構文を使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of protocol extensions in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Extension Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> now that <bpt i="2" x="2">&lt;c2&gt;</bpt>final<ept i="2">&lt;/c2&gt;</ept> isn’t allowed in them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル拡張の議論を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>拡張宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>において更新した、今では<bpt i="2" x="2">&lt;c2&gt;</bpt>final<ept i="2">&lt;/c2&gt;</ept>はそれらにおいて許可されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of the <bpt i="0" x="0">&lt;c0&gt;</bpt>@NSManaged<ept i="0">&lt;/c0&gt;</ept> attribute in the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Declaration Attributes<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section, now that the attribute can be applied to certain instance methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@NSManaged<ept i="0">&lt;/c0&gt;</ept>属性の議論を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>宣言属性<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節において更新した、現在ではこの属性は特定のインスタンスメソッドに適用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of the <bpt i="0" x="0">&lt;c0&gt;</bpt>@noescape<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>@autoclosure<ept i="1">&lt;/c1&gt;</ept> attributes in the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Escaping Closures<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> and <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Autoclosures<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> sections and the <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Attributes<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept> chapter now that they are type attributes, rather than declaration attributes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@noescape<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>@autoclosure<ept i="1">&lt;/c1&gt;</ept>属性の議論を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>脱出クロージャ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>と<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>自動クロージャ<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>の節および<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>属性<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>の章で更新した、今ではそれらは型属性です、宣言属性ではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of the <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept> attribute in the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Declaration Attributes<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section to note that enumerations and enumeration cases can use this attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept>属性についての議論を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>宣言属性<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>において更新して、列挙と列挙ケースがこの属性を使用できることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of the <bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept> attribute in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Declaration Attributes<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>, now that this attribute is inferred in fewer places.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>objc<ept i="0">&lt;/c0&gt;</ept>属性の議論を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>宣言属性<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>において更新した、現在この属性はいくつかの場所で推測されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of weak and unowned references in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Automatic Reference Counting<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>弱いそして非所有参照の議論を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>自動参照カウント<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の章において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the entire book to refer to <bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept> as the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Half-Open Range Operator<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> (rather than the “half-closed range operator”).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>半開範囲演算子<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>と言うように本全体を更新しました（「半完結範囲演算子」ではなしに）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the example in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Type Casting for Any and AnyObject<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> to show how to check for and cast to a function type within a <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>AnyおよびAnyObjectに対する型キャスト<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>での例を更新して、<bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>文内のある関数型について調べてキャストする方法を示しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the information about <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Memberwise Initializers for Structure Types<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> to clarify that the memberwise structure initializer is made available even if a structure’s stored properties do not have default values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>構造体型のためのメンバー関連イニシャライザ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>についての情報が更新されて、メンバー関連の構造体初期化子が、ある構造体の持つ保存プロパティが省略時の値を持たなくてさえも、利用可能にされることをわかりやすくされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the information about <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Mutability of Collections<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> and <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Arrays<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> to reflect the new approach.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい取り組み方を反映するために、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>コレクションの可変性<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>および<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>配列<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>についての情報が更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the rules for constant and constant property declaration and initialization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数と定数プロパティの宣言と初期化についての規則を新しくしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated to <bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept> rather than <bpt i="1" x="1">&lt;c1&gt;</bpt>..<ept i="1">&lt;/c1&gt;</ept> for the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Half-Open Range Operator<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>半開範囲演算子<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>に対して<bpt i="1" x="1">&lt;c1&gt;</bpt>..<ept i="1">&lt;/c1&gt;</ept>ではなく<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>に更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept> to make a range that omits its upper value, and use <bpt i="1" x="1">&lt;c1&gt;</bpt>...<ept i="1">&lt;/c1&gt;</ept> to make a range that includes both values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>をその上側の値を除く範囲を作るために使ってください、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>...<ept i="1">&lt;/c1&gt;</ept>を両方の値を含む範囲を作るために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>AnyObject<ept i="1">&lt;/c1&gt;</ept> only when you explicitly need the behavior and capabilities they provide.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが明白にそれらが提供する挙動と能力を必要とする時にだけ、<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>AnyObject<ept i="1">&lt;/c1&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>UInt<ept i="0">&lt;/c0&gt;</ept> only when you specifically need an unsigned integer type with the same size as the platform’s native word size.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが特にプラットホーム固有のワードサイズと同じ大きさで符号なし整数型を必要とする時にだけ<bpt i="0" x="0">&lt;c0&gt;</bpt>UInt<ept i="0">&lt;/c0&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>\()<ept i="0">&lt;/c0&gt;</ept> to include a floating-point calculation in a string and to include someone’s name in a greeting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>\()<ept i="0">&lt;/c0&gt;</ept>を、浮動小数点計算を文字列に含めるために、そして誰かの名前をある挨拶に含めるために使ってみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>class<ept i="0">&lt;/c0&gt;</ept> followed by the class’s name to create a class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラスを作成するために<bpt i="0" x="0">&lt;c0&gt;</bpt>class<ept i="0">&lt;/c0&gt;</ept>を使ってその後にそのクラスの名前を続けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept> to write a block of code that is executed after all other code in the function, just before the function returns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept>を使って関数の中の全ての他のコードの後で、その関数が返る直前に実行されるひとかたまりのコードを書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>deinit<ept i="0">&lt;/c0&gt;</ept> to create a deinitializer if you need to perform some cleanup before the object is deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクトが割り当て解除される前にあなたがいくらかの掃除をする必要があるならば、デイニシャライザをつくるために、<bpt i="0" x="0">&lt;c0&gt;</bpt>deinit<ept i="0">&lt;/c0&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>enum<ept i="0">&lt;/c0&gt;</ept> to create an enumeration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙をつくるために、<bpt i="0" x="0">&lt;c0&gt;</bpt>enum<ept i="0">&lt;/c0&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>extension<ept i="0">&lt;/c0&gt;</ept> to add functionality to an existing type, such as new methods and computed properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>機能性、例えば新しいメソッドや計算プロパティなどを、既存の型に加えるために、<bpt i="0" x="0">&lt;c0&gt;</bpt>extension<ept i="0">&lt;/c0&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>fileprivate(set)<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>private(set)<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>internal(set)<ept i="2">&lt;/c2&gt;</ept> to change the access level of this synthesized setter in exactly the same way as for an explicit setter in a computed property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>fileprivate(set)<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>private(set)<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>internal(set)<ept i="2">&lt;/c2&gt;</ept>を使って、計算プロパティにおける明示的なセッターと正確に同じ方法で、この総合されたセッターのアクセス水準を変更してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>func<ept i="0">&lt;/c0&gt;</ept> to declare a function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>func<ept i="0">&lt;/c0&gt;</ept>を使うことで、あるひとつの関数を宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>iOS<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>macOS<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>watchOS<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>tvOS<ept i="3">&lt;/c3&gt;</ept> for the platform names, and include the corresponding version numbers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プラットホーム名として<bpt i="0" x="0">&lt;c0&gt;</bpt>iOS<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>macOS<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>watchOS<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>tvOS<ept i="3">&lt;/c3&gt;</ept>を、付随するバージョン番号を含めて使ってください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> to make conditionals, and use <bpt i="2" x="2">&lt;c2&gt;</bpt>for<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>in<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>while<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>repeat<ept i="5">&lt;/c5&gt;</ept>-<bpt i="6" x="6">&lt;c6&gt;</bpt>while<ept i="6">&lt;/c6&gt;</ept> to make loops.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>条件文を作るために<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>を使ってください、そしてループを作るために<bpt i="2" x="2">&lt;c2&gt;</bpt>for<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>in<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>while<ept i="4">&lt;/c4&gt;</ept>、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>repeat<ept i="5">&lt;/c5&gt;</ept>-<bpt i="6" x="6">&lt;c6&gt;</bpt>while<ept i="6">&lt;/c6&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept> to make a constant and <bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept> to make a variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept>を使って定数を作り<bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept>を使って変数を作ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>protocol<ept i="0">&lt;/c0&gt;</ept> to declare a protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコルを宣言するために、<bpt i="0" x="0">&lt;c0&gt;</bpt>protocol<ept i="0">&lt;/c0&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>struct<ept i="0">&lt;/c0&gt;</ept> to create a structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体を作成するために、<bpt i="0" x="0">&lt;c0&gt;</bpt>struct<ept i="0">&lt;/c0&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept> to throw an error and <bpt i="1" x="1">&lt;c1&gt;</bpt>throws<ept i="1">&lt;/c1&gt;</ept> to mark a function that can throw an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるエラーをスローする（投げかける）ために<bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept>を、そしてエラーをスローできる関数に印をつけるために<bpt i="1" x="1">&lt;c1&gt;</bpt>throws<ept i="1">&lt;/c1&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> right before the body to specify a list of requirements—for example, to require the type to implement a protocol, to require two types to be the same, or to require a class to have a particular superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>本文のまさに前に、必要なことのリストを指定するために<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>を使ってください ― 例えば、型があるプロトコルを実装することを要求するために、２つの型が同じものであることを要求するために、またはあるクラスがある特定のスーパークラスを持つことを要求するために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept> to repeat a block of code until a condition changes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>while<ept i="0">&lt;/c0&gt;</ept>を使って、コードのひとかたまり（ブロック）を、ある条件が変化するまで繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="1" x="1">&lt;c1&gt;</bpt>-&gt;<ept i="1">&lt;/c1&gt;</ept> to separate the parameter names and types from the function’s return type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>-&gt;<ept i="1">&lt;/c1&gt;</ept>を使って、パラメーター名とその関数の返す型とを隔ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> to separate the arguments and return type from the body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>を使って、引数および返す型を本文から切り離してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="1" x="1">&lt;c1&gt;</bpt>init<ept i="1">&lt;/c1&gt;</ept> to create one.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうしたものをつくるために、<bpt i="1" x="1">&lt;c1&gt;</bpt>init<ept i="1">&lt;/c1&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use a class-only protocol when the behavior defined by that protocol’s requirements assumes or requires that a conforming type has reference semantics rather than value semantics.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス専用プロトコルを、そのプロトコルの要件によって定義される挙動が想定されるまたは必要とされる時、準拠する型が値意味論ではなく参照意味論を持つ時に、使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use a line control statement to change the source code location used by Swift for diagnostic and debugging purposes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行制御文を使ってスウィフトによって使われるソースコード位置を診断上のそしてデバッグの目的で変更してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use a new key of the appropriate type as the subscript index, and assign a new value of the appropriate type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字インデックスとして適切な型の新しいキーを使ってください、そして適切な型の新しい値を割り当ててください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use a precondition whenever a condition has the potential to be false, but must <bpt i="0" x="0">&lt;e0&gt;</bpt>definitely<ept i="0">&lt;/e0&gt;</ept> be true for your code to continue execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある条件が偽である可能性をもつ、しかし<bpt i="0" x="0">&lt;e0&gt;</bpt>definitely<ept i="0">&lt;/e0&gt;</ept>があなたのコードの実行の継続のためにtrueでなければならない時はいつでも前提条件を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use a single <bpt i="4" x="4">&lt;c4&gt;</bpt>break<ept i="4">&lt;/c4&gt;</ept> statement if you don’t intend to execute any code in the body of a matched case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがマッチされたケース節の本文において何らコードを実行するつもりでないならば、ただ１つ<bpt i="4" x="4">&lt;c4&gt;</bpt>break<ept i="4">&lt;/c4&gt;</ept>文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use a string literal as an initial value for a constant or variable:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列リテラルを定数または変数の初期値として使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use a tuple to make a compound value—for example, to return multiple values from a function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある混成の値を作るために、タプル（一組にしたもの）を使ってください ― 例えば、関数から複数の値を返すために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use a weak reference when the other instance has a shorter lifetime—that is, when the other instance can be deallocated first.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>弱い参照を他のインスタンスがより短い生涯を持つ場合に使ってください — すなわち、他のインスタンスが最初にでアロケートされることが可能である時。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use a wildcard pattern when you don’t care about the values being matched against.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがマッチされている値を気にかけない場合に、ワイルドカード・パターンを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use an initializer expression to construct an instance of a type from that type’s metatype value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザ式を使って、ある型のインスタンスをその型のメタタイプ値から組み立ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use an unowned reference only when you are sure that the reference <bpt i="0" x="0">&lt;e0&gt;</bpt>always<ept i="0">&lt;/e0&gt;</ept> refers to an instance that has not been deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非所有者参照を、その参照が<bpt i="0" x="0">&lt;e0&gt;</bpt>常に<ept i="0">&lt;/e0&gt;</ept>デアロケートされていないインスタンスに言及するとあなたが確信する時にだけ使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use comments to include nonexecutable text in your code, as a note or reminder to yourself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなた自身への注意事項または覚え書きとして、実行可能でないテキストをあなたのコードに含めるために、コメントを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use dot syntax to access the properties and methods of the instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのインスタンスのプロパティおよびメソッドにアクセスするためにドット構文を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use file-private access to hide the implementation details of a specific piece of functionality when those details are used within an entire file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それら詳細があるファイル全体の内部で使われる時に、機能性のある特定部分のそれら実装詳細を隠すために、ファイル外非公開アクセスを使ってください。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use optional chaining to conditionally perform an operation on an implicitly unwrapped optional expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある暗黙的にアンラップされるオプショナルの式に関して演算を条件付きで実行するために、オプショナル連鎖を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use other integer types only when they’re specifically needed for the task at hand, because of explicitly sized data from an external source, or for performance, memory usage, or other necessary optimization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>外部ソース由来の明確に大きさを設定されたデータのために、またはパフォーマンス、メモリ使用、または他の必要な最適化のためになど、目下の作業に特に必要とされる時にだけ、他の整数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use private access to hide the implementation details of a specific piece of functionality when those details are used only within a single declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それら詳細がある単一の宣言内部でのみ使われる時に、機能性のある特定部分のそれら実装詳細を隠すために、非公開アクセスを使ってください。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use statement labels with <bpt i="4" x="4">&lt;c4&gt;</bpt>break<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>continue<ept i="5">&lt;/c5&gt;</ept> statements to be explicit about how you want to change control flow in a loop statement or a <bpt i="6" x="6">&lt;c6&gt;</bpt>switch<ept i="6">&lt;/c6&gt;</ept> statement, as discussed in <bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>Break Statement<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept> and <bpt i="9" x="9">&lt;s9&gt;</bpt><bpt i="10" x="10">&lt;a10&gt;</bpt>Continue Statement<ept i="10">&lt;/a10&gt;</ept><ept i="9">&lt;/s9&gt;</ept> below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>break<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>continue<ept i="5">&lt;/c5&gt;</ept>文で文ラベルを使って、あなたがループ文または<bpt i="6" x="6">&lt;c6&gt;</bpt>switch<ept i="6">&lt;/c6&gt;</ept>文においてどのように制御の流れを変えたいかについて明示してください、下記の<bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>ブレーク文<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>と<bpt i="9" x="9">&lt;s9&gt;</bpt><bpt i="10" x="10">&lt;a10&gt;</bpt>継続文<ept i="10">&lt;/a10&gt;</ept><ept i="9">&lt;/s9&gt;</ept>で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> type for all general-purpose integer constants and variables in your code, even if they’re known to be nonnegative.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>型を全ての一般的な目的のための整数の定数と変数に対してあなたのコードにおいて使ってください、たとえそれらが負数でないことが知られているとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>indices<ept i="0">&lt;/c0&gt;</ept> property to access all of the indices of individual characters in a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>indices<ept i="0">&lt;/c0&gt;</ept>プロパティを使って、ある文字列中の個々の文字のインデックスの全てにアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>init?(rawValue:)<ept i="0">&lt;/c0&gt;</ept> initializer to make an instance of an enumeration from a raw value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>init?(rawValue:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザを使用して、生の値から列挙のインスタンスを作ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>intersection(_:)<ept i="0">&lt;/c0&gt;</ept> method to create a new set with only the values common to both sets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>intersection(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って両方の集合に共通した値だけを持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>isDisjoint(with:)<ept i="0">&lt;/c0&gt;</ept> method to determine whether two sets have no values in common.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>isDisjoint(with:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って２つの集合が共通の値を全く持たないかどうか判定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>isStrictSubset(of:)<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>isStrictSuperset(of:)<ept i="1">&lt;/c1&gt;</ept> methods to determine whether a set is a subset or superset, but not equal to, a specified set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>isStrictSubset(of:)<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>isStrictSuperset(of:)<ept i="1">&lt;/c1&gt;</ept>メソッドを使ってある集合がある指定した集合の下位集合または上位集合、しかし等しくはない、かどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>isSubset(of:)<ept i="0">&lt;/c0&gt;</ept> method to determine whether all of the values of a set are contained in the specified set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>isSubset(of:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使ってある集合のすべての値が指定した集合の値の中に含まれるかどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>isSuperset(of:)<ept i="0">&lt;/c0&gt;</ept> method to determine whether a set contains all of the values in a specified set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>isSuperset(of:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使ってある集合がある指定した集合の値のすべてを含むかどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>startIndex<ept i="0">&lt;/c0&gt;</ept> property to access the position of the first <bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept> of a <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>の最初の<bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept>の位置にアクセスするために<bpt i="0" x="0">&lt;c0&gt;</bpt>startIndex<ept i="0">&lt;/c0&gt;</ept>プロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>subtracting(_:)<ept i="0">&lt;/c0&gt;</ept> method to create a new set with values not in the specified set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>subtracting(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って指定した集合にない値を持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>symmetricDifference(_:)<ept i="0">&lt;/c0&gt;</ept> method to create a new set with values in either set, but not both.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>symmetricDifference(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使ってどちらかの集合にある、しかし両方にではない値を持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>union(_:)<ept i="0">&lt;/c0&gt;</ept> method to create a new set with all of the values in both sets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>union(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って両方の集合のすべての値を持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="1" x="1">&lt;c1&gt;</bpt>stride(from:to:by:)<ept i="1">&lt;/c1&gt;</ept> function to skip the unwanted marks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>stride(from:to:by:)<ept i="1">&lt;/c1&gt;</ept>関数を使って、不必要な印を飛ばしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="2" x="2">&lt;c2&gt;</bpt>rawValue<ept i="2">&lt;/c2&gt;</ept> property to access the raw value of an enumeration case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>rawValue<ept i="2">&lt;/c2&gt;</ept>プロパティを使用して、列挙ケース節の生の値にアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="7" x="7">&lt;c7&gt;</bpt>String<ept i="7">&lt;/c7&gt;</ept> type’s <bpt i="8" x="8">&lt;c8&gt;</bpt>append(_:)<ept i="8">&lt;/c8&gt;</ept> method to append a single <bpt i="9" x="9">&lt;c9&gt;</bpt>Character<ept i="9">&lt;/c9&gt;</ept> value onto the end of a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt>String<ept i="7">&lt;/c7&gt;</ept>型の<bpt i="8" x="8">&lt;c8&gt;</bpt>append(_:)<ept i="8">&lt;/c8&gt;</ept>メソッドを単一の<bpt i="9" x="9">&lt;c9&gt;</bpt>Character<ept i="9">&lt;/c9&gt;</ept>値を文字列の終わりに加えるために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;e0&gt;</bpt>type check operator<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>is<ept i="1">&lt;/c1&gt;</ept>) to check whether an instance is of a certain subclass type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>型確認演算子<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>is<ept i="1">&lt;/c1&gt;</ept>）を使用して、あるインスタンスが特定のサブクラス型であるかどうか調べてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the Boolean <bpt i="0" x="0">&lt;c0&gt;</bpt>isEmpty<ept i="0">&lt;/c0&gt;</ept> property as a shortcut for checking whether the <bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept> property is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブールの<bpt i="0" x="0">&lt;c0&gt;</bpt>isEmpty<ept i="0">&lt;/c0&gt;</ept>プロパティを<bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept>プロパティが<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>と等しいかどうかを調べる近道として使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the classes defined above to create a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> instance, and try to access its <bpt i="1" x="1">&lt;c1&gt;</bpt>numberOfRooms<ept i="1">&lt;/c1&gt;</ept> property as before:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上のクラス定義を使って、新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>インスタンスをつくって、前のようにその<bpt i="1" x="1">&lt;c1&gt;</bpt>numberOfRooms<ept i="1">&lt;/c1&gt;</ept>プロパティにアクセスすることを試みてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the conditional form of the type cast operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>) when you are not sure if the downcast will succeed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがダウンキャストが成功するかどうかよくわからない場合には、条件形式の型キャスト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the forced form of the type cast operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>as!<ept i="0">&lt;/c0&gt;</ept>) only when you are sure that the downcast will always succeed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがダウンキャストが常に成功すると確信する場合には、強制形式の型キャスト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>as!<ept i="0">&lt;/c0&gt;</ept>）を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the half-open range operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>..&lt;<ept i="2">&lt;/c2&gt;</ept>) to include the lower bound but not the upper bound.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>半開範囲演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>..&lt;<ept i="2">&lt;/c2&gt;</ept>）を使って、下方の境界を含めて、しかし上方の境界を含めないようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the ternary conditional operator with care, however.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、注意して三項条件演算子を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the “is equal” operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>) to determine whether two sets contain all of the same values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「同等」演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>）を使って２つの集合がすべて同じ値を含むかどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use these operators to check whether two constants or variables refer to the same single instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの定数または変数が同じ一つのインスタンスに言及するかどうか調べるためにこれらの演算子を使用してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this approach if you need to add a potential failure state to an existing initialization process that does not otherwise fail.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが、起こりうる失敗状況を、その場合にも失敗しない既存の初期化プロセスに加える必要がある場合に、このやり方を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this form of an access-level modifier when you want to specify an access level for the setter of a variable or subscript that’s less than or equal to the access level of the variable or subscript itself, as discussed in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Getters and Setters<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセス水準修飾子のこの形式は、あなたが変数または添え字のセッターにその変数または添え字それ自身のアクセス水準よりもより少ないか等しいアクセス水準を指定することを望むときに使ってください、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ゲッターとセッター<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use this form to access a type as a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値として型にアクセスするために、この形式を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use three double quotes (<bpt i="0" x="0">&lt;c0&gt;</bpt>"""<ept i="0">&lt;/c0&gt;</ept>) for strings that take up multiple lines.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数行にわたる文字列のために３つの二重引用符（<bpt i="0" x="0">&lt;c0&gt;</bpt>"""<ept i="0">&lt;/c0&gt;</ept>）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use variables only for storing values that need to be able to change.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変更できる必要がある値を保存するためにだけ、変数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using <bpt i="0" x="0">&lt;c0&gt;</bpt>try?<ept i="0">&lt;/c0&gt;</ept> lets you write concise error handling code when you want to handle all errors in the same way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>try?<ept i="0">&lt;/c0&gt;</ept>を使うことで、あなたに簡潔なエラー処理コードを書くことを可能にするのは、あなたがすべてのエラーを同じやり方で取り扱いたい時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using ARC in Swift is very similar to the approach described in <bpt i="0" x="0">&lt;e0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Transitioning to ARC Release Notes<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/e0&gt;</ept> for using ARC with Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでのARCの使用は、Objective-CでARCを使うための<bpt i="0" x="0">&lt;e0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Transitioning to ARC Release Notes<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/e0&gt;</ept>で記述される取り組みに非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using Function Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数型を使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using Type Annotations to Constrain an Associated Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型注釈を使って関連型を制約する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using a <bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept> statement for requirements improves the readability of your code, compared to doing the same check with an <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept>文を必要条件に対して使うことは、あなたのコードの可読性を同じ検査確認を<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>文を使って実行するのと比べて向上します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using a generic <bpt i="6" x="6">&lt;c6&gt;</bpt>where<ept i="6">&lt;/c6&gt;</ept> clause lets you add a new requirement to the extension, so that the extension adds the <bpt i="7" x="7">&lt;c7&gt;</bpt>isTop(_:)<ept i="7">&lt;/c7&gt;</ept> method only when the items in the stack are equatable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体<bpt i="6" x="6">&lt;c6&gt;</bpt>where<ept i="6">&lt;/c6&gt;</ept>節を使うことは、あなたに新しい要件をその拡張に追加させます、それで拡張は<bpt i="7" x="7">&lt;c7&gt;</bpt>isTop(_:)<ept i="7">&lt;/c7&gt;</ept>メソッドをスタックの中の項目が同等評価可能なものである時のみ加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using assertions and preconditions isn’t a substitute for designing your code in such a way that invalid conditions are unlikely to arise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>表明と前提条件を使用することは、無効な条件が思いもよらず起こるようなあなたのコードの設計に対する代役ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using explicitly sized types in these situations helps to catch any accidental value overflows and implicitly documents the nature of the data being used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの状況において明示的に大きさを設定された型を使うことは、偶発的な何らかの値のオーバフローを捕えることや、使われているデータの性質を暗黙的に記録することの手助けになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using optionals is similar to using <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> with pointers in Objective-C, but they work for any type, not just classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの使用は、Objective-Cのポインターで<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を使うことに似ています、しかしそれは、ただクラスだけでなく、どんな型のためにでも働きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept> operator to unwrap an optional that has a value of <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> results in a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept>演算子を使って<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>の値を持つあるオプショナルをアンラップすることは、実行時エラーの結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the <bpt i="4" x="4">&lt;c4&gt;</bpt>gameLoop<ept i="4">&lt;/c4&gt;</ept> label makes it clear which control statement should be terminated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>gameLoop<ept i="4">&lt;/c4&gt;</ept>ラベルを使用することは、どの制御文が終了されなければならないかを明確にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using the default integer type in everyday situations means that integer constants and variables are immediately interoperable in your code and will match the inferred type for integer literal values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>日々の状況において初期状態として整数型を使うことは、整数の定数と変数があなたのコードにおいて直接に情報交換が可能で、いろいろな整数のリテラル値に対して推論される型と調和することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using this attribute is equivalent to calling the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSApplicationMain(_:_:)<ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性を使用することは、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSApplicationMain(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数を呼ぶことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using this attribute is equivalent to calling the <bpt i="0" x="0">&lt;c0&gt;</bpt>UIApplicationMain<ept i="0">&lt;/c0&gt;</ept> function and passing this class’s name as the name of the delegate class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この属性を使用することは、<bpt i="0" x="0">&lt;c0&gt;</bpt>UIApplicationMain<ept i="0">&lt;/c0&gt;</ept>関数を呼んで、このクラスの名前を委任クラスの名前として渡すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Valid arguments</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>有効な引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Value Bindings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値束縛</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Value Overflow</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値オーバフロー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Value types (structures and enumerations) do not support inheritance, and so their initializer delegation process is relatively simple, because they can only delegate to another initializer that they provide themselves.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型（構造体と列挙）は、継承をサポートしません、なので、それらのイニシャライザ委任プロセスは比較的単純です、なぜなら、それらがそれら自身で提供する別のイニシャライザに委任できるだけだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Value types are described in <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>Structures and Enumerations Are Value Types<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型は<bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>「構造体と列挙は値型です」<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Value-Binding Pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値束縛パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Value-binding patterns that bind a matched value to the name of a constant begin with the <bpt i="1" x="1">&lt;c1&gt;</bpt>let<ept i="1">&lt;/c1&gt;</ept> keyword; those that bind to the name of variable begin with the <bpt i="2" x="2">&lt;c2&gt;</bpt>var<ept i="2">&lt;/c2&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>マッチした値を定数の名前に束縛する値束縛パターンは、<bpt i="1" x="1">&lt;c1&gt;</bpt>let<ept i="1">&lt;/c1&gt;</ept>キーワードで始まります；変数の名前と縛りつけるものは、<bpt i="2" x="2">&lt;c2&gt;</bpt>var<ept i="2">&lt;/c2&gt;</ept>キーワードで始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Values are never implicitly converted to another type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>なんらかの値が暗黙のうちに別の型に変換されることは決してありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Values in <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> cases can be checked for their inclusion in an interval.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>ケース節における値は、ある区間におけるそれの包含について調べられることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Values in the matrix can be set by passing row and column values into the subscript, separated by a comma:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>行列の中の値は、コンマで区切った行と列の値を添え字に渡すことによって設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variable Declaration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数の宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variable declarations have several forms that declare different kinds of named, mutable values, including stored and computed variables and properties, stored variable and property observers, and static variable properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数宣言はいくつかの形式を持ちます、それらは、保存および計算の変数およびプロパティ、保存の変数およびプロパティのオブザーバー、そして静的変数プロパティを含む、異なる種類の名前をつけられた可変の値を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variables and constants declared in the scope of a <bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept> statement can be accessed only within that scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept>文のスコープ内で宣言される変数と定数は、そのスコープ内でのみアクセスされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variables are always initialized before use.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数は、常に使用前に初期化される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variadic Parameters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変長パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variadic parameters are allowed, subject to the same rules as for normal methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変長パラメータは、許され、普通のメソッドと同じ規則の支配下にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variadic parameters can be used if you name the variadic parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが可変長パラメータに名前をつけるならば、可変長パラメータが使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Version Compatibility</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バージョン互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>We can’t wait to see what you create with it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>私達は、あなたがそれで何をつくるか知るのが待ち切れません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Weak References</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>弱い参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Weak and Unowned References</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>弱いおよび非所有者参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Weak and unowned references enable one instance in a reference cycle to refer to the other instance <bpt i="0" x="0">&lt;e0&gt;</bpt>without<ept i="0">&lt;/e0&gt;</ept> keeping a strong hold on it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>弱いおよび非所有者参照は、ある参照循環の中の１つのインスタンスに、他のインスタンスに言及することをそれに対する強い支配力を持つこと<bpt i="0" x="0">&lt;e0&gt;</bpt>なく<ept i="0">&lt;/e0&gt;</ept>可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Weak references are always of an optional type, and automatically become <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> when the instance they reference is deallocated.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>弱い参照は常にオプショナルの型です、そしてそれが参照をつけるインスタンスが割り当て解除されるとき、自動的に<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Welcome to Swift</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにようこそ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>What about the second and third blocks?</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２番目と３番目のブロックはどうですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>What error do you get?</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、どんなエラーを得ますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>What greeting do you get?</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、どんな挨拶を得ますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>What kind of error do you need to throw so that the error is handled by the first <bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> block?</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーが最初の<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>ブロックによって取り扱われるためには、どんな種類のエラーをあなたはスローする必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt>cinema<ept i="0">&lt;/c0&gt;</ept> was given the current value of <bpt i="1" x="1">&lt;c1&gt;</bpt>hd<ept i="1">&lt;/c1&gt;</ept>, the <bpt i="2" x="2">&lt;e2&gt;</bpt>values<ept i="2">&lt;/e2&gt;</ept> stored in <bpt i="3" x="3">&lt;c3&gt;</bpt>hd<ept i="3">&lt;/c3&gt;</ept> were copied into the new <bpt i="4" x="4">&lt;c4&gt;</bpt>cinema<ept i="4">&lt;/c4&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>cinema<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>hd<ept i="1">&lt;/c1&gt;</ept>の現在の値を与えられたとき、<bpt i="3" x="3">&lt;c3&gt;</bpt>hd<ept i="3">&lt;/c3&gt;</ept>に保存される<bpt i="2" x="2">&lt;e2&gt;</bpt>値<ept i="2">&lt;/e2&gt;</ept>は新しい<bpt i="4" x="4">&lt;c4&gt;</bpt>cinema<ept i="4">&lt;/c4&gt;</ept>インスタンスにコピーされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt>printMathResult(_:_:_:)<ept i="0">&lt;/c0&gt;</ept> is called, it is passed the <bpt i="1" x="1">&lt;c1&gt;</bpt>addTwoInts(_:_:)<ept i="1">&lt;/c1&gt;</ept> function, and the integer values <bpt i="2" x="2">&lt;c2&gt;</bpt>3<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>5<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>printMathResult(_:_:_:)<ept i="0">&lt;/c0&gt;</ept>が呼ばれるとき、それは、<bpt i="1" x="1">&lt;c1&gt;</bpt>addTwoInts(_:_:)<ept i="1">&lt;/c1&gt;</ept>関数、そして整数値<bpt i="2" x="2">&lt;c2&gt;</bpt>3<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>5<ept i="3">&lt;/c3&gt;</ept>を渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt>rememberedDirection<ept i="0">&lt;/c0&gt;</ept> is assigned the value of <bpt i="1" x="1">&lt;c1&gt;</bpt>currentDirection<ept i="1">&lt;/c1&gt;</ept>, it is actually set to a copy of that value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rememberedDirection<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>currentDirection<ept i="1">&lt;/c1&gt;</ept>の値を代入されるとき、それは実際にはその値のコピーに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="3" x="3">&lt;c3&gt;</bpt>residence<ept i="3">&lt;/c3&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>, as in the example above, this optional <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept> will also be <bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept>, to reflect the fact that it was not possible to access <bpt i="7" x="7">&lt;c7&gt;</bpt>numberOfRooms<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>residence<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>のとき、上の例の場合のように、このオプショナルの<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>はまた<bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept>になり、<bpt i="7" x="7">&lt;c7&gt;</bpt>numberOfRooms<ept i="7">&lt;/c7&gt;</ept>にアクセスすることは可能でなかったという事実を反映します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept> statement is followed by the name of a statement label, it ends program execution of the loop, <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept> statement, or <bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept> statement named by that label.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>文に文ラベルの名前が続くとき、それはそのラベルによって指定されるループ、<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>文、または<bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept>文のプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept> statement is not followed by the name of a statement label, it ends program execution of the <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement or the innermost enclosing loop statement in which it occurs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>文に文ラベルの名前が続かないとき、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文またはそれが現れているところの最も内側のそれを囲んでいるループ文のプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a <bpt i="0" x="0">&lt;c0&gt;</bpt>continue<ept i="0">&lt;/c0&gt;</ept> statement is followed by the name of a statement label, it ends program execution of the current iteration of the loop statement named by that label.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>continue<ept i="0">&lt;/c0&gt;</ept>文に文ラベルの名前が続くとき、それは、そのラベルによって指名されるループ文の現在の繰り返しのプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a <bpt i="0" x="0">&lt;c0&gt;</bpt>continue<ept i="0">&lt;/c0&gt;</ept> statement is not followed by the name of a statement label, it ends program execution of the current iteration of the innermost enclosing loop statement in which it occurs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>continue<ept i="0">&lt;/c0&gt;</ept>文に文ラベルの名前が続かないとき、それは、それが現れるところの一番内側のそれを囲んでいるループ文の現在の繰り返しのプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a <bpt i="0" x="0">&lt;c0&gt;</bpt>return<ept i="0">&lt;/c0&gt;</ept> statement is followed by an expression, the value of the expression is returned to the calling function or method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>return<ept i="0">&lt;/c0&gt;</ept>文の後に式が続くとき、式の値は関数またはメソッドを呼んでいるところに返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a <bpt i="0" x="0">&lt;c0&gt;</bpt>return<ept i="0">&lt;/c0&gt;</ept> statement is not followed by an expression, it can be used only to return from a function or method that does not return a value (that is, when the return type of the function or method is <bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>()<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>return<ept i="0">&lt;/c0&gt;</ept>文の後に式が続かないとき、それは値を返さない関数またはメソッド（すなわち、戻り型が<bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>()<ept i="2">&lt;/c2&gt;</ept>である関数またはメソッド）から返るためにだけ使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a Unicode string is written to a text file or some other storage, the Unicode scalars in that string are encoded in one of several Unicode-defined <bpt i="0" x="0">&lt;e0&gt;</bpt>encoding forms<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるUnicode文字列がテキスト・ファイルまたは何か他の記憶装置に書かれるとき、その文字列内のユニコード・スカラーはいくつかのUnicode定義の<bpt i="0" x="0">&lt;e0&gt;</bpt>符号化方式<ept i="0">&lt;/e0&gt;</ept>のうちの１つで符号化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a channel’s audio level is <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>, none of the lights for that channel are lit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>チャンネルの音声のレベルが<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>であるとき、そのチャンネルのための光のどれも点灯されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a class implements an initializer to satisfy a protocol’s initializer requirement, the initializer must be marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept> declaration modifier if the class is not already marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>final<ept i="1">&lt;/c1&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラスがプロトコルのイニシャライザ要件を満たすためにイニシャライザを実装するとき、そのイニシャライザは<bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept>宣言修飾子を使って印される必要が、そのクラスが既に<bpt i="1" x="1">&lt;c1&gt;</bpt>final<ept i="1">&lt;/c1&gt;</ept>宣言修飾子を使って印されていないならば、あります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a closure is the only argument to a function, you can omit the parentheses entirely.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつのクロージャが関数の唯一の引数である時、あなたは丸括弧をすっかり省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a closure’s type is already known, such as the callback for a delegate, you can omit the type of its parameters, its return type, or both.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャの型がすでに知られているとき、例えば委任先のためのコールバックなどでは、あなたはそのパラメータの型、その戻り型、あるいは両方を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a constant declaration occurs in the context of a class or structure declaration, it is considered a <bpt i="0" x="0">&lt;e0&gt;</bpt>constant property<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数宣言がクラスまたは構造体宣言の文脈において起こるとき、それは<bpt i="0" x="0">&lt;e0&gt;</bpt>定数プロパティ<ept i="0">&lt;/e0&gt;</ept>とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a constant declaration occurs in the context of a function or method, it can be initialized later, as long as it is guaranteed to have a value set before the first time its value is read.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数宣言が関数またはメソッドの文脈において現れるとき、それは後で初期化されることができます、それがある値をその値が読み出される最初の時の前に設定されてしまっているよう保証する限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a constant is declared at global scope, it must be initialized with a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数がグローバルなスコープで宣言されるとき、それはひとつの値で初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a declaration is obsoleted, it’s removed from the specified platform or language and can no longer be used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある宣言が廃止された場合は、それは指定されたプラットホームまたは言語から取り除かれます、そしてもはや使用されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a function encounters an error condition, it <bpt i="0" x="0">&lt;e0&gt;</bpt>throws<ept i="0">&lt;/e0&gt;</ept> an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある関数がエラー状態に遭遇するとき、それはあるエラーを<bpt i="0" x="0">&lt;e0&gt;</bpt>スローします<ept i="0">&lt;/e0&gt;</ept>（投げます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a function throws an error, it changes the flow of your program, so it’s important that you can quickly identify places in your code that can throw errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある関数がエラーをスローするとき、それはあなたのプログラムの流れを変えます、そのため重要なのは、あなたがすばやくあなたのコードの中のエラーをスローできる場所を識別することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a member has the same name as a keyword, references to that member don’t need to be escaped with backticks, except when there’s ambiguity between referring to the member and using the keyword—for example, <bpt i="5" x="5">&lt;c5&gt;</bpt>self<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>Type<ept i="6">&lt;/c6&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>Protocol<ept i="7">&lt;/c7&gt;</ept> have special meaning in an explicit member expression, so they must be escaped with backticks in that context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるメンバがあるキーワードと同じ名前を持つ時、そのメンバへの参照はバッククォートでエスケープされる必要はありません、そのメンバへの参照とキーワードの使用の間に曖昧さがある場合を除いては—例えば、<bpt i="5" x="5">&lt;c5&gt;</bpt>self<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>Type<ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>Protocol<ept i="7">&lt;/c7&gt;</ept>は、特別な意味をある明示的なメンバ式の中で持ちます、それでそれらはバッククォートでエスケープされることがその文脈においては必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a protocol composition type contains type aliases, it’s possible for the same protocol to appear more than once in the definitions—duplicates are ignored.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコル合成型が型エイリアスを含む場合、同じプロトコルが１度以上多く定義の中に現れることが可能です — 重複は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a protocol type inherits from other protocols, the set of requirements from those other protocols are aggregated together, and any type that inherits from the current protocol must conform to all of those requirements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル型が他のプロトコルから継承するとき、それらの他のプロトコルからの要件ひとそろいは一緒にまとめられます、そして、現在のプロトコルから継承するどんな型でもそれらの要件の全てに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a protocol type inherits from other protocols, the set of requirements from those other protocols are aggregated, and any type that inherits from the current protocol must conform to all those requirements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコル型が他のプロトコルから継承するとき、それらの他のプロトコルからの要件一式は、ひとまとめにされます、そして現在のプロトコルから継承するどんな型でも、それらの要件の全てに従わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a single else clause is present, an <bpt i="3" x="3">&lt;c3&gt;</bpt>if<ept i="3">&lt;/c3&gt;</ept> statement has the following form:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ただ１つだけのelse節が含まれている時は、<bpt i="3" x="3">&lt;c3&gt;</bpt>if<ept i="3">&lt;/c3&gt;</ept>文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a tuple pattern is used as the pattern in a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> statement or in a variable or constant declaration, it can contain only wildcard patterns, identifier patterns, optional patterns, or other tuple patterns that contain those.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプルパターンが<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>文においてまたは変数や定数宣言においてパターンとして使われるとき、それはワイルドカード・パターン、識別子パターン、オプショナルパターン、またはそれらを含む他のタプルパターンだけを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a type alias is declared with generic parameters, the constraints on those parameters must match exactly the constraints on the existing type’s generic parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型エイリアスが総称体パラメータで宣言されるとき、それらのパラメータ上の制約は厳密に既存の型の持つ総称体パラメータ上の制約に一致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a variable declaration of this form is declared at global scope or the local scope of a function, it is referred to as a <bpt i="0" x="0">&lt;e0&gt;</bpt>computed variable<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この形式の変数の宣言がグローバルなスコープまたは関数のローカルなスコープで宣言されるとき、それは<bpt i="0" x="0">&lt;e0&gt;</bpt>計算変数<ept i="0">&lt;/e0&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a variable declaration of this form is declared at global scope or the local scope of a function, it is referred to as a <bpt i="0" x="0">&lt;e0&gt;</bpt>stored variable<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この形式の変数の宣言がグローバルなスコープまたは関数のローカルなスコープで宣言されるとき、それは<bpt i="0" x="0">&lt;e0&gt;</bpt>保存変数<ept i="0">&lt;/e0&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a variable declaration of this form is declared at global scope or the local scope of a function, the observers are referred to as <bpt i="0" x="0">&lt;e0&gt;</bpt>stored variable observers<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この形式の変数の宣言がグローバルなスコープまたは関数のローカルスコープで宣言されるとき、オブザーバーは<bpt i="0" x="0">&lt;e0&gt;</bpt>保存変数オブザーバー<ept i="0">&lt;/e0&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When accessing the elements in a multidimensional array, the left-most subscript index refers to the element at that index in the outermost array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>多次元配列の要素にアクセスするとき、最も左の添え字インデックスは、最も外側の配列の中のそのインデックスでの要素に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When alternative productions are too long to read easily, they are broken into multiple grammar production rules on new lines.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代替の導出が簡単に読むにはあまりに長いとき、それらが新しい行で複数部分の文法導出規則へとばらされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When an element of a tuple type has a name, that name is part of the type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるタプル型の要素が名前を持つ場合、その名前は型の一部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When an error is thrown, some surrounding piece of code must be responsible for handling the error—for example, by correcting the problem, trying an alternative approach, or informing the user of the failure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるエラーがスローされるとき、なかには周囲のコード部分がエラーを処理することに対して責任を持たなければならないこともあります ― 例えば、問題を訂正すること、代わりの取り組みを試みること、または失敗をユーザに知らせることによって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When an instance of a value type is marked as a constant, so are all of its properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型のインスタンスが定数として印される時は、そのプロパティの全てがそうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When considered in isolation, the nested <bpt i="0" x="0">&lt;c0&gt;</bpt>incrementer()<ept i="0">&lt;/c0&gt;</ept> function might seem unusual:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>切り離して考えたとき、入れ子にされた<bpt i="0" x="0">&lt;c0&gt;</bpt>incrementer()<ept i="0">&lt;/c0&gt;</ept>関数は普通でないものに見えるかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When creating a selector for a property’s getter, the <bpt i="0" x="0">&lt;e0&gt;</bpt>property name<ept i="0">&lt;/e0&gt;</ept> can be a reference to a variable or constant property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティのゲッターのためのセレクタを作成するとき、<bpt i="0" x="0">&lt;e0&gt;</bpt>property name<ept i="0">&lt;/e0&gt;</ept>は変数または定数プロパティへの参照であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When defining a class, the name of the superclass must appear first in the list of type identifiers, followed by any number of protocols the class must conform to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスを定義するとき、スーパークラスの名前は型識別子のリストにおいて最初に現れなければなりません、そしてそのクラスが準拠しなければならないいくらかのプロトコルが続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When defining a protocol, it’s sometimes useful to declare one or more associated types as part of the protocol’s definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルを定義するとき、時々役に立つのは、プロトコルの定義の一部として一つ以上の関連型を宣言することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When it is declared in the context of a class or structure declaration, it is referred to as a <bpt i="1" x="1">&lt;e1&gt;</bpt>stored variable property<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それがクラスまたは構造体宣言の文脈において宣言されるとき、それは<bpt i="1" x="1">&lt;e1&gt;</bpt>保存変数プロパティ<ept i="1">&lt;/e1&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When it is declared in the context of a class or structure declaration, the observers are referred to as <bpt i="1" x="1">&lt;e1&gt;</bpt>property observers<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それがクラスまたは構造体宣言の文脈において宣言されるとき、オブザーバーは<bpt i="1" x="1">&lt;e1&gt;</bpt>プロパティオブザーバー<ept i="1">&lt;/e1&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When it is declared in the context of a class, structure, or extension declaration, it is referred to as a <bpt i="1" x="1">&lt;e1&gt;</bpt>computed property<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それがクラス、構造体、または拡張宣言の文脈において宣言されるとき、それは<bpt i="1" x="1">&lt;e1&gt;</bpt>計算プロパティ<ept i="1">&lt;/e1&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When it is not appropriate to provide a <bpt i="0" x="0">&lt;c0&gt;</bpt>case<ept i="0">&lt;/c0&gt;</ept> for every enumeration case, you can provide a <bpt i="1" x="1">&lt;c1&gt;</bpt>default<ept i="1">&lt;/c1&gt;</ept> case to cover any cases that are not addressed explicitly:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>すべての列挙ケース節に<bpt i="0" x="0">&lt;c0&gt;</bpt>case<ept i="0">&lt;/c0&gt;</ept>を提供することが妥当でないとき、あなたは明確に指定されないあらゆるケース節を扱うために<bpt i="1" x="1">&lt;c1&gt;</bpt>default<ept i="1">&lt;/c1&gt;</ept>の場合を提供することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When one class inherits from another, the inheriting class is known as a <bpt i="1" x="1">&lt;e1&gt;</bpt>subclass<ept i="1">&lt;/e1&gt;</ept>, and the class it inherits from is known as its <bpt i="2" x="2">&lt;e2&gt;</bpt>superclass<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラスが他のものから継承するとき、継承を受けているクラスは<bpt i="1" x="1">&lt;e1&gt;</bpt>サブクラス<ept i="1">&lt;/e1&gt;</ept>として知られています、そして、そこからそれが譲り受ける原点のクラスは、それの<bpt i="2" x="2">&lt;e2&gt;</bpt>スーパークラス<ept i="2">&lt;/e2&gt;</ept>として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When set to <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>, an operator in the corresponding precedence group uses the same grouping rules during optional chaining as the assignment operators from the standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>に設定する場合、対応する優先順位グループの演算子は標準ライブラリ由来のassignment（割り当て）演算子と同じグループ化規則をオプショナル連鎖の間に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When specifying the type annotation for a literal value, the annotation’s type must be a type that can be instantiated from that literal value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるリテラル値に型注釈を指定するとき、その注釈の型は、そのリテラル値からインスタンス化されることができる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When strings are used for raw values, the implicit value for each case is the text of that case’s name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列が生の値のために使われる時、各ケース節のための暗黙的な値は、そのケース節の名前のテキストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When that case is matched by the <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> statement, the <bpt i="4" x="4">&lt;c4&gt;</bpt>break<ept i="4">&lt;/c4&gt;</ept> statement inside the case ends the <bpt i="5" x="5">&lt;c5&gt;</bpt>switch<ept i="5">&lt;/c5&gt;</ept> statement’s execution immediately.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのケース節が<bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>文によってマッチされるとき、ケース節の内側の<bpt i="4" x="4">&lt;c4&gt;</bpt>break<ept i="4">&lt;/c4&gt;</ept>文は直ちに<bpt i="5" x="5">&lt;c5&gt;</bpt>switch<ept i="5">&lt;/c5&gt;</ept>文の実行を終えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the Swift 4 compiler is working with Swift 3 code, it identifies its language version as 3.2.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 4コンパイラがSwift 3コードを扱う場合、それはその言語バージョンを3.2と識別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the audio level is <bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>, all of the lights for that channel are lit.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>音声のレベルが<bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>であるとき、そのチャンネルのための光の全ては点灯されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the enumeration type can be inferred from context, you can omit it (the dot is still required), as described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Enumeration Syntax<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> and <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Implicit Member Expression<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙型が前後関係から推論されることができるとき、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>列挙構文<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>と<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>暗黙のメンバー式<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>で記述されるように、あなたはそれを省略することができます（ドットは依然必要です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the expression on the left-hand side of a binary operator is marked with <bpt i="0" x="0">&lt;c0&gt;</bpt>try<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>try?<ept i="1">&lt;/c1&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt>try!<ept i="2">&lt;/c2&gt;</ept>, that operator applies to the whole binary expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある二項演算子の左手側での式が<bpt i="0" x="0">&lt;c0&gt;</bpt>try<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>try?<ept i="1">&lt;/c1&gt;</ept>、または<bpt i="2" x="2">&lt;c2&gt;</bpt>try!<ept i="2">&lt;/c2&gt;</ept>で印される場合、その演算子は二項式全体に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the function is called, the value of the argument is copied.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数が呼ばれる時、その引数の値はコピー（複製）をつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the function returns, the copy’s value is assigned to the original argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数が戻る時、コピーの値はそのオリジナルの（元の）引数に代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the function returns, your changes to the original are overwritten with the value of the copy.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数が戻る時、オリジナルへのあなたの変更はコピーの値で上書きされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the match succeeds, the value <bpt i="0" x="0">&lt;c0&gt;</bpt>42<ept i="0">&lt;/c0&gt;</ept> is bound (assigned) to the constant name <bpt i="1" x="1">&lt;c1&gt;</bpt>someValue<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>マッチが成功するとき、値<bpt i="0" x="0">&lt;c0&gt;</bpt>42<ept i="0">&lt;/c0&gt;</ept>は、定数の名前の<bpt i="1" x="1">&lt;c1&gt;</bpt>someValue<ept i="1">&lt;/c1&gt;</ept>に縛りつけられます（代入されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the pattern on the left-hand side of a variable or constant declaration is an identifier pattern, the identifier pattern is implicitly a subpattern of a value-binding pattern.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>変数や定数宣言の左側のパターンが識別子パターンであるとき、その識別子パターンは暗黙のうちに値束縛パターンの下位パターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When the second function is called, the message is still printed by the first function, but the returned value is not used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>第二の関数が呼ばれるとき、メッセージは最初の関数によって依然として出力されます、しかし返された値は使われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When this detailed form is used, only the imported symbol (and not the module that declares it) is made available in the current scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この詳細な書式が使われるとき、インポートされたシンボルだけが（そしてそれを宣言するモジュールでなく）、現在のスコープにおいて利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When this simply isn’t feasible (for instance, when the control expression’s type is <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>), you can include a default case to satisfy the requirement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これが単に実行可能でないとき（たとえば、制御式のもつ型が<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>であるとき）、あなたはこの必要条件を満たすために省略時のケース節を含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When two operators compete with each other for their operands, such as in the expression <bpt i="3" x="3">&lt;c3&gt;</bpt>2 + 3 * 5<ept i="3">&lt;/c3&gt;</ept>, the operator with the higher relative precedence binds more tightly to its operands.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つの演算子がそれらの演算数に対して互いと比較される時、例えば式<bpt i="3" x="3">&lt;c3&gt;</bpt>2 + 3 * 5<ept i="3">&lt;/c3&gt;</ept>などで、より高い関係優先順位を持つ演算子はよりきつくそれの演算数に束縛されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When used as the default value of a function or method parameter, the special literal’s value is determined when the default value expression is evaluated at the call site.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数およびメソッドのパラメータの省略時の値として使われる時、特殊リテラルの値は、省略時値式が呼び出し現場で評価される場合は決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When used inside a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement, <bpt i="1" x="1">&lt;c1&gt;</bpt>break<ept i="1">&lt;/c1&gt;</ept> causes the <bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept> statement to end its execution immediately and to transfer control to the code after the <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept> statement’s closing brace (<bpt i="4" x="4">&lt;c4&gt;</bpt>}<ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文の中に使われるとき、<bpt i="1" x="1">&lt;c1&gt;</bpt>break<ept i="1">&lt;/c1&gt;</ept>によって<bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept>文が直ちにその実行を終えて、<bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>文の閉じ波括弧（<bpt i="4" x="4">&lt;c4&gt;</bpt>}<ept i="4">&lt;/c4&gt;</ept>）の後のコードへ制御を移します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When used inside a loop statement, <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept> ends the loop’s execution immediately and transfers control to the code after the loop’s closing brace (<bpt i="1" x="1">&lt;c1&gt;</bpt>}<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループ文の内側で使われるとき、<bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>は直ちにループの実行を終えて、ループの閉じ波括弧（<bpt i="1" x="1">&lt;c1&gt;</bpt>}<ept i="1">&lt;/c1&gt;</ept>）の後のコードへ制御を移します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When working with optional values, you can write <bpt i="0" x="0">&lt;c0&gt;</bpt>?<ept i="0">&lt;/c0&gt;</ept> before operations like methods, properties, and subscripting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの値を扱うとき、あなたはメソッド、プロパティ、そして添え字指定のような演算の前に<bpt i="0" x="0">&lt;c0&gt;</bpt>?<ept i="0">&lt;/c0&gt;</ept>を書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you access a subscript on an optional value through optional chaining, you place the question mark <bpt i="0" x="0">&lt;e0&gt;</bpt>before<ept i="0">&lt;/e0&gt;</ept> the subscript’s brackets, not after.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがオプショナル連鎖を通してオプショナルの値の上で添え字にアクセスするとき、あなたは添え字の角括弧の<bpt i="0" x="0">&lt;e0&gt;</bpt>前に<ept i="0">&lt;/e0&gt;</ept>疑問符を置きます、後ろではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you assign a closure to a property, you are assigning a <bpt i="1" x="1">&lt;e1&gt;</bpt>reference<ept i="1">&lt;/e1&gt;</ept> to that closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがクロージャをプロパティに代入するとき、あなたは<bpt i="1" x="1">&lt;e1&gt;</bpt>参照<ept i="1">&lt;/e1&gt;</ept>をそのクロージャに代入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you assign a default value to a stored property, or set its initial value within an initializer, the value of that property is set directly, without calling any property observers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある保存プロパティに省略時の値を代入する、またはその初期値をイニシャライザの内部で設定するとき、そのプロパティの値は、どんなプロパティオブザーバーも呼び出すことなく、直接に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you call a function that can throw an error, you prepend the <bpt i="1" x="1">&lt;c1&gt;</bpt>try<ept i="1">&lt;/c1&gt;</ept> keyword to the expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがエラーをスローできる関数を呼ぶとき、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>try<ept i="1">&lt;/c1&gt;</ept>キーワードをその式の前に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you call an overloaded generic function or initializer, the compiler uses these constraints to resolve which overloaded function or initializer to invoke.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがオーバーロードされた総称体関数またはイニシャライザを呼ぶとき、コンパイラはこれらの制約を使って、呼び出すことになるオーバーロードされた関数またはイニシャライザはどれか決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you declare a function that takes a closure as one of its parameters, you can write <bpt i="1" x="1">&lt;c1&gt;</bpt>@escaping<ept i="1">&lt;/c1&gt;</ept> before the parameter’s type to indicate that the closure is allowed to escape.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある関数、それのパラメータの１つとしてクロージャをとるものを宣言する時、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>@escaping<ept i="1">&lt;/c1&gt;</ept>をパラメータの型の前に書くことによって、そのクロージャが脱出を許可されるのを指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you declare a generic type, function, subscript, or initializer, you specify the type parameters that the generic type, function, or initializer can work with.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある総称体型、添え字、関数、またはイニシャライザを宣言するとき、あなたはその総称体型、関数、またはイニシャライザが扱うことができる型パラメータを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you define a function, you can optionally define one or more named, typed values that the function takes as input, known as <bpt i="0" x="0">&lt;e0&gt;</bpt>parameters<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある関数を定義するとき、あなたは随意にその関数が入力としてとる、一つ以上の名前をつけられ型付けされた値、<bpt i="0" x="0">&lt;e0&gt;</bpt>パラメータ<ept i="0">&lt;/e0&gt;</ept>として知られるものを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you define a protocol extension, you can specify constraints that conforming types must satisfy before the methods and properties of the extension are available.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがプロトコル拡張を定義するとき、あなたは準拠している型がその拡張のメソッドやプロパティが利用可能になる前に満たさなければならない制約を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you define your own custom classes and structures, it is your responsibility to decide what qualifies as two instances being “equal”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが独自の特注のクラスと構造体を定義するとき、２つのインスタンスが「等しい」とする基準は何かを決めるのはなたの責任です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you define your own structures, classes, and enumerations, it can be useful to provide your own implementations of the standard Swift operators for these custom types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあなた自身の構造体、クラス、そして列挙を定義するとき、標準のスウィフト演算子のあなた自身の実施をそれらあつらえの型のために提供することは役に立つことがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you develop a framework, mark the public-facing interface to that framework as open or public so that it can be viewed and accessed by other modules, such as an app that imports the framework.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがフレームワークを開発する場合、そのフレームワークを開放または公開するために公開向けインタフェースとして印してください、それで、他のモジュール、例えばそのフレームワークをインポートするアプリによってそれが見られてアクセスされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you do so, you must mark the overridden subscript declaration with the <bpt i="2" x="2">&lt;c2&gt;</bpt>override<ept i="2">&lt;/c2&gt;</ept> declaration modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがそうするとき、あなたはオーバーライドされる添え字宣言を<bpt i="2" x="2">&lt;c2&gt;</bpt>override<ept i="2">&lt;/c2&gt;</ept>宣言修飾子で印しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you don’t, Swift will automatically assign the values for you.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがそうしない時は、スウィフトはあなたの代わりに自動的に値を割り当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you extend a generic type, you don’t provide a type parameter list as part of the extension’s definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある総称体型を拡張する時、あなたは型パラメーターリストを拡張の定義の一部として提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you get a substring from a string—for example, using a subscript or a method like <bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(_:)<ept i="0">&lt;/c0&gt;</ept>—the result is an instance of <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Substring<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, not another string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある文字列から下位文字列を得る場合 — 例えば、添え字または<bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(_:)<ept i="0">&lt;/c0&gt;</ept>のようなメソッドを使って — その結果は<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Substring<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>のインスタンスとなります、別の文字列ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you mark a member declaration with the <bpt i="0" x="0">&lt;c0&gt;</bpt>dynamic<ept i="0">&lt;/c0&gt;</ept> modifier, access to that member is always dynamically dispatched using the Objective-C runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがメンバー宣言を<bpt i="0" x="0">&lt;c0&gt;</bpt>dynamic<ept i="0">&lt;/c0&gt;</ept>修飾子で印する時は、そのメンバーへのアクセスは、常に動的にObjective-Cランタイムを使用してディスパッチされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you provide a method, property, or subscript override for a subclass, it is sometimes useful to use the existing superclass implementation as part of your override.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがサブクラスのためにメソッド、プロパティ、または添え字のオーバーライドを提供する時、既存のスーパークラスの実装をあなたのオーバーライドの一部として使うことは時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you use Xcode 9 to build Swift 3 code, most of the new Swift 4 functionality is available.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがXcode 9を使ってSwift 3コードをビルドする場合、新しいSwift 4機能性のほとんどが利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you use a key-path string expression within a class, you can refer to a property of that class by writing just the property name, without the class name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがキーパス文字列式をあるクラス内で使う時、あなたはそのクラスのプロパティを参照することが、クラス名なしで単にそのプロパティ名を書くことによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you use a method or property in an optional requirement, its type automatically becomes an optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがオプショナルの要件の中のメソッドやプロパティを使うとき、それの型は自動的にオプショナルになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you use subscript syntax, the index you specify needs to be valid.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが添え字構文を使う時、あなたが指定するインデックスは有効である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you use the trailing closure syntax, you don’t write the argument label for the closure as part of the function call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが後付クロージャ構文を使うとき、あなたは引数ラベルをそのクロージャに対して関数呼び出しの一部として書きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you work with values whose type is a protocol type, methods outside the protocol definition are not available.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その型があるプロトコル型である値をあなたが扱うとき、そのプロトコル定義の外部のメソッドは利用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you write a simple single-target app, the code in your app is typically self-contained within the app and doesn’t need to be made available outside of the app’s module.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが単純な単一ターゲットアプリを書いている場合、あなたのアプリのコードは概してそのアプリの内部に自身で持っていて、そしてそのアプリのモジュールの外側で利用可能にされることは必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you write a subclass initializer that matches a superclass <bpt i="0" x="0">&lt;e0&gt;</bpt>designated<ept i="0">&lt;/e0&gt;</ept> initializer, you are effectively providing an override of that designated initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがスーパークラスの<bpt i="0" x="0">&lt;e0&gt;</bpt>指定<ept i="0">&lt;/e0&gt;</ept>イニシャライザと一致するあるサブクラス・イニシャライザを書く時、あなたは事実上その指定イニシャライザのオーバーライドを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you write an app with a unit test target, the code in your app needs to be made available to that module in order to be tested.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがユニットテストターゲットを使ってアプリを書く場合、あなたのアプリのコードはテストされるためにそのモジュールに対して利用可能にされる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you write or extend a type to conform to a protocol, you must ensure that the type’s implementation of each protocol requirement has at least the same access level as the type’s conformance to that protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある型をプロトコルに準拠するように書く、または拡張する時は、あなたはその型のもつ各プロトコル要件の実装が少なくともそのプロトコルに対するその型の準拠と同じアクセス水準を持つことを確かにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you write the name of a generic superclass class after the colon, you must include the full name of that generic class, including its generic parameter clause.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがコロンの後に総称体スーパークラスの名前を書く時、あなたはその総称体クラスの名前全体を、それの総称体パラメーター節を含めて書く必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When your source code includes a line break inside of a multiline string literal, that line break also appears in the string’s value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのソースコードがある複数行文字列リテラルの内部に改行を含む場合、その改行はまたその文字列の持つ値の中に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you’re ready to store the result for a longer time, you convert the substring to an instance of <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが結果を長期間にわたって格納しようとする場合、あなたは下位文字列を<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>のインスタンスへと変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you’re working with enumerations that store integer or string raw values, you don’t have to explicitly assign a raw value for each case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが整数や文字列の生の値を格納する列挙を使って作業している時、あなたは各ケース節に生の値を明示的に割り当てる必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Chessboard<ept i="0">&lt;/c0&gt;</ept> instance is created, the closure is executed, and the default value of <bpt i="1" x="1">&lt;c1&gt;</bpt>boardColors<ept i="1">&lt;/c1&gt;</ept> is calculated and returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Chessboard<ept i="0">&lt;/c0&gt;</ept>インスタンスがつくられるときはいつでも、このクロージャは実行されます、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>boardColors<ept i="1">&lt;/c1&gt;</ept>の省略時の値が計算されて、返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever a new instance of the type that the property belongs to is initialized, the closure or function is called, and its return value is assigned as the property’s default value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのプロパティが属している型の新しいインスタンスが初期化されるときはいつでも、そのクロージャまたは関数が呼ばれます、そしてその戻り値はプロパティの省略時の値として代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever an object in the array conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>HasArea<ept i="0">&lt;/c0&gt;</ept> protocol, the optional value returned by the <bpt i="1" x="1">&lt;c1&gt;</bpt>as?<ept i="1">&lt;/c1&gt;</ept> operator is unwrapped with optional binding into a constant called <bpt i="2" x="2">&lt;c2&gt;</bpt>objectWithArea<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列のオブジェクトが<bpt i="0" x="0">&lt;c0&gt;</bpt>HasArea<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するときはいつでも、<bpt i="1" x="1">&lt;c1&gt;</bpt>as?<ept i="1">&lt;/c1&gt;</ept>演算子によって返されるオプショナルの値は、オプショナル束縛によって<bpt i="2" x="2">&lt;c2&gt;</bpt>objectWithArea<ept i="2">&lt;/c2&gt;</ept>と呼ばれる定数へとアンラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever this return value equals <bpt i="4" x="4">&lt;c4&gt;</bpt>7<ept i="4">&lt;/c4&gt;</ept>, the dice roll has become too large and is reset to a value of <bpt i="5" x="5">&lt;c5&gt;</bpt>1<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この戻り値が<bpt i="4" x="4">&lt;c4&gt;</bpt>7<ept i="4">&lt;/c4&gt;</ept>に等しいときはいつでも、そのさいころの目は大きくなり過ぎているので、値<bpt i="5" x="5">&lt;c5&gt;</bpt>1<ept i="5">&lt;/c5&gt;</ept>へ設定し直されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever you assign a function or a closure to a constant or a variable, you are actually setting that constant or variable to be a <bpt i="0" x="0">&lt;e0&gt;</bpt>reference<ept i="0">&lt;/e0&gt;</ept> to the function or closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが関数やクロージャを定数または変数に代入するときはいつでも、あなたは実際はその定数または変数が関数やクロージャへの<bpt i="0" x="0">&lt;e0&gt;</bpt>参照<ept i="0">&lt;/e0&gt;</ept>であると設定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever you define a new class or structure, you effectively define a brand new Swift type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが新しいクラスまたは構造体を定義するときはいつでも、あなたは実質的にまっさらなスウィフト型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever you set the <bpt i="0" x="0">&lt;c0&gt;</bpt>currentSpeed<ept i="0">&lt;/c0&gt;</ept> property of an <bpt i="1" x="1">&lt;c1&gt;</bpt>AutomaticCar<ept i="1">&lt;/c1&gt;</ept> instance, the property’s <bpt i="2" x="2">&lt;c2&gt;</bpt>didSet<ept i="2">&lt;/c2&gt;</ept> observer sets the instance’s <bpt i="3" x="3">&lt;c3&gt;</bpt>gear<ept i="3">&lt;/c3&gt;</ept> property to an appropriate choice of gear for the new speed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="1" x="1">&lt;c1&gt;</bpt>AutomaticCar<ept i="1">&lt;/c1&gt;</ept>インスタンスの<bpt i="0" x="0">&lt;c0&gt;</bpt>currentSpeed<ept i="0">&lt;/c0&gt;</ept>プロパティを設定したときはいつでも、そのプロパティの<bpt i="2" x="2">&lt;c2&gt;</bpt>didSet<ept i="2">&lt;/c2&gt;</ept>オブザーバーは、そのインスタンスの<bpt i="3" x="3">&lt;c3&gt;</bpt>gear<ept i="3">&lt;/c3&gt;</ept>プロパティを新しい速度のために適切な選択に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Where this is appropriate, you access the superclass version of a method, property, or subscript by using the <bpt i="0" x="0">&lt;c0&gt;</bpt>super<ept i="0">&lt;/c0&gt;</ept> prefix:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これがふさわしい所で、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>super<ept i="0">&lt;/c0&gt;</ept>接頭辞を使用することによってスーパークラス版のメソッド、プロパティ、または添え字にアクセスします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Where you believe this is the case, you can try to <bpt i="0" x="0">&lt;e0&gt;</bpt>downcast<ept i="0">&lt;/e0&gt;</ept> to the subclass type with a <bpt i="1" x="1">&lt;e1&gt;</bpt>type cast operator<ept i="1">&lt;/e1&gt;</ept> (<bpt i="2" x="2">&lt;c2&gt;</bpt>as?<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>as!<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこの場合であると思う所で、あなたはサブクラス型への<bpt i="0" x="0">&lt;e0&gt;</bpt>ダウンキャスト<ept i="0">&lt;/e0&gt;</ept>を試みることが<bpt i="1" x="1">&lt;e1&gt;</bpt>型キャスト演算子<ept i="1">&lt;/e1&gt;</ept>（<bpt i="2" x="2">&lt;c2&gt;</bpt>as?<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>as!<ept i="3">&lt;/c3&gt;</ept>）を使ってできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初に評価</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While Loops</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>whileループ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While Statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>while文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>While it is most common for a subscript to take a single parameter, you can also define a subscript with multiple parameters if it is appropriate for your type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>添え字がただ一つのパラメータをとることが最も普通であるけれども、あなたはまた、それがあなたの型に適切ならば、複数のパラメータをもつ添え字を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whitespace and Comments</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空白とコメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whitespace has two uses: to separate tokens in the source file and to help determine whether an operator is a prefix or postfix (see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Operators<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>), but is otherwise ignored.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空白には、２つの用途があります：ソース・ファイルの中のトークンを切り離すため、そして、演算子が接頭辞か接尾辞であるかについて決定することを手伝います（<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>演算子<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください）、それ以外では無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Wildcard Expression</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ワイルドカード式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Wildcard Pattern</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ワイルドカード・パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With a conditional statement, you can use a statement label with the <bpt i="1" x="1">&lt;c1&gt;</bpt>break<ept i="1">&lt;/c1&gt;</ept> statement to end the execution of the labeled statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>条件文では、あなたは文ラベルを<bpt i="1" x="1">&lt;c1&gt;</bpt>break<ept i="1">&lt;/c1&gt;</ept>文とともに使うことで、ラベルをつけられた文の実行を終えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With a loop statement, you can use a statement label with the <bpt i="2" x="2">&lt;c2&gt;</bpt>break<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>continue<ept i="3">&lt;/c3&gt;</ept> statement to end or continue the execution of the labeled statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ループ文では、あなたは文ラベルを<bpt i="2" x="2">&lt;c2&gt;</bpt>break<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>continue<ept i="3">&lt;/c3&gt;</ept>文とともに使うことで、ラベルをつけられた文の実行を終えたり継続したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With an optional tuple type, the entire tuple is optional, not just each individual value within the tuple.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルタプル型では、タプル全体がオプショナルです、単にタプルの内部の個々の値それぞれではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With the exception of the implicit unwrapping behavior, the following two declarations are equivalent:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>暗黙的にアンラップされる挙動を除けば、以下の２つの宣言は等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Within the body of a type method, the implicit <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> property refers to the type itself, rather than an instance of that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある型メソッドの本文内で、暗黙の<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>プロパティはその型自身に言及します、その型のインスタンスではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Without the <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> prefix, Swift would assume that both uses of <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> referred to the method parameter called <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>接頭辞なしでは、スウィフトは両方の<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>の使用が<bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>と呼ばれるメソッドパラメータに言及したものと仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Without this conversion in place, the addition would not be allowed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>適切なこの変換なしでは、この加算は許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Without this requirement, <bpt i="5" x="5">&lt;c5&gt;</bpt>Dictionary<ept i="5">&lt;/c5&gt;</ept> could not tell whether it should insert or replace a value for a particular key, nor would it be able to find a value for a given key that is already in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この要件なしでは、<bpt i="5" x="5">&lt;c5&gt;</bpt>Dictionary<ept i="5">&lt;/c5&gt;</ept>はそれが特定のキーのために値を差し込んだり取り替えたりするべきかどうか伝えることができませんし、それはすでに辞書の中にある指定されたキーに対する値を見つけることもできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Without this type alias, the <bpt i="0" x="0">&lt;c0&gt;</bpt>sum<ept i="0">&lt;/c0&gt;</ept> function would have to refer to the associated type as <bpt i="1" x="1">&lt;c1&gt;</bpt>T.Iterator.Element<ept i="1">&lt;/c1&gt;</ept> instead of <bpt i="2" x="2">&lt;c2&gt;</bpt>T.Element<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この型エイリアスな時では、<bpt i="0" x="0">&lt;c0&gt;</bpt>sum<ept i="0">&lt;/c0&gt;</ept>関数は関連値を<bpt i="1" x="1">&lt;c1&gt;</bpt>T.Iterator.Element<ept i="1">&lt;/c1&gt;</ept>のように参照しなければならないでしょう、<bpt i="2" x="2">&lt;c2&gt;</bpt>T.Element<ept i="2">&lt;/c2&gt;</ept>ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>連鎖の最上部から逆に階層を下って、連鎖の中の各指定イニシャライザは、さらにインスタンスを好みに合わせて作り変える選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working with Characters</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字を扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Wrap the name in parentheses and escape it with a backslash before the opening parenthesis:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>丸括弧にその名前を包んで、始めの括弧の前のバックスラッシュでそれをエスケープします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write a custom argument label before the parameter name, or write <bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept> to use no argument label.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あつらえの引数ラベルはパラメータ名の前に書いてください、または引数ラベルなしで使うためには<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write a function that compares two <bpt i="0" x="0">&lt;c0&gt;</bpt>Rank<ept i="0">&lt;/c0&gt;</ept> values by comparing their raw values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの生の値を比較することによって２つの<bpt i="0" x="0">&lt;c0&gt;</bpt>Rank<ept i="0">&lt;/c0&gt;</ept>の値を比較する関数を記述してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write a name inside angle brackets to make a generic function or type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体である関数や型を作るためには、その名前を山形括弧の中に書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write a question mark (<bpt i="3" x="3">&lt;c3&gt;</bpt>?<ept i="3">&lt;/c3&gt;</ept>) after the type of a value to mark the value as optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある値がオプショナルであると印するために、その値の型の後に疑問符（<bpt i="3" x="3">&lt;c3&gt;</bpt>?<ept i="3">&lt;/c3&gt;</ept>）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write a type annotation by placing a colon after the constant or variable name, followed by a space, followed by the name of the type to use.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数か変数の名前のあとにコロンを置いて、１つの空白に続き、使用する型の名前を続けることによって型注釈を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write an enumeration that conforms to this protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このプロトコルに準拠する列挙を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write an extension for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> type that adds an <bpt i="1" x="1">&lt;c1&gt;</bpt>absoluteValue<ept i="1">&lt;/c1&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>型のために拡張をひとつ書いてください、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>absoluteValue<ept i="1">&lt;/c1&gt;</ept>プロパティを加えるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write an optional binding for an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルの束縛を<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文のために次のように書いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write an underscore (<bpt i="1" x="1">&lt;c1&gt;</bpt>_<ept i="1">&lt;/c1&gt;</ept>) for an argument with no name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>名前のない引数に対しては１つのアンダースコア（<bpt i="1" x="1">&lt;c1&gt;</bpt>_<ept i="1">&lt;/c1&gt;</ept>）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write the <bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept> modifier before the definition of a class initializer to indicate that every subclass of the class must implement that initializer:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept>修飾子をクラス・イニシャライザの定義の前に書いて、そのクラスの全てのサブクラスがそのイニシャライザを実装しなければならないことを示してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write variadic parameters by inserting three period characters (<bpt i="1" x="1">&lt;c1&gt;</bpt>...<ept i="1">&lt;/c1&gt;</ept>) after the parameter’s type name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのパラメータの型名の後に３つのピリオド文字（<bpt i="1" x="1">&lt;c1&gt;</bpt>...<ept i="1">&lt;/c1&gt;</ept>）を書き入れることによって、可変長パラメータを書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Write your code using the model given by copy-in copy-out, without depending on the call-by-reference optimization, so that it behaves correctly with or without the optimization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコードをコピーイン・コピーアウトによって与えられるモデルを使って描いてください、参照呼び出し最適化に依存することなしに、そうすることでそれは最適化があってもなくても正しく振舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writing <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;T: Equatable&gt;<ept i="0">&lt;/c0&gt;</ept> is the same as writing <bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;T&gt; ... where T: Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;T: Equatable&gt;<ept i="0">&lt;/c0&gt;</ept>と書くことは、<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;T&gt; ... where T: Equatable<ept i="1">&lt;/c1&gt;</ept>と書くことと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writing Swift code in a playground lets you experiment with code and see the results immediately, without the overhead of building and running an app.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコードをあるプレイグラウンドの中で書くことで、あなたはコードで実験しその結果を直ちに確かめます、アプリをビルドして実行する手間なしにです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You <bpt i="0" x="0">&lt;e0&gt;</bpt>can<ept i="0">&lt;/e0&gt;</ept> iterate over a one-sided range that omits its final value; however, because the range continues indefinitely, make sure you add an explicit end condition for the loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、それの最後の値を省いた片側範囲に対して反復処理<bpt i="0" x="0">&lt;e0&gt;</bpt>できます<ept i="0">&lt;/e0&gt;</ept>；しかしながら、範囲があいまいに続いていることから、確実にあなたが明示的な終了条件をそのループに対して加えるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You access and modify a dictionary through its methods and properties, or by using subscript syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、辞書へのアクセスおよび修正をそれのメソッドとプロパティを通して、または添え字構文を使うことで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You access and modify a set through its methods and properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは集合へのアクセス及び変更をそれのメソッドとプロパティを通して行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You access and modify a string through its methods and properties, or by using subscript syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは文字列へのアクセスと修正を、それのメソッドとプロパティを通して、または添え字構文を使うことによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You access and modify an array through its methods and properties, or by using subscript syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、そのメソッドとプロパティを通して、または添え字構文を使うことによって、配列にアクセスして修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You access the indices before and after a given index using the <bpt i="0" x="0">&lt;c0&gt;</bpt>index(before:)<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>index(after:)<ept i="1">&lt;/c1&gt;</ept> methods of <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある与えられたインデックスの前後のインデックスに<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>index(before:)<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>index(after:)<ept i="1">&lt;/c1&gt;</ept>メソッドを使ってアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You access the raw value of an enumeration case with its <bpt i="0" x="0">&lt;c0&gt;</bpt>rawValue<ept i="0">&lt;/c0&gt;</ept> property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある列挙ケース節の生の値にそれの<bpt i="0" x="0">&lt;c0&gt;</bpt>rawValue<ept i="0">&lt;/c0&gt;</ept>プロパティでアクセスしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You also cannot use the implicit <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> property, or call any of the instance’s methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、暗黙の<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>プロパティを使うことや、そのインスタンスのメソッドの何も呼ぶことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You also don’t need to write semicolons at the end of every statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、すべての文の終わりにセミコロンを書く必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You also saw how to use weak and unowned references to break these strong reference cycles.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、これらの強い参照循環を壊すために弱いおよび非所有者参照を使う方法を見ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You also use an initializer expression to delegate to the initializer of a superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、スーパークラスのイニシャライザに委任するために、イニシャライザ式を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You always write the <bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept> modifier when overriding a superclass designated initializer, even if your subclass’s implementation of the initializer is a convenience initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはスーパークラスの指定イニシャライザをオーバーライドする時に常に<bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept>修飾子を書きます、そのイニシャライザのあなたのサブクラスでの実装が便宜イニシャライザであるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You apply the <bpt i="0" x="0">&lt;c0&gt;</bpt>IBOutlet<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>IBInspectable<ept i="1">&lt;/c1&gt;</ept> attributes to property declarations of a class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>IBOutlet<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>IBInspectable<ept i="1">&lt;/c1&gt;</ept>属性をクラスのプロパティ宣言に適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You apply the <bpt i="2" x="2">&lt;c2&gt;</bpt>IBAction<ept i="2">&lt;/c2&gt;</ept> attribute to method declarations of a class and the <bpt i="3" x="3">&lt;c3&gt;</bpt>IBDesignable<ept i="3">&lt;/c3&gt;</ept> attribute to class declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="2" x="2">&lt;c2&gt;</bpt>IBAction<ept i="2">&lt;/c2&gt;</ept>属性をクラスのメソッド宣言に、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>IBDesignable<ept i="3">&lt;/c3&gt;</ept>属性をクラス宣言に適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You are free to implement subscripts in the most appropriate way for your particular class or structure’s functionality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなたの特定のクラスまたは構造体の機能性に最も適切な方法で、添え字を実装して結構です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You are not allowed to call a deinitializer yourself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、デイニシャライザをあなた自身で呼び出すことは許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You assign a lower access level by writing <bpt i="1" x="1">&lt;c1&gt;</bpt>fileprivate(set)<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>private(set)<ept i="2">&lt;/c2&gt;</ept>, or <bpt i="3" x="3">&lt;c3&gt;</bpt>internal(set)<ept i="3">&lt;/c3&gt;</ept> before the <bpt i="4" x="4">&lt;c4&gt;</bpt>var<ept i="4">&lt;/c4&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>subscript<ept i="5">&lt;/c5&gt;</ept> introducer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、より低いアクセス水準を割り当てることを、<bpt i="1" x="1">&lt;c1&gt;</bpt>fileprivate(set)<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>private(set)<ept i="2">&lt;/c2&gt;</ept>、または<bpt i="3" x="3">&lt;c3&gt;</bpt>internal(set)<ept i="3">&lt;/c3&gt;</ept>を<bpt i="4" x="4">&lt;c4&gt;</bpt>var<ept i="4">&lt;/c4&gt;</ept>または<bpt i="5" x="5">&lt;c5&gt;</bpt>subscript<ept i="5">&lt;/c5&gt;</ept>導入子の前に書くことによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You call an <bpt i="0" x="0">&lt;c0&gt;</bpt>init?<ept i="0">&lt;/c0&gt;</ept> failable initializer in the same way that you call a nonfailable initializer, except that you must deal with the optionality of the result.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは失敗できるイニシャライザ<bpt i="0" x="0">&lt;c0&gt;</bpt>init?<ept i="0">&lt;/c0&gt;</ept>を、オプショナルの結果を処理する必要があることを除き、失敗できないイニシャライザを呼び出すのと同じ方法で呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You call instance methods with the same dot syntax as properties:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、インスタンスメソッドをプロパティと同じドット構文を使って呼び出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You call the <bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:)<ept i="0">&lt;/c0&gt;</ept> function by passing it a <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> value after the <bpt i="2" x="2">&lt;c2&gt;</bpt>person<ept i="2">&lt;/c2&gt;</ept> argument label, such as <bpt i="3" x="3">&lt;c3&gt;</bpt>greet(person: "Anna")<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:)<ept i="0">&lt;/c0&gt;</ept>関数をそれに<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値を<bpt i="2" x="2">&lt;c2&gt;</bpt>person<ept i="2">&lt;/c2&gt;</ept>引数ラベルの後で渡すことによって、例えば<bpt i="3" x="3">&lt;c3&gt;</bpt>greet(person: "Anna")<ept i="3">&lt;/c3&gt;</ept>のように呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You call the <bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:alreadyGreeted:)<ept i="0">&lt;/c0&gt;</ept> function by passing it both a <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> argument value labeled <bpt i="2" x="2">&lt;c2&gt;</bpt>person<ept i="2">&lt;/c2&gt;</ept> and a <bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept> argument value labeled <bpt i="4" x="4">&lt;c4&gt;</bpt>alreadyGreeted<ept i="4">&lt;/c4&gt;</ept> in parentheses, separated by commas.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:alreadyGreeted:)<ept i="0">&lt;/c0&gt;</ept>関数をそれに<bpt i="2" x="2">&lt;c2&gt;</bpt>person<ept i="2">&lt;/c2&gt;</ept>でラベルした<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>引数値と<bpt i="4" x="4">&lt;c4&gt;</bpt>alreadyGreeted<ept i="4">&lt;/c4&gt;</ept>でラベルした<bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept>引き数値を両方とも丸括弧内に、コンマで区切って渡すことで呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You call the <bpt i="1" x="1">&lt;c1&gt;</bpt>UINavigationController<ept i="1">&lt;/c1&gt;</ept> class <bpt i="2" x="2">&lt;c2&gt;</bpt>pushViewController(_:animated:)<ept i="2">&lt;/c2&gt;</ept> method to add (or push) a view controller on to the navigation stack, and its <bpt i="3" x="3">&lt;c3&gt;</bpt>popViewControllerAnimated(_:)<ept i="3">&lt;/c3&gt;</ept> method to remove (or pop) a view controller from the navigation stack.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>UINavigationController<ept i="1">&lt;/c1&gt;</ept>クラスの<bpt i="2" x="2">&lt;c2&gt;</bpt>pushViewController(_:animated:)<ept i="2">&lt;/c2&gt;</ept>メソッドをナビゲーション・スタックにビュー・コントローラを加える（またはプッシュする）ために、そしてそれの<bpt i="3" x="3">&lt;c3&gt;</bpt>popViewControllerAnimated(_:)<ept i="3">&lt;/c3&gt;</ept>メソッドをナビゲーション・スタックからビュー・コントローラを取り除くために呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can <bpt i="0" x="0">&lt;e0&gt;</bpt>decompose<ept i="0">&lt;/e0&gt;</ept> a tuple’s contents into separate constants or variables, which you then access as usual:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはタプルの内容を個々の定数または変数に<bpt i="0" x="0">&lt;e0&gt;</bpt>分解<ept i="0">&lt;/e0&gt;</ept>することができます。そして、あなたはそれから通常通りそれにアクセスします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can access a UTF-16 representation of a <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> by iterating over its <bpt i="1" x="1">&lt;c1&gt;</bpt>utf16<ept i="1">&lt;/c1&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>のUTF-16叙述に、それの<bpt i="1" x="1">&lt;c1&gt;</bpt>utf16<ept i="1">&lt;/c1&gt;</ept>プロパティのすべてに渡って繰り返していくことによってアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can access a UTF-8 representation of a <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> by iterating over its <bpt i="1" x="1">&lt;c1&gt;</bpt>utf8<ept i="1">&lt;/c1&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>のUTF-８叙述に、それの<bpt i="1" x="1">&lt;c1&gt;</bpt>utf8<ept i="1">&lt;/c1&gt;</ept>プロパティのすべてに渡って繰り返していくことによってアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can access a Unicode scalar representation of a <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> value by iterating over its <bpt i="1" x="1">&lt;c1&gt;</bpt>unicodeScalars<ept i="1">&lt;/c1&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>のUnicodeスカラー叙述に、それの<bpt i="1" x="1">&lt;c1&gt;</bpt>unicodeScalars<ept i="1">&lt;/c1&gt;</ept>プロパティのすべてに渡って繰り返していくことによってアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can access the individual <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> values for a <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> by iterating over the string with a <bpt i="2" x="2">&lt;c2&gt;</bpt>for<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>in<ept i="3">&lt;/c3&gt;</ept> loop:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>の個々の<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>値に<bpt i="2" x="2">&lt;c2&gt;</bpt>for<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>in<ept i="3">&lt;/c3&gt;</ept>ループでその文字列の初めから終わりまで反復することによってアクセスできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can access the minimum and maximum values of each integer type with its <bpt i="0" x="0">&lt;c0&gt;</bpt>min<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>max<ept i="1">&lt;/c1&gt;</ept> properties:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、その<bpt i="0" x="0">&lt;c0&gt;</bpt>min<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>max<ept i="1">&lt;/c1&gt;</ept>プロパティで各整数型の最小と最大の値を得ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can access the properties of an instance using <bpt i="0" x="0">&lt;e0&gt;</bpt>dot syntax<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;e0&gt;</bpt>ドット構文<ept i="0">&lt;/e0&gt;</ept>を使ってインスタンスのプロパティにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can add a new item into a set by calling the set’s <bpt i="0" x="0">&lt;c0&gt;</bpt>insert(_:)<ept i="0">&lt;/c0&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは新しい項目を集合に加えることが集合の<bpt i="0" x="0">&lt;c0&gt;</bpt>insert(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを呼ぶことによって行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can add a new item to a dictionary with subscript syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、添え字構文を使って辞書に新しい項目を付け加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can add a new item to the end of an array by calling the array’s <bpt i="0" x="0">&lt;c0&gt;</bpt>append(_:)<ept i="0">&lt;/c0&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、配列の<bpt i="0" x="0">&lt;c0&gt;</bpt>append(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを呼ぶことによって配列の終わりに新しい項目を加えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can add a type annotation to an associated type in a protocol, to require that conforming types satisfy the constraints described by the type annotation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、型注釈を関連型へとプロトコルの中で加えることで、準拠する型が型注釈によって記述される制約を満たすことを要求できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can add any number of additional branches using <bpt i="1" x="1">&lt;c1&gt;</bpt>#elseif<ept i="1">&lt;/c1&gt;</ept> clauses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、任意の数の追加の分岐を加えることが<bpt i="1" x="1">&lt;c1&gt;</bpt>#elseif<ept i="1">&lt;/c1&gt;</ept>を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can add property observers to any stored properties you define, except for lazy stored properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、プロパティオブザーバーをあなたが定義するどんな保存プロパティにでも加えることができます、しかし遅延保存プロパティは除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can add property observers to any stored property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、プロパティオブザーバーをどんな保存プロパティにでも加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can add protocol conformance to a previously declared type by adopting the protocol in an extension declaration of that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、プロトコル準拠を以前に宣言された型に加えることが、その型の拡張宣言においてそのプロトコルを採用することによってできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also add a final additional branch using an <bpt i="2" x="2">&lt;c2&gt;</bpt>#else<ept i="2">&lt;/c2&gt;</ept> clause.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、最後の追加の分岐を<bpt i="2" x="2">&lt;c2&gt;</bpt>#else<ept i="2">&lt;/c2&gt;</ept>節を使って加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also add new characteristics to the subclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、新しい特徴をサブクラスに加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Overriding Property Observers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、プロパティオブザーバーをあらゆる継承されたプロパティ（保存されるか、計算されるかに関係なく）にでも加えることが、サブクラスの内部でプロパティをオーバーライドすることによって、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロパティオブザーバーのオーバーライド<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、プロパティオブザーバーを、どんな継承されたプロパティにでも（保存されるか、計算されるかに関係なく）、サブクラス内でそのプロパティをオーバーライドすることによって加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also aggregate the conformance requirements of multiple protocols using protocol composition types, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocol Composition Type<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Protocol Composition<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコル合成型<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>プロトコル合成<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されるように、複数のプロトコルの準拠要件をひとまとめにすることがプロトコル合成（コンポジション）型を使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also append a <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> value to an existing <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> variable with the addition assignment operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>+=<ept i="2">&lt;/c2&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、ある<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>値を既存の<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>変数に加算代入演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>+=<ept i="2">&lt;/c2&gt;</ept>）を使って追加することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also attempt to set a property’s value through optional chaining:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまたプロパティの値をオプショナル連鎖を通して設定することを試みることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also bind an arbitrary expression to a named value in a capture list.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、ある任意の式を、キャプチャリストの中の名前をつけられた値と結び付けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also call the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>preconditionFailure(_:file:line:)<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function to indicate that a failure has occurred—for example, if the default case of a switch was taken, but all valid input data should have been handled by one of the switch’s other cases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>preconditionFailure(_:file:line:)<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を呼び出して失敗がすでに起こっていることを示すことができます — 例えば、あるスイッチ文の省略時のケース節が取られた、しかし全ての有効な入力データがそのスイッチ文の他のケース節の１つによって取り扱われてしまっている場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also check whether a one-sided range contains a particular value, as shown in the code below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、以下のコードで示すように、片側範囲が特定の値を含むかどうか調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also compare tuples that have the same number of values, as long as each of the values in the tuple can be compared.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、同数の値を持つタプルを比較することが、そのタプルの中の値が比較されることができる限りは、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also declare a stored variable or property with <bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept> observers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、<bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>didSet<ept i="1">&lt;/c1&gt;</ept>オブザーバーをもつ保存変数やプロパティを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also declare properties in the context of a protocol declaration, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocol Property Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコルプロパティ宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、あなたはまた、プロトコル宣言の文脈において、プロパティを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also declare subscripts in the context of a protocol declaration, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocol Subscript Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコル添え字宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、あなたはまた、プロトコル宣言の文脈において添え字を宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、ある便宜イニシャライザを定義して、そのクラスのインスタンスを特定の使用状況のために作成したり、値型を入力することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also define custom operators that begin with a dot (<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、１つのドット（<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>）で始まるあつらえの演算子を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also define functions inside the bodies of other functions, known as <bpt i="1" x="1">&lt;e1&gt;</bpt>nested functions<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、他の関数の本体の内側に関数を、<bpt i="1" x="1">&lt;e1&gt;</bpt>入れ子にされた関数<ept i="1">&lt;/e1&gt;</ept>として知られるものを、定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also define methods that are called on the type itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、型それ自体の上で呼ばれるメソッドを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also define properties that belong to the type itself, not to any one instance of that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、その型のどれかひとつのインスタンスにではなく、型それ自体に属しているいくらかのプロパティを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also delegate from <bpt i="4" x="4">&lt;c4&gt;</bpt>init<ept i="4">&lt;/c4&gt;</ept> to <bpt i="5" x="5">&lt;c5&gt;</bpt>init!<ept i="5">&lt;/c5&gt;</ept>, although doing so will trigger an assertion if the <bpt i="6" x="6">&lt;c6&gt;</bpt>init!<ept i="6">&lt;/c6&gt;</ept> initializer causes initialization to fail.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、<bpt i="4" x="4">&lt;c4&gt;</bpt>init<ept i="4">&lt;/c4&gt;</ept>から<bpt i="5" x="5">&lt;c5&gt;</bpt>init!<ept i="5">&lt;/c5&gt;</ept>へ委任することができます、もっともそうすることは、<bpt i="6" x="6">&lt;c6&gt;</bpt>init!<ept i="6">&lt;/c6&gt;</ept>イニシャライザが初期化失敗の原因となるならば、ある表明を引き起こすことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also extend a generic type to conditionally add functionality, as described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Extensions with a Generic Where Clause<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた総称体型を拡張することで条件付きの機能性を追加することができます、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ひとつの総称体where節を持つ拡張<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also initialize a dictionary with a <bpt i="0" x="0">&lt;e0&gt;</bpt>dictionary literal<ept i="0">&lt;/e0&gt;</ept>, which has a similar syntax to the array literal seen earlier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、<bpt i="0" x="0">&lt;e0&gt;</bpt>辞書リテラル<ept i="0">&lt;/e0&gt;</ept>で辞書を初期化することができます、それは以前に見た配列リテラルに似ている構文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also initialize a set with an array literal, as a shorthand way to write one or more values as a set collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、１つ以上の値を集合コレクションとして書くための省略法として、集合を配列リテラルを使って初期化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also initialize an array with an <bpt i="0" x="0">&lt;e0&gt;</bpt>array literal<ept i="0">&lt;/e0&gt;</ept>, which is a shorthand way to write one or more values as an array collection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた<bpt i="0" x="0">&lt;e0&gt;</bpt>配列リテラル<ept i="0">&lt;/e0&gt;</ept>を使って配列を初期化することができます、それは一つ以上の値を配列コレクションとして書くための短縮形の方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also iterate over a dictionary to access its key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、辞書の端から端まで繰り返して、その「キーと値」の対にアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also make the generic <bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept> type conform to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept> protocol:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept>型を<bpt i="1" x="1">&lt;c1&gt;</bpt>Container<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠させることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also modify the inherited <bpt i="0" x="0">&lt;c0&gt;</bpt>currentSpeed<ept i="0">&lt;/c0&gt;</ept> property of a <bpt i="1" x="1">&lt;c1&gt;</bpt>Bicycle<ept i="1">&lt;/c1&gt;</ept> instance, and query the instance’s inherited <bpt i="2" x="2">&lt;c2&gt;</bpt>description<ept i="2">&lt;/c2&gt;</ept> property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、ある<bpt i="1" x="1">&lt;c1&gt;</bpt>Bicycle<ept i="1">&lt;/c1&gt;</ept>インスタンスの継承された<bpt i="0" x="0">&lt;c0&gt;</bpt>currentSpeed<ept i="0">&lt;/c0&gt;</ept>プロパティを変更することが出来ます、そしてそのインスタンスの持つ継承された<bpt i="2" x="2">&lt;c2&gt;</bpt>description<ept i="2">&lt;/c2&gt;</ept>プロパティについて問い合わせることが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also name the elements of a tuple type and use those names to refer to the values of the individual elements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、タプル型の要素に名をつけることができて、それらの名前を個々の要素の値に言及するために使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also optionally define a type of value that the function will pass back as output when it is done, known as its <bpt i="1" x="1">&lt;e1&gt;</bpt>return type<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、随意にその関数が実行を終えたとき出力として逆に渡す値の型、その<bpt i="1" x="1">&lt;e1&gt;</bpt>戻り型<ept i="1">&lt;/e1&gt;</ept>として知られるものを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also override a subscript declaration inherited from a superclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、スーパークラスから継承した添え字宣言をオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also replace a type parameter with a type argument that is itself a specialized version of a generic type (provided it satisfies the appropriate constraints and requirements).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、型パラメータを、それ自身が総称体型の特殊化版である型引数と置き換えることができます（それが適切な制約と要件を満たすという条件で）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also retrieve an iterable collection of a dictionary’s keys or values by accessing its <bpt i="0" x="0">&lt;c0&gt;</bpt>keys<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>values<ept i="1">&lt;/c1&gt;</ept> properties:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、その<bpt i="0" x="0">&lt;c0&gt;</bpt>keys<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>values<ept i="1">&lt;/c1&gt;</ept>プロパティにアクセスすることによって、ある辞書のキーまたは値からなる、for-in文で繰り返し可能なコレクション（集まり）を取り出すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also set and modify the initial value for a stored property during initialization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、初期化のときに保存プロパティに対して最初の値を設定および修正することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also specify the requirement that two types be identical, using the <bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>演算子を使用して、２つの型が同一であるという要件を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loops with numeric ranges.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループを数値範囲とともに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use a declaration to extend the behavior of an existing named type and to import symbols into your program that are declared elsewhere.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、ある宣言を使うことで、既存の名前付きの型の振るまいを拡張することや、どこかほかで宣言されるシンボルをあなたのプログラムへインポートすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use a generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clause as part of an extension.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたまた、総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節を拡張の一部として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use a raw value to find a corresponding case, if there is one, by calling the enumeration’s failable initializer, as in <bpt i="5" x="5">&lt;c5&gt;</bpt>ExampleEnum(rawValue: 5)<ept i="5">&lt;/c5&gt;</ept>, which returns an optional case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた生の値を使用して対応するケース節を見つけることが、もしそれが１つあるならば、列挙の持つ失敗できるイニシャライザを呼ぶことによって可能です、例えば<bpt i="5" x="5">&lt;c5&gt;</bpt>ExampleEnum(rawValue: 5)<ept i="5">&lt;/c5&gt;</ept>のように、それはオプショナルのケース節を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use an asterisk (<bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept>) to indicate the availability of the declaration on all of the platform names listed above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、アスタリスク（<bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept>）を使って上でリストされるプラットホーム名の全てでその宣言の有効性を指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use an implicitly unwrapped optional with optional binding, to check and unwrap its value in a single statement:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、暗黙的にアンラップされるオプショナルをオプショナル束縛とともに使うことができます、一つの文でその値を確認してアンラップするためには：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use dot syntax to assign a new value to a variable property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、新しい値を変数プロパティに代入するためにドット構文を使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use optional chaining and optional binding to conditionally perform an operation on an optional expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまたオプショナル連鎖とオプショナル束縛を使って、あるオプショナルの式に関して演算を条件付きで実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use optional chaining to call a method that returns a value of optional type, and to chain on that method’s return value if needed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまたオプショナル連鎖を使って、オプショナルの型の値を返すメソッドを呼び出すこと、そして必要ならば、そのメソッドの戻り値の上で連鎖することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use strings or floating-point numbers as the raw type of an enumeration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、列挙の生の型として、文字列または浮動小数点数を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use strings to insert constants, variables, literals, and expressions into longer strings, in a process known as string interpolation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた文字列を、文字列補間として知られているやり方で、定数、変数、リテラル、および式をより長い文字列に差し入れるために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use subscript syntax to change a range of values at once, even if the replacement set of values has a different length than the range you are replacing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、添え字構文を使って、ある範囲の値を一度に変えることができます、たとえ代替の値一式があなたが置き換えている範囲と異なる長さを持つとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use subscript syntax to change the value associated with a particular key:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、添え字構文を特定のキーと結びつけられる値を変えるために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use subscript syntax to retrieve a value from the dictionary for a particular key.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、添え字構文を特定のキーに対する値を辞書から取り出すために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use type casting to check whether a type conforms to a protocol, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Checking for Protocol Conformance<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコル準拠の確認<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、その型があるプロトコルに準拠しているどうか調べるために型キャストを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also write <bpt i="0" x="0">&lt;c0&gt;</bpt>indirect<ept i="0">&lt;/c0&gt;</ept> before the beginning of the enumeration, to enable indirection for all of the enumeration’s cases that need it:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、列挙の始まりの前に<bpt i="0" x="0">&lt;c0&gt;</bpt>indirect<ept i="0">&lt;/c0&gt;</ept>を書くことができます、それで間接参照がその列挙のそれを必要とするケース節のすべてに可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also write the type of a dictionary in shorthand form as <bpt i="0" x="0">&lt;c0&gt;</bpt>[Key: Value]<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、辞書の型を<bpt i="0" x="0">&lt;c0&gt;</bpt>[Key: Value]<ept i="0">&lt;/c0&gt;</ept>のような省略形で書くこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also write the type of an array in shorthand form as <bpt i="2" x="2">&lt;c2&gt;</bpt>[Element]<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、短縮形形式で配列の型を<bpt i="2" x="2">&lt;c2&gt;</bpt>[Element]<ept i="2">&lt;/c2&gt;</ept>のように書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can append a <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> value to a <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> variable with the <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> type’s <bpt i="3" x="3">&lt;c3&gt;</bpt>append()<ept i="3">&lt;/c3&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>値を<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>変数にその<bpt i="2" x="2">&lt;c2&gt;</bpt>String型<ept i="2">&lt;/c2&gt;</ept>のもつ<bpt i="3" x="3">&lt;c3&gt;</bpt>append()<ept i="3">&lt;/c3&gt;</ept>メソッドを使って追加することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can apply a declaration attribute to declarations only.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、宣言属性を宣言だけに適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can apply multiple <bpt i="0" x="0">&lt;c0&gt;</bpt>available<ept i="0">&lt;/c0&gt;</ept> attributes on a single declaration to specify the declaration’s availability on different platforms and different versions of Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、複数の<bpt i="0" x="0">&lt;c0&gt;</bpt>available<ept i="0">&lt;/c0&gt;</ept>属性を単一の宣言上に適用することで、その宣言の利用可能性を異なるプラットホームおよび異なるバージョンのスウィフトに関して指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can apply the <bpt i="0" x="0">&lt;c0&gt;</bpt>optional<ept i="0">&lt;/c0&gt;</ept> modifier only to protocols that are marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>optional<ept i="0">&lt;/c0&gt;</ept>修飾子を<bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept>属性で印されるプロトコルだけに適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can apply type attributes to types only.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、型属性を型だけに適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can assign a <bpt i="0" x="0">&lt;c0&gt;</bpt>Residence<ept i="0">&lt;/c0&gt;</ept> instance to <bpt i="1" x="1">&lt;c1&gt;</bpt>john.residence<ept i="1">&lt;/c1&gt;</ept>, so that it no longer has a <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>john.residence<ept i="1">&lt;/c1&gt;</ept>に<bpt i="0" x="0">&lt;c0&gt;</bpt>Residence<ept i="0">&lt;/c0&gt;</ept>インスタンスを代入することができます、それによってそれはもはや<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>値を持ちません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can assign a value to a constant property at any point during initialization, as long as it is set to a definite value by the time initialization finishes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、それが初期化終了時にある明確な値に設定されさえするならば、ある値を初期化の間のどの時点ででも定数プロパティに割り当てることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can assign specific access levels to individual types (classes, structures, and enumerations), as well as to properties, methods, initializers, and subscripts belonging to those types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは特定のアクセス水準を個々の型（クラス、構造体、および列挙）、それだけでなくそれらの型に属しているプロパティ、メソッド、イニシャライザ、そして添え字に、個別に割り当てることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can be confident that the string you are passed won’t be modified unless you modify it yourself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなたが渡される文字列があなたが自身でそれを修正しない限り修正されないことを確信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can call <bpt i="1" x="1">&lt;c1&gt;</bpt>self.init<ept i="1">&lt;/c1&gt;</ept> only from within an initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="1" x="1">&lt;c1&gt;</bpt>self.init<ept i="1">&lt;/c1&gt;</ept>をイニシャライザ内からだけ呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can call such functions with either a <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>Substring<ept i="5">&lt;/c5&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、そのような関数を<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>または<bpt i="5" x="5">&lt;c5&gt;</bpt>Substring<ept i="5">&lt;/c5&gt;</ept>値で呼出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can call the <bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:)<ept i="0">&lt;/c0&gt;</ept> function multiple times with different input values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、異なる入力値を使って<bpt i="0" x="0">&lt;c0&gt;</bpt>greet(person:)<ept i="0">&lt;/c0&gt;</ept>関数を複数回呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can call the <bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept> function with two variables of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> to swap their values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept>関数を、それらの値を交換する２つの<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>型の変数で呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can call the <bpt i="7" x="7">&lt;c7&gt;</bpt>type(of:)<ept i="7">&lt;/c7&gt;</ept> function with an instance of a type to access that instance’s dynamic, runtime type as a value, as the following example shows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある型のインスタンスを使って<bpt i="7" x="7">&lt;c7&gt;</bpt>type(of:)<ept i="7">&lt;/c7&gt;</ept>関数を呼び出して、そのインスタンスの持つ動的な、実行時の型にひとつの値としてアクセスできます、以下の例で示すように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can call this function to swap the values in two <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept> variables:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、２つの<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>変数の値を交換するためにこの関数を呼ぶことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can chain multiple <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statements together to consider additional clauses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、複数の<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文を一緒につないで追加の条項を考慮することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can change the value of an existing variable to another value of a compatible type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、既存の変数の値を、別の互換性を持つ型の値に変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can check for the existence of a value in the weak reference, just like any other optional value, and you will never end up with a reference to an invalid instance that no longer exists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他のあらゆるオプショナルの値と同じように、あなたは弱い参照の中の値の存在について調べることができます、そして、あなたは既に存在しない無効なインスタンスへの参照に至ることは決してありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can check that an index is valid before using it by comparing it to the array’s <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはあるインデックスが有効なことを、それを配列の<bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>プロパティと比較することによって、それを使う前に確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can combine compilation conditions using the logical operators <bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&amp;<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>||<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>!<ept i="2">&lt;/c2&gt;</ept> and use parentheses for grouping.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、コンパイル条件を結合させることが論理演算子<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&amp;<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>||<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>!<ept i="2">&lt;/c2&gt;</ept>を使って可能です、そして丸括弧をグループにするのに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can combine multiple logical operators to create longer compound expressions:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、より長く複雑な式をつくるために複数の論理演算子を結合することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can combine multiple protocols into a single requirement with a <bpt i="0" x="0">&lt;e0&gt;</bpt>protocol composition<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;e0&gt;</bpt>プロトコル合成<ept i="0">&lt;/e0&gt;</ept>を使って複数のプロトコルを１つの要件に結合することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can constrain a tuple pattern to match certain kinds of tuple types by using type annotations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、型注釈を使うことによって特定の種類のタプル型にマッチするようにタプルパターンに制約を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can construct a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Matrix<ept i="0">&lt;/c0&gt;</ept> instance by passing an appropriate row and column count to its initializer:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、そのイニシャライザに適切な行と列の数を渡すことによって新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Matrix<ept i="0">&lt;/c0&gt;</ept>インスタンスを造ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create a new array by adding together two existing arrays with compatible types with the addition operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、互換性を持つ型の２つの既存の配列を加算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>）を使って一緒に加えることによって、新しい配列をつくることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create an array that holds <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> values, or an array that holds <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept> values, or indeed an array for any other type that can be created in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>値を保持する配列、または<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>値を保持する配列、またはそれどころかスウィフトで作成可能なあらゆる他の型のためにも配列をつくることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create an empty array of a certain type using initializer syntax:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、特定の型の空の配列をイニシャライザ構文を使って作成できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create an empty set of a certain type using initializer syntax:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは特定の型の空の集合を初期化構文を使って作成することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create an instance of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept> class for a new player, and see what happens when the player completes level one:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、新しいプレーヤーのために<bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept>クラスのインスタンスをつくることができて、そのプレーヤーがレベル１を完了するとき、何が起こるか見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create and print an <bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept> instance as before:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>HTMLElement<ept i="0">&lt;/c0&gt;</ept>インスタンスを前の通り作成して出力することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create multidimensional arrays by nesting pairs of square brackets, where the name of the base type of the elements is contained in the innermost pair of square brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、角括弧の対を入れにすることによって多次元配列をつくることができます、そこで要素の基本型の名前は最も内側の角括弧の対の中に含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create tuples from any permutation of types, and they can contain as many different types as you like.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、いろいろな型をどんな順列にしてタプルを作っても構いません、そして、それらはあなたが望むだけ多くの異なる型を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can customize the initialization process with input parameters and optional property types, or by assigning constant properties during initialization, as described in the following sections.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、以下の節で記述されるように、入力パラメータとオプショナルプロパティ型を使って、または初期化の間に定数プロパティを割り当てることによって、初期化処理を目的に合わせて作り変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can declare and implement your own <bpt i="0" x="0">&lt;e0&gt;</bpt>custom operators<ept i="0">&lt;/e0&gt;</ept> in addition to the standard operators provided by Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、スウィフトによって提供される標準の演算子に加えて、あなた独自の<bpt i="0" x="0">&lt;e0&gt;</bpt>あつらえの演算子<ept i="0">&lt;/e0&gt;</ept>を宣言して実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can declare multiple constants or multiple variables on a single line, separated by commas:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは複数の定数または複数の変数を、コンマで区切ることで一つの行に宣言することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can declare operators of three different fixities: infix, prefix, and postfix.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、３つの異なる定着性の演算子を宣言することができます：接中辞、接頭辞、そして接尾辞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can decompose the tuple into temporary constants or variables as part of the iteration:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、繰り返しの一部としてそのタプルを一時的な定数または変数に分解することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can define <bpt i="0" x="0">&lt;e0&gt;</bpt>optional requirements<ept i="0">&lt;/e0&gt;</ept> for protocols, These requirements don’t have to be implemented by types that conform to the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはプロトコルのために<bpt i="0" x="0">&lt;e0&gt;</bpt>オプショナルの要件<ept i="0">&lt;/e0&gt;</ept>を定義することができます。 それらの要件は、そのプロトコルに準拠する型によって実装されることは必要ではありません。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can define Swift enumerations to store associated values of any given type, and the value types can be different for each case of the enumeration if needed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはスウィフト列挙を、どんな与えられた型の関連値でも保存するように定義することができます、そして値の型は列挙のケース節それぞれで異なっていることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can define a <bpt i="0" x="0">&lt;e0&gt;</bpt>default value<ept i="0">&lt;/e0&gt;</ept> for any parameter in a function by assigning a value to the parameter after that parameter’s type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある関数のすべてのパラメータに対して<bpt i="0" x="0">&lt;e0&gt;</bpt>省略時の値<ept i="0">&lt;/e0&gt;</ept>を定義することが、そのパラメーターの型の後でパラメーターに値を割り当てることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can define a common set of related cases as part of one enumeration, each of which has a different set of values of appropriate types associated with it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、１つの列挙の一部として、関連したケース節のよくある集合を定義することができます、そのそれぞれはそれと結びつけられる適切な型の値の集合をそれぞれ別に持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある便宜イニシャライザを定義して、同じクラスからある指定イニシャライザをその便宜イニシャライザとして呼び出し、その指定イニシャライザのパラメータのいくつかを省略時の値に設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can define anything from a simple utility function with a single unnamed parameter to a complex function with expressive parameter names and different parameter options.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ただ一つの無名のパラメータを持つ単純で便利な支援関数から、表現豊かなパラメータ名と種々のパラメータ・オプションを持つ複雑な関数まで何でも定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can define multiple related variables of the same type on a single line, separated by commas, with a single type annotation after the final variable name:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは同じ型の複数の関連した変数を、１行上に、コンマで区切って、型注釈を１つだけ最後の変数名の後につけて、定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can define multiple subscripts for a single type, and the appropriate subscript overload to use is selected based on the type of index value you pass to the subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは一つの型のために複数の添え字を定義することができます、そしてあなたが添え字に渡すインデックス値の型に基づいて、使うのに適切な添え字のオーバーロードが選択されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can define your own type constraints when creating custom generic types, and these constraints provide much of the power of generic programming.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、独自の型制約をあつらえの総称体型を作成する時に定義することができます、そして、それらの制約は総称体プログラミングの力の多くを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can delegate from <bpt i="0" x="0">&lt;c0&gt;</bpt>init?<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>init!<ept i="1">&lt;/c1&gt;</ept> and vice versa, and you can override <bpt i="2" x="2">&lt;c2&gt;</bpt>init?<ept i="2">&lt;/c2&gt;</ept> with <bpt i="3" x="3">&lt;c3&gt;</bpt>init!<ept i="3">&lt;/c3&gt;</ept> and vice versa.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>init?<ept i="0">&lt;/c0&gt;</ept>から<bpt i="1" x="1">&lt;c1&gt;</bpt>init!<ept i="1">&lt;/c1&gt;</ept>への委任およびその逆が行えます、そしてあなたは<bpt i="2" x="2">&lt;c2&gt;</bpt>init?<ept i="2">&lt;/c2&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt>init!<ept i="3">&lt;/c3&gt;</ept>でオーバーライドすること、およびその逆もできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can do this even if that method does not define a return value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえそのメソッドが戻り値を定義しないとしても、あなたはこれをすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can drill down into sub-properties, such as the <bpt i="0" x="0">&lt;c0&gt;</bpt>width<ept i="0">&lt;/c0&gt;</ept> property in the <bpt i="1" x="1">&lt;c1&gt;</bpt>resolution<ept i="1">&lt;/c1&gt;</ept> property of a <bpt i="2" x="2">&lt;c2&gt;</bpt>VideoMode<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、下位プロパティへと掘り下っていくことができます、例えば、ある<bpt i="2" x="2">&lt;c2&gt;</bpt>VideoMode<ept i="2">&lt;/c2&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>resolution<ept i="1">&lt;/c1&gt;</ept>プロパティの中の<bpt i="0" x="0">&lt;c0&gt;</bpt>width<ept i="0">&lt;/c0&gt;</ept>プロパティ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can efficiently perform fundamental set operations, such as combining two sets together, determining which values two sets have in common, or determining whether two sets contain all, some, or none of the same values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは効率的に基本的な集合演算を実行することができます、例えば２つの集合を１つに結合する、２つの集合が共通して持つ値はどれか決定する、または２つの集合が同じ値のすべて、いくつか、または全く含まないかどうかを決定するなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can explicitly add the <bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept> attribute to a subclass that meets these criteria, to specify its Objective-C name as discussed below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、明示的に<bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept>属性をこの基準に合うサブクラスに適用して、下で議論されるように、それのObjective-C名を指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can extend a class, structure, or enumeration in any access context in which the class, structure, or enumeration is available.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるクラス、構造体、または列挙を拡張することが、そこにおいてそのクラス、構造体、または列挙が利用可能であるあらゆるアクセス文脈において可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can extend an existing type to add conformance to a protocol, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Adding Protocol Conformance with an Extension<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>拡張を使ってプロトコル準拠を加える<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、既存の型を拡張することでプロトコルへの準拠を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can extend an existing type to adopt and conform to a new protocol, even if you don’t have access to the source code for the existing type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある新しいプロトコルを採用して準拠することで既存の型を拡張することができます、たとえあなたが既存の型のソース・コードにアクセスをしないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can extend the <bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept> structure to provide an additional initializer that takes a specific center point and size:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept>構造体を拡張して、特定の中心点と大きさをとる追加のイニシャライザを提供することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can extend the behavior of a class type with an extension declaration, as discussed in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Extension Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはクラス型の挙動を拡張宣言を使って拡張することができます、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>拡張宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can extend the behavior of a structure type with an extension declaration, as discussed in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Extension Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは構造体型の挙動を拡張宣言を使って拡張することができます、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>拡張宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can extend the behavior of an enumeration type with an extension declaration, as discussed in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Extension Declaration<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは列挙型の挙動を拡張宣言を使って拡張することができます、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>拡張宣言<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can fit two <bpt i="0" x="0">&lt;c0&gt;</bpt>4<ept i="0">&lt;/c0&gt;</ept>s inside <bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept>, and the remainder is <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept> (shown in orange).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは２つの<bpt i="0" x="0">&lt;c0&gt;</bpt>4<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept>の内部に収めることができます、そして余りは<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>です（オレンジ色で示されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can give a setter a <bpt i="0" x="0">&lt;e0&gt;</bpt>lower<ept i="0">&lt;/e0&gt;</ept> access level than its corresponding getter, to restrict the read-write scope of that variable, property, or subscript.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、セッターにその対応するゲッターよりも<bpt i="0" x="0">&lt;e0&gt;</bpt>より低い<ept i="0">&lt;/e0&gt;</ept>アクセス水準を与えて、その変数、プロパティ、または添え字の読み書きのスコープを制限することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can implement a protocol initializer requirement on a conforming class as either a designated initializer or a convenience initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、イニシャライザ要件プロトコルを準拠クラス上で指定イニシャライザまたは便宜イニシャライザとして実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can include a generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clause on an associated type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節を関連型に関して含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can include additional spaces and tabs after that indentation; those spaces and tabs appear in the string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、追加の空白とタブをその字下げの後に含めることができます；それらの空白とタブは文字列の中に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can include as many optional bindings and Boolean conditions in a single <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement as you need to, separated by commas.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、単一の<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文の中に、コンマで区切ったオプショナル束縛とブール条件をあなたが必要とするだけ多く含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can include multiple requirements in a generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clause that is part of an extension, just like you can for a generic <bpt i="1" x="1">&lt;c1&gt;</bpt>where<ept i="1">&lt;/c1&gt;</ept> clause that you write elsewhere.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、複数の要件を拡張の一部であるひとつの<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節の中に含めることができます、ちょうどあなたがどこか他で書く総称体<bpt i="1" x="1">&lt;c1&gt;</bpt>where<ept i="1">&lt;/c1&gt;</ept>節に対してできるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can include predefined <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> values within your code as <bpt i="1" x="1">&lt;e1&gt;</bpt>string literals<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あらかじめ定義された<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>値を<bpt i="1" x="1">&lt;e1&gt;</bpt>文字列リテラル<ept i="1">&lt;/e1&gt;</ept>としてあなたのコードの内部に含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can initialize the <bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept> structure below in one of three ways—by using its default zero-initialized <bpt i="1" x="1">&lt;c1&gt;</bpt>origin<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>size<ept i="2">&lt;/c2&gt;</ept> property values, by providing a specific origin point and size, or by providing a specific center point and size.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、以下の<bpt i="0" x="0">&lt;c0&gt;</bpt>Rect<ept i="0">&lt;/c0&gt;</ept>構造体を３つの方法のうちの１つで初期化することができます ― それの省略時の０で初期化された<bpt i="1" x="1">&lt;c1&gt;</bpt>origin<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>size<ept i="2">&lt;/c2&gt;</ept>プロパティ値を使うことによって、特定の原点とサイズを提供することによって、または特定の中心点とサイズを提供することによって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can iterate over the entire set of values in an array with the <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループを使って配列中の値ひとそろい全部に渡って繰り返すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can iterate over the key-value pairs in a dictionary with a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループを使って、ある辞書の中の「キーと値」のすべてに対して操作を繰り返し適用していくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can iterate over the string with a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> statement, to access its individual <bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept> values as Unicode extended grapheme clusters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは文字列の全体にわたって<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>文を使って繰り返すことができます、それでユニコードの拡張書記素クラスタとしてのそれの個々の<bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept>値にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can iterate over the values in a set with a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは集合の中の値すべてに渡って繰り返しすることが<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can keep an index in a loop by using <bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept> to make a range of indexes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、インデックス（索引）をループにおいて保持することが、<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>を使ってインデックスの範囲を作ることで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can limit protocol adoption to class types (and not structures or enumerations) by adding the <bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept> protocol to a protocol’s inheritance list.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、プロトコル採用をクラス型に制限する（つまり構造体や列挙で採用しない）ことが<bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept>プロトコルをプロトコルのもつ継承リストに加えることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can link together multiple levels of optional chaining to drill down to properties, methods, and subscripts deeper within a model.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、オプショナル連鎖の複数の階層を結びつけて、あるモデル内のより深いプロパティ、メソッド、そして添え字に掘り下げていくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can list as many protocols as you need, separating them with ampersands (<bpt i="1" x="1">&lt;c1&gt;</bpt>&amp;<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなたが必要とするだけ多くのプロトコルを、それらをアンパサンド（<bpt i="1" x="1">&lt;c1&gt;</bpt>&amp;<ept i="1">&lt;/c1&gt;</ept>）で隔てて列記できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can make generic forms of functions and methods, as well as classes, enumerations, and structures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは関数やメソッドだけでなく、クラス、列挙、そして構造体も総称体の形式にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can make the structure’s <bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfEdits<ept i="2">&lt;/c2&gt;</ept> property getter public, and its property setter private, by combining the <bpt i="3" x="3">&lt;c3&gt;</bpt>public<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>private(set)<ept i="4">&lt;/c4&gt;</ept> access-level modifiers:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、この構造体の<bpt i="2" x="2">&lt;c2&gt;</bpt>numberOfEdits<ept i="2">&lt;/c2&gt;</ept>プロパティゲッターを公開に、そしてそれのプロパティセッターを非公開にすることが、<bpt i="3" x="3">&lt;c3&gt;</bpt>public<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>private(set)<ept i="4">&lt;/c4&gt;</ept>アクセス水準修飾子を組み合わせることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can mark a declaration with one of the access-level modifiers below to specify the declaration’s access level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、宣言を以下のアクセス水準修飾子のうちの１つで印して、その宣言のアクセス水準を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can mark an entire class as final by writing the <bpt i="0" x="0">&lt;c0&gt;</bpt>final<ept i="0">&lt;/c0&gt;</ept> modifier before the <bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept> keyword in its class definition (<bpt i="2" x="2">&lt;c2&gt;</bpt>final class<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、そのクラス定義において<bpt i="1" x="1">&lt;c1&gt;</bpt>class<ept i="1">&lt;/c1&gt;</ept>キーワードの前に<bpt i="0" x="0">&lt;c0&gt;</bpt>final<ept i="0">&lt;/c0&gt;</ept>修飾子を書くことによって（<bpt i="2" x="2">&lt;c2&gt;</bpt>final class<ept i="2">&lt;/c2&gt;</ept>）、そのクラス全体を最終版として印することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can mark designated and convenience initializers with the <bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept> declaration modifier to require that every subclass implement the initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは指定および便宜イニシャライザを<bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept>宣言修飾子で印して、全てのサブクラスがそのイニシャライザを実装することが必須であるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can match individual enumeration values with a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文を使って個々の列挙値を照合することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can name the individual elements in a tuple when the tuple is defined:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、タプルの個々の要素に名前をつけることが、そのタプルが定義される時に可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can name the parameter or use the default parameter name of <bpt i="1" x="1">&lt;c1&gt;</bpt>oldValue<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはパラメータに名をつけること、または省略時のパラメータ名の<bpt i="1" x="1">&lt;c1&gt;</bpt>oldValue<ept i="1">&lt;/c1&gt;</ept>を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can nest labeled statements, but the name of each statement label must be unique.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはラベルをつけられた文を入れ子にすることができます、しかし、各文ラベルの名前は特有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can now call the assigned function with the name <bpt i="0" x="0">&lt;c0&gt;</bpt>mathFunction<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、今や、代入された関数を名前<bpt i="0" x="0">&lt;c0&gt;</bpt>mathFunction<ept i="0">&lt;/c0&gt;</ept>を使って呼ぶことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can now create a <bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept> instance, and use it to initialize and assign a new <bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept> instance as that customer’s <bpt i="2" x="2">&lt;c2&gt;</bpt>card<ept i="2">&lt;/c2&gt;</ept> property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、現在<bpt i="0" x="0">&lt;c0&gt;</bpt>Customer<ept i="0">&lt;/c0&gt;</ept>インスタンスを作成して、それを使って、新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>CreditCard<ept i="1">&lt;/c1&gt;</ept>インスタンスを、その顧客の<bpt i="2" x="2">&lt;c2&gt;</bpt>card<ept i="2">&lt;/c2&gt;</ept>プロパティとして初期化して代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can now create a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> instance and assign it to one of these three variables:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、いま新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>インスタンスを作成して、それをこれらの３つの変数のうちの１つに代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can now create a specific <bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept> instance and <bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept> instance and assign these new instances to the <bpt i="2" x="2">&lt;c2&gt;</bpt>john<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>unit4A<ept i="3">&lt;/c3&gt;</ept> variables:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、今や特定の<bpt i="0" x="0">&lt;c0&gt;</bpt>Person<ept i="0">&lt;/c0&gt;</ept>インスタンスと<bpt i="1" x="1">&lt;c1&gt;</bpt>Apartment<ept i="1">&lt;/c1&gt;</ept>インスタンスを作成して、それらの新しいインスタンスを<bpt i="2" x="2">&lt;c2&gt;</bpt>john<ept i="2">&lt;/c2&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt>unit4A<ept i="3">&lt;/c3&gt;</ept>変数に代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can now link the two instances together so that the person has an apartment, and the apartment has a tenant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは次に人がアパートを持つように、２つのインスタンスを結びつけることができます、するとアパートには賃借人があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can now try to set a property’s value, assign to a subscript, or call a mutating method or operator through <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Optional Chaining<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは今では<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オプショナル連鎖<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を通して、プロパティの値を設定する、ある添え字に代入する、または可変メソッドまたは演算子を呼び出すことを試みることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can now use <bpt i="0" x="0">&lt;c0&gt;</bpt>chooseStepFunction(backward:)<ept i="0">&lt;/c0&gt;</ept> to obtain a function that will step in one direction or the other:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>現在あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>chooseStepFunction(backward:)<ept i="0">&lt;/c0&gt;</ept>を使って、ある方向にまたはもう一方に進む関数を取得できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can now use the <bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<ept i="0">&lt;/c0&gt;</ept> array to create an array of <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> values, by passing a closure expression to the array’s <bpt i="2" x="2">&lt;c2&gt;</bpt>map(_:)<ept i="2">&lt;/c2&gt;</ept> method as a trailing closure:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、現在、この<bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<ept i="0">&lt;/c0&gt;</ept>配列を<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値の配列をつくるために使うことが、あるクロージャ式を配列の<bpt i="2" x="2">&lt;c2&gt;</bpt>map(_:)<ept i="2">&lt;/c2&gt;</ept>メソッドに後付クロージャとして渡すことによって、可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can now use these operators to check whether two <bpt i="0" x="0">&lt;c0&gt;</bpt>Vector2D<ept i="0">&lt;/c0&gt;</ept> instances are equivalent:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、現在２つの<bpt i="0" x="0">&lt;c0&gt;</bpt>Vector2D<ept i="0">&lt;/c0&gt;</ept>インスタンスが等しいかどうか調べるために、これらの演算子を使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can omit the assertion message—for example, when it would just repeat the condition as prose.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは表明メッセージを省略できます — 例えば、それが単に条件を単調に繰り返す場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can only pass a variable as the argument for an in-out parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、in-outパラメータに対する引数として、変数を渡すことだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can opt in to this behavior by placing the <bpt i="0" x="0">&lt;c0&gt;</bpt>mutating<ept i="0">&lt;/c0&gt;</ept> keyword before the <bpt i="1" x="1">&lt;c1&gt;</bpt>func<ept i="1">&lt;/c1&gt;</ept> keyword for that method:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、そのメソッドのための<bpt i="1" x="1">&lt;c1&gt;</bpt>func<ept i="1">&lt;/c1&gt;</ept>キーワードの前に<bpt i="0" x="0">&lt;c0&gt;</bpt>mutating<ept i="0">&lt;/c0&gt;</ept>キーワードを置くことによってこの挙動を取り入れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can opt in to value overflow behavior by using Swift’s overflow operators (such as <bpt i="0" x="0">&lt;c0&gt;</bpt>a &amp;+ b<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、スウィフトのオーバフロー演算子を使用することによって、値オーバフロー挙動を選ぶことが可能です（例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>a &amp;+ b<ept i="0">&lt;/c0&gt;</ept>のように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can opt in to value overflow behavior by using Swift’s overflow operators, as described in <bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>Overflow Operators<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;a8&gt;</bpt>オーバフロー演算子<ept i="8">&lt;/a8&gt;</ept><ept i="7">&lt;/s7&gt;</ept>で記述されるように、あなたは、スウィフトのもつオーバフロー演算子を使うことによって、値オーバフロー挙動を選ぶことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can overload a generic function or initializer by providing different constraints, requirements, or both on the type parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、総称体の関数やイニシャライザをオーバーロードすることが、異なる制約、要件、または両方を型パラメータ上で提供することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can overload a subscript declaration in the type in which it is declared, as long as the <bpt i="0" x="0">&lt;e0&gt;</bpt>parameters<ept i="0">&lt;/e0&gt;</ept> or the <bpt i="1" x="1">&lt;e1&gt;</bpt>return type<ept i="1">&lt;/e1&gt;</ept> differ from the one you’re overloading.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある添え字宣言を、そこにおいてそれが宣言される型においてオーバーロードすることができます、<bpt i="0" x="0">&lt;e0&gt;</bpt>パラメーター<ept i="0">&lt;/e0&gt;</ept>または<bpt i="1" x="1">&lt;e1&gt;</bpt>戻り型<ept i="1">&lt;/e1&gt;</ept>があなたがオーバーロードしているものと異なる限りはです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can overload the <bpt i="0" x="0">&lt;c0&gt;</bpt>~=<ept i="0">&lt;/c0&gt;</ept> operator to provide custom expression matching behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>~=<ept i="0">&lt;/c0&gt;</ept>演算子をオーバーロードして、あつらえの式マッチング挙動を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can override a failable initializer with a nonfailable initializer but not the other way around.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは失敗できるイニシャライザを、失敗できないイニシャライザでオーバーライドできます、しかし逆はできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can override a nonreturning method, but the new method must preserve its return type and nonreturning behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは非復帰メソッドをオーバーライドすることができます、しかし新しいメソッドはそれの戻り型と非復帰挙動を維持しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can override a property in a subclass by marking the subclass’s property declaration with the <bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept> declaration modifier, as described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Overriding<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>オーバーライド<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述されるように、、サブクラスのプロパティ宣言を<bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept>宣言修飾子で印することによってサブクラスの中のプロパティをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can override a superclass failable initializer in a subclass, just like any other initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、スーパークラスの失敗できるイニシャライザをサブクラスにおいてオーバーライドすることが、何らかの他のイニシャライザとまったく同じようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can override an inherited instance or type method to provide a tailored or alternative implementation of the method within your subclass.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある継承されたインスタンスまたは型メソッドをオーバーライドすることで、あなたのサブクラス内部でそのメソッドの特注のまたは代替の実装を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can override an inherited instance or type property to provide your own custom getter and setter for that property, or to add property observers to enable the overriding property to observe when the underlying property value changes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは継承されたインスタンスまたは型プロパティをオーバーライドして、そのプロパティのためにあなた独自のあつらえのゲッターとセッターを用意したり、根底にあるプロパティ値がいつ変化するか監視することをオーバーライドしているプロパティに可能にするプロパティオブザーバーを加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can override the default behavior for argument labels with one of the following forms:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは引数ラベルに対する初期状態の挙動をオーバーライドすることが以下の形式の１つで可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can override this default behavior by marking the declaration with an access-level modifier, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Access Control Levels<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>アクセス制御ラベル<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、この初期状態のふるまいをその宣言をアクセス水準修飾子で印することによってオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can pass a value of any conforming type in to this parameter when initializing a new <bpt i="3" x="3">&lt;c3&gt;</bpt>Dice<ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しい<bpt i="3" x="3">&lt;c3&gt;</bpt>Dice<ept i="3">&lt;/c3&gt;</ept>インスタンスを初期化するとき、あなたはどんな準拠型の値でもこのパラメータに渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can pass any function of that type as the argument for this first parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、この最初のパラメータに対する引数として、その型のどんな関数でも渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can prefix a loop statement, an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement, a <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> statement, or a <bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept> statement with a <bpt i="3" x="3">&lt;e3&gt;</bpt>statement label<ept i="3">&lt;/e3&gt;</ept>, which consists of the name of the label followed immediately by a colon (:).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはループ文、<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文、<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>文、または<bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept>文の前に<bpt i="3" x="3">&lt;e3&gt;</bpt>文ラベル<ept i="3">&lt;/e3&gt;</ept>を置くことができます、それは、ラベルの名前とそれに直ちに続くコロン（:）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのサブクラスプロパティオーバーライドにおいてゲッターとセッターの両方を提供することによって、あなたは継承された読み出し専用のプロパティを、読み書き両用のプロパティとして提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can prevent a method, property, or subscript from being overridden by marking it as <bpt i="0" x="0">&lt;e0&gt;</bpt>final<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはメソッド、プロパティ、または添え字がオーバーライドされるのを、それを<bpt i="0" x="0">&lt;e0&gt;</bpt>最終版（final）<ept i="0">&lt;/e0&gt;</ept>と印することによって妨げることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can print the current value of a constant or variable with the <bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:separator:terminator:)<ept i="0">&lt;/c0&gt;</ept> function:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:separator:terminator:)<ept i="0">&lt;/c0&gt;</ept>関数で定数または変数の現在の値を出力することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can propagate the error from a function to the code that calls that function, handle the error using a <bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> statement, handle the error as an optional value, or assert that the error will not occur.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、エラーを関数からその関数を呼び出しているコードに伝えて、そのエラーを<bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>文を使って取り扱う、エラーをオプショナルとして取り扱う、またはそのエラーは起こらないことを表明することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can provide <bpt i="0" x="0">&lt;e0&gt;</bpt>initialization parameters<ept i="0">&lt;/e0&gt;</ept> as part of an initializer’s definition, to define the types and names of values that customize the initialization process.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、イニシャライザの定義の一部として<bpt i="0" x="0">&lt;e0&gt;</bpt>初期化パラメータ<ept i="0">&lt;/e0&gt;</ept>を提供することができます、それによって初期化処理をカスタマイズする値の型と名前を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can provide a <bpt i="0" x="0">&lt;e0&gt;</bpt>type annotation<ept i="0">&lt;/e0&gt;</ept> when you declare a constant or variable, to be clear about the kind of values the constant or variable can store.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなたが定数または変数を宣言するとき、その定数または変数が保存することができる値の種類について明確にするために、<bpt i="0" x="0">&lt;e0&gt;</bpt>型注釈<ept i="0">&lt;/e0&gt;</ept>を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can provide a custom getter (and setter, if appropriate) to override <bpt i="0" x="0">&lt;e0&gt;</bpt>any<ept i="0">&lt;/e0&gt;</ept> inherited property, regardless of whether the inherited property is implemented as a stored or computed property at source.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あつらえののゲッターを（そして適切ならば、セッターも）提供することで、<bpt i="0" x="0">&lt;e0&gt;</bpt>あらゆる<ept i="0">&lt;/e0&gt;</ept>継承されたプロパティをオーバーライドできます、継承されたプロパティがその発生源で保存プロパティもしくは計算プロパティとして実装されるかは関係しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can provide a default value for a stored property as part of its definition, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Default Property Values<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>省略時のプロパティ値<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように、あなたは保存プロパティのために省略時の値をその定義の一部として用意することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can provide an explicit name in parentheses after <bpt i="2" x="2">&lt;c2&gt;</bpt>set<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="2" x="2">&lt;c2&gt;</bpt>set<ept i="2">&lt;/c2&gt;</ept>の後に括弧の中ではっきりとした名前を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can provide more than one type parameter by writing multiple type parameter names within the angle brackets, separated by commas.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、山形括弧内に複数の型パラメータ名をコンマで区切って書くことによって、複数の型パラメータを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can provide multiple <bpt i="0" x="0">&lt;c0&gt;</bpt>catch<ept i="0">&lt;/c0&gt;</ept> blocks that handle specific errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、それぞれが特定のエラーを取り扱う複数の<bpt i="0" x="0">&lt;c0&gt;</bpt>catch<ept i="0">&lt;/c0&gt;</ept>ブロックを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can put parentheses around a named type or a compound type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、名前付きの型や複合の型の周りに丸括弧を置くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can query the <bpt i="0" x="0">&lt;c0&gt;</bpt>threeTimesTable<ept i="0">&lt;/c0&gt;</ept> instance by calling its subscript, as shown in the call to <bpt i="1" x="1">&lt;c1&gt;</bpt>threeTimesTable[6]<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>threeTimesTable<ept i="0">&lt;/c0&gt;</ept>インスタンスにその添え字を呼ぶことによって問い合わせることが<bpt i="1" x="1">&lt;c1&gt;</bpt>threeTimesTable[6]<ept i="1">&lt;/c1&gt;</ept>への呼び出しで示されるように可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can read this code as:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、このコードを次のように読むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can refer to parameters by number instead of by name—this approach is especially useful in very short closures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、名前によってでなく、数によってパラメータに言及することができます ― この取り組み方は、特に非常に短いクロージャで役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can remove an item from a set by calling the set’s <bpt i="0" x="0">&lt;c0&gt;</bpt>remove(_:)<ept i="0">&lt;/c0&gt;</ept> method, which removes the item if it’s a member of the set, and returns the removed value, or returns <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> if the set did not contain it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはある項目を集合から取り除くことが集合の<bpt i="0" x="0">&lt;c0&gt;</bpt>remove(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを呼ぶことによって行えます、それは、その項目をそれが集合のメンバーであるならば取り除きます、そして取り除かれた項目を返します、または集合がそれを含まないならば<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can revise the <bpt i="0" x="0">&lt;c0&gt;</bpt>SurveyQuestion<ept i="0">&lt;/c0&gt;</ept> example from above to use a constant property rather than a variable property for the <bpt i="1" x="1">&lt;c1&gt;</bpt>text<ept i="1">&lt;/c1&gt;</ept> property of the question, to indicate that the question does not change once an instance of <bpt i="2" x="2">&lt;c2&gt;</bpt>SurveyQuestion<ept i="2">&lt;/c2&gt;</ept> is created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、上記の<bpt i="0" x="0">&lt;c0&gt;</bpt>SurveyQuestion<ept i="0">&lt;/c0&gt;</ept>例を、変数プロパティではなく定数プロパティを質問の<bpt i="1" x="1">&lt;c1&gt;</bpt>text<ept i="1">&lt;/c1&gt;</ept>プロパティのために使うように見直して、その質問は一旦<bpt i="2" x="2">&lt;c2&gt;</bpt>SurveyQuestion<ept i="2">&lt;/c2&gt;</ept>のインスタンスが作成されるならば変化しないことを示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can rewrite the <bpt i="0" x="0">&lt;c0&gt;</bpt>TemperatureUnit<ept i="0">&lt;/c0&gt;</ept> example from above to use raw values of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept> and to take advantage of the <bpt i="2" x="2">&lt;c2&gt;</bpt>init?(rawValue:)<ept i="2">&lt;/c2&gt;</ept> initializer:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、上の<bpt i="0" x="0">&lt;c0&gt;</bpt>TemperatureUnit<ept i="0">&lt;/c0&gt;</ept>例を<bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept>型の生の値を使うように、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>init?(rawValue:)<ept i="2">&lt;/c2&gt;</ept>イニシャライザを活用するように書き直すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can rewrite the <bpt i="0" x="0">&lt;c0&gt;</bpt>chooseStepFunction(backward:)<ept i="0">&lt;/c0&gt;</ept> example above to use and return nested functions:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、入れ子にされた関数を使用して返すように、上記の<bpt i="0" x="0">&lt;c0&gt;</bpt>chooseStepFunction(backward:)<ept i="0">&lt;/c0&gt;</ept>の例を書き直すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can rewrite the <bpt i="0" x="0">&lt;c0&gt;</bpt>possibleNumber<ept i="0">&lt;/c0&gt;</ept> example from the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Optionals<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section to use optional binding rather than forced unwrapping:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>オプショナル<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節の<bpt i="0" x="0">&lt;c0&gt;</bpt>possibleNumber<ept i="0">&lt;/c0&gt;</ept>例を、強制アンラップではなくて、オプショナル束縛を使うように書き直すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can set a constant or variable to <bpt i="0" x="0">&lt;c0&gt;</bpt>Planet.earth<ept i="0">&lt;/c0&gt;</ept>, and check for this value later.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、定数または変数を<bpt i="0" x="0">&lt;c0&gt;</bpt>Planet.earth<ept i="0">&lt;/c0&gt;</ept>に設定することができて、後でその値について調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can set a value in a dictionary by providing a key of the dictionary’s key type within subscript brackets, and assigning a value of the dictionary’s value type to the subscript:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、添え字角括弧内にその辞書のキー型のキーを提供し、そしてその添え字に辞書の値型の値を代入することによって、値を辞書に設定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can set an initial value for a stored property within an initializer, or by assigning a default property value as part of the property’s definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、イニシャライザの内部で、またはそのプロパティの定義の一部として省略時のプロパティの値を代入することによって、保存プロパティのために初期値を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can set the <bpt i="1" x="1">&lt;c1&gt;</bpt>hasBasket<ept i="1">&lt;/c1&gt;</ept> property to <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept> for a particular <bpt i="3" x="3">&lt;c3&gt;</bpt>Bicycle<ept i="3">&lt;/c3&gt;</ept> instance after that instance is created:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、特定の<bpt i="3" x="3">&lt;c3&gt;</bpt>Bicycle<ept i="3">&lt;/c3&gt;</ept>インスタンスに対して<bpt i="1" x="1">&lt;c1&gt;</bpt>hasBasket<ept i="1">&lt;/c1&gt;</ept>プロパティを<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>に設定することが、そのインスタンスを作成した後で行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can set the initial value of a stored property from within an initializer, as shown above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはイニシャライザ内から保存プロパティの初期値を設定することが、上で示されるように、行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can simplify the declaration of a read-only computed property by removing the <bpt i="0" x="0">&lt;c0&gt;</bpt>get<ept i="0">&lt;/c0&gt;</ept> keyword and its braces:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、読み出し専用の計算プロパティの宣言を<bpt i="0" x="0">&lt;c0&gt;</bpt>get<ept i="0">&lt;/c0&gt;</ept>キーワードとそれの波括弧を取り除くことによって単純化することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can specify a name for this parameter as part of your <bpt i="1" x="1">&lt;c1&gt;</bpt>willSet<ept i="1">&lt;/c1&gt;</ept> implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなたの<bpt i="1" x="1">&lt;c1&gt;</bpt>willSet<ept i="1">&lt;/c1&gt;</ept>実装の一部としてこのパラメータに名前を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can specify a type annotation for these patterns to constrain them to match only values of a certain type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは型注釈をこれらのパターンに指定して、それらがある特定の型の値だけにマッチするように制約を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can specify additional requirements on type parameters and their associated types by including a generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clause right before the opening curly brace of a type or function’s body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、追加の要件を型パラメータおよびそれの関連型に指定することが総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節を型または関数の本文の開き波括弧のまさに前に含めることによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can still treat an implicitly unwrapped optional like a normal optional, to check if it contains a value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは依然として暗黙的にアンラップされるオプショナルを通常のオプショナルのように扱うことができます、それが値を含むかどうか確認するためには：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can subclass any class that can be accessed in the current access context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、現在のアクセス前後関係においてアクセスされることができるどんなクラスにでもサブクラスをつくることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can tell that the <bpt i="0" x="0">&lt;c0&gt;</bpt>createAddress()<ept i="0">&lt;/c0&gt;</ept> function isn’t called, because nothing is printed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>createAddress()<ept i="0">&lt;/c0&gt;</ept>関数が呼ばれなかったと言うことができます、なぜなら何も出力されなかったからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can therefore call the <bpt i="4" x="4">&lt;c4&gt;</bpt>allItemsMatch(_:_:)<ept i="4">&lt;/c4&gt;</ept> function with these two containers as its arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、したがって、<bpt i="4" x="4">&lt;c4&gt;</bpt>allItemsMatch(_:_:)<ept i="4">&lt;/c4&gt;</ept>関数をその引数としてこれらの２つのコンテナを使って呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can think of an implicitly unwrapped optional as giving permission for the optional to be unwrapped automatically whenever it’s used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは暗黙的にアンラップされるオプショナルを、それが使われるときはいつでも自動的にアンラップされる許可をそのオプショナルに与えていると考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can think of the associated values as behaving like stored properties of the enumeration case instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはそれら関連値を、その列挙ケース節インスタンスに属する保存プロパティのように振る舞うものとして考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>let<ept i="1">&lt;/c1&gt;</ept> together to work with values that might be missing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>let<ept i="1">&lt;/c1&gt;</ept>を一緒に使って、見つからないかもしれない値を扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use <bpt i="1" x="1">&lt;c1&gt;</bpt>defer<ept i="1">&lt;/c1&gt;</ept> to write setup and cleanup code next to each other, even though they need to be executed at different times.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="1" x="1">&lt;c1&gt;</bpt>defer<ept i="1">&lt;/c1&gt;</ept>を使うことでセットアップおよびクリーンアップコードを隣り合わせに書くことができます、たとえそれらが異なる時に実行される必要があるにしても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use Xcode 9 to build targets that are written in either Swift 4 or Swift 3.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、Xcode 9を使ってSwift 4またはSwift 3のどちらかで書かれたターゲットをビルドできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept> statement even when no error handling code is involved.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept>文を使うことが、エラー処理コードを伴わない時でさえも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a <bpt i="0" x="0">&lt;e0&gt;</bpt>capture list<ept i="0">&lt;/e0&gt;</ept> to explicitly control how values are captured in a closure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;e0&gt;</bpt>キャプチャリスト<ept i="0">&lt;/e0&gt;</ept>を使って、どのようにあるクロージャにおいて値がキャプチャされるかを明示的に制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a failable initializer to select an appropriate enumeration case based on one or more parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、失敗できるイニシャライザを使って適切な列挙ケース節を１つ以上のパラメータに基づいて選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a function type as the return type of another function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある関数型をそれとは違う関数の戻り型として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a function type such as <bpt i="0" x="0">&lt;c0&gt;</bpt>(Int, Int) -&gt; Int<ept i="0">&lt;/c0&gt;</ept> as a parameter type for another function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある関数型、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>(Int, Int) -&gt; Int<ept i="0">&lt;/c0&gt;</ept>を、別の関数のためのパラメータ型として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clause with extensions to a protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節をプロトコルに対する拡張で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a protocol name just like any other named type—for example, to create a collection of objects that have different types but that all conform to a single protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、何かほかの名前付きの型のようにプロトコル名を使用することができます ― 例えば、それぞれ異なる型を持つが全てがただ１つのプロトコルに準拠するオブジェクトたちのコレクションをつくるためなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a set instead of an array when the order of items is not important, or when you need to ensure that an item only appears once.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、項目の順番が重要でないときに、またはあなたがひとつの項目がただ一度だけ現れることを確実にする必要があるときに、配列の代わりに集合を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a tuple to return multiple values from a function as a single compound value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはタプルを使って、関数から複数の値を一つの混成値として返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a tuple type as the return type for a function to return multiple values as part of one compound return value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、関数の戻り型としてタプル型を使って、複数の値をひとつの複合の戻り値の一部として返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use a tuple type as the return type of a function to enable the function to return a single tuple containing multiple values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、関数の戻り型としてタプル型を使って、その関数に複数の値を含んでいる一つのタプルを返すのを可能にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use all three of the inherited initializers to create a new <bpt i="0" x="0">&lt;c0&gt;</bpt>ShoppingListItem<ept i="0">&lt;/c0&gt;</ept> instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、継承されたイニシャライザの３つ全てを新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>ShoppingListItem<ept i="0">&lt;/c0&gt;</ept>インスタンスをつくるために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement to find out whether an optional contains a value by comparing the optional against <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文を、あるオプショナルが値を含むかどうか知るために使うことができます、それは、そのオプショナルを<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>と比べることによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use an empty dictionary literal to create an empty dictionary literal of specified key and value types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、空の辞書リテラルを使って、指定されたキーと値型の空の辞書リテラルを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use an extension to add protocol conformance to a type that is declared elsewhere, or even to a type that you imported from a library or framework.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは１つの拡張を使用することで、どこかほかで宣言される型に、またはあなたがライブラリやフレームワークからインポートした型にさえもプロトコル準拠を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use an extension to add protocol conformance, like this:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはある拡張を使って、このようにプロトコル準拠を加えることが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>ThreeSource<ept i="0">&lt;/c0&gt;</ept> as the data source for a new <bpt i="1" x="1">&lt;c1&gt;</bpt>Counter<ept i="1">&lt;/c1&gt;</ept> instance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>ThreeSource<ept i="0">&lt;/c0&gt;</ept>のインスタンスを新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>Counter<ept i="1">&lt;/c1&gt;</ept>インスタンスのためのデータ・ソースとして使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>TowardsZeroSource<ept i="0">&lt;/c0&gt;</ept> with the existing <bpt i="1" x="1">&lt;c1&gt;</bpt>Counter<ept i="1">&lt;/c1&gt;</ept> instance to count from <bpt i="2" x="2">&lt;c2&gt;</bpt>-4<ept i="2">&lt;/c2&gt;</ept> to zero.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>TowardsZeroSource<ept i="0">&lt;/c0&gt;</ept>のインスタンスを既存の<bpt i="1" x="1">&lt;c1&gt;</bpt>Counter<ept i="1">&lt;/c1&gt;</ept>インスタンスとともに使って、<bpt i="2" x="2">&lt;c2&gt;</bpt>-4<ept i="2">&lt;/c2&gt;</ept>からゼロへと数えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use bit shifting to encode and decode values within other data types:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、他のデータ型内の値を符号化したり復号するために、ビットシフトを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use both classes and structures to define custom data types to use as the building blocks of your program’s code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなたのプログラムのコードの建築ブロックとして使う特別あつらえのデータ型を定義するために、クラスと構造体のどちらでも使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use both constants and variables with optional binding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、定数と変数の両方をオプショナル束縛で使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use forced unwrapping in an initializer to call a failable initializer from the superclass as part of the implementation of a subclass’s nonfailable initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、強制アンラップをイニシャライザの中で使うことで、失敗できるイニシャライザをスーパークラスから呼び出し、サブクラスの失敗できないイニシャライザの実装の一部とすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use nested functions to organize the code in a function that is long or complex.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、長いか複雑である関数においてコードを組織するために、入れ子にされた関数を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use optional binding to check whether this version of the <bpt i="0" x="0">&lt;c0&gt;</bpt>minMax(array:)<ept i="0">&lt;/c0&gt;</ept> function returns an actual tuple value or <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>minMax(array:)<ept i="0">&lt;/c0&gt;</ept>関数のこの改作が返すのは本当のタプルなのかまたは<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>なのかを調べるためにオプショナル束縛を使うことが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use optional chaining to call a method on an optional value, and to check whether that method call is successful.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはオプショナル連鎖を使って、オプショナルの値の上でメソッドを呼んで、そしてそのメソッド呼び出しが成功しているかどうか調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use optional chaining to try to retrieve and set a value from a subscript on an optional value, and to check whether that subscript call is successful.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、オプショナル連鎖を使って、あるオプショナルの値上の添え字から値を取り出したり設定したりすること、そしてその添え字がうまく呼び出されるかどうかを調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use optional chaining with calls to properties, methods, and subscripts that are more than one level deep.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、深さ１階層以上であるプロパティ、メソッド、そして添え字への呼び出しでオプショナル連鎖を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use parentheses to specify the precedence of operations by explicitly grouping expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは丸括弧を使って、明示的にいくらかの式をグループにまとめることによって演算の優先順位を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use property overriding to add property observers to an inherited property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、プロパティをオーバーライドすることを継承されたプロパティにプロパティオブザーバーを追加するために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use protocol extensions to provide a default implementation to any method or computed property requirement of that protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはプロトコル拡張を使うことで省略時の実装をそのプロトコルのどのメソッドまたは計算プロパティ要件に対しても提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use protocols to declare which methods a delegate of a class or structure should implement, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Delegation<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはプロトコルを使って、あるクラスまたは構造体から委任を受ける側が実装しなければならないのはどのメソッドかを宣言することができます、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>委任<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use string interpolation in both single-line and multiline string literals.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、文字列補間を単一行および複数行文字列リテラルにおいて使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use subscript syntax to access the <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> at a particular <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> index.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、添え字構文を使うことで特定の<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>インデックス位置での<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>へアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use subscript syntax to change an existing value at a given index:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、添え字構文を使って、与えられたインデックス位置にある既存の値を変えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use subscript syntax to remove a key-value pair from a dictionary by assigning a value of <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> for that key:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは添え字構文を、そのキーに対して<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>の値を代入することによって、辞書からある「キーと値」の対を削除するために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>AudioChannel<ept i="0">&lt;/c0&gt;</ept> structure to create two new audio channels called <bpt i="1" x="1">&lt;c1&gt;</bpt>leftChannel<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>rightChannel<ept i="2">&lt;/c2&gt;</ept>, to represent the audio levels of a stereo sound system:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>AudioChannel<ept i="0">&lt;/c0&gt;</ept>構造体を、<bpt i="1" x="1">&lt;c1&gt;</bpt>leftChannel<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>rightChannel<ept i="2">&lt;/c2&gt;</ept>と呼ばれる２つの新しい音声チャンネルをつくるために使用して、ステレオ・オーディオ・システムの音声のレベルを表すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>fatalError(_:file:line:)<ept i="0">&lt;/c0&gt;</ept> function during prototyping and early development to create stubs for functionality that hasn’t been implemented yet, by writing <bpt i="1" x="1">&lt;c1&gt;</bpt>fatalError("Unimplemented")<ept i="1">&lt;/c1&gt;</ept> as the stub implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>fatalError(_:file:line:)<ept i="0">&lt;/c0&gt;</ept>関数を試作段階および開発初期の間に使って、まだ実装されていない機能性に対してスタブ（代用品）を作成することが、<bpt i="1" x="1">&lt;c1&gt;</bpt>fatalError("Unimplemented")<ept i="1">&lt;/c1&gt;</ept>をスタブ実装として記述することによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>hasPrefix(_:)<ept i="0">&lt;/c0&gt;</ept> method with the <bpt i="1" x="1">&lt;c1&gt;</bpt>romeoAndJuliet<ept i="1">&lt;/c1&gt;</ept> array to count the number of scenes in Act 1 of the play:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、劇の「一幕（Act 1）」の場面の数を数えるために<bpt i="0" x="0">&lt;c0&gt;</bpt>hasPrefix(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを<bpt i="1" x="1">&lt;c1&gt;</bpt>romeoAndJuliet<ept i="1">&lt;/c1&gt;</ept>配列で使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept> operators described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Type Casting<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> to check for protocol conformance, and to cast to a specific protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>型キャスト<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述される<bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept>演算子を特定のプロトコルへキャストするために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>renamed<ept i="0">&lt;/c0&gt;</ept> argument in conjunction with the <bpt i="1" x="1">&lt;c1&gt;</bpt>unavailable<ept i="1">&lt;/c1&gt;</ept> argument and a type alias declaration to indicate to clients of your code that a declaration has been renamed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>renamed<ept i="0">&lt;/c0&gt;</ept>引数を<bpt i="1" x="1">&lt;c1&gt;</bpt>unavailable<ept i="1">&lt;/c1&gt;</ept>引数および型エイリアス宣言と連携して使うことで、あなたのコードのクライアントに宣言が改名されたを指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>startIndex<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>endIndex<ept i="1">&lt;/c1&gt;</ept> properties and the <bpt i="2" x="2">&lt;c2&gt;</bpt>index(before:)<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>index(after:)<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>index(_:offsetBy:)<ept i="4">&lt;/c4&gt;</ept> methods on any type that conforms to the <bpt i="5" x="5">&lt;c5&gt;</bpt>Collection<ept i="5">&lt;/c5&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>startIndex<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>endIndex<ept i="1">&lt;/c1&gt;</ept>プロパティそして<bpt i="2" x="2">&lt;c2&gt;</bpt>index(before:)<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>index(after:)<ept i="3">&lt;/c3&gt;</ept>、および<bpt i="4" x="4">&lt;c4&gt;</bpt>index(_:offsetBy:)メ<ept i="4">&lt;/c4&gt;</ept>ソッドを<bpt i="5" x="5">&lt;c5&gt;</bpt>Collection<ept i="5">&lt;/c5&gt;</ept>プロトコルに準拠するあらゆる型で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="3" x="3">&lt;c3&gt;</bpt>rawValue<ept i="3">&lt;/c3&gt;</ept> property to access the raw value of an enumeration case, as in <bpt i="4" x="4">&lt;c4&gt;</bpt>ExampleEnum.b.rawValue<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="3" x="3">&lt;c3&gt;</bpt>rawValue<ept i="3">&lt;/c3&gt;</ept>プロパティを使うことで列挙ケース節の生の値にアクセスできます、<bpt i="4" x="4">&lt;c4&gt;</bpt>ExampleEnum.b.rawValue<ept i="4">&lt;/c4&gt;</ept>におけるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the abbreviated form anytime the value’s type is already known.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、値の型がすでに知られているときはいつでも省略形を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the postfix <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> expression to access a type as a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、接尾辞<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>式を使って、ある型に値としてアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the the <bpt i="0" x="0">&lt;c0&gt;</bpt>insert(_:at:)<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>insert(contentsOf:at:)<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>remove(at:)<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>removeSubrange(_:)<ept i="3">&lt;/c3&gt;</ept> methods on any type that conforms to the <bpt i="4" x="4">&lt;c4&gt;</bpt>RangeReplaceableCollection<ept i="4">&lt;/c4&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>insert(_:at:)<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>insert(contentsOf:at:)<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>remove(at:)<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>removeSubrange(_:)<ept i="3">&lt;/c3&gt;</ept>メソッドを<bpt i="4" x="4">&lt;c4&gt;</bpt>RangeReplaceableCollection<ept i="4">&lt;/c4&gt;</ept>プロトコルに準拠するあらゆる型で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this argument to name classes, enumerations, enumeration cases, protocols, methods, getters, setters, and initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこの引数を、クラス、列挙、列挙ケース、プロトコル、メソッド、ゲッター、セッター、そしてイニシャライザに名前をつけるために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this failable initializer to choose an appropriate enumeration case for the three possible states and to cause initialization to fail if the parameter does not match one of these states:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、この失敗できるイニシャライザを使って、適切な列挙ケース節を３つの可能な状態に対して選び取るように、そしてパラメータが３つの状態の内の１つに合わない場合に初期化が失敗するようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this failable initializer to try to initialize a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Animal<ept i="0">&lt;/c0&gt;</ept> instance and to check if initialization succeeded:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、この失敗できるイニシャライザを使うことで、新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Animal<ept i="0">&lt;/c0&gt;</ept>インスタンスを初期化することを試みて、初期化が成功したか確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this initializer to initialize a new constant called <bpt i="3" x="3">&lt;c3&gt;</bpt>theAceOfSpades<ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="3" x="3">&lt;c3&gt;</bpt>theAceOfSpades<ept i="3">&lt;/c3&gt;</ept>と呼ばれる新しい定数を初期化するために、このイニシャライザを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this initializer to try to create a new instance of the enumeration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、このイニシャライザを使って、この列挙の新しいインスタンスを作成するように試みることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this optional return value to check whether the optional chaining call was successful (the returned optional contains a value), or did not succeed due to a <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> value in the chain (the returned optional value is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、このオプショナルの戻り値を使って、オプショナル連鎖呼び出しが成功した（返されたオプショナルが値を含む）か、あるいは連鎖の中の<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>値のために成功しなかった（返されたオプショナルの値が<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>である）かどうか確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this syntax to hard wrap a multiline string literal in your source code, without changing the value of the resulting string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、この構文を使うことで、複数行文字列リテラルをあなたのソースコードにおいてハードラップする（次行に送る）ことが、結果となる文字列の値を変更することなく行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this type like any other type in Swift, which makes it easy to pass functions as parameters to other functions, and to return functions from functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはスウィフトの他のあらゆる型と同じようにこの型を使うことができます、そしてそれは、他の関数へのパラメータとして関数を渡して、関数から関数を返すことを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use tuples to test multiple values in the same <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、複数の値を同じ<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文において試験するためにタプルを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use type casting with a hierarchy of classes and subclasses to check the type of a particular class instance and to cast that instance to another class within the same hierarchy.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、いくつかのクラスおよびサブクラスからなるある階層とともに型キャストを使って、特定のクラスインスタンスの型を調べて、そのインスタンスを同じ階層内の別のクラスにキャストすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use your own custom types as set value types or dictionary key types by making them conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> protocol from Swift’s standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなた独自のあつらえの型を集合の値型または辞書のキー型として使用することが、それらをスウィフトの標準ライブラリからの<bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>プロトコルに適合させることで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can write a closure without a name by surrounding code with braces (<bpt i="0" x="0">&lt;c0&gt;</bpt>{}<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、名前なしで波括弧（<bpt i="0" x="0">&lt;c0&gt;</bpt>{}<ept i="0">&lt;/c0&gt;</ept>）でコードを囲むことによってクロージャを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、重複を避けて、明快な、抽象化された手法で、その意図を表すコードを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can write the <bpt i="0" x="0">&lt;c0&gt;</bpt>Fahrenheit<ept i="0">&lt;/c0&gt;</ept> structure from above in a simpler form by providing a default value for its <bpt i="1" x="1">&lt;c1&gt;</bpt>temperature<ept i="1">&lt;/c1&gt;</ept> property at the point that the property is declared:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、上記の<bpt i="0" x="0">&lt;c0&gt;</bpt>Fahrenheit<ept i="0">&lt;/c0&gt;</ept>構造体を、その<bpt i="1" x="1">&lt;c1&gt;</bpt>temperature<ept i="1">&lt;/c1&gt;</ept>プロパティのために省略時の値をそのプロパティが宣言される時点で用意することによって、より単純な形式で書くことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can write the same functionality as a generic function by replacing any mention of strings with values of some type <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは同じ機能性を総称体関数として書くことが、何であれ文字列への言及部分をその代わりにある何らかの型<bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>の値で置き換えることで行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You cannot add property observers to inherited constant stored properties or inherited read-only computed properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、プロパティオブザーバーを、継承された定数保存プロパティに、または継承された読み出し専用の計算プロパティに加えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You cannot define a failable and a nonfailable initializer with the same parameter types and names.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、失敗できる及び失敗できないイニシャライザを同じパラメータの型と名前で定義することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You cannot pass a constant or a literal value as the argument, because constants and literals cannot be modified.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは引数として定数またはリテラル値を渡すことができません、なぜなら定数とリテラルは修正されることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You cannot, however, present an inherited read-write property as a read-only property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、しかし、継承された読み書き両用プロパティを、読み出し専用のプロパティとして提示することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t append a <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept> to an existing <bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept> variable, because a <bpt i="3" x="3">&lt;c3&gt;</bpt>Character<ept i="3">&lt;/c3&gt;</ept> value must contain a single character only.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept>を既存の<bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept>変数に追加することはできません、なぜなら<bpt i="3" x="3">&lt;c3&gt;</bpt>Character<ept i="3">&lt;/c3&gt;</ept>値がただ一つの文字だけを含まなければならないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t iterate over a one-sided range that omits a first value, because it isn’t clear where iteration should begin.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、最初の値を省いた片側範囲に対して反復していくことができません、なぜならどこで反復が始まるべきかが明瞭でないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t mark a variadic parameter or a return type with the <bpt i="1" x="1">&lt;c1&gt;</bpt>inout<ept i="1">&lt;/c1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、可変長パラメータまたは戻り型に<bpt i="1" x="1">&lt;c1&gt;</bpt>inout<ept i="1">&lt;/c1&gt;</ept>キーワードで印をつけることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t overload a function based only on whether the function can throw an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはある関数を、その関数がエラーをスローできるかどうかのみに基づいてオーバーロードできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t pass in <bpt i="5" x="5">&lt;e5&gt;</bpt>any<ept i="5">&lt;/e5&gt;</ept> type here, however—it has to be a type for which <bpt i="6" x="6">&lt;c6&gt;</bpt>UInt16<ept i="6">&lt;/c6&gt;</ept> provides an initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、あなたは<bpt i="5" x="5">&lt;e5&gt;</bpt>あらゆる<ept i="5">&lt;/e5&gt;</ept>型をここに渡すことはできません ― それは<bpt i="6" x="6">&lt;c6&gt;</bpt>UInt16<ept i="6">&lt;/c6&gt;</ept>がイニシャライザを提供する型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t pass the same argument to multiple in-out parameters because the order in which the copies are written back is not well defined, which means the final value of the original would also not be well defined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、同じ引数を複数のin-outパラメータに渡すことができません、なぜならコピーが書き戻される順番はうまく定義されないからです、それはオリジナルの最終的な値もまたうまく定義されないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t provide an explicit access-level modifier for an extension if you’re using that extension to add protocol conformance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがプロトコル準拠を加えるためにその拡張を使っているならば、あなたは明確なアクセス水準修飾子を拡張のために用意することが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t set a protocol requirement to a different access level than the protocol it supports.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるプロトコル要件をそれが支えるプロトコルと異なるアクセス水準に設定することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t specify a different access level for individual enumeration cases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、個々の列挙ケース節に対して異なるアクセス水準を指定することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t use <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> with nonoptional constants and variables.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を非オプショナルの定数および変数で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t use a <bpt i="0" x="0">&lt;c0&gt;</bpt>private<ept i="0">&lt;/c0&gt;</ept> type as the raw-value type of an enumeration with an <bpt i="1" x="1">&lt;c1&gt;</bpt>internal<ept i="1">&lt;/c1&gt;</ept> access level, for example.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはある<bpt i="0" x="0">&lt;c0&gt;</bpt>private<ept i="0">&lt;/c0&gt;</ept>型を、<bpt i="1" x="1">&lt;c1&gt;</bpt>internal<ept i="1">&lt;/c1&gt;</ept>のアクセス水準をもつ列挙の「生の値」型として使うことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t use an unlabeled <bpt i="2" x="2">&lt;c2&gt;</bpt>break<ept i="2">&lt;/c2&gt;</ept> statement to break out of an <bpt i="3" x="3">&lt;c3&gt;</bpt>if<ept i="3">&lt;/c3&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ラベルを付けられない<bpt i="2" x="2">&lt;c2&gt;</bpt>break<ept i="2">&lt;/c2&gt;</ept>文を<bpt i="3" x="3">&lt;c3&gt;</bpt>if<ept i="3">&lt;/c3&gt;</ept>文を脱するために使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can’t write a public protocol that inherits from an internal protocol, for example.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、例えば、内部のプロトコルから継承する公開のプロトコルを書くことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You check for an implementation of an optional method by writing a question mark after the name of the method when it’s called, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>someOptionalMethod?(someArgument)<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、それが呼ばれるときに疑問符をそのメソッドの後に書くことによって、あるオプショナルメソッドの実装について確認することができます、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>someOptionalMethod?(someArgument)<ept i="0">&lt;/c0&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You create a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept> instance by writing the type to be stored in the stack within angle brackets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Stack<ept i="0">&lt;/c0&gt;</ept>インスタンスを、角括弧の内側にそのスタックの中に格納される型を書くことによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You create a new instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept> with <bpt i="1" x="1">&lt;e1&gt;</bpt>initializer syntax<ept i="1">&lt;/e1&gt;</ept>, which is written as a type name followed by empty parentheses:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Vehicle<ept i="0">&lt;/c0&gt;</ept>の新しいインスタンスを<bpt i="1" x="1">&lt;e1&gt;</bpt>初期化構文<ept i="1">&lt;/e1&gt;</ept>を使って作成します、それは１つの型名に続く空の丸括弧として書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You declare constants with the <bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept> keyword and variables with the <bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept>キーワードを使って定数を、<bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept>キーワードを使って変数を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You define properties and methods to add functionality to your classes and structures by using exactly the same syntax as for constants, variables, and functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、機能性をあなたのクラスおよび構造体に加えるためにプロパティとメソッドを定義します、それには、定数、変数、そして関数に対するのとまったく同じ構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You define protocols in a very similar way to classes, structures, and enumerations:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、クラス、構造体、および列挙と非常に類似した方法で、プロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You define this form of a variable declaration at global scope, the local scope of a function, or in the context of a class or structure declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、変数宣言のこの形式を、グローバルなスコープ、関数のローカルなスコープで、またはクラスおよび構造体宣言の文脈において定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You define this form of a variable declaration at global scope, the local scope of a function, or in the context of a class, structure, enumeration, or extension declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、変数宣言のこの形式を、グローバルなスコープ、関数のローカルなスコープで、またはクラス、構造体、列挙、および拡張宣言の文脈において定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You define type aliases with the <bpt i="1" x="1">&lt;c1&gt;</bpt>typealias<ept i="1">&lt;/c1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="1" x="1">&lt;c1&gt;</bpt>typealias<ept i="1">&lt;/c1&gt;</ept>キーワードで型エイリアスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You define type properties with the <bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、型プロパティを<bpt i="0" x="0">&lt;c0&gt;</bpt>static<ept i="0">&lt;/c0&gt;</ept>キーワードを使って定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You do not have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなたがある継承されたイニシャライザの要件を満たすことができるならば、必須イニシャライザの明示的な実装を提供する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You do not have to provide convenience initializers if your class does not require them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのクラスがそれらを必要としないならば、あなたは便宜イニシャライザを提供する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You do not need to specify the type of the closure’s input parameter, <bpt i="1" x="1">&lt;c1&gt;</bpt>number<ept i="1">&lt;/c1&gt;</ept>, because the type can be inferred from the values in the array to be mapped.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはクロージャの入力パラメータ、<bpt i="1" x="1">&lt;c1&gt;</bpt>number<ept i="1">&lt;/c1&gt;</ept>の型を指定する必要がありません、なぜならその型が対応付けされる配列の値から推論されることができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You do not specify a precedence when defining a prefix or postfix operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、接頭辞または接尾辞演算子を定義するときに優先順位を指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You do not write the <bpt i="1" x="1">&lt;c1&gt;</bpt>override<ept i="1">&lt;/c1&gt;</ept> modifier when overriding a required designated initializer:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、必須指定イニシャライザをオーバーライドする時に<bpt i="1" x="1">&lt;c1&gt;</bpt>override<ept i="1">&lt;/c1&gt;</ept>修飾子を書きません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You do this by defining a <bpt i="0" x="0">&lt;e0&gt;</bpt>generic where clause<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこれを<bpt i="0" x="0">&lt;e0&gt;</bpt>総称体where節<ept i="0">&lt;/e0&gt;</ept>を定義する事によって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You do this by writing a complete function type immediately after the return arrow (<bpt i="0" x="0">&lt;c0&gt;</bpt>-&gt;<ept i="0">&lt;/c0&gt;</ept>) of the returning function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、返すことになる関数の戻り矢印（<bpt i="0" x="0">&lt;c0&gt;</bpt>-&gt;<ept i="0">&lt;/c0&gt;</ept>）の直後に完全な関数型を書くことによってこれをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You do this by writing the <bpt i="2" x="2">&lt;c2&gt;</bpt>break<ept i="2">&lt;/c2&gt;</ept> statement as the entire body of the case you want to ignore.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="2" x="2">&lt;c2&gt;</bpt>break<ept i="2">&lt;/c2&gt;</ept>文をあなたが無視したいケース節の全本文として書くことによってこれをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You do this with an empty extension, as described in <bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>Declaring Protocol Adoption with an Extension<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>拡張を使ってプロトコル採用を宣言する<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>で記述されるように、あなたは空の拡張でこれを行います</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You don’t know in advance which actual class to use for each item, and so it is appropriate to use the conditional form of the type cast operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>as?<ept i="2">&lt;/c2&gt;</ept>) to check the downcast each time through the loop:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、前もって、各項目のために使われる実際のクラスがどれかを知りません、なので適切なのは、型キャスト演算子の条件形式（<bpt i="2" x="2">&lt;c2&gt;</bpt>as?<ept i="2">&lt;/c2&gt;</ept>）を使用してループを通して毎回ダウンキャストを確認することです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You don’t need to define property observers for nonoverridden computed properties, because you can observe and respond to changes to their value in the computed property’s setter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、オーバーライドされていない計算プロパティのためにプロパティオブザーバーを定義する必要はありません、なぜならあなたは計算プロパティのセッターにおいてそれらの値の変化を観察して応答することができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You don’t need to import a separate library for functionality like input/output or string handling.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、入力／出力または文字列取り扱いのような機能性のために個々のライブラリをインポートする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You don’t need to mark protocol initializer implementations with the <bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept> modifier on classes that are marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>final<ept i="1">&lt;/c1&gt;</ept> modifier, because final classes can’t subclassed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>final<ept i="1">&lt;/c1&gt;</ept>修飾子で印されるクラス上でプロトコルイニシャライザ実装を<bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept>修飾子で印する必要はありません、なぜなら、finalクラスはサブクラスを作られることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You extract each associated value as a constant (with the <bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept> prefix) or a variable (with the <bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept> prefix) for use within the <bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept> case’s body:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、関連値それぞれを定数（<bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept>接頭辞を使って）または変数（<bpt i="1" x="1">&lt;c1&gt;</bpt>var<ept i="1">&lt;/c1&gt;</ept>接頭辞を使って）として<bpt i="2" x="2">&lt;c2&gt;</bpt>switch<ept i="2">&lt;/c2&gt;</ept>のケース節の本文内で使用するために抽出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You get the same behavior of delayed evaluation when you pass a closure as an argument to a function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが同じ挙動の延期した評価を得るのは、あなたがクロージャを引数として関数に渡す時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは関数にそれが何をするかについて識別する名前を与えます、そしてこの名前が必要なときその作業を実行するために関数を「呼び出す」のに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You have access to the type parameters (and any of their associated types) in the rest of the type, function, or initializer declaration, including in the signature of the function or initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、そのままの型、関数、またはイニシャライザ宣言の中の、さらに含めて関数またはイニシャライザのシグネチャの中の、型パラメータ（およびあらゆるそれの関連型）にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You have several options for writing closures more concisely.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、より簡潔にクロージャを書くためにいくつかの選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You have the option to define either or both of these observers on a property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるプロパティに関してこれらのオブザーバーのどちらかまたは両方とも定義する選択肢を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You implement a prefix or postfix unary operator by writing the <bpt i="0" x="0">&lt;c0&gt;</bpt>prefix<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>postfix<ept i="1">&lt;/c1&gt;</ept> modifier before the <bpt i="2" x="2">&lt;c2&gt;</bpt>func<ept i="2">&lt;/c2&gt;</ept> keyword when declaring the operator method:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、接頭辞または接尾辞単項演算子を、<bpt i="0" x="0">&lt;c0&gt;</bpt>prefix<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>postfix<ept i="1">&lt;/c1&gt;</ept>修飾子を<bpt i="2" x="2">&lt;c2&gt;</bpt>func<ept i="2">&lt;/c2&gt;</ept>キーワードの前に演算子メソッドを宣言するときに書くことによって実装します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You implement this initialization process by defining <bpt i="0" x="0">&lt;e0&gt;</bpt>initializers<ept i="0">&lt;/e0&gt;</ept>, which are like special methods that can be called to create a new instance of a particular type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこの初期化処理を<bpt i="0" x="0">&lt;e0&gt;</bpt>イニシャライザ<ept i="0">&lt;/e0&gt;</ept>を定義することによって実装します、それは、特定の型の新しいインスタンスをつくるために呼ばれることができる特別なメソッドのようなものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You indicate a lazy stored property by writing the <bpt i="1" x="1">&lt;c1&gt;</bpt>lazy<ept i="1">&lt;/c1&gt;</ept> modifier before its declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="1" x="1">&lt;c1&gt;</bpt>lazy<ept i="1">&lt;/c1&gt;</ept>修飾子をその宣言の前に書くことによって遅延保存プロパティであることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You indicate a weak reference by placing the <bpt i="1" x="1">&lt;c1&gt;</bpt>weak<ept i="1">&lt;/c1&gt;</ept> keyword before a property or variable declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、プロパティまたは変数の宣言の前に<bpt i="1" x="1">&lt;c1&gt;</bpt>weak<ept i="1">&lt;/c1&gt;</ept>キーワードを置くことによって弱い参照を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You indicate an unowned reference by placing the <bpt i="1" x="1">&lt;c1&gt;</bpt>unowned<ept i="1">&lt;/c1&gt;</ept> keyword before a property or variable declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、プロパティまたは変数の宣言の前に<bpt i="1" x="1">&lt;c1&gt;</bpt>unowned<ept i="1">&lt;/c1&gt;</ept>キーワードを置くことによって非所有者参照を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You indicate an unsafe unowned reference by writing <bpt i="0" x="0">&lt;c0&gt;</bpt>unowned(unsafe)<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、安全でない非所有参照を<bpt i="0" x="0">&lt;c0&gt;</bpt>unowned(unsafe)<ept i="0">&lt;/c0&gt;</ept>を書くことによって指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You indicate that an enumeration case is recursive by writing <bpt i="1" x="1">&lt;c1&gt;</bpt>indirect<ept i="1">&lt;/c1&gt;</ept> before it, which tells the compiler to insert the necessary layer of indirection.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、ある列挙ケース節が再帰することをそれの前に<bpt i="1" x="1">&lt;c1&gt;</bpt>indirect<ept i="1">&lt;/c1&gt;</ept>を書くことによって指し示します、それは、コンパイラに不可欠な間接参照の階層を差し入れるように伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You indicate the function’s return type with the <bpt i="2" x="2">&lt;e2&gt;</bpt>return arrow<ept i="2">&lt;/e2&gt;</ept> <bpt i="3" x="3">&lt;c3&gt;</bpt>-&gt;<ept i="3">&lt;/c3&gt;</ept> (a hyphen followed by a right angle bracket), which is followed by the name of the type to return.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、関数の戻り型を、<bpt i="2" x="2">&lt;e2&gt;</bpt>戻り矢印<ept i="2">&lt;/e2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>-&gt;<ept i="3">&lt;/c3&gt;</ept>（ハイフンに続けて右の山形括弧）、それに続く返す型の名前で示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You indicate type methods by writing the <bpt i="1" x="1">&lt;c1&gt;</bpt>static<ept i="1">&lt;/c1&gt;</ept> keyword before the method’s <bpt i="2" x="2">&lt;c2&gt;</bpt>func<ept i="2">&lt;/c2&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、型メソッドを<bpt i="1" x="1">&lt;c1&gt;</bpt>static<ept i="1">&lt;/c1&gt;</ept>キーワードをメソッドの<bpt i="2" x="2">&lt;c2&gt;</bpt>func<ept i="2">&lt;/c2&gt;</ept>キーワードの前に書くことによって示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You indicate whether a particular <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> can be modified (or <bpt i="1" x="1">&lt;e1&gt;</bpt>mutated<ept i="1">&lt;/e1&gt;</ept>) by assigning it to a variable (in which case it can be modified), or to a constant (in which case it can’t be modified):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、特定の<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>が修正される（または<bpt i="1" x="1">&lt;e1&gt;</bpt>変化する<ept i="1">&lt;/e1&gt;</ept>）ことができるかどうか、それを変数（その場合それは修が可能です）にまたは定数（その場合それは修正できません）に代入することによって示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You introduce classes with the <bpt i="0" x="0">&lt;c0&gt;</bpt>class<ept i="0">&lt;/c0&gt;</ept> keyword and structures with the <bpt i="1" x="1">&lt;c1&gt;</bpt>struct<ept i="1">&lt;/c1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>class<ept i="0">&lt;/c0&gt;</ept>キーワードでクラスを、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>struct<ept i="1">&lt;/c1&gt;</ept>キーワードで構造体を始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You introduce enumerations with the <bpt i="0" x="0">&lt;c0&gt;</bpt>enum<ept i="0">&lt;/c0&gt;</ept> keyword and place their entire definition within a pair of braces:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、列挙を<bpt i="0" x="0">&lt;c0&gt;</bpt>enum<ept i="0">&lt;/c0&gt;</ept>キーワードで始めて、一対の波括弧の内側にそれらの全ての定義を置きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You mark a compound assignment operator’s left input parameter type as <bpt i="3" x="3">&lt;c3&gt;</bpt>inout<ept i="3">&lt;/c3&gt;</ept>, because the parameter’s value will be modified directly from within the operator method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは複合代入演算子の左入力パラメーター型を<bpt i="3" x="3">&lt;c3&gt;</bpt>inout<ept i="3">&lt;/c3&gt;</ept>として印します、なぜなら、このパラメーターの値は直接にこの演算子メソッド内で修正されることになるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You may have noticed that the bodies of the <bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>swapTwoStrings(_:_:)<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>swapTwoDoubles(_:_:)<ept i="2">&lt;/c2&gt;</ept> functions are identical.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>swapTwoInts(_:_:)<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>swapTwoStrings(_:_:)<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>swapTwoDoubles(_:_:)<ept i="2">&lt;/c2&gt;</ept>関数の本文が同一であると気がついたかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You may, however, want to mark some parts of your code as file private or private in order to hide their implementation details from other code within the app’s module.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、しかし、あなたのコードのいくつかの部分をファイル外非公開または非公開として印して、それらの実施詳細をそのアプリのモジュール内の他のコードから隠したいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You might expect this function to have the default access level of “internal”, but this isn’t the case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこの関数が省略時アクセス水準の「内部」を持つのを期待するかもしれません、しかし事実はそうではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You might want to run an extra piece of code when an error occurs, or to display a message when a value becomes too high or too low.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、エラーが発生する時にコードの臨時の小片を実行したいかもしれません、またある値があまりに高いかあまりに低くなる時にお知らせを表示したいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You must also write the <bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept> modifier before every subclass implementation of a required initializer, to indicate that the initializer requirement applies to further subclasses in the chain.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>required<ept i="0">&lt;/c0&gt;</ept>修飾子を必須イニシャライザの全てのサブクラス実装の前に書かなければなりません、そうすることでそのイニシャライザ要件がさらにその連鎖のサブクラスに適用されることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You must always declare a lazy property as a variable (with the <bpt i="0" x="0">&lt;c0&gt;</bpt>var<ept i="0">&lt;/c0&gt;</ept> keyword), because its initial value might not be retrieved until after instance initialization completes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは常に遅延プロパティを変数として（<bpt i="0" x="0">&lt;c0&gt;</bpt>var<ept i="0">&lt;/c0&gt;</ept>キーワードを使って）宣言しなければなりません、なぜならその最初の値はインスタンスの初期化が完了する後まで取り出されないかもしれないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You must always state both the name and the type of the property you are overriding, to enable the compiler to check that your override matches a superclass property with the same name and type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、常にあなたがオーバーライドしているプロパティの名前と型を明確に述べなければなりません、そうすることであなたのオーバーライドがスーパークラスの同じ名前と型をもつプロパティと合致することをコンパイラが確認できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You must declare computed properties—including read-only computed properties—as variable properties with the <bpt i="0" x="0">&lt;c0&gt;</bpt>var<ept i="0">&lt;/c0&gt;</ept> keyword, because their value is not fixed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、計算プロパティ ― 読み出し専用の計算プロパティを含む ― を<bpt i="0" x="0">&lt;c0&gt;</bpt>var<ept i="0">&lt;/c0&gt;</ept>キーワードをつかって変数プロパティとして宣言しなければなりません、なぜならそれらの値は固定されないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You must specify the access level explicitly as part of the function’s definition if the function’s calculated access level doesn’t match the contextual default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その関数の計算されたアクセス水準が省略時の文脈に合致しないと思うならば、あなたは関数の定義の一部として明確にアクセス水準を指定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You need to mark an entity as open or public only if you want it to become part of your framework’s API.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、それにあなたのフレームワークのもつAPIの一部になってほしいならば、ある実在を開放または公開として印する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You now write <bpt i="2" x="2">&lt;c2&gt;</bpt>prefix operator<ept i="2">&lt;/c2&gt;</ept> rather than <bpt i="3" x="3">&lt;c3&gt;</bpt>operator prefix<ept i="3">&lt;/c3&gt;</ept>, for example.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは今や、例えば、<bpt i="3" x="3">&lt;c3&gt;</bpt>operator prefix<ept i="3">&lt;/c3&gt;</ept>ではなく<bpt i="2" x="2">&lt;c2&gt;</bpt>prefix operator<ept i="2">&lt;/c2&gt;</ept>と書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You pass this function an expression that evaluates to <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept> and a message to display if the result of the condition is <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこの関数に、<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>に評価する式と条件の結果が<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>であるならば表示するメッセージを渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You pass this initializer a default value of the appropriate type (called <bpt i="1" x="1">&lt;c1&gt;</bpt>repeating<ept i="1">&lt;/c1&gt;</ept>): and the number of times that value is repeated in the new array (called <bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、このイニシャライザに対して、適切な型のひとつの初期値（<bpt i="1" x="1">&lt;c1&gt;</bpt>repeating<ept i="1">&lt;/c1&gt;</ept>と呼ばれます）、そしてその値が新しい配列の中で繰り返される回数（<bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept>と呼ばれます）とを渡します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You perform this comparison with the “equal to” operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>==<ept i="2">&lt;/c2&gt;</ept>) or the “not equal to” operator (<bpt i="3" x="3">&lt;c3&gt;</bpt>!=<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、この比較を「同等」演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>==<ept i="2">&lt;/c2&gt;</ept>）または「不等」演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt>!=<ept i="3">&lt;/c3&gt;</ept>）を使って実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You place an ampersand (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;<ept i="0">&lt;/c0&gt;</ept>) directly before a variable’s name when you pass it as an argument to an in-out parameter, to indicate that it can be modified by the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは変数の名前の直前に、あなたがin-outパラメータに対する引数としてそれを渡すときに、それが関数によって修正されることができることを示すために、アンパサンド（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;<ept i="0">&lt;/c0&gt;</ept>）を置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You represent errors using any type that adopts the <bpt i="0" x="0">&lt;c0&gt;</bpt>Error<ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Error<ept i="0">&lt;/c0&gt;</ept>プロトコルを採用するどんな型でも使用してエラーを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You resolve a strong reference cycle between a closure and a class instance by defining a <bpt i="0" x="0">&lt;e0&gt;</bpt>capture list<ept i="0">&lt;/e0&gt;</ept> as part of the closure’s definition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、クロージャの定義の一部として<bpt i="0" x="0">&lt;e0&gt;</bpt>捕獲リスト<ept i="0">&lt;/e0&gt;</ept>を定義することによってクロージャとクラスインスタンスの間で強い参照循環を解消します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You resolve strong reference cycles by defining some of the relationships between classes as weak or unowned references instead of as strong references.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、クラス間の関係の一部を強い参照としてでなくて弱い、または非所有者参照として定義することによって強い参照循環を解消します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You saw above how a strong reference cycle can be created when two class instance properties hold a strong reference to each other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは上で、２つのクラスインスタンスプロパティが強い参照にお互いを守らせるとき、どのように強い参照循環がつくられることができるかを見ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You set an optional variable to a valueless state by assigning it the special value <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが、あるオプショナルの変数を値が無い状態へと設定するには、それに特別な値<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を代入します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You specify a declaration modifier by writing the appropriate keyword or context-sensitive keyword between a declaration’s attributes (if any) and the keyword that introduces the declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、宣言修飾子を適切なキーワードまたは文脈依存キーワードを宣言の属性（もしあれば）と宣言を導入するキーワードとの間に書くことによって指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You specify a default property value by assigning an initial value to the property when it is defined.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、それが定義されるときプロパティに初期値を代入することによって、省略時のプロパティ値を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You specify an attribute by writing the <bpt i="0" x="0">&lt;c0&gt;</bpt>@<ept i="0">&lt;/c0&gt;</ept> symbol followed by the attribute’s name and any arguments that the attribute accepts:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>@<ept i="0">&lt;/c0&gt;</ept>記号に続いてその属性の名前そしてその属性が受け入れる任意の引数を書くことによって属性を指定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You specify optional chaining by placing a question mark (<bpt i="0" x="0">&lt;c0&gt;</bpt>?<ept i="0">&lt;/c0&gt;</ept>) after the optional value on which you wish to call a property, method or subscript if the optional is non-<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはオプショナル連鎖を、そのオプショナルが<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>で無いならばあなたがプロパティ、メソッド、または添え字を呼び出したいオプショナルの値の後に疑問符（<bpt i="0" x="0">&lt;c0&gt;</bpt>?<ept i="0">&lt;/c0&gt;</ept>）を置くことによって指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You specify the associativity of an operator by writing one of the context-sensitive keywords <bpt i="1" x="1">&lt;c1&gt;</bpt>left<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>right<ept i="2">&lt;/c2&gt;</ept>, or <bpt i="3" x="3">&lt;c3&gt;</bpt>none<ept i="3">&lt;/c3&gt;</ept>—if your omit the associativity, the default is <bpt i="4" x="4">&lt;c4&gt;</bpt>none<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはある演算子の結合性を文脈依存キーワード<bpt i="1" x="1">&lt;c1&gt;</bpt>left<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>right<ept i="2">&lt;/c2&gt;</ept>、または<bpt i="3" x="3">&lt;c3&gt;</bpt>none<ept i="3">&lt;/c3&gt;</ept>のうちの１つを書くことによって指定します—あなたが結合性を省略するならば、初期状態は<bpt i="4" x="4">&lt;c4&gt;</bpt>none<ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You typically define a failable initializer that creates an optional instance of the appropriate type by placing a question mark after the <bpt i="0" x="0">&lt;c0&gt;</bpt>init<ept i="0">&lt;/c0&gt;</ept> keyword (<bpt i="1" x="1">&lt;c1&gt;</bpt>init?<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは一般的に、適切な型のオプショナルのインスタンスを作成する失敗できるイニシャライザを、疑問符を<bpt i="0" x="0">&lt;c0&gt;</bpt>init<ept i="0">&lt;/c0&gt;</ept>キーワードの後において（<bpt i="1" x="1">&lt;c1&gt;</bpt>init?<ept i="1">&lt;/c1&gt;</ept>）定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You typically use internal access when defining an app’s or a framework’s internal structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは概して内部アクセスを、アプリのまたはフレームワークの内部用の構造体を定義するときに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You typically use open or public access when specifying the public interface to a framework.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは概して開放または公開アクセスを、あるフレームワークに公開インタフェースを指定するときに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> to iterate over items in a dictionary by providing a pair of names to use for each key-value pair.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>を使って、辞書の中の項目のすべてに対して繰り返すことを、一対の名前を提供してそれぞれの「キーと値」の対に使用することで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use <bpt i="0" x="0">&lt;c0&gt;</bpt>try?<ept i="0">&lt;/c0&gt;</ept> to handle an error by converting it to an optional value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>try?<ept i="0">&lt;/c0&gt;</ept>を使って、あるエラーをオプショナルの値に変換することによって取り扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use <bpt i="0" x="0">&lt;e0&gt;</bpt>error handling<ept i="0">&lt;/e0&gt;</ept> to respond to error conditions your program may encounter during execution.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;e0&gt;</bpt>エラー処理<ept i="0">&lt;/e0&gt;</ept>を使ってあなたのプログラムが実行の間に遭遇するエラー状態に応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use <bpt i="0" x="0">&lt;e0&gt;</bpt>optional binding<ept i="0">&lt;/e0&gt;</ept> to find out whether an optional contains a value, and if so, to make that value available as a temporary constant or variable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるオプショナルが値を含むかどうか知るために、そしてもしそうならば、その値を一時的な定数または変数として利用可能にするために、<bpt i="0" x="0">&lt;e0&gt;</bpt>オプショナル束縛<ept i="0">&lt;/e0&gt;</ept>を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use <bpt i="0" x="0">&lt;e0&gt;</bpt>optionals<ept i="0">&lt;/e0&gt;</ept> in situations where a value may be absent.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;e0&gt;</bpt>オプショナル<ept i="0">&lt;/e0&gt;</ept>を、ある値が不在かもしれない状況において使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use a <bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept> statement to execute a set of statements just before code execution leaves the current block of code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>defer<ept i="0">&lt;/c0&gt;</ept>文を使うことで、コード実行が現在のコードブロックから離れる直前に一揃いの文を実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use a <bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> statement to handle errors by running a block of code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるコードの塊を実行することによってエラーを処理するために、<bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use a <bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept> statement to throw an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept>文を使ってエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use a <bpt i="2" x="2">&lt;c2&gt;</bpt>guard<ept i="2">&lt;/c2&gt;</ept> statement to require that a condition must be true in order for the code after the <bpt i="3" x="3">&lt;c3&gt;</bpt>guard<ept i="3">&lt;/c3&gt;</ept> statement to be executed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="2" x="2">&lt;c2&gt;</bpt>guard<ept i="2">&lt;/c2&gt;</ept>文を使って、<bpt i="3" x="3">&lt;c3&gt;</bpt>guard<ept i="3">&lt;/c3&gt;</ept>文の後のコードが実行されるためにはある条件が真でなけれればならないことを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use a dictionary when you need to look up values based on their identifier, in much the same way that a real-world dictionary is used to look up the definition for a particular word.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>現実世界の辞書が特定の語の定義を調べるために使われるのと全く同様に、あなたが値をそれらの識別子に基づいて調べる必要があるとき、あなたは辞書を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use a generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clause in a protocol declaration to add constraints to an associated types inherited from another protocol, without redeclaring the associated types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節をプロトコル宣言の中で使うことで、別のプロトコルから継承された関連型に制約を追加します、その関連型を再宣言することなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use a variadic parameter to specify that the parameter can be passed a varying number of input values when the function is called.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは可変長パラメータを、関数が呼ばれる時にそのパラメータが変動する数の入力値を渡されることができることを示すために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use an <bpt i="0" x="0">&lt;e0&gt;</bpt>availability condition<ept i="0">&lt;/e0&gt;</ept> in an <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>guard<ept i="2">&lt;/c2&gt;</ept> statement to conditionally execute a block of code, depending on whether the APIs you want to use are available at runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;e0&gt;</bpt>有効性条件<ept i="0">&lt;/e0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>guard<ept i="2">&lt;/c2&gt;</ept>文の中で使って、あなたが使用したいAPIが実行時に有効かどうかに基づいて、条件付きでコードプロックを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use an availability condition to execute a block of code, depending on whether the APIs you want to use are available at runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、有効性条件を使って、あなたが使用したいAPIが実行時に有効かどうかに基づいて、あるコードのブロックを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use assertions and preconditions to express the assumptions you make and the expectations you have while coding, so you can include them as part of your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは表明と前提条件を使うことであなたのする想定とあなたが持つ期待をコーディングの間に表します、それであなたはそれらをあなたのコードの一部として含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use function types just like any other types in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、関数型をスウィフトでのあらゆる他の型と同じように使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use it to create logical expressions in which only <bpt i="2" x="2">&lt;e2&gt;</bpt>one<ept i="2">&lt;/e2&gt;</ept> of the two values has to be <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept> for the overall expression to be <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはそれを、全体的な式が<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>になるためには２つの値のうちの<bpt i="2" x="2">&lt;e2&gt;</bpt>１つ<ept i="2">&lt;/e2&gt;</ept>だけが<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>であればよい論理式をつくるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use platform names such as <bpt i="0" x="0">&lt;c0&gt;</bpt>iOS<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>macOS<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>watchOS<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>tvOS<ept i="3">&lt;/c3&gt;</ept>—for the full list, see <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Declaration Attributes<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>iOS<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>macOS<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>watchOS<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>tvOS<ept i="3">&lt;/c3&gt;</ept>のようなプラットホーム名を使います—完全なリストのために、<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>宣言属性<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは添え字を使うことで、独立したメソッドを設定や検索のために必要とすることなしに、インデックスによって値を設定したり取得したりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop to iterate over a sequence, such as items in an array, ranges of numbers, or characters in a string.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループを、ある連続物について、例えば配列の中の項目、数の範囲、または文字列の中の文字について、それに含まれるすべてに繰り返していくために使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the <bpt i="0" x="0">&lt;c0&gt;</bpt>nonobjc<ept i="0">&lt;/c0&gt;</ept> attribute to resolve circularity for bridging methods in a class marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept> attribute, and to allow overloading of methods and initializers in a class marked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>objc<ept i="2">&lt;/c2&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="1" x="1">&lt;c1&gt;</bpt>objc<ept i="1">&lt;/c1&gt;</ept>属性で印されるクラスの中のブリッジしているメソッドに対する循環性を解決するために、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>objc<ept i="2">&lt;/c2&gt;</ept>属性で印されるクラスにおいてメソッドとイニシャライザをオーバーロードすることを許可するために<bpt i="0" x="0">&lt;c0&gt;</bpt>nonobjc<ept i="0">&lt;/c0&gt;</ept>属性を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> property to distinguish between the parameter name and the property name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>プロパティをパラメータ名とプロパティ名を区別するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> property to refer to the current instance within its own instance methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>プロパティを現在のインスタンスに言及するためにそれ自身のインスタンスメソッド内で使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the <bpt i="5" x="5">&lt;c5&gt;</bpt>case<ept i="5">&lt;/c5&gt;</ept> keyword to introduce new enumeration cases.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="5" x="5">&lt;c5&gt;</bpt>case<ept i="5">&lt;/c5&gt;</ept>キーワードを使って、新しい列挙ケース節を導入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the initializer expression in a function call expression to initialize a new instance of a type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、イニシャライザ式を関数呼び出し式において使うことで、ある型の新しいインスタンスを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use them to make sure an essential condition is satisfied before executing any further code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはそれらを使って、必要不可欠な条件が満たされるのを何らかのその先のコードが実行される前に確実なものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use these patterns in a case label of a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement, a <bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> clause of a <bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept> statement, or in the case condition of an <bpt i="3" x="3">&lt;c3&gt;</bpt>if<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>while<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>guard<ept i="5">&lt;/c5&gt;</ept>, or <bpt i="6" x="6">&lt;c6&gt;</bpt>for<ept i="6">&lt;/c6&gt;</ept>-<bpt i="7" x="7">&lt;c7&gt;</bpt>in<ept i="7">&lt;/c7&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこれらのパターンを<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文のケース節ラベル、<bpt i="2" x="2">&lt;c2&gt;</bpt>do<ept i="2">&lt;/c2&gt;</ept>文の<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>節において、または<bpt i="3" x="3">&lt;c3&gt;</bpt>if<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>while<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>guard<ept i="5">&lt;/c5&gt;</ept>、および<bpt i="6" x="6">&lt;c6&gt;</bpt>for<ept i="6">&lt;/c6&gt;</ept>-<bpt i="7" x="7">&lt;c7&gt;</bpt>in<ept i="7">&lt;/c7&gt;</ept>文のケース節条件において使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You want to draw <bpt i="0" x="0">&lt;c0&gt;</bpt>60<ept i="0">&lt;/c0&gt;</ept> tick marks, starting with the <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept> minute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>分から開始して、<bpt i="0" x="0">&lt;c0&gt;</bpt>60<ept i="0">&lt;/c0&gt;</ept>個の目盛りを描こうと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write <bpt i="1" x="1">&lt;c1&gt;</bpt>return nil<ept i="1">&lt;/c1&gt;</ept> within a failable initializer to indicate a point at which initialization failure can be triggered.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは失敗できるイニシャライザの内部で<bpt i="1" x="1">&lt;c1&gt;</bpt>return nil<ept i="1">&lt;/c1&gt;</ept>を書くことで、そこにおいて初期化失敗が引き起こされる可能性がある地点を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write a failable initializer by placing a question mark after the <bpt i="0" x="0">&lt;c0&gt;</bpt>init<ept i="0">&lt;/c0&gt;</ept> keyword (<bpt i="1" x="1">&lt;c1&gt;</bpt>init?<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、失敗可能なイニシャライザを疑問符を<bpt i="0" x="0">&lt;c0&gt;</bpt>init<ept i="0">&lt;/c0&gt;</ept>キーワードの後に置くこと（<bpt i="1" x="1">&lt;c1&gt;</bpt>init?<ept i="1">&lt;/c1&gt;</ept>）によって記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write a generic <bpt i="4" x="4">&lt;c4&gt;</bpt>where<ept i="4">&lt;/c4&gt;</ept> clause right before the opening curly brace of a type or function’s body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、総称体<bpt i="4" x="4">&lt;c4&gt;</bpt>where<ept i="4">&lt;/c4&gt;</ept>節を、型や関数のもつ本文の開き波括弧のまさに前に記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write a pattern after <bpt i="0" x="0">&lt;c0&gt;</bpt>catch<ept i="0">&lt;/c0&gt;</ept> to indicate what errors that clause can handle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>catch<ept i="0">&lt;/c0&gt;</ept>の後にあるパターンを書いてどんなエラーをその節が取り扱えるかを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write a pattern after <bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> just as you do after <bpt i="2" x="2">&lt;c2&gt;</bpt>case<ept i="2">&lt;/c2&gt;</ept> in a switch.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、まさにあなたがスイッチにおいて<bpt i="2" x="2">&lt;c2&gt;</bpt>case<ept i="2">&lt;/c2&gt;</ept>の後にするように、<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>の後にひとつのパターンを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write a precondition by calling the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>precondition(_:_:file:line:)<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、前提条件を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>precondition(_:_:file:line:)<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を呼び出すことによって記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write an argument label before the parameter name, separated by a space:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは引数ラベルを、パラメーター名の前に、空白で区切って書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write an assertion by calling the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>assert(_:_:file:line:)<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function from the Swift standard library.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは表明を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>assert(_:_:file:line:)<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数をSwift標準ライブラリから呼び出すことによって記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write an implicitly unwrapped optional by placing an exclamation mark (<bpt i="1" x="1">&lt;c1&gt;</bpt>String!<ept i="1">&lt;/c1&gt;</ept>) rather than a question mark (<bpt i="2" x="2">&lt;c2&gt;</bpt>String?<ept i="2">&lt;/c2&gt;</ept>) after the type that you want to make optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは暗黙的にアンラップされるオプショナルを、あなたがオプショナルを作りたい型の後に疑問符（<bpt i="2" x="2">&lt;c2&gt;</bpt>String?<ept i="2">&lt;/c2&gt;</ept>）ではなく感嘆符（<bpt i="1" x="1">&lt;c1&gt;</bpt>String!<ept i="1">&lt;/c1&gt;</ept>）を置くことによって記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write an in-out parameter by placing the <bpt i="0" x="0">&lt;c0&gt;</bpt>inout<ept i="0">&lt;/c0&gt;</ept> keyword right before a parameter’s type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、パラメータの型のすぐ前に<bpt i="0" x="0">&lt;c0&gt;</bpt>inout<ept i="0">&lt;/c0&gt;</ept>キーワードを置くことによってin-outパラメータを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write an instance method within the opening and closing braces of the type it belongs to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、インスタンスメソッドを、それが属している型の開始と終わりの波括弧の内部に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write an optional tuple return type by placing a question mark after the tuple type’s closing parenthesis, such as <bpt i="2" x="2">&lt;c2&gt;</bpt>(Int, Int)?<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>(String, Int, Bool)?<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはオプショナルタプルの戻り型をタプル型の閉じ括弧の後に疑問符を置くことによって書きます、例えば<bpt i="2" x="2">&lt;c2&gt;</bpt>(Int、Int)?<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>(String、Int、Bool)?<ept i="3">&lt;/c3&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write deinitializers with the <bpt i="1" x="1">&lt;c1&gt;</bpt>deinit<ept i="1">&lt;/c1&gt;</ept> keyword, similar to how initializers are written with the <bpt i="2" x="2">&lt;c2&gt;</bpt>init<ept i="2">&lt;/c2&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、イニシャライザが<bpt i="2" x="2">&lt;c2&gt;</bpt>init<ept i="2">&lt;/c2&gt;</ept>キーワードで書かれる方法と同様に、デイニシャライザを<bpt i="1" x="1">&lt;c1&gt;</bpt>deinit<ept i="1">&lt;/c1&gt;</ept>キーワードを使って書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write nested comments by starting a multiline comment block and then starting a second multiline comment within the first block.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはひとつの複数行コメント・ブロックを始めて、それから第二の複数行を最初のブロック以内に始めることによって入れ子にされたコメントを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write subscript definitions with the <bpt i="0" x="0">&lt;c0&gt;</bpt>subscript<ept i="0">&lt;/c0&gt;</ept> keyword, and specify one or more input parameters and a return type, in the same way as instance methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、添え字定義を<bpt i="0" x="0">&lt;c0&gt;</bpt>subscript<ept i="0">&lt;/c0&gt;</ept>キーワードを使って書きます、そしてインスタンスメソッドと同じ方法で、一つ以上の入力パラメータと戻り型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write the placeholder type name inside angle brackets after <bpt i="1" x="1">&lt;c1&gt;</bpt>subscript<ept i="1">&lt;/c1&gt;</ept>, and you write a generic <bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept> clause right before the opening curly brace of the subscript’s body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、プレースホルダ型名を山括弧の内部に<bpt i="1" x="1">&lt;c1&gt;</bpt>subscript<ept i="1">&lt;/c1&gt;</ept>の後に書きます、そしてあなたは総称体<bpt i="2" x="2">&lt;c2&gt;</bpt>where<ept i="2">&lt;/c2&gt;</ept>節を添え字本文の開き波括弧の直前に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write these constraints after the name of the protocol you’re extending using a generic <bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept> clause, as described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Generic Where Clauses<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、これらの制約をあなたが拡張しているプロトコルの名前の後に、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>総称体where節<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述される総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>where<ept i="0">&lt;/c0&gt;</ept>節を使って書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write these initializers as part of the protocol’s definition in exactly the same way as for normal initializers, but without curly braces or an initializer body:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、これらのイニシャライザをプロトコル定義の一部として普通のイニシャライザと正確に同じ方法で書くことができます、しかし波括弧またはイニシャライザ本文はありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You write type constraints by placing a single class or protocol constraint after a type parameter’s name, separated by a colon, as part of the type parameter list.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、型パラメーターリストの一部として、型パラメータの名前の後にコロンで区切って一つのクラスまたはプロトコル制約を置くことによって、型制約を書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You’re not limited to the predefined operators.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あらかじめ定義された演算子に制限されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You’ve actually been using value types extensively throughout the previous chapters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、実際に前の章を通して広く値型を使っていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Zeros are inserted in the spaces left behind after the original bits are moved to the left or right.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>元のビットが左または右へ移動した後に残される空きに、ゼロが差し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Zeros become ones, and ones become zeros.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ゼロは１になります、そして１はゼロになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>but is written over multiple lines.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（しかし複数行にわたって書かれます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>giving a remainder value of <bpt i="0" x="0">&lt;c0&gt;</bpt>-1<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そして<bpt i="0" x="0">&lt;c0&gt;</bpt>-1<ept i="0">&lt;/c0&gt;</ept>の余り値を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>where <bpt i="0" x="0">&lt;c0&gt;</bpt>some multiplier<ept i="0">&lt;/c0&gt;</ept> is the largest number of multiples of <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept> that will fit inside <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここで<bpt i="0" x="0">&lt;c0&gt;</bpt>いくらかの乗数<ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>の内部に収まる<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>の倍数の最も大きな数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>“A function that has two parameters, both of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>, and that returns a value of type <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「２つのパラメータを持ち、両方とも型<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>で、そして型<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>の値をひとつ返す関数」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>“Consider the value of <bpt i="0" x="0">&lt;c0&gt;</bpt>directionToHead<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「<bpt i="0" x="0">&lt;c0&gt;</bpt>directionToHead<ept i="0">&lt;/c0&gt;</ept>の値を考慮する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>“Declare a new constant called <bpt i="0" x="0">&lt;c0&gt;</bpt>maximumNumberOfLoginAttempts<ept i="0">&lt;/c0&gt;</ept>, and give it a value of <bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「<bpt i="0" x="0">&lt;c0&gt;</bpt>maximumNumberOfLoginAttempts<ept i="0">&lt;/c0&gt;</ept>と呼ばれるある新しい定数を宣言して、それに<bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>というひとつの値を与える。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>“Declare a variable called <bpt i="0" x="0">&lt;c0&gt;</bpt>welcomeMessage<ept i="0">&lt;/c0&gt;</ept> that is of type <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「<bpt i="0" x="0">&lt;c0&gt;</bpt>welcomeMessage<ept i="0">&lt;/c0&gt;</ept>と呼ばれる型<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>の変数を宣言する。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>“Define a variable called <bpt i="0" x="0">&lt;c0&gt;</bpt>mathFunction<ept i="0">&lt;/c0&gt;</ept>, which has a type of ‘a function that takes two <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> values, and returns an <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> value.’ Set this new variable to refer to the function called <bpt i="3" x="3">&lt;c3&gt;</bpt>addTwoInts<ept i="3">&lt;/c3&gt;</ept>.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「『２つの<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値をとり、１つの<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>値を返す関数』の型を持ち、<bpt i="0" x="0">&lt;c0&gt;</bpt>mathFunction<ept i="0">&lt;/c0&gt;</ept>と呼ばれる、ある変数を定義する。この新しい変数を<bpt i="3" x="3">&lt;c3&gt;</bpt>addTwoInts<ept i="3">&lt;/c3&gt;</ept>と呼ばれる関数に言及するように設定する。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>“Define an enumeration type called <bpt i="0" x="0">&lt;c0&gt;</bpt>Barcode<ept i="0">&lt;/c0&gt;</ept>, which can take either a value of <bpt i="1" x="1">&lt;c1&gt;</bpt>upc<ept i="1">&lt;/c1&gt;</ept> with an associated value of type (<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>), or a value of <bpt i="6" x="6">&lt;c6&gt;</bpt>qrCode<ept i="6">&lt;/c6&gt;</ept> with an associated value of type <bpt i="7" x="7">&lt;c7&gt;</bpt>String<ept i="7">&lt;/c7&gt;</ept>.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「<bpt i="0" x="0">&lt;c0&gt;</bpt>Barcode<ept i="0">&lt;/c0&gt;</ept>と呼ばれる列挙型を定義します、それは型（<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>）の関連値をもつ<bpt i="1" x="1">&lt;c1&gt;</bpt>upc<ept i="1">&lt;/c1&gt;</ept>の値、または型<bpt i="7" x="7">&lt;c7&gt;</bpt>String<ept i="7">&lt;/c7&gt;</ept>の関連値をもつ<bpt i="6" x="6">&lt;c6&gt;</bpt>qRCode<ept i="6">&lt;/c6&gt;</ept>の値をとることができます。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>“Equal to” means that two instances are considered “equal” or “equivalent” in value, for some appropriate meaning of “equal”, as defined by the type’s designer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「同等」は、２つのインスタンスが、値で「等しい」あるいは「相当する」と、ある適切な「等しい」の意味で、型の設計者によって定義されたとおりに、考慮されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>“Identical to” means that two constants or variables of class type refer to exactly the same class instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「同一」は、クラス型の２つの定数または変数が、正確に同じクラスインスタンスに言及することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>“If the optional <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> returned by <bpt i="1" x="1">&lt;c1&gt;</bpt>Int(possibleNumber)<ept i="1">&lt;/c1&gt;</ept> contains a value, set a new constant called <bpt i="2" x="2">&lt;c2&gt;</bpt>actualNumber<ept i="2">&lt;/c2&gt;</ept> to the value contained in the optional.”</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「<bpt i="1" x="1">&lt;c1&gt;</bpt>Int(possibleNumber)<ept i="1">&lt;/c1&gt;</ept>によって返されるオプショナルの<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>が値を含むならば、ある新しい定数<bpt i="2" x="2">&lt;c2&gt;</bpt>actualNumber<ept i="2">&lt;/c2&gt;</ept>をそのオプショナルに含まれる値に設定してください。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>“Try to access <bpt i="0" x="0">&lt;c0&gt;</bpt>item<ept i="0">&lt;/c0&gt;</ept> as a <bpt i="1" x="1">&lt;c1&gt;</bpt>Movie<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「<bpt i="0" x="0">&lt;c0&gt;</bpt>item<ept i="0">&lt;/c0&gt;</ept>に<bpt i="1" x="1">&lt;c1&gt;</bpt>Movie<ept i="1">&lt;/c1&gt;</ept>としてアクセスを試みてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>…and so on.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>…などなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>…and so on:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>…などなど：</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
