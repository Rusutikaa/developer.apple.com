<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.1.1_0_9688" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(You’ll learn more about the product module name later, in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Naming Your Product Module<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（あなたは後で製品モジュール名について<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>「あなたの製品モジュールに名前をつける」<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>でさらに学びます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>(You’ll learn more about the product module name later, in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Naming Your Product Module<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（あなたは後で製品モジュール名について<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>「あなたの製品モジュールに名前をつける」<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>でさらに学びます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Configure cell</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（セルを構成設定する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Insert code here to add functionality to your managed object subclass</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（コードをここに挿入して機能性をあなたの管理オブジェクトサブクラスに加えます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Method is available for use.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（メソッドは利用に応じられます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Method is not available.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（メソッドは利用できません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Not a compile-time error because NSDictionary has this selector.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（コンパイル時エラーでは無い、なぜならNSDictionaryはこのセレクタを持つからです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// Raises an exception because NSArray does not respond to this selector.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（例外を引き起こします、なぜならNSArrayはこのセレクタに応答しないからです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// amenities is an NSSet object containing three values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（amenitiesは３つの値を含んでいるNSSetオブジェクトです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// code that creates autoreleased objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（オートリリースされるオブジェクトを作成するコード）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// conditional branch not executed</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（条件分岐は実行されません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// could not load the image</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（画像を読み込めなかった）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// crash, myObject doesn't respond to that method</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（失敗、myObjectはこのメソッドに応答することができません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// define the class</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（クラスを定義する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// error: only available on iOS 8.0 or newer</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（エラー：iOS 8.0以降でのみ利用可能）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// loaded the image successfully</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（画像をうまく読み込んだ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// medalRankings is an NSDictionary object containing three key-value pairs</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（medalRankingsは、NSDictionaryオブジェクトでキー値ペアを含んでいます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// memoryManagedResult is a memory managed CFString</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（memoryManagedResultは、メモリ管理されるCFStringです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// myChar has unichar? type and nil value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（myCharはunichar?型でNSDatenilを持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// myCount has Int? type and nil value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（myCountはInt?型でnil値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// myObject has AnyObject type and NSDate value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（myObjectはAnyObject型でNSDate値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// object conforms to UITableViewDataSource and is bound to dataSource</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（オブジェクトは、UITableViewDataSourceに準拠して、dataSourceに結束されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// object could not be cast to type UIButton</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（オブジェクトは、型UIButtonにキャストされることができませんでした）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// object is not of type UIButton</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（オブジェクトは、型UIButtonではありません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// object is of type UIButton</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（オブジェクトは、型UIButtonです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// object is successfully cast to type UIButton and bound to button</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（オブジェクトは、型UIButtonにうまくキャストされて、buttonに束縛されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// object not conform to UITableViewDataSource</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（オブジェクトは、UITableViewDataSourceに準拠しません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// offsetPointer is 24 strides ahead of pointer</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（offsetPointerは、pointerの前方24ストライドです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// play song or throw an error if unavailable</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（曲を再生するか利用可能でないならばエラーをスローする）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>// schoolSupplies is an NSArray object containing three values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>（schoolSuppliesは３つの値を含んでいるNSArrayオブジェクトです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;=<ept i="0">&lt;/c0&gt;</ept> followed by a version number</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;=<ept i="0">&lt;/c0&gt;</ept>にバージョン番号が続きます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>NSString<ept i="2">&lt;/c2&gt;</ept> methods that express length, character indexes, or ranges in terms of 16-bit platform-endian values have corresponding Swift <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> methods that use <bpt i="4" x="4">&lt;c4&gt;</bpt>String.Index<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>Range&lt;String.Index&gt;<ept i="5">&lt;/c5&gt;</ept> values rather than <bpt i="6" x="6">&lt;c6&gt;</bpt>Int<ept i="6">&lt;/c6&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt>NSRange<ept i="7">&lt;/c7&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>16ビットのプラットホームエンディアンの値の観点から長さ、文字インデックス、または範囲を表す<bpt i="2" x="2">&lt;c2&gt;</bpt>NSString<ept i="2">&lt;/c2&gt;</ept>メソッドは、対応するスウィフトの<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>メソッドを持ちます、それは<bpt i="4" x="4">&lt;c4&gt;</bpt>String.Index<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>Range&lt;String.Index&gt;<ept i="5">&lt;/c5&gt;</ept>値を使います、<bpt i="6" x="6">&lt;c6&gt;</bpt>Int<ept i="6">&lt;/c6&gt;</ept>と<bpt i="7" x="7">&lt;c7&gt;</bpt>NSRange<ept i="7">&lt;/c7&gt;</ept>値ではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Extensions<ept i="0">&lt;/e0&gt;</ept> expand the behavior of existing classes, structures, and enumerations, including those defined in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>拡張<ept i="0">&lt;/e0&gt;</ept>は、既存のクラス、構造体、そして列挙の挙動を、Objective-Cで定義されるそれらを含めて、発展させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Interoperability<ept i="0">&lt;/e0&gt;</ept> is the ability to interface between Swift and Objective-C in either direction, letting you access and use pieces of code written in one language in a file of the other language.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>相互運用性<ept i="0">&lt;/e0&gt;</ept>は、スウィフトとObjective-Cの間でどちらの方向からでも調和させ、あなたに一方の言語で書かれるコード断片を他方の言語のファイルの中でアクセスおよび使用させる能力です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Migration<ept i="0">&lt;/e0&gt;</ept> provides an opportunity to revisit an existing Objective-C app and improve its architecture, logic, and performance by replacing pieces of it in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>移行<ept i="0">&lt;/e0&gt;</ept>は、既存のObjective-Cアプリを再検討するための、およびその設計仕様、論理、そして性能をそれの一部をスウィフトにおいて取り替えることによって向上させるための機会を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>Interoperability<ept i="0">&lt;/s0&gt;</ept> lets you interface between Swift and Objective-C code, allowing you to use Swift classes in Objective-C and to take advantage of familiar Cocoa classes, patterns, and practices when writing Swift code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>相互運用性<ept i="0">&lt;/s0&gt;</ept>は、あなたにスウィフトとObjective-Cコードの間を円滑に相互運用させて、スウィフトクラスをObjective-Cにおいて使用できるように、そしてスウィフトコードを書く場合には、よく知られているココア・クラス、パターン、および慣行を利用できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>Migration<ept i="0">&lt;/s0&gt;</ept> from existing Objective-C code to Swift is made easy with interoperability and mix and match, making it possible to replace parts of your Objective-C apps with the latest Swift features.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>移行<ept i="0">&lt;/s0&gt;</ept>。既存のObjective-Cコードからスウィフトへの移行は、相互運用性および混合と適合によって簡単にされます、そして、あなたのObjective-Cアプリの一部を最新のスウィフト特徴で取り替えることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>Mix and match<ept i="0">&lt;/s0&gt;</ept> allows you to create mixed-language apps containing both Swift and Objective-C files that can communicate with each other.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>混合と適合<ept i="0">&lt;/s0&gt;</ept>は、あなたにお互いと通信することができるスウィフトとObjective-Cファイルを含んでいる混合言語アプリを作成することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="5" x="5">&lt;s5&gt;</bpt>// Received an NSNull value.<ept i="5">&lt;/s5&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="5" x="5">&lt;s5&gt;</bpt>（NSNull値を受け取った。）<ept i="5">&lt;/s5&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg><bpt i="6" x="6">&lt;s6&gt;</bpt>// lastRefreshDate is of type Any?<ept i="6">&lt;/s6&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="6" x="6">&lt;s6&gt;</bpt>（lastRefreshDateは型Any?です）<ept i="6">&lt;/s6&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> value, if <bpt i="1" x="1">&lt;c1&gt;</bpt>Type<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Int8<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつの<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>値、<bpt i="1" x="1">&lt;c1&gt;</bpt>Type<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Int8<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept>であるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>[Type]<ept i="0">&lt;/c0&gt;</ept> value, which is passed as a pointer to the start of the array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつの<bpt i="0" x="0">&lt;c0&gt;</bpt>[Type]<ept i="0">&lt;/c0&gt;</ept>値、それは配列の始まりへのポインターとして渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>buffer pointer<ept i="0">&lt;/e0&gt;</ept> is used for low-level access to a region of memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>バッファポインタ<ept i="0">&lt;/e0&gt;</ept>は、メモリのある領域への低水準アクセスのために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>compilation condition<ept i="0">&lt;/e0&gt;</ept> can include the literal <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept> values, custom conditional compilation flags (specified using <bpt i="3" x="3">&lt;c3&gt;</bpt>-D &lt;#flag#&gt;<ept i="3">&lt;/c3&gt;</ept>), and the platform conditions listed in the table below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>コンパイル条件<ept i="0">&lt;/e0&gt;</ept>は、リテラルの<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>値、誂えの条件コンパイルフラグ（<bpt i="3" x="3">&lt;c3&gt;</bpt>-D &lt;#flag#&gt;<ept i="3">&lt;/c3&gt;</ept>を使って指定される）、そして以下の表で一覧にされるプラットホーム条件を含むことができます、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>lazy property<ept i="0">&lt;/e0&gt;</ept> is a property whose underlying value is only initialized when the property is first accessed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>遅延プロパティ<ept i="0">&lt;/e0&gt;</ept>は、それの裏に潜んだ値が初期化されるのがそのプロパティが最初にアクセスされる時にして初めてというプロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A <bpt i="1" x="1">&lt;e1&gt;</bpt>key path<ept i="1">&lt;/e1&gt;</ept> is a string of dot-separated keys that specifies a sequence of object properties to traverse.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;e1&gt;</bpt>キーパス<ept i="1">&lt;/e1&gt;</ept>は、ドットで区切られたいくらかのキーからなる文字列で、巡回していく一連のオブジェクトプロパティを指定するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A C enumeration that is not marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_ENUM<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>NS_OPTIONS<ept i="1">&lt;/c1&gt;</ept> macro is imported as a Swift structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS_ENUM<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>NS_OPTIONS<ept i="1">&lt;/c1&gt;</ept>マクロで印されないC列挙は、スウィフト構造体としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Swift app target is a module itself, so the fully qualified name of a Swift class named <bpt i="3" x="3">&lt;c3&gt;</bpt>Observer<ept i="3">&lt;/c3&gt;</ept> in an app called <bpt i="4" x="4">&lt;c4&gt;</bpt>MyGreatApp<ept i="4">&lt;/c4&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>MyGreatApp.Observer<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるスウィフトアプリ・ターゲートは、あるモジュールそれ自体です、なので<bpt i="3" x="3">&lt;c3&gt;</bpt>MyGreatApp<ept i="3">&lt;/c3&gt;</ept>と呼ばれるあるアプリの中の<bpt i="4" x="4">&lt;c4&gt;</bpt>Observer<ept i="4">&lt;/c4&gt;</ept>と命名されるあるスウィフトクラスの完全修飾名は、<bpt i="5" x="5">&lt;c5&gt;</bpt>MyGreatApp.Observer<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Swift class must be a descendant of an Objective-C class to be accessible and usable in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトクラスは、Objective-Cにおいてアクセス可能および利用可能であるためにはObjective-Cクラスの子孫でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Swift extension is similar to an Objective-C category.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの拡張は、Objective-Cのカテゴリーに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Swift project’s structure is nearly identical to an Objective-C project, with one important distinction: Swift has no header files.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトプロジェクトの構造は、Objective-Cプロジェクトにほとんど同一ですが、１つの重要な違いがあります：スウィフトには、ヘッダ・ファイルがありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A Swift subclass gets all the functionality offered by the superclass in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのサブクラスは、Objective-Cでのスーパークラスによって提供される全ての機能性を獲得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A key-path expression accepts property references and chained property references, such as <bpt i="3" x="3">&lt;c3&gt;</bpt>\Animal.name.count<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパス式は、プロパティ参照そして数珠つなぎにされたプロパティ参照を受け入れます、例えば<bpt i="3" x="3">&lt;c3&gt;</bpt>\Animal.name.count<ept i="3">&lt;/c3&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A method annotated with the <bpt i="0" x="0">&lt;c0&gt;</bpt>@available<ept i="0">&lt;/c0&gt;</ept> attribute can safely use APIs available to the specified platform requirements without the use of an explicit availability check.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@available<ept i="0">&lt;/c0&gt;</ept>属性で注釈を付けられるメソッドは、指定されたプラッホーム要件で利用可能なAPIを明確に有効性確認を使うことなく安全に使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A non-optional pointer type cannot be assigned a <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非オプショナルポインタ型は、<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>値を割り当てられることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A parameterized class written in Objective-C is imported into Swift as a generic class with the same number of type parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cにおいて書かれたパラメータ化されたクラスは、同じ数の型パラメータを持つ総称体クラスとしスウィフトにインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>A protocol declares all initializers, properties, subscripts, and methods that an Objective-C class must implement in order to conform to the protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルは、Objective-Cクラスがそのプロトコルに準拠するために実装しなければならない全てのイニシャライザ、プロパティ、添え字、そしてメソッドを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>API Availability</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>API有効性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing Properties</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessing arguments using <bpt i="0" x="0">&lt;c0&gt;</bpt>CommandLine.arguments<ept i="0">&lt;/c0&gt;</ept> is equivalent to accessing the <bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>arguments<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> property on <bpt i="3" x="3">&lt;c3&gt;</bpt>ProcessInfo.processInfo<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>CommandLine.arguments<ept i="0">&lt;/c0&gt;</ept>を使って引数にアクセスすることは、<bpt i="1" x="1">&lt;c1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>arguments<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロパティに<bpt i="3" x="3">&lt;c3&gt;</bpt>ProcessInfo.processInfo<ept i="3">&lt;/c3&gt;</ept>上でアクセスすることと等価です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Accessor property attributes (<bpt i="0" x="0">&lt;c0&gt;</bpt>getter=<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>setter=<ept i="1">&lt;/c1&gt;</ept>) are ignored by Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセッサプロパティ属性（<bpt i="0" x="0">&lt;c0&gt;</bpt>getter=<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>setter=<ept i="1">&lt;/c1&gt;</ept>）は、スウィフトによって無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add the <bpt i="0" x="0">&lt;c0&gt;</bpt>@NSManaged<ept i="0">&lt;/c0&gt;</ept> attribute to each property or method declaration in your managed object subclass that corresponds to an attribute or relationship in your Core Data model.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコアデータモデルの中の属性またはリレーションシップに対応する、あなたの管理オブジェクトのサブクラスにおけるプロパティまたはメソッド宣言それぞれに、<bpt i="0" x="0">&lt;c0&gt;</bpt>@NSManaged<ept i="0">&lt;/c0&gt;</ept>属性を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Add the <bpt i="0" x="0">&lt;c0&gt;</bpt>dynamic<ept i="0">&lt;/c0&gt;</ept> modifier and <bpt i="1" x="1">&lt;c1&gt;</bpt>@objc<ept i="1">&lt;/c1&gt;</ept> attribute to any property you want to observe.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>dynamic<ept i="0">&lt;/c0&gt;</ept>修飾子と<bpt i="1" x="1">&lt;c1&gt;</bpt>@objc<ept i="1">&lt;/c1&gt;</ept>属性をあなたが監視したい何らかのプロパティに加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a note about Swift target system requirements for executables built from the command line in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Setting Up Your Swift Environment<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コマンドラインからビルドされる実行形式に対するスウィフトターゲットシステム要件についての注意を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>あなたのスウィフト環境を設定する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a note to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Enumerations<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section about initializing imported C enumerations with raw values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポートされたC列挙を生の値で初期化することについての注意を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>列挙<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added a note to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Option Sets<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about imported C enumerations cases that have a value of <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>注釈を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オプションセット<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節へ加えて<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>の値を持つインポートされたC列挙ケース節についての情報を持たせた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added an example of the syntax for initializing unnamed fields to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Unnamed Structure and Union Fields<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無名フィールドを初期化するための構文の例を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>無名構造体と共用体フィールド<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added an implementation of <bpt i="0" x="0">&lt;c0&gt;</bpt>deinit<ept i="0">&lt;/c0&gt;</ept> and a call to <bpt i="1" x="1">&lt;c1&gt;</bpt>super<ept i="1">&lt;/c1&gt;</ept> in the last code sample in the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Key-Value Observing<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>deinit<ept i="0">&lt;/c0&gt;</ept>の実装と<bpt i="1" x="1">&lt;c1&gt;</bpt>super<ept i="1">&lt;/c1&gt;</ept>への呼び出しを<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>キー値監視<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>節での最後のコード例に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about Objective-C class properties to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Accessing Properties<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cクラスプロパティについての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロパティにアクセスする<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about autorelease pool blocks and the <bpt i="0" x="0">&lt;c0&gt;</bpt>autoreleasepool(_:)<ept i="0">&lt;/c0&gt;</ept> function in the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Autorelease Pools<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オートリリースプール・ブロックおよび<bpt i="0" x="0">&lt;c0&gt;</bpt>autoreleasepool(_:)<ept i="0">&lt;/c0&gt;</ept>関数についての情報を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>オートリリースプール<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about bridged value types and renamed types in the Swift Foundation overlay to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Working with Cocoa Frameworks<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift Foundationオーバーレイにおけるブリッジされた値型と新しい名前をつけられた型についての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ココアフレームワークを扱う<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>章へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about bridging between <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NSDictionary<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>NSDictionary<ept i="1">&lt;/c1&gt;</ept>の間のブリッジについての情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about defining a Swift protocol that Objective-C classes can conform to in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Declaring Protocols<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Declaring a Swift Protocol That Can Be Adopted by an Objective-C Class<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> sections.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cクラスが準拠することができるスウィフトプロトコルを定義することについての情報を、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコルを宣言する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>および<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Objective-Cクラスによって採用されることができるスウィフトプロトコルを宣言する<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about global constants annotated with the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_STRING_ENUM<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NS_EXTENSIBLE_STRING_ENUM<ept i="1">&lt;/c1&gt;</ept> macros and functions annotated with the <bpt i="2" x="2">&lt;c2&gt;</bpt>CF_SWIFT_NAME<ept i="2">&lt;/c2&gt;</ept> macro to the <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Interacting with C APIs<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS_STRING_ENUM<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>NS_EXTENSIBLE_STRING_ENUM<ept i="1">&lt;/c1&gt;</ept>マクロで注釈を付けられたグローバル定数および<bpt i="2" x="2">&lt;c2&gt;</bpt>CF_SWIFT_NAME<ept i="2">&lt;/c2&gt;</ept>マクロで注釈を付けられた関数についての情報を<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>C APIとの相互作用<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>章へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about how <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> is bridged to <bpt i="1" x="1">&lt;c1&gt;</bpt>NSNull<ept i="1">&lt;/c1&gt;</ept> to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Bridging Optionals to Nonnullable Objects<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>NSNull<ept i="1">&lt;/c1&gt;</ept>へとブリッジされる方法についての情報を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>オプショナルをnull不可オブジェクトへブリッジする<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about how nullable pointers are imported as optionals to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Null Pointers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>null許容ポインタがオプショナルとしてインポートされる方法についての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>nullポインタ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about how some Objective-C structures are bridged as instances of the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSValue<ept i="0">&lt;/c0&gt;</ept> class to the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Cocoa Structures<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかのObjective-C構造体が<bpt i="0" x="0">&lt;c0&gt;</bpt>NSValue<ept i="0">&lt;/c0&gt;</ept>クラスのインスタンスとしてブリッジされる方法についての情報を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Cocoa構造体<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about imported Objective-C classes with generic parameterization to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Lightweight Generics<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体パラメータ表現でインポートされたObjective-Cクラスについての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>軽量総称体<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about low-level access to memory to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Buffer Pointers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリへの低水準アクセスについての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>バッファポインタ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about performing unsafe pointer operations to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Pointer Arithmetic<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>非安全ポインタ操作を実行することについての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ポインタ算術<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the <bpt i="0" x="0">&lt;c0&gt;</bpt>#keyPath<ept i="0">&lt;/c0&gt;</ept> expression to the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Keys and Key Paths<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>#keyPath<ept i="0">&lt;/c0&gt;</ept>式についての情報を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>キーとキーパス<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>章へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the <bpt i="0" x="0">&lt;c0&gt;</bpt>#selector<ept i="0">&lt;/c0&gt;</ept> expression to the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Selectors<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>#selector<ept i="0">&lt;/c0&gt;</ept>式についての情報を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>セレクタ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_TYPED_ENUM<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NS_TYPED_EXTENSIBLE_ENUM<ept i="1">&lt;/c1&gt;</ept> macros to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Imported Constant Enumerations and Structures<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS_TYPED_ENUM<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>NS_TYPED_EXTENSIBLE_ENUM<ept i="1">&lt;/c1&gt;</ept>マクロについての情報を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>インポートされる定数列挙と構造体<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the <bpt i="0" x="0">&lt;c0&gt;</bpt>os_log(_:dso:log:type:_:)<ept i="0">&lt;/c0&gt;</ept> function in the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Unified Logging<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>os_log(_:dso:log:type:_:)<ept i="0">&lt;/c0&gt;</ept>関数についての情報を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>統合ログ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about the new key-path expression syntax to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Keys and Key Paths<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいキーパス式構文についての情報を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>キーとキーパス<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added information about thread-safe initialization to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>One-Time Initialization<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section of the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Interacting with C APIs<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スレッド安全初期化についての情報を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>C APIとの相互作用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>章の<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ワンタイム初期化<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>API Availability<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Adopting Cocoa Design Patterns<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>API有効性<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ココア・デザインパターンの採用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Adding Availability Information to Objective-C APIs<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Swift and Objective-C in the Same Project<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>利用可能性情報をObjective-C APIに加える<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>同じプロジェクトの中のSwiftとObjective-C<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Avoiding Strong Reference Cycles When Capturing self<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Interacting with Objective-C APIs<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>強い参照循環を自身をキャプチャするときに避ける<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を章<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Objective-C APIとの相互作用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Bit Fields<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section and updated the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Unions<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> section in the <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Interacting with C APIs<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ビットフィールド<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節の追加と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>共用体<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>節の更新を<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>C APIとの相互作用<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>章で行った。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Catching and Handling Custom Errors<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about how to handle custom errors defined using the <bpt i="2" x="2">&lt;c2&gt;</bpt>NS_ERROR_ENUM<ept i="2">&lt;/c2&gt;</ept> macro.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>カスタムエラーを捕えて処理する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;c2&gt;</bpt>NS_ERROR_ENUM<ept i="2">&lt;/c2&gt;</ept>マクロを使って定義されたカスタムエラーを取り扱う方法についての情報とともに追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Catching and Handling an Error<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Adopting Cocoa Design Patterns<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>エラーを捕えて処理する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ココア・デザインパターンの採用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Converting Errors to Optional Values<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Adopting Cocoa Design Patterns<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter with information about the <bpt i="4" x="4">&lt;c4&gt;</bpt>try?<ept i="4">&lt;/c4&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>エラーをオプショナル値に変換する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を加えて、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ココア・デザインパターンの採用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章が<bpt i="4" x="4">&lt;c4&gt;</bpt>try?<ept i="4">&lt;/c4&gt;</ept>キーワードについての情報を持つようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Data Type Size Calculation<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Interacting with C APIs<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter with information about the <bpt i="4" x="4">&lt;c4&gt;</bpt>sizeof<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>sizeofValue<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>strideof<ept i="6">&lt;/c6&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>strideOfValue<ept i="7">&lt;/c7&gt;</ept> functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>データ型サイズ計算<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を加えて<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>C APIとの相互作用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>章に<bpt i="4" x="4">&lt;c4&gt;</bpt>sizeof<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>sizeofValue<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>strideof<ept i="6">&lt;/c6&gt;</ept>、そしてs<bpt i="7" x="7">&lt;c7&gt;</bpt>trideOfValue<ept i="7">&lt;/c7&gt;</ept>関数についての情報をもたせた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Error Handling<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Adopting Cocoa Design Patterns<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>エラーの処理<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ココア・デザインパターンの採用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Failable Initialization<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Interacting with Objective-C APIs<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>失敗できる初期化<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Objective-C APIとの相互作用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Key-Value Observing<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Adopting Cocoa Design Patterns<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>キー値監視<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を章<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Cocoaデザインパターンの採用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Lazy Initialization<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Adopting Cocoa Design Patterns<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>遅延初期化<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ココア・デザインパターンの採用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Making Objective-C Interfaces Unavailable in Swift<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Swift and Objective-C in the Same Project<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>スウィフトで利用できないObjective-Cインターフェイスを作る<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>同じプロジェクト中のスウィフトとObjective-C<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Memory Managed Objects<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Working with Cocoa Frameworks<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>メモリ管理オブジェクト<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ココアフレームワークを扱う<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>NSCoding<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Interacting with Objective-C APIs<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>NSCodingプロトコル<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Objective-C APIとの相互作用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Option Sets<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Interacting with C APIs<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オプションセット<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>C APIとの相互作用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Overriding Swift Names for Objective-C Interfaces<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Interacting with Objective-C APIs<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Objective-Cインターフェイスのためのスウィフト名のオーバーライド<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Objective-C APIとの相互作用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Processing Command-Line Arguments<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Adopting Cocoa Design Patterns<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter with information about reading command line flags.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>コマンドライン引数の処理<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を加えて<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ココア・デザインパターンの採用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>章がコマンドラインフラグの読み込みについての情報を持つようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Refining Objective-C Declarations<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Swift and Objective-C in the Same Project<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter with information about the <bpt i="4" x="4">&lt;c4&gt;</bpt>NS_REFINED_FOR_SWIFT<ept i="4">&lt;/c4&gt;</ept> macro.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Objective-C宣言を改良する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を加えて、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>同じプロジェクト中のスウィフトとObjective-C<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章が<bpt i="4" x="4">&lt;c4&gt;</bpt>NS_REFINED_FOR_SWIFT<ept i="4">&lt;/c4&gt;</ept>マクロについての情報を持つようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Requiring Dynamic Dispatch<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Interacting with Objective-C APIs<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>動的ディスパッチの必要<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を章<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Objective-C APIとの相互作用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Serialization<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Adopting Cocoa Design Patterns<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter with information about serializing objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>シリアライズ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ココア・デザインパターンの採用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>章に加えてオブジェクトのシリアライズについての情報を持つようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Sets<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Working with Cocoa Frameworks<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>集合<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ココアフレームワークを扱う<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Singleton<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Adopting Cocoa Design Patterns<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>シングルトン<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を章<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ココア・デザインパターンの採用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Throwing an Error<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Adopting Cocoa Design Patterns<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>エラーをスローする<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ココア・デザインパターンの採用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Undo<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Adopting Cocoa Design Patterns<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter with information about implementing undo support.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>取り消し<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を加えて<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ココア・デザインパターンの採用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>章がアンドゥサポート実装についての情報を持つようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Unions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Interacting with C APIs<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>共用体<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>C APIとの相互作用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Unnamed Structure and Union Fields<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Interacting with C APIs<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>無名の構造体と共用体フィールド<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>C APIとの相互作用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Unrecognized Selectors and Optional Chaining<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section and the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Downcasting Any<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> section to the <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Interacting with Objective-C APIs<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>識別不能セレクタとオプショナル連鎖<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Anyのダウンキャスト<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>節を<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Objective-C APIとの相互作用<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Unsafe Invocation of Objective-C Methods<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Interacting with Objective-C APIs<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter now that the <bpt i="4" x="4">&lt;c4&gt;</bpt>performSelector<ept i="4">&lt;/c4&gt;</ept> API family is available in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Objective-Cメソッドの安全でない発動<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Objective-C APIとの相互作用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>章に加えた、今では<bpt i="4" x="4">&lt;c4&gt;</bpt>performSelector<ept i="4">&lt;/c4&gt;</ept> APIファミリはスウィフトで利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Using Swift Class Names with Objective-C APIs<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Writing Swift Classes and Protocols with Objective-C Behavior<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>スウィフトクラス名をObjective-C APIで使う<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を章<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>スウィフトのクラスとプロトコルをObjective-C挙動で書く<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Variadic Functions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Interacting with C APIs<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>可変長引数関数<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>C APIとの相互作用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added to the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Nullability and Optionals<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section in the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Interacting with Objective-C APIs<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ヌル許可とオプショナル<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を章<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Objective-C APIとの相互作用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Added various references to tvOS and watchOS platform support.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>種々の参照をtvOSとwatchOSプラットホームサポートに対して加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adding Availability Information to Objective-C APIs</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>利用可能性情報をObjective-C APIに加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Additionally, unlike Objective-C, in Swift there is no separate memory allocation method to invoke.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その上に、Objective-Cと違って、スウィフトでは別々のメモリ割り当てメソッドが呼ばれることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Additionally, you can use <bpt i="0" x="0">&lt;c0&gt;</bpt>catch<ept i="0">&lt;/c0&gt;</ept> clauses to match on particular error codes as a convenient way to differentiate possible failure conditions:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加えて、あなたは、起こりうる失敗条件を見分ける便利な方法として、<bpt i="0" x="0">&lt;c0&gt;</bpt>catch<ept i="0">&lt;/c0&gt;</ept>節を特定のエラーコードで一致するように使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adopting Cocoa Design Patterns</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ココア・デザインパターンの採用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adopting Protocols</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルを採用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Adopting a Swift Protocol in an Objective-C Implementation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトプロトコルをObjective-C実装において採用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After You Finish</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがやり終えたあと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After the <bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept> structure has been imported, you can initialize it and use it as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept>構造体がインポートされてしまった後、あなたはそれを初期化してそれを以下のように使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After you add the custom view to Interface Builder (by setting the custom class of the view in the inspector pane), Interface Builder renders your view in the canvas.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがカスタムメイドのビューをインタフェースビルダーに加えた（インスペクターペインにおいてそのビューのカスタム・クラスを設定することによって）後に、インタフェースビルダーはキャンバスにおいてあなたのビューを描画します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After you add your custom view to Interface Builder, you can edit these properties in the inspector.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあなたのカスタムメイドのビューをインタフェースビルダーに加えたあと、あなたはインスペクターにおいてこれらのプロパティを編集することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After you have your Xcode project set up, you can import any framework from Cocoa or Cocoa Touch to start working with Objective-C from Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが、あなたのXcodeプロジェクトを設定した後は、あなたはどんなフレームワークでもCocoaまたはCocoa Touchからインポートすることで、スウィフトからObjective-Cを扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>After you import an Objective-C framework, you can instantiate classes from it and interact with them using native Swift syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがObjective-Cフレームワークをインポートしたあと、あなたはそれからのクラスをインスタンス化することができて、スウィフト本来の構文を使ってそれらと相互に作用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All Objective-C generic type parameters imported by Swift have a type constraint that requires that type to be a class (<bpt i="0" x="0">&lt;c0&gt;</bpt>T: Any<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトによってインポートされる全てのObjective-C総称体型パラメータは、ある型制約を持ちます、それはあるクラス（<bpt i="0" x="0">&lt;c0&gt;</bpt>T: Any<ept i="0">&lt;/c0&gt;</ept>）であることをその型に要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All indirectly returned Core Foundation objects are unmanaged as well.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全ての間接的に返されたコアファウンデーション・オブジェクトは、同様に管理されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All of the Cocoa APIs provide availability information, so you can be confident the code you write works as expected on any of the platforms your app targets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cocoa APIの全ては、有効性情報を提供します、それであなたは、あなたの書くコードが予想されるようにあなたのアプリがターゲットにするどのプラットホーム上でも機能すると確信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>All selector pieces are required at the call site.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>全てのセレクタ片は、呼び出し現場で必須とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alongside these Swift modules are generated Objective-C headers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それと並んでこれらのスウィフトモジュールは、Objective-Cヘッダを生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, you can check availability in a <bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept> statement, which exits out of scope unless the current target satisfies the specified requirements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるいはまた、あなたは有効性を<bpt i="0" x="0">&lt;c0&gt;</bpt>guard<ept i="0">&lt;/c0&gt;</ept>文の中で使うことができます、それは現在のターゲットが指定された要件を満たさない限りスコープの外に退出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Alternatively, you can create a bridging header yourself by choosing File &gt; New &gt; File &gt; (iOS, watchOS, tvOS, <bpt i="0" x="0">&lt;e0&gt;</bpt>or<ept i="0">&lt;/e0&gt;</ept> macOS) &gt; Source &gt; Header File.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、あなたは橋渡しヘッダをあなた自身でFile &gt; New &gt; File &gt; (iOS、watchOS、tvOS、<bpt i="0" x="0">&lt;e0&gt;</bpt>または<ept i="0">&lt;/e0&gt;</ept>macOS) &gt; Source &gt; Header Fileを選ぶことによって作成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although Swift does not require forced unwrapping when calling methods on values of type <bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept>, it is recommended as a way to safeguard against unexpected behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>とは言え、スウィフトは<bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept>型の値の上でメソッドを呼び出しているとき強制アンラップを必要としません、それは予期しない挙動に対抗して安全を守るための方法として推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although Swift doesn’t support unions, a C union imported as a Swift structure still behaves like a C union.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは共用体をサポートしないにもかかわらず、スウィフト構造体としてインポートされたC共用体は依然としてC共用体のように振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Although Swift error handling resembles exception handling in Objective-C, it is entirely separate functionality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトエラー処理はObjective-Cでの例外処理に似ていますが、それは完全に関係のない機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt>AutoreleasingUnsafeMutablePointer&lt;Type&gt;<ept i="0">&lt;/c0&gt;</ept> value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつの<bpt i="0" x="0">&lt;c0&gt;</bpt>AutoreleasingUnsafeMutablePointer&lt;Type&gt;<ept i="0">&lt;/c0&gt;</ept>値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafeMutablePointer&lt;Type&gt;<ept i="0">&lt;/c0&gt;</ept> value</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつの<bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafeMutablePointer&lt;Type&gt;<ept i="0">&lt;/c0&gt;</ept>値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafePointer&lt;Type&gt;<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>UnsafeMutablePointer&lt;Type&gt;<ept i="1">&lt;/c1&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt>AutoreleasingUnsafeMutablePointer&lt;Type&gt;<ept i="2">&lt;/c2&gt;</ept> value, which is converted to <bpt i="3" x="3">&lt;c3&gt;</bpt>UnsafePointer&lt;Type&gt;<ept i="3">&lt;/c3&gt;</ept> if necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつの<bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafePointer&lt;Type&gt;<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>UnsafeMutablePointer&lt;Type&gt;<ept i="1">&lt;/c1&gt;</ept>、または<bpt i="2" x="2">&lt;c2&gt;</bpt>AutoreleasingUnsafeMutablePointer&lt;Type&gt;<ept i="2">&lt;/c2&gt;</ept>値、それは必要ならば<bpt i="3" x="3">&lt;c3&gt;</bpt>UnsafePointer&lt;Type&gt;<ept i="3">&lt;/c3&gt;</ept>に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An Objective-C class can adopt a Swift protocol in its implementation (<bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>) file by importing the Xcode-generated header for Swift code and using a class extension.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cクラスは、その実装（<bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>）ファイルにおいてスウィフトプロトコルを採用することが、スウィフトコードのためのXcode生成ヘッダをインポートすることとクラス拡張を使うことでできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An Objective-C class can conform a protocol declared in Swift in the same way that it would an Objective-C protocol, by implementing the required methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cクラスは、スウィフトで宣言されるプロトコルにそれがObjective-Cプロトコルにするのと同じ方法で、必須メソッドを実装することによって、準拠できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An Objective-C method reference can be parenthesized, and it can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept> operator to disambiguate between overloaded functions, such as <bpt i="1" x="1">&lt;c1&gt;</bpt>#selector(((UIView.insert(subview:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void))<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cメソッド参照は、丸括弧で括られることができます、そしてそれはオーバーロードされた関数間を明確にするために<bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept>演算子を使うことができます、例えば<bpt i="1" x="1">&lt;c1&gt;</bpt>#selector(((UIView.insert(subview:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void))<ept i="1">&lt;/c1&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An empty option set can be created from an empty array literal (<bpt i="2" x="2">&lt;c2&gt;</bpt>[]<ept i="2">&lt;/c2&gt;</ept>) or by calling its default initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>空のオプションセットは、空の配列リテラル（<bpt i="2" x="2">&lt;c2&gt;</bpt>[]<ept i="2">&lt;/c2&gt;</ept>）から、またはそれの省略時のイニシャライザを呼ぶことによって作成されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An in-out expression of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept> that contains a mutable variable, property, or subscript reference, which is passed as a pointer to the address of the mutable value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つの可変の変数、プロパティ、または添え字参照を含んでいる、型<bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept>の１つのin-out式、それは、ボインタとしてその可変値のアドレスへと渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An in-out expression of type <bpt i="0" x="0">&lt;c0&gt;</bpt>[Type]<ept i="0">&lt;/c0&gt;</ept> that contains a mutable variable, property, or subscript reference, which is passed as a pointer to the start of the array, and is lifetime-extended for the duration of the call</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変の変数、プロパティ、または添え字参照を含んでいる、型<bpt i="0" x="0">&lt;c0&gt;</bpt>[Type]<ept i="0">&lt;/c0&gt;</ept>のin-out式、それは、ポインタとしてその配列の始まりへと渡されます、そして呼び出しの持続期間は寿命延長されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An in-out expression that contains a mutable variable, property, or subscript reference of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept>, which is copied bitwise into a temporary nonowning buffer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつのin-out式で、それが型<bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept>の可変の変数、プロパティ、または添え字参照を含むもの、それは一時的な非所有バッファにビット単位でコピーされるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An in-out expression that contains a mutable variable, property, or subscript reference of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept>, which is passed as a pointer to the address of the left-hand side identifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとつのin-out式で、それが型<bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept>の可変の変数、プロパティ、または添え字参照を含むもの、それは左手側識別子のアドレスへのポインタとして渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>An undo operation records the steps necessary to counteract its corresponding operation, such as setting the text of a control back to its original value or adding a deleted item back into a table.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある取り消し操作は、それの対応している操作を無効にするために必要な段取りを記録します、例えばあるコントロールのテキストをそれのオリジナルの値に戻すよう設定する、または削除した項目を表に戻すよう加えるなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And here’s how Swift imports it:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そしてここにスウィフトがそれをインポートする方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And here’s how you add the same availability information in Objective-C:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そしてここにあなたが同じ利用可能性情報をObjective-Cにおいて加える方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And here’s how you use the same availability information in Objective-C:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そしてここにはあなたが同じ利用可能性情報をObjective-Cで使う方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And here’s the equivalent code in Swift:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そしてここにスウィフトにおける同等のコードがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>And here’s what it looks like in Swift:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そして、それがスウィフトではどんなものになるかがここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any Objective-C framework or C library that supports <bpt i="0" x="0">&lt;e0&gt;</bpt>modules<ept i="0">&lt;/e0&gt;</ept> can be imported directly into Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>モジュール<ept i="0">&lt;/e0&gt;</ept>をサポートするどんなObjective-CフレームワークまたはCライブラリでも、スウィフトに直接インポートされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any command-line arguments that are specified at launch begin at <bpt i="1" x="1">&lt;c1&gt;</bpt>CommandLine.arguments[1]<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>起動時に指定される何らかのコマンドライン引数は、<bpt i="1" x="1">&lt;c1&gt;</bpt>CommandLine.arguments[1]<ept i="1">&lt;/c1&gt;</ept>で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any exception handling behavior must be implemented in Objective-C code used by Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>どのような例外処理挙動もスウィフトによって使用されるObjective-Cコードの中で実装されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any language framework</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>何らかの言語フレームワーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any optional protocol requirements must be marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept> attribute and have the <bpt i="1" x="1">&lt;c1&gt;</bpt>optional<ept i="1">&lt;/c1&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>なんであれオプショナルのプロトコル要件は、<bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept>属性で印されて<bpt i="1" x="1">&lt;c1&gt;</bpt>optional<ept i="1">&lt;/c1&gt;</ept>修飾子を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Any public Objective-C headers listed in this bridging header file will be visible to Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この橋渡しヘッダ・ファイルにリストされるどんなパブリックObjective-Cヘッダでも、スウィフトに見えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Anywhere you can use a bridged Objective-C reference type, you can use the Swift value type instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがブリッジObjective-C参照型を使うことができるどこにでも、あなたはスウィフト値型をその代わりに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Applying a key path to an instance results in a value of the same type as accessing that instance’s property directly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパス式をインスタンスに適用することは、そのインスタンスの持つプロパティに直接にアクセスするのと同じ型の値という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Applying the <bpt i="1" x="1">&lt;c1&gt;</bpt>@objMembers<ept i="1">&lt;/c1&gt;</ept> attribute to a class implicitly adds the <bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept> attribute to all of its Objective-C compatible members.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>@objMembers<ept i="1">&lt;/c1&gt;</ept>属性をあるクラスに適用することは、それのObjective-C互換メンバの全てに暗黙的に<bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept>属性を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Arrays</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As You Work</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが作業するとき</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, changing the value of any computed property on an instance of the imported structure changes the value of all other properties defined by that structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、インポートされた構造体のインスタンス上で何らかの計算プロパティを変更することは、その構造体によって定義される他のプロパティすべての値を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, this attribute can also be useful when migrating an archivable Objective-C class to Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その結果、この属性はまた、アーカイブできるObjective-Cクラスをスウィフトに移行するとき便利でありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As a result, you can use an Objective-C structure from Swift in Cocoa APIs that accept only instances of reference types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として、あなたは参照型のインスタンスのみを受け取るCocoa APIにおいてスウィフト由来のObjective-C構造体を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As in Objective-C, you can use outlets, actions, and live rendering in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cの場合のように、あなたはスウィフトにおいてアウトレット、アクション、そしてライブレンダリングを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As part of its interoperability with Objective-C, Swift maintains compatibility with a number of C language types and features.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのObjective-Cとの相互運用性の一部として、スウィフトはたくさんのC言語型と特徴との互換性を維持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As part of its interoperability with Objective-C, Swift offers convenient and efficient ways of working with Cocoa frameworks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それのObjective-Cとの相互運用性の一部として、スウィフトはCocoaフレームワークを扱う便利で効率的な方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As you begin to integrate Swift into your app development workflow, it’s a good idea to understand how you can leverage interoperability to redefine, improve, and enhance the way you write Cocoa apps.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがスウィフトをあなたのアプリ開発ワークフローに組み込み始めるとき、あなたがあなたがココア・アプリを書く方法をとらえ直して、向上させて、強化するために、どのように相互運用性を使って小さな労力で大きな成果を得られるようにできるか理解することは良い考えです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As you incorporate Cocoa patterns into your Swift class, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Adopting Cocoa Design Patterns<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> for information on translating common design patterns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがココアパターンをあなたのスウィフトクラスに組み込むとき、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ココア・デザインパターンの採用<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を一般的なデザイン・パターンを翻訳することに関する情報のために見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>As you work with Objective-C APIs, you’ll need to know how Swift translates certain Objective-C language features.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがObjective-C APIを扱うとき、あなたはスウィフトがどのように特定のObjective-C言語機能を翻訳するか知っている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>At compile time and runtime, the compiler introduces a universal bridging conversion operation when a Swift value or object is passed into Objective-C as an <bpt i="2" x="2">&lt;c2&gt;</bpt>id<ept i="2">&lt;/c2&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイル時および実行時に、コンパイラは全般的ブリッジ変換演算を、スウィフトの値やオブジェクトがObjective-Cへ<bpt i="2" x="2">&lt;c2&gt;</bpt>id<ept i="2">&lt;/c2&gt;</ept>パラメータとして渡される時に導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Atomicity property attributes (<bpt i="0" x="0">&lt;c0&gt;</bpt>atomic<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>nonatomic<ept i="1">&lt;/c1&gt;</ept>) are not reflected in the corresponding Swift property declaration, but the atomicity guarantees of the Objective-C implementation still hold when the imported property is accessed from Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>原子性プロパティ属性（<bpt i="0" x="0">&lt;c0&gt;</bpt>atomic<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>nonatomic<ept i="1">&lt;/c1&gt;</ept>）は、スウィフトプロパティ宣言に反映されません、しかしObjective-C実装の原子性担保はインポートされたプロパティがスウィフトからアクセスされる時に依然として保持されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Attempting to call the <bpt i="0" x="0">&lt;c0&gt;</bpt>+collectionWithValues:forKeys:<ept i="0">&lt;/c0&gt;</ept> method from Swift code will result in a compiler error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>+collectionWithValues:forKeys:<ept i="0">&lt;/c0&gt;</ept>メソッドをスウィフトコードから呼び出す試みは、コンパイラエラーの結果になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Attempting to invoke a method on an object with an unrecognized selector causes the receiver to call <bpt i="0" x="0">&lt;c0&gt;</bpt>doesNotRecognizeSelector(_:)<ept i="0">&lt;/c0&gt;</ept>, which by default raises an <bpt i="1" x="1">&lt;c1&gt;</bpt>NSInvalidArgumentException<ept i="1">&lt;/c1&gt;</ept> exception.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッドをオブジェクト上で十分に評価されていないセレクタで発動することは、そのレシーバが<bpt i="0" x="0">&lt;c0&gt;</bpt>doesNotRecognizeSelector(_:)<ept i="0">&lt;/c0&gt;</ept>を呼び出す原因になります、それは初期設定では<bpt i="1" x="1">&lt;c1&gt;</bpt>NSInvalidArgumentException<ept i="1">&lt;/c1&gt;</ept>例外を引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Autorelease Pools</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オートリリースプール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Autorelease pool blocks allow objects to relinquish ownership without being deallocated immediately.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オートリリースプール・ブロックは、オブジェクトに直ちにデアロケートされることなしに所有権を放棄させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Autoreleasing Pointers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自動解放ポインター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Availability checks can be used in place of a condition in a control flow statement, such as an <bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>guard<ept i="2">&lt;/c2&gt;</ept>, or <bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>有効性確認は、制御の流れ文、例えば<bpt i="1" x="1">&lt;c1&gt;</bpt>if<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>guard<ept i="2">&lt;/c2&gt;</ept>、または<bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept>の中のひとつの条件の代わりに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Avoiding Strong Reference Cycles When Capturing self</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>強い参照循環を自身をキャプチャするときに避ける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Basic Setup</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基本の準備</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because <bpt i="2" x="2">&lt;c2&gt;</bpt>NSNumber<ept i="2">&lt;/c2&gt;</ept> can contain a variety of different types, you must use the <bpt i="3" x="3">&lt;c3&gt;</bpt>as?<ept i="3">&lt;/c3&gt;</ept> operator when casting to a Swift number type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>NSNumber<ept i="2">&lt;/c2&gt;</ept>が様々な異なる型を含むことができることから、あなたはスウィフト数値型をキャストする時に<bpt i="3" x="3">&lt;c3&gt;</bpt>as?<ept i="3">&lt;/c3&gt;</ept>演算子を使わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because a lazy property is only computed when accessed for a fully-initialized instance it may access constant or variable properties in its default value initialization expression:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延プロパティは、完全に初期化されたインスタンスに対してアクセスされる時に初めて計算されるので、それは、定数または変数プロパティにアクセスすることがそれの省略時の値の初期化式において可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because applying the <bpt i="3" x="3">&lt;c3&gt;</bpt>@objc<ept i="3">&lt;/c3&gt;</ept> attribute can increase the compiled size of an app and adversely affect performance, only apply the <bpt i="4" x="4">&lt;c4&gt;</bpt>@objcMembers<ept i="4">&lt;/c4&gt;</ept> attribute on declarations when each member needs to have the <bpt i="5" x="5">&lt;c5&gt;</bpt>@objc<ept i="5">&lt;/c5&gt;</ept> attribute applied.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>@objc<ept i="3">&lt;/c3&gt;</ept>属性を適用することはアプリのコンパイル済みサイズを増大させて性能に不利な影響をもたらすことから、各メンバが<bpt i="5" x="5">&lt;c5&gt;</bpt>@objc<ept i="5">&lt;/c5&gt;</ept>属性を適用される必要がある場合に、ただ<bpt i="4" x="4">&lt;c4&gt;</bpt>@objcMembers<ept i="4">&lt;/c4&gt;</ept>属性を宣言上でだけ適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because archived objects store the name of their class in the archive, you should use the <bpt i="3" x="3">&lt;c3&gt;</bpt>@objc(<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;e4&gt;</bpt>name<ept i="4">&lt;/e4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>)<ept i="5">&lt;/c5&gt;</ept> attribute to specify the same name as your Objective-C class so that older archives can be unarchived by your new Swift class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アーカイブされたオブジェクトがそれらのクラスの名前をアーカイブに格納するので、あなたは<bpt i="3" x="3">&lt;c3&gt;</bpt>@objc(<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;e4&gt;</bpt>name<ept i="4">&lt;/e4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>)<ept i="5">&lt;/c5&gt;</ept>属性を使ってあなたのObjective-Cクラスと同じ名前を指定しなければなりません、それでちょっと古くなったアーカイブがあなたの新しいスウィフトクラスによってアンアーカイブされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because of Swift’s interoperability with Objective-C, you can take advantage of these common patterns in your Swift code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのObjective-Cとの相互運用性のため、あなたはこれらの共通のパターンをあなたのスウィフトコードにおいて活用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because simple constant-like macros map directly to Swift global variables, the compiler automatically imports simple macros defined in C and Objective-C source files.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単純な定数的なマクロがスウィフトのグローバル変数に直接にマップするので、コンパイラは、CとObjective-Cソース・ファイルにおいて定義される単純なマクロを自動的にインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the <bpt i="1" x="1">&lt;c1&gt;</bpt>Cake<ept i="1">&lt;/c1&gt;</ept> structure has fields with unnamed types, you use the <bpt i="2" x="2">&lt;c2&gt;</bpt>.init<ept i="2">&lt;/c2&gt;</ept> initializers, which are picked using type inference, to set the initial value for each of the structure’s unnamed fields.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Cake<ept i="1">&lt;/c1&gt;</ept>構造体は無名型でのフィールドを持つことから、あなたは<bpt i="2" x="2">&lt;c2&gt;</bpt>.init<ept i="2">&lt;/c2&gt;</ept>イニシャライザを使うことによって、それは型推論を使って選択されます、その構造体の持つ無名フィールドの各々に対して初期値を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the first field of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept> structure is unnamed, its initializer’s first parameter does not have a label.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept>構造体の最初のフィールドが無名であるため、それのイニシャライザの最初のパラメータはラベルを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the generated header for a framework target is part of the framework’s public interface, only declarations marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>public<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>open<ept i="1">&lt;/c1&gt;</ept> modifier appear in the generated header for a framework target.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるフレームワークターゲットのために生成されたヘッダはそのフレームワークのパブリックなインターフェイスの一部なので、<bpt i="0" x="0">&lt;c0&gt;</bpt>public<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>open<ept i="1">&lt;/c1&gt;</ept>修飾子で印された宣言だけがフレームワークターゲットのために生成されたヘッダの中に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the namespace of classes and protocols is unified in Swift, the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSObject<ept i="0">&lt;/c0&gt;</ept> protocol in Objective-C is remapped to <bpt i="1" x="1">&lt;c1&gt;</bpt>NSObjectProtocol<ept i="1">&lt;/c1&gt;</ept> in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスとプロトコルの名前空間はスウィフトにおいて統一されるので、Objective-Cの<bpt i="0" x="0">&lt;c0&gt;</bpt>NSObject<ept i="0">&lt;/c0&gt;</ept>プロトコルはスウィフトにおいて<bpt i="1" x="1">&lt;c1&gt;</bpt>NSObjectProtocol<ept i="1">&lt;/c1&gt;</ept>にリマップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the specific type of an <bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept> value is not known until runtime, it is possible to inadvertently write unsafe code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept>値の具体的な型は実行時まで知られないことから、不注意に安全でないコードを書くことは可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because the type of the <bpt i="0" x="0">&lt;c0&gt;</bpt>valueFromSwift<ept i="0">&lt;/c0&gt;</ept> parameter is <bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept>, it’s imported in the Swift code below as the Swift type <bpt i="2" x="2">&lt;c2&gt;</bpt>Any<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>valueFromSwift<ept i="0">&lt;/c0&gt;</ept>パラメータの型は<bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept>であるので、それは以下のスウィフトコードにおいてスウィフト型<bpt i="2" x="2">&lt;c2&gt;</bpt>Any<ept i="2">&lt;/c2&gt;</ept>としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because this functionality is provided through language features, the corresponding POSIX and Grand Central Dispatch C function calls are not exposed by Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この機能性は言語特徴によって提供されるので、相当するPOSIXおよびGrand Central DispatchのC関数呼び出しはスウィフトによって暴露されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because unions in C use the same base memory address for all of their fields, all of the computed properties in a union imported by Swift use the same underlying memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cでの共用体は同じ基盤メモリアドレスをすべてのそれのフィールドに対して使うことから、スウィフトによってインポートされる共用体の中の計算プロパティのすべては同じ基礎をなすメモリを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Because you can’t subclass Swift classes in Objective-C, it’s best to choose a class in your app that doesn’t have any subclasses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがスウィフトクラスをObjective-Cにおいてサブクラス化できないので、あなたのアプリにおいて全くサブクラスを持たないクラスを選択するのは最も良いことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Before You Start</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが始める前に</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Before you begin migrating your codebase, make sure that your Objective-C and Swift code has optimal compatibility.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあなたのコードベースを移行し始める前に、あなたのObjective-Cとスウィフトコードが最適の互換性を持つことを確かにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Before you get started learning about these features, you need a basic understanding of how to set up a Swift environment in which you can access Cocoa system frameworks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこれらの特徴について学ぶことを始める前に、あなたは、そこにおいてあなたがココア・システム・フレームワークにアクセスすることができるところの、スウィフト環境を設定する方法の基本的な理解が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bit Fields</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ビットフィールド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Blocks maintain strong references to any captured objects, including <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブロックは、<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>を含めて、あらゆるキャプチャされるオブジェクトに対する強い参照を管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both kinds of availability specifier are available in Objective-C using the corresponding syntax shown in the following examples.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>両方の種類の利用可能性指定子は、以下の例で示される対応する構文を使ってObjective-Cで利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Both of these methods return the original, unwrapped type of the object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのメソッドの両方とも、最初の、包装を取られた型のオブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bridged Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブリッジ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Bridging Optionals to Nonnullable Objects</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルをnull不可オブジェクトへブリッジする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Buffer Pointers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>バッファポインタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By casting to <bpt i="2" x="2">&lt;c2&gt;</bpt>ToDoListController<ept i="2">&lt;/c2&gt;</ept>, this return value can make the corresponding call to <bpt i="3" x="3">&lt;c3&gt;</bpt>mark(task:asCompleted:)<ept i="3">&lt;/c3&gt;</ept> directly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>ToDoListController<ept i="2">&lt;/c2&gt;</ept>にキャストすることによって、この戻り値は直接に<bpt i="3" x="3">&lt;c3&gt;</bpt>mark(task:asCompleted:)<ept i="3">&lt;/c3&gt;</ept>に対する対応する呼び出しを作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, Swift imports enumerations by truncating enumeration value name prefixes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に何もしなくとも、スウィフトは列挙値名接頭辞を切り取ることによってを列挙インポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, the generated header contains interfaces for Swift declarations marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>public<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>open<ept i="1">&lt;/c1&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に何もしなければ、生成されたヘッダはスウィフト宣言を<bpt i="0" x="0">&lt;c0&gt;</bpt>public<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>open<ept i="1">&lt;/c1&gt;</ept>修飾子で印して含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>By default, your product module name is the same as your product name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特に何もしなければ、あなたの製品モジュール名は、あなたの製品名と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>C <bpt i="0" x="0">&lt;c0&gt;</bpt>struct<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>union<ept i="1">&lt;/c1&gt;</ept> types can define fields that have no name or that are of an unnamed type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cの<bpt i="0" x="0">&lt;c0&gt;</bpt>struct<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>union<ept i="1">&lt;/c1&gt;</ept>型は、名前を持たないまたは無名型であるフィールドを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>C APIs, such as the Core Foundation framework, often provide functions that create, access, or modify C structures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C API、例えばCore Foundationフレームワークは、C構造体の作成、アクセス、または修正をする関数をしばしば提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>C Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>C Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>C enumerations imported by Swift do not fail when initializing with a raw value that does not correspond to an enumeration case.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトによってインポートされるC列挙は、ある生の値が列挙ケース節と調和しない状態での初期化の時に失敗しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>C function pointers are imported into Swift as closures with C function pointer calling convention, denoted by the <bpt i="0" x="0">&lt;c0&gt;</bpt>@convention(c)<ept i="0">&lt;/c0&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C関数ポインターは、スウィフトにC関数呼出規約を持つクロージャとしてインポートされ、<bpt i="0" x="0">&lt;c0&gt;</bpt>@convention(c)属性<ept i="0">&lt;/c0&gt;</ept>によって印を付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Catching and Handling Custom Errors</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>カスタムエラーを捕まえて処理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Catching and Handling an Error</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーを捕えて処理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Changed code listings to use the new <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept> type syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コード出力を変更して新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept>型構文を使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Check that <bpt i="0" x="0">&lt;c0&gt;</bpt>myDelegate<ept i="0">&lt;/c0&gt;</ept> implements the method <bpt i="1" x="1">&lt;c1&gt;</bpt>window:willUseFullScreenContentSize:<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>myDelegate<ept i="0">&lt;/c0&gt;</ept>がメソッド<bpt i="1" x="1">&lt;c1&gt;</bpt>window:willUseFullScreenContentSize:<ept i="1">&lt;/c1&gt;</ept>を実装することを確かめる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Check that <bpt i="0" x="0">&lt;c0&gt;</bpt>myDelegate<ept i="0">&lt;/c0&gt;</ept> is not <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>myDelegate<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>でないことを確かめる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Checking for and casting to a protocol follows exactly the same syntax as checking for and casting to a class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコルに対する調査とキャストは、あるクラスに対する調査とキャストと正確に同じ構文に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Choose File &gt; New &gt; Project &gt; (iOS, watchOS, tvOS, <bpt i="0" x="0">&lt;e0&gt;</bpt>or<ept i="0">&lt;/e0&gt;</ept> macOS) &gt; Application &gt; <bpt i="1" x="1">&lt;e1&gt;</bpt>your template of choice<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「ファイル」&gt;「新規」&gt;「プロジェクト」&gt;（iOS、watchOS、tvOS、<bpt i="0" x="0">&lt;e0&gt;</bpt>または<ept i="0">&lt;/e0&gt;</ept>macOS）&gt;「アプリケーション」&gt;<bpt i="1" x="1">&lt;e1&gt;</bpt>あなたの選ぶひな形<ept i="1">&lt;/e1&gt;</ept>を選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Choose “Create NSManagedObject Subclass…” from the “Editor” menu to generate corresponding Swift code for the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSManagedObject<ept i="0">&lt;/c0&gt;</ept> subclass, <bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「Create NSManagedObject Subclass…」を「Editor」メニューから選択することで、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSManagedObject<ept i="0">&lt;/c0&gt;</ept>のサブクラス、<bpt i="1" x="1">&lt;c1&gt;</bpt>Person<ept i="1">&lt;/c1&gt;</ept>に対応するスウィフトコードを生成してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Clarified the behavior of Objective-C atomicity attributes in Swift in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Accessing Properties<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおけるObjective-C原子性属性の挙動を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロパティにアクセスする<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節においてわかりやすくした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Clarified the behavior of the <bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept> protocol in the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>id Compatibility<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept>プロトコルの挙動を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>id互換性<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節においてわかりやすくした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class Factory Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスファクトリメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class Factory Methods and Convenience Initializers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスファクトリメソッドと便宜イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class clusters that include immutable and mutable subclasses are bridged to a single value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>不変および可変サブクラスを含むクラス群は、単一値型へブリッジされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Class prefixes are optional in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス接頭辞は、スウィフトでは随意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes specific to Objective-C or inherently tied to the Objective-C runtime, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>NSObject<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>NSAutoreleasePool<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>NSException<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>NSProxy<ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-C特有の、またはObjective-Cランタイムに本質的に結びつけられ切り離せないクラス、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>NSObject<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>NSAutoreleasePool<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>NSException<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>NSProxy<ept i="3">&lt;/c3&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes that adopt <bpt i="3" x="3">&lt;c3&gt;</bpt>NSCoding<ept i="3">&lt;/c3&gt;</ept> directly must implement this method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>直接に<bpt i="3" x="3">&lt;c3&gt;</bpt>NSCoding<ept i="3">&lt;/c3&gt;</ept>を採用するクラスは、このメソッドを実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes that do not have a value type equivalent but are planned to have one in the near future, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>NSAttributedString<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>NSRegularExpression<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>NSPredicate<ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型の相当物を持たないが近い将来それを持つ計画をされるクラス、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>NSAttributedString<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>NSRegularExpression<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>NSPredicate<ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Classes that have a value type equivalent, as described in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Bridged Types<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, such as <bpt i="2" x="2">&lt;c2&gt;</bpt>NSString<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>NSDictionary<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>NSURL<ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ブリッジ型<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>で記述される、値型の相当物を持つクラス、例えば<bpt i="2" x="2">&lt;c2&gt;</bpt>NSString<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>NSDictionary<ept i="3">&lt;/c3&gt;</ept>、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>NSURL<ept i="4">&lt;/c4&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Click the Language pop-up menu and choose Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「言語」ポップアップ・メニューをクリックして、スウィフトを選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Closures have similar capture semantics as blocks but differ in one key way: Variables are mutable rather than copied.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クロージャは、ブロックとしての類似したキャプチャ意味論を持ちますが、１つの重要なやり方において異なります：変数は、コピーされるのではなく、可変です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Cocoa Structures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cocoa構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Command-click a Swift class name to see its generated header.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトクラス名をコマンド-クリックして、その生成ヘッダを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complex Macros</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複雑なマクロ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complex macros are macros that do not define constants, including parenthesized, function-like macros.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複雑なマクロは、定数を定義するものではなく、括弧に入れられた、関数のようなマクロのことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Complex macros are used in C and Objective-C but have no counterpart in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複雑なマクロがCとObjective-Cで使われますが、スウィフトにおいて対応するものがありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conditional Compilation Blocks</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>条件コンパイルブロック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Configuring Swift Interfaces in Objective-C</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトインターフェイスをObjective-Cにおいて構成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Consider the following Objective-C initializer declarations:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のObjective-Cイニシャライザ宣言を考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constant Pointers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>定数ポインター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constants imported from a type declaration marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_TYPED_EXTENSIBLE_ENUM<ept i="0">&lt;/c0&gt;</ept> macro can be extended in Swift code to add new values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS_TYPED_EXTENSIBLE_ENUM<ept i="0">&lt;/c0&gt;</ept>マクロで印される型宣言からインポートされる定数は、スウィフトコードにおいて拡張されて新しい値を加えられることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constants that represent a fixed set of possible values can be imported as a structure by adding the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_TYPED_ENUM<ept i="0">&lt;/c0&gt;</ept> macro.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある固定された一揃いの候補の値を表す定数いくらかは、構造体としてインポートされることが<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_TYPED_ENUM<ept i="0">&lt;/c0&gt;</ept>マクロを加えることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constants that represent an extensible set of possible values can be imported as a structure by adding the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_TYPED_EXTENSIBLE_ENUM<ept i="0">&lt;/c0&gt;</ept> macro.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある拡張可能な一揃いの候補の値を表す定数いくらかは、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_TYPED_EXTENSIBLE_ENUM<ept i="0">&lt;/c0&gt;</ept>マクロを加えることによって構造体としてインポートされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Constants using this extensible form are imported with an additional initializer that lets callers omit the argument label when extending the set with new values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この拡張可能な形式を使う定数は、追加的なイニシャライザ、新しい値を持つ集合を拡張する時に呼出し側に引数ラベルを省略させるもの、でインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Conversely, Swift also provides the <bpt i="0" x="0">&lt;c0&gt;</bpt>@nonobjc<ept i="0">&lt;/c0&gt;</ept> attribute, which makes a Swift declaration unavailable in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>逆に、スウィフトはまた<bpt i="0" x="0">&lt;c0&gt;</bpt>@nonobjc<ept i="0">&lt;/c0&gt;</ept>属性も提供します、それはあるスウィフト宣言をObjective-Cにおいて利用不可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Converting Errors to Optional Values</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーをオプショナルの値に変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Copy Semantics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コピー意味論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Core Data also provides the implementation of instance methods that you use to add and remove objects from to-many relationships.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コアデータはまた、あなたが対多リレーションシップからのオブジェクトの追加と削除をするために使うインスタンスメソッドの実装を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Core Data provides the underlying storage and implementation of properties in subclasses of the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSManagedObject<ept i="0">&lt;/c0&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コアデータは、プロパティたちの基盤となる外部記憶と実装を<bpt i="0" x="0">&lt;c0&gt;</bpt>NSManagedObject<ept i="0">&lt;/c0&gt;</ept>クラスのサブクラスにおいて提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Core Foundation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コアファウンデーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Core Foundation objects returned from annotated APIs are automatically memory managed in Swift—you do not need to invoke the <bpt i="0" x="0">&lt;c0&gt;</bpt>CFRetain<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>CFRelease<ept i="1">&lt;/c1&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt>CFAutorelease<ept i="2">&lt;/c2&gt;</ept> functions yourself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>注釈をつけられたAPIから返されるコアファウンデーション・オブジェクトは、自動的にスウィフトにおいてメモリ管理されます ― あなたは、あなた自身で<bpt i="0" x="0">&lt;c0&gt;</bpt>CFRetain<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>CFRelease<ept i="1">&lt;/c1&gt;</ept>、または<bpt i="2" x="2">&lt;c2&gt;</bpt>CFAutorelease<ept i="2">&lt;/c2&gt;</ept>関数を呼び出す必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Core Foundation types are imported as Swift classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コアファウンデーション型は、スウィフトクラスとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Corrected the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Live Rendering<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section which previously stated that live rendering only worked when a designable class was compiled in a framework.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ライブレンダリング<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を訂正した、それは以前はライブレンダリングはただdesignableクラスがフレームワークにおいてコンパイルされた場合にのみ働くと述べていた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create a Swift class for your corresponding Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>.h<ept i="1">&lt;/c1&gt;</ept> files by choosing File &gt; New &gt; File &gt; (iOS, watchOS, tvOS, <bpt i="2" x="2">&lt;e2&gt;</bpt>or<ept i="2">&lt;/e2&gt;</ept> macOS) &gt; Source &gt; Swift File.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトクラスをあなたの対応するObjective-Cの<bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>.h<ept i="1">&lt;/c1&gt;</ept>ファイルのために、File &gt; New &gt; File &gt;（iOS、watchOS、tvOS、<bpt i="2" x="2">&lt;e2&gt;</bpt>または<ept i="2">&lt;/e2&gt;</ept>macOS）&gt; Source &gt; Swift Fileを選ぶことによって作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Create an observer for the key path and call the <bpt i="0" x="0">&lt;c0&gt;</bpt>observe(_:options:changeHandler)<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパスに対する監視を作成して<bpt i="0" x="0">&lt;c0&gt;</bpt>observe(_:options:changeHandler)<ept i="0">&lt;/c0&gt;</ept>メソッドを呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Curried functions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>カリー化関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Data Type Size Calculation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>データ型サイズ計算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declarations marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>dynamic<ept i="0">&lt;/c0&gt;</ept> modifier must also be explicitly marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>@objc<ept i="1">&lt;/c1&gt;</ept> attribute unless the <bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept> attribute is implicitly added by the declaration’s context.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>dynamic<ept i="0">&lt;/c0&gt;</ept>修飾子で印される宣言はまた、明示的に<bpt i="1" x="1">&lt;c1&gt;</bpt>@objc<ept i="1">&lt;/c1&gt;</ept>属性で印されなければなりません、<bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept>属性が暗黙的にその宣言の持つ文脈によって加えられるのでない限り。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declarations marked with the <bpt i="3" x="3">&lt;c3&gt;</bpt>private<ept i="3">&lt;/c3&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt>fileprivate<ept i="4">&lt;/c4&gt;</ept> modifier do not appear in the generated header.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>private<ept i="3">&lt;/c3&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt>fileprivate<ept i="4">&lt;/c4&gt;</ept>修飾子で印される宣言は、生成されたヘッダの中に現れることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declare simple macros as global constants, and translate complex macros into functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単純なマクロをグローバルな定数として宣言してください、そして複雑なマクロを関数へと翻訳してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declaring Protocols</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコルを宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declaring a Swift Error Type That Can Be Used from Objective-C</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cから利用されることができるスウィフトエラー型を宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Declaring a Swift Protocol That Can Be Adopted by an Objective-C Class</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cクラスによって採用されることができるスウィフトプロトコルを宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Delegation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>委任</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Denote instance (<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>) and class (<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>) methods with <bpt i="2" x="2">&lt;c2&gt;</bpt>func<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>class func<ept i="3">&lt;/c3&gt;</ept>, respectively.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インスタンス（<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>）およびクラス（<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>）メソッドであることを、それぞれ<bpt i="2" x="2">&lt;c2&gt;</bpt>func<ept i="2">&lt;/c2&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt>class func<ept i="3">&lt;/c3&gt;</ept>で示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dictionaries</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>辞書</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Document Revision History</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文書改訂履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Don’t delete the <bpt i="1" x="1">&lt;c1&gt;</bpt>.m<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>.h<ept i="2">&lt;/c2&gt;</ept> files immediately; use them to troubleshoot.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>.m<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>.h<ept i="2">&lt;/c2&gt;</ept>ファイルを直ぐに削除しないでください；それらを不具合対処のために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Don’t try to persist the pointer and access it after the function has returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのポインタに固執すること、そして関数が帰った後でそれにアクセスすることを試みないでください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Downcasting Any</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Anyのダウンキャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Dynamic Method Lookup</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>動的メソッド検索</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each member of the C enumeration is imported as a global read-only computed property of the structure’s type—not as a member of the Swift structure itself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C列挙の各メンバーは、その構造体の型のグローバルな読み出し専用の計算プロパティとしてインポートされます ― スウィフト構造体自身のメンバーとしてではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Each platform argument consists of one of platform names listed below, followed by corresponding version number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>各プラットホーム引数は、以下で箇条書きにされるプラットホーム名の１つ、それに続く該当するバージョン番号から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Enumerations defined in Swift without <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> raw value type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>の生の値型なしでスウィフトにおいて定義される列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Error Handling</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーの処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Even though each migration experience is different depending on your existing codebase, there are some general steps and tools to help you troubleshoot your code migration:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえそれぞれの移行体験があなたの既存のコードベースに従い異なるものではあっても、あなたのコード移行の問題解決を助けるいくつかの一般的な取るべき段階と手段があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Everything from your implementation and interface goes directly into this single Swift file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの実装とインタフェースからのすべては、直接この単一のスウィフトファイルに入ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Extensions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Failable Initialization</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>失敗できる初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fill out an Objective-C bridging header if you need to access Objective-C code from the same app target in your Swift file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあなたのスウィフトファイルにおいて同じアプリターゲットからのObjective-Cコードにアクセスする必要があるならば、Objective-C橋渡しヘッダに記入してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fixed the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept> example from the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Overriding Swift Names for Objective-C Interfaces<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section in the <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Swift and Objective-C in the Same Project<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Objective-Cインターフェイスのためのスウィフト名のオーバーライド<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節の<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept>例を<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>同じプロジェクト中のスウィフトとObjective-C<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>章において修正した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fixed the <bpt i="0" x="0">&lt;c0&gt;</bpt>UIBezierPath<ept i="0">&lt;/c0&gt;</ept> example to correctly create a triangle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>UIBezierPath<ept i="0">&lt;/c0&gt;</ept>例を直して、正しく三角形を作成できるようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Fixed the examples for <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_STRING_ENUM<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NS_EXTENSIBLE_STRING_ENUM<ept i="1">&lt;/c1&gt;</ept> in the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Imported Constant Enumerations and Structures<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS_STRING_ENUM<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>NS_EXTENSIBLE_STRING_ENUM<ept i="1">&lt;/c1&gt;</ept>のための例を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>インポートされる定数列挙と構造体<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の節において修正した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a list, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Using Swift from Objective-C<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その一覧のために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>スウィフトをObjective-Cから使う<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a short list of practices to adopt before moving forward, see <bpt i="0" x="0">&lt;e0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Adopting Modern Objective-C<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>前進する前に採用するべき短い慣行リストとして、<bpt i="0" x="0">&lt;e0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>現代のObjective-Cを採用する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/e0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For a straightforward, incremental migration of an app, you’ll be using the tools learned earlier—mix and match plus interoperability.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アプリのわかりやすい、徐々に進める移動のために、あなたは以前に学んだいくつかの手段を使用することになります ― 混合と適合それに相互運用性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an example of using target-action in Swift code, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Selectors<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコードにおいてターゲット-アクションを使う例のために、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>セレクタ<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For an unspecialized Objective-C type, Swift infers the generic parameterization for the imported class type constraints.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特殊化されないObjective-C型に対して、スウィフトは総称体パラメータ化をインポートされたクラス型制約に対して推測します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For app targets, declarations marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>internal<ept i="0">&lt;/c0&gt;</ept> modifier appear in the generated header if the app target has an Objective-C bridging header.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アプリターゲットでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>internal<ept i="0">&lt;/c0&gt;</ept>修飾子で印される宣言は、そのアプリターゲットがObjective-C橋渡しヘッダを持つならば、生成ヘッダの中に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For class types, the following mappings apply:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラス型のために、以下のマッピングが適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For considerations on translating your properties from Objective-C to Swift, read <bpt i="0" x="0">&lt;a0&gt;</bpt>Properties<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにあなたのプロパティをObjective-Cから翻訳することでの配慮について、<bpt i="0" x="0">&lt;a0&gt;</bpt>プロパティ<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>で読んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For consistency and simplicity, Objective-C class factory methods are imported as convenience initializers in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一貫性と単純さのために、Objective-Cクラスファクトリメソッドは、便宜イニシャライザとしてスウィフトにインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, <bpt i="0" x="0">&lt;c0&gt;</bpt>NSString **<ept i="0">&lt;/c0&gt;</ept> comes over to Swift as <bpt i="1" x="1">&lt;c1&gt;</bpt>AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;<ept i="1">&lt;/c1&gt;</ept>, not <bpt i="2" x="2">&lt;c2&gt;</bpt>AutoreleasingUnsafeMutablePointer&lt;String?&gt;<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSString **<ept i="0">&lt;/c0&gt;</ept>はスウィフトに<bpt i="1" x="1">&lt;c1&gt;</bpt>AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;<ept i="1">&lt;/c1&gt;</ept>としてやってきます、<bpt i="2" x="2">&lt;c2&gt;</bpt>AutoreleasingUnsafeMutablePointer&lt;String?&gt;<ept i="2">&lt;/c2&gt;</ept>ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, a function pointer that has the type <bpt i="1" x="1">&lt;c1&gt;</bpt>int (*)(void)<ept i="1">&lt;/c1&gt;</ept> in C is imported into Swift as <bpt i="2" x="2">&lt;c2&gt;</bpt>@convention(c) () -&gt; Int32<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、Cにおける<bpt i="1" x="1">&lt;c1&gt;</bpt>int (*)(void)<ept i="1">&lt;/c1&gt;</ept>型をもつ関数ポインターは、スウィフトに<bpt i="2" x="2">&lt;c2&gt;</bpt>@convention(c) () -&gt; Int32<ept i="2">&lt;/c2&gt;</ept>としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, an Objective-C class providing a convenience initializer that takes variadic arguments for keys-value pairs may advise a Swift consumer to use a dictionary literal instead:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あるObjective-Cクラスは便利なイニシャライザを提供していて、それは可変長引数をキー-値ペアに対して取るもので、スウィフト消費者に勧めるのは代わりに1つの辞書を使うことです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, an app that communicates with a web server would receive JSON representations of grocery products, such as:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あるアプリでウェブサーバと通信するものは、日用製品のJSON表現を受け取るでしょう、このように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, casting an <bpt i="4" x="4">&lt;c4&gt;</bpt>NSNumber<ept i="4">&lt;/c4&gt;</ept> value representing the number 500 to the <bpt i="5" x="5">&lt;c5&gt;</bpt>Int8<ept i="5">&lt;/c5&gt;</ept> Swift type will fail and return <bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept>, because the largest value that an <bpt i="7" x="7">&lt;c7&gt;</bpt>Int8<ept i="7">&lt;/c7&gt;</ept> value can represent is 127.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、数500を表している<bpt i="4" x="4">&lt;c4&gt;</bpt>NSNumber<ept i="4">&lt;/c4&gt;</ept>値を<bpt i="5" x="5">&lt;c5&gt;</bpt>Int8<ept i="5">&lt;/c5&gt;</ept>のSwift型へキャストすることは失敗して<bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept>を返します、なぜなら<bpt i="7" x="7">&lt;c7&gt;</bpt>Int8<ept i="7">&lt;/c7&gt;</ept>値が表すことができる最大値は127だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider Core Foundation’s <bpt i="1" x="1">&lt;c1&gt;</bpt>CFArrayCreateMutable(_:_:_:)<ept i="1">&lt;/c1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、Core Foundationの<bpt i="1" x="1">&lt;c1&gt;</bpt>CFArrayCreateMutable(_:_:_:)<ept i="1">&lt;/c1&gt;</ept>関数を考えてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider a C structure named <bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept> that contains the fields <bpt i="1" x="1">&lt;c1&gt;</bpt>layers<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>height<ept i="2">&lt;/c2&gt;</ept> nested within an unnamed <bpt i="3" x="3">&lt;c3&gt;</bpt>union<ept i="3">&lt;/c3&gt;</ept> type, and a field <bpt i="4" x="4">&lt;c4&gt;</bpt>toppings<ept i="4">&lt;/c4&gt;</ept> of an unnamed <bpt i="5" x="5">&lt;c5&gt;</bpt>struct<ept i="5">&lt;/c5&gt;</ept> type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept>と名前を付けられるC構造体を考えてください、それはフィールド<bpt i="1" x="1">&lt;c1&gt;</bpt>layers<ept i="1">&lt;/c1&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt>height<ept i="2">&lt;/c2&gt;</ept>を無名の<bpt i="3" x="3">&lt;c3&gt;</bpt>union<ept i="3">&lt;/c3&gt;</ept>型内部に、そして無名<bpt i="5" x="5">&lt;c5&gt;</bpt>struct<ept i="5">&lt;/c5&gt;</ept>型のフィールド<bpt i="4" x="4">&lt;c4&gt;</bpt>toppings<ept i="4">&lt;/c4&gt;</ept>を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider a C union named <bpt i="0" x="0">&lt;c0&gt;</bpt>SchroedingersCat<ept i="0">&lt;/c0&gt;</ept> that has an <bpt i="1" x="1">&lt;c1&gt;</bpt>isAlive<ept i="1">&lt;/c1&gt;</ept> and an <bpt i="2" x="2">&lt;c2&gt;</bpt>isDead<ept i="2">&lt;/c2&gt;</ept> field:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>SchroedingersCat<ept i="0">&lt;/c0&gt;</ept>と名前を付けられるC共用体を考えてください、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>isAlive<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>isDead<ept i="2">&lt;/c2&gt;</ept>フィールドを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider a Core Data entity called “Person” with a String attribute “name” and a to-many relationship “friends”:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あるコアデータ・エントリ、「Person」と呼ばれて、String属性「name」と対多リレーションシップ「friends」をもつものを考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider a simple <bpt i="0" x="0">&lt;c0&gt;</bpt>Task<ept i="0">&lt;/c0&gt;</ept> model, which is used by a <bpt i="1" x="1">&lt;c1&gt;</bpt>ToDoListController<ept i="1">&lt;/c1&gt;</ept> to display a list of tasks to complete:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、単純な<bpt i="0" x="0">&lt;c0&gt;</bpt>Task<ept i="0">&lt;/c0&gt;</ept>モデルを考えてください、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>ToDoListController<ept i="1">&lt;/c1&gt;</ept>によって使われて完了するべきタスク（作業）のリストを表示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider the <bpt i="0" x="0">&lt;c0&gt;</bpt>read(from:ofType:)<ept i="0">&lt;/c0&gt;</ept> method in <bpt i="1" x="1">&lt;c1&gt;</bpt>NSDocument<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例として、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSDocument<ept i="0">&lt;/c0&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>read(from:ofType:)<ept i="1">&lt;/c1&gt;</ept>メソッドを考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider the following C function declarations:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のC関数定義を考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider the following Objective-C declarations for integer constants of type <bpt i="1" x="1">&lt;c1&gt;</bpt>TrafficLightColor<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、型<bpt i="1" x="1">&lt;c1&gt;</bpt>TrafficLightColor<ept i="1">&lt;/c1&gt;</ept>の整数定数のための以下のObjective-C宣言を考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider the following Objective-C declarations that represent sets of actively illuminated colors on a traffic light:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、信号機上で活発に変わる照明された色の一揃いを表す以下のObjective-C宣言を考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider the following Objective-C declarations:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例として、以下のObjective-C宣言を考えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider the following Objective-C method from <bpt i="0" x="0">&lt;c0&gt;</bpt>NSFileManager<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例として、以下の<bpt i="0" x="0">&lt;c0&gt;</bpt>NSFileManager<ept i="0">&lt;/c0&gt;</ept>からのObjective-Cメソッドを考えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider the following Objective-C options declaration:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例として、以下のObjective-Cオプション定義を考えてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, consider the following Swift declaration:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例として、以下のスウィフト宣言を考えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, given the following C function declarations:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のC関数定義を与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, given the following C structure:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のC構造体を与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, given the following Objective-C class and category declarations:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のObjective-Cクラスおよびカテゴリ定義を与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, given the following Objective-C declarations:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のObjective-C宣言を与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, given the following Objective-C method that performs an operation on the specified class:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、指定されたクラス上である演算を実行する以下のObjective-Cメソッドを与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, given the following Objective-C property declarations:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のObjective-Cプロパティを与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, given the following Objective-C property that refers to a view controller:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あるビューコントローラを参照する以下のObjective-Cプロパティを与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, given the following Swift enumeration declaration:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のスウィフト列挙宣言を与えられたとして：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, here is an Objective-C block variable:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ひとつのObjective-Cブロック変数がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, here’s an unannotated C function:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ここに注釈をつけられなかったC関数があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, here’s how to call the <bpt i="0" x="0">&lt;c0&gt;</bpt>vasprintf<ept i="0">&lt;/c0&gt;</ept> function in Swift:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、ここに<bpt i="0" x="0">&lt;c0&gt;</bpt>vasprintf<ept i="0">&lt;/c0&gt;</ept>関数をスウィフトにおいて呼び出す方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if the name of your Swift class contains a character that isn’t supported by Objective-C, you can provide an alternative name to use in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたのスウィフトクラスの名前がObjective-Cで支持されない文字を含むならば、あなたはObjective-Cで使うために代わりの名前を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, if you compile the code below using <bpt i="1" x="1">&lt;c1&gt;</bpt>swift -D DEBUG_LOGGING<ept i="1">&lt;/c1&gt;</ept> to set the <bpt i="2" x="2">&lt;c2&gt;</bpt>DEBUG_LOGGING<ept i="2">&lt;/c2&gt;</ept> conditional compilation flag, the compiler includes the code in the body of the conditional complication block.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたが下記のコードを<bpt i="1" x="1">&lt;c1&gt;</bpt>swift -D DEBUG_LOGGING<ept i="1">&lt;/c1&gt;</ept>を使ってコンパイルして<bpt i="2" x="2">&lt;c2&gt;</bpt>DEBUG_LOGGING<ept i="2">&lt;/c2&gt;</ept>条件コンパイルフラグを設定するならば、コンパイラはそのコードを条件コンパイルブロックの本文の中に含めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, in Swift code, you can pass a <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> value to an Objective-C method declared to take an <bpt i="2" x="2">&lt;c2&gt;</bpt>NSString<ept i="2">&lt;/c2&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、スウィフトコードにおいて、あなたはある<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>値を、<bpt i="2" x="2">&lt;c2&gt;</bpt>NSString<ept i="2">&lt;/c2&gt;</ept>パラメータをとるように宣言されたObjective-Cメソッドに渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, in the code listing below, the first and second lines are not executed because the <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> property and the <bpt i="1" x="1">&lt;c1&gt;</bpt>character(at:)<ept i="1">&lt;/c1&gt;</ept> method do not exist on an <bpt i="2" x="2">&lt;c2&gt;</bpt>NSDate<ept i="2">&lt;/c2&gt;</ept> object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、下記のコード出力において、最初と２番目の行が実行されません、なぜなら、<bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>プロパティと<bpt i="1" x="1">&lt;c1&gt;</bpt>character(at:)<ept i="1">&lt;/c1&gt;</ept>メソッドは<bpt i="2" x="2">&lt;c2&gt;</bpt>NSDate<ept i="2">&lt;/c2&gt;</ept>オブジェクトには存在しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, information that may be helpful, but isn’t essential for troubleshooting errors should be logged at the Info level.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、助けとなるかもしれない、しかしエラーを解決するのに必須ではない情報は、Info水準でログされるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, suppose the C function above does not retain the <bpt i="0" x="0">&lt;c0&gt;</bpt>CFString<ept i="0">&lt;/c0&gt;</ept> object before returning it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、上のC関数が<bpt i="0" x="0">&lt;c0&gt;</bpt>CFString<ept i="0">&lt;/c0&gt;</ept>オブジェクトを、それを返す前に保持しないと思ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSFileManager<ept i="0">&lt;/c0&gt;</ept> instance method <bpt i="1" x="1">&lt;c1&gt;</bpt>URL(for:in:appropriateForURL:create:)<ept i="1">&lt;/c1&gt;</ept> returns a URL in the specified search path and domain, or produces an error if an appropriate URL does not exist and cannot be created.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSFileManager<ept i="0">&lt;/c0&gt;</ept>のインスタンスメソッド<bpt i="1" x="1">&lt;c1&gt;</bpt>URL(for:in:appropriateForURL:create:)<ept i="1">&lt;/c1&gt;</ept>は指定された検索パスとドメインにおけるURLを返すか、または適切なURLが存在せず作成もできないならばエラーを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSJSONReadingOptions<ept i="0">&lt;/c0&gt;</ept> option set is imported as <bpt i="1" x="1">&lt;c1&gt;</bpt>JSONSerialization.ReadingOptions<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSJSONReadingOptions<ept i="0">&lt;/c0&gt;</ept>オプションセットは<bpt i="1" x="1">&lt;c1&gt;</bpt>JSONSerialization.ReadingOptions<ept i="1">&lt;/c1&gt;</ept>としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>UIImage(contentsOfFile:)<ept i="0">&lt;/c0&gt;</ept> initializer can fail to initialize a <bpt i="1" x="1">&lt;c1&gt;</bpt>UIImage<ept i="1">&lt;/c1&gt;</ept> object if an image file doesn’t exist at the provided path.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>UIImage(contentsOfFile:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザは、与えられたパスでファイルが存在しないならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>UIImage<ept i="1">&lt;/c1&gt;</ept>オブジェクトを初期化するのに失敗する可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>setsockopt(_:_:_:_:_:)<ept i="0">&lt;/c0&gt;</ept> function can specify a <bpt i="1" x="1">&lt;c1&gt;</bpt>timeval<ept i="1">&lt;/c1&gt;</ept> value as a receive timeout option (<bpt i="2" x="2">&lt;c2&gt;</bpt>SO_RCVTIMEO<ept i="2">&lt;/c2&gt;</ept>) for a socket by passing a pointer to that value and the length of that value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>setsockopt(_:_:_:_:_:)<ept i="0">&lt;/c0&gt;</ept>関数は、ある<bpt i="1" x="1">&lt;c1&gt;</bpt>timeval<ept i="1">&lt;/c1&gt;</ept>値を、受信時間切れオプション（<bpt i="2" x="2">&lt;c2&gt;</bpt>SO_RCVTIMEO<ept i="2">&lt;/c2&gt;</ept>）としてあるソケットに対して指定することが、その値へのポインタとその値の長さを渡すことによって可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="3" x="3">&lt;c3&gt;</bpt>NSCoder<ept i="3">&lt;/c3&gt;</ept> method <bpt i="4" x="4">&lt;c4&gt;</bpt>decodeObjectOfClass(_:forKey:)<ept i="4">&lt;/c4&gt;</ept> uses Swift generics to provide a stronger type signature.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="3" x="3">&lt;c3&gt;</bpt>NSCoder<ept i="3">&lt;/c3&gt;</ept>のメソッド<bpt i="4" x="4">&lt;c4&gt;</bpt>decodeObjectOfClass(_:forKey:)<ept i="4">&lt;/c4&gt;</ept>は、スウィフト総称体を使うことでより強力な型シグネチャを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="3" x="3">&lt;c3&gt;</bpt>requestWhenInUseAuthorization<ept i="3">&lt;/c3&gt;</ept> method is only available to instances of <bpt i="4" x="4">&lt;c4&gt;</bpt>CLLocationManager<ept i="4">&lt;/c4&gt;</ept> starting in iOS 8.0 and macOS 10.10:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="3" x="3">&lt;c3&gt;</bpt>requestWhenInUseAuthorization<ept i="3">&lt;/c3&gt;</ept>メソッドは、<bpt i="4" x="4">&lt;c4&gt;</bpt>CLLocationManager<ept i="4">&lt;/c4&gt;</ept>のインスタンスに対してiOS 8.0およびmacOS 10.10からのみ利用可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the <bpt i="7" x="7">&lt;c7&gt;</bpt>timeval<ept i="7">&lt;/c7&gt;</ept> structure in Darwin has a size and stride of <bpt i="8" x="8">&lt;c8&gt;</bpt>16<ept i="8">&lt;/c8&gt;</ept> and an alignment of <bpt i="9" x="9">&lt;c9&gt;</bpt>8<ept i="9">&lt;/c9&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、Darwinにおける<bpt i="7" x="7">&lt;c7&gt;</bpt>timeval<ept i="7">&lt;/c7&gt;</ept>構造体は、<bpt i="8" x="8">&lt;c8&gt;</bpt>16<ept i="8">&lt;/c8&gt;</ept>のサイズとストライドおよび<bpt i="9" x="9">&lt;c9&gt;</bpt>8<ept i="9">&lt;/c9&gt;</ept>のアラインメントを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the C enumeration below is declared using the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_ENUM<ept i="0">&lt;/c0&gt;</ept> macro.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のC列挙は<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_ENUM<ept i="0">&lt;/c0&gt;</ept>マクロを使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the constant definition <bpt i="1" x="1">&lt;c1&gt;</bpt>#define FADE_ANIMATION_DURATION 0.35<ept i="1">&lt;/c1&gt;</ept> can be better expressed in Swift with <bpt i="2" x="2">&lt;c2&gt;</bpt>let FADE_ANIMATION_DURATION = 0.35<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、定数定義<bpt i="1" x="1">&lt;c1&gt;</bpt>#define FADE_ANIMATION_DURATION 0.35<ept i="1">&lt;/c1&gt;</ept>は、スウィフトにおいてよりよく表されることが<bpt i="2" x="2">&lt;c2&gt;</bpt>let FADE_ANIMATION_DURATION = 0.35<ept i="2">&lt;/c2&gt;</ept>でできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following C enumeration is not declared using the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_ENUM<ept i="0">&lt;/c0&gt;</ept> macro:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のC列挙は<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_ENUM<ept i="0">&lt;/c0&gt;</ept>マクロを使って宣言されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following Swift code declares a class with an outlet, an outlet collection, and an action:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のスウィフトコードは、１つのアウトレット、１つのアウトレット接続、そして１つのアクションを持つクラスを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the following code compiles without a compiler warning, but triggers an error at runtime:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、以下のコードは警告なしにコンパイルします、しかし実行時にエラーの引き金となります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the fully qualified name of a Swift class named <bpt i="0" x="0">&lt;c0&gt;</bpt>DataManager<ept i="0">&lt;/c0&gt;</ept> in a framework named <bpt i="1" x="1">&lt;c1&gt;</bpt>MyFramework<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>MyFramework.DataManager<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>MyFramework<ept i="1">&lt;/c1&gt;</ept>と命名されるあるフレームワークの<bpt i="0" x="0">&lt;c0&gt;</bpt>DataManager<ept i="0">&lt;/c0&gt;</ept>と命名されるあるスウィフトクラスの完全修飾名は、<bpt i="2" x="2">&lt;c2&gt;</bpt>MyFramework.DataManager<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, the most common form of a localized string in an app may only need a localization key and a comment:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、アプリにおける最も一般的な形式の現地語化文字列は、現地語キーとコメントを必要とするだけでしょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, to use Foundation APIs from a Swift file, add the following import statement to the top of the file:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、Foundation APIをスウィフトファイルから利用するには、以下のインポート文をその ファイルの一番上に加えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, using these APIs would be appropriate if you need to implement a class that uses the target-action design pattern in its interface, like <bpt i="1" x="1">&lt;c1&gt;</bpt>NSResponder<ept i="1">&lt;/c1&gt;</ept> does.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、これらのAPIの使用は、もしあなたがそれのインターフェイスにおいてターゲット-アクション・デザインパターンを使うクラスを実装する必要があるならば適切でしょう、<bpt i="1" x="1">&lt;c1&gt;</bpt>NSResponder<ept i="1">&lt;/c1&gt;</ept>がするように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, when you create a document–based Mac app, you provide the name of your <bpt i="0" x="0">&lt;c0&gt;</bpt>NSDocument<ept i="0">&lt;/c0&gt;</ept> subclass in your app’s <bpt i="1" x="1">&lt;c1&gt;</bpt>Info.plist<ept i="1">&lt;/c1&gt;</ept> file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたがドキュメントベースのMacアプリを作成しているとき、あなたは、あなたの<bpt i="0" x="0">&lt;c0&gt;</bpt>NSDocument<ept i="0">&lt;/c0&gt;</ept>サブクラスの名前をあなたのアプリの<bpt i="1" x="1">&lt;c1&gt;</bpt>Info.plist<ept i="1">&lt;/c1&gt;</ept>ファイルにおいて提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, whereas in Objective-C you would call this factory method like this:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、Objective-Cではあなたはこのクラスファクトリメソッドこのように呼び出しますが：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, whereas in Objective-C you would do this:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、Objective-Cではあなたがこうするのに対して：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can assign an object of any class type to a constant or variable of <bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept> type and reassign a variable to an object of a different type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはどんなクラス型のオブジェクトでも<bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept>型の定数や変数に代入できます、そしてある変数を異なる型のオブジェクトへ再度代入できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can extend the <bpt i="0" x="0">&lt;c0&gt;</bpt>UIBezierPath<ept i="0">&lt;/c0&gt;</ept> class to create a simple Bézier path with an equilateral triangle, based on a provided side length and starting point.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>UIBezierPath<ept i="0">&lt;/c0&gt;</ept>クラスを拡張して、二等辺三角形を使った単純な「ベジェ」パスを作成するようにできます、それは提供された辺長と開始点に基づきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can mark a property called <bpt i="3" x="3">&lt;c3&gt;</bpt>enabled<ept i="3">&lt;/c3&gt;</ept> to have a getter named <bpt i="4" x="4">&lt;c4&gt;</bpt>isEnabled<ept i="4">&lt;/c4&gt;</ept> in Objective-C like this:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたは<bpt i="3" x="3">&lt;c3&gt;</bpt>enabled<ept i="3">&lt;/c3&gt;</ept>と呼ばれるあるプロパティを、以下のように印してObjective-Cにおいて<bpt i="4" x="4">&lt;c4&gt;</bpt>isEnabled<ept i="4">&lt;/c4&gt;</ept>と名前をつけられるゲッターを持つようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can set the <bpt i="0" x="0">&lt;c0&gt;</bpt>textColor<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>text<ept i="1">&lt;/c1&gt;</ept> properties of a <bpt i="2" x="2">&lt;c2&gt;</bpt>UITextField<ept i="2">&lt;/c2&gt;</ept> object with the following code:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはある<bpt i="2" x="2">&lt;c2&gt;</bpt>UITextField<ept i="2">&lt;/c2&gt;</ept>オブジェクトの<bpt i="0" x="0">&lt;c0&gt;</bpt>textColor<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>text<ept i="1">&lt;/c1&gt;</ept>プロパティを設定するにの以下のコードを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can use a buffer pointer for efficent processing and communication of data between apps and services.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>たとえば、あなたはアプリとサービス間での効率の良いデータの処理および通信のためにバッファポインタを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>\Animal.name<ept i="0">&lt;/c0&gt;</ept> key-path expression to access the <bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept> property of the <bpt i="2" x="2">&lt;c2&gt;</bpt>Animal<ept i="2">&lt;/c2&gt;</ept> class shown below.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>\Animal.name<ept i="0">&lt;/c0&gt;</ept>キーパス式を使って、下で示す<bpt i="2" x="2">&lt;c2&gt;</bpt>Animal<ept i="2">&lt;/c2&gt;</ept>クラスの<bpt i="1" x="1">&lt;c1&gt;</bpt>name<ept i="1">&lt;/c1&gt;</ept>プロパティにアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example, you see this behavior when an optional is passed to an Objective-C API that takes a nonnull <bpt i="3" x="3">&lt;c3&gt;</bpt>id<ept i="3">&lt;/c3&gt;</ept> and when an array of optional items (<bpt i="4" x="4">&lt;c4&gt;</bpt>[T?]<ept i="4">&lt;/c4&gt;</ept>) is bridged to an <bpt i="5" x="5">&lt;c5&gt;</bpt>NSArray<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、あなたはこの挙動を、あるオプショナルが非null <bpt i="3" x="3">&lt;c3&gt;</bpt>id<ept i="3">&lt;/c3&gt;</ept>をとるObjective-C APIに渡される時、およびオプショナル項目（<bpt i="4" x="4">&lt;c4&gt;</bpt>[T?]<ept i="4">&lt;/c4&gt;</ept>）からなる配列が<bpt i="5" x="5">&lt;c5&gt;</bpt>NSArray<ept i="5">&lt;/c5&gt;</ept>へブリッジされる時に見ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For framework targets, only declarations with the <bpt i="0" x="0">&lt;c0&gt;</bpt>public<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>open<ept i="1">&lt;/c1&gt;</ept> modifier appear in the generated header.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>フレームワークターゲットでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>public<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>open<ept i="1">&lt;/c1&gt;</ept>修飾子を持つ宣言だけが生成ヘッダの中に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For functions and methods, this process affects the types of their arguments and return values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数とメソッドに対して、このプロセスは、それらの引数と戻り値の型に影響を及ぼします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information about encoding and decoding more complex custom types, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Encoding and Decoding Custom Types<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>より複雑なカスタム型のエンコードおよびデコードについての情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>Encoding and Decoding Custom Types<ept i="0">&lt;/a0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information about when the <bpt i="3" x="3">&lt;c3&gt;</bpt>@objc<ept i="3">&lt;/c3&gt;</ept> attribute is implicitly added, see <bpt i="4" x="4">&lt;a4&gt;</bpt>Declaration Attributes<ept i="4">&lt;/a4&gt;</ept> in <bpt i="5" x="5">&lt;e5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/e5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>@objc<ept i="3">&lt;/c3&gt;</ept>属性が暗黙的に加えられる場合についての情報として、<bpt i="4" x="4">&lt;a4&gt;</bpt>宣言属性<ept i="4">&lt;/a4&gt;</ept>を<bpt i="5" x="5">&lt;e5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/e5&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information on product module naming, see <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Naming Your Product Module<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>製品モジュールに名前をつけることに関する情報のために、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>あなたの製品モジュールに名をつける<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For information on using Swift from Objective-C code, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Using Swift from Objective-C<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cコードからスウィフトを使うことに関する情報のために、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>スウィフトをObjective-Cから使う<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instance, an Objective-C method that takes one or more pointer arguments could be refined in Swift to return a tuple of values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>例えば、１つ以上のポインタ引数を取るObjective-Cメソッドが改良されてスウィフトにおいてタプル値を返すようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For instructions, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Importing Code from Within the Same App Target<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>手順指示のために、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>コードを同じアプリターゲットからインポートする<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For methods that take more than one argument, you can create an undo operation using an <bpt i="0" x="0">&lt;c0&gt;</bpt>NSInvocation<ept i="0">&lt;/c0&gt;</ept>, which invokes the method with arguments that effectively revert the app to its previous state:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つ以上の引数を取るメソッドのために、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>NSInvocation<ept i="0">&lt;/c0&gt;</ept>を使って取り消し操作を作成することができます、それはアプリをそれの前の状態に効果的に戻す引数を使ってそのメソッドを呼び出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about encoding and decoding JSON, see <bpt i="1" x="1">&lt;a1&gt;</bpt>Using JSON with Custom Types<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>JSONのエンコードおよびデコードについてのさらなる情報として、<bpt i="1" x="1">&lt;a1&gt;</bpt>Using JSON with Custom Types<ept i="1">&lt;/a1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about implementing comparison logic, see <bpt i="3" x="3">&lt;a3&gt;</bpt>Object comparison<ept i="3">&lt;/a3&gt;</ept> in <bpt i="4" x="4">&lt;e4&gt;</bpt>Cocoa Core Competencies<ept i="4">&lt;/e4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>比較ロジックの実装についての更なる情報として、<bpt i="3" x="3">&lt;a3&gt;</bpt>Object comparison<ept i="3">&lt;/a3&gt;</ept>を<bpt i="4" x="4">&lt;e4&gt;</bpt>Cocoa Core Competencies<ept i="4">&lt;/e4&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about implementing your own deinitializers, see <bpt i="2" x="2">&lt;a2&gt;</bpt>Deinitializers<ept i="2">&lt;/a2&gt;</ept> in <bpt i="3" x="3">&lt;e3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなた自身のデイニシャライザを実装することについての更なる情報として、<bpt i="2" x="2">&lt;a2&gt;</bpt>デイニシャライザ<ept i="2">&lt;/a2&gt;</ept>を<bpt i="3" x="3">&lt;e3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/e3&gt;</ept>でみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about implementing your own initializers, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Initializers<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなた自身のイニシャライザを実装することについての更なる情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>イニシャライザ<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>でみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about optionals, see <bpt i="4" x="4">&lt;a4&gt;</bpt>Optionals<ept i="4">&lt;/a4&gt;</ept> in <bpt i="5" x="5">&lt;e5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/e5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルについての更なる情報として、<bpt i="4" x="4">&lt;a4&gt;</bpt>オプショナル<ept i="4">&lt;/a4&gt;</ept>を<bpt i="5" x="5">&lt;e5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/e5&gt;</ept>において見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about specifiying platform availability, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Declaration Attributes<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プラットホーム利用可能性を指定することについての更なる情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>宣言属性<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about the unified logging system, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Logging<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>統合ログシステムについてのさらなる情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>Logging<ept i="0">&lt;/a0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about value types, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Classes and Structures<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>, and WWDC 2015 session 414 <bpt i="3" x="3">&lt;a3&gt;</bpt>Building Better Apps with Value Types in Swift<ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値型についてのさらなる情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>クラスと構造体<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>スウィフトプログラミング言語 (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>で、そしてWWDC 2015 セッション 414 <bpt i="3" x="3">&lt;a3&gt;</bpt>より良いアプリをスウィフトの値型で作り上げる<ept i="3">&lt;/a3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information about what you can access from Objective-C and how the Swift interface is imported, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Swift Type Compatibility<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがObjective-Cからアクセスできることとスウィフトインタへフェイスがインポートされる方法についての更なる情報として、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>スウィフト型互換性<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information on <bpt i="2" x="2">&lt;c2&gt;</bpt>dynamic<ept i="2">&lt;/c2&gt;</ept>, see <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Requiring Dynamic Dispatch<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>dynamic<ept i="2">&lt;/c2&gt;</ept>に関数さらなる情報として、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>動的なディスパッチを要求する<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information on <bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept>, see <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Swift Type Compatibility<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept>の詳細については、<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>スウィフト型互換性<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information on access-level modifiers, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Access Control<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセス水準修飾子に関する更なる情報のために、<bpt i="0" x="0">&lt;a0&gt;</bpt>アクセス制御<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information on access-level modifiers, see <bpt i="3" x="3">&lt;a3&gt;</bpt>Access Control<ept i="3">&lt;/a3&gt;</ept> in <bpt i="4" x="4">&lt;e4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/e4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アクセス水準修飾子に関する更なる情報のために、<bpt i="3" x="3">&lt;a3&gt;</bpt>アクセス制御<ept i="3">&lt;/a3&gt;</ept>を<bpt i="4" x="4">&lt;e4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/e4&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information on key paths, see <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Keys and Key Paths<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>新しいキーパスについてのさらなる情報として、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>キーとキーパス<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information on using Objective-C in Swift, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Interacting with Objective-C APIs<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cをスウィフトにおいて使うことに関するさらなる情報のために<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Objective-C APIとの相互作用<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information on using Swift in Objective-C, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Swift and Objective-C in the Same Project<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでスウィフトを使うことの詳細については、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>同じプロジェクト中のスウィフトとObjective-C<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Lazy Stored Properties<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>遅延保存プロパティ<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Ownership Policy<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Memory Management Programming Guide for Core Foundation<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報のために、<bpt i="0" x="0">&lt;a0&gt;</bpt>所有者方針<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>コアファウンデーションのためのメモリ管理プログラミングガイド<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Protocols<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらなる情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>プロトコル<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Resolving Strong Reference Cycles for Closures<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>クロージャのための強い参照循環の解消<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Type Attributes<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報としては、<bpt i="0" x="0">&lt;a0&gt;</bpt>型属性<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>において見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Type Casting<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらなる情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>型キャスト<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Type Properties<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>型プロパティ<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="1" x="1">&lt;a1&gt;</bpt>Attributes<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="1" x="1">&lt;a1&gt;</bpt>属性<ept i="1">&lt;/a1&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="3" x="3">&lt;a3&gt;</bpt>Attributes<ept i="3">&lt;/a3&gt;</ept> in <bpt i="4" x="4">&lt;e4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/e4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="3" x="3">&lt;a3&gt;</bpt>属性<ept i="3">&lt;/a3&gt;</ept>を<bpt i="4" x="4">&lt;e4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/e4&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="4" x="4">&lt;a4&gt;</bpt>Properties<ept i="4">&lt;/a4&gt;</ept> in <bpt i="5" x="5">&lt;e5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>The Swift Programming Language (Swift 4)<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/e5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="4" x="4">&lt;a4&gt;</bpt>プロパティ<ept i="4">&lt;/a4&gt;</ept>を<bpt i="5" x="5">&lt;e5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>スウィフトプログラミング言語（Swift 4）<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/e5&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>AnyHashable<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>AnyHashable<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>MemoryLayout<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>MemoryLayout<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;e0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Advanced Memory Management Programming Guide<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらなる情報は、<bpt i="0" x="0">&lt;e0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Advanced Memory Management Programming Guide<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/e0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;e0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Internationalization and Localization Guide<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>さらなる情報として、<bpt i="0" x="0">&lt;e0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>インターナショナライゼーションとローカリゼーションのガイド<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/e0&gt;</ept>（Apple訳有り）を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;e0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Undo Architecture<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として<bpt i="0" x="0">&lt;e0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Undo Architecture<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/e0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Interacting with Objective-C APIs<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Objective-C APIとの相互作用<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Working with Cocoa Frameworks<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ココアフレームワーク<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を扱うを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Writing Swift Classes and Protocols with Objective-C Behavior<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>詳細は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>スウィフトのクラスとプロトコルをObjective-C挙動で書く<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For objects that are loaded from Storyboards or archived to disk using the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSUserDefaults<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>NSKeyedArchiver<ept i="1">&lt;/c1&gt;</ept> classes, you must provide a full implementation of this initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ストーリーボードからロードされるかディスクに<bpt i="0" x="0">&lt;c0&gt;</bpt>NSUserDefaults<ept i="0">&lt;/c0&gt;</ept>や<bpt i="1" x="1">&lt;c1&gt;</bpt>NSKeyedArchiver<ept i="1">&lt;/c1&gt;</ept>クラスを使ってアーカイブされるオブジェクトに対して、あなたはこのイニシャライザの完全な実装を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For pointers to untyped, raw memory, the following mappings apply:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型無しの、生のメモリへのポインタに対して、以下のマッピングを適用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For properties in Swift, you can create an undo operation in the <bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept> observer using <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> as the <bpt i="2" x="2">&lt;c2&gt;</bpt>target<ept i="2">&lt;/c2&gt;</ept>, the corresponding Objective-C setter as the <bpt i="3" x="3">&lt;c3&gt;</bpt>selector<ept i="3">&lt;/c3&gt;</ept>, and the current value of the property as the <bpt i="4" x="4">&lt;c4&gt;</bpt>object<ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでのプロパティに対して、あなたは取消操作を<bpt i="0" x="0">&lt;c0&gt;</bpt>willSet<ept i="0">&lt;/c0&gt;</ept>オブザーバにおいて作成することが<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>target<ept i="2">&lt;/c2&gt;</ept>として、対応Objective-Cセッターを<bpt i="3" x="3">&lt;c3&gt;</bpt>selector<ept i="3">&lt;/c3&gt;</ept>として、そしてプロパティの現在の値を<bpt i="4" x="4">&lt;c4&gt;</bpt>object<ept i="4">&lt;/c4&gt;</ept>として使って可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For return types, variables, and arguments, the following mappings apply:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>戻り型、変数、そして引数のために、以下のマッピングが適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For this reason, preprocessor directives are not imported in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この理由のために、プリプロセッサ指令は、スウィフトにインポートされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For this reason, you should almost never need to use a bridged reference type directly in your own code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この理由のために、あなたはブリッジ参照型を直接にあなた自身のコードにおいて使う必要はほとんどないはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For types, the process of importing can have the following effects:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型のために、インポートのプロセスは、以下の影響を与えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>For values that require additional setup beyond initialization, you can assign the default value of the property to a self-evaluating closure that returns a fully-initialized value:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化を越えて更なる準備が必要な値に対して、あなたはプロパティの省略時の値を得る仕事を、完全初期化された値を返すある自己評価するクロージャに任せることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Forward declarations of Swift classes and protocols can only be used as types for method and property declarations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのクラスとプロトコルの前方宣言は、ただメソッドおよびプロパティ宣言の型として使われることができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Foundation</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ファウンデーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Foundation classes often declare enumeration or constant types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Foundationクラスは、しばしば列挙や定数型を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>From here, you can start experimenting by writing Swift code in the app delegate or a new Swift file you create by choosing File &gt; New &gt; File &gt; (iOS, watchOS, tvOS, <bpt i="0" x="0">&lt;e0&gt;</bpt>or<ept i="0">&lt;/e0&gt;</ept> macOS) &gt; Source &gt; Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここから、あなたはアプリデリケートまたは「ファイル」&gt;「新規」&gt;「ファイル」&gt;（iOS、watchOS、tvOS、<bpt i="0" x="0">&lt;e0&gt;</bpt>または<ept i="0">&lt;/e0&gt;</ept>macOS）&gt;「ソース」&gt;「Swift」を選んで作成する新規スウィフトファイルにおいてスウィフトコードを書くことで実験を始めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Function Pointers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数ポインター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Functions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Generics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>総称体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Getting Started</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初めに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Given the following Objective-C declarations:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のObjective-C宣言を与えられたとして：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Global Constants</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>グローバルな定数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Global constants defined in C and Objective-C source files are automatically imported by the Swift compiler as Swift global constants.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>CとObjective-Cソース・ファイルにおいて定義されるグローバル定数は、スウィフトコンパイラによってスウィフトのグローバル定数として自動的にインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Global variables defined in Swift</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて定義されるグローバル変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Hashing</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ハッシュ化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here are the equivalent Swift initializer declarations:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに同等のスウィフトイニシャライザ宣言があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here is an example of using the <bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept> operator to check for protocol conformance:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>演算子を使ってプロトコル準拠について調べる例がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s an example of how to handle an error when calling a method in Objective-C:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにObejctive-Cにおいてメソッドを呼び出す時どのようにエラーを取り扱うかの例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how Swift imports it:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにスウィフトがそれをインポートする方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how Swift imports them as type members:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにどのようにスウィフトがそれらを型メンバとしてインポートするかがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how Swift imports them:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにどのようにスウィフトがそれらをインポートするかがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how it’s imported by Objective-C:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにそれがObjective-Cによってインポートされる方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how they’re imported by Swift:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに、どのようにそれらがスウィフトにインポートされるかがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s how to write a Swift type that represents a grocery product and can be used with any serialization format that provides encoders and decoders:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにあるのは、日用製品を表して、エンコーダおよびデコーダで提供される何らかのシリアライズ形式で使用できるスウィフト型を書く方法です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s the corresponding Objective-C declaration in the generated header:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに生成ヘッダにおける対応するObjective-C宣言があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s the corresponding Swift type:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここに対応するスウィフト型があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Here’s the previous example, in Swift:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ここにスウィフトでの以前の例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, because passing an optional when an <bpt i="3" x="3">&lt;c3&gt;</bpt>Any<ept i="3">&lt;/c3&gt;</ept> was expected is uncommon, the optionals passed into the <bpt i="4" x="4">&lt;c4&gt;</bpt>logSomeValue(_:)<ept i="4">&lt;/c4&gt;</ept> class method are explicitly cast to the <bpt i="5" x="5">&lt;c5&gt;</bpt>Any<ept i="5">&lt;/c5&gt;</ept> type, which silences a compiler warning.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、<bpt i="3" x="3">&lt;c3&gt;</bpt>Any<ept i="3">&lt;/c3&gt;</ept>が期待された時オプショナルを渡すことは普通でないため、<bpt i="4" x="4">&lt;c4&gt;</bpt>logSomeValue(_:)<ept i="4">&lt;/c4&gt;</ept>メソッドへと渡されるオプショナルは明示的に<bpt i="5" x="5">&lt;c5&gt;</bpt>Any<ept i="5">&lt;/c5&gt;</ept>型へキャストされます、それはコンパイラ警告を黙らせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, because the <bpt i="1" x="1">&lt;c1&gt;</bpt>Any<ept i="1">&lt;/c1&gt;</ept> type can refer to any type, a downcast to a more specific type is not guaranteed to succeed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、<bpt i="1" x="1">&lt;c1&gt;</bpt>Any<ept i="1">&lt;/c1&gt;</ept>型はあらゆる型を参照できることから、より具体的な型へダウンキャウトすることは成功することを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if a forced downcast fails, a runtime error is triggered:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、強制型キャストが失敗するならば、実行時エラーが引き起こされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, if your product name has any nonalphanumeric characters, such as a period (<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>), they are replaced with an underscore (<bpt i="1" x="1">&lt;c1&gt;</bpt>_<ept i="1">&lt;/c1&gt;</ept>) in your product module name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたの製品名がアルファベットでない文字、例えばピリオド（<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>）を持つならば、それらはあなたの製品モジュール名においてアンダーライン（<bpt i="1" x="1">&lt;c1&gt;</bpt>_<ept i="1">&lt;/c1&gt;</ept>）と取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, it is necessary when using APIs like key–value observing or the <bpt i="2" x="2">&lt;c2&gt;</bpt>method_exchangeImplementations<ept i="2">&lt;/c2&gt;</ept> function in the Objective-C runtime, which dynamically replace the implementation of a method at runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、それが必要であるのは、キー値監視または<bpt i="2" x="2">&lt;c2&gt;</bpt>method_exchangeImplementations<ept i="2">&lt;/c2&gt;</ept>関数のようなAPIをObjective-Cランタイムにおいて使う時です、それはあるメソッドの実装を実行時に動的に置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, macros can make debugging and refactoring difficult.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、マクロはデバッグやリファクタリングを難しくすることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, there is an exception if the compilation condition includes a <bpt i="0" x="0">&lt;c0&gt;</bpt>swift()<ept i="0">&lt;/c0&gt;</ept> platform condition: The statements are parsed only if the compiler’s version of Swift matches what is specified in the platform condition.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、例外があります、それはコンパイル条件が<bpt i="0" x="0">&lt;c0&gt;</bpt>swift()<ept i="0">&lt;/c0&gt;</ept>プラットホーム条件を含む場合です：文はスウィフトのコンパイラのバージョンがプラットホーム条件において指定されるものと合致する場合にのみ構文解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, there is no implicit conversion between these types and core Swift integer types, such as <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、これらの型と中心的なスウィフト整数型、例えば<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>との間に暗黙的な変換はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, these are imported by Swift as instance methods, as only Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>@property<ept i="0">&lt;/c0&gt;</ept> declarations are imported by Swift as properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、それらはスウィフトによってインスタンスメソッドのようにインポートされます、Objective-Cの<bpt i="0" x="0">&lt;c0&gt;</bpt>@property<ept i="0">&lt;/c0&gt;</ept>宣言だけはスウィフトによってプロパティとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, these properties must be computed; extensions can’t add stored properties to classes, structures, or enumerations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、これらのプロパティは、計算されなければなりません；拡張は、保存プロパティをクラス、構造体、または列挙に加えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, they are not accessible at compile time and do not appear in the generated header for a framework target.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、それらはコンパイル時にアクセス可能ではありません、そしてフレームワークターゲットのための生成ヘッダの中に現れません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, this does not prevent the Swift compiler from selecting a more efficient dispatch approach when those APIs are called from Swift code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、これはスウィフトコンパイラがより効果的なディスパッチを選択することを、それらのAPIがスウィフトコードから呼び出される時に妨げはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, to avoid cyclical references, don’t import Swift code from within the <bpt i="1" x="1">&lt;e1&gt;</bpt>same<ept i="1">&lt;/e1&gt;</ept> module into an Objective-C header (<bpt i="2" x="2">&lt;c2&gt;</bpt>.h<ept i="2">&lt;/c2&gt;</ept>) file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、循環参照を防ぐために、スウィフトコードを<bpt i="1" x="1">&lt;e1&gt;</bpt>同じ<ept i="1">&lt;/e1&gt;</ept>モジュール内部からObjective-Cヘッダ（<bpt i="2" x="2">&lt;c2&gt;</bpt>.h<ept i="2">&lt;/c2&gt;</ept>）ファイルへとインポートしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, you can also open an app programmatically and pass command-line arguments from Terminal.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、あなたはまたアプリをプログラムに基づきそしてコマンドライン引数を渡してTerminalから開くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>However, you might not need to implement an initializer for types that are expected to or cannot be instantiated in this way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかしながら、あなたはこの方法でインスタンス化されることが出来ないかそうするつもりでない型のためにイニシャライザを実装する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If 1 and 2 hold true, invoke the method and assign the result of the method to the value named <bpt i="0" x="0">&lt;c0&gt;</bpt>fullScreenSize<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１と２が当てはまるならば、そのメソッドを呼び出して、メソッドの結果を<bpt i="0" x="0">&lt;c0&gt;</bpt>fullScreenSize<ept i="0">&lt;/c0&gt;</ept>と名前をつけられる値に代入する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> maintains a strong reference to the block, such as a copying property, this would create a strong reference cycle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>がブロックに対する強い参照を管理するならば、これは強い参照循環を作り出すでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If Objective-C code calls a Swift method that throws an error, the error is automatically propagated to the error pointer argument of the bridged Objective-C method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cコードがエラーをスローするスウィフトメソッドを呼ぶならば、そのエラーは橋渡しされたObjective-Cメソッドのエラーポインタ引数に自動的に伝達されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a Swift method does not specify a return type, the corresponding Objective-C method has a <bpt i="3" x="3">&lt;c3&gt;</bpt>BOOL<ept i="3">&lt;/c3&gt;</ept> return type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのスウィフトメソッドが戻り型を指定しないならば、対応するObjective-Cメソッドは<bpt i="3" x="3">&lt;c3&gt;</bpt>BOOL<ept i="3">&lt;/c3&gt;</ept>の戻り型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If a lazy property has not yet been initialized and is accessed by more than one thread at the same time, there is no guarantee that the property will be initialized only once.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延プロパティがまだ初期化されてしまわないのに１つ以上のスレッドによって同時にアクセスされるならば、そのプロパティがただ一度だけ初期化されるとは保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If all of the imported members have default values, Swift also provides a default initializer that takes no arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポートされたメンバのすべてが省略時の値を持つならば、スウィフトもまた引数を取らない省略時のイニシャライザをひとつ提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an <bpt i="3" x="3">&lt;c3&gt;</bpt>NSArray<ept i="3">&lt;/c3&gt;</ept> object does not specify a parameterized type, it is bridged to a Swift array of type <bpt i="4" x="4">&lt;c4&gt;</bpt>[Any]<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>NSArray<ept i="3">&lt;/c3&gt;</ept>オブジェクトがパラメータ化された型を指定しないならば、それは型<bpt i="4" x="4">&lt;c4&gt;</bpt>[Any]<ept i="4">&lt;/c4&gt;</ept>のスウィフト配列に橋渡しされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an <bpt i="4" x="4">&lt;c4&gt;</bpt>NSDictionary<ept i="4">&lt;/c4&gt;</ept> object does not specify parameterized types, it is bridged to a Swift dictionary of type <bpt i="5" x="5">&lt;c5&gt;</bpt>[AnyHashable: Any]<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>NSDictionary<ept i="4">&lt;/c4&gt;</ept>オブジェクトがパラメーター化された型を指定しないならば、それは型<bpt i="5" x="5">&lt;c5&gt;</bpt>[AnyHashable: Any]<ept i="5">&lt;/c5&gt;</ept>のスウィフト辞書に橋渡しされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an <bpt i="4" x="4">&lt;c4&gt;</bpt>NSSet<ept i="4">&lt;/c4&gt;</ept> object does not specify a parameterized type, it is bridged to a Swift set of type <bpt i="5" x="5">&lt;c5&gt;</bpt>Set&lt;AnyHashable&gt;<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>NSSet<ept i="4">&lt;/c4&gt;</ept>オブジェクトがパラメーター化された型を指定しないならば、それは型<bpt i="5" x="5">&lt;c5&gt;</bpt>Set&lt;AnyHashable&gt;<ept i="5">&lt;/c5&gt;</ept>のスウィフト集合に橋渡しされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an <bpt i="8" x="8">&lt;c8&gt;</bpt>NSDictionary<ept i="8">&lt;/c8&gt;</ept> or <bpt i="9" x="9">&lt;c9&gt;</bpt>NSSet<ept i="9">&lt;/c9&gt;</ept> declaration does parameterize its key or object type, respectively, that type is used instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある<bpt i="8" x="8">&lt;c8&gt;</bpt>NSDictionary<ept i="8">&lt;/c8&gt;</ept>または<bpt i="9" x="9">&lt;c9&gt;</bpt>NSSet<ept i="9">&lt;/c9&gt;</ept>宣言がそれのキーまたはオブジェクト型をパラメータ化するならば、それぞれ、その型が代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an Objective-C method is overridden by a Swift method that cannot be represented in Objective-C, such as by specifying a parameter to be a variable, that method must be marked <bpt i="1" x="1">&lt;c1&gt;</bpt>@nonobjc<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるObjective-Cメソッドが、Objective-Cでは表現できないスウィフトメソッドによって、たとえばあるパラメータを変数であるとして指定することなどによって、オーバーライドされるならば、そのメソッドは<bpt i="1" x="1">&lt;c1&gt;</bpt>@nonobjc<ept i="1">&lt;/c1&gt;</ept>と印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an Objective-C method throws an exception during runtime, Swift triggers a runtime error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cメソッドが実行時に例外をスローするならば、スウィフトは実行時エラーの引き金を引きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an error occurs in a Swift method, the error is thrown, and automatically propagated to the caller:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーがスウィフトメソッドにおいて起こるならば、そのエラーはスローされます、そして自動的に呼び出し側に伝達されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an error occurs in an Objective-C method, that error is used to populate the error pointer argument of that method:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーがObjective-Cメソッドにおいて起こるならば、そのエラーはそのメソッドのエラーポインター引数に入れられるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If an error producing Objective-C method returns a <bpt i="0" x="0">&lt;c0&gt;</bpt>BOOL<ept i="0">&lt;/c0&gt;</ept> value to indicate the success or failure of a method call, Swift changes the return type of the function to <bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーを生成しているObjective-Cメソッドが<bpt i="0" x="0">&lt;c0&gt;</bpt>BOOL<ept i="0">&lt;/c0&gt;</ept>値を返してメソッド呼び出しが成功か失敗かを指し示すならば、スウィフトは関数の戻り型を<bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept>に変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If another method is declared with the resulting selector, the method name is not changed.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果として生じるセレクタで別のメソッドが宣言されるならば、メソッド名は変更されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If no nullability information is provided for a type, Swift cannot distinguish between optional and nonoptional references, and imports it as an implicitly unwrapped optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ヌル許可情報がある型に提供されないならば、スウィフトはオプショナル参照と非オプショナル参照とを見分けることができません、そしてそれを暗黙的にアンラップされるオプショナルとしてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the Objective-C generic parameterization specifies a class qualification, the imported Swift class has a constraint that requires that type to be a subclass of the specified class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるクラス資格をObjective-C総称体パラメータ化が指定するならば、インポートされたスウィフトクラスはある制約を持ちます、それは指定されたクラスのサブクラスであることをその型に要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the Objective-C generic parameterization specifies a protocol qualification, the imported Swift class has a constraint that requires that type to conform to the specified protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロトコル資格をObjective-C総称体パラメータ化が指定するならば、インポートされたスウィフトクラスはある制約を持ちます、それは指定されたプロトコルに準拠することをその型に要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the Objective-C method’s error parameter is also its first parameter, Swift attempts to simplify the method name further, by removing the “WithError” or “AndReturnError” suffix, if present, from the first part of the selector.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cメソッドのエラーパラメーターがまたそれの最初のパラメーターでもあるならば、スウィフトは「WithError」または「AndReturnError」接尾辞を、もしあるならば、セレクタの最初の部分から取り除くことで、メソッド名をいっそう単純化することを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the Swift compiler fails to identify a class factory method, you can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept> macro, passing the Swift signature of the initializer to have it imported correctly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコンパイラがクラスファクトリメソッドを識別するのを失敗したならば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept>マクロを使うことができ、イニシャライザのスウィフトシグネチャを渡すことでそれは正しくインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the Swift compiler mistakenly identifies a method as a class factory method, you can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept> macro, passing the Swift signature of the method to have it imported correctly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコンパイラが間違ってあるメソッドをクラスファクトリメソッドと識別するならば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept>マクロを使うことができ、そのメソッドのスウィフトシグネチャを渡すことでそれは正しくインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the Swift method has no parameters, <bpt i="1" x="1">&lt;c1&gt;</bpt>AndReturnError:<ept i="1">&lt;/c1&gt;</ept> is appended to the Objective-C method name, otherwise <bpt i="2" x="2">&lt;c2&gt;</bpt>error:<ept i="2">&lt;/c2&gt;</ept> is appended.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのスウィフトメソッドがパラメータを持たないならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>AndReturnError:<ept i="1">&lt;/c1&gt;</ept>がObjective-Cメソッド名に加えられ、そうでないならば<bpt i="2" x="2">&lt;c2&gt;</bpt>error:<ept i="2">&lt;/c2&gt;</ept>が加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the Swift method returns a nonoptional type, the corresponding Objective-C method has an optional return type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのスウィフトメソッドが非オプショナル型を返すならば、対応するObjective-Cメソッドはオプショナルの戻り型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the app targets a version of iOS prior to 8.0 or macOS prior to 10.10, <bpt i="0" x="0">&lt;c0&gt;</bpt>requestWhenInUseAuthorization()<ept i="0">&lt;/c0&gt;</ept> is unavailable, so the compiler reports an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アプリがiOSの8.0より前のまたはmacOSの10.10より前のあるバージョンをターゲットにするならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>requestWhenInUseAuthorization()<ept i="0">&lt;/c0&gt;</ept>は利用可能でありません、それでコンパイラはエラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the initializer takes an argument, the <bpt i="4" x="4">&lt;c4&gt;</bpt>With<ept i="4">&lt;/c4&gt;</ept> is removed and the rest of the selector is divided up into named parameters accordingly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザが引数をとるならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>With<ept i="4">&lt;/c4&gt;</ept>は取り除かれて残りのセレクタが名前付きパラメーターへとそれらしく分離されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the last non-block parameter of an Objective-C method is of type <bpt i="0" x="0">&lt;c0&gt;</bpt>NSError **<ept i="0">&lt;/c0&gt;</ept>, Swift replaces it with the <bpt i="1" x="1">&lt;c1&gt;</bpt>throws<ept i="1">&lt;/c1&gt;</ept> keyword, to indicate that the method can throw an error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cメソッドの最後の非ブロックパラメーターが型<bpt i="0" x="0">&lt;c0&gt;</bpt>NSError **<ept i="0">&lt;/c0&gt;</ept>ならば、スウィフトはそれを<bpt i="1" x="1">&lt;c1&gt;</bpt>throws<ept i="1">&lt;/c1&gt;</ept>キーワードで置き換えて、そのメソッドがエラーをスローできることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the method is called from Objective-C code, the error instead populates the error pointer argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッドがObjective-Cコードから呼ばれるならば、代わりにエラーはエラーポインタ引数に入れられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the method is called from Swift code, the error is propagated to its calling scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッドがスウィフトコードから呼ばれるならば、エラーはそれを呼び出しているスコープに伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the method is unable to create an object with the regular file contents of the document, it throws an <bpt i="0" x="0">&lt;c0&gt;</bpt>NSError<ept i="0">&lt;/c0&gt;</ept> object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッドがオブジェクトを書類の標準ファイル内容で作成することができないならば、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>NSError<ept i="0">&lt;/c0&gt;</ept>オブジェクトをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the name begins with a number, the first number is replaced with an underscore.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>名前が数で始まるならば、最初の数はアンダーラインと取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the optional is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>, Swift bridges the <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> value as an <bpt i="2" x="2">&lt;c2&gt;</bpt>NSNull<ept i="2">&lt;/c2&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのオプショナルが<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>ならば、スウィフトはその<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>値を<bpt i="2" x="2">&lt;c2&gt;</bpt>NSNull<ept i="2">&lt;/c2&gt;</ept>インスタンスとしてブリッジします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the protocol is defined in Swift, you can also add conformance to it to structures or enumerations, whether defined in Swift or Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのプロトコルがスウィフトにおいて定義されるならば、スウィフトまたはObjective-Cで定義されるかに関係なく、あなたは同様にそれに対する準拠を構造体または列挙に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If the type of the value pointed to by a C pointer cannot be represented by Swift, such as an incomplete struct type, the pointer is imported as an <bpt i="0" x="0">&lt;c0&gt;</bpt>OpaquePointer<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cポインタによって指し示される値の型がスウィフトによって表されることができないならば、たとえば不完全なstruct型など、そのポインタは<bpt i="0" x="0">&lt;c0&gt;</bpt>OpaquePointer<ept i="0">&lt;/c0&gt;</ept>としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you accept, Xcode creates the header file along with the file you were creating, and names it by your product module name followed by adding <bpt i="0" x="0">&lt;c0&gt;</bpt>"-Bridging-Header.h"<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが承諾するならば、Xcodeはヘッダ・ファイルをあなたがつくっていたファイルと一緒に作成して、あなたの製品モジュール名に続けて<bpt i="0" x="0">&lt;c0&gt;</bpt>"-Bridging-Header.h"<ept i="0">&lt;/c0&gt;</ept>を加わることによってそれに名前をつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you are certain of the type of the object, you can use the forced downcast operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>as!<ept i="0">&lt;/c0&gt;</ept>) instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがそのオプジェクトの型について確信をもつならば、あなたは強制ダウンキャスト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>as!<ept i="0">&lt;/c0&gt;</ept>）を代わりに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you do need to use a bridged Foundation object, you can cast between bridged types using the <bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept> type casting operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがブリッジFoundationオブジェクトを使うことをどうしても必要とするならば、あなたはブリッジ型の間でキャストすることが<bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept>型キャスト演算子を使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you have declared a function like this one:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこのような関数を宣言したならば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to change the name imported by Swift of an Objective-C method, enumeration case, or option set value, you can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept> macro to customize how a declaration is imported.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがObjective-Cメソッド、列挙ケース節、またはオプションセット値のスウィフトによってインポートされた名前を変更する必要があるならば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept>マクロを使ってどのようにある宣言がインポートされるかをカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you need to perform additional setup beyond initialization, you can assign the result of the invocation of a closure to the global constant:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが追加的な準備を初期化が済んだら実行する必要があるならば、あなたはあるクロージャの発動の結果をグローバル定数に割り当てることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you provide an Objective-C name for a Swift function, use Objective-C selector syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあるObjective-C名をスウィフト関数のために用意する場合は、Objective-Cセレクタ構文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you return Core Foundation objects from your own C functions and Objective-C methods, you can annotate them with either the <bpt i="0" x="0">&lt;c0&gt;</bpt>CF_RETURNS_RETAINED<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>CF_RETURNS_NOT_RETAINED<ept i="1">&lt;/c1&gt;</ept> macro to automatically insert memory management calls.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがコアファウンデーション・オブジェクトをあなた独自のC関数およびObjective-Cメソッドから返すならば、あなたはそれらに<bpt i="0" x="0">&lt;c0&gt;</bpt>CF_RETURNS_RETAINED<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>CF_RETURNS_NOT_RETAINED<ept i="1">&lt;/c1&gt;</ept>マクロのどちらかで注釈をつけて、自動的にメモリ管理呼び出しを差し込むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use only annotated APIs that do not indirectly return Core Foundation objects, you can skip the rest of this section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがコアファウンデーション・オブジェクトを間接的に返さない注釈をつけられたAPIだけを使うならば、あなたはこの節の残りをスキップすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use your own Objective-C types in your Swift code, make sure to import the Objective-C headers for those types before importing the Swift generated header into the Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> file you want to access the Swift code from.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあなた独自のObjective-C型をあなたのスウィフトコードにおいて使うならば、必ずそれらの型のためのObjective-Cヘッダをインポートするようにするようにしてください、スウィフトの生成ヘッダをあなたがそれからスウィフトコードにアクセスすることを望むObjective-Cの<bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルにインポートする前にです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you use your own Objective-C types in your Swift code, make sure to import the Objective-C headers for those types before importing the Swift generated header into the Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> file you want to use your Swift code from.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあなたのスウィフトコードにおいてあなた独自のObjective-C型を使うならば、スウィフト生成のヘッダをあなたがそれからスウィフトコードにアクセスすることを望むObjective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルにインポートする前に、必ずそれらの型のためのObjective-Cヘッダをインポートするようにするようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If your app target is compiled with testing enabled, a unit test target can access any declaration with the <bpt i="8" x="8">&lt;c8&gt;</bpt>internal<ept i="8">&lt;/c8&gt;</ept> modifier as if they were declared with the <bpt i="9" x="9">&lt;c9&gt;</bpt>public<ept i="9">&lt;/c9&gt;</ept> modifier by prepending <bpt i="10" x="10">&lt;c10&gt;</bpt>@testable<ept i="10">&lt;/c10&gt;</ept> to the product module import statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのアプリターゲットがテスト可能にされてコンパイルされるならば、ユニットテストターゲットは<bpt i="8" x="8">&lt;c8&gt;</bpt>internal<ept i="8">&lt;/c8&gt;</ept>修飾子を持つあらゆる宣言にアクセスできます、まるでそれらが、<bpt i="10" x="10">&lt;c10&gt;</bpt>@testable<ept i="10">&lt;/c10&gt;</ept>を製品モジュールインポート文の先頭に付けることで、<bpt i="9" x="9">&lt;c9&gt;</bpt>public<ept i="9">&lt;/c9&gt;</ept>修飾子とともに宣言をされたかのようにです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you’re calling a method with no arguments, you must still include parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが引数なしでメソッドを呼んでいる場合、あなたはそれでも括弧を含めなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you’re working with frameworks, make sure the Defines Module (<bpt i="0" x="0">&lt;c0&gt;</bpt>DEFINES_MODULE<ept i="0">&lt;/c0&gt;</ept>) build setting under Packaging is set to “Yes”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがフレームワークを扱ってならば、「Packaging」の下の「Defines Module（<bpt i="0" x="0">&lt;c0&gt;</bpt>DEFINES_MODULE<ept i="0">&lt;/c0&gt;</ept>）」ビルド設定が「Yes」に設定されることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you’re working with the Objective-C bridging header, make sure the Objective-C Bridging Header (<bpt i="0" x="0">&lt;c0&gt;</bpt>SWIFT_OBJC_BRIDGING_HEADER<ept i="0">&lt;/c0&gt;</ept>) build setting under Swift Compiler - Code Generation is set to a path to the bridging header file relative to your project (for example, “MyApp/MyApp-Bridging-Header.h”).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがObjective-C橋渡しヘッダを扱っているならば、「Swift Compiler - Code Generation」下の「Objective-C Bridging Header（<bpt i="0" x="0">&lt;c0&gt;</bpt>SWIFT_OBJC_BRIDGING_HEADER<ept i="0">&lt;/c0&gt;</ept>）」ビルド設定が、あなたのプロジェクトに関連する橋渡しヘッダファイルへのパスを持つことを確認してください（例えば、「MyApp/MyApp-Bridging-Header.h」）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you’re writing a mixed-language app, you may need to access your Objective-C code from Swift and your Swift code from Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが混合言語のアプリを書いているならば、あなたは、あなたのObjective-Cコードにスウィフトから、そしてあなたのスウィフトコードにObjective-Cからアクセスする必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>If you’re writing a mixed-language framework, you may need to access your Objective-C code from Swift and your Swift code from Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが混合言語のフレームワークを書いているならば、あなたはObjective-Cコードにあなたのスウィフトから、そしてあなたのスウィフトコードにObjective-Cからアクセスする必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Implementing Core Data Managed Object Subclasses</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コアデータ管理オブジェクトのサブクラスを実装する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Import into Objective-C</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cへインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Import into Swift</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトへインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Import relevant system frameworks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関連するシステム・フレームワークをインポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Import the Swift code from that framework target into any Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> file within that framework target using this syntax and substituting the appropriate names:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコードをそのフレームワークターゲットから、そのフレームワークターゲット内の何らかのObjective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルにこの構文を使って、適切な名前で置き換えて、インポートしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Import the Swift code from that target into any Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> file within that target using this syntax and substituting the appropriate name:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのターゲットからスウィフトコードを何らかのObjective-Cの<bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルへ、この構文を使って、適切な名前で置き換えて、インポートしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Imported Constant Enumerations and Structures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポートされる定数列挙と構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Imported Foundation classes and protocols drop their <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<ept i="0">&lt;/c0&gt;</ept> prefix, with the following exceptions:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポートされたFoundationのクラスおよびプロトコルは、それらの<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<ept i="0">&lt;/c0&gt;</ept>接頭辞を外します、以下の例外を除いては：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Importing Code from Within the Same App Target</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コードを同じアプリターゲットからインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Importing Code from Within the Same Framework Target</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コードを同じフレームワークターゲット内からインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Importing External Frameworks</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>外部のフレームワークをインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Importing Functions as Type Members</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数を型メンバとしてインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Importing Objective-C into Swift</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cをスウィフトにインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Importing Swift into Objective-C</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトをObjective-Cにインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Build Settings, in Swift Compiler - Code Generation, make sure the Objective-C Bridging Header build setting has a path to the bridging header file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Build Settingsにおいて、Swift Compiler - Code Generationにおいて、Objective-C Bridging Headerビルド設定がブリッジしているヘッダファイルへのパスを持つことを確実にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In C, the <bpt i="0" x="0">&lt;c0&gt;</bpt>pthread_once()<ept i="0">&lt;/c0&gt;</ept> function in POSIX and the <bpt i="1" x="1">&lt;c1&gt;</bpt>dispatch_once()<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>dispatch_once_f()<ept i="2">&lt;/c2&gt;</ept> functions in Grand Central Dispatch provide mechanisms for executing initialization code exactly once.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cでは、POSIXでの<bpt i="0" x="0">&lt;c0&gt;</bpt>pthread_once()<ept i="0">&lt;/c0&gt;</ept>関数およびGrand Central Dispatchでの<bpt i="1" x="1">&lt;c1&gt;</bpt>dispatch_once()<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>dispatch_once_f()<ept i="2">&lt;/c2&gt;</ept>関数は、厳密に一度だけ初期化コードを実行する仕組みを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In C, the <bpt i="0" x="0">&lt;c0&gt;</bpt>sizeof<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>alignof<ept i="1">&lt;/c1&gt;</ept> operators return the size and alignment of any variable or data type, In Swift, you use <bpt i="2" x="2">&lt;c2&gt;</bpt>MemoryLayout&lt;T&gt;<ept i="2">&lt;/c2&gt;</ept> to access the memory layout of the parameterized type <bpt i="3" x="3">&lt;c3&gt;</bpt>T<ept i="3">&lt;/c3&gt;</ept> through the <bpt i="4" x="4">&lt;c4&gt;</bpt>size<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>stride<ept i="5">&lt;/c5&gt;</ept>, and <bpt i="6" x="6">&lt;c6&gt;</bpt>alignment<ept i="6">&lt;/c6&gt;</ept> properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>sizeof<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>alignof<ept i="1">&lt;/c1&gt;</ept>演算子はあらゆる変数またはデータ型のサイズとアラインメントを返します、スウィフトでは、あなたは<bpt i="2" x="2">&lt;c2&gt;</bpt>MemoryLayout&lt;T&gt;<ept i="2">&lt;/c2&gt;</ept>を使って、パラメータ化された型<bpt i="3" x="3">&lt;c3&gt;</bpt>T<ept i="3">&lt;/c3&gt;</ept>のメモリレイアウトに<bpt i="4" x="4">&lt;c4&gt;</bpt>size<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>stride<ept i="5">&lt;/c5&gt;</ept>、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>alignment<ept i="6">&lt;/c6&gt;</ept>プロパティを通してアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Cocoa, methods that produce errors take an <bpt i="0" x="0">&lt;c0&gt;</bpt>NSError<ept i="0">&lt;/c0&gt;</ept> pointer parameter as their last parameter, which populates its argument with an <bpt i="1" x="1">&lt;c1&gt;</bpt>NSError<ept i="1">&lt;/c1&gt;</ept> object if an error occurs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cocoaでは、エラーを生成するメソッドは、それの最後のパラメーターとして<bpt i="0" x="0">&lt;c0&gt;</bpt>NSError<ept i="0">&lt;/c0&gt;</ept>ポインターパラメーターを取ります、エラーが起こるならばその引数に<bpt i="1" x="1">&lt;c1&gt;</bpt>NSError<ept i="1">&lt;/c1&gt;</ept>オブジェクトが入ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Cocoa, you register operations with <bpt i="0" x="0">&lt;c0&gt;</bpt>NSUndoManager<ept i="0">&lt;/c0&gt;</ept> to allow users to reverse that operation’s effect.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cocoaでは、あなたはそれぞれの操作を<bpt i="0" x="0">&lt;c0&gt;</bpt>NSUndoManager<ept i="0">&lt;/c0&gt;</ept>に登録して、ユーザがその操作の効果を取り消せるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, a <bpt i="0" x="0">&lt;e0&gt;</bpt>key<ept i="0">&lt;/e0&gt;</ept> is a string that identifies a specific property of an object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、<bpt i="0" x="0">&lt;e0&gt;</bpt>key<ept i="0">&lt;/e0&gt;</ept>はオプジェクトの特定のプロパティを識別するある文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, a pointer type declaration can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>_Nullable<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>_Nonnull<ept i="1">&lt;/c1&gt;</ept> annotations to specify whether or not that pointer may have a <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>NULL<ept i="3">&lt;/c3&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、ボインタ型宣言は<bpt i="0" x="0">&lt;c0&gt;</bpt>_Nullable<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>_Nonnull<ept i="1">&lt;/c1&gt;</ept>注釈を使うことで、そのポインタが<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>NULL<ept i="3">&lt;/c3&gt;</ept>値を持つかどうか指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, a property may override its synthesized getter method such that the underlying instance variable is conditionally initialized if its value is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、プロパティは、それの合成されたゲッターメソッドをオーバーライドできます、例えば、裏に潜んだインスタンス変数が、それの値が<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>かどうかで、条件付きで初期化されるように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, a selector is a type that refers to the name of an Objective-C method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Ojbective-Cでは、セレクタはObjective-Cメソッドの名前を参照するある型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, an option set is a bit mask of integer values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、オプションセットは整数値のビットマスクです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, autorelease pool blocks are marked using <bpt i="0" x="0">&lt;c0&gt;</bpt>@autoreleasepool<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、オートリリース・ブロックは<bpt i="0" x="0">&lt;c0&gt;</bpt>@autoreleasepool<ept i="0">&lt;/c0&gt;</ept>を使って印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, constants are often used to provide a list of possible values for properties and method parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、プロパティおよびメソッドパラメータに対する候補の値のリストを提供するためにしばしば定数が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, error handling is opt-in, meaning that errors produced by calling a method are ignored unless an error pointer is provided.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、エラー処理はオプトインです、それはメソッドを呼び出すことで生成されたエラーはエラーポインターが提供されない限りは無視されるということを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, error handling is opt-in, meaning that errors produced by calling a method are ignored unless you provide an error pointer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、エラー処理はオプトインです、それはメソッドを呼び出すことで生成されたエラーはあなたがエラーポインターを提供しない限りは無視されるということを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, if you need to capture <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> in a block, it’s important to consider the memory management implications.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cにおいて、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>をあるブロックにおいてキャプチャする必要があるならば、メモリ管理の影響を考慮することが重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, initializers directly return the object they initialize.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、イニシャライザは直接にそれが初期化したオブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, properties have a range of potential attributes that specify additional information about a property’s behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cにおいて、プロパティたちは、あるプロパティの挙動に関する追加の情報を指定する多種多様な潜在的な属性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, the success or failure of the method can be determined by whether an <bpt i="2" x="2">&lt;c2&gt;</bpt>NSURL<ept i="2">&lt;/c2&gt;</ept> object is returned.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、メソッドの成功や失敗は、<bpt i="2" x="2">&lt;c2&gt;</bpt>NSURL<ept i="2">&lt;/c2&gt;</ept>オブジェクトが返されるかどうかによって判断されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, this method’s last parameter is of type <bpt i="2" x="2">&lt;c2&gt;</bpt>NSError **<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、このメソッドの最後のパラメーターは型<bpt i="2" x="2">&lt;c2&gt;</bpt>NSError **<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, you can ensure that only one instance of a singleton object is created by wrapping its initialization in a call the <bpt i="0" x="0">&lt;c0&gt;</bpt>dispatch_once<ept i="0">&lt;/c0&gt;</ept> function, which executes a block once and only once for the lifetime of an app:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、あなたはあるシングルトンオブジェクトにただ１つのインスタンスが作成されることを、それの初期化を、あるプロックをあるアプリのライフタイムに対していっぺんこっきり実行する<bpt i="0" x="0">&lt;c0&gt;</bpt>dispatch_once<ept i="0">&lt;/c0&gt;</ept>関数呼び出しの中にラップする（包む）ことによって確実にできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, you can use the Foundation framework classes <bpt i="0" x="0">&lt;c0&gt;</bpt>NSJSONSerialization<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NSPropertyListSerialization<ept i="1">&lt;/c1&gt;</ept> to initialize objects from a decoded JSON or property list serialization value—usually an object of type <bpt i="2" x="2">&lt;c2&gt;</bpt>NSDictionary&lt;NSString *, id&gt;<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、あなたはFoundationフレームワーククラスの<bpt i="0" x="0">&lt;c0&gt;</bpt>NSJSONSerialization<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>NSPropertyListSerialization<ept i="1">&lt;/c1&gt;</ept>を使って、復号化されたJSONまたはプロパティリストのシリアライズ値 ― 通常は型<bpt i="2" x="2">&lt;c2&gt;</bpt>NSDictionary&lt;NSString *, id&gt;<ept i="2">&lt;/c2&gt;</ept>のオブジェクトから各オブジェクトを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, you do this:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、あなたはこうします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, you pass <bpt i="0" x="0">&lt;c0&gt;</bpt>NULL<ept i="0">&lt;/c0&gt;</ept> for the error parameter when you only care whether there was an error, not what specific error occurred.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>NULL<ept i="0">&lt;/c0&gt;</ept>をエラーパラメータのために渡すことが、あなたが心配するのがただエラーがあったかどうかだけであり、特定のエラーに出くわしたことではない時に行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, you typically use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSLocalizedString<ept i="0">&lt;/c0&gt;</ept> family of macros to localize strings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、あなたは一般的に文字列を現地語化するためにマクロの<bpt i="0" x="0">&lt;c0&gt;</bpt>NSLocalizedString<ept i="0">&lt;/c0&gt;</ept>ファミリーを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, you use the <bpt i="0" x="0">&lt;c0&gt;</bpt>isKindOfClass:<ept i="0">&lt;/c0&gt;</ept> method to check whether an object is of a certain class type, and the <bpt i="1" x="1">&lt;c1&gt;</bpt>conformsToProtocol:<ept i="1">&lt;/c1&gt;</ept> method to check whether an object conforms to a specified protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、あるオブジェクトが特定のクラス型かどうか調べるために<bpt i="0" x="0">&lt;c0&gt;</bpt>isKindOfClass:<ept i="0">&lt;/c0&gt;</ept>を、そしてオブジェクトが指定されたプロトコルに準拠するかどうか調べるために<bpt i="1" x="1">&lt;c1&gt;</bpt>conformsToProtocol:を<ept i="1">&lt;/c1&gt;</ept>使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, you use the <bpt i="0" x="0">&lt;c0&gt;</bpt>respondsToSelector:<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>instancesRespondToSelector:<ept i="1">&lt;/c1&gt;</ept> methods to check for the availability of a class or instance method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>respondsToSelector:<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>instancesRespondToSelector:<ept i="1">&lt;/c1&gt;</ept>メソッドを使ってクラスおよびインスタンス・メソッドの有効性を確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Objective-C, you work with references to objects using raw pointers that could be <bpt i="0" x="0">&lt;c0&gt;</bpt>NULL<ept i="0">&lt;/c0&gt;</ept> (referred to as <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> in Objective-C).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでは、あなたはオブジェクトへの参照を、<bpt i="0" x="0">&lt;c0&gt;</bpt>NULL<ept i="0">&lt;/c0&gt;</ept>（Objective-Cでは<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>と呼ばれます）であることができる生のポインターを使って扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift as well as Objective-C, attempting to call a method that does not exist triggers an unrecognized selector error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトではObjective-C同様に、存在しないメソッドを呼び出す試みは、識別不能セレクタエラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, Objective-C selectors are represented by the <bpt i="0" x="0">&lt;c0&gt;</bpt>Selector<ept i="0">&lt;/c0&gt;</ept> structure, and can be constructed using the <bpt i="1" x="1">&lt;c1&gt;</bpt>#selector<ept i="1">&lt;/c1&gt;</ept> expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、Objective-Cセレクタは<bpt i="0" x="0">&lt;c0&gt;</bpt>Selector<ept i="0">&lt;/c0&gt;</ept>構造体によって表されます、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>#selector<ept i="1">&lt;/c1&gt;</ept>式を使って組み立てられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, a null pointer is represented by a <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept> value of an optional pointer type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、ヌルポインタはオプショナルポインタ型の<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>値によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, a stored property with an initial value can be declared with the <bpt i="0" x="0">&lt;c0&gt;</bpt>lazy<ept i="0">&lt;/c0&gt;</ept> modifier to have the expression calculating the initial value only evaluated when the property is first accessed:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、初期値を持つ保存プロパティが<bpt i="0" x="0">&lt;c0&gt;</bpt>lazy<ept i="0">&lt;/c0&gt;</ept>修飾子を使って宣言されると、初期値を計算する式は、そのプロパティが最初にアクセスされる時に初めて数値を求められるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, all values—including structures and object references—are guaranteed to be non–null.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、すべての値は ― 構造体やオブジェクト参照を含めて ― 非nullであることを保証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, attempting to call a method that is not supported on all targeted platform versions causes a compile-time error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、ターゲットにされるすべてのプラットホーム上でサポートされないメソッドを呼び出す試みは、コンパイル時エラーを生じさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, calling a method that throws requires explicit error handling.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、スローするメソッドを呼び出すことは明確にエラー処理することを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, global constants and stored type properties are guaranteed to be initialized only once, even when accessed across multiple threads simultaneously.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、グローバル定数と保存型プロパティは、ただ一度だけ初期化されることを保証されます、複数のスレッドをまたいで同時にアクセスされた時でさえもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, it’s imported like this:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、それはこのようにインポートされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, option sets are represented by structures conforming to the <bpt i="0" x="0">&lt;c0&gt;</bpt>OptionSet<ept i="0">&lt;/c0&gt;</ept> protocol, with static variables for each option value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、オプションセットは<bpt i="0" x="0">&lt;c0&gt;</bpt>OptionSet<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠している構造体によって表され、静的変数を各オプション値に対して持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, the Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>copy<ept i="0">&lt;/c0&gt;</ept> property attribute translates to <bpt i="1" x="1">&lt;c1&gt;</bpt>@NSCopying<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、Objective-Cの<bpt i="0" x="0">&lt;c0&gt;</bpt>copy<ept i="0">&lt;/c0&gt;</ept>プロパティ属性は、<bpt i="1" x="1">&lt;c1&gt;</bpt>@NSCopying<ept i="1">&lt;/c1&gt;</ept>として解釈します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, the functionality of these macros is made available through a single function: <bpt i="5" x="5">&lt;c5&gt;</bpt>NSLocalizedString(_:tableName:bundle:value:comment:)<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、これらのマクロの機能性は、ただ１つの関数：<bpt i="5" x="5">&lt;c5&gt;</bpt>NSLocalizedString(_:tableName:bundle:value:comment:)<ept i="5">&lt;/c5&gt;</ept>を通して利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, the standard library defines a standardized approach to data encoding and decoding.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、標準ライブラリが標準化された取り組みをデータのエンコーディングとデコーディングに対して定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, there are no <bpt i="0" x="0">&lt;c0&gt;</bpt>readwrite<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>readonly<ept i="1">&lt;/c1&gt;</ept> attributes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>readwrite<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>readonly<ept i="1">&lt;/c1&gt;</ept>属性はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, this pattern is built into a language feature called <bpt i="1" x="1">&lt;e1&gt;</bpt>failable initialization<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、このよくある操作は<bpt i="1" x="1">&lt;e1&gt;</bpt>失敗できる初期化<ept i="1">&lt;/e1&gt;</ept>と呼ばれる言語機能に組み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, those header files are compiled down to Objective-C modules, which are then imported into Swift as Swift APIs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて、それらのヘッダ・ファイルはObjective-Cモジュールに至るまでコンパイルされます、それらは、それからスウィフトにスウィフト APIとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you accomplish this task by using the <bpt i="2" x="2">&lt;c2&gt;</bpt>is<ept i="2">&lt;/c2&gt;</ept> operator to check for a type, or the <bpt i="3" x="3">&lt;c3&gt;</bpt>as?<ept i="3">&lt;/c3&gt;</ept> operator to downcast to that type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたは、ある型か調べる<bpt i="2" x="2">&lt;c2&gt;</bpt>is<ept i="2">&lt;/c2&gt;</ept>演算子、またはその型にダウンキャストする<bpt i="3" x="3">&lt;c3&gt;</bpt>as?<ept i="3">&lt;/c3&gt;</ept>演算子を使うことによってこの作業を達成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you call it like this:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたはそれをこのように呼び出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can also use the <bpt i="0" x="0">&lt;c0&gt;</bpt>#keyPath<ept i="0">&lt;/c0&gt;</ept> string expression to create compiler-checked keys and key paths that can be used by KVC methods like <bpt i="1" x="1">&lt;c1&gt;</bpt>value(forKey:)<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>value(forKeyPath:)<ept i="2">&lt;/c2&gt;</ept>, and KVO methods like <bpt i="3" x="3">&lt;c3&gt;</bpt>addObserver(_:forKeyPath:options:context:)<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>#keyPath<ept i="0">&lt;/c0&gt;</ept>文字列式を使うことでコンパイラチェック済みのキーやキーパスを作成できます、それらは<bpt i="1" x="1">&lt;c1&gt;</bpt>value(forKey:)<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>value(forKeyPath:)<ept i="2">&lt;/c2&gt;</ept>のようなKVCメソッドおよび<bpt i="3" x="3">&lt;c3&gt;</bpt>addObserver(_:forKeyPath:options:context:)<ept i="3">&lt;/c3&gt;</ept>のようなKVOメソッドによって使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can call C variadic functions, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>vasprintf<ept i="0">&lt;/c0&gt;</ept>, using the <bpt i="1" x="1">&lt;c1&gt;</bpt>getVaList(_:)<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>withVaList(_:_:)<ept i="2">&lt;/c2&gt;</ept> functions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて、あなたはCの可変長引数関数、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>vasprintf<ept i="0">&lt;/c0&gt;</ept>などを呼び出すことが<bpt i="1" x="1">&lt;c1&gt;</bpt>getVaList(_:)<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>withVaList(_:_:)<ept i="2">&lt;/c2&gt;</ept>関数を使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can define protocols that Objective-C classes can conform to.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて、あなたはObjective-Cクラスが準拠できるプロトコルを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can define subclasses of Objective-C classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて、あなたはObjective-Cクラスのサブクラスを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can interact with the unified logging system using the top level <bpt i="0" x="0">&lt;c0&gt;</bpt>os_log(_:dso:log:type:_:)<ept i="0">&lt;/c0&gt;</ept> function, found in the <bpt i="1" x="1">&lt;c1&gt;</bpt>log<ept i="1">&lt;/c1&gt;</ept> submodule of the <bpt i="2" x="2">&lt;c2&gt;</bpt>os<ept i="2">&lt;/c2&gt;</ept> module.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたは統合ログシステムとトップレベルの<bpt i="0" x="0">&lt;c0&gt;</bpt>os_log(_:dso:log:type:_:)<ept i="0">&lt;/c0&gt;</ept>関数、<bpt i="2" x="2">&lt;c2&gt;</bpt>os<ept i="2">&lt;/c2&gt;</ept>モジュールの<bpt i="1" x="1">&lt;c1&gt;</bpt>log<ept i="1">&lt;/c1&gt;</ept>サブモジュールで見つかります、を使ってやり取りできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can simply use a static type property, which is guaranteed to be lazily initialized only once, even when accessed across multiple threads simultaneously:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたは単にstatic型プロパティを使うことができます、それは、複数のスレッドから同時にアクセスされる時でさえも、ただ一度だけ遅延初期化されることを保証します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can use a key-path expression to create key paths for accessing properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたはキーパス式を使うことで、プロパティにアクセスするためのキーパスを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can use each pair of toll-free bridged Foundation and Core Foundation types interchangeably.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて、あなたは、無料の橋渡しされたファウンデーションとコアファウンデーション型のそれぞれの対を入れ替えて使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can use functions and generics to achieve the same results without any compromises.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたはどんな妥協もなしで同じ結果を成し遂げるために、関数と総称体を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can use optional chaining to invoke an optional protocol method on a possibly <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> object and unwrap the possible result using <bpt i="1" x="1">&lt;c1&gt;</bpt>if–let<ept i="1">&lt;/c1&gt;</ept> syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたはオプショナル連鎖を使用することで、オプショナルのプロトコルメソッドをもしかすると<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>であるオブジェクト上で呼び出して<bpt i="1" x="1">&lt;c1&gt;</bpt>if–let<ept i="1">&lt;/c1&gt;</ept>構文を使って可能な結果をアンラップすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you can use the <bpt i="1" x="1">&lt;c1&gt;</bpt>autoreleasepool(_:)<ept i="1">&lt;/c1&gt;</ept> function to execute a closure within an autorelease pool block.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>autoreleasepool(_:)<ept i="1">&lt;/c1&gt;</ept>関数を使って、あるクロージャをオートリリース・ブロックの内部で実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you do this:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたはこうします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you must use the full name of your document subclass, including the module name derived from the name of your app or framework.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて、あなたは、あなたのアプリまたはフレームワークの名前から引き出されるモジュール名を含めて、あなたのドキュメントサブクラスの完全な名前を使う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you specify these property attributes in a different way.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて、あなたは異なる方法でこれらのプロパティ属性を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you use the <bpt i="0" x="0">&lt;c0&gt;</bpt>@available<ept i="0">&lt;/c0&gt;</ept> attribute to control whether a declaration is available to use when building an app for a particular target platform.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>@available<ept i="0">&lt;/c0&gt;</ept>属性を使うことで、ある宣言が利用可能であるかどうかを制御して、特定の対象プラットホームのためにアプリをビルドするときに使うようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you use the <bpt i="0" x="0">&lt;c0&gt;</bpt>Selector<ept i="0">&lt;/c0&gt;</ept> type to refer to Objective-C selectors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて、あなたはObjective-Cセレクタに言及するために<bpt i="0" x="0">&lt;c0&gt;</bpt>Selector<ept i="0">&lt;/c0&gt;</ept>型を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In Swift, you write <bpt i="1" x="1">&lt;c1&gt;</bpt>try?<ept i="1">&lt;/c1&gt;</ept> to change a throwing expression into one that returns an optional value, and then check whether the value is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトでは、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>try?<ept i="1">&lt;/c1&gt;</ept>を書くことで、スローする式をオプショナルの値を返すものへと変えて、それからその値が<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>かどうかを調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition to arrays, Swift bridges between the <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept> type and the <bpt i="1" x="1">&lt;c1&gt;</bpt>NSSet<ept i="1">&lt;/c1&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>配列に加えて、スウィフトは<bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>型と<bpt i="1" x="1">&lt;c1&gt;</bpt>NSSet<ept i="1">&lt;/c1&gt;</ept>クラスの間を橋渡しします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In addition, many of the Cocoa frameworks, including Foundation, AppKit, and UIKit refine their APIs to be more natural in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>加えて、Foundation、AppKit、そしてUIKitを含む、多くのCocoaフレームワークは、それらのAPIをSwiftにおいてより自然なものに改良されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In both Swift and Objective-C, delegation is often expressed with a protocol that defines the interaction and a conforming delegate property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトとObjective-Cの両方で、委任は、相互作用を定義するプロトコルと準拠している委任プロパティでたいてい表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast with condition compilation in the C preprocessor, conditional compilation blocks in Swift must completely surround blocks of code that are self-contained and syntactically valid.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cプリプロセッサでの条件コンパイルと対照的に、スウィフトでの条件コンパイルブロックは、自給自足で統語論的に有効であるコードのブロックを完全に伴っていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In contrast, the methods that perform a selector on a specific thread or after a delay, such as <bpt i="3" x="3">&lt;c3&gt;</bpt>perform(_:on:with:waitUntilDone:modes:)<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>perform(_:with:afterDelay:)<ept i="4">&lt;/c4&gt;</ept>, don’t return a value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対照的に、セレクタを特定のスレッド上やある猶予の後で実行するメソッド、例えば<bpt i="3" x="3">&lt;c3&gt;</bpt>perform(_:on:with:waitUntilDone:modes:)<ept i="3">&lt;/c3&gt;</ept>そして<bpt i="4" x="4">&lt;c4&gt;</bpt>perform(_:with:afterDelay:)<ept i="4">&lt;/c4&gt;</ept>は、値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In fact, when Swift code imports Objective-C APIs, the importer replaces Objective-C reference types with their corresponding value types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>実際、スウィフトコードがObjective-C APIをインポートするとき、インポーターはObjective-C参照型をそれらの対応する値型と置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In many cases, you can use Swift language features to extend or simplify existing Cocoa patterns, making them more powerful and easier to use.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>多くの場合に、あなたは既存のココア・パターンを拡張したり、単純化するためにスウィフト言語の特徴を働かせることができます。そして、それらをより強力でより使いやすくします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In most cases, it’s safer and more convenient to cast the object to <bpt i="2" x="2">&lt;c2&gt;</bpt>AnyObject<ept i="2">&lt;/c2&gt;</ept> and use optional chaining with a method call as described in <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>id Compatibility<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの場合には、より安全でいっそう便利なのはそのオブジェクトを<bpt i="2" x="2">&lt;c2&gt;</bpt>AnyObject<ept i="2">&lt;/c2&gt;</ept>にキャストして、メソッド呼び出しとともにオプショナル連鎖を使うことです、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>id互換性<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In most cases, you should not need to modify this setting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどの場合、あなたはこの説定を修正する必要がないはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to preserve namespacing when a Swift class is used in Objective-C code, Swift classes are exposed to the Objective-C runtime with their fully qualified names.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトクラスがObjective-Cコードの中で使用されるときに名前空間を保護する目的で、スウィフトクラスたちはそれらの完全修飾名を使ってObjective-Cランタイムに露出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In order to retrieve a Swift class, the fully qualified name, including the name of the app, is used.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるスウィフトクラスを取り出すために、その完全修飾名が、そのアプリの名前を含めて、使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In other words, the behavior of <bpt i="0" x="0">&lt;c0&gt;</bpt>__block<ept i="0">&lt;/c0&gt;</ept> in Objective-C is the default behavior for variables in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>言い換えると、Objective-Cでの<bpt i="0" x="0">&lt;c0&gt;</bpt>__block<ept i="0">&lt;/c0&gt;</ept>の挙動は、スウィフトの中の変数のための初期状態での挙動です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In some cases, you need finer grained control over how your Swift API is exposed to Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの場合に、あなたはよりきめ細かな管理をあなたのスウィフト APIがObjective-Cに露出される方法に対して必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example above, the <bpt i="0" x="0">&lt;c0&gt;</bpt>CFArrayCallBacks<ept i="0">&lt;/c0&gt;</ept> initializer uses <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> values as arguments for the <bpt i="2" x="2">&lt;c2&gt;</bpt>retain<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>release<ept i="3">&lt;/c3&gt;</ept> parameters, the <bpt i="4" x="4">&lt;c4&gt;</bpt>customCopyDescription(_:)<ept i="4">&lt;/c4&gt;</ept> function as the argument for the <bpt i="5" x="5">&lt;c5&gt;</bpt>customCopyDescription<ept i="5">&lt;/c5&gt;</ept> parameter, and a closure literal as the argument for the <bpt i="6" x="6">&lt;c6&gt;</bpt>equal<ept i="6">&lt;/c6&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>上の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>CFArrayCallBacks<ept i="0">&lt;/c0&gt;</ept>イニシャライザは<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>値を<bpt i="2" x="2">&lt;c2&gt;</bpt>retain<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>release<ept i="3">&lt;/c3&gt;</ept>パラメーターに対する引数として、<bpt i="4" x="4">&lt;c4&gt;</bpt>customCopyDescription(_:)<ept i="4">&lt;/c4&gt;</ept>関数を<bpt i="5" x="5">&lt;c5&gt;</bpt>customCopyDescription<ept i="5">&lt;/c5&gt;</ept>パラメーターに対する引数として、そしてクロージャリテラルを<bpt i="6" x="6">&lt;c6&gt;</bpt>equal<ept i="6">&lt;/c6&gt;</ept>パラメーターに対する引数として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, changing the value of the <bpt i="0" x="0">&lt;c0&gt;</bpt>isAlive<ept i="0">&lt;/c0&gt;</ept> computed property on an instance of the <bpt i="1" x="1">&lt;c1&gt;</bpt>SchroedingersCat<ept i="1">&lt;/c1&gt;</ept> structure also changes the value of the instance’s <bpt i="2" x="2">&lt;c2&gt;</bpt>isDead<ept i="2">&lt;/c2&gt;</ept> computed property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>isAlive<ept i="0">&lt;/c0&gt;</ept>計算プロパティの値を<bpt i="1" x="1">&lt;c1&gt;</bpt>SchroedingersCat<ept i="1">&lt;/c1&gt;</ept>構造体のインスタンス上で変更することは、またそのインスタンスの<bpt i="2" x="2">&lt;c2&gt;</bpt>isDead<ept i="2">&lt;/c2&gt;</ept>計算プロパティの値も変更します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In the example below, the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSClassFromString(_:)<ept i="0">&lt;/c0&gt;</ept> function is used to retrieve a reference to a class from its string representation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSClassFromString(_:)<ept i="0">&lt;/c0&gt;</ept>関数は、あるクラスへの参照をそれの文字列表現から取り出すために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In your Objective-C bridging header file, import every Objective-C header you want to expose to Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのObjective-C橋渡しヘッダ・ファイルにおいて、あなたがスウィフトに露出したいあらゆるObjective-Cヘッダをインポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>In your umbrella header file, import every Objective-C header you want to expose to Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのアンブレラヘッダ・ファイルにおいて、あなたがスウィフトに露出したいあらゆるObjective-Cヘッダをインポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Individual type declarations can be audited using the <bpt i="2" x="2">&lt;c2&gt;</bpt>_Nullable<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>_Nonnull<ept i="3">&lt;/c3&gt;</ept> annotations, individual property declarations can be audited using the <bpt i="4" x="4">&lt;c4&gt;</bpt>nullable<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>nonnull<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>null_resettable<ept i="6">&lt;/c6&gt;</ept> property attributes, or entire regions can be audited for nullability using the <bpt i="7" x="7">&lt;c7&gt;</bpt>NS_ASSUME_NONNULL_BEGIN<ept i="7">&lt;/c7&gt;</ept> and <bpt i="8" x="8">&lt;c8&gt;</bpt>NS_ASSUME_NONNULL_END<ept i="8">&lt;/c8&gt;</ept> macros.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>個々の型宣言は<bpt i="2" x="2">&lt;c2&gt;</bpt>_Nullable<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>_Nonnull<ept i="3">&lt;/c3&gt;</ept>注釈を使って監査されることができます、個々のプロパティ宣言は<bpt i="4" x="4">&lt;c4&gt;</bpt>nullable<ept i="4">&lt;/c4&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>nonnull<ept i="5">&lt;/c5&gt;</ept>、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>null_resettable<ept i="6">&lt;/c6&gt;</ept>プロパティ属性を使って監査されることができます、または領域全体がヌル許可について監査されることが<bpt i="7" x="7">&lt;c7&gt;</bpt>NS_ASSUME_NONNULL_BEGIN<ept i="7">&lt;/c7&gt;</ept>と<bpt i="8" x="8">&lt;c8&gt;</bpt>NS_ASSUME_NONNULL_END<ept i="8">&lt;/c8&gt;</ept>マクロを使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Inheriting from Objective-C Classes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cクラスから継承する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initialization</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Initializer methods are imported by Swift with double underscores (<bpt i="0" x="0">&lt;c0&gt;</bpt>__<ept i="0">&lt;/c0&gt;</ept>) prepended to their first argument labels.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザメソッドは、二重アンダースコア（<bpt i="0" x="0">&lt;c0&gt;</bpt>__<ept i="0">&lt;/c0&gt;</ept>）をそれの最初の引数ラベルの前に付けられてスウィフトによってインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, create an Objective-C or C wrapper for C++ code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、C++コードのためにObjective-CまたはCラッパーをつくってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, import the Xcode-generated header file for your Swift code into any Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> file you want to use your Swift code from.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、あなたのスウィフトコードのためのXcode生成のヘッダ・ファイルを、あなたがそのコードを使いたい何らかのObjective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルにインポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, it takes advantage of compile-time attributes, conditional compilation blocks, and language features to accomplish the same functionality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、それは同じ機能性を達成するために、さまざまなコンパイル時属性、条件コンパイルブロック、そして言語機能を活用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, use the <bpt i="1" x="1">&lt;c1&gt;</bpt>Int.init(bitPattern:)<ept i="1">&lt;/c1&gt;</ept> initializer to interpret the optional pointer as an <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>, which has the same C variadic calling conventions as a pointer on all supported platforms.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int.init(bitPattern:)<ept i="1">&lt;/c1&gt;</ept>イニシャライザを使ってオプショナルポインタを<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>として解釈してください、それはすべてのプラットホーム上でポインタと同じCの可変長引数呼び出し取り決めを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, you can forward declare a Swift class or protocol to reference it in an Objective-C interface.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その代わりに、あなたはスウィフトのクラスやプロトコルを先に宣言して、Objective-Cインターフェイスにおいてそれを参照することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Instead, you represent a value that could be missing by wrapping the type of the value in an <bpt i="2" x="2">&lt;e2&gt;</bpt>optional type<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>代わりに、あなたは見つからない値を、その型の値を<bpt i="2" x="2">&lt;e2&gt;</bpt>オプショナル型<ept i="2">&lt;/e2&gt;</ept>の中にラップすることによって表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Integrating with Interface Builder</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インタフェースビルダーと統合する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Interacting with C APIs</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C APIとの相互作用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Interacting with Objective-C APIs</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-C APIとの相互作用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Interoperability</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>相互運用性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Interoperability lets you write Swift code that incorporates Objective-C behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>相互運用性は、あなたにObjective-C挙動を取り入れるスウィフトコードを書かせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Interoperability makes it possible to integrate those features back into Objective-C code with no hassle.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>相互運用性は、それらの特徴をObjective-Cコードに逆に戻って統合することを面倒なしで可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Introspection</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自己観察</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Invoking a method using a selector is inherently unsafe, because the compiler cannot make any guarantees about the result, or even guarantee whether the object responds to the selector.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッドをセレクタを使って発動することは、本質的に安全ではありません、なぜならコンパイラはその結果についてどんな保証も、またはオブジェクトがセレクタに応答するかどうかの保証さえもすることが不可能だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It also contains those marked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>internal<ept i="2">&lt;/c2&gt;</ept> modifier if your app target has an Objective-C bridging header.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはまた、あなたのアプリターゲットがObjective-C橋渡しヘッダを持つならば、それらを<bpt i="2" x="2">&lt;c2&gt;</bpt>internal<ept i="2">&lt;/c2&gt;</ept>修飾子で印して含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It also supports chaining through optional values within a chain, such as <bpt i="5" x="5">&lt;c5&gt;</bpt>#keyPath(Person.bestFriend.name)<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはまた、ある数珠つなぎ内でオプショナル値を通した連鎖をサポートします、例えば<bpt i="5" x="5">&lt;c5&gt;</bpt>#keyPath(Person.bestFriend.name)<ept i="5">&lt;/c5&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It can be thought of as an umbrella header for your Swift code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それは、あなたのスウィフトコードのためのアンブレラヘッダとみなされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>It imports Objective-C class factory methods as Swift initializers, and Objective-C enumeration cases truncated names.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それはObjective-Cファクトリメソッドをスウィフトイニシャライザとして、そして名前の先端を切ったObjective-C列挙をインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Just as in Objective-C, before you send a message that a delegate may not respond to, you ask the delegate whether it responds to the selector.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ちょうどObjective-Cでのように、あなたが委任先が応答しないかもしれないメッセージを送る前に、あなたはその委任先にそれがセレクタに応答するかどうか尋ねます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Key paths created using key-path expressions include type information about the properties they reference.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパス式を使って作成されるキーパスは、それらが参照するプロパティについての型情報を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Key-Value Observing</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー値監視</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Key-value observing is a mechanism that allows objects to be notified of changes to specified properties of other objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キー値監視は、オブジェクトが他のオブジェクトの指定されたプロパティに対する変更を通知されるようにする仕組みです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keys and Key Paths</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーとキーパス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keys and key paths are also used for <bpt i="3" x="3">&lt;e3&gt;</bpt>key-value observing<ept i="3">&lt;/e3&gt;</ept> (KVO), a mechanism that enables an object to be notified directly when a property of another object changes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーとキーパスはまた、他のオブジェクトのプロパティが変化した時にあるオブジェクトが直接に通知されることを可能にする仕組み、<bpt i="3" x="3">&lt;e3&gt;</bpt>キー値監視<ept i="3">&lt;/e3&gt;</ept>（KVO）のためにも使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Keys and key paths are frequently used for <bpt i="2" x="2">&lt;e2&gt;</bpt>key-value coding<ept i="2">&lt;/e2&gt;</ept> (KVC), a mechanism for indirectly accessing an object’s attributes and relationships using string identifiers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーとキーパスは、文字列識別子を使ってオブジェクトの属性および関連付け（リレーションシップ）に間接的にアクセスするための仕組み、<bpt i="2" x="2">&lt;e2&gt;</bpt>キー値コーディング<ept i="2">&lt;/e2&gt;</ept>（KVC）のためにしばしば使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Lazy Initialization</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Lazy properties are useful when the initial value for a property either requires complex or computationally expensive setup, or cannot be determined until after an instance’s initialization is complete.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>遅延プロパティが便利なのは、あるプロパティに対する初期値が、複雑なもしくは計算的に高くつく準備を必要とする、またはあるインスタンスの初期化が完了する後まで決定されることが出来ない、このどちらかである場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Lightweight Generics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>軽量総称体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like a C function pointer, a Swift function type with the <bpt i="0" x="0">&lt;c0&gt;</bpt>@convention(c)<ept i="0">&lt;/c0&gt;</ept> attribute does not capture the context of its surrounding scope.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C関数ポインタのように、<bpt i="0" x="0">&lt;c0&gt;</bpt>@convention(c)<ept i="0">&lt;/c0&gt;</ept>属性を持つスウィフト関数型は、それを取り囲んでいるスコープのコンテキストをキャプチャしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Like blocks in Objective-C, closures in Swift also maintain strong references to any captured objects, including <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでのブロックのように、スウィフトでのクロージャもまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>を含めて、あらゆるキャプチャされたオブジェクトに対する強い参照を管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Likewise, when Objective-C code imports Swift APIs, the importer also replaces Swift value types with their corresponding Objective-C reference types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、Objective-Cコードがスウィフト APIをインポートするとき、インポーターはまたスウィフト値型をそれらの対応するObjective-C参照型と置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Live Rendering</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ライブレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Localization</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>現地語化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Making Objective-C Interfaces Unavailable in Swift</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cインターフェイスをスウィフトで利用できなくする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Many Objective-C initializers in system frameworks have been audited to indicate whether initialization can fail.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>システムフレームワークの中の多くのObjective-Cイニシャライザは、初期化が失敗する可能性があるかどうか検査されてしまっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Many of these patterns rely on classes defined in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのパターンの多くは、Objective-Cで定義されるクラスに頼ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Memory Managed Objects</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリ管理オブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Methods are imported and called as described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Working with Methods<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッドは、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>メソッドを扱う<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述されるように、インポートされ呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Methods that <bpt i="0" x="0">&lt;e0&gt;</bpt>consume<ept i="0">&lt;/e0&gt;</ept> errors, such as delegate methods or methods that take a completion handler with an <bpt i="1" x="1">&lt;c1&gt;</bpt>NSError<ept i="1">&lt;/c1&gt;</ept> object argument, do not become methods that throw when imported by Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーを<bpt i="0" x="0">&lt;e0&gt;</bpt>食べ尽くす<ept i="0">&lt;/e0&gt;</ept>メソッド、例えば委任先メソッドたちや完了ハンドラを<bpt i="1" x="1">&lt;c1&gt;</bpt>NSError<ept i="1">&lt;/c1&gt;</ept>オブジェクト引数で取るメソッドたちは、スウィフトによってインポートされる時にスローするメソッドになりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Migrating Your Objective-C Code to Swift</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのObjective-Cコードのスウィフトへの移行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Migration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>移行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mix and Match</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>混合と適合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mix and Match Overview</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>混合と適合の概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mix-and-match functionality makes it easy to choose which features and functionality to implement in Swift, and which to leave in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>混合と適合の機能性は、どの特徴と機能性をスウィフトにおいて実装するか、そしてどれをObjective-Cのままにしておくべきかを選択をするのを容易にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Most of the Objective-C system frameworks, including Foundation, already provide nullability annotations, allowing you to work with values in an idiomatic and type-safe manner.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ほとんどのObjective-Cシステムフレームワーク、Foundationを含む、は、すでにヌル可能注釈を提供し、あなたに慣用句的な型安全な手法で値を扱えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Mutable Pointers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変ポインター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>NSCoding</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NSCodingプロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>NSUndoManager supports two ways to register undo operations: a “simple undo”, which performs a selector with a single object argument, and an “invocation-based undo”, which uses an <bpt i="0" x="0">&lt;c0&gt;</bpt>NSInvocation<ept i="0">&lt;/c0&gt;</ept> object that takes any number and any type of arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>NSUndoManagerは、取り消し操作を登録する２つの方法をサポートします：ただ１つのオブジェクト引数を使ってセレクタを実行する「単純な取り消し」、そして随意の数の随意の型の引数を取る<bpt i="0" x="0">&lt;c0&gt;</bpt>NSInvocation<ept i="0">&lt;/c0&gt;</ept>オブジェクトを使う「呼び出し基盤の取り消し」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Naming Your Product Module</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの製品モジュールに名前をつける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nested types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>入れ子にされた型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>New document that describes various aspects of Swift 1.0 and its compatibility with the Objective-C language and Cocoa/Cocoa Touch frameworks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのObjective-C言語やCocoa／Cocoa Touchフレームワークとの互換性の様々な面を解説する新しい文書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>No import statement</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポート文なし</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>No import statement; Objective-C bridging header required</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポート文なし；Objective-Cブリッジヘッダ必須</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>No import statement; Objective-C umbrella header required</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポート文なし；Objective-Cアンブレラヘッダ必須</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that after this cast, the <bpt i="0" x="0">&lt;c0&gt;</bpt>dataSource<ept i="0">&lt;/c0&gt;</ept> constant is of type <bpt i="1" x="1">&lt;c1&gt;</bpt>UITableViewDataSource<ept i="1">&lt;/c1&gt;</ept>, so you can only call methods and access properties defined on the <bpt i="2" x="2">&lt;c2&gt;</bpt>UITableViewDataSource<ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このキャストの後で、<bpt i="0" x="0">&lt;c0&gt;</bpt>dataSource<ept i="0">&lt;/c0&gt;</ept>定数は型<bpt i="1" x="1">&lt;c1&gt;</bpt>UITableViewDataSource<ept i="1">&lt;/c1&gt;</ept>である点に注意してください、なのであなたは<bpt i="2" x="2">&lt;c2&gt;</bpt>UITableViewDataSource<ept i="2">&lt;/c2&gt;</ept>プロトコル上で定義されるメソッド呼び出しとプロパティアクセスができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that the Swift interfaces in the generated header include references to all of the Objective-C types used in them.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生成されたヘッダの中のスウィフトインタフェースたちが、それらの中で使われるObjective-C型への全ての参照を含む点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Note that this list does not include arrays.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このリストが配列を含まない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Noted that C function pointers are now imported as <bpt i="0" x="0">&lt;c0&gt;</bpt>CFunctionPointer<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C関数ポインターは現在は<bpt i="0" x="0">&lt;c0&gt;</bpt>CFunctionPointer<ept i="0">&lt;/c0&gt;</ept>としてインポートされることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Noted that the compiler does not implicitly synthesize the <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept> attribute for private methods and properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラはプライペートなメソッドおよびプロパティのための<bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept>属性を暗黙的に合成して作り出さないことを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Noted that types that are pointed to, like <bpt i="0" x="0">&lt;c0&gt;</bpt>NSString **<ept i="0">&lt;/c0&gt;</ept>, are not bridged.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインターを付けられる型、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSString **<ept i="0">&lt;/c0&gt;</ept>のようなものは、ブリッジされないことを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice also that “init” doesn’t appear anywhere when calling the Swift-style initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>またスウィフト形式のイニシャライザを呼ぶとき「init」がどこにも現れないことに注目してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice that the <bpt i="0" x="0">&lt;c0&gt;</bpt>removeItem(at:)<ept i="0">&lt;/c0&gt;</ept> method is imported by Swift with a <bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept> return type, no <bpt i="2" x="2">&lt;c2&gt;</bpt>error<ept i="2">&lt;/c2&gt;</ept> parameter, and a <bpt i="3" x="3">&lt;c3&gt;</bpt>throws<ept i="3">&lt;/c3&gt;</ept> declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>removeItem(at:)<ept i="0">&lt;/c0&gt;</ept>メソッドがスウィフトによって<bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept>の戻り型で、<bpt i="2" x="2">&lt;c2&gt;</bpt>error<ept i="2">&lt;/c2&gt;</ept>パラメーターなしで、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>throws<ept i="3">&lt;/c3&gt;</ept>宣言でインポートされることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Notice that you don’t need to call <bpt i="0" x="0">&lt;c0&gt;</bpt>alloc<ept i="0">&lt;/c0&gt;</ept>; Swift handles this for you.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>alloc<ept i="0">&lt;/c0&gt;</ept>を呼ぶ必要がないことに注意してください；スウィフトは、これをあなたの代わりに処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Null Pointers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ヌルポインタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Nullability and Optionals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ヌル許可とオプショナル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Numbers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Object Comparison</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクト比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Object subscripting methods are imported by Swift as methods with double underscores (<bpt i="0" x="0">&lt;c0&gt;</bpt>__<ept i="0">&lt;/c0&gt;</ept>) prepended to their base names, rather than as a Swift subscript, if either the getter or setter method is marked as <bpt i="1" x="1">&lt;c1&gt;</bpt>NS_REFINED_FOR_SWIFT<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オブジェクト添え字メソッドは、二重アンダースコア（<bpt i="0" x="0">&lt;c0&gt;</bpt>__<ept i="0">&lt;/c0&gt;</ept>）をそれのベース名の前に付けられてスウィフトによってメソッドとしてインポートされます、スウィフト添え字としてではなく、もしゲッターとセッターメソッドの両方が<bpt i="1" x="1">&lt;c1&gt;</bpt>NS_REFINED_FOR_SWIFT<ept i="1">&lt;/c1&gt;</ept>と印付けされるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C Reference Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-C参照型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-C構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C and Swift files can coexist in a single project, whether the project was originally an Objective-C or Swift project.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロジェクトが元々はObjective-Cかスウィフトのプロジェクトであったかどうかに関係なく、Objective-Cとスウィフトのファイルは一つのプロジェクトにおいて共存することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C blocks are automatically imported as Swift closures with Objective-C block calling convention, denoted by the <bpt i="0" x="0">&lt;c0&gt;</bpt>@convention(block)<ept i="0">&lt;/c0&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cのブロックは、Objective-Cのブロック呼出規約をもつスウィフトのクロージャとして自動的にインポートされ、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>@convention(block)<ept i="0">&lt;/c0&gt;</ept>属性で分かります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C can use nullability annotations to designate whether a parameter type, property type, or return type, can have a <bpt i="0" x="0">&lt;c0&gt;</bpt>NULL<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cは、ヌル許可注釈を使って、あるパラメーター型、プロパティ型、または戻り値型が<bpt i="0" x="0">&lt;c0&gt;</bpt>NULL<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>値を持つことが可能かどうか任命できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C classes qualified by one or more protocols are imported by Swift as protocol composition types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つ以上のプロトコルによって適格にされるObjective-Cクラスは、スウィフトによってプロトコル合成型としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C code</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C frameworks can use custom error domains and enumerations to group related categories of errors.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cフレームワークは、カスタムエラードメインと列挙を使って、エラーの関連カテゴリをグループ化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C frameworks vend APIs in header files.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cフレームワークは、ヘッダ・ファイルの中のAPIを販売します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C initializers begin with <bpt i="0" x="0">&lt;c0&gt;</bpt>init<ept i="0">&lt;/c0&gt;</ept>, or <bpt i="1" x="1">&lt;c1&gt;</bpt>initWith:<ept i="1">&lt;/c1&gt;</ept> if the initializer takes one or more arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cイニシャライザは、<bpt i="0" x="0">&lt;c0&gt;</bpt>init<ept i="0">&lt;/c0&gt;</ept>で、またはイニシャライザがひとつ以上の引数をとるならば<bpt i="1" x="1">&lt;c1&gt;</bpt>initWith:<ept i="1">&lt;/c1&gt;</ept>で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C initializers that indicate whether they’re failable are imported as either <bpt i="3" x="3">&lt;c3&gt;</bpt>init(...)<ept i="3">&lt;/c3&gt;</ept>—if initialization cannot fail—or <bpt i="4" x="4">&lt;c4&gt;</bpt>init?(...)<ept i="4">&lt;/c4&gt;</ept>—if initialization can fail.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらが失敗できるかどうか指し示すObjective-Cイニシャライザは、初期化が失敗できないならば ― <bpt i="3" x="3">&lt;c3&gt;</bpt>init(...)<ept i="3">&lt;/c3&gt;</ept>、または初期化が失敗できるならば ― <bpt i="4" x="4">&lt;c4&gt;</bpt>init?(...)<ept i="4">&lt;/c4&gt;</ept>、このどちらかでインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C methods that return a value and take no arguments can be called like an Objective-C property using dot syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>値を返して引数を取らないObjective-Cメソッドは、Objective-Cプロパティのように呼び出すことがドット構文を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C platform-adaptive integer types, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>NSUInteger<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NSInteger<ept i="1">&lt;/c1&gt;</ept>, are bridged to <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cのプラットホーム順応性の整数型、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>NSUInteger<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>NSInteger<ept i="1">&lt;/c1&gt;</ept>などは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>にブリッジされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C property declarations using the <bpt i="0" x="0">&lt;c0&gt;</bpt>@property<ept i="0">&lt;/c0&gt;</ept> syntax are imported as Swift properties in the following way:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cプロパティ宣言で<bpt i="0" x="0">&lt;c0&gt;</bpt>@property<ept i="0">&lt;/c0&gt;</ept>構文を使っているものは、スウィフトプロパティとして以下の方法でインポートされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C protocol-qualified metaclasses are imported by Swift as protocol metatypes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cのプロトコル適格メタクラスは、スウィフトによってプロトコルメタタイプとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C protocols are imported as Swift protocols, which can be adopted by a class in a comma-separated list following the name of a class’s superclass, if any.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cプロトコルは、スウィフトプロトコルとしてインポートされます、そしてそれは、クラスによって採用されることが、もしあればクラスのもつスーパークラスの名前に続けて、コンマ区切りのリストに入れて、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objective-C type declarations using lightweight generic parameterization are imported by Swift with information about the type of their contents preserved.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>軽量総称体パラメーター化を使っているObjective-C宣言は、それらの保管される内容についての情報を使ってスウィフトによってインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Objects in an app’s responder chain—that is, subclasses of <bpt i="0" x="0">&lt;c0&gt;</bpt>NSResponder<ept i="0">&lt;/c0&gt;</ept> on macOS and <bpt i="1" x="1">&lt;c1&gt;</bpt>UIResponder<ept i="1">&lt;/c1&gt;</ept> on iOS—have a read-only <bpt i="2" x="2">&lt;c2&gt;</bpt>undoManager<ept i="2">&lt;/c2&gt;</ept> property that returns an optional <bpt i="3" x="3">&lt;c3&gt;</bpt>NSUndoManager<ept i="3">&lt;/c3&gt;</ept> value, which manages the undo stack for the app.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アプリのレスポンダ連鎖の中のオブジェクト ― すなわち、macOSでの<bpt i="0" x="0">&lt;c0&gt;</bpt>NSResponder<ept i="0">&lt;/c0&gt;</ept>そしてiOSでの<bpt i="1" x="1">&lt;c1&gt;</bpt>UIResponder<ept i="1">&lt;/c1&gt;</ept>のサブクラス ― は、読み出し専用の<bpt i="2" x="2">&lt;c2&gt;</bpt>undoManager<ept i="2">&lt;/c2&gt;</ept>プロパティを持ちます、それはオプショナルの<bpt i="3" x="3">&lt;c3&gt;</bpt>NSUndoManager<ept i="3">&lt;/c3&gt;</ept>値を返します、そして取り消しスタックをアプリのために管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>On macOS, you typically open an app by clicking its icon in the Dock or Launchpad, or by double-clicking its icon from the Finder.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>macOSでは、あなたは通常はアプリをそれのアイコンをDockまたはLaunchpadでクリックすることで、またはそれのアイコンをFinderからダブルクリックすることで開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once you import your Swift code into Objective-C, use regular Objective-C syntax for working with Swift classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一旦あなたがObjective-Cにあなたのスウィフトコードをインポートするならば、一般的なObjective-C構文をスウィフトクラスを扱うために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Once you migrate a class to Swift, you must remove the corresponding <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> file from the target before building to avoid a duplicate symbol error.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一旦あなたがあるクラスをスウィフトに移行したならば、あなたは、ビルドの前にそのターゲットから対応する<bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルを取り除いて重複シンボル・エラーを避けなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One aid in writing well-designed, resilient apps is to use Cocoa’s established design patterns.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>よく設計された、溌剌としたアプリを記述することでの１つの援助は、ココアのいくつかの確立したデザインパターンを使うことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One important aspect of interoperability is that it lets you work with Objective-C APIs when writing Swift code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>相互運用性の１つの重要な面は、スウィフトコードを書くとき、それがあなたにObjective-C APIを扱わせるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One of the primary advantages of value types over reference types is that they make it easier to reason about your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>参照型を超える値型の主要な利点の１つは、それらがあなたのコードについて考えるのをより簡単にすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>One-Time Initialization</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ワンタイム初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Only Swift function types with C function reference calling convention may be used for function pointer arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C関数参照呼出手法を持つスウィフト関数型だけが、関数ポインタ引数のために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Option Sets</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプションセット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Option sets behave like Swift’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept> collection type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプションセットは、スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>コレクション型に似た振る舞いをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Option sets behave similarly to imported enumerations by truncating their prefixes to option value names.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプションセットは、それらのオプション値名の接頭辞を切り取ることでインポートされた列挙と同じように振舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Option-click a symbol to see implicit information about it, like its type, attributes, and documentation comments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シンボルをオプション-クリックして、それに関する暗黙表示の情報、その型、属性、そして注釈文書などを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Optional pointers cannot be passed to the <bpt i="0" x="0">&lt;c0&gt;</bpt>withVaList(_:invoke:)<ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルポインタは、<bpt i="0" x="0">&lt;c0&gt;</bpt>withVaList(_:invoke:)<ept i="0">&lt;/c0&gt;</ept>関数に渡されることが可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Or, an app may require more complex usage in order to use localization resources from a separate bundle:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>または、独立したバンドルから現地語化リソースを使うために、アプリはより複雑な語法を必要とするかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Other methods are imported with double underscores (<bpt i="0" x="0">&lt;c0&gt;</bpt>__<ept i="0">&lt;/c0&gt;</ept>) prepended to their base names.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>他のメソッドは、二重アンダースコア（<bpt i="0" x="0">&lt;c0&gt;</bpt>__<ept i="0">&lt;/c0&gt;</ept>）をそれのベース名の前に付けられてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, Objective-C initializers are imported as <bpt i="5" x="5">&lt;c5&gt;</bpt>init!(...)<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それ以外では、Objective-Cイニシャライザは、<bpt i="5" x="5">&lt;c5&gt;</bpt>init!(...)<ept i="5">&lt;/c5&gt;</ept>としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, Swift bridges the optional as its unwrapped value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうでなければ、スウィフトはそのオプショナルをそれのアンラップされた値としてブリッジします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, continue on to learn about working with unmanaged Core Foundation objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>一方で、管理されないコアファウンデーション・オブジェクトを扱うことについて学ぶためには続けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Otherwise, if no convention can be inferred, the method is left intact.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それ以外では、推論されることができる慣行がないならば、メソッドは元のままにしておかれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Outlets and actions allow you to connect your source code to user interface objects in Interface Builder.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アウトレットとアクションによって、あなたは、あなたのソース・コードをインタフェースビルダーのユーザー・インタフェースオブジェクトに接続することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Overriding Swift Names for Objective-C Interfaces</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cインターフェイスのためのスウィフト名のオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Platform-specific classes, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>NSBackgroundActivity<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>NSUserNotification<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>NSXPCConnection<ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プラットホーム特有のクラス、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>NSBackgroundActivity<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>NSUserNotification<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>NSXPCConnection<ept i="2">&lt;/c2&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pointer Arithmetic</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインタ算術</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pointer initializers taking the integer representation of an address in memory are failable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリ中のあるアドレスの整数表現をとるポインタイニシャライザは失敗可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Pointers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Preparing Your Objective-C Code for Migration</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>移動のためのあなたのObjective-Cコードの準備</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Preprocessor Directives</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プリプロセッサ指令</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Primitive Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基本の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Print the return value of the method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッドの戻り値を出力する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Private declarations are not exposed to Objective-C unless they are explicitly marked with <bpt i="2" x="2">&lt;c2&gt;</bpt>@IBAction<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>@IBOutlet<ept i="3">&lt;/c3&gt;</ept>, or <bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プライベートな宣言はObjective-Cにさらされません、それらが明示的に<bpt i="2" x="2">&lt;c2&gt;</bpt>@IBAction<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>@IBOutlet<ept i="3">&lt;/c3&gt;</ept>、または<bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept>で印されない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Private declarations are not exposed to Objective-C unless they are explicitly marked with <bpt i="5" x="5">&lt;c5&gt;</bpt>@IBAction<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>@IBOutlet<ept i="6">&lt;/c6&gt;</ept>, or <bpt i="7" x="7">&lt;c7&gt;</bpt>@objc<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プライベートな宣言はObjective-Cにさらされません、それらが明示的に<bpt i="5" x="5">&lt;c5&gt;</bpt>@IBAction<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>@IBOutlet<ept i="6">&lt;/c6&gt;</ept>、または<bpt i="7" x="7">&lt;c7&gt;</bpt>@objc<ept i="7">&lt;/c7&gt;</ept>で印されない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Processing Command-Line Arguments</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コマンドライン引数の処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Properties with an ownership property attribute other than <bpt i="0" x="0">&lt;c0&gt;</bpt>weak<ept i="0">&lt;/c0&gt;</ept> (that is, <bpt i="1" x="1">&lt;c1&gt;</bpt>assign<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>copy<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>strong<ept i="3">&lt;/c3&gt;</ept>, or <bpt i="4" x="4">&lt;c4&gt;</bpt>unsafe_unretained<ept i="4">&lt;/c4&gt;</ept>) are imported as Swift properties with the appropriate storage.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>weak<ept i="0">&lt;/c0&gt;</ept>とは別の所有者プロパティ属性（すなわち、<bpt i="1" x="1">&lt;c1&gt;</bpt>assign<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>copy<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>strong<ept i="3">&lt;/c3&gt;</ept>、または<bpt i="4" x="4">&lt;c4&gt;</bpt>unsafe_unretained<ept i="4">&lt;/c4&gt;</ept>）を持つプロパティは、スウィフトプロパティとしてインポートされるのに適切なストレージを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Properties with the <bpt i="0" x="0">&lt;c0&gt;</bpt>class<ept i="0">&lt;/c0&gt;</ept> property attribute are imported as Swift type properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>class<ept i="0">&lt;/c0&gt;</ept>プロパティ属性を持つプロパティは、スウィフト型プロパティとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Properties with the <bpt i="0" x="0">&lt;c0&gt;</bpt>readonly<ept i="0">&lt;/c0&gt;</ept> property attribute are imported as Swift computed properties with a getter (<bpt i="1" x="1">&lt;c1&gt;</bpt>{ get }<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>readonly<ept i="0">&lt;/c0&gt;</ept>プロパティ属性を使うプロパティは、スウィフト計算プロパティとしてインポートされるのにゲッター（<bpt i="1" x="1">&lt;c1&gt;</bpt>{ get }<ept i="1">&lt;/c1&gt;</ept>）を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Properties with the <bpt i="0" x="0">&lt;c0&gt;</bpt>weak<ept i="0">&lt;/c0&gt;</ept> property attribute are imported as Swift properties marked with the <bpt i="1" x="1">&lt;c1&gt;</bpt>weak<ept i="1">&lt;/c1&gt;</ept> keyword (<bpt i="2" x="2">&lt;c2&gt;</bpt>weak var<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>weak<ept i="0">&lt;/c0&gt;</ept>プロパティ属性を使うプロパティは、<bpt i="1" x="1">&lt;c1&gt;</bpt>weak<ept i="1">&lt;/c1&gt;</ept>キーワード（<bpt i="2" x="2">&lt;c2&gt;</bpt>weak var<ept i="2">&lt;/c2&gt;</ept>）で印されるスウィフトプロパティとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Properties with the nullability property attributes (<bpt i="0" x="0">&lt;c0&gt;</bpt>nonnull<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>nullable<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>null_resettable<ept i="2">&lt;/c2&gt;</ept>) are imported as Swift properties with optional or nonoptional type as described in <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>Nullability and Optionals<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ヌル許可プロパティ属性（<bpt i="0" x="0">&lt;c0&gt;</bpt>nonnull<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>nullable<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>null_resettable<ept i="2">&lt;/c2&gt;</ept>）を使ったプロパティは、スウィフトプロパティとしてインポートされるのにオプショナルまたは非オプショナル型を使います、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;a4&gt;</bpt>ヌル許可とオプショナル<ept i="4">&lt;/a4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Protocol-Qualified Classes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロトコル適格クラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Rather than defining separate functions that correspond to each Objective-C macro, the Swift <bpt i="0" x="0">&lt;c0&gt;</bpt>NSLocalizedString(_:tableName:bundle:value:)<ept i="0">&lt;/c0&gt;</ept> function specifies default values for the <bpt i="1" x="1">&lt;c1&gt;</bpt>tableName<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>bundle<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>value<ept i="3">&lt;/c3&gt;</ept> arguments, so that they may be overridden as necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それぞれのObjective-Cマクロに対応した独立した関数を定義するのではなく、スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>NSLocalizedString(_:tableName:bundle:value:)<ept i="0">&lt;/c0&gt;</ept>関数は<bpt i="1" x="1">&lt;c1&gt;</bpt>tableName<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>bundle<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>value<ept i="3">&lt;/c3&gt;</ept>引数に省略時の値を指定します、それでそれらは必要に応じてオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Read/Write and Read-Only</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「読み/書き」と「読み出し専用」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Referencing a Swift Class or Protocol in an Objective-C Header</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのクラスやプロトコルをObjective-Cヘッダにおいて参照する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Refining Objective-C Declarations</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-C宣言を改良する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remap certain Objective-C concepts to matching concepts in Swift, like pointers to optionals</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特定のObjective-C概念をスウィフトでの匹敵する概念にリマップします、ポインターをオプショナルへ、のように</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remap certain Objective-C core types to their alternatives in Swift, like <bpt i="0" x="0">&lt;c0&gt;</bpt>NSString<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特定のObjective-Cコア型をスウィフトでのそれらの代替物にリマップします、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSString<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>へ、のように</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remap certain Objective-C types to their equivalents in Swift, like <bpt i="0" x="0">&lt;c0&gt;</bpt>id<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>Any<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>特定のObjective-C型をそれらのスウィフトでの等価物にリマップ（関数を別のキーに割り当てる）します、<bpt i="0" x="0">&lt;c0&gt;</bpt>id<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>Any<ept i="1">&lt;/c1&gt;</ept>に、のように</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remapped Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>リマップされた型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remember that you cannot subclass a Swift class in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがObjective-Cにおいてスウィフトクラスをサブクラス化することができないことを忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remember to add a colon (<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>) wherever a parameter follows a selector piece.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるセレクタ片にパラメータが続くところはどこにでも、コロン（<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>）を加えるのを忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Remove the original Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> file from the target by deselecting the target membership checkbox.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ターゲットから本来のObjective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルを、ターゲットメンバーシップ・チェックボックスの選択を外すことによって取り除いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Renamed Types</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>改名された型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Requiring Dynamic Dispatch</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>動的なディスパッチを要求する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Requiring this kind of dynamic dispatch is rarely necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この種の動的なディスパッチの要請は、めったに必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Revision History</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>改訂履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Data Type Size Calculation<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> for more information about how Swift calculates the sizes of data types and values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>データ型サイズ計算<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>をスウィフトがデータ型と値の大きさを計算する方法についての詳細のために見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>See <bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>Unmanaged Objects<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept> for more information.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>更なる情報として<bpt i="5" x="5">&lt;s5&gt;</bpt><bpt i="6" x="6">&lt;a6&gt;</bpt>管理されないオブジェクト<ept i="6">&lt;/a6&gt;</ept><ept i="5">&lt;/s5&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Selectors</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>セレクタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Serialization</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シリアライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Serialization allows you to encode and decode objects in your app to and from architecture-independent representations, such as JSON or property lists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シリアライズは、オブジェクトをあなたのアプリにおいてアーキテクチャ非依存の表現、例えばJSONやプロパティリストなどに符号化および復号化できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Sets</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>集合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Setting Up Your Swift Environment</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのスウィフト環境を設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, <bpt i="4" x="4">&lt;c4&gt;</bpt>NSSet<ept i="4">&lt;/c4&gt;</ept> declarations without a class-qualified object type are imported by Swift as a <bpt i="5" x="5">&lt;c5&gt;</bpt>Set<ept i="5">&lt;/c5&gt;</ept> with the <bpt i="6" x="6">&lt;c6&gt;</bpt>Element<ept i="6">&lt;/c6&gt;</ept> type <bpt i="7" x="7">&lt;c7&gt;</bpt>AnyHashable<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、クラス適格オブジェクト型なしでの<bpt i="4" x="4">&lt;c4&gt;</bpt>NSSet<ept i="4">&lt;/c4&gt;</ept>宣言は、スウィフトによって<bpt i="6" x="6">&lt;c6&gt;</bpt>Element<ept i="6">&lt;/c6&gt;</ept>型<bpt i="7" x="7">&lt;c7&gt;</bpt>AnyHashable<ept i="7">&lt;/c7&gt;</ept>を持つ<bpt i="5" x="5">&lt;c5&gt;</bpt>Set<ept i="5">&lt;/c5&gt;</ept>としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, if an error producing Objective-C method returns a <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept> value to indicate the failure of a method call, Swift changes the return type of the function to a nonoptional type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、エラーを生成しているObjective-Cメソッドが<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>値を返してメソッド呼び出しの失敗を指し示すならば、スウィフトは関数の戻り型を非オプショナル型に変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, you can use the <bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;a11&gt;</bpt>JSONDecoder<ept i="11">&lt;/a11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> and <bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;a13&gt;</bpt>PropertyListDecoder<ept i="13">&lt;/a13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> classes to decode and initialize instances from JSON or property list data.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、あなたは<bpt i="10" x="10">&lt;c10&gt;</bpt><bpt i="11" x="11">&lt;a11&gt;</bpt>JSONDecoder<ept i="11">&lt;/a11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>と<bpt i="12" x="12">&lt;c12&gt;</bpt><bpt i="13" x="13">&lt;a13&gt;</bpt>PropertyListDecoder<ept i="13">&lt;/a13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>クラスを使って、インスタンスをJSONまたはプロパティリストデータからデコードして初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Similarly, you use the <bpt i="1" x="1">&lt;c1&gt;</bpt>#available<ept i="1">&lt;/c1&gt;</ept> availability condition to conditionally execute code based on required platform and version conditions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同様に、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>#available<ept i="1">&lt;/c1&gt;</ept>利用可能性条件を使うことで、必要なプラットホームおよびバージョン条件に基づいて、条件付きでコードを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Simple Macros</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単純なマクロ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Simplified the instructions in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Basic Setup<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかの指示を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>基本の準備<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>章において簡略化した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Simply import the appropriate module, and refer to the class, structure, or enumeration by the same name that you would use in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>単に適切なモジュールをインポートしてください、そしてあなたがObjective-Cで使うだろうのと同じ名前によって、そのクラス、構造体、または列挙を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Singleton</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シングルトン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Singletons provide a globally accessible, shared instance of an object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>シングルトンは、全体で利用できる、共有されるひとつのインスタンスを、あるオブジェクトに提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some Objective-C interfaces may not be suitable or necessary to be exposed as Swift interfaces.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかのObjective-Cインターフェイスは、スウィフトインターフェイスとして露出されるのにふさわしくないもしくは必要でない可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some Swift APIs do not map back to Objective-C because they leverage language features that are not available in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト若干のAPIは、Objective-Cへと逆にマップされません、なぜならそれらがObjective-Cで利用できない言語機能に影響を及ぼすからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Some classes and methods are not available to all versions of all platforms that your app targets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>いくつかのクラスやメソッドは、あなたのアプリターゲットであるすべてのプラットホームのすべてのバージョンで利用可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Specifying Property Attributes</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティ属性を指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strings</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Strong and Weak</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>強い、弱い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structures</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Structures defined in Swift</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて定義される構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Subclasses of classes that adopt <bpt i="4" x="4">&lt;c4&gt;</bpt>NSCoding<ept i="4">&lt;/c4&gt;</ept> that have one or more custom initializers or any properties without initial values must also implement this method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>NSCoding<ept i="4">&lt;/c4&gt;</ept>を採用するクラスのサブクラスで１つ以上のカスタムイニシャライザまたはなんらかの初期値なしのプロパティを持つものは、同様にこのメソッドを実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift APIs are translated into Objective-C similar to how Objective-C APIs are translated into Swift, but in reverse:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのAPIは、Objective-C APIがスウィフトへと翻訳される方法と同じように、しかし逆に、Objective-Cへと翻訳されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift APIs that are callable from Objective-C must be accessible through dynamic dispatch.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cから呼び出し可能なスウィフトAPIは、動的ディスパッチを通してアクセス可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift Syntax</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift Type Compatibility</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト型互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift Value Type</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト値型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift also bridges between the <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> type and the <bpt i="1" x="1">&lt;c1&gt;</bpt>NSDictionary<ept i="1">&lt;/c1&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>型から<bpt i="1" x="1">&lt;c1&gt;</bpt>NSDictionary<ept i="1">&lt;/c1&gt;</ept>クラスへ橋渡しします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift also imports C enumerations marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_OPTIONS<ept i="0">&lt;/c0&gt;</ept> macro as a Swift option set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_OPTIONS<ept i="0">&lt;/c0&gt;</ept>マクロで印を付けられるCの列挙をスウィフトオプションセットとしてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift also includes an <bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept> type that represents some kind of object and has the special ability to look up any <bpt i="1" x="1">&lt;c1&gt;</bpt>@objc<ept i="1">&lt;/c1&gt;</ept> method dynamically.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはまた<bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept>型を含んでいます。それは何かわからないある種類のオブジェクトを表します、そしてどれかの<bpt i="1" x="1">&lt;c1&gt;</bpt>@objc<ept i="1">&lt;/c1&gt;</ept>メソッドを動的に検索する特別な能力を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift also provides a way of working with common C constructs and patterns, in case your code requires it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはまた、あなたのコードがそれを必要とする場合に備えて、一般的なC構造物とパターンを扱う方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift also provides pointer types for working with buffers, which are discussed in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Buffer Pointers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトはまたバッファを扱うためにいくつかのポインタ型を提供します、それらは<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>バッファポインタ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>において解説されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift and Objective-C in the Same Project</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じプロジェクト中のスウィフトとObjective-C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift automatically calls the superclass deinitializer after invoking your subclass’ deinitializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、あなたのサブクラスのデイニシャライザを呼び出した後、自動的にスーパークラスのデイニシャライザを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift automatically converts some Objective-C types to Swift types, and some Swift types to Objective-C types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、いくつかのObjective-C型をスウィフト型に、そしていくつかのスウィフト型をObjective-C型に自動的に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift automatically provides implementations for the logical complements of the equality and identity operators (<bpt i="0" x="0">&lt;c0&gt;</bpt>!=<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>!==<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、同等性と同一性演算子の論理上当然な補完物（<bpt i="0" x="0">&lt;c0&gt;</bpt>!=<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>!==<ept i="1">&lt;/c1&gt;</ept>）に対する実装を自動的に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift automatically synthesizes conformance to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> protocol for imported C enumeration types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、インポートされたC列挙型に対して自動的に<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>プロトコルへの準拠を合成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift automatically translates Objective-C methods that produce errors into methods that throw an error according to Swift’s native error handling functionality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、自動的にエラーを生成するObjective-Cメソッドを、スウィフト固有のエラー処理機能に従ってエラーをスローするメソッドに翻訳します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift bridges between the <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> type and the <bpt i="1" x="1">&lt;c1&gt;</bpt>NSArray<ept i="1">&lt;/c1&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>型と<bpt i="1" x="1">&lt;c1&gt;</bpt>NSArray<ept i="1">&lt;/c1&gt;</ept>クラスの間での橋渡しをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift bridges between the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSNumber<ept i="0">&lt;/c0&gt;</ept> class and Swift numeric types, including <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは<bpt i="0" x="0">&lt;c0&gt;</bpt>NSNumber<ept i="0">&lt;/c0&gt;</ept>クラスと、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>、および<bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept>を含むスウィフト数値型の間をブリッジします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift bridges between the <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> type and the <bpt i="1" x="1">&lt;c1&gt;</bpt>NSString<ept i="1">&lt;/c1&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スフィフトは、<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>型と<bpt i="1" x="1">&lt;c1&gt;</bpt>NSString<ept i="1">&lt;/c1&gt;</ept>クラスの間をブリッジします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift bridges optional values to nonnullable Objective-C objects according to whether the optional contains an underlying, wrapped value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、オプショナル値をnull不可Objective-Cオブジェクトへと、そのオプショナルがその下に隠している、ラップされた値を持つかどうかに従ってブリッジします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift classes are namespaced based on the module they are compiled in, even when used from Objective-C code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトクラスは、それらがコンパイルされているモジュールに基づく名前空間に置かれます、Objective-Cコードから使用される時でさえもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift closures and Objective-C blocks are compatible, so you can pass Swift closures to Objective-C methods that expect blocks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのクロージャとObjective-Cのブロックは互換性を持つので、ブロックを要求するObjective-Cメソッドに、あなたはスウィフトクロージャを渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift closures and functions have the same type, so you can even pass the name of a Swift function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのクロージャと関数は同じ型を持つので、あなたはスウィフト関数の名前を渡しさえすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift code</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift code and Objective-C code are conditionally compiled in different ways.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコードとObjective-Cコードは、異なる方法で条件付きコンパイルされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift code can be conditionally compiled using <bpt i="0" x="0">&lt;e0&gt;</bpt>conditional compilation blocks<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコードは、<bpt i="0" x="0">&lt;e0&gt;</bpt>条件コンパイルブロック<ept i="0">&lt;/e0&gt;</ept>を使って条件付きコンパイルされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift code can use the availability of APIs as a condition <bpt i="0" x="0">&lt;s0&gt;</bpt>at run-time<ept i="0">&lt;/s0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコードは、APIの有効性をひとつの条件として使うことが<bpt i="0" x="0">&lt;s0&gt;</bpt>実行時に<ept i="0">&lt;/s0&gt;</ept>可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift code uses <bpt i="0" x="0">&lt;c0&gt;</bpt>var<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>let<ept i="1">&lt;/c1&gt;</ept> to control mutability, so it doesn’t need both classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコードは、<bpt i="0" x="0">&lt;c0&gt;</bpt>var<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>let<ept i="1">&lt;/c1&gt;</ept>を使って可変性を制御します、それでそれは両方のクラスを必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift constant stored properties and computed properties become read-only Objective-C properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの定数保存プロパティと計算プロパティは、読出し専用Objecive-Cプロパティになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift declarations marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>private<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>fileprivate<ept i="1">&lt;/c1&gt;</ept> modifier do not appear in the generated header.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>private<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>fileprivate<ept i="1">&lt;/c1&gt;</ept>修飾子で印される宣言は、生成されたヘッダの中に現れません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift deinitializers are called automatically, just before instance deallocation happens.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトデイニシャライザは、ちょうどインスタンスの割り当て解除が起こる前に、自動的に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift enumerations conforming to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Error<ept i="0">&lt;/c0&gt;</ept> protocol and declared with the <bpt i="1" x="1">&lt;c1&gt;</bpt>@objc<ept i="1">&lt;/c1&gt;</ept> attribute produce an <bpt i="2" x="2">&lt;c2&gt;</bpt>NS_ENUM<ept i="2">&lt;/c2&gt;</ept> declaration, as well as an <bpt i="3" x="3">&lt;c3&gt;</bpt>NSString<ept i="3">&lt;/c3&gt;</ept> constant for the corresponding error domain in the generated header.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Error<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠していて<bpt i="1" x="1">&lt;c1&gt;</bpt>@objc<ept i="1">&lt;/c1&gt;</ept>属性で印されるスウィフト列挙は、生成ヘッダにおいて<bpt i="2" x="2">&lt;c2&gt;</bpt>NS_ENUM<ept i="2">&lt;/c2&gt;</ept>宣言、それだけでなく対応するエラードメインに対する<bpt i="3" x="3">&lt;c3&gt;</bpt>NSString<ept i="3">&lt;/c3&gt;</ept>定数を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift has the following buffer pointer types:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、以下のバッファポインタ型を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift imports C unions as Swift structures.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、C共用体をスウィフト構造体としてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift imports Objective-C declarations of <bpt i="0" x="0">&lt;c0&gt;</bpt>NSDictionary<ept i="0">&lt;/c0&gt;</ept> that don’t specify a class qualification for the key type as a <bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept> with the <bpt i="2" x="2">&lt;c2&gt;</bpt>Key<ept i="2">&lt;/c2&gt;</ept> type <bpt i="3" x="3">&lt;c3&gt;</bpt>AnyHashable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、キー型に対してクラス資格を指定しない<bpt i="0" x="0">&lt;c0&gt;</bpt>NSDictionary<ept i="0">&lt;/c0&gt;</ept>のObjective-C宣言を、<bpt i="2" x="2">&lt;c2&gt;</bpt>Key<ept i="2">&lt;/c2&gt;</ept>型<bpt i="3" x="3">&lt;c3&gt;</bpt>AnyHashable<ept i="3">&lt;/c3&gt;</ept>を持つ<bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept>としてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift imports any C enumeration marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_ENUM<ept i="0">&lt;/c0&gt;</ept> macro as a Swift enumeration with an <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> raw value type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_ENUM<ept i="0">&lt;/c0&gt;</ept>マクロで印を付けられるどんなCの列挙でも、生の値型<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>を持つスウィフト列挙としてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift imports any C structure declared in a C header as a Swift structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、Cヘッダにおいて宣言されるどんなC構造体もスウィフト構造体としてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift imports any function declared in a C header as a Swift global function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、Cヘッダにおいて宣言されるどんな関数もスウィフトのグローバルな関数としてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift imports bit fields in structures, such those found in Foundation’s <bpt i="0" x="0">&lt;c0&gt;</bpt>NSDecimal<ept i="0">&lt;/c0&gt;</ept> type, as computed properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、構造体においてビットフィールド、Foundationの<bpt i="0" x="0">&lt;c0&gt;</bpt>NSDecimal<ept i="0">&lt;/c0&gt;</ept>型において見つけられるものなどを、計算プロパティとしてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift initializers and instance methods become Objective-C instance methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのイニシャライザとインスタンスメソッドは、Objective-Cインスタンスメソッドになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift is designed to provide seamless compatibility with Cocoa and Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、ココアとObjective-Cに継ぎ目のない互換性を提供するように設計されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift methods and properties that are marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>internal<ept i="0">&lt;/c0&gt;</ept> modifier and declared within a class that inherits from an Objective-C class are accessible to the Objective-C runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cクラスから継承するクラスの内部で宣言されて<bpt i="0" x="0">&lt;c0&gt;</bpt>internal<ept i="0">&lt;/c0&gt;</ept>修飾子で印されるスウィフトのメソッドとプロパティは、Objective-Cランタイムへとアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift methods that throw errors become Objective-C methods with an <bpt i="0" x="0">&lt;c0&gt;</bpt>NSError **<ept i="0">&lt;/c0&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーをスローするスウィフトメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSError **<ept i="0">&lt;/c0&gt;</ept>パラメータを持つObjective-Cメソッドになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift nonoptional types are annotated as <bpt i="0" x="0">&lt;c0&gt;</bpt>__nonnull<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの非オプショナル型は、<bpt i="0" x="0">&lt;c0&gt;</bpt>__nonnull<ept i="0">&lt;/c0&gt;</ept>として注釈を付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift numeric types (<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>, and so on.)</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト数値型（<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>、など）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift optional types are annotated as <bpt i="0" x="0">&lt;c0&gt;</bpt>__nullable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのオプショナル型は、<bpt i="0" x="0">&lt;c0&gt;</bpt>__nullable<ept i="0">&lt;/c0&gt;</ept>として注釈を付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift properties are strong by default.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトプロパティは、特に何もしなければ強いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides default implementations of the <bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>===<ept i="1">&lt;/c1&gt;</ept> operators and adopts the <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept> protocol for objects that derive from the <bpt i="3" x="3">&lt;c3&gt;</bpt>NSObject<ept i="3">&lt;/c3&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>===<ept i="1">&lt;/c1&gt;</ept>演算子の省略時の実装を提供します、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>プロトコルを<bpt i="3" x="3">&lt;c3&gt;</bpt>NSObject<ept i="3">&lt;/c3&gt;</ept>クラス由来のオブジェクトに対して採用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift provides equivalents of C primitive integer types—for example, <bpt i="0" x="0">&lt;c0&gt;</bpt>char<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>int<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>float<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>double<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、Cの基本の整数型の等価物を提供します ― 例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>char<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>int<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>float<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>double<ept i="3">&lt;/c3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift type methods become Objective-C class methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの型メソッドは、Objective-Cクラスメソッドになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift type properties become Objective-C properties with the <bpt i="0" x="0">&lt;c0&gt;</bpt>class<ept i="0">&lt;/c0&gt;</ept> property attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト型プロパティは、<bpt i="0" x="0">&lt;c0&gt;</bpt>class<ept i="0">&lt;/c0&gt;</ept>プロパティ属性を持つObjective-Cプロパティになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift uses optionals to guard against such unsafe behavior.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、オプショナルを使用してこのような安全でない挙動の発生を防ぐことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift variable stored properties become read-write Objective-C properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの変数保存プロパティは、読み書き両用のObjective-Cプロパティになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift vends its APIs—such as from a framework—as Swift modules.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、そのAPIを  ― 例えばフレームワークから ― スウィフトモジュールとして売り渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift will see every header you expose publicly in your umbrella header.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、あなたがあなたのアンブレラヘッダにおいて公的に露出するあらゆるヘッダを見るようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift wraps these returned Core Foundation objects in an <bpt i="0" x="0">&lt;c0&gt;</bpt>Unmanaged&lt;Instance&gt;<ept i="0">&lt;/c0&gt;</ept> structure.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトは、これらの返されたコアファウンデーション・オブジェクトを<bpt i="0" x="0">&lt;c0&gt;</bpt>Unmanaged&lt;T&gt;<ept i="0">&lt;/c0&gt;</ept>構造体に包みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift-style variadics</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト形式の可変長引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Swift’s compatibility with Objective-C lets you create a project that contains files written in either language.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cとのスウィフトの互換性は、あなたにどちらの言語ででも記述されるファイルを含むプロジェクトをつくらせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Taking the previous example, you can check availability in an <bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept> statement to call <bpt i="1" x="1">&lt;c1&gt;</bpt>requestWhenInUseAuthorization()<ept i="1">&lt;/c1&gt;</ept> only if the method is available at runtime:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以前の例をとって、あなたは有効性を<bpt i="0" x="0">&lt;c0&gt;</bpt>if<ept i="0">&lt;/c0&gt;</ept>文の中で確認して、<bpt i="1" x="1">&lt;c1&gt;</bpt>requestWhenInUseAuthorization()<ept i="1">&lt;/c1&gt;</ept>をそのメソッドが実行時に有効である場合にのみ呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Target-Action</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ターゲット-アクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Target-action is a common Cocoa design pattern in which one object sends a message to another object when a specific event occurs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ターゲット-アクションは、特定のイベントが起こる時にあるオブジェクトが別のオブジェクトにメッセージを送る場合の、一般的なココア・デザインパターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>That way, Swift can handle memory management for you.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのように、スウィフトはあなたの代わりにメモリ管理をうまく取り扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>@IBOutlet<ept i="0">&lt;/c0&gt;</ept> attribute no longer implicitly declares a property as optional and weak.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@IBOutlet<ept i="0">&lt;/c0&gt;</ept>属性はもはやプロパティを暗黙的にオプショナルや弱いとして宣言しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>AnyHashable<ept i="0">&lt;/c0&gt;</ept> type is used by Swift when importing Objective-C declarations with an unspecified or <bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept> type that cannot be otherwise be imported as <bpt i="2" x="2">&lt;c2&gt;</bpt>Any<ept i="2">&lt;/c2&gt;</ept> because the type needs to conform to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>AnyHashable<ept i="0">&lt;/c0&gt;</ept>型は、スウィフトによって、<bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept>または未指定型を持つObjective-C宣言をインポートする時に使われます、それはそうでなければ<bpt i="2" x="2">&lt;c2&gt;</bpt>Any<ept i="2">&lt;/c2&gt;</ept>としてインポートされることができません、なぜならその型は<bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>プロトコルに準拠する必要があるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept> structure is imported with a memberwise initializer that you can use to initialize the structure with custom values for its fields, as seen below:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept>構造体は、メンバー関連イニシャライザでインポートされます、それはあなたが構造体をそれのフィールドに誂えの値を使って初期化するのに使うことができるものです、下で見られるように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>NSCoding<ept i="0">&lt;/c0&gt;</ept> protocol requires that conforming types implement the required initializer <bpt i="1" x="1">&lt;c1&gt;</bpt>init(coder:)<ept i="1">&lt;/c1&gt;</ept> and the required method <bpt i="2" x="2">&lt;c2&gt;</bpt>encode(with:)<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSCoding<ept i="0">&lt;/c0&gt;</ept>プロトコルは、準拠している型が必須イニシャライザ<bpt i="1" x="1">&lt;c1&gt;</bpt>init(coder:)<ept i="1">&lt;/c1&gt;</ept>および必須メソッド<bpt i="2" x="2">&lt;c2&gt;</bpt>encode(with:)<ept i="2">&lt;/c2&gt;</ept>を実装することを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Unmanaged&lt;Instance&gt;<ept i="0">&lt;/c0&gt;</ept> structure provides two methods to convert an unmanaged object to a memory managed object—<bpt i="1" x="1">&lt;c1&gt;</bpt>takeUnretainedValue()<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>takeRetainedValue()<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Unmanaged&lt;T&gt;<ept i="0">&lt;/c0&gt;</ept>構造体は、管理されないオブジェクトをメモリ管理されたオブジェクトに変換するために、２つのメソッドを提供します ― <bpt i="1" x="1">&lt;c1&gt;</bpt>takeUnretainedValue()<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>takeRetainedValue()<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>arch(arm)<ept i="0">&lt;/c0&gt;</ept> platform condition does not return <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> for ARM 64 devices.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>arch(arm)<ept i="0">&lt;/c0&gt;</ept>プラットホーム条件は、ARM 64機器に対して<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>name<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>friends<ept i="1">&lt;/c1&gt;</ept> properties are both declared with the <bpt i="2" x="2">&lt;c2&gt;</bpt>@NSManaged<ept i="2">&lt;/c2&gt;</ept> attribute to indicate that Core Data provides their implementation and storage at runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>name<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>friends<ept i="1">&lt;/c1&gt;</ept>プロパティは、両方とも<bpt i="2" x="2">&lt;c2&gt;</bpt>@NSManaged<ept i="2">&lt;/c2&gt;</ept>属性を使って宣言され、コアデータがそれらの実装とストレージを実行時に提供することを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>prepare(withInvocationTarget:)<ept i="0">&lt;/c0&gt;</ept> method returns a proxy to the specified <bpt i="1" x="1">&lt;c1&gt;</bpt>target<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>prepare(withInvocationTarget:)<ept i="0">&lt;/c0&gt;</ept>メソッドは、措定された<bpt i="1" x="1">&lt;c1&gt;</bpt>target<ept i="1">&lt;/c1&gt;</ept>に対する代理を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>@available<ept i="1">&lt;/c1&gt;</ept> attribute uses the same syntax as the <bpt i="2" x="2">&lt;c2&gt;</bpt>#available<ept i="2">&lt;/c2&gt;</ept> runtime check, with the platform version requirements provided as comma-delimited arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>@available<ept i="1">&lt;/c1&gt;</ept>属性は、コンマ区切り引数として提供されるプラットホームバージョン要件を使う、<bpt i="2" x="2">&lt;c2&gt;</bpt>#available<ept i="2">&lt;/c2&gt;</ept>実行時確認と同じ構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>NSString<ept i="1">&lt;/c1&gt;</ept> class encodes a Unicode-compliant text string, represented as a sequence of UTF–16 code units.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>NSString<ept i="1">&lt;/c1&gt;</ept>クラスは、一連のUTF–16コード単位として表される、あるユニコード遵守テキスト文字列を符号化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>as?<ept i="1">&lt;/c1&gt;</ept> operator returns an optional value that can be bound to a constant using an <bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>let<ept i="3">&lt;/c3&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>as?<ept i="1">&lt;/c1&gt;</ept>演算子は、<bpt i="2" x="2">&lt;c2&gt;</bpt>if<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>let<ept i="3">&lt;/c3&gt;</ept>文を使って定数に束縛されることができるオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>is<ept i="1">&lt;/c1&gt;</ept> operator returns <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept> if the instance is of that subclass type, and <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept> if it is not.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>is<ept i="1">&lt;/c1&gt;</ept>演算子は、そのインスタンスがそのサブクラス型であるならば<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>を、それがそうでないならば<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>CFArrayCreateMutable(_:_:_:)<ept i="2">&lt;/c2&gt;</ept> function takes a <bpt i="3" x="3">&lt;c3&gt;</bpt>CFArrayCallBacks<ept i="3">&lt;/c3&gt;</ept> structure, which is initialized with function pointer callbacks:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>CFArrayCreateMutable(_:_:_:)<ept i="2">&lt;/c2&gt;</ept>関数は、ひとつの<bpt i="3" x="3">&lt;c3&gt;</bpt>CFArrayCallBacks<ept i="3">&lt;/c3&gt;</ept>構造体を取ります、それは関数ポインタコールバックで初期化されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>arch(i386)<ept i="2">&lt;/c2&gt;</ept> platform condition returns <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept> when code is compiled for the 32–bit iOS simulator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>arch(i386)<ept i="2">&lt;/c2&gt;</ept>プラットホーム条件は、コードが32ビットiOSシミュレーターに対してコンパイルされるとき<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>getVaList(_:)<ept i="3">&lt;/c3&gt;</ept> function takes an array of <bpt i="4" x="4">&lt;c4&gt;</bpt>CVarArg<ept i="4">&lt;/c4&gt;</ept> values and returns a <bpt i="5" x="5">&lt;c5&gt;</bpt>CVaListPointer<ept i="5">&lt;/c5&gt;</ept> value, whereas the <bpt i="6" x="6">&lt;c6&gt;</bpt>withVaList(_:_:)<ept i="6">&lt;/c6&gt;</ept> provides this value within the body a closure parameter rather than returning it directly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>getVaList(_:)<ept i="3">&lt;/c3&gt;</ept>関数は、<bpt i="4" x="4">&lt;c4&gt;</bpt>CVarArg<ept i="4">&lt;/c4&gt;</ept>値からなるひとつの配列をとって<bpt i="5" x="5">&lt;c5&gt;</bpt>CVaListPointer<ept i="5">&lt;/c5&gt;</ept>値を返します、一方で<bpt i="6" x="6">&lt;c6&gt;</bpt>withVaList(_:_:)<ept i="6">&lt;/c6&gt;</ept>は、この値を本文内部でクロージャパラメータに提供します、それを直接返すのではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>myCount<ept i="3">&lt;/c3&gt;</ept> constant is inferred to be an optional <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>, and is set to <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>myCount<ept i="3">&lt;/c3&gt;</ept>定数は、オプショナルの<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>であると推論されて、<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>#keyPath<ept i="4">&lt;/c4&gt;</ept> string expression accepts chained method or property references.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>#keyPath<ept i="4">&lt;/c4&gt;</ept>文字列式は、数珠つなぎにされたメソッドまたはプロパティ参照を受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>AnyHashable<ept i="4">&lt;/c4&gt;</ept> type is implicitly converted from any <bpt i="5" x="5">&lt;c5&gt;</bpt>Hashable<ept i="5">&lt;/c5&gt;</ept> type, and you can use the <bpt i="6" x="6">&lt;c6&gt;</bpt>as?<ept i="6">&lt;/c6&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt>as!<ept i="7">&lt;/c7&gt;</ept> operators to cast from <bpt i="8" x="8">&lt;c8&gt;</bpt>AnyHashable<ept i="8">&lt;/c8&gt;</ept> to a more specific type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>AnyHashable<ept i="4">&lt;/c4&gt;</ept>型は暗黙的に何らかの<bpt i="5" x="5">&lt;c5&gt;</bpt>Hashable<ept i="5">&lt;/c5&gt;</ept>型から変換されます、そしてあなたは<bpt i="6" x="6">&lt;c6&gt;</bpt>as?<ept i="6">&lt;/c6&gt;</ept>および<bpt i="7" x="7">&lt;c7&gt;</bpt>as!<ept i="7">&lt;/c7&gt;</ept>演算子を使って<bpt i="8" x="8">&lt;c8&gt;</bpt>AnyHashable<ept i="8">&lt;/c8&gt;</ept>からより具体的な型へキャストできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Core Foundation <bpt i="0" x="0">&lt;c0&gt;</bpt>CFTypeRef<ept i="0">&lt;/c0&gt;</ept> type completely remaps to the <bpt i="1" x="1">&lt;c1&gt;</bpt>AnyObject<ept i="1">&lt;/c1&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コアファウンデーションの<bpt i="0" x="0">&lt;c0&gt;</bpt>CFTypeRef<ept i="0">&lt;/c0&gt;</ept>型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>AnyObject<ept i="1">&lt;/c1&gt;</ept>型に完全にリマップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Foundation framework provides a base layer of functionality for apps and frameworks, including data storage, text processing, dates and times, sorting and filtering, persistence, and networking.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Foundationフレームワークは、ある基盤階層をアプリとフレームワークのための機能性に関して提供していて、データストレージ、テキスト処理、日付と時刻、ソートとフィルタ、永続、そしてネートワーク処理を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Migration Process</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>移動プロセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>id<ept i="0">&lt;/c0&gt;</ept> type is imported by Swift as the <bpt i="1" x="1">&lt;c1&gt;</bpt>Any<ept i="1">&lt;/c1&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>id<ept i="0">&lt;/c0&gt;</ept>型は、スウィフトによって<bpt i="1" x="1">&lt;c1&gt;</bpt>Any<ept i="1">&lt;/c1&gt;</ept>型としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Objective-C functionality will be available in any Swift file within that target automatically, without any import statements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-C機能性は、まったくインポート文なしで、自動的にそのターゲット内のどんなスウィフトファイルにおいても利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> type is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトの<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>型は、符号化非依存のユニコード文字から構成されます、そしてそれらの文字に様々なユニコード表現においてアクセスするための支援を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift Foundation overlay provides the following bridged value types for the following Objective-C reference types:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト Foundationオーバーレイは、以下のブリッジ値型を以下のObjective-C参照型に対して提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift Foundation overlay renames classes and protocols, as well as related enumerations and constants.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフト Foundationオーバーレイは、クラスおよびプロトコルを改名します、それだけでなく関連した列挙と定数も。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift compiler automatically imports Objective-C code as conventional Swift code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコンパイラは、自動的にObjective-Cコードを普通の意味でのスウィフトコードとしてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift compiler does not include a preprocessor.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコンパイラは、プリプロセッサを含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift compiler ensures that your initializers do not leave any properties in your class uninitialized to increase the safety and predictability of your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコンパイラは、あなたのコードの安全性と予測可能性を高めるためにあなたのイニシャライザたちがアンイニシャライズされるあなたのクラスにおいて１つのプロパティもそのままにしておかないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift compiler includes attributes that enable Interface Builder features for your Swift classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコンパイラは、あなたのスウィフトクラスのためにインタフェースビルダー機能を可能にする属性を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift files in your framework target will be visible in Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> files containing this import statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのフレームワークターゲットの中のスウィフトファイルは、このインポート文を含んでいるObjective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルにおいて見えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The Swift files in your target will be visible in Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> files containing this import statement.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのターゲットの中のスウィフトファイルは、このインポート文を含んでいるObjective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルにおいて見えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The address of that buffer is passed to the callee, and on return, the value in the buffer is loaded, retained, and reassigned into the operand.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのバッファのアドレスは呼び出される側に渡されます、そして戻る時に、バッファの値はロードされ、保持され、演算数に再割り当てされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The argument passed to the <bpt i="0" x="0">&lt;c0&gt;</bpt>CF_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept> macro uses the same syntax as the <bpt i="1" x="1">&lt;c1&gt;</bpt>#selector<ept i="1">&lt;/c1&gt;</ept> expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>CF_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept>マクロに渡された引数は、<bpt i="1" x="1">&lt;c1&gt;</bpt>#selector<ept i="1">&lt;/c1&gt;</ept>式と同じ構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The base implementation of the <bpt i="0" x="0">&lt;c0&gt;</bpt>isEqual:<ept i="0">&lt;/c0&gt;</ept> provided by the <bpt i="1" x="1">&lt;c1&gt;</bpt>NSObject<ept i="1">&lt;/c1&gt;</ept> class is equivalent to an identity check by pointer equality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>NSObject<ept i="1">&lt;/c1&gt;</ept>クラスによって提供される<bpt i="0" x="0">&lt;c0&gt;</bpt>isEqual:<ept i="0">&lt;/c0&gt;</ept>の基本実装は、ポインタ同等性による同一性確認に等しいものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The code listing below illustrates the following process:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下記のコード出力は、次の過程を例示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The compiler automatically infers the name of the overridden Objective-C method that matches the Swift method name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラは、そのスウィフトメソッド名と適合するオーバーライドされたObjective-Cメソッドの名前を自動的に推論します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The compiler removes <bpt i="0" x="0">&lt;e0&gt;</bpt>Ref<ept i="0">&lt;/e0&gt;</ept> from the end of each type name because all Swift classes are reference types, therefore the suffix is redundant.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コンパイラは各型名の終わりから<bpt i="0" x="0">&lt;e0&gt;</bpt>Ref<ept i="0">&lt;/e0&gt;</ept>を削除します、なぜなら全てのスウィフトクラスが参照型であり、したがってこの接尾辞は冗長です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The contents of the Objective-C files in that framework will be available in any Swift file within that framework target automatically, without any import statements.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのフレームワークの中のObjective-Cファイルの中身は、まったくインポート文なしで、そのフレームワークターゲット内のあらゆるスウィフトファイルにおいて自動的に利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The corresponding reference types can be accessed with their original <bpt i="2" x="2">&lt;c2&gt;</bpt>NS<ept i="2">&lt;/c2&gt;</ept> class name prefix.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>対応する参照型は、それら本来の<bpt i="2" x="2">&lt;c2&gt;</bpt>NS<ept i="2">&lt;/c2&gt;</ept>クラス名接頭辞でアクセスされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The default implementation of the <bpt i="4" x="4">&lt;c4&gt;</bpt>==<ept i="4">&lt;/c4&gt;</ept> operator invokes the <bpt i="5" x="5">&lt;c5&gt;</bpt>isEqual:<ept i="5">&lt;/c5&gt;</ept> method, and the default implementation of the <bpt i="6" x="6">&lt;c6&gt;</bpt>===<ept i="6">&lt;/c6&gt;</ept> operator checks pointer equality.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>==<ept i="4">&lt;/c4&gt;</ept>演算子の省略時の実装は、<bpt i="5" x="5">&lt;c5&gt;</bpt>isEqual:<ept i="5">&lt;/c5&gt;</ept>メソッドを発動します、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>===<ept i="6">&lt;/c6&gt;</ept>演算子の省略時の実装はポインタの同等性を調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The differences between Objective-C and Swift syntax are all the more apparent when instantiating objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cとスウィフト構文の間の違いは、オブジェクトをインスタンス化するとき全て明らかになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows a customized error type defined using the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_ERROR_ENUM<ept i="0">&lt;/c0&gt;</ept> macro in Objective-C:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、Objective-Cにおいて<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_ERROR_ENUM<ept i="0">&lt;/c0&gt;</ept>を使ってカスタマイズされたエラー型を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows availability information used in a conditional statement in Swift:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、スウィフトでの条件文で使われる利用可能性情報を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The example below shows availability information used on a declaration in Swift:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>下の例は、スウィフトでのある宣言で使われる利用可能性情報を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first argument appears immediately inside the parentheses, without a name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最初の引数は、名前なしで、丸括弧の直ぐ内側に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first element in <bpt i="0" x="0">&lt;c0&gt;</bpt>CommandLine.arguments<ept i="0">&lt;/c0&gt;</ept> is a path to the executable.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>CommandLine.arguments<ept i="0">&lt;/c0&gt;</ept>の中の最初の項目は、常に実行ファイルへのパスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The first, <bpt i="0" x="0">&lt;e0&gt;</bpt>equality<ept i="0">&lt;/e0&gt;</ept> (<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>), compares the contents of the objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>１つめ、<bpt i="0" x="0">&lt;e0&gt;</bpt>同等性<ept i="0">&lt;/e0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>）は、オブジェクトの内容を比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following code shows how <bpt i="0" x="0">&lt;c0&gt;</bpt>String?<ept i="0">&lt;/c0&gt;</ept> instances bridge to Objective-C depending on their value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のコードは、どのように<bpt i="0" x="0">&lt;c0&gt;</bpt>String?<ept i="0">&lt;/c0&gt;</ept>インスタンスがObjective-Cへとそれの値に基づいてブリッジするかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following mappings apply:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下のマッピングを適用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The following tables use <bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept> as a placeholder type name to indicate syntax for the mappings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>以下の表は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept>をプレースホルダー型名として使ってマップのための構文を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The general import model for working with both languages within the same target is depicted below and described in more detail in the following sections.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じターゲット内で両方の言語を扱う一般的なインポートモデルは下で表され、更に詳細に以下の節において記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The import process is straightforward.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポートプロセスは単刀直入です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The imported Swift structure contains a stored property for each C structure field and an initializer whose parameters correspond to the stored properties.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>インポートされたスウィフト構造体は、各C構造体フィールドに対してひとつの保存プロパティを、そしてそれのパラメータが保存プロパティと対応するひとつのイニシャライザを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The importing process determines how functions, classes, methods, and types declared in Objective-C code appear in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインポートブロセスは、Objective-Cコードにおいて宣言した関数、クラス、メソッド、そして型が、スウィフトの中にどのように現れるかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The last argument is an asterisk (<bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept>), which is used to handle potential future platforms.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>最後の引数は、ひとつのアスタリスクです（<bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept>）、それは潜在的な将来のプラットホームを取り扱うために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The macro behaves just like the <bpt i="1" x="1">&lt;c1&gt;</bpt>NS_SWIFT_UNAVAILABLE<ept i="1">&lt;/c1&gt;</ept> macro except that it omits the customizable error message and it restricts compile-time access to the declaration in Objective-C code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このマクロはちょうど<bpt i="1" x="1">&lt;c1&gt;</bpt>NS_SWIFT_UNAVAILABLE<ept i="1">&lt;/c1&gt;</ept>マクロのように振舞います、しかしそれがカスタマイズ可能なエラーメッセージを省略することと、それがコンパイル時アクセスをObjective-Cコードの中の宣言に制限することを除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The methods that perform a selector synchronously, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>perform(_:)<ept i="0">&lt;/c0&gt;</ept>, return an implicitly unwrapped optional unmanaged pointer to an <bpt i="1" x="1">&lt;c1&gt;</bpt>AnyObject<ept i="1">&lt;/c1&gt;</ept> instance (<bpt i="2" x="2">&lt;c2&gt;</bpt>Unmanaged&lt;AnyObject&gt;!<ept i="2">&lt;/c2&gt;</ept>), because the type and ownership of the value returned by performing the selector can’t be determined at compile time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>セレクタを同期的に実行するメソッド、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>perform(_:)<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>AnyObject<ept i="1">&lt;/c1&gt;</ept>インスタンス（<bpt i="2" x="2">&lt;c2&gt;</bpt>Unmanaged&lt;AnyObject&gt;!<ept i="2">&lt;/c2&gt;</ept>）に対する暗黙的にアンラップされたオプショナルの非管理ボインタを返します、なぜならセレクタ実行によって返される値の型と所有権はコンパイル時に確定されることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The model for importing Swift into Objective-C is similar to the one used for importing Objective-C into Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトをObjective-Cにインポートすることの原型は、Objective-Cをスウィフトにインポートするために使われるものに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The most effective approach for migrating code to Swift is on a per-file basis—that is, one class at a time.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトへの移っているコードのために最も効果的なアプローチは、ファイル毎原則の上にあります ― すなわち、一度にひとつのクラス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The name of the Xcode-generated header for Swift code, and the name of the Objective-C bridging header that Xcode creates for you, are generated from your product module name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコードのためのXcode生成のヘッダの名前、そしてXcodeがあなたの代わりにつくるObjective-C橋渡しヘッダのの名前は、あなたの製品モジュール名から生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The name of this header is your product module name followed by adding <bpt i="1" x="1">&lt;c1&gt;</bpt>"-Swift.h"<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このヘッダの名前は、あなたの製品モジュール名に続けて<bpt i="1" x="1">&lt;c1&gt;</bpt>"-Swift.h"<ept i="1">&lt;/c1&gt;</ept>を加えたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The path should be relative to your project, similar to the way your Info.plist path is specified in Build Settings.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>パスは、あなたのプロジェクトに相対的でなければなりません、あなたのInfo.plistパスが「Build Settings」において指定される方法に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The pointer passed to the function is guaranteed to be valid only for the duration of the function call.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数に渡されるポインタは、その関数呼び出しの継続期間に対してのみ有効であることを保証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The prefixes to C enumeration case names are removed when they are imported into Swift, whether they’re defined in system frameworks or in custom code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>C列挙ケース節名への接頭辞は、それらがスウィフトにインポートされるとき削除されます、それらがシステムフレームワークでまたはあつらえのコードで定義されるかに関係なくです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The process described in this section applies to non-framework targets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この節で記述されるプロセスは、非フレームワークターゲットにあてはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The process for importing an external framework is the same whether the framework is written in a single language or contains files from both languages.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>外部フレームワークをインポートするプロセスは、そのフレームワークが１つだけの言語で書かれるか、両方の言語からのファイルを含むかに関係なく、同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The process for working with mixed-language targets differs slightly depending on whether you’re writing an app or a framework.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>混合言語のターゲットを扱う過程は、あなたがアプリを書いているかフレームワークを書いているかに従い、わずかに異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The raw buffer pointer types, <bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafeRawBufferPointer<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>UnsafeMutableRawBufferPointer<ept i="1">&lt;/c1&gt;</ept>, let you view or mutate a contiguous block of memory as a collection of <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt8<ept i="2">&lt;/c2&gt;</ept> values, where each value corresponds to a byte of memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>生のバッファポインタ型、<bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafeRawBufferPointer<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>UnsafeMutableRawBufferPointer<ept i="1">&lt;/c1&gt;</ept>は、あなたにメモリの隣接ブロックを<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt8<ept i="2">&lt;/c2&gt;</ept>値のコレクションとして眺めさせたり変化させたりします、そこで各値はメモリのあるバイトに対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The rest of the selector pieces correspond to argument names and appear inside the parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>残りのセレクタ片は、引数名に相当して、括弧の内側に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The resulting <bpt i="7" x="7">&lt;c7&gt;</bpt>CVaListPointer<ept i="7">&lt;/c7&gt;</ept> value is then passed to the <bpt i="8" x="8">&lt;c8&gt;</bpt>va_list<ept i="8">&lt;/c8&gt;</ept> argument of the C variadic function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>結果の<bpt i="7" x="7">&lt;c7&gt;</bpt>CVaListPointer<ept i="7">&lt;/c7&gt;</ept>値は、それからC可変長引数関数の<bpt i="8" x="8">&lt;c8&gt;</bpt>va_list<ept i="8">&lt;/c8&gt;</ept>引数に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The second, <bpt i="2" x="2">&lt;e2&gt;</bpt>identity<ept i="2">&lt;/e2&gt;</ept> (<bpt i="3" x="3">&lt;c3&gt;</bpt>===<ept i="3">&lt;/c3&gt;</ept>), determines whether or not the constants or variables refer to the same object instance.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>２つめ、<bpt i="2" x="2">&lt;e2&gt;</bpt>同一性<ept i="2">&lt;/e2&gt;</ept>（<bpt i="3" x="3">&lt;c3&gt;</bpt>===<ept i="3">&lt;/c3&gt;</ept>）は、定数または変数が同じオブジェクトインスタンスに言及するかどうかを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The string will automatically be converted to UTF8 in a buffer, and a pointer to that buffer is passed to the function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>その文字列は、あるバッファにおいて自動的にUTF8に変換されます、そしてそのバッファへのポインタが関数へ渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The syntax of a <bpt i="0" x="0">&lt;c0&gt;</bpt>#keyPath<ept i="0">&lt;/c0&gt;</ept> string expression is similar to the syntax of a <bpt i="1" x="1">&lt;c1&gt;</bpt>#selector<ept i="1">&lt;/c1&gt;</ept> expression, as described in <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Selectors<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>#keyPath<ept i="0">&lt;/c0&gt;</ept>文字列式の構文は、<bpt i="1" x="1">&lt;c1&gt;</bpt>#selector<ept i="1">&lt;/c1&gt;</ept>式の構文に似ています、<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>セレクタ<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The target-action model is fundamentally similar in Swift and Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ターゲット-アクションの雛形は、スウィフトとObjective-Cで基本的に類似しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The type of the property must conform to the <bpt i="2" x="2">&lt;c2&gt;</bpt>NSCopying<ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>プロパティの型は、<bpt i="2" x="2">&lt;c2&gt;</bpt>NSCopying<ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The typed buffer pointer types, <bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafeBufferPointer<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>UnsafeMutableBufferPointer<ept i="1">&lt;/c1&gt;</ept>, let you view or mutate a contiguous block of memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>型付きバッファポインタ型、<bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafeBufferPointer<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>UnsafeMutableBufferPointer<ept i="1">&lt;/c1&gt;</ept>は、あなたにメモリの隣接ブロックを眺めさせたり変化させたりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The unified logging system provides an API for capturing messaging across all levels of the system, and is a replacement for the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSLog<ept i="0">&lt;/c0&gt;</ept> function in the Foundation framework.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>統合ログシステムは、システムのすべての水準にまたがってメッセージを捕らえるためにAPIを提供します、そしてFoundationフレームワークにおける<bpt i="0" x="0">&lt;c0&gt;</bpt>NSLog<ept i="0">&lt;/c0&gt;</ept>関数に対する置き換えです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>The use of <bpt i="2" x="2">&lt;c2&gt;</bpt>self<ept i="2">&lt;/c2&gt;</ept> in a <bpt i="3" x="3">&lt;c3&gt;</bpt>CF_SWIFT_NAME<ept i="3">&lt;/c3&gt;</ept> argument is used for instance methods to refer to the method receiver.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>CF_SWIFT_NAME<ept i="3">&lt;/c3&gt;</ept>引数における<bpt i="2" x="2">&lt;c2&gt;</bpt>self<ept i="2">&lt;/c2&gt;</ept>の使用は、インスタンスメソッドに対して使われてメソッドのレシーバを参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are two distinct types of comparison you can make between two objects in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがスウィフトにおいて２つのオブジェクトの間に作ることができる比較には２つの別個の型があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There are, however, various pointer types available for your use when you need direct access to memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>しかし、あなたがメモリへの直接のアクセスを必要とするとき、あなたの利用に応じられるいろいろなポインター型があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is no explicit delineation between the implementation and the interface—all of the information about a class, function, or constant resides in a single <bpt i="0" x="0">&lt;c0&gt;</bpt>.swift<ept i="0">&lt;/c0&gt;</ept> file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>明確な境界線が実装とインタフェースの間にありません ― クラス、関数、または定数に関する全ての情報は１つの<bpt i="0" x="0">&lt;c0&gt;</bpt>.swift<ept i="0">&lt;/c0&gt;</ept>ファイルに属します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There is no way to recover from Objective-C exceptions directly in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトには直接にObjective-C例外から回復する方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>There may be edge cases in your code that are not automatically handled.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>自動的に処理されることが際どい場合があなたのコードであるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, the class you migrate cannot have any Objective-C subclasses in your app.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、あなたが移行するクラスは、あなたのアプリにおいて１つもObjective-Cサブクラスを持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, the complex macros that are in C and Objective-C source files are not made available to your Swift code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、CとObjective-Cソース・ファイルの中にある複雑なマクロは、あなたのスウィフトコードで利用可能にされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, use these types if your code specifically requires them, but use <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept> wherever possible otherwise.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>したがって、あなたのコードが特にそれらを必要とする場合にこれらの型を使ってください、しかし一方で可能な場合にはいつでも<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, using these APIs is strongly discouraged unless your code specifically relies on the dynamic method resolution provided by the Objective-C runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それゆえに、これらのAPIを使うことは強く反対されます、あなたのコードがObjective-Cランタイムによって提供される動的メソッド解決を特別に当てにするのでない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Therefore, when you work with APIs that operate on the string representation of a Swift class, you must include the fully qualified name of the class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それゆえに、あなたがあるスウィフトクラスの文字列表現で作動するAPIを扱うとき、あなたはそのクラスの完全修飾名を含めなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These <bpt i="0" x="0">&lt;c0&gt;</bpt>UITableView<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>UITextField<ept i="1">&lt;/c1&gt;</ept> objects are the same objects that you’d instantiate in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの<bpt i="0" x="0">&lt;c0&gt;</bpt>UITableView<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>UITextField<ept i="1">&lt;/c1&gt;</ept>オブジェクトは、それらがObjective-Cでインスタンス化するのと同じオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These headers vend the APIs that can be mapped back to Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのヘッダは、Objective-Cに逆にマップされることができるAPIを売り歩きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These include <bpt i="1" x="1">&lt;c1&gt;</bpt>NSLocalizedString<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>NSLocalizedStringFromTable<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>NSLocalizedStringFromTableInBundle<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>NSLocalizedStringWithDefaultValue<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらは、<bpt i="1" x="1">&lt;c1&gt;</bpt>NSLocalizedString<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>NSLocalizedStringFromTable<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>NSLocalizedStringFromTableInBundle<ept i="3">&lt;/c3&gt;</ept>, そして<bpt i="4" x="4">&lt;c4&gt;</bpt>NSLocalizedStringWithDefaultValue<ept i="4">&lt;/c4&gt;</ept>を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These representations can then be written to a file, or transmitted to another process locally or over a network.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの表現は、それからファイルに書き出されたり、別のプロセスにローカルにまたはそのネットワークを超えて送られたりができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These should not be overridden.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらはオーバーライドされるべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These types let you access the memory as a collection, where each item is an instance of the buffer type’s <bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> generic type parameter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの型は、あなたにコレクションとしてメモリにアクセスさせます、そこで各項目はそのバッファ型のもつ<bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>総称体型パラメータのインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These types let you use low-level programming patterns, such as operating on raw memory without compiler-checked type safety, or switching between several different typed interpretations of the same memory.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの型はあなたに低水準プログラミングパターンを使用させます、たとえばコンパイラ確認の型安全なしの生の値上での演算など、または同じメモリのいくつかの異なる型での実装の間での切り替えなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>These value types have the same functionality as their corresponding reference types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらの値型は、それらの対応する参照型と同じ機能性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This allows them to be used with the same syntax as initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、それらにイニシャライザと同じ構文で使用されることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This allows you to write maintain flexibility of untyped access to Objective-C APIs that return <bpt i="2" x="2">&lt;c2&gt;</bpt>id<ept i="2">&lt;/c2&gt;</ept> values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これがあなたに書くことを可能にするのは、<bpt i="2" x="2">&lt;c2&gt;</bpt>id<ept i="2">&lt;/c2&gt;</ept>値を返すObjective-C APIに対する型なしでのアクセスの柔軟性の維持です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This approach simplifies the logic of handling different platform capabilities.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この取り組みは、異なるプラットホーム適応性の取り扱い論理を単純にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This automatically generated file is an Objective-C header that declares the Swift interfaces in your target.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この自動的に生成されるファイルは、あなたのターゲットの中のスウィフトインタフェースを宣言するObjective-Cヘッダです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This documentation contains preliminary information about an API or technology in development.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example extends the <bpt i="0" x="0">&lt;c0&gt;</bpt>CGRect<ept i="0">&lt;/c0&gt;</ept> structure to contain a computed <bpt i="1" x="1">&lt;c1&gt;</bpt>area<ept i="1">&lt;/c1&gt;</ept> property:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>CGRect<ept i="0">&lt;/c0&gt;</ept>構造体を拡張して、計算<bpt i="1" x="1">&lt;c1&gt;</bpt>area<ept i="1">&lt;/c1&gt;</ept>プロパティを含むようにします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This example shows how to generate errors using that custom error type in Swift:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例は、そのあつらえのエラー型をスウィフトにおいて使うことでエラーを生成する方法を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This exception ensures that an older compiler doesn’t attempt to parse syntax introduced in a newer version of Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この例外は、古いコンパイラがより新しいバージョンのスウィフトで導入される構文の解析を試みないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This excludes Swift-only features, such as those listed here:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、ここに一覧にされるようなスウィフトのみの機能を除外します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This guide covers three important aspects of Swift and Objective-C compatibility that you can use to your advantage when developing Cocoa apps:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このガイドは、この互換性の３つの重要な面を扱います、それは、あなたがココア・アプリを開発するときあなたの強みとして使うことができるものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This includes all of the Objective-C system frameworks—such as Foundation, UIKit, and SpriteKit—as well as common C libraries supplied with the system.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、Objective-Cシステムフレームワークの全て ― Foundation、UIKit、そしてSpriteKitなど ― それだけでなくシステムで供給される一般的なCライブラリをも含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is because all Swift code is syntax checked, even when it is not compiled.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは全てのスウィフトコードが、それがコンパイルされないときでも、構文チェックされるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is discussed in more detail in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Swift and Objective-C in the Same Project<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、より詳細に<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>同じプロジェクト中のスウィフトとObjective-C<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is done for compatibility with C, which allows any value to be stored in an enumeration, including values used internally but not exposed in headers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、Cとの互換性のために行われます、それはどんな値も列挙に格納されることを許します、内部的に使われるがヘッダに暴露されない値も含めて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This is true even though the instance’s defining type is bridged to Swift as a structure type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、たとえそのインスタンスのもつ定義型がスウィフトへ構造体型としてブリッジされるとしても当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This keyword can be used only for properties that are optional class types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>オプショナルのクラス型であるプロパティだけに対して、このキーワードは使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This lets you take advantage of the functionality available on the reference type’s implementation in a way that is natural in Swift code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたに参照型の実装上で利用可能な機能性を、スウィフトコードにおける自然な方法で利用させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This limitation no longer exists.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この制限はもはや存在しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This makes Swift an easy, convenient, and powerful tool to integrate into your development workflow.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、スウィフトを簡単で、便利で、強力なツールにして、あなたの開発ワークフローへと統合させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means that you can create classes and protocols based on familiar, established behavior in Objective-C and enhance them with Swift’s modern and powerful language features.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたがObjective-Cでのお馴染みの、確立された挙動に基づいてクラスおよびプロトコルを作成して、それらをスウィフトの現代的で強力な言語機能で強化することができることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This means tidying up and modernizing your existing Objective-C codebase.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これは、あなたの既存のObjective-Cコードベースを整えて、現代化することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This natural workflow makes creating mixed-language app and framework targets as straightforward as creating an app or framework target written in a single language.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この自然なワークフローは、一つの言語で書かれるアプリまたはフレームワーク・ターゲットをつくるのと同じくらい直接的に、混合言語のアプリとフレームワーク・ターゲットを作成することをもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This table describes the changes to <bpt i="0" x="0">&lt;e0&gt;</bpt>Using Swift with Cocoa and Objective-C<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>この表は<bpt i="0" x="0">&lt;e0&gt;</bpt>「CocoaとObjective-Cとともにスウィフトを使う」<ept i="0">&lt;/e0&gt;</ept>に対する変更点を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>This way, you can let the storyboard connect the outlets at runtime, after initialization.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そうして、あなたは、初期化の後で、実行時にストーリーボードをアウトレットたちに接続させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Throwing an Error</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>エラーをスローする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To avoid this, you can instead have the block capture a weak reference to <bpt i="2" x="2">&lt;c2&gt;</bpt>self<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これを避けるために、あなたは代わりにブロックが<bpt i="2" x="2">&lt;c2&gt;</bpt>self<ept i="2">&lt;/c2&gt;</ept>に対する弱い参照をキャプチャするようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To be accessible and usable in Objective-C, a Swift class must be a descendant of an Objective-C class or it must be marked <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでアクセス可能にされて利用可能にされるために、スウィフトクラスはObjective-Cクラスの子孫でなければなりません、あるいは、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept>で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To be accessible and usable in Objective-C, a Swift class must be a descendant of an Objective-C class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cでアクセス可能で利用可能であるために、スウィフトクラスはObjective-Cクラスの子孫でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To configure a Swift subclass of <bpt i="0" x="0">&lt;c0&gt;</bpt>NSManagedObject<ept i="0">&lt;/c0&gt;</ept> for use by a Core Data model entity, open the model entity inspector in Xcode, enter the class name into the Class field, and choose “Current Product Module” from the Module field drop-down list.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるコアデータ・エントリによって使うために<bpt i="0" x="0">&lt;c0&gt;</bpt>NSManagedObject<ept i="0">&lt;/c0&gt;</ept>のスウィフトサブクラスを構成するには、そのモデルのEntityインスペクタをXcodeにおいて開いて、クラス名をClass欄に入力して、「Current Product Module」をModule欄ポップダウンリストから選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To construct a selector for a property’s Objective-C getter or setter method, pass the property name prefixed by the <bpt i="3" x="3">&lt;c3&gt;</bpt>getter:<ept i="3">&lt;/c3&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt>setter:<ept i="4">&lt;/c4&gt;</ept> label, such as <bpt i="5" x="5">&lt;c5&gt;</bpt>#selector(getter: MyViewController.myButton)<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるプロパティの持つObjective-Cゲッターまたはセッターメソッドに対してセレクタを組み立てるには、<bpt i="3" x="3">&lt;c3&gt;</bpt>getter:<ept i="3">&lt;/c3&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt>setter:<ept i="4">&lt;/c4&gt;</ept>接頭辞を付けられたプロパティ名を渡してください、例えば<bpt i="5" x="5">&lt;c5&gt;</bpt>#selector(getter: MyViewController.myButton)<ept i="5">&lt;/c5&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To create a Swift class that inherits from an Objective-C class, add a colon (<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>) after the name of the Swift class, followed by the name of the Objective-C class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cクラスから継承するスウィフトクラスを作成するために、スウィフトクラスの名前の後にコロン（<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>）、それに続けてObjective-Cクラスの名前を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To create a Swift project in Xcode</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Xcodeにおいてスウィフトプロジェクトを作成します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To create a Swift protocol that can be adopted by an Objective-C class, mark the <bpt i="0" x="0">&lt;c0&gt;</bpt>protocol<ept i="0">&lt;/c0&gt;</ept> declaration with the <bpt i="1" x="1">&lt;c1&gt;</bpt>@objc<ept i="1">&lt;/c1&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cクラスによって採用されることができるスウィフトプロトコルを宣言するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>protocol<ept i="0">&lt;/c0&gt;</ept>宣言を<bpt i="1" x="1">&lt;c1&gt;</bpt>@objc<ept i="1">&lt;/c1&gt;</ept>属性で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To create a selector for a method that can be called from Objective-C, pass the name of the method, such as <bpt i="2" x="2">&lt;c2&gt;</bpt>#selector(MyViewController.tappedButton(_:))<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cから呼び出されることができるメソッドに対してセレクタを作成するには、そのメソッドの名前を渡してください、例えば<bpt i="2" x="2">&lt;c2&gt;</bpt>#selector(MyViewController.tappedButton(_:))<ept i="2">&lt;/c2&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To customize the name of an enumeration case, you can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept> macro, passing the Swift enumeration case name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>列挙ケース節の名前をカスタマイズするために、あなたはスウィフト列挙ケース節名を渡して、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept>マクロを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To declare a type that conforms to a single protocol in Swift code, use the protocol name directly as its type (as compared to <bpt i="0" x="0">&lt;c0&gt;</bpt>id&lt;SomeProtocol&gt;<ept i="0">&lt;/c0&gt;</ept> in Objective-C).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ただ１つのプロトコルに準拠する型をスウィフトコードにおいて定義するには、そのプロトコル名を直接にそれの型として使ってください（Objective-Cでの<bpt i="0" x="0">&lt;c0&gt;</bpt>id&lt;SomeProtocol&gt;<ept i="0">&lt;/c0&gt;</ept>になぞらえられる）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To declare a type that conforms to multiple protocols in Swift code, use a protocol composition, which takes the form <bpt i="1" x="1">&lt;c1&gt;</bpt>SomeProtocol &amp; AnotherProtocol<ept i="1">&lt;/c1&gt;</ept> (as compared to <bpt i="2" x="2">&lt;c2&gt;</bpt>id&lt;SomeProtocol, AnotherProtocol&gt;<ept i="2">&lt;/c2&gt;</ept> in Objective-C).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>複数のプロトコルに準拠する型をスウィフトコードにおいて定義するには、プロトコル合成物を使ってください、それは形式<bpt i="1" x="1">&lt;c1&gt;</bpt>SomeProtocol &amp; AnotherProtocol<ept i="1">&lt;/c1&gt;</ept>をとります（Objective-Cでの<bpt i="2" x="2">&lt;c2&gt;</bpt>id&lt;SomeProtocol, AnotherProtocol&gt;<ept i="2">&lt;/c2&gt;</ept>になぞらえられる）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To do this, change the Product Module Name build setting.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これをするために、「Product Module Name」ビルド設定を変更してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To ensure that your app can accommodate any differences in functionality, you check the availability those APIs.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのアプリが機能性でのどんな違いでも調整できることを確実にするために、あなたはそれらのAPIの有効性を確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To import Objective-C code into Swift from the same framework</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じフレームワークからスウィフトにObjective-Cコードをインポートするには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To import Objective-C code into Swift from the same target</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じターゲットからObjective-Cコードをスウィフトにインポートするには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To import Swift code into Objective-C from the same framework</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトコードを同じフレームワークからObjective-Cにインポートするには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To import Swift code into Objective-C from the same target</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>同じターゲットからObjective-Cにスウィフトコードをインポートするには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To import a set of Objective-C files in the same app target as your Swift code, you rely on an <bpt i="0" x="0">&lt;e0&gt;</bpt>Objective-C bridging header<ept i="0">&lt;/e0&gt;</ept> to expose those files to Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのスウィフトコードと同じアプリターゲットにひとそろいのObjective-Cファイルをインポートするために、あなたは<bpt i="0" x="0">&lt;e0&gt;</bpt>Objective-C橋渡しヘッダ<ept i="0">&lt;/e0&gt;</ept>を当てにしてそれらのファイルをスウィフトに露出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To import a set of Objective-C files in the same framework target as your Swift code, you’ll need to import those files into the Objective-C umbrella header for the framework.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとそろいのObjective-Cファイルをあなたのスウィフトコードと同じフレームワークターゲットにインポートするために、あなたはそれらのファイルをそのフレームワークのためのObjective-Cアンブレラヘッダにインポートする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To import a set of Swift files in the same framework target as your Objective-C code, you don’t need to import anything into the umbrella header for the framework.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ひとそろいのスウィフトファイルをあなたのObjective-Cコードと同じフレームワークターゲットにインポートするために、あなたはそのフレームワークのためのアンブレラヘッダに何もインポートする必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To inform the caller when initialization has failed, an Objective-C initializer can return <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>初期化が失敗した時に呼び出し側に報告するために、Objective-Cイニシャライザは<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To instantiate an Objective-C class in Swift, you call one of its initializers using Swift initializer syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cクラスをスウィフトにおいてインスタンス化するために、あなたはそれのイニシャライザのうちの１つをスウィフト初期化構文を使って呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To log a message to a specific subsystem, you can create a new <bpt i="0" x="0">&lt;c0&gt;</bpt>OSLog<ept i="0">&lt;/c0&gt;</ept> object, specifying the subsystem and category, and pass it as a parameter to the <bpt i="1" x="1">&lt;c1&gt;</bpt>os_log<ept i="1">&lt;/c1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある特定のサブシステムに対するメッセージをログするには、あなたは新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>OSLog<ept i="0">&lt;/c0&gt;</ept>オブジェクトを作成して、そのサブシステムとカテゴリを指定します、そしてそれをパラメータとして<bpt i="1" x="1">&lt;c1&gt;</bpt>os_log<ept i="1">&lt;/c1&gt;</ept>関数に渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make an Objective-C declaration unavailable at compile time in both Swift and Objective-C, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_UNAVAILABLE<ept i="0">&lt;/c0&gt;</ept> macro.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-C宣言をコンパイル時にSwiftとObjective-Cの両方で利用できなくするには、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_UNAVAILABLE<ept i="0">&lt;/c0&gt;</ept>マクロを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To make your Swift class accessible and usable back in Objective-C, make it a descendant of an Objective-C class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのスウィフトクラスをObjective-Cから逆にアクセス可能および使用可能にするために、それをObjective-Cクラスの子孫にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To prevent a strong reference cycle, you can specify <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> to be <bpt i="2" x="2">&lt;c2&gt;</bpt>unowned<ept i="2">&lt;/c2&gt;</ept> in a closure’s capture list:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>強い参照循環を防ぐために、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>unowned<ept i="2">&lt;/c2&gt;</ept>であるとクロージャのキャプチャリストにおいて指定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To prevent an Objective-C declaration from being imported by Swift, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_SWIFT_UNAVAILABLE<ept i="0">&lt;/c0&gt;</ept> macro, passing a message directing API consumers to any alternatives that may exist.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるObjective-C宣言がスウィフトによってインポートされるのを防止するために、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_SWIFT_UNAVAILABLE<ept i="0">&lt;/c0&gt;</ept>マクロを使って、API消費者に存在するであろう何らかの代替手段を指示するメッセージを渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To provide a refined Swift interface to C functionality, create an overlay by declaring new Swift functions that make the necessary C function calls in their implementation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>洗練されたスウィフトインターフェイスをCの機能性に提供するには、必要なC関数をそれの実装において呼び出すようにする新しいスウィフト関数を定義することによって、オーバーレイを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To provide your own implementations of the superclass’s methods, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのスーパークラスの持つメソッドのあなた独自の実装を提供するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>override<ept i="0">&lt;/c0&gt;</ept>修飾子を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To specify a particular name for the class to use in Objective-C, mark it with <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc(<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>name<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>)<ept i="2">&lt;/c2&gt;</ept>, where <bpt i="3" x="3">&lt;e3&gt;</bpt>name<ept i="3">&lt;/e3&gt;</ept> is the name that your Objective-C code uses to reference the Swift class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>クラスに対してObjective-Cで使うために特定の名前を指定するために、それを<bpt i="0" x="0">&lt;c0&gt;</bpt>@objc(<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>name<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>)<ept i="2">&lt;/c2&gt;</ept>で印してください、そこにおいて<bpt i="3" x="3">&lt;e3&gt;</bpt>name<ept i="3">&lt;/e3&gt;</ept>はあなたのObjective-Cコードがスウィフトクラスを参照するために使う名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To start experimenting with Cocoa app development using Swift, create a new Swift project from one of the provided Xcode templates.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトを使うCocoaアプリ開発の実験を始めるために、提供されるXcodeテンプレートの１つから新規スウィフトプロジェクトを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To start using the object, you use the <bpt i="1" x="1">&lt;c1&gt;</bpt>takeUnretainedValue()<ept i="1">&lt;/c1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>そのオブジェクトを使い始めるために、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>takeUnretainedValue()<ept i="1">&lt;/c1&gt;</ept>関数を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>To use outlets and actions in Swift, insert <bpt i="0" x="0">&lt;c0&gt;</bpt>@IBOutlet<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>@IBAction<ept i="1">&lt;/c1&gt;</ept> just before the property or method declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいてアウトレットとアクションを使うために、プロパティまたはメソッド宣言の直前に<bpt i="0" x="0">&lt;c0&gt;</bpt>@IBOutlet<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>@IBAction<ept i="1">&lt;/c1&gt;</ept>を書き込んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Top-level functions defined in Swift</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて定義されるトップレベル関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Treat your Swift and Objective-C files as the same collection of code, and watch out for naming collisions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのスウィフトとObjective-Cファイルを同じコードのコレクションとみなしてください、そして名前衝突に気をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Troubleshooting Tips and Reminders</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>問題解決の秘訣と注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Tuples</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>タプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typealiases defined in Swift</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトにおいて定義される型エイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types declared to be <bpt i="0" x="0">&lt;e0&gt;</bpt>nonnullable<ept i="0">&lt;/e0&gt;</ept>, either with a <bpt i="1" x="1">&lt;c1&gt;</bpt>_Nonnull<ept i="1">&lt;/c1&gt;</ept> annotation or in an audited region, are imported by Swift as a <bpt i="2" x="2">&lt;e2&gt;</bpt>nonoptional<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>非ヌル可能<ept i="0">&lt;/e0&gt;</ept>として定義された型、<bpt i="1" x="1">&lt;c1&gt;</bpt>_Nonnull<ept i="1">&lt;/c1&gt;</ept>注釈を使ってまたはある監査された領域の中の両方、は、スウィフトによって<bpt i="2" x="2">&lt;e2&gt;</bpt>非オプショナル<ept i="2">&lt;/e2&gt;</ept>としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types declared to be <bpt i="0" x="0">&lt;e0&gt;</bpt>nullable<ept i="0">&lt;/e0&gt;</ept> with a <bpt i="1" x="1">&lt;c1&gt;</bpt>_Nullable<ept i="1">&lt;/c1&gt;</ept> annotation, are imported by Swift as an <bpt i="2" x="2">&lt;e2&gt;</bpt>optional<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ヌル可能<ept i="0">&lt;/e0&gt;</ept>として<bpt i="1" x="1">&lt;c1&gt;</bpt>_Nullable<ept i="1">&lt;/c1&gt;</ept>注釈を使って定義された型は、スウィフトによって<bpt i="2" x="2">&lt;e2&gt;</bpt>オプショナル<ept i="2">&lt;/e2&gt;</ept>としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types declared without a nullability annotation are imported by Swift as an <bpt i="0" x="0">&lt;e0&gt;</bpt>implicitly unwrapped optional<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ヌル可能注釈を使わずに定義された型は、スウィフトによって<bpt i="0" x="0">&lt;e0&gt;</bpt>暗黙的にアンラップされるオプショナル<ept i="0">&lt;/e0&gt;</ept>としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types that are pointed to are not bridged.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ポインターで指される型は、橋渡しされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Types that can be converted between Objective-C and Swift are referred to as <bpt i="0" x="0">&lt;e0&gt;</bpt>bridged<ept i="0">&lt;/e0&gt;</ept> types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cとスウィフトの間で変換されることが可能な型は、<bpt i="0" x="0">&lt;e0&gt;</bpt>ブリッジ（橋渡しされる）<ept i="0">&lt;/e0&gt;</ept>型と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Typically, you don’t need to create your own autorelease pool blocks, but there are some situations in which either you must—such as when spawning a secondary thread—or it is beneficial to do so—such as when writing a loop that creates many temporary objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>概して、あなたはあなた独自のオートリリース・ブロックを作成する必要はありません、しかしいくつかの状況があり、そこにおいては、あなたが必要とする—例えば副次的スレッドを生み出す時など—もしくはそうすることが利益をもたらす—例えば多くの一時的オブジェクトを作成するあるループを書く時など—のいずれかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Under Build Settings, in Packaging, make sure the Defines Module setting for that framework target is set to “Yes”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「Build Settings」において、「Packaging」の中で、そのフレームワークターゲットのための「Defines Module」設定が「Yes」に設定されることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Understanding the Swift Import Process</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのインポートプロセスを理解する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Undo</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>取り消し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unified Logging</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>統合ログ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unified logging is available in iOS 10.0 and later, macOS 10.12 and later, tvOS 10.0 and later, and watchOS 3.0 and later.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>統合ログは、iOS 10.0以降、macOS 10.12以降、tvOS 10.0以降、そしてwatchOS 3.0以降で利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>共用体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike Objective-C, where all classes are part of a global namespace–and must not have the same name–Swift classes can be disambiguated based on the module they reside in.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cとは違い、全てのクラスがグローバルな名前空間の一部である ― それゆえ同じ名前を持ってはならない ― ところで、スウィフトクラスは、それらが属するモジュールに基づいて違いを明らかにされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unlike key paths created using key-path expressions, key paths created using the <bpt i="6" x="6">&lt;c6&gt;</bpt>#keyPath<ept i="6">&lt;/c6&gt;</ept> string expression don’t pass type information about the properties or methods they reference to the APIs that accept key paths.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>キーパス式を使って作成されるキーパスと違い、<bpt i="6" x="6">&lt;c6&gt;</bpt>#keyPath<ept i="6">&lt;/c6&gt;</ept>文字列式を使って作成されるキーパスは、それらが参照するプロパティやメソッドについての型情報をキーパスを受け入れるAPIへ伝えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unmanaged Objects</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>管理されないオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unnamed Structure and Union Fields</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無名の構造体と共用体フィールド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unnamed fields consist of a nested <bpt i="2" x="2">&lt;c2&gt;</bpt>struct<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>union<ept i="3">&lt;/c3&gt;</ept> type with named fields.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>無名フィールドは、入れ子にされた<bpt i="2" x="2">&lt;c2&gt;</bpt>struct<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>union<ept i="3">&lt;/c3&gt;</ept>で名前付きフィールドを持つものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unrecognized Selectors and Optional Chaining</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>識別不能セレクタとオプショナル連鎖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Unsafe Invocation of Objective-C Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cメソッドの安全でない発動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Update import statements in your Objective-C code (to <bpt i="0" x="0">&lt;c0&gt;</bpt>#import "ProductModuleName-Swift.h"<ept i="0">&lt;/c0&gt;</ept>), as described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Importing Code from Within the Same App Target<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのObjective-Cコードにおいてインポート文を更新してください（<bpt i="0" x="0">&lt;c0&gt;</bpt>#import "ProductModuleName-Swift.h"<ept i="0">&lt;/c0&gt;</ept>へと）、<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>コードを同じアプリターゲットからインポートする<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Update your code to use the Swift class name instead of the Objective-C name if you gave the Swift class a different name.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがスウィフトクラスに異なる名前を与えるならば、Objective-C名でなくてスウィフトクラス名を使用するようにあなたのコードを更新してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Constant Pointers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about bridging Swift <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> values to C pointers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>章<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>定数ポインター<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>をスウィフトの<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>値からCポインターへの橋渡しについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated an example in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Key-Value Observing<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to use <bpt i="2" x="2">&lt;c2&gt;</bpt>#keyPath<ept i="2">&lt;/c2&gt;</ept> instead of string literals.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>キー値監視<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節の例を更新して、<bpt i="2" x="2">&lt;c2&gt;</bpt>#keyPath<ept i="2">&lt;/c2&gt;</ept>を文字列リテラルの代わりに使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated and expanded the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Swift Type Compatibility<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section in the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Interacting with Objective-C APIs<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>スウィフト型互換性<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>C APIとの相互作用<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>章において更新および拡張した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated and expanded the Bridging Collections section in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Working with Cocoa Frameworks<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ブリッジコレクション節を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ココアフレームワークを扱う<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>章において更新および拡張した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 1.1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 1.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 1.2.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 1.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 2.0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 2.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 2.1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 2.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 2.2.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 2.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 3.0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 3.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 3.0.1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 3.0.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 3.1.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 3.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated for Swift 4.0.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Swift 4.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated screenshots of Xcode user interface.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Xcodeユーザインターフェイスのスクリーンショットを更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;c0&gt;</bpt>CFArrayCreateMutable<ept i="0">&lt;/c0&gt;</ept> code sample in the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Function Pointers<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>CFArrayCreateMutable<ept i="0">&lt;/c0&gt;</ept>コードサンプルを<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>関数ポインター<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>節において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>API Availability<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section and the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Conditional Compilation Blocks<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> section with information about tvOS.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>API有効性<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>条件コンパイルブロック<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>節をtvOSについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Accessing Properties<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with additional information about how Objective-C property attributes are imported by Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロパティにアクセスする<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節をどのようにObjective-Cプロパティ属性がスウィフトによってインポートされるかについての追加情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Adopting Protocols<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to describe how to constrain the type of a variable or constant to multiple protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコルを採用する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を更新して、どのように変数や定数の型に対して複数のプロトコルの制約を加えるかについて記述した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Conditional Compilation Blocks<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about the <bpt i="2" x="2">&lt;c2&gt;</bpt>swift<ept i="2">&lt;/c2&gt;</ept> build configuration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>条件コンパイルブロック<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を<bpt i="2" x="2">&lt;c2&gt;</bpt>swift<ept i="2">&lt;/c2&gt;</ept>ビルド構成についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Configuring Swift Interfaces in Objective-C<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about the <bpt i="2" x="2">&lt;c2&gt;</bpt>@nonobjc<ept i="2">&lt;/c2&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>スウィフトインターフェイスをObjective-Cにおいて構成する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>@nonobjc<ept i="2">&lt;/c2&gt;</ept>属性についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Configuring Swift Interfaces in Objective-C<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about using the <bpt i="2" x="2">&lt;c2&gt;</bpt>@objc(<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;e3&gt;</bpt>name<ept i="3">&lt;/e3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>)<ept i="4">&lt;/c4&gt;</ept> attribute with Swift enumerations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>スウィフトインターフェイスをObjective-Cにおいて構成する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節をスウィフト列挙とともに<bpt i="2" x="2">&lt;c2&gt;</bpt>@objc(<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;e3&gt;</bpt>name<ept i="3">&lt;/e3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>)<ept i="4">&lt;/c4&gt;</ept>属性を使用することについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Configuring Swift Interfaces in Objective-C<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about using the <bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept> attribute for Swift enumerations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>スウィフトインターフェイスをObjective-Cにおいて構成する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節をスウィフト列挙に<bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept>属性を使うことについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Data Type Size Calculation<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about the <bpt i="2" x="2">&lt;c2&gt;</bpt>MemoryLayout<ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>データ型サイズ計算<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を更新して、<bpt i="2" x="2">&lt;c2&gt;</bpt>MemoryLayout<ept i="2">&lt;/c2&gt;</ept>型についての情報を含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Enumerations<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about how C enumerations not marked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>NS_ENUM<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>NS_OPTIONS<ept i="3">&lt;/c3&gt;</ept> macro are imported by Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>列挙<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を、どのように<bpt i="2" x="2">&lt;c2&gt;</bpt>NS_ENUM<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>NS_OPTIONS<ept i="3">&lt;/c3&gt;</ept>マクロで印されないC列挙がスウィフトによってインポートされるかについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Error Handling<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to reflect that Swift removes the <bpt i="2" x="2">&lt;c2&gt;</bpt>WithError<ept i="2">&lt;/c2&gt;</ept> suffix from the selector of an error-producing Objective-C method, when that method is imported as a Swift method that throws.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>エラーの処理<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を更新して、「エラーを生じる」Objective-Cメソッドのセレクタから、そのメソッドがスローするスウィフトメソッドとしてインポートされる時に、スウィフトが<bpt i="2" x="2">&lt;c2&gt;</bpt>WithError<ept i="2">&lt;/c2&gt;</ept>接尾辞を取り除いたことを反映した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Error Handling<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about the <bpt i="2" x="2">&lt;c2&gt;</bpt>NS_ERROR_RESULT<ept i="2">&lt;/c2&gt;</ept> Objective-C macro.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>エラーの処理<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を<bpt i="2" x="2">&lt;c2&gt;</bpt>NS_ERROR_RESULT<ept i="2">&lt;/c2&gt;</ept> Objective-Cマクロについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Failable Initialization<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about nullability annotations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>失敗できる初期化<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>をヌル許可注釈についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Function Pointers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about bridging Swift function and closure values with C function pointers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>関数ポインター<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の章をスウィフト関数やクロージャとC関数ポインタとの橋渡しについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Hashing<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about the <bpt i="2" x="2">&lt;c2&gt;</bpt>AnyHashable<ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ハッシュ化<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を更新して、<bpt i="2" x="2">&lt;c2&gt;</bpt>AnyHashable<ept i="2">&lt;/c2&gt;</ept>型についての情報を含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Interacting with Objective-C APIs<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter with information about how Swift imports Objective-C <bpt i="2" x="2">&lt;c2&gt;</bpt>id<ept i="2">&lt;/c2&gt;</ept> types as <bpt i="3" x="3">&lt;c3&gt;</bpt>Any<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Objective-C APIとの相互作用<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の章を更新して、どのようにスウィフトがObjective-C <bpt i="2" x="2">&lt;c2&gt;</bpt>id<ept i="2">&lt;/c2&gt;</ept>型を<bpt i="3" x="3">&lt;c3&gt;</bpt>Any<ept i="3">&lt;/c3&gt;</ept>としてインポートするかの情報を含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Object Comparison<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Hashing<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> section in the <bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Interacting with Objective-C APIs<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>オブジェクト比較<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>ハッシュ化<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>節を<bpt i="4" x="4">&lt;s4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>C APIとの相互作用<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/s4&gt;</ept>章において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Pointers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to reflect that <bpt i="2" x="2">&lt;c2&gt;</bpt>CMutablePointer<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>CMutableVoidPointer<ept i="3">&lt;/c3&gt;</ept> have been replaced with <bpt i="4" x="4">&lt;c4&gt;</bpt>UnsafePointer<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>CConstPointer<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>CConstVoidPointer<ept i="6">&lt;/c6&gt;</ept> have been replaced with <bpt i="7" x="7">&lt;c7&gt;</bpt>ConstUnsafePointer<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ポインター<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を更新して、<bpt i="2" x="2">&lt;c2&gt;</bpt>CMutablePointer<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>CMutableVoidPointer<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>UnsafePointer<ept i="4">&lt;/c4&gt;</ept>と置き換えられ、<bpt i="5" x="5">&lt;c5&gt;</bpt>CConstPointer<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>CConstVoidPointer<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>ConstUnsafePointer<ept i="7">&lt;/c7&gt;</ept>と置き換えられたことを反映するようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Pointers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to reflect that <bpt i="2" x="2">&lt;c2&gt;</bpt>UnsafePointer<ept i="2">&lt;/c2&gt;</ept> has been replaced with <bpt i="3" x="3">&lt;c3&gt;</bpt>UnsafeMutablePointer<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>ConstUnsafePointer<ept i="4">&lt;/c4&gt;</ept> has been replaced with <bpt i="5" x="5">&lt;c5&gt;</bpt>UnsafePointer<ept i="5">&lt;/c5&gt;</ept>, and <bpt i="6" x="6">&lt;c6&gt;</bpt>AutoreleasingUnsafePointer<ept i="6">&lt;/c6&gt;</ept> has been replaced with <bpt i="7" x="7">&lt;c7&gt;</bpt>AutoreleasingUnsafeMutablePointer<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>節<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ポインター<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を更新して、<bpt i="2" x="2">&lt;c2&gt;</bpt>UnsafePointer<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>UnsafeMutablePointer<ept i="3">&lt;/c3&gt;</ept>と置き換えられ、<bpt i="4" x="4">&lt;c4&gt;</bpt>ConstUnsafePointer<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>UnsafePointer<ept i="5">&lt;/c5&gt;</ept>と置き換えられ、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>AutoreleasingUnsafePointer<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>AutoreleasingUnsafeMutablePointer<ept i="7">&lt;/c7&gt;</ept>と置き換えられることを反映するようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Pointers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about the <bpt i="2" x="2">&lt;c2&gt;</bpt>UnsafeRawPointer<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>UnsafeMutableRawPointer<ept i="3">&lt;/c3&gt;</ept> types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ポインター<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節を更新して、<bpt i="2" x="2">&lt;c2&gt;</bpt>UnsafeRawPointer<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>UnsafeMutableRawPointer<ept i="3">&lt;/c3&gt;</ept>型の情報を含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Pointers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about the duration of pointers passed to <bpt i="2" x="2">&lt;c2&gt;</bpt>inout<ept i="2">&lt;/c2&gt;</ept> parameters.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ポインター<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節を<bpt i="2" x="2">&lt;c2&gt;</bpt>inout<ept i="2">&lt;/c2&gt;</ept>パラメータに渡されたポインタの継続期間についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Selectors<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about the Swift <bpt i="2" x="2">&lt;c2&gt;</bpt>#selector<ept i="2">&lt;/c2&gt;</ept> expression.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>セレクタ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節をスウィフトの<bpt i="2" x="2">&lt;c2&gt;</bpt>#selector<ept i="2">&lt;/c2&gt;</ept>式についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Setting Up Your Swift Environment<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section with information about base SDK requirements for Swift apps.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>あなたのスウィフト環境を設定する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>節をスウィフトアプリに対する基盤SDK要件についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Swift Type Compatibility<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Configuring Swift Interfaces in Objective-C<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> sections now that the <bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept> attribute can only be applied to classes that descend from <bpt i="5" x="5">&lt;c5&gt;</bpt>NSObject<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>スウィフト型互換性<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>スウィフトインターフェイスをObjective-Cにおいて構成する<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>節を更新した、今では<bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept>属性はただ<bpt i="5" x="5">&lt;c5&gt;</bpt>NSObject<ept i="5">&lt;/c5&gt;</ept>の系統を引くクラスにだけ適用されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Swift and Objective-C in the Same Project<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter with information about access control in mixed-language targets.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>章<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>同じプロジェクト内のスウィフトとObjective-C<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を混合言語ターゲットでのアクセス制御ついての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Swift and Objective-C in the Same Project<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter with information about the <bpt i="2" x="2">&lt;c2&gt;</bpt>@testable<ept i="2">&lt;/c2&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>同じプロジェクト中のスウィフトとObjective-C<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の章を<bpt i="2" x="2">&lt;c2&gt;</bpt>@testable<ept i="2">&lt;/c2&gt;</ept>属性についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Swift and Objective-C in the Same Project<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter with information about the <bpt i="2" x="2">&lt;c2&gt;</bpt>open<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>fileprivate<ept i="3">&lt;/c3&gt;</ept> access modifiers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>同じプロジェクト中のスウィフトとObjective-C<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の章を更新して、<bpt i="2" x="2">&lt;c2&gt;</bpt>open<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>fileprivate<ept i="3">&lt;/c3&gt;</ept>アクセス修飾子についての情報を含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Working with Cocoa Frameworks<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter to use the <bpt i="2" x="2">&lt;c2&gt;</bpt>as!<ept i="2">&lt;/c2&gt;</ept> operator and bridging semantics in Swift 1.2.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>章<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>ココアフレームワークを扱う<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>as!<ept i="2">&lt;/c2&gt;</ept>演算子の利用とスウィフト 1.2における意味論との溝を埋めるために更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the Bridging Collections section to discuss Swift bridging of parameterized Objective-C collection classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>「ブリッジコレクション」節をパラメーター化されたObjective-Cコレクションクラスのスウィフト橋渡しについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the Core Data section to include directions to configure the managed object model.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>コアデータの節を更新してオブジェクトモデル管理のための指針を含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Processing Command-Line Arguments<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, now that <bpt i="2" x="2">&lt;c2&gt;</bpt>Process<ept i="2">&lt;/c2&gt;</ept> has been renamed to <bpt i="3" x="3">&lt;c3&gt;</bpt>CommandLine<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>コマンドライン引数の処理<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>での議論を更新した、今では<bpt i="2" x="2">&lt;c2&gt;</bpt>Process<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>CommandLine<ept i="3">&lt;/c3&gt;</ept>と改名されてしまっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Numbers<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section of the <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Working with Cocoa Frameworks<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> chapter, now that <bpt i="4" x="4">&lt;c4&gt;</bpt>as?<ept i="4">&lt;/c4&gt;</ept> casts fail when attempting to convert an <bpt i="5" x="5">&lt;c5&gt;</bpt>NSNumber<ept i="5">&lt;/c5&gt;</ept> to a numeric type that isn’t large enough to fit the entire number.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>数<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節での議論を<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Cocoaフレームワークを扱う<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の章で更新した、今では<bpt i="4" x="4">&lt;c4&gt;</bpt>as?<ept i="4">&lt;/c4&gt;</ept>キャストは<bpt i="5" x="5">&lt;c5&gt;</bpt>NSNumber<ept i="5">&lt;/c5&gt;</ept>をその数全体をはめ込むには十分に大きくない数値型に変換する場合に失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Protocol-Qualified Classes<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section now that classes are imported as part of protocol compositions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>プロトコル適格クラス<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節での議論を更新した、今ではクラスはプロトコル合成の一部としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Requiring Dynamic Dispatch<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Inheriting from Objective-C Classes<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> sections, now that the <bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept> attribute is inferred in fewer contexts.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>動的なディスパッチを要求する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Objective-Cクラスから継承する<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の節での議論を更新した、今では<bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept>属性はより新しい文脈において継承されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Requiring Dynamic Dispatch<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to include <bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>dynamic<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>動的なディスパッチを要求する<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節での議論を更新して<bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>dynamic<ept i="3">&lt;/c3&gt;</ept>を含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Serialization<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section to include the new encoders and decoders for JSON and property list data.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>シリアライズ<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節での議論を更新して、新しいJSONおよびプロパティリストデータのためのエンコーダとデコーダを含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Unions<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> and <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Unnamed Structure and Union Fields<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> sections, now that unnamed fields from C structures and unions are always imported.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>共用体<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>と<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>無名構造体と共用体フィールド<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>の節での議論を更新した、今ではC構造体と共用体からの無名フィールドは常にインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the discussion of the <bpt i="0" x="0">&lt;c0&gt;</bpt>@NSManaged<ept i="0">&lt;/c0&gt;</ept> attribute in the <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Implementing Core Data Managed Object Subclasses<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept> section, now that the attribute can be applied to certain instance methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@NSManaged<ept i="0">&lt;/c0&gt;</ept>属性の説明を<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>コアデータ管理オブジェクトのサブクラスを実装する<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>の節において更新した、今ではこの属性は特定のインスタンスメソッドに適用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the example in the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Key-Value Observing<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> section, now that the key-value observing APIs accept key-path expressions.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>キー値監視<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の節での例を更新した、今ではキー値監視APIはキーパス式を受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Updated the introductions of the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Interacting with Objective-C APIs<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> chapter.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>導入部を<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Objective-C APIとの相互作用<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>章において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="3" x="3">&lt;c3&gt;</bpt>NS_TYPED_ENUM<ept i="3">&lt;/c3&gt;</ept> for sets of values that can’t logically have additional values added by code in adopting modules.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>採用しているモジュールの中のコードによって追加的な値を加えられることが論理的に不可能な値の集合に対して、<bpt i="3" x="3">&lt;c3&gt;</bpt>NS_TYPED_ENUM<ept i="3">&lt;/c3&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use <bpt i="4" x="4">&lt;c4&gt;</bpt>NS_TYPED_EXTENSIBLE_ENUM<ept i="4">&lt;/c4&gt;</ept> for sets of values which may be expanded in a Swift extension.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるスウィフト拡張において拡張されるかもしれない値の集合に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt>NS_TYPED_EXTENSIBLE_ENUM<ept i="4">&lt;/c4&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc(<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>name<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>)<ept i="2">&lt;/c2&gt;</ept> attribute to provide Objective-C names for properties and methods when necessary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@objc(<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>name<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>)<ept i="2">&lt;/c2&gt;</ept>属性をObjective-C名をプロパティとメソッドに必要に応じて用意するために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_SWIFT_NOTHROW<ept i="0">&lt;/c0&gt;</ept> macro on an Objective-C method declaration that produces an <bpt i="1" x="1">&lt;c1&gt;</bpt>NSError<ept i="1">&lt;/c1&gt;</ept> to prevent it from being imported by Swift as a method that throws.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS_SWIFT_NOTHROW<ept i="0">&lt;/c0&gt;</ept>マクロを<bpt i="1" x="1">&lt;c1&gt;</bpt>NSError<ept i="1">&lt;/c1&gt;</ept>を生み出すObjective-Cメソッド宣言上で使って、それがスウィフトによってスローするメソッドとしてインポートされるのを防止してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>weak<ept i="0">&lt;/c0&gt;</ept> keyword to indicate that a property has a weak reference to the object stored as its value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>weak<ept i="0">&lt;/c0&gt;</ept>キーワードを使用して、あるプロパティがその値として保存しておくオブジェクトへの弱い参照を持つことを示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use these tools to explore Swift’s extensive functionality and integrate it back into your existing Objective-C app without having to rewrite the entire app in Swift at once.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>これらのツールを使用して、スウィフトの広大な機能性を調査して、いっぺんにスウィフトでアプリ全体を書き直ししなくとも、それをあなたの既存のObjective-Cアプリに逆に組み込んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Use your custom Objective-C code with the same Swift syntax you use with system classes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのあつらえのObjective-Cコードを、あなたがシステム・クラスで使うのと同じスウィフト構文で使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using Swift Class Names with Objective-C APIs</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトクラス名をObjective-C APIで使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using Swift from Objective-C</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトをObjective-Cから使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Using mix and match, you can implement part of your app’s functionality using the latest Swift features and seamlessly incorporate it back into your existing Objective-C codebase.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>混合と適合を使って、あなたは最新のスウィフト特徴を使ってあなたのアプリの機能性の一部を実施して、継ぎ目なくそれをあなたの既存のObjective-Cコードベースにさかのぼって組み込むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Valid arguments</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>有効な引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Variadic Functions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可変長引数関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When <bpt i="3" x="3">&lt;c3&gt;</bpt>id<ept i="3">&lt;/c3&gt;</ept> values are imported into Swift as <bpt i="4" x="4">&lt;c4&gt;</bpt>Any<ept i="4">&lt;/c4&gt;</ept>, the runtime automatically handles bridging back to either class references or Swift value types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>id<ept i="3">&lt;/c3&gt;</ept>値がスウィフトへ<bpt i="4" x="4">&lt;c4&gt;</bpt>Any<ept i="4">&lt;/c4&gt;</ept>としてインポートされる時、ランタイムは自動的にクラス参照またはスウィフト値型のどちらかへ戻すブリッジを取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When Objective-C methods are imported into Swift, the first part of the Objective-C selector becomes the base method name and appears before the parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cメソッドがスウィフトにインポートされるとき、Objective-Cセレクタの最初の部分は、基盤となるメソッド名になって、丸括弧の前に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When Swift imports APIs that have not been annotated, the compiler cannot automatically memory manage the returned Core Foundation objects.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>注釈をつけられなかったAPIをスウィフトがインポートするとき、コンパイラは返されたコアファウンデーション・オブジェクトを自動的にメモリ管理できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When Swift imports Core Foundation types, the compiler remaps the names of these types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトがコアファウンデーション型をインポートするとき、コンパイラはこれらの型の名前をリマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a Swift class introduces many new methods or properties that require behavior from the Objective-C runtime, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>@objcMembers<ept i="0">&lt;/c0&gt;</ept> attribute in the declaration of that class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるスウィフトクラスがObjective-Cランタイムからの挙動を要求する多くの新しいメソッドまたはプロパティを導入するならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>@objcMembers<ept i="0">&lt;/c0&gt;</ept>属性をそのクラスの宣言において使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a Swift initializer, property, subscript, or method is used to satisfy a requirement of an Objective-C protocol, the compiler automatically infers the name to match the requirement, similar to what is done for overridden methods.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのイニシャライザ、プロパティ、添え字、またはメソッドがObjective-Cプロトコルのある要件を満たすために使われる場合、コンパイラは自動的にその要件と適合する名前を推論します、オーバーライドされたメソッドに対して行われることと同じように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a function is declared as taking an <bpt i="0" x="0">&lt;c0&gt;</bpt>AutoreleasingUnsafeMutablePointer&lt;Type&gt;<ept i="0">&lt;/c0&gt;</ept>, it can accept any of the following:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある関数が<bpt i="0" x="0">&lt;c0&gt;</bpt>AutoreleasingUnsafeMutablePointer&lt;Type&gt;<ept i="0">&lt;/c0&gt;</ept>を取るとして宣言されるとき、それは以下の何でも受け入れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a function is declared as taking an <bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafeMutablePointer&lt;Type&gt;<ept i="0">&lt;/c0&gt;</ept> argument, it can accept any of the following:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある関数が<bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafeMutablePointer&lt;Type&gt;<ept i="0">&lt;/c0&gt;</ept>引数を取るとして宣言されるとき、それは以下の何でも受け入れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a function is declared as taking an <bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafeMutableRawPointer<ept i="0">&lt;/c0&gt;</ept> argument, it can accept the same operands as <bpt i="1" x="1">&lt;c1&gt;</bpt>UnsafeMutablePointer&lt;Type&gt;<ept i="1">&lt;/c1&gt;</ept> for any type <bpt i="2" x="2">&lt;c2&gt;</bpt>Type<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある関数が<bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafeMutableRawPointer<ept i="0">&lt;/c0&gt;</ept>引数を取るとして宣言されるとき、それは何らかの型<bpt i="1" x="1">&lt;c1&gt;</bpt>Type<ept i="1">&lt;/c1&gt;</ept>に対する<bpt i="2" x="2">&lt;c2&gt;</bpt>UnsafeMutablePointer&lt;Type&gt;<ept i="2">&lt;/c2&gt;</ept>と同じ演算数を受け入れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a function is declared as taking an <bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafePointer&lt;Type&gt;<ept i="0">&lt;/c0&gt;</ept> argument, it can accept any of the following:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある関数が<bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafePointer&lt;Type&gt;<ept i="0">&lt;/c0&gt;</ept>引数を取るとして宣言されるとき、それは以下の何でも受け入れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When a function is declared as taking an <bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafeRawPointer<ept i="0">&lt;/c0&gt;</ept> argument, it can accept the same operands as <bpt i="1" x="1">&lt;c1&gt;</bpt>UnsafePointer&lt;Type&gt;<ept i="1">&lt;/c1&gt;</ept> for any type <bpt i="2" x="2">&lt;c2&gt;</bpt>Type<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある関数が<bpt i="0" x="0">&lt;c0&gt;</bpt>UnsafeRawPointer<ept i="0">&lt;/c0&gt;</ept>引数を取るとして宣言されるとき、それは何らかの型<bpt i="2" x="2">&lt;c2&gt;</bpt>Type<ept i="2">&lt;/c2&gt;</ept>に対する<bpt i="1" x="1">&lt;c1&gt;</bpt>UnsafePointer&lt;Type&gt;<ept i="1">&lt;/c1&gt;</ept>と同じ演算数を受け入れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When accessing a computed property corresponding to a bit field, Swift automatically converts the value to and from compatible Swift types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるビットフィールドに対応している計算プロパティにアクセスするとき、スウィフトはその値を自動的に互換性のあるスウィフト型へと、またはそれから、変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When an Objective-C initializer is imported by Swift, the <bpt i="2" x="2">&lt;c2&gt;</bpt>init<ept i="2">&lt;/c2&gt;</ept> prefix becomes an <bpt i="3" x="3">&lt;c3&gt;</bpt>init<ept i="3">&lt;/c3&gt;</ept> keyword to indicate that the method is a Swift initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Objective-Cイニシャライザがスウィフトによってインポートされる時、<bpt i="2" x="2">&lt;c2&gt;</bpt>init<ept i="2">&lt;/c2&gt;</ept>接頭辞は<bpt i="3" x="3">&lt;c3&gt;</bpt>init<ept i="3">&lt;/c3&gt;</ept>キーワードになって、そのメソッドがスウィフトイニシャライザであることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When calling a function that takes a function pointer argument, you can pass a top-level Swift function, a closure literal, or <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>関数ポインタ引数を取る関数を呼び出しているとき、あなたはトップレベルスウィフト関数、クロージャリテラル、または<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When declaring a computed property, provide a getter only to make it read-only and provide both a getter and setter to make it read/write.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある計算プロパティを宣言するとき、それを読み出し専用にするためにゲッターのみを提供してください、そしてそれを読み／書きにするためにゲッターとセッターの両方を提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When declaring a stored property, use <bpt i="2" x="2">&lt;c2&gt;</bpt>let<ept i="2">&lt;/c2&gt;</ept> to make it read-only, and use <bpt i="3" x="3">&lt;c3&gt;</bpt>var<ept i="3">&lt;/c3&gt;</ept> to make it read/write.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ある保存プロパティを宣言するとき、それを読み出し専用にするために<bpt i="2" x="2">&lt;c2&gt;</bpt>let<ept i="2">&lt;/c2&gt;</ept>を、そしてそれを読み／書きにするために<bpt i="3" x="3">&lt;c3&gt;</bpt>var<ept i="3">&lt;/c3&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When importing C enumeration marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_OPTIONS<ept i="0">&lt;/c0&gt;</ept> macro, Swift marks any members that have a value of <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept> as unavailable, because Swift uses an empty option set to specify no options.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS_OPTIONS<ept i="0">&lt;/c0&gt;</ept>マクロで印されたC列挙をインポートするとき、スウィフトは<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>の値を持つメンバはなんであれ利用不可として印します、なぜならスウィフトは空のオプションセットをオプション無しを指定するために使うからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When importing these types, Swift moves them to be nested types of their related types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>それらの型をインポートするとき、スウィフトはそれらを移動して、それらの関連型の入れ子にされた型にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When overriding this method in a Swift subclass of <bpt i="3" x="3">&lt;c3&gt;</bpt>NSDocument<ept i="3">&lt;/c3&gt;</ept>, the method replaces its error parameter and throws instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このメソッドを<bpt i="3" x="3">&lt;c3&gt;</bpt>NSDocument<ept i="3">&lt;/c3&gt;</ept>のスウィフトのサブクラスにおいてオーバーライドする時、メソッドはそれのエラーパラメーターを置き替えて、代わりにスローをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When working with objects of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept> where the underlying type is known or could be reasonably determined, it is often useful to downcast those objects to a more specific type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>基礎をなす型が知られているかまずまず判定されることができるところの型<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept>のオブジェクトを扱う時、そのようなオブジェクトをもっとはっきりした型へダウンキャストするのはしばしば便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When working with opaque data types, you may need to perform unsafe pointer operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>不透明データ型を扱うとき、あなたは非安全ポインタ演算を行う必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When writing Swift code that incorporates Cocoa frameworks, remember that certain types are bridged, which means you can work with Swift types in place of Objective-C types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>ココア・フレームワークを取り入れるスウィフトコードを書くとき、特定の型が橋渡しをされるのを思い出してください、それはあなたがスウィフト型をObjective-C型の代わりに扱うことができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you are working with an Objective-C class or your Swift class inherits from an Objective-C class, Swift calls your class’s superclass <bpt i="1" x="1">&lt;c1&gt;</bpt>dealloc<ept i="1">&lt;/c1&gt;</ept> method for you as well.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがObjective-CクラスまたはObjective-Cクラスから継承するあなたのスウィフトクラスを扱ってとき、スウィフトはあなたのクラスのスーパークラスの<bpt i="1" x="1">&lt;c1&gt;</bpt>dealloc<ept i="1">&lt;/c1&gt;</ept>メソッドもまたあなたの代わりに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you bridge from an <bpt i="2" x="2">&lt;c2&gt;</bpt>NSArray<ept i="2">&lt;/c2&gt;</ept> object with a parameterized type to a Swift array, the element type of the resulting array is bridged as well.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあるパラメーター化された型を使う<bpt i="2" x="2">&lt;c2&gt;</bpt>NSArray<ept i="2">&lt;/c2&gt;</ept>オブジェクトからスウィフト配列へとブリッジするとき、結果として生じる配列の要素型も同様にブリッジされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you bridge from an <bpt i="2" x="2">&lt;c2&gt;</bpt>NSDictionary<ept i="2">&lt;/c2&gt;</ept> object with parameterized types to a Swift dictionary, the resulting dictionary is of type <bpt i="3" x="3">&lt;c3&gt;</bpt>[Key: Value]<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがパラメーター化された型たちを使うある<bpt i="2" x="2">&lt;c2&gt;</bpt>NSDictionary<ept i="2">&lt;/c2&gt;</ept>オブジェクトからスウィフト辞書へ橋渡しするとき、結果として得られる辞書は型<bpt i="3" x="3">&lt;c3&gt;</bpt>[Key: Value]<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you bridge from an <bpt i="2" x="2">&lt;c2&gt;</bpt>NSSet<ept i="2">&lt;/c2&gt;</ept> object with a parameterized type to a Swift set, the resulting set is of type <bpt i="3" x="3">&lt;c3&gt;</bpt>Set&lt;ObjectType&gt;<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがあるパラメーター化された型を使う<bpt i="2" x="2">&lt;c2&gt;</bpt>NSSet<ept i="2">&lt;/c2&gt;</ept>オブジェクトからスウィフト集合へ橋渡しするとき、結果として生じる集合は型<bpt i="3" x="3">&lt;c3&gt;</bpt>Set&lt;ObjectType&gt;<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you bring Swift code into Objective-C, remember that Objective-C won’t be able to translate certain features that are specific to Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがObjective-Cにスウィフトコードを連れて来るとき、Objective-Cがスウィフトに特有である特定の特徴を翻訳することができないのを思い出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you call a method on a value of <bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept> type, that method call behaves like an implicitly unwrapped optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>AnyObject<ept i="0">&lt;/c0&gt;</ept>型の値上でメソッドを呼ぶとき、そのメソッド呼び出しは暗黙的にアンラップされるオプショナルのように振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you create a Swift class that descends from an Objective-C class, the class and its members—properties, methods, subscripts, and initializers—that are compatible with Objective-C are automatically available from Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがObjective-Cクラス由来のスウィフトクラスを作成するとき、そのクラスおよびObjective-C互換のそれのメンバー ― プロパティ、メソッド、添え字、そしてイニシャライザ ― は、自動的にObjective-Cから利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you create a custom view that inherits from the <bpt i="2" x="2">&lt;c2&gt;</bpt>UIView<ept i="2">&lt;/c2&gt;</ept> class or the <bpt i="3" x="3">&lt;c3&gt;</bpt>NSView<ept i="3">&lt;/c3&gt;</ept> class, you can add the <bpt i="4" x="4">&lt;c4&gt;</bpt>@IBDesignable<ept i="4">&lt;/c4&gt;</ept> attribute just before the class declaration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="2" x="2">&lt;c2&gt;</bpt>UIView<ept i="2">&lt;/c2&gt;</ept>クラスまたは<bpt i="3" x="3">&lt;c3&gt;</bpt>NSView<ept i="3">&lt;/c3&gt;</ept>クラスから継承するカスタムメイドのビューをつくるとき、あなたは<bpt i="4" x="4">&lt;c4&gt;</bpt>@IBDesignable<ept i="4">&lt;/c4&gt;</ept>属性をクラス宣言の直前に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you declare an outlet in Swift, you should make the type of the outlet an implicitly unwrapped optional.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがスウィフトにおいてアウトレットを宣言するとき、あなたはそのアウトレットの型を暗黙的にアンラップされるオプショナルにしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you explicitly type a constant or variable as an <bpt i="1" x="1">&lt;c1&gt;</bpt>NSArray<ept i="1">&lt;/c1&gt;</ept> object and assign it an array literal, Swift creates an <bpt i="2" x="2">&lt;c2&gt;</bpt>NSArray<ept i="2">&lt;/c2&gt;</ept> object instead of a Swift array.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが明示的に定数または変数を<bpt i="1" x="1">&lt;c1&gt;</bpt>NSArray<ept i="1">&lt;/c1&gt;</ept>オブジェクトとして型指定して、それに配列リテラルを代入するとき、スウィフトはスウィフト配列でなくて<bpt i="2" x="2">&lt;c2&gt;</bpt>NSArray<ept i="2">&lt;/c2&gt;</ept>オブジェクトをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you explicitly type a constant or variable as an <bpt i="1" x="1">&lt;c1&gt;</bpt>NSDictionary<ept i="1">&lt;/c1&gt;</ept> object and assign it a dictionary literal, Swift creates an <bpt i="2" x="2">&lt;c2&gt;</bpt>NSDictionary<ept i="2">&lt;/c2&gt;</ept> object instead of a Swift dictionary.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが明示的に定数または変数を<bpt i="1" x="1">&lt;c1&gt;</bpt>NSDictionary<ept i="1">&lt;/c1&gt;</ept>オブジェクトとして型指定して、それに辞書リテラルを代入するとき、スウィフトはスウィフト辞書でなくて<bpt i="2" x="2">&lt;c2&gt;</bpt>NSDictionary<ept i="2">&lt;/c2&gt;</ept>オブジェクトをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you explicitly type a constant or variable as an <bpt i="1" x="1">&lt;c1&gt;</bpt>NSSet<ept i="1">&lt;/c1&gt;</ept> object and assign it an array literal, Swift creates an <bpt i="2" x="2">&lt;c2&gt;</bpt>NSSet<ept i="2">&lt;/c2&gt;</ept> object instead of a Swift set.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが明示的に定数または変数を<bpt i="1" x="1">&lt;c1&gt;</bpt>NSSet<ept i="1">&lt;/c1&gt;</ept>オブジェクトとして型指定して、それに配列リテラルを代入するとき、スウィフトはスウィフト集合でなくて<bpt i="2" x="2">&lt;c2&gt;</bpt>NSSet<ept i="2">&lt;/c2&gt;</ept>オブジェクトをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you import Swift code into Objective-C, you rely on an <bpt i="0" x="0">&lt;e0&gt;</bpt>Xcode-generated header<ept i="0">&lt;/e0&gt;</ept> file to expose those files to Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがスウィフトコードをObjective-Cにインポートするとき、あなたはそれらのファイルをObjective-Cにさらすために<bpt i="0" x="0">&lt;e0&gt;</bpt>Xcode生成のヘッダ<ept i="0">&lt;/e0&gt;</ept>ファイルに頼ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you import an external framework, make sure the Defines Module build setting for the framework you’re importing is set to “Yes”.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが外部のフレームワークをインポートするとき、あなたがインポートしているフレームワークのための「Defines Module」ビルド設定が「Yes」に設定されることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you need to indicate that a value is missing, you use the value <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがある値が見つからないことを指し示す必要があるならば、あなたは値<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you receive an unmanaged object from an unannotated API, you should immediately convert it to a memory managed object before you work with it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが注釈をつけられなかったAPIから管理されないオブジェクトを受け取るとき、あなたがそれを扱う前に、あなたは直ちにそれをメモリ管理されたオブジェクトに変換しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you refer to an enumeration value, use the value name with a leading dot (<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが列挙値に言及するとき、前にドット（<bpt i="0" x="0">&lt;c0&gt;</bpt>.<ept i="0">&lt;/c0&gt;</ept>）をつけた値名を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you use the <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc(<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>name<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>)<ept i="2">&lt;/c2&gt;</ept> attribute on a Swift class, the class is made available in Objective-C without any namespacing.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがスウィフトクラス上で<bpt i="0" x="0">&lt;c0&gt;</bpt>@objc(<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>name<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>)<ept i="2">&lt;/c2&gt;</ept>属性を使うとき、そのクラスは何ら名前空間操作なしにObjective-Cで利用できるようにされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When you want to perform additional clean-up before your class is deallocated, you can implement a deninitializer instead of the <bpt i="0" x="0">&lt;c0&gt;</bpt>dealloc<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのクラスがメモリ割り当て解除される前に、あなたが追加の掃除をしたいときは、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>dealloc<ept i="0">&lt;/c0&gt;</ept>メソッドでなくてデイニシャライザを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When your class is initialized from a storyboard or <bpt i="0" x="0">&lt;c0&gt;</bpt>xib<ept i="0">&lt;/c0&gt;</ept> file, you can assume that the outlet has been connected.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのクラスがストーリーボードまたは<bpt i="0" x="0">&lt;c0&gt;</bpt>xib<ept i="0">&lt;/c0&gt;</ept>ファイルから初期化されるときは、あなたはアウトレットが接続されてしまっていることを確信できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>When your code refers to a Swift class or protocol that comes from a different module, you import the Swift module into your Objective-C header using <bpt i="0" x="0">&lt;c0&gt;</bpt>@import<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたのコードが異なるモジュールから来るスウィフトクラスやプロトコルを参照する場合、あなたはスウィフトモジュールをあなたのObjective-Cヘッダへと<bpt i="0" x="0">&lt;c0&gt;</bpt>@import<ept i="0">&lt;/c0&gt;</ept>を使ってインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever an action is taken by the user, such as editing the text in a control or deleting an item at a selected row, an undo operation can be registered with the undo manager to allow the user to reverse the effect of that operation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あるアクションがユーザによってとられる時はいつでも、例えばテキストのカラーの編集や選択行での項目の削除などで、取り消し操作は取り消しマネージャを使って登録されることで、ユーザがその操作の効果を取り消せるようにされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Whenever possible, Swift avoids giving you direct access to pointers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>可能なときはいつでも、スウィフトはあなたにポインターへの直接のアクセスを与えることを避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Where you typically used the <bpt i="0" x="0">&lt;c0&gt;</bpt>#define<ept i="0">&lt;/c0&gt;</ept> directive to define a primitive constant in C and Objective-C, in Swift you use a global constant instead.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがCとObjective-Cでプリミティブ定数を定義するために概して<bpt i="0" x="0">&lt;c0&gt;</bpt>#define<ept i="0">&lt;/c0&gt;</ept>指令を使ったところを、スウィフトでは、あなたはその代わりにグローバル定数を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Wherever memory management annotations have been provided, Swift automatically manages the memory of Core Foundation objects, including Core Foundation objects that you instantiate yourself.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メモリ管理注釈が提供されているどこででも、あなた自身でインスタンス化するコアファウンデーション・オブジェクトを含めて、スウィフトは自動的にコアファウンデーション・オブジェクトのメモリを管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Wherever you would use <bpt i="2" x="2">&lt;c2&gt;</bpt>CFTypeRef<ept i="2">&lt;/c2&gt;</ept>, you should now use <bpt i="3" x="3">&lt;c3&gt;</bpt>AnyObject<ept i="3">&lt;/c3&gt;</ept> in your code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたが<bpt i="2" x="2">&lt;c2&gt;</bpt>CFTypeRef<ept i="2">&lt;/c2&gt;</ept>を使うどこであろうとも、あなたは現在あなたのコードにおいて<bpt i="3" x="3">&lt;c3&gt;</bpt>AnyObject<ept i="3">&lt;/c3&gt;</ept>を使わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>With this import statement, that Swift file can now access all of Foundation’s classes, protocols, methods, properties, and constants.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>このインポート文で、このスウィフトファイルは今や全てのFoundationのクラス、プロトコル、メソッド、プロパティ、そして定数にアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Without a check, the method call throws an <bpt i="2" x="2">&lt;c2&gt;</bpt>NSInvalidArgumentException<ept i="2">&lt;/c2&gt;</ept> “unrecognized selector sent to instance” exception.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>確認なしでは、メソッド呼び出しは<bpt i="2" x="2">&lt;c2&gt;</bpt>NSInvalidArgumentException<ept i="2">&lt;/c2&gt;</ept>「認識不能セレクタがインスタンスに送られます」例外をスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working with Cocoa Frameworks</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Cocoaフレームワークを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working with Methods</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>メソッドを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Working with Outlets and Actions</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>アウトレットとアクションを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writing Initializers and Deinitializers</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>イニシャライザとデイニシャライザを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Writing Swift Classes and Protocols with Objective-C Behavior</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>スウィフトのクラスとプロトコルをObjective-C挙動で書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Xcode offers to create this header file when you add a Swift file to an existing Objective-C app, or an Objective-C file to an existing Swift app.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Xcodeは、あなたがスウィフトファイルを既存のObjective-Cアプリに、またはObjective-Cファイルを既存のスウィフトアプリに加えるとき、このヘッダ・ファイルを作成することを提案します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Xcode uses your product module name (<bpt i="0" x="0">&lt;c0&gt;</bpt>PRODUCT_MODULE_NAME<ept i="0">&lt;/c0&gt;</ept>)—not your target name (<bpt i="1" x="1">&lt;c1&gt;</bpt>TARGET_NAME<ept i="1">&lt;/c1&gt;</ept>)—when naming the Objective-C bridging header and the generated header for your Swift code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>Xcodeは、あなたのスウィフトコードのためのObjective-C橋渡しヘッダと生成ヘッダに名前をつける時、あなたの製品モジュール名（<bpt i="0" x="0">&lt;c0&gt;</bpt>PRODUCT_MODULE_NAME<ept i="0">&lt;/c0&gt;</ept>）を使います ― あなたのターゲット名（<bpt i="1" x="1">&lt;c1&gt;</bpt>TARGET_NAME<ept i="1">&lt;/c1&gt;</ept>）でなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You access properties on Objective-C objects in Swift using dot syntax, using the name of the property without parentheses.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、Objective-Cオブジェクト上のプロパティにスウィフトにおいてドット構文によって、そのプロパティの名前を丸括弧なして使ってアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You adopt this approach by making your types conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Encodable<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Decodable<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocols, or by conforming to <bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Codable<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> as shorthand for conforming to both protocols.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこの取り組み方を、あなたの型を<bpt i="0" x="0">&lt;c0&gt;</bpt><bpt i="1" x="1">&lt;a1&gt;</bpt>Encodable<ept i="1">&lt;/a1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt><bpt i="3" x="3">&lt;a3&gt;</bpt>Decodable<ept i="3">&lt;/a3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠するようにして、または両方のプロトコルへの準拠の簡略法として<bpt i="4" x="4">&lt;c4&gt;</bpt><bpt i="5" x="5">&lt;a5&gt;</bpt>Codable<ept i="5">&lt;/a5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に準拠することによって採用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also add the <bpt i="0" x="0">&lt;c0&gt;</bpt>@IBInspectable<ept i="0">&lt;/c0&gt;</ept> attribute to properties with types compatible with user defined runtime attributes.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、また、ユーザー定義のランタイム属性と互換性を持つ型をもつプロパティへ<bpt i="0" x="0">&lt;c0&gt;</bpt>@IBInspectable<ept i="0">&lt;/c0&gt;</ept>属性を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also bridge some toll-free bridged Core Foundation types to Swift standard library types if you cast to a bridging Foundation type first.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、いくつかの無料の橋渡しされたコアファウンデーション型をスウィフト標準のライブラリ型に橋渡しをすることが、橋渡ししているファウンデーション型にあなたが最初にキャストするならば、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also call any Objective-C method and access any property on an <bpt i="1" x="1">&lt;c1&gt;</bpt>AnyObject<ept i="1">&lt;/c1&gt;</ept> value without casting to a more specific class type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、あらゆるObjective-Cメソッドを呼び出すこと、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>AnyObject<ept i="1">&lt;/c1&gt;</ept>値上のあらゆるプロパティにアクセスすることが、より具体的なクラス型にキャストすることなしに可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also create an <bpt i="0" x="0">&lt;c0&gt;</bpt>NSArray<ept i="0">&lt;/c0&gt;</ept> object directly from a Swift array literal, following the same bridging rules outlined above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、スウィフト配列リテラルから直接<bpt i="0" x="0">&lt;c0&gt;</bpt>NSArray<ept i="0">&lt;/c0&gt;</ept>オブジェクトをつくることが、上で概説されるのと同じ橋渡し規則にしたがって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also create an <bpt i="0" x="0">&lt;c0&gt;</bpt>NSDictionary<ept i="0">&lt;/c0&gt;</ept> object directly from a Swift dictionary literal, following the same bridging rules outlined above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSDictionary<ept i="0">&lt;/c0&gt;</ept>オブジェクトを直接にスウィフト辞書リテラルから作成することが、上で概説されるのと同じ橋渡し規則にしたがって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also create an <bpt i="0" x="0">&lt;c0&gt;</bpt>NSNumber<ept i="0">&lt;/c0&gt;</ept> object using a floating-point, integer, or Boolean literal by explicitly providing a type annotation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSNumber<ept i="0">&lt;/c0&gt;</ept>オブジェクトを作成することが、浮動小数点、整数、またはブールのリテラルを使って明示的に型注釈を提供することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also create an <bpt i="0" x="0">&lt;c0&gt;</bpt>NSSet<ept i="0">&lt;/c0&gt;</ept> object directly from a Swift array literal, following the same bridging rules outlined above.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSSet<ept i="0">&lt;/c0&gt;</ept>オブジェクトを直接にスウィフト配列リテラルから作成することが、上で概説されるのと同じ橋渡し規則にしたがって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also create an <bpt i="5" x="5">&lt;c5&gt;</bpt>NSString<ept i="5">&lt;/c5&gt;</ept> object using a string literal by explicitly providing a type annotation.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、明示的に型注釈を提供することによって文字列リテラルを使って<bpt i="5" x="5">&lt;c5&gt;</bpt>NSString<ept i="5">&lt;/c5&gt;</ept>オブジェクトを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also invoke the <bpt i="0" x="0">&lt;c0&gt;</bpt>retain()<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>release()<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>autorelease()<ept i="2">&lt;/c2&gt;</ept> methods on unmanaged objects, but this approach is not recommended.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、管理されないオブジェクトの上で<bpt i="0" x="0">&lt;c0&gt;</bpt>retain()<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>release()<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>autorelease()<ept i="2">&lt;/c2&gt;</ept>メソッドを呼び出すことができます、しかしこの取り組みは推薦されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also nest conditional compilation blocks within other conditional compilation blocks.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、条件コンパイルブロックを他の条件コンパイルブロックの内部に入れ子にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also pass a closure property of a generic type or a generic method as long as no generic type parameters are referenced in the closure’s argument list or body.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、ひとつの総称体型のクロージャプロパティまたは総称体メソッドを渡すことが、いくつかの総称体型パラメータがクロージャの引数リストまたは本文において参照されるのでない限りは可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also provide a custom name for the product module name and Xcode will use this when naming the bridging and generated headers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、あつらえの名前を製品モジュール名のために用意することができます、そしてXcodeはこれを橋渡しおよび生成ヘッダに名前をつけるとき使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also specify a log level defined by the logging system, such as Info, Debug, or Error, in order to control how log messages are handled according to the importance of the logging event.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、ログイベントの重要性にそってどのようにログメッセージが取り扱われるか制御するために、ログシステムによって定義されるログ水準、例えばInfo、Debug、またはErrorを指定することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also try and downcast to the subclass type by using the <bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>演算子を使うことによって、そのサブクラス型へのダウンキャストを試みることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use an <bpt i="6" x="6">&lt;c6&gt;</bpt>if<ept i="6">&lt;/c6&gt;</ept>–<bpt i="7" x="7">&lt;c7&gt;</bpt>let<ept i="7">&lt;/c7&gt;</ept> statement to conditionally unwrap the result of a method that the object may not respond to, as shown on line three.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた<bpt i="6" x="6">&lt;c6&gt;</bpt>if<ept i="6">&lt;/c6&gt;</ept>–<bpt i="7" x="7">&lt;c7&gt;</bpt>let<ept i="7">&lt;/c7&gt;</ept>文を使用して、３行目で示されるように、条件付きでオブジェクトが応答しないかもしれないメソッドの結果をアンラップすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use extensions to add protocol conformance to a class without subclassing it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた拡張を使って、プロトコル準拠をあるクラスに、それをサブクラス化することなく加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can also use the <bpt i="2" x="2">&lt;c2&gt;</bpt>CF_IMPLICIT_BRIDGING_ENABLED<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>CF_IMPLICIT_BRIDGING_DISABLED<ept i="3">&lt;/c3&gt;</ept> macros to enclose C function declarations that follow Core Foundation ownership policy naming policy in order to infer memory management from naming.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはまた、<bpt i="2" x="2">&lt;c2&gt;</bpt>CF_IMPLICIT_BRIDGING_ENABLED<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>CF_IMPLICIT_BRIDGING_DISABLED<ept i="3">&lt;/c3&gt;</ept>マクロを使って、C関数宣言たち、それらは名前の付け方からメモリ管理を推測するためのコアファウンデーション所有者方針の命名方針に従うもの、を取り囲むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can annotate an Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>typedef<ept i="0">&lt;/c0&gt;</ept> declaration with the <bpt i="1" x="1">&lt;c1&gt;</bpt>NS_TYPED_ENUM<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>NS_TYPED_EXTENSIBLE_ENUM<ept i="2">&lt;/c2&gt;</ept> macro to have constants of that type imported by Swift as members of a common type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、Objective-Cの<bpt i="0" x="0">&lt;c0&gt;</bpt>typedef<ept i="0">&lt;/c0&gt;</ept>宣言に<bpt i="1" x="1">&lt;c1&gt;</bpt>NS_TYPED_ENUM<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>NS_TYPED_EXTENSIBLE_ENUM<ept i="2">&lt;/c2&gt;</ept>マクロで注釈をつけることで、その型の定数をスウィフトによって普通の型のメンバとしてインポートされるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can call Objective-C methods from Swift using dot syntax.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、Objective-Cメソッドをスウィフトからドット構文を使って呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can call it in any of the following ways:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、以下の方法の何ででもそれを呼ぶことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can call it in the following way:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、以下の方法でそれを呼ぶことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can check whether an instance is of a certain subclass type by using the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるインスタンスが特定のサブクラス型であるかどうか、<bpt i="0" x="0">&lt;c0&gt;</bpt>is<ept i="0">&lt;/c0&gt;</ept>演算子を使うことによって調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can combine compilation conditions using the <bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&amp;<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>||<ept i="1">&lt;/c1&gt;</ept> operators, negate them with the <bpt i="2" x="2">&lt;c2&gt;</bpt>!<ept i="2">&lt;/c2&gt;</ept> operator, and add branches with <bpt i="3" x="3">&lt;c3&gt;</bpt>#elseif<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>#else<ept i="4">&lt;/c4&gt;</ept> compilation directives.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、コンパイル条件を<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&amp;<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>||<ept i="1">&lt;/c1&gt;</ept>を使って結合すること、<bpt i="2" x="2">&lt;c2&gt;</bpt>!<ept i="2">&lt;/c2&gt;</ept>演算子でそれらを無効にすること、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>#elseif<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>#else<ept i="4">&lt;/c4&gt;</ept>条件指示子で分岐を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create a <bpt i="0" x="0">&lt;c0&gt;</bpt>GroceryProduct<ept i="0">&lt;/c0&gt;</ept> from a JSON representation by creating a <bpt i="1" x="1">&lt;c1&gt;</bpt>JSONDecoder<ept i="1">&lt;/c1&gt;</ept> instance and passing it the <bpt i="2" x="2">&lt;c2&gt;</bpt>GroceryProduct.self<ept i="2">&lt;/c2&gt;</ept> type along with the JSON data:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>GroceryProduct<ept i="0">&lt;/c0&gt;</ept>をJSON表現から作成することが<bpt i="1" x="1">&lt;c1&gt;</bpt>JSONDecoder<ept i="1">&lt;/c1&gt;</ept>インスタンスを作成してそれを<bpt i="2" x="2">&lt;c2&gt;</bpt>GroceryProduct.self<ept i="2">&lt;/c2&gt;</ept>型にそのJSONデータとともに渡すことによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create a new option set value using an array literal, and access option values with a leading dot (<bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept>), similar to an enumeration.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、新しいオプションセット値を配列リテラルを使って作成すること、そしてオプション値へ前に付けたドット（<bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept>）で、列挙のようにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create an <bpt i="0" x="0">&lt;c0&gt;</bpt>NSNumber<ept i="0">&lt;/c0&gt;</ept> object by casting a Swift number value using the <bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSNumber<ept i="0">&lt;/c0&gt;</ept>オブジェクトを作成することが、スウィフト数値を<bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept>演算子を使ってキャストすることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create an <bpt i="2" x="2">&lt;c2&gt;</bpt>NSString<ept i="2">&lt;/c2&gt;</ept> object by casting a <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> value using the <bpt i="4" x="4">&lt;c4&gt;</bpt>as<ept i="4">&lt;/c4&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="2" x="2">&lt;c2&gt;</bpt>NSString<ept i="2">&lt;/c2&gt;</ept>オブジェクトの作成が、<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>値を<bpt i="4" x="4">&lt;c4&gt;</bpt>as<ept i="4">&lt;/c4&gt;</ept>演算子を使ってキャストすることで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can create your own singletons as a way to provide a unified access point to a resource or service that’s shared across an app, such as an audio channel to play sound effects or a network manager to make HTTP requests.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あるアプリ全体で共有されるリソースやサービス、例えばサウンドエフェクトを再生するオーディオチャンネルやHTTPリクエストを行うネットワークマネージャなどへの一本化されたアクセスポイントを提供する方法として、あなた自身のシングルトンを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can define an extension on a type from either a system framework or one of your own custom types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、システム・フレームワークから、またはあなた独自のあつらえの型の１つから、そのどちらかの型の上で拡張を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can denote the availability of your own APIs by annotating declarations with the <bpt i="0" x="0">&lt;c0&gt;</bpt>@available<ept i="0">&lt;/c0&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、宣言に<bpt i="0" x="0">&lt;c0&gt;</bpt>@available<ept i="0">&lt;/c0&gt;</ept>属性で注釈を付けることによって、あなたの独自APIの有効性を示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can do the same in Swift as follows:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、同じことをスウィフトにおいて以下のように行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can format a log message using an <bpt i="0" x="0">&lt;c0&gt;</bpt>NSString<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>printf<ept i="1">&lt;/c1&gt;</ept> format string along with one or more trailing arguments.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはログメッセージをフォーマットすることが、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSString<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>printf<ept i="1">&lt;/c1&gt;</ept>フォーマット文字列を１つ以上の後に続く引数とともに使うことで行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can get a list of any command-line arguments that are specified at launch by accessing the <bpt i="0" x="0">&lt;c0&gt;</bpt>CommandLine.arguments<ept i="0">&lt;/c0&gt;</ept> type property.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、起動時に<bpt i="0" x="0">&lt;c0&gt;</bpt>CommandLine.arguments<ept i="0">&lt;/c0&gt;</ept>型プロパティにアクセスすることによって指定される、あらゆるコマンドライン引数のリストを得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can import a framework into any Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> file within a different target using the following syntax:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、フレームワークを異なるターゲット内のどんなObjective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルにでも以下の構文を使ってインポートすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can import a framework into any Swift file within a different target using the following syntax:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはフレームワークをある異なるターゲット内のどんなスウィフトファイルにでも、以下の構文を使ってインポートすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can import external frameworks that have a pure Objective-C codebase, a pure Swift codebase, or a mixed-language codebase.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、純粋なObjective-Cコードベース、純粋なスウィフトコードベース、または混合言語のコードベースを持つ外部のフレームワークをインポートすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can indicate whether initializers in your own Objective-C classes can fail using <bpt i="0" x="0">&lt;e0&gt;</bpt>nullability annotations<ept i="0">&lt;/e0&gt;</ept>, as described in <bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Nullability and Optionals<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなた独自のObjective-Cクラスの中のイニシャライザが失敗できるかどうかを<bpt i="0" x="0">&lt;e0&gt;</bpt>ヌル許可注釈<ept i="0">&lt;/e0&gt;</ept>を使って指し示すことができます、それは<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>ヌル許可とオプショナル<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/s1&gt;</ept>で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can invoke an Objective-C method on an Objective-C compatible object using a selector with the <bpt i="0" x="0">&lt;c0&gt;</bpt>perform(_:)<ept i="0">&lt;/c0&gt;</ept> method or one of its variants.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはObjective-CメソッドをObjective-C互換オブジェクト上で発動することが<bpt i="0" x="0">&lt;c0&gt;</bpt>perform(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドやそれの変種の１つを持つセレクタを使うことで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can override <bpt i="2" x="2">&lt;c2&gt;</bpt>isEqual:<ept i="2">&lt;/c2&gt;</ept> in a subclass to have Swift and Objective-C APIs determine equality based on the contents of objects rather than their identities.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="2" x="2">&lt;c2&gt;</bpt>isEqual:<ept i="2">&lt;/c2&gt;</ept>をサブクラスにおいてオーバーライドして、それらの同一性ではなくてオブジエクトの内容に基づいて同等性を判断するスウィフトとObjective-C APIを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can provide a refined Swift interface in an extension like this:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、改良スウィフトインターフェイスをある拡張においてこのように提供することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can provide an explicit type when assigning to a constant or variable, or you can omit the type and have Swift infer the type automatically from the initializer.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、定数または変数に割り当てする時に明示的な型を提供することができます、またはあなたは型を省略してスウィフトに型をイニシャライザから自動的に推論させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can set up your Swift class to integrate Objective-C behavior by subclassing Objective-C classes, adopting Objective-C protocols, and more.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなたのスウィフトクラスをObjective-Cクラスのサブクラスにすること、Objective-Cプロトコルを採用すること、そしてもっと多くのことによって、Objective-C挙動に溶け込むように準備することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can simply add a file of the other language directly to an existing project.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、単に既存のプロジェクトに直接他の言語のファイルを加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can still use Swift methods and properties that are marked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>internal<ept i="2">&lt;/c2&gt;</ept> modifier from within the Objective-C part of your framework, as long they are declared within a class that inherits from an Objective-C class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは依然として<bpt i="2" x="2">&lt;c2&gt;</bpt>internal<ept i="2">&lt;/c2&gt;</ept>修飾子で印されるスウィフトのメソッドとプロパティをあなたのフレームワークのObjecctive-C部分の内部から使うことができます、それらがObjective-Cクラスから継承するクラスの内部で宣言される限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can subclass Objective-C classes, declare and adopt Objective-C protocols, and take advantage of other Objective-C functionality when writing Swift code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、スウィフトコードを記述する時に、Objective-Cクラスのサブクラス作成、Objective-Cプロトコルの宣言と採用、そして他のObjective-C機能性の利用が可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can take advantage of Cocoa’s undo architecture in Swift just as you would in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、Cocoaの取り消し機構の長所をスウィフトにおいてまさにあなたがObjective-Cでするように利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use Objective-C APIs in Swift, and you can use Swift APIs in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはObjective-CのAPIをスウィフトにおいて使うことができます、そしてあなたはスウィフト APIをObjective-Cにおいて使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use extensions to add properties (including class and static properties).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、拡張を使ってプロパティ（クラスや静的なプロパティを含む）を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use it to resolve circularity for bridging methods and to allow overloading of methods for classes imported by Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはそれを使って、メソッドをブリッジすることの循環性を解決して、Objective-Cでインポートされるクラスに対してメソッドのオーバーロードを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use key-value observing with a Swift class, as long as the class inherits from the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSObject<ept i="0">&lt;/c0&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、そのクラスが<bpt i="0" x="0">&lt;c0&gt;</bpt>NSObject<ept i="0">&lt;/c0&gt;</ept>クラスから継承する限り、スウィフトクラスでキー値監視を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use optional binding to unwrap the result of a failable initializer if initialization is successful.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはオプショナル束縛を使って、初期化がうまくいったならば失敗できるイニシャライザの結果をアンラップすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc(<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>name<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>)<ept i="2">&lt;/c2&gt;</ept> attribute to change the name of a class, property, method, enumeration type, or enumeration case declaration in your interface as it’s exposed to Objective-C code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>@objc(<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>name<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>)<ept i="2">&lt;/c2&gt;</ept>属性を使うことで、あなたのインターフェイスにおいてクラス、プロパティ、メソッド、列挙型、または列挙ケース宣言の名前を変更することがそれがObjective-Cコードに露出されるときに可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc(<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>name<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>)<ept i="2">&lt;/c2&gt;</ept> attribute to explicitly specify the corresponding Objective-C symbol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;@objc(<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>name<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>)<ept i="2">&lt;/c2&gt;</ept>属性を使うことで、対応するObjective-Cシンボルを明示的に指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>CF_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept> macro in your own code to have Swift import C functions as members of the imported structure type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>CF_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept>マクロをあなた自身のコードにおいて使うことで、スウィフトがC関数をインポートされた構造体型のメンバとしてインポートするようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_REFINED_FOR_SWIFT<ept i="0">&lt;/c0&gt;</ept> macro on an Objective-C method declaration to provide a refined Swift interface in an extension, while keeping the original implementation available to be called from the refined interface.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_REFINED_FOR_SWIFT<ept i="0">&lt;/c0&gt;</ept>マクロをObjective-Cメソッド宣言上で使って、ある拡張において改良スウィフトインターフェイスを提供して、オリジナル実装を利用可能に保ったまま、その改良インターフェイスから呼び出されるようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the <bpt i="1" x="1">&lt;c1&gt;</bpt>@objc(<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;e2&gt;</bpt>name<ept i="2">&lt;/e2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>)<ept i="3">&lt;/c3&gt;</ept> attribute to explicitly specify the corresponding Objective-C symbol.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="1" x="1">&lt;c1&gt;</bpt>@objc(<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;e2&gt;</bpt>name<ept i="2">&lt;/e2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>)<ept i="3">&lt;/c3&gt;</ept>属性を使うことで、対応するObjective-Cシンボルを明示的に指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the Foundation framework classes <bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>JSONEncoder<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> and <bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>PropertyListEncoder<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> to convert instances to JSON or property list data.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、Foundationフレームワーククラス<bpt i="6" x="6">&lt;c6&gt;</bpt><bpt i="7" x="7">&lt;a7&gt;</bpt>JSONEncoder<ept i="7">&lt;/a7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>と<bpt i="8" x="8">&lt;c8&gt;</bpt><bpt i="9" x="9">&lt;a9&gt;</bpt>PropertyListEncoder<ept i="9">&lt;/a9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を使って、インスタンスをJSONまたはプロパティリストデータへ変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the arithmetic operators on Swift pointer values to create new pointers at a specified offset.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは算術演算子をスウィフトポインタ値上で使って、新しいポインタを指定されたオフセットで作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the conditional type cast operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>), which returns an optional value of the type you are trying to downcast to:</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、条件型キャスト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>）を使うことができます、それは、あなたがそれへとダウンキャストを試みている型のオプショナルの値を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the same optional chaining syntax you would use for optional methods in protocols to optionally invoke a method on <bpt i="1" x="1">&lt;c1&gt;</bpt>AnyObject<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、プロトコルにおいてオプショナルメソッドに対して使う同じオプショナル連鎖構文を使って、<bpt i="1" x="1">&lt;c1&gt;</bpt>AnyObject<ept i="1">&lt;/c1&gt;</ept>上でメソッドを随意なものとして発動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use the same or a different name than your Objective-C class.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなたのObjective-Cクラスと同じまたは異なる名前を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use them in the same way you would in Objective-C, accessing any properties and calling any methods defined on their respective types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、それらをあなたがObjective-Cでするのと同じ方法で使って、それらの各自の型上で定義される、どんなプロパティにでもアクセスして、どんなメソッドでも呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use these two steps to implement key-value observing in Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、これら２つの手順を使ってキー値監視をスウィフトにおいて実装できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use this feature, called <bpt i="0" x="0">&lt;e0&gt;</bpt>mix and match<ept i="0">&lt;/e0&gt;</ept>, to write apps that have a mixed-language codebase.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはこの特徴、<bpt i="0" x="0">&lt;e0&gt;</bpt>混合と適合<ept i="0">&lt;/e0&gt;</ept>と呼ばれるものを働かせて、混合言語のコードベースを持つアプリを記述することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You can use two different attributes—<bpt i="0" x="0">&lt;c0&gt;</bpt>@IBDesignable<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>@IBInspectable<ept i="1">&lt;/c1&gt;</ept>—to enable live, interactive custom view design in Interface Builder.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、インタフェースビルダーにおいて、生の、双方向のあつらえのビュー設計をできるように、２つの異なる属性 ― <bpt i="0" x="0">&lt;c0&gt;</bpt>@IBDesignable<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>@IBInspectable<ept i="1">&lt;/c1&gt;</ept> ― を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You cannot import C++ code directly into Swift.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、スウィフトに直接C++コードをインポートすることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You cannot override the product module name of a framework.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、フレームワークの製品モジュール名をオーバーライドすることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You cannot reorder or change the number of arguments for type members imported using the <bpt i="0" x="0">&lt;c0&gt;</bpt>CF_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept> macro.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>CF_SWIFT_NAME<ept i="0">&lt;/c0&gt;</ept>マクロを使ってインポートされる型メンバのための引数の数を変更したり順番を変えたりできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You cannot subclass a Swift class in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、スウィフトクラスのサブクラスをObjective-Cにおいて作成できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You cannot use extensions to override existing methods or properties on Objective-C types.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、Objective-C型上での既存のメソッドまたはプロパティをオーバーライドするために拡張を使うことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You choose which method to use based on whether the API you are invoking returns an unretained or retained object.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなたが呼んでいるAPIが保有されない、または保有されるオブジェクトを返すかに基づいて、どちらかのメソッドを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You create a new option set from a constant value or expression, An empty option set is represented by the constant zero (<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、新しいオプションセットを定数値または式から作成します。空のオプションセットは定数ゼロ（<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>）で表現されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You don’t need to do anything special to create the generated header file—just import it to use its contents in your Objective-C code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、生成ヘッダ・ファイルを作成するために特に何もする必要がありません ― あなたは、単にあなたのObjective-Cコードにおいてその内容を使うためにそれをインポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You might encounter Objective-C code that uses the older <bpt i="0" x="0">&lt;c0&gt;</bpt>NS_STRING_ENUM<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NS_EXTENSIBLE_STRING_ENUM<ept i="1">&lt;/c1&gt;</ept> macros, which were used to group string constants.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、より古い<bpt i="0" x="0">&lt;c0&gt;</bpt>NS_STRING_ENUM<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>NS_EXTENSIBLE_STRING_ENUM<ept i="1">&lt;/c1&gt;</ept>マクロを使うObjective-Cコードに直面するかもしれません、それは文字列定数をグループにするために使われました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You must cast it back to another type to perform other operations.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、他の操作を実行するために再び別の型へそれをキャストしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You should not override the equality or identity operators for types imported from Objective-C.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、Objective-Cからインポートされた型に対する同等性または同一性演算子をオーバーライドすべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You should use <bpt i="2" x="2">&lt;c2&gt;</bpt>NS_TYPED_ENUM<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>NS_TYPED_EXTENSIBLE_ENUM<ept i="3">&lt;/c3&gt;</ept> when grouping related constants of any type, including string constants.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="2" x="2">&lt;c2&gt;</bpt>NS_TYPED_ENUM<ept i="2">&lt;/c2&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt>NS_TYPED_EXTENSIBLE_ENUM<ept i="3">&lt;/c3&gt;</ept>を、文字列定数を含む何らかの型の関連する定数をグループにする時に使うべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use complex macros in C and Objective-C to avoid type-checking constraints or to avoid retyping large amounts of boilerplate code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、複雑なマクロをCとObjective-Cにおいて型チェック制約を避けたり、常用文コードの大きな塊を繰り返しタイピングすることを避けるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use native Swift initialization syntax even when you are working with Objective-C classes—Swift converts Objective-C initialization methods to Swift initializers.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがObjective-Cクラスを扱っているときでも、あなたは生粋のスウィフト初期化構文を使います ― スウィフトは、Objective-C初期化メソッドをスウィフトイニシャライザに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept> attribute along with the <bpt i="1" x="1">&lt;c1&gt;</bpt>dynamic<ept i="1">&lt;/c1&gt;</ept> modifier to require that access to members be dynamically dispatched through the Objective-C runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept>属性に加えて<bpt i="1" x="1">&lt;c1&gt;</bpt>dynamic<ept i="1">&lt;/c1&gt;</ept>修飾子を使うことで、メンバへのアクセスがObjective-Cランタイムを通して動的にディスパッチされることを要請します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the <bpt i="1" x="1">&lt;c1&gt;</bpt>@NSManaged<ept i="1">&lt;/c1&gt;</ept> attribute to inform the Swift compiler that Core Data provides the storage and implementation of a declaration at runtime.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、<bpt i="1" x="1">&lt;c1&gt;</bpt>@NSManaged<ept i="1">&lt;/c1&gt;</ept>属性を使って、コアデータがある宣言のストレージと実装を実行時に提供することをスウィフトコンパイラに知らせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the <bpt i="1" x="1">&lt;c1&gt;</bpt>insert(_:)<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>formUnion(_:)<ept i="2">&lt;/c2&gt;</ept> methods to add option values, the <bpt i="3" x="3">&lt;c3&gt;</bpt>remove(_:)<ept i="3">&lt;/c3&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt>subtract(_:)<ept i="4">&lt;/c4&gt;</ept> methods to remove option values, and the <bpt i="5" x="5">&lt;c5&gt;</bpt>contains(_:)<ept i="5">&lt;/c5&gt;</ept> method to check for an option value.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>insert(_:)<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>formUnion(_:)<ept i="2">&lt;/c2&gt;</ept>メソッドを使ってオプション値を付け加え、<bpt i="3" x="3">&lt;c3&gt;</bpt>remove(_:)<ept i="3">&lt;/c3&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt>subtract(_:)<ept i="4">&lt;/c4&gt;</ept>メソッドを使ってオプション値を削除し、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>contains(_:)<ept i="5">&lt;/c5&gt;</ept>メソッドを使ってあるオプション値を調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the bitwise OR operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>|<ept i="0">&lt;/c0&gt;</ept>) to combine option values, and the bitwise AND operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>&amp;<ept i="1">&lt;/c1&gt;</ept>) to check for option values.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはビット単位OR演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>|<ept i="0">&lt;/c0&gt;</ept>）をオプション値を結合するために、そしてビット単位AND演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>&amp;<ept i="1">&lt;/c1&gt;</ept>）をオプション値の確認に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use the same <bpt i="2" x="2">&lt;c2&gt;</bpt>@IBOutlet<ept i="2">&lt;/c2&gt;</ept> attribute to declare an outlet collection—just specify an array for the type.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、同じ<bpt i="2" x="2">&lt;c2&gt;</bpt>@IBOutlet<ept i="2">&lt;/c2&gt;</ept>属性をアウトレット・コレクションを宣言するために使います ― ちょうどある配列に型を指定するように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You use this when calling C functions from Swift that take the size of a type or value as an argument.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたがこれを使うのは、ある型や値のサイズを引数としてとるC関数をスウィフトから呼び出している時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You won’t create a header file; Xcode generates a header automatically in case you need to reference it.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたはヘッダ・ファイルを作成しません；あなたがそれに参照をつける必要がある場合に備えて、Xcodeが自動的にヘッダを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>Your existing code should follow modern coding practices to make it easier to interact with Swift seamlessly.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたの既存のコードは、継ぎ目なくスウィフトと相互に作用することをより簡単にするために、現代のコード記述慣行に従わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You’ll need to edit the bridging header file to expose your Objective-C code to your Swift code.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、あなたのObjective-Cコードをあなたのスウィフトコードに露出するためにこのファイルを編集する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>You’ll replace the <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>.h<ept i="1">&lt;/c1&gt;</ept> files for that class with a single <bpt i="2" x="2">&lt;c2&gt;</bpt>.swift<ept i="2">&lt;/c2&gt;</ept> file.</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>あなたは、そのクラスのための<bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>.h<ept i="1">&lt;/c1&gt;</ept>ファイルを単一の<bpt i="2" x="2">&lt;c2&gt;</bpt>.swift<ept i="2">&lt;/c2&gt;</ept>ファイルで置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="EN-US">
        <seg>id Compatibility</seg>
      </tuv>
      <tuv xml:lang="JA">
        <seg>id互換性</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
