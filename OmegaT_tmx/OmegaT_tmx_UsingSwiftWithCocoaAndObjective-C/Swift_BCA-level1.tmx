<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.1.1_0_9688" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>(You’ll learn more about the product module name later, in Naming Your Product Module.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（あなたは後で製品モジュール名について「あなたの製品モジュールに名前をつける」でさらに学びます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(You’ll learn more about the product module name later, in Naming Your Product Module.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（あなたは後で製品モジュール名について「あなたの製品モジュールに名前をつける」でさらに学びます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Configure cell</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（セルを構成設定する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Insert code here to add functionality to your managed object subclass</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（コードをここに挿入して機能性をあなたの管理オブジェクトサブクラスに加えます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Method is available for use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（メソッドは利用に応じられます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Method is not available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（メソッドは利用できません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Not a compile-time error because NSDictionary has this selector.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（コンパイル時エラーでは無い、なぜならNSDictionaryはこのセレクタを持つからです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Raises an exception because NSArray does not respond to this selector.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（例外を引き起こします、なぜならNSArrayはこのセレクタに応答しないからです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Store the three traffic light color options as 0, 1, and 2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（３つの交通信号色選択肢を0、1、および2として格納する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// amenities is an NSSet object containing three values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（amenitiesは３つの値を含んでいるNSSetオブジェクトです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// code that creates autoreleased objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（オートリリースされるオブジェクトを作成するコード）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// conditional branch not executed</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（条件分岐は実行されません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// could not load the image</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（画像を読み込めなかった）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// crash, myObject doesn't respond to that method</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（失敗、myObjectはこのメソッドに応答することができません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// define the class</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（クラスを定義する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// error: only available on iOS 8.0 or newer</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（エラー：iOS 8.0以降でのみ利用可能）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// loaded the image successfully</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（画像をうまく読み込んだ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// medalRankings is an NSDictionary object containing three key-value pairs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（medalRankingsは、NSDictionaryオブジェクトでキー値ペアを含んでいます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// memoryManagedResult is a memory managed CFString</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（memoryManagedResultは、メモリ管理されるCFStringです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// myChar has unichar? type and nil value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（myCharはunichar?型でNSDatenilを持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// myCount has Int? type and nil value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（myCountはInt?型でnil値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// myObject has AnyObject type and NSDate value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（myObjectはAnyObject型でNSDate値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// object conforms to UITableViewDataSource and is bound to dataSource</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（オブジェクトは、UITableViewDataSourceに準拠して、dataSourceに結束されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// object could not be cast to type UIButton</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（オブジェクトは、型UIButtonにキャストされることができませんでした）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// object is not of type UIButton</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（オブジェクトは、型UIButtonではありません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// object is of type UIButton</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（オブジェクトは、型UIButtonです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// object is successfully cast to type UIButton and bound to button</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（オブジェクトは、型UIButtonにうまくキャストされて、buttonに束縛されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// object not conform to UITableViewDataSource</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（オブジェクトは、UITableViewDataSourceに準拠しません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// offsetPointer is 24 strides ahead of pointer</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（offsetPointerは、pointerの前方24ストライドです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// play song or throw an error if unavailable</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（曲を再生するか利用可能でないならばエラーをスローする）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// schoolSupplies is an NSArray object containing three values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（schoolSuppliesは３つの値を含んでいるNSArrayオブジェクトです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&gt;= followed by a version number</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&gt;=にバージョン番号が続きます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NSString methods that express length, character indexes, or ranges in terms of 16-bit platform-endian values have corresponding Swift String methods that use String.Index and Range&lt;String.Index&gt; values rather than Int and NSRange values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>16ビットのプラットホームエンディアンの値の観点から長さ、文字インデックス、または範囲を表すNSStringメソッドは、対応するスウィフトのStringメソッドを持ちます、それはString.IndexとRange&lt;String.Index&gt;値を使います、IntとNSRange値ではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions expand the behavior of existing classes, structures, and enumerations, including those defined in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、既存のクラス、構造体、そして列挙の挙動を、Objective-Cで定義されるそれらを含めて、発展させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interoperability is the ability to interface between Swift and Objective-C in either direction, letting you access and use pieces of code written in one language in a file of the other language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>相互運用性は、スウィフトとObjective-Cの間でどちらの方向からでも調和させ、あなたに一方の言語で書かれるコード断片を他方の言語のファイルの中でアクセスおよび使用させる能力です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Migration provides an opportunity to revisit an existing Objective-C app and improve its architecture, logic, and performance by replacing pieces of it in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>移行は、既存のObjective-Cアプリを再検討するための、およびその設計仕様、論理、そして性能をそれの一部をスウィフトにおいて取り替えることによって向上させるための機会を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interoperability lets you interface between Swift and Objective-C code, allowing you to use Swift classes in Objective-C and to take advantage of familiar Cocoa classes, patterns, and practices when writing Swift code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>相互運用性は、あなたにスウィフトとObjective-Cコードの間を円滑に相互運用させて、スウィフトクラスをObjective-Cにおいて使用できるように、そしてスウィフトコードを書く場合には、よく知られているココア・クラス、パターン、および慣行を利用できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Migration from existing Objective-C code to Swift is made easy with interoperability and mix and match, making it possible to replace parts of your Objective-C apps with the latest Swift features.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>移行。既存のObjective-Cコードからスウィフトへの移行は、相互運用性および混合と適合によって簡単にされます、そして、あなたのObjective-Cアプリの一部を最新のスウィフト特徴で取り替えることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mix and match allows you to create mixed-language apps containing both Swift and Objective-C files that can communicate with each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>混合と適合は、あなたにお互いと通信することができるスウィフトとObjective-Cファイルを含んでいる混合言語アプリを作成することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Received an NSNull value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（NSNull値を受け取った。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// lastRefreshDate is of type Any?</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（lastRefreshDateは型Any?です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A String value, if Type is Int8 or UInt8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつのString値、TypeがInt8またはUInt8であるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A [Type] value, which is passed as a pointer to the start of the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの[Type]値、それは配列の始まりへのポインターとして渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A buffer pointer is used for low-level access to a region of memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バッファポインタは、メモリのある領域への低水準アクセスのために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A compilation condition can include the literal true and false values, custom conditional compilation flags (specified using -D &lt;#flag#&gt;), and the platform conditions listed in the table below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイル条件は、リテラルのtrueとfalse値、誂えの条件コンパイルフラグ（-D &lt;#flag#&gt;を使って指定される）、そして以下の表で一覧にされるプラットホーム条件を含むことができます、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A lazy property is a property whose underlying value is only initialized when the property is first accessed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延プロパティは、それの裏に潜んだ値が初期化されるのがそのプロパティが最初にアクセスされる時にして初めてというプロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key path is a string of dot-separated keys that specifies a sequence of object properties to traverse.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパスは、ドットで区切られたいくらかのキーからなる文字列で、巡回していく一連のオブジェクトプロパティを指定するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C enumeration that is not marked with the NS_ENUM or NS_OPTIONS macro is imported as a Swift structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NS_ENUMまたはNS_OPTIONSマクロで印されないC列挙は、スウィフト構造体としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Swift app target is a module itself, so the fully qualified name of a Swift class named Observer in an app called MyGreatApp is MyGreatApp.Observer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるスウィフトアプリ・ターゲートは、あるモジュールそれ自体です、なのでMyGreatAppと呼ばれるあるアプリの中のObserverと命名されるあるスウィフトクラスの完全修飾名は、MyGreatApp.Observerです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Swift class must be a descendant of an Objective-C class to be accessible and usable in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトクラスは、Objective-Cにおいてアクセス可能および利用可能であるためにはObjective-Cクラスの子孫でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Swift extension is similar to an Objective-C category.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの拡張は、Objective-Cのカテゴリーに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Swift project’s structure is nearly identical to an Objective-C project, with one important distinction: Swift has no header files.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトプロジェクトの構造は、Objective-Cプロジェクトにほとんど同一ですが、１つの重要な違いがあります：スウィフトには、ヘッダ・ファイルがありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Swift subclass gets all the functionality offered by the superclass in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのサブクラスは、Objective-Cでのスーパークラスによって提供される全ての機能性を獲得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key-path expression accepts property references and chained property references, such as \Animal.name.count.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパス式は、プロパティ参照そして数珠つなぎにされたプロパティ参照を受け入れます、例えば\Animal.name.countのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A method annotated with the @available attribute can safely use APIs available to the specified platform requirements without the use of an explicit availability check.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@available属性で注釈を付けられるメソッドは、指定されたプラッホーム要件で利用可能なAPIを明確に有効性確認を使うことなく安全に使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A non-optional pointer type cannot be assigned a nil value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非オプショナルポインタ型は、nil値を割り当てられることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parameterized class written in Objective-C is imported into Swift as a generic class with the same number of type parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cにおいて書かれたパラメータ化されたクラスは、同じ数の型パラメータを持つ総称体クラスとしスウィフトにインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A protocol declares all initializers, properties, subscripts, and methods that an Objective-C class must implement in order to conform to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、Objective-Cクラスがそのプロトコルに準拠するために実装しなければならない全てのイニシャライザ、プロパティ、添え字、そしてメソッドを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>API Availability</seg>
      </tuv>
      <tuv lang="JA">
        <seg>API有効性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing arguments using CommandLine.arguments is equivalent to accessing the arguments property on ProcessInfo.processInfo.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CommandLine.argumentsを使って引数にアクセスすることは、argumentsプロパティにProcessInfo.processInfo上でアクセスすることと等価です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessor property attributes (getter= and setter=) are ignored by Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセッサプロパティ属性（getter=とsetter=）は、スウィフトによって無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add the @NSManaged attribute to each property or method declaration in your managed object subclass that corresponds to an attribute or relationship in your Core Data model.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコアデータモデルの中の属性またはリレーションシップに対応する、あなたの管理オブジェクトのサブクラスにおけるプロパティまたはメソッド宣言それぞれに、@NSManaged属性を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add the dynamic modifier and @objc attribute to any property you want to observe.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>dynamic修飾子と@objc属性をあなたが監視したい何らかのプロパティに加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note about Swift target system requirements for executables built from the command line in the Setting Up Your Swift Environment section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コマンドラインからビルドされる実行形式に対するスウィフトターゲットシステム要件についての注意をあなたのスウィフト環境を設定するの章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the Enumerations section about initializing imported C enumerations with raw values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポートされたC列挙を生の値で初期化することについての注意を列挙節へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the Option Sets section with information about imported C enumerations cases that have a value of 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注釈をオプションセット節へ加えて0の値を持つインポートされたC列挙ケース節についての情報を持たせた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added an example of the syntax for initializing unnamed fields to the Unnamed Structure and Union Fields section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>無名フィールドを初期化するための構文の例を無名構造体と共用体フィールドの節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added an implementation of deinit and a call to super in the last code sample in the Key-Value Observing section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>deinitの実装とsuperへの呼び出しをキー値監視節での最後のコード例に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about Objective-C class properties to the Accessing Properties section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cクラスプロパティについての情報をプロパティにアクセスする節へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about autorelease pool blocks and the autoreleasepool(_:) function in the Autorelease Pools section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オートリリースプール・ブロックおよびautoreleasepool(_:)関数についての情報をオートリリースプールの節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about bridged value types and renamed types in the Swift Foundation overlay to the Working with Cocoa Frameworks chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift Foundationオーバーレイにおけるブリッジされた値型と新しい名前をつけられた型についての情報をココアフレームワークを扱う章へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about bridging between Dictionary and NSDictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>DictionaryとNSDictionaryの間のブリッジについての情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about defining a Swift protocol that Objective-C classes can conform to in the Declaring Protocols and Declaring a Swift Protocol That Can Be Adopted by an Objective-C Class sections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cクラスが準拠することができるスウィフトプロトコルを定義することについての情報を、プロトコルを宣言するおよびObjective-Cクラスによって採用されることができるスウィフトプロトコルを宣言するの節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about global constants annotated with the NS_STRING_ENUM and NS_EXTENSIBLE_STRING_ENUM macros and functions annotated with the CF_SWIFT_NAME macro to the Interacting with C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NS_STRING_ENUMとNS_EXTENSIBLE_STRING_ENUMマクロで注釈を付けられたグローバル定数およびCF_SWIFT_NAMEマクロで注釈を付けられた関数についての情報をC APIとの相互作用章へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about how nil is bridged to NSNull to the Bridging Optionals to Nonnullable Objects section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>nilがNSNullへとブリッジされる方法についての情報をオプショナルをnull不可オブジェクトへブリッジするの節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about how nullable pointers are imported as optionals to the Null Pointers section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>null許容ポインタがオプショナルとしてインポートされる方法についての情報をnullポインタ節へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about how some Objective-C structures are bridged as instances of the NSValue class to the Cocoa Structures section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかのObjective-C構造体がNSValueクラスのインスタンスとしてブリッジされる方法についての情報をCocoa構造体の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about imported Objective-C classes with generic parameterization to the Lightweight Generics section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体パラメータ表現でインポートされたObjective-Cクラスについての情報を軽量総称体節へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about low-level access to memory to the Buffer Pointers section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリへの低水準アクセスについての情報をバッファポインタの節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about performing unsafe pointer operations to the Pointer Arithmetic section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非安全ポインタ操作を実行することについての情報をポインタ算術節へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the #keyPath expression to the Keys and Key Paths section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>#keyPath式についての情報をキーとキーパス章へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the #selector expression to the Selectors section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>#selector式についての情報をセレクタ節へ加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the NS_TYPED_ENUM and NS_TYPED_EXTENSIBLE_ENUM macros to the Imported Constant Enumerations and Structures section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NS_TYPED_ENUMおよびNS_TYPED_EXTENSIBLE_ENUMマクロについての情報をインポートされる定数列挙と構造体の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the os_log(_:dso:log:type:_:) function in the Unified Logging section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>os_log(_:dso:log:type:_:)関数についての情報を統合ログの節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the new key-path expression syntax to the Keys and Key Paths section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいキーパス式構文についての情報をキーとキーパスの節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about thread-safe initialization to the One-Time Initialization section of the Interacting with C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スレッド安全初期化についての情報をC APIとの相互作用章のワンタイム初期化節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the API Availability section to the Adopting Cocoa Design Patterns chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>API有効性の節をココア・デザインパターンの採用の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Adding Availability Information to Objective-C APIs section to the Swift and Objective-C in the Same Project chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>利用可能性情報をObjective-C APIに加えるの節を同じプロジェクトの中のSwiftとObjective-Cの章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Avoiding Strong Reference Cycles When Capturing self section to the Interacting with Objective-C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節強い参照循環を自身をキャプチャするときに避けるを章Objective-C APIとの相互作用に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Bit Fields section and updated the Unions section in the Interacting with C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビットフィールド節の追加と共用体節の更新をC APIとの相互作用章で行った。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Catching and Handling Custom Errors section with information about how to handle custom errors defined using the NS_ERROR_ENUM macro.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>カスタムエラーを捕えて処理するの節をNS_ERROR_ENUMマクロを使って定義されたカスタムエラーを取り扱う方法についての情報とともに追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Catching and Handling an Error section to the Adopting Cocoa Design Patterns chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーを捕えて処理するの節をココア・デザインパターンの採用の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Converting Errors to Optional Values section to the Adopting Cocoa Design Patterns chapter with information about the try? keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーをオプショナル値に変換するの節を加えて、ココア・デザインパターンの採用の章がtry?キーワードについての情報を持つようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Data Type Size Calculation section to the Interacting with C APIs chapter with information about the sizeof, sizeofValue, strideof, and strideOfValue functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>データ型サイズ計算節を加えてC APIとの相互作用章にsizeof、sizeofValue、strideof、そしてstrideOfValue関数についての情報をもたせた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Error Handling section to the Adopting Cocoa Design Patterns chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーの処理の節をココア・デザインパターンの採用の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Failable Initialization section to the Interacting with Objective-C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できる初期化の節をObjective-C APIとの相互作用の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Key-Value Observing section to the Adopting Cocoa Design Patterns chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節キー値監視を章Cocoaデザインパターンの採用に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Lazy Initialization section to the Adopting Cocoa Design Patterns chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延初期化の節をココア・デザインパターンの採用の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Making Objective-C Interfaces Unavailable in Swift section to the Swift and Objective-C in the Same Project chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトで利用できないObjective-Cインターフェイスを作る節を同じプロジェクト中のスウィフトとObjective-C章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Memory Managed Objects section to the Working with Cocoa Frameworks chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリ管理オブジェクトの節をココアフレームワークを扱うの章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the NSCoding section to the Interacting with Objective-C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NSCodingプロトコルの節をObjective-C APIとの相互作用の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Option Sets section to the Interacting with C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプションセットの節をC APIとの相互作用の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Overriding Swift Names for Objective-C Interfaces section to the Interacting with Objective-C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cインターフェイスのためのスウィフト名のオーバーライドの節をObjective-C APIとの相互作用の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Processing Command-Line Arguments section to the Adopting Cocoa Design Patterns chapter with information about reading command line flags.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コマンドライン引数の処理節を加えてココア・デザインパターンの採用章がコマンドラインフラグの読み込みについての情報を持つようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Refining Objective-C Declarations section to the Swift and Objective-C in the Same Project chapter with information about the NS_REFINED_FOR_SWIFT macro.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C宣言を改良するの節を加えて、同じプロジェクト中のスウィフトとObjective-Cの章がNS_REFINED_FOR_SWIFTマクロについての情報を持つようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Requiring Dynamic Dispatch section to the Interacting with Objective-C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節動的ディスパッチの必要を章Objective-C APIとの相互作用に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Serialization section to the Adopting Cocoa Design Patterns chapter with information about serializing objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シリアライズ節をココア・デザインパターンの採用章に加えてオブジェクトのシリアライズについての情報を持つようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Sets section to the Working with Cocoa Frameworks chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合の節をココアフレームワークを扱うの章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Singleton section to the Adopting Cocoa Design Patterns chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節シングルトンを章ココア・デザインパターンの採用に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Throwing an Error section to the Adopting Cocoa Design Patterns chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーをスローするの節をココア・デザインパターンの採用の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Undo section to the Adopting Cocoa Design Patterns chapter with information about implementing undo support.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>取り消し節を加えてココア・デザインパターンの採用章がアンドゥサポート実装についての情報を持つようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Unions section to the Interacting with C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>共用体の節をC APIとの相互作用の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Unnamed Structure and Union Fields section to the Interacting with C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>無名の構造体と共用体フィールド節をC APIとの相互作用章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Unrecognized Selectors and Optional Chaining section and the Downcasting Any section to the Interacting with Objective-C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別不能セレクタとオプショナル連鎖節とAnyのダウンキャスト節をObjective-C APIとの相互作用章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Unsafe Invocation of Objective-C Methods section to the Interacting with Objective-C APIs chapter now that the performSelector API family is available in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cメソッドの安全でない発動節をObjective-C APIとの相互作用章に加えた、今ではperformSelector APIファミリはスウィフトで利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Using Swift Class Names with Objective-C APIs section to the Writing Swift Classes and Protocols with Objective-C Behavior chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節スウィフトクラス名をObjective-C APIで使うを章スウィフトのクラスとプロトコルをObjective-C挙動で書くに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the Variadic Functions section to the Interacting with C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長引数関数の節をC APIとの相互作用の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added to the Nullability and Optionals section in the Interacting with Objective-C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節ヌル許可とオプショナルを章Objective-C APIとの相互作用に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added various references to tvOS and watchOS platform support.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>種々の参照をtvOSとwatchOSプラットホームサポートに対して加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding Availability Information to Objective-C APIs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>利用可能性情報をObjective-C APIに加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, unlike Objective-C, in Swift there is no separate memory allocation method to invoke.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その上に、Objective-Cと違って、スウィフトでは別々のメモリ割り当てメソッドが呼ばれることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, you can use catch clauses to match on particular error codes as a convenient way to differentiate possible failure conditions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて、あなたは、起こりうる失敗条件を見分ける便利な方法として、catch節を特定のエラーコードで一致するように使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adopting Cocoa Design Patterns</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ココア・デザインパターンの採用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adopting Protocols</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルを採用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adopting a Swift Protocol in an Objective-C Implementation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトプロトコルをObjective-C実装において採用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After You Finish</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがやり終えたあと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the Cake structure has been imported, you can initialize it and use it as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cake構造体がインポートされてしまった後、あなたはそれを初期化してそれを以下のように使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After you add the custom view to Interface Builder (by setting the custom class of the view in the inspector pane), Interface Builder renders your view in the canvas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがカスタムメイドのビューをインタフェースビルダーに加えた（インスペクターペインにおいてそのビューのカスタム・クラスを設定することによって）後に、インタフェースビルダーはキャンバスにおいてあなたのビューを描画します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After you add your custom view to Interface Builder, you can edit these properties in the inspector.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあなたのカスタムメイドのビューをインタフェースビルダーに加えたあと、あなたはインスペクターにおいてこれらのプロパティを編集することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After you have your Xcode project set up, you can import any framework from Cocoa or Cocoa Touch to start working with Objective-C from Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、あなたのXcodeプロジェクトを設定した後は、あなたはどんなフレームワークでもCocoaまたはCocoa Touchからインポートすることで、スウィフトからObjective-Cを扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After you import an Objective-C framework, you can instantiate classes from it and interact with them using native Swift syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがObjective-Cフレームワークをインポートしたあと、あなたはそれからのクラスをインスタンス化することができて、スウィフト本来の構文を使ってそれらと相互に作用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All Objective-C generic type parameters imported by Swift have a type constraint that requires that type to be a class (T: Any).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトによってインポートされる全てのObjective-C総称体型パラメータは、ある型制約を持ちます、それはあるクラス（T: Any）であることをその型に要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All indirectly returned Core Foundation objects are unmanaged as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての間接的に返されたコアファウンデーション・オブジェクトは、同様に管理されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the Cocoa APIs provide availability information, so you can be confident the code you write works as expected on any of the platforms your app targets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cocoa APIの全ては、有効性情報を提供します、それであなたは、あなたの書くコードが予想されるようにあなたのアプリがターゲットにするどのプラットホーム上でも機能すると確信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All selector pieces are required at the call site.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全てのセレクタ片は、呼び出し現場で必須とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alongside these Swift modules are generated Objective-C headers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それと並んでこれらのスウィフトモジュールは、Objective-Cヘッダを生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can check availability in a guard statement, which exits out of scope unless the current target satisfies the specified requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいはまた、あなたは有効性をguard文の中で使うことができます、それは現在のターゲットが指定された要件を満たさない限りスコープの外に退出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can create a bridging header yourself by choosing File &gt; New &gt; File &gt; (iOS, watchOS, tvOS, or macOS) &gt; Source &gt; Header File.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに、あなたは橋渡しヘッダをあなた自身でFile &gt; New &gt; File &gt; (iOS、watchOS、tvOS、またはmacOS) &gt; Source &gt; Header Fileを選ぶことによって作成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although Swift does not require forced unwrapping when calling methods on values of type AnyObject, it is recommended as a way to safeguard against unexpected behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、スウィフトはAnyObject型の値の上でメソッドを呼び出しているとき強制アンラップを必要としません、それは予期しない挙動に対抗して安全を守るための方法として推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although Swift doesn’t support unions, a C union imported as a Swift structure still behaves like a C union.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは共用体をサポートしないにもかかわらず、スウィフト構造体としてインポートされたC共用体は依然としてC共用体のように振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although Swift error handling resembles exception handling in Objective-C, it is entirely separate functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトエラー処理はObjective-Cでの例外処理に似ていますが、それは完全に関係のない機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An AutoreleasingUnsafeMutablePointer&lt;Type&gt; value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつのAutoreleasingUnsafeMutablePointer&lt;Type&gt;値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An UnsafeMutablePointer&lt;Type&gt; value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつのUnsafeMutablePointer&lt;Type&gt;値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An UnsafePointer&lt;Type&gt;, UnsafeMutablePointer&lt;Type&gt;, or AutoreleasingUnsafeMutablePointer&lt;Type&gt; value, which is converted to UnsafePointer&lt;Type&gt; if necessary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつのUnsafePointer&lt;Type&gt;、UnsafeMutablePointer&lt;Type&gt;、またはAutoreleasingUnsafeMutablePointer&lt;Type&gt;値、それは必要ならばUnsafePointer&lt;Type&gt;に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Objective-C class can adopt a Swift protocol in its implementation (.m) file by importing the Xcode-generated header for Swift code and using a class extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cクラスは、その実装（.m）ファイルにおいてスウィフトプロトコルを採用することが、スウィフトコードのためのXcode生成ヘッダをインポートすることとクラス拡張を使うことでできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Objective-C class can conform a protocol declared in Swift in the same way that it would an Objective-C protocol, by implementing the required methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cクラスは、スウィフトで宣言されるプロトコルにそれがObjective-Cプロトコルにするのと同じ方法で、必須メソッドを実装することによって、準拠できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An Objective-C method reference can be parenthesized, and it can use the as operator to disambiguate between overloaded functions, such as #selector(((UIView.insert(subview:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void)).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cメソッド参照は、丸括弧で括られることができます、そしてそれはオーバーロードされた関数間を明確にするためにas演算子を使うことができます、例えば#selector(((UIView.insert(subview:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void))のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An empty option set can be created from an empty array literal ([]) or by calling its default initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空のオプションセットは、空の配列リテラル（[]）から、またはそれの省略時のイニシャライザを呼ぶことによって作成されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An in-out expression of type Type that contains a mutable variable, property, or subscript reference, which is passed as a pointer to the address of the mutable value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つの可変の変数、プロパティ、または添え字参照を含んでいる、型Typeの１つのin-out式、それは、ボインタとしてその可変値のアドレスへと渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An in-out expression of type [Type] that contains a mutable variable, property, or subscript reference, which is passed as a pointer to the start of the array, and is lifetime-extended for the duration of the call</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変の変数、プロパティ、または添え字参照を含んでいる、型[Type]のin-out式、それは、ポインタとしてその配列の始まりへと渡されます、そして呼び出しの持続期間は寿命延長されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An in-out expression that contains a mutable variable, property, or subscript reference of type Type, which is copied bitwise into a temporary nonowning buffer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつのin-out式で、それが型Typeの可変の変数、プロパティ、または添え字参照を含むもの、それは一時的な非所有バッファにビット単位でコピーされるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An in-out expression that contains a mutable variable, property, or subscript reference of type Type, which is passed as a pointer to the address of the left-hand side identifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつのin-out式で、それが型Typeの可変の変数、プロパティ、または添え字参照を含むもの、それは左手側識別子のアドレスへのポインタとして渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An undo operation records the steps necessary to counteract its corresponding operation, such as setting the text of a control back to its original value or adding a deleted item back into a table.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある取り消し操作は、それの対応している操作を無効にするために必要な段取りを記録します、例えばあるコントロールのテキストをそれのオリジナルの値に戻すよう設定する、または削除した項目を表に戻すよう加えるなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And here’s how Swift imports it:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そしてここにスウィフトがそれをインポートする方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And here’s how you add the same availability information in Objective-C:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そしてここにあなたが同じ利用可能性情報をObjective-Cにおいて加える方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And here’s how you use the same availability information in Objective-C:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そしてここにはあなたが同じ利用可能性情報をObjective-Cで使う方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And here’s the equivalent code in Swift:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そしてここにスウィフトにおける同等のコードがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And here’s what it looks like in Swift:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして、それがスウィフトではどんなものになるかがここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any Objective-C framework or C library that supports modules can be imported directly into Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>モジュールをサポートするどんなObjective-CフレームワークまたはCライブラリでも、スウィフトに直接インポートされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any command-line arguments that are specified at launch begin at CommandLine.arguments[1].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>起動時に指定される何らかのコマンドライン引数は、CommandLine.arguments[1]で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any exception handling behavior must be implemented in Objective-C code used by Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのような例外処理挙動もスウィフトによって使用されるObjective-Cコードの中で実装されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any language framework</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何らかの言語フレームワーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any optional protocol requirements must be marked with the @objc attribute and have the optional modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>なんであれオプショナルのプロトコル要件は、@objc属性で印されてoptional修飾子を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any public Objective-C headers listed in this bridging header file will be visible to Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この橋渡しヘッダ・ファイルにリストされるどんなパブリックObjective-Cヘッダでも、スウィフトに見えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anywhere you can use a bridged Objective-C reference type, you can use the Swift value type instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがブリッジObjective-C参照型を使うことができるどこにでも、あなたはスウィフト値型をその代わりに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying a key path to an instance results in a value of the same type as accessing that instance’s property directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパス式をインスタンスに適用することは、そのインスタンスの持つプロパティに直接にアクセスするのと同じ型の値という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying the @objcMembers attribute to a class implicitly adds the @objc attribute to all of its Objective-C compatible members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@objcMembers属性をあるクラスに適用することは、それのObjective-C互換メンバの全てに暗黙的に@objc属性を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As You Work</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが作業するとき</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, changing the value of any computed property on an instance of the imported structure changes the value of all other properties defined by that structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、インポートされた構造体のインスタンス上で何らかの計算プロパティを変更することは、その構造体によって定義される他のプロパティすべての値を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, this attribute can also be useful when migrating an archivable Objective-C class to Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、この属性はまた、アーカイブできるObjective-Cクラスをスウィフトに移行するとき便利でありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, you can use an Objective-C structure from Swift in Cocoa APIs that accept only instances of reference types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、あなたは参照型のインスタンスのみを受け取るCocoa APIにおいてスウィフト由来のObjective-C構造体を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in Objective-C, you can use outlets, actions, and live rendering in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cの場合のように、あなたはスウィフトにおいてアウトレット、アクション、そしてライブレンダリングを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As part of its interoperability with Objective-C, Swift maintains compatibility with a number of C language types and features.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのObjective-Cとの相互運用性の一部として、スウィフトはたくさんのC言語型と特徴との互換性を維持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As part of its interoperability with Objective-C, Swift offers convenient and efficient ways of working with Cocoa frameworks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それのObjective-Cとの相互運用性の一部として、スウィフトはCocoaフレームワークを扱う便利で効率的な方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you begin to integrate Swift into your app development workflow, it’s a good idea to understand how you can leverage interoperability to redefine, improve, and enhance the way you write Cocoa apps.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがスウィフトをあなたのアプリ開発ワークフローに組み込み始めるとき、あなたがあなたがココア・アプリを書く方法をとらえ直して、向上させて、強化するために、どのように相互運用性を使って小さな労力で大きな成果を得られるようにできるか理解することは良い考えです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you incorporate Cocoa patterns into your Swift class, see Adopting Cocoa Design Patterns for information on translating common design patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがココアパターンをあなたのスウィフトクラスに組み込むとき、ココア・デザインパターンの採用を一般的なデザイン・パターンを翻訳することに関する情報のために見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you work with Objective-C APIs, you’ll need to know how Swift translates certain Objective-C language features.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがObjective-C APIを扱うとき、あなたはスウィフトがどのように特定のObjective-C言語機能を翻訳するか知っている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At compile time and runtime, the compiler introduces a universal bridging conversion operation when a Swift value or object is passed into Objective-C as an id parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイル時および実行時に、コンパイラは全般的ブリッジ変換演算を、スウィフトの値やオブジェクトがObjective-Cへidパラメータとして渡される時に導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Atomicity property attributes (atomic and nonatomic) are not reflected in the corresponding Swift property declaration, but the atomicity guarantees of the Objective-C implementation still hold when the imported property is accessed from Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>原子性プロパティ属性（atomicとnonatomic）は、スウィフトプロパティ宣言に反映されません、しかしObjective-C実装の原子性担保はインポートされたプロパティがスウィフトからアクセスされる時に依然として保持されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempting to call the +collectionWithValues:forKeys: method from Swift code will result in a compiler error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>+collectionWithValues:forKeys:メソッドをスウィフトコードから呼び出す試みは、コンパイラエラーの結果になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempting to invoke a method on an object with an unrecognized selector causes the receiver to call doesNotRecognizeSelector(_:), which by default raises an NSInvalidArgumentException exception.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドをオブジェクト上で十分に評価されていないセレクタで発動することは、そのレシーバがdoesNotRecognizeSelector(_:)を呼び出す原因になります、それは初期設定ではNSInvalidArgumentException例外を引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Autorelease Pools</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オートリリースプール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Autorelease pool blocks allow objects to relinquish ownership without being deallocated immediately.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オートリリースプール・ブロックは、オブジェクトに直ちにデアロケートされることなしに所有権を放棄させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Autoreleasing Pointers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動解放ポインター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Availability checks can be used in place of a condition in a control flow statement, such as an if, guard, or while statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効性確認は、制御の流れ文、例えばif、guard、またはwhileの中のひとつの条件の代わりに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoiding Strong Reference Cycles When Capturing self</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強い参照循環を自身をキャプチャするときに避ける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic Setup</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本の準備</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because NSNumber can contain a variety of different types, you must use the as? operator when casting to a Swift number type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NSNumberが様々な異なる型を含むことができることから、あなたはスウィフト数値型をキャストする時にas?演算子を使わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a lazy property is only computed when accessed for a fully-initialized instance it may access constant or variable properties in its default value initialization expression:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延プロパティは、完全に初期化されたインスタンスに対してアクセスされる時に初めて計算されるので、それは、定数または変数プロパティにアクセスすることがそれの省略時の値の初期化式において可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because applying the @objc attribute can increase the compiled size of an app and adversely affect performance, only apply the @objcMembers attribute on declarations when each member needs to have the @objc attribute applied.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@objc属性を適用することはアプリのコンパイル済みサイズを増大させて性能に不利な影響をもたらすことから、各メンバが@objc属性を適用される必要がある場合に、ただ@objcMembers属性を宣言上でだけ適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because archived objects store the name of their class in the archive, you should use the @objc(name) attribute to specify the same name as your Objective-C class so that older archives can be unarchived by your new Swift class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アーカイブされたオブジェクトがそれらのクラスの名前をアーカイブに格納するので、あなたは@objc(name)属性を使ってあなたのObjective-Cクラスと同じ名前を指定しなければなりません、それでちょっと古くなったアーカイブがあなたの新しいスウィフトクラスによってアンアーカイブされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of Swift’s interoperability with Objective-C, you can take advantage of these common patterns in your Swift code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのObjective-Cとの相互運用性のため、あなたはこれらの共通のパターンをあなたのスウィフトコードにおいて活用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because simple constant-like macros map directly to Swift global variables, the compiler automatically imports simple macros defined in C and Objective-C source files.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単純な定数的なマクロがスウィフトのグローバル変数に直接にマップするので、コンパイラは、CとObjective-Cソース・ファイルにおいて定義される単純なマクロを自動的にインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the Cake structure has fields with unnamed types, you use the .init initializers, which are picked using type inference, to set the initial value for each of the structure’s unnamed fields.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cake構造体は無名型でのフィールドを持つことから、あなたは.initイニシャライザを使うことによって、それは型推論を使って選択されます、その構造体の持つ無名フィールドの各々に対して初期値を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the first field of the Cake structure is unnamed, its initializer’s first parameter does not have a label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cake構造体の最初のフィールドが無名であるため、それのイニシャライザの最初のパラメータはラベルを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the generated header for a framework target is part of the framework’s public interface, only declarations marked with the public or open modifier appear in the generated header for a framework target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるフレームワークターゲットのために生成されたヘッダはそのフレームワークのパブリックなインターフェイスの一部なので、publicまたはopen修飾子で印された宣言だけがフレームワークターゲットのために生成されたヘッダの中に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the namespace of classes and protocols is unified in Swift, the NSObject protocol in Objective-C is remapped to NSObjectProtocol in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスとプロトコルの名前空間はスウィフトにおいて統一されるので、Objective-CのNSObjectプロトコルはスウィフトにおいてNSObjectProtocolにリマップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the specific type of an AnyObject value is not known until runtime, it is possible to inadvertently write unsafe code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AnyObject値の具体的な型は実行時まで知られないことから、不注意に安全でないコードを書くことは可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the type of the valueFromSwift parameter is id, it’s imported in the Swift code below as the Swift type Any.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>valueFromSwiftパラメータの型はidであるので、それは以下のスウィフトコードにおいてスウィフト型Anyとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this functionality is provided through language features, the corresponding POSIX and Grand Central Dispatch C function calls are not exposed by Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この機能性は言語特徴によって提供されるので、相当するPOSIXおよびGrand Central DispatchのC関数呼び出しはスウィフトによって暴露されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because unions in C use the same base memory address for all of their fields, all of the computed properties in a union imported by Swift use the same underlying memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cでの共用体は同じ基盤メモリアドレスをすべてのそれのフィールドに対して使うことから、スウィフトによってインポートされる共用体の中の計算プロパティのすべては同じ基礎をなすメモリを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because you can’t subclass Swift classes in Objective-C, it’s best to choose a class in your app that doesn’t have any subclasses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがスウィフトクラスをObjective-Cにおいてサブクラス化できないので、あなたのアプリにおいて全くサブクラスを持たないクラスを選択するのは最も良いことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before You Start</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが始める前に</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before you begin migrating your codebase, make sure that your Objective-C and Swift code has optimal compatibility.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあなたのコードベースを移行し始める前に、あなたのObjective-Cとスウィフトコードが最適の互換性を持つことを確かにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before you get started learning about these features, you need a basic understanding of how to set up a Swift environment in which you can access Cocoa system frameworks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこれらの特徴について学ぶことを始める前に、あなたは、そこにおいてあなたがココア・システム・フレームワークにアクセスすることができるところの、スウィフト環境を設定する方法の基本的な理解が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bit Fields</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビットフィールド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Blocks maintain strong references to any captured objects, including self.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブロックは、selfを含めて、あらゆるキャプチャされるオブジェクトに対する強い参照を管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both kinds of availability specifier are available in Objective-C using the corresponding syntax shown in the following examples.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の種類の利用可能性指定子は、以下の例で示される対応する構文を使ってObjective-Cで利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both of these methods return the original, unwrapped type of the object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのメソッドの両方とも、最初の、包装を取られた型のオブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bridged Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブリッジ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bridging Optionals to Nonnullable Objects</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルをnull不可オブジェクトへブリッジする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Buffer Pointers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バッファポインタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By casting to ToDoListController, this return value can make the corresponding call to mark(task:asCompleted:) directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ToDoListControllerにキャストすることによって、この戻り値は直接にmark(task:asCompleted:)に対する対応する呼び出しを作ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Swift imports enumerations by truncating enumeration value name prefixes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしなくとも、スウィフトは列挙値名接頭辞を切り取ることによってを列挙インポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the generated header contains interfaces for Swift declarations marked with the public or open modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしなければ、生成されたヘッダはスウィフト宣言をpublicまたはopen修飾子で印して含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, your product module name is the same as your product name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしなければ、あなたの製品モジュール名は、あなたの製品名と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C struct and union types can define fields that have no name or that are of an unnamed type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cのstructおよびunion型は、名前を持たないまたは無名型であるフィールドを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C APIs, such as the Core Foundation framework, often provide functions that create, access, or modify C structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C API、例えばCore Foundationフレームワークは、C構造体の作成、アクセス、または修正をする関数をしばしば提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C enumerations imported by Swift do not fail when initializing with a raw value that does not correspond to an enumeration case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトによってインポートされるC列挙は、ある生の値が列挙ケース節と調和しない状態での初期化の時に失敗しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C function pointers are imported into Swift as closures with C function pointer calling convention, denoted by the @convention(c) attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C関数ポインターは、スウィフトにC関数呼出規約を持つクロージャとしてインポートされ、@convention(c)属性によって印を付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Catching and Handling Custom Errors</seg>
      </tuv>
      <tuv lang="JA">
        <seg>カスタムエラーを捕まえて処理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Catching and Handling an Error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーを捕えて処理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changed code listings to use the new Array and Dictionary type syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コード出力を変更して新しいArrayとDictionary型構文を使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Check that myDelegate implements the method window:willUseFullScreenContentSize:.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>myDelegateがメソッドwindow:willUseFullScreenContentSize:を実装することを確かめる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Check that myDelegate is not nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>myDelegateがnilでないことを確かめる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking for and casting to a protocol follows exactly the same syntax as checking for and casting to a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルに対する調査とキャストは、あるクラスに対する調査とキャストと正確に同じ構文に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choose File &gt; New &gt; Project &gt; (iOS, watchOS, tvOS, or macOS) &gt; Application &gt; your template of choice.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「ファイル」&gt;「新規」&gt;「プロジェクト」&gt;（iOS、watchOS、tvOS、またはmacOS）&gt;「アプリケーション」&gt;あなたの選ぶひな形を選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choose “Create NSManagedObject Subclass…” from the “Editor” menu to generate corresponding Swift code for the NSManagedObject subclass, Person:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「Create NSManagedObject Subclass…」を「Editor」メニューから選択することで、NSManagedObjectのサブクラス、Personに対応するスウィフトコードを生成してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clarified the behavior of Objective-C atomicity attributes in Swift in the Accessing Properties section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおけるObjective-C原子性属性の挙動をプロパティにアクセスする節においてわかりやすくした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clarified the behavior of the AnyObject protocol in the id Compatibility section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AnyObjectプロトコルの挙動をid互換性節においてわかりやすくした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class Factory Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスファクトリメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class Factory Methods and Convenience Initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスファクトリメソッドと便宜イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class clusters that include immutable and mutable subclasses are bridged to a single value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不変および可変サブクラスを含むクラス群は、単一値型へブリッジされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class prefixes are optional in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス接頭辞は、スウィフトでは随意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes specific to Objective-C or inherently tied to the Objective-C runtime, such as NSObject, NSAutoreleasePool, NSException, and NSProxy</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C特有の、またはObjective-Cランタイムに本質的に結びつけられ切り離せないクラス、例えばNSObject、NSAutoreleasePool、NSException、そしてNSProxyなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes that adopt NSCoding directly must implement this method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>直接にNSCodingを採用するクラスは、このメソッドを実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes that do not have a value type equivalent but are planned to have one in the near future, such as NSAttributedString, NSRegularExpression, and NSPredicate</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型の相当物を持たないが近い将来それを持つ計画をされるクラス、例えばNSAttributedString、NSRegularExpression、そしてNSPredicate</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes that have a value type equivalent, as described in Bridged Types, such as NSString, NSDictionary, and NSURL</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブリッジ型で記述される、値型の相当物を持つクラス、例えばNSString、NSDictionary、そしてNSURLなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Click the Language pop-up menu and choose Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「言語」ポップアップ・メニューをクリックして、スウィフトを選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closures have similar capture semantics as blocks but differ in one key way: Variables are mutable rather than copied.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは、ブロックとしての類似したキャプチャ意味論を持ちますが、１つの重要なやり方において異なります：変数は、コピーされるのではなく、可変です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cocoa Structures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cocoa構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Command-click a Swift class name to see its generated header.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトクラス名をコマンド-クリックして、その生成ヘッダを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Complex Macros</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複雑なマクロ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Complex macros are macros that do not define constants, including parenthesized, function-like macros.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複雑なマクロは、定数を定義するものではなく、括弧に入れられた、関数のようなマクロのことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Complex macros are used in C and Objective-C but have no counterpart in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複雑なマクロがCとObjective-Cで使われますが、スウィフトにおいて対応するものがありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional Compilation Blocks</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件コンパイルブロック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Configuring Swift Interfaces in Objective-C</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトインターフェイスをObjective-Cにおいて構成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the following Objective-C initializer declarations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のObjective-Cイニシャライザ宣言を考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant Pointers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数ポインター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants imported from a type declaration marked with the NS_TYPED_EXTENSIBLE_ENUM macro can be extended in Swift code to add new values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NS_TYPED_EXTENSIBLE_ENUMマクロで印される型宣言からインポートされる定数は、スウィフトコードにおいて拡張されて新しい値を加えられることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants that represent a fixed set of possible values can be imported as a structure by adding the NS_TYPED_ENUM macro.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある固定された一揃いの候補の値を表す定数いくらかは、構造体としてインポートされることがNS_TYPED_ENUMマクロを加えることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants that represent an extensible set of possible values can be imported as a structure by adding the NS_TYPED_EXTENSIBLE_ENUM macro.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある拡張可能な一揃いの候補の値を表す定数いくらかは、NS_TYPED_EXTENSIBLE_ENUMマクロを加えることによって構造体としてインポートされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants using this extensible form are imported with an additional initializer that lets you omit the argument label when extending the set with new values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この拡張可能な形式を使う定数は、追加的なイニシャライザ、集合を新しい値で拡張する時に引数ラベルをあなたに省略させるもの、でインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, Swift also provides the @nonobjc attribute, which makes a Swift declaration unavailable in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>逆に、スウィフトはまた@nonobjc属性も提供します、それはあるスウィフト宣言をObjective-Cにおいて利用不可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Converting Errors to Optional Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーをオプショナルの値に変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copy Semantics</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コピー意味論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core Data also provides the implementation of instance methods that you use to add and remove objects from to-many relationships.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コアデータはまた、あなたが対多リレーションシップからのオブジェクトの追加と削除をするために使うインスタンスメソッドの実装を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core Data provides the underlying storage and implementation of properties in subclasses of the NSManagedObject class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コアデータは、プロパティたちの基盤となる外部記憶と実装をNSManagedObjectクラスのサブクラスにおいて提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core Foundation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コアファウンデーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core Foundation objects returned from annotated APIs are automatically memory managed in Swift—you do not need to invoke the CFRetain, CFRelease, or CFAutorelease functions yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注釈をつけられたAPIから返されるコアファウンデーション・オブジェクトは、自動的にスウィフトにおいてメモリ管理されます ― あなたは、あなた自身でCFRetain、CFRelease、またはCFAutorelease関数を呼び出す必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Core Foundation types are imported as Swift classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コアファウンデーション型は、スウィフトクラスとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Corrected the Live Rendering section which previously stated that live rendering only worked when a designable class was compiled in a framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節ライブレンダリングを訂正した、それは以前はライブレンダリングはただdesignableクラスがフレームワークにおいてコンパイルされた場合にのみ働くと述べていた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create a Swift class for your corresponding Objective-C .m and .h files by choosing File &gt; New &gt; File &gt; (iOS, watchOS, tvOS, or macOS) &gt; Source &gt; Swift File.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトクラスをあなたの対応するObjective-Cの.mと.hファイルのために、File &gt; New &gt; File &gt;（iOS、watchOS、tvOS、またはmacOS）&gt; Source &gt; Swift Fileを選ぶことによって作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create an observer for the key path and call the observe(_:options:changeHandler) method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパスに対する監視を作成してobserve(_:options:changeHandler)メソッドを呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Curried functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>カリー化関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Type Size Calculation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>データ型サイズ計算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declarations marked with the dynamic modifier must also be explicitly marked with the @objc attribute unless the @objc attribute is implicitly added by the declaration’s context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>dynamic修飾子で印される宣言はまた、明示的に@objc属性で印されなければなりません、@objc属性が暗黙的にその宣言の持つ文脈によって加えられるのでない限り。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declarations marked with the private or fileprivate modifier do not appear in the generated header.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>privateまたはfileprivate修飾子で印される宣言は、生成されたヘッダの中に現れることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declare simple macros as global constants, and translate complex macros into functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単純なマクロをグローバルな定数として宣言してください、そして複雑なマクロを関数へと翻訳してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring Protocols</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルを宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring a Swift Error Type That Can Be Used from Objective-C</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cから利用されることができるスウィフトエラー型を宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring a Swift Protocol That Can Be Adopted by an Objective-C Class</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cクラスによって採用されることができるスウィフトプロトコルを宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delegation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>委任</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Denote instance (-) and class (+) methods with func and class func, respectively.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンス（-）およびクラス（+）メソッドであることを、それぞれfuncおよびclass funcで示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dictionaries</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Document Revision History</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文書改訂履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don’t delete the .m and .h files immediately; use them to troubleshoot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>.mと.hファイルを直ぐに削除しないでください；それらを不具合対処のために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don’t try to persist the pointer and access it after the function has returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのポインタに固執すること、そして関数が帰った後でそれにアクセスすることを試みないでください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Downcasting Any</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Anyのダウンキャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic Method Lookup</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動的メソッド検索</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each member of the C enumeration is imported as a global read-only computed property of the structure’s type—not as a member of the Swift structure itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C列挙の各メンバーは、その構造体の型のグローバルな読み出し専用の計算プロパティとしてインポートされます ― スウィフト構造体自身のメンバーとしてではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each platform argument consists of one of platform names listed below, followed by corresponding version number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各プラットホーム引数は、以下で箇条書きにされるプラットホーム名の１つ、それに続く該当するバージョン番号から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations defined in Swift without Int raw value type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Intの生の値型なしでスウィフトにおいて定義される列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error Handling</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーの処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though each migration experience is different depending on your existing codebase, there are some general steps and tools to help you troubleshoot your code migration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえそれぞれの移行体験があなたの既存のコードベースに従い異なるものではあっても、あなたのコード移行の問題解決を助けるいくつかの一般的な取るべき段階と手段があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Everything from your implementation and interface goes directly into this single Swift file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたの実装とインタフェースからのすべては、直接この単一のスウィフトファイルに入ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failable Initialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できる初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fill out an Objective-C bridging header if you need to access Objective-C code from the same app target in your Swift file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあなたのスウィフトファイルにおいて同じアプリターゲットからのObjective-Cコードにアクセスする必要があるならば、Objective-C橋渡しヘッダに記入してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fixed the NS_SWIFT_NAME example from the Overriding Swift Names for Objective-C Interfaces section in the Swift and Objective-C in the Same Project chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cインターフェイスのためのスウィフト名のオーバーライド節のNS_SWIFT_NAME例を同じプロジェクト中のスウィフトとObjective-C章において修正した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fixed the UIBezierPath example to correctly create a triangle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>UIBezierPath例を直して、正しく三角形を作成できるようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fixed the examples for NS_STRING_ENUM and NS_EXTENSIBLE_STRING_ENUM in the Imported Constant Enumerations and Structures section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NS_STRING_ENUMとNS_EXTENSIBLE_STRING_ENUMのための例をインポートされる定数列挙と構造体の節において修正した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a list, see Using Swift from Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その一覧のために、スウィフトをObjective-Cから使うを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a short list of practices to adopt before moving forward, see Adopting Modern Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前進する前に採用するべき短い慣行リストとして、現代のObjective-Cを採用するを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a straightforward, incremental migration of an app, you’ll be using the tools learned earlier—mix and match plus interoperability.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アプリのわかりやすい、徐々に進める移動のために、あなたは以前に学んだいくつかの手段を使用することになります ― 混合と適合それに相互運用性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of using target-action in Swift code, see Selectors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコードにおいてターゲット-アクションを使う例のために、セレクタを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an unspecialized Objective-C type, Swift infers the generic parameterization for the imported class type constraints.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特殊化されないObjective-C型に対して、スウィフトは総称体パラメータ化をインポートされたクラス型制約に対して推測します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For app targets, declarations marked with the internal modifier appear in the generated header if the app target has an Objective-C bridging header.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アプリターゲットでは、internal修飾子で印される宣言は、そのアプリターゲットがObjective-C橋渡しヘッダを持つならば、生成ヘッダの中に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For class types, the following mappings apply:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス型のために、以下のマッピングが適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For considerations on translating your properties from Objective-C to Swift, read Properties in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにあなたのプロパティをObjective-Cから翻訳することでの配慮について、プロパティをスウィフトプログラミング言語（Swift 4）で読んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For consistency and simplicity, Objective-C class factory methods are imported as convenience initializers in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一貫性と単純さのために、Objective-Cクラスファクトリメソッドは、便宜イニシャライザとしてスウィフトにインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, NSString ** comes over to Swift as AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;, not AutoreleasingUnsafeMutablePointer&lt;String?&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、NSString **はスウィフトにAutoreleasingUnsafeMutablePointer&lt;NSString?&gt;としてやってきます、AutoreleasingUnsafeMutablePointer&lt;String?&gt;ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a function pointer that has the type int (*)(void) in C is imported into Swift as @convention(c) () -&gt; Int32.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、Cにおけるint (*)(void)型をもつ関数ポインターは、スウィフトに@convention(c) () -&gt; Int32としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an Objective-C class providing a convenience initializer that takes variadic arguments for keys-value pairs may advise a Swift consumer to use a dictionary literal instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あるObjective-Cクラスは便利なイニシャライザを提供していて、それは可変長引数をキー-値ペアに対して取るもので、スウィフト消費者に勧めるのは代わりに1つの辞書を使うことです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an app that communicates with a web server would receive JSON representations of grocery products, such as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あるアプリでウェブサーバと通信するものは、日用製品のJSON表現を受け取るでしょう、このように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, casting an NSNumber value representing the number 500 to the Int8 Swift type will fail and return nil, because the largest value that an Int8 value can represent is 127.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、数500を表しているNSNumber値をInt8のSwift型へキャストすることは失敗してnilを返します、なぜならInt8値が表すことができる最大値は127だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider Core Foundation’s CFArrayCreateMutable(_:_:_:) function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、Core FoundationのCFArrayCreateMutable(_:_:_:)関数を考えてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider a C structure named Cake that contains the fields layers and height nested within an unnamed union type, and a field toppings of an unnamed struct type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、Cakeと名前を付けられるC構造体を考えてください、それはフィールドlayersおよびheightを無名のunion型内部に、そして無名struct型のフィールドtoppingsを含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider a C union named SchroedingersCat that has an isAlive and an isDead field:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、SchroedingersCatと名前を付けられるC共用体を考えてください、それはisAliveとisDeadフィールドを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider a Core Data entity called “Person” with a String attribute “name” and a to-many relationship “friends”:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あるコアデータ・エントリ、「Person」と呼ばれて、String属性「name」と対多リレーションシップ「friends」をもつものを考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider a simple Task model, which is used by a ToDoListController to display a list of tasks to complete:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、単純なTaskモデルを考えてください、それはToDoListControllerによって使われて完了するべきタスク（作業）のリストを表示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider the read(from:ofType:) method in NSDocument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、NSDocumentのread(from:ofType:)メソッドを考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider the following C function declarations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のC関数定義を考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider the following Objective-C declarations for integer constants of type TrafficLightColor:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、型TrafficLightColorの整数定数のための以下のObjective-C宣言を考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider the following Objective-C declarations that represent sets of actively illuminated colors on a traffic light:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、信号機上で活発に変わる照明された色の一揃いを表す以下のObjective-C宣言を考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider the following Objective-C declarations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、以下のObjective-C宣言を考えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider the following Objective-C method from NSFileManager:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、以下のNSFileManagerからのObjective-Cメソッドを考えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider the following Objective-C options declaration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、以下のObjective-Cオプション定義を考えてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider the following Swift declaration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、以下のスウィフト宣言を考えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given the following C function declarations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のC関数定義を与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given the following C structure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のC構造体を与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given the following Objective-C class and category declarations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のObjective-Cクラスおよびカテゴリ定義を与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given the following Objective-C declarations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のObjective-C宣言を与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given the following Objective-C method that performs an operation on the specified class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、指定されたクラス上である演算を実行する以下のObjective-Cメソッドを与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given the following Objective-C property declarations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のObjective-Cプロパティを与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given the following Objective-C property that refers to a view controller:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あるビューコントローラを参照する以下のObjective-Cプロパティを与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given the following Swift enumeration declaration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のスウィフト列挙宣言を与えられたとして：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here is an Objective-C block variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ひとつのObjective-Cブロック変数がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here’s an unannotated C function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここに注釈をつけられなかったC関数があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here’s how to call the vasprintf function in Swift:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここにvasprintf関数をスウィフトにおいて呼び出す方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if the name of your Swift class contains a character that isn’t supported by Objective-C, you can provide an alternative name to use in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたのスウィフトクラスの名前がObjective-Cで支持されない文字を含むならば、あなたはObjective-Cで使うために代わりの名前を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you compile the code below using swift -D DEBUG_LOGGING to set the DEBUG_LOGGING conditional compilation flag, the compiler includes the code in the body of the conditional complication block.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたが下記のコードをswift -D DEBUG_LOGGINGを使ってコンパイルしてDEBUG_LOGGING条件コンパイルフラグを設定するならば、コンパイラはそのコードを条件コンパイルブロックの本文の中に含めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in Swift code, you can pass a String value to an Objective-C method declared to take an NSString parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、スウィフトコードにおいて、あなたはあるString値を、NSStringパラメータをとるように宣言されたObjective-Cメソッドに渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the code listing below, the first and second lines are not executed because the count property and the character(at:) method do not exist on an NSDate object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、下記のコード出力において、最初と２番目の行が実行されません、なぜなら、countプロパティとcharacter(at:)メソッドはNSDateオブジェクトには存在しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, information that may be helpful, but isn’t essential for troubleshooting errors should be logged at the Info level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、助けとなるかもしれない、しかしエラーを解決するのに必須ではない情報は、Info水準でログされるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, suppose the C function above does not retain the CFString object before returning it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、上のC関数がCFStringオブジェクトを、それを返す前に保持しないと思ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the NSFileManager instance method URL(for:in:appropriateForURL:create:) returns a URL in the specified search path and domain, or produces an error if an appropriate URL does not exist and cannot be created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、NSFileManagerのインスタンスメソッドURL(for:in:appropriateForURL:create:)は指定された検索パスとドメインにおけるURLを返すか、または適切なURLが存在せず作成もできないならばエラーを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the NSJSONReadingOptions option set is imported as JSONSerialization.ReadingOptions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、NSJSONReadingOptionsオプションセットはJSONSerialization.ReadingOptionsとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the UIImage(contentsOfFile:) initializer can fail to initialize a UIImage object if an image file doesn’t exist at the provided path.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、UIImage(contentsOfFile:)イニシャライザは、与えられたパスでファイルが存在しないならば、UIImageオブジェクトを初期化するのに失敗する可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the setsockopt(_:_:_:_:_:) function can specify a timeval value as a receive timeout option (SO_RCVTIMEO) for a socket by passing a pointer to that value and the length of that value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、setsockopt(_:_:_:_:_:)関数は、あるtimeval値を、受信時間切れオプション（SO_RCVTIMEO）としてあるソケットに対して指定することが、その値へのポインタとその値の長さを渡すことによって可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the NSCoder method decodeObjectOfClass(_:forKey:) uses Swift generics to provide a stronger type signature.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、NSCoderのメソッドdecodeObjectOfClass(_:forKey:)は、スウィフト総称体を使うことでより強力な型シグネチャを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the requestWhenInUseAuthorization method is only available to instances of CLLocationManager starting in iOS 8.0 and macOS 10.10:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、requestWhenInUseAuthorizationメソッドは、CLLocationManagerのインスタンスに対してiOS 8.0およびmacOS 10.10からのみ利用可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the timeval structure in Darwin has a size and stride of 16 and an alignment of 8:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、Darwinにおけるtimeval構造体は、16のサイズとストライドおよび8のアラインメントを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the C enumeration below is declared using the NS_ENUM macro.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のC列挙はNS_ENUMマクロを使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the constant definition #define FADE_ANIMATION_DURATION 0.35 can be better expressed in Swift with let FADE_ANIMATION_DURATION = 0.35.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、定数定義#define FADE_ANIMATION_DURATION 0.35は、スウィフトにおいてよりよく表されることがlet FADE_ANIMATION_DURATION = 0.35でできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following C enumeration is not declared using the NS_ENUM macro:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のC列挙はNS_ENUMマクロを使って宣言されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following Swift code declares a class with an outlet, an outlet collection, and an action:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のスウィフトコードは、１つのアウトレット、１つのアウトレット接続、そして１つのアクションを持つクラスを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code compiles without a compiler warning, but triggers an error at runtime:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードは警告なしにコンパイルします、しかし実行時にエラーの引き金となります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the fully qualified name of a Swift class named DataManager in a framework named MyFramework is MyFramework.DataManager.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、MyFrameworkと命名されるあるフレームワークのDataManagerと命名されるあるスウィフトクラスの完全修飾名は、MyFramework.DataManagerです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the most common form of a localized string in an app may only need a localization key and a comment:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、アプリにおける最も一般的な形式の現地語化文字列は、現地語キーとコメントを必要とするだけでしょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to use Foundation APIs from a Swift file, add the following import statement to the top of the file:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、Foundation APIをスウィフトファイルから利用するには、以下のインポート文をその ファイルの一番上に加えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, using these APIs would be appropriate if you need to implement a class that uses the target-action design pattern in its interface, like NSResponder does.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、これらのAPIの使用は、もしあなたがそれのインターフェイスにおいてターゲット-アクション・デザインパターンを使うクラスを実装する必要があるならば適切でしょう、NSResponderがするように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when you create a document–based Mac app, you provide the name of your NSDocument subclass in your app’s Info.plist file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたがドキュメントベースのMacアプリを作成しているとき、あなたは、あなたのNSDocumentサブクラスの名前をあなたのアプリのInfo.plistファイルにおいて提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, whereas in Objective-C you would call this factory method like this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、Objective-Cではあなたはこのクラスファクトリメソッドこのように呼び出しますが：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, whereas in Objective-C you would do this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、Objective-Cではあなたがこうするのに対して：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can assign an object of any class type to a constant or variable of AnyObject type and reassign a variable to an object of a different type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはどんなクラス型のオブジェクトでもAnyObject型の定数や変数に代入できます、そしてある変数を異なる型のオブジェクトへ再度代入できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can extend the UIBezierPath class to create a simple Bézier path with an equilateral triangle, based on a provided side length and starting point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはUIBezierPathクラスを拡張して、二等辺三角形を使った単純な「ベジェ」パスを作成するようにできます、それは提供された辺長と開始点に基づきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can mark a property called enabled to have a getter named isEnabled in Objective-C like this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはenabledと呼ばれるあるプロパティを、以下のように印してObjective-CにおいてisEnabledと名前をつけられるゲッターを持つようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can set the textColor and text properties of a UITextField object with the following code:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはあるUITextFieldオブジェクトのtextColorとtextプロパティを設定するにの以下のコードを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can use a buffer pointer for efficent processing and communication of data between apps and services.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、あなたはアプリとサービス間での効率の良いデータの処理および通信のためにバッファポインタを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can use the \Animal.name key-path expression to access the name property of the Animal class shown below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたは\Animal.nameキーパス式を使って、下で示すAnimalクラスのnameプロパティにアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you see this behavior when an optional is passed to an Objective-C API that takes a nonnull id and when an array of optional items ([T?]) is bridged to an NSArray.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはこの挙動を、あるオプショナルが非null idをとるObjective-C APIに渡される時、およびオプショナル項目（[T?]）からなる配列がNSArrayへブリッジされる時に見ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For framework targets, only declarations with the public or open modifier appear in the generated header.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>フレームワークターゲットでは、publicまたはopen修飾子を持つ宣言だけが生成ヘッダの中に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For functions and methods, this process affects the types of their arguments and return values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数とメソッドに対して、このプロセスは、それらの引数と戻り値の型に影響を及ぼします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about encoding and decoding more complex custom types, see Encoding and Decoding Custom Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より複雑なカスタム型のエンコードおよびデコードについての情報として、Encoding and Decoding Custom Typesを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about when the @objc attribute is implicitly added, see Declaration Attributes in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@objc属性が暗黙的に加えられる場合についての情報として、宣言属性をスウィフトプログラミング言語（Swift 4）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information on product module naming, see Naming Your Product Module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>製品モジュールに名前をつけることに関する情報のために、あなたの製品モジュールに名をつけるを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information on using Swift from Objective-C code, see Using Swift from Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cコードからスウィフトを使うことに関する情報のために、スウィフトをObjective-Cから使うを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, an Objective-C method that takes one or more pointer arguments could be refined in Swift to return a tuple of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、１つ以上のポインタ引数を取るObjective-Cメソッドが改良されてスウィフトにおいてタプル値を返すようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instructions, see Importing Code from Within the Same App Target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>手順指示のために、コードを同じアプリターゲットからインポートするを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For methods that take more than one argument, you can create an undo operation using an NSInvocation, which invokes the method with arguments that effectively revert the app to its previous state:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つ以上の引数を取るメソッドのために、あなたはNSInvocationを使って取り消し操作を作成することができます、それはアプリをそれの前の状態に効果的に戻す引数を使ってそのメソッドを呼び出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about encoding and decoding JSON, see Using JSON with Custom Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>JSONのエンコードおよびデコードについてのさらなる情報として、Using JSON with Custom Typesを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about implementing comparison logic, see Object comparison in Cocoa Core Competencies.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>比較ロジックの実装についての更なる情報として、Object comparisonをCocoa Core Competenciesで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about implementing your own deinitializers, see Deinitializers in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなた自身のデイニシャライザを実装することについての更なる情報として、デイニシャライザをスウィフトプログラミング言語（Swift 4）でみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about implementing your own initializers, see Initializers in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなた自身のイニシャライザを実装することについての更なる情報として、イニシャライザをスウィフトプログラミング言語（Swift 4）でみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about optionals, see Optionals in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルについての更なる情報として、オプショナルをスウィフトプログラミング言語（Swift 4）において見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about specifiying platform availability, see Declaration Attributes in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プラットホーム利用可能性を指定することについての更なる情報として、宣言属性をThe Swift Programming Language (Swift 4)で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about the unified logging system, see Logging.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>統合ログシステムについてのさらなる情報として、Loggingを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about value types, see Classes and Structures in The Swift Programming Language (Swift 4), and WWDC 2015 session 414 Building Better Apps with Value Types in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型についてのさらなる情報として、クラスと構造体をスウィフトプログラミング言語 (Swift 4)で、そしてWWDC 2015 セッション 414 より良いアプリをスウィフトの値型で作り上げるを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about what you can access from Objective-C and how the Swift interface is imported, see Swift Type Compatibility.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがObjective-Cからアクセスできることとスウィフトインタへフェイスがインポートされる方法についての更なる情報として、スウィフト型互換性を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on dynamic, see Requiring Dynamic Dispatch.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>dynamicに関数さらなる情報として、動的なディスパッチを要求するを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on @objc, see Swift Type Compatibility.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@objcの詳細については、スウィフト型互換性を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on access-level modifiers, see Access Control in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス水準修飾子に関する更なる情報のために、アクセス制御をスウィフトプログラミング言語（Swift 4）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on access-level modifiers, see Access Control in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス水準修飾子に関する更なる情報のために、アクセス制御をスウィフトプログラミング言語（Swift 4）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on key paths, see Keys and Key Paths.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいキーパスについてのさらなる情報として、キーとキーパスを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on using Objective-C in Swift, see Interacting with Objective-C APIs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cをスウィフトにおいて使うことに関するさらなる情報のためにObjective-C APIとの相互作用を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on using Swift in Objective-C, see Swift and Objective-C in the Same Project.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでスウィフトを使うことの詳細については、同じプロジェクト中のスウィフトとObjective-Cを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Lazy Stored Properties in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、遅延格納プロパティをスウィフトプログラミング言語（Swift 4）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Ownership Policy in Memory Management Programming Guide for Core Foundation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報のために、所有者方針をコアファウンデーションのためのメモリ管理プログラミングガイドで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Protocols in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらなる情報として、プロトコルをスウィフトプログラミング言語（Swift 4）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Resolving Strong Reference Cycles for Closures in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、クロージャのための強い参照循環の解消をスウィフトプログラミング言語（Swift 4）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Type Attributes in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報としては、型属性をスウィフトプログラミング言語（Swift 4）において見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Type Casting in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらなる情報として、型キャストをスウィフトプログラミング言語（Swift 4）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Type Properties in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、型プロパティをスウィフトプログラミング言語（Swift 4）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、属性を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Attributes in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、属性をスウィフトプログラミング言語（Swift 4）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Properties in The Swift Programming Language (Swift 4).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、プロパティをスウィフトプログラミング言語（Swift 4）で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see AnyHashable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、AnyHashableを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see MemoryLayout.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、MemoryLayoutを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Advanced Memory Management Programming Guide.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらなる情報は、Advanced Memory Management Programming Guideを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Internationalization and Localization Guide.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらなる情報として、インターナショナライゼーションとローカリゼーションのガイド（Apple訳有り）を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Undo Architecture.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報としてUndo Architectureを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Interacting with Objective-C APIs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、Objective-C APIとの相互作用を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Working with Cocoa Frameworks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、ココアフレームワークを扱うを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see Writing Swift Classes and Protocols with Objective-C Behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、スウィフトのクラスとプロトコルをObjective-C挙動で書くを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For objects that are loaded from Storyboards or archived to disk using the NSUserDefaults or NSKeyedArchiver classes, you must provide a full implementation of this initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ストーリーボードからロードされるかディスクにNSUserDefaultsやNSKeyedArchiverクラスを使ってアーカイブされるオブジェクトに対して、あなたはこのイニシャライザの完全な実装を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For pointers to untyped, raw memory, the following mappings apply:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型無しの、生のメモリへのポインタに対して、以下のマッピングを適用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For properties in Swift, you can create an undo operation in the willSet observer using self as the target, the corresponding Objective-C setter as the selector, and the current value of the property as the object:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでのプロパティに対して、あなたは取消操作をwillSetオブザーバにおいて作成することがselfをtargetとして、対応Objective-Cセッターをselectorとして、そしてプロパティの現在の値をobjectとして使って可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For return types, variables, and arguments, the following mappings apply:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>戻り型、変数、そして引数のために、以下のマッピングが適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, preprocessor directives are not imported in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この理由のために、プリプロセッサ指令は、スウィフトにインポートされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, you should almost never need to use a bridged reference type directly in your own code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この理由のために、あなたはブリッジ参照型を直接にあなた自身のコードにおいて使う必要はほとんどないはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For types, the process of importing can have the following effects:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型のために、インポートのプロセスは、以下の影響を与えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For values that require additional setup beyond initialization, you can assign the default value of the property to a self-evaluating closure that returns a fully-initialized value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化を越えて更なる準備が必要な値に対して、あなたはプロパティの省略時の値を得る仕事を、完全初期化された値を返すある自己評価するクロージャに任せることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forward declarations of Swift classes and protocols can only be used as types for method and property declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのクラスとプロトコルの前方宣言は、ただメソッドおよびプロパティ宣言の型として使われることができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Foundation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ファウンデーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Foundation classes often declare enumeration or constant types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Foundationクラスは、しばしば列挙や定数型を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From here, you can start experimenting by writing Swift code in the app delegate or a new Swift file you create by choosing File &gt; New &gt; File &gt; (iOS, watchOS, tvOS, or macOS) &gt; Source &gt; Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここから、あなたはアプリデリケートまたは「ファイル」&gt;「新規」&gt;「ファイル」&gt;（iOS、watchOS、tvOS、またはmacOS）&gt;「ソース」&gt;「Swift」を選んで作成する新規スウィフトファイルにおいてスウィフトコードを書くことで実験を始めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Pointers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数ポインター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generics</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getting Started</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初めに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Given the following Objective-C declarations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のObjective-C宣言を与えられたとして：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global Constants</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グローバルな定数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global constants defined in C and Objective-C source files are automatically imported by the Swift compiler as Swift global constants.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CとObjective-Cソース・ファイルにおいて定義されるグローバル定数は、スウィフトコンパイラによってスウィフトのグローバル定数として自動的にインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global variables defined in Swift</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて定義されるグローバル変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hashing</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ハッシュ化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are the equivalent Swift initializer declarations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに同等のスウィフトイニシャライザ宣言があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example of using the as? operator to check for protocol conformance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>as?演算子を使ってプロトコル準拠について調べる例がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of how to handle an error when calling a method in Objective-C:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにObejctive-Cにおいてメソッドを呼び出す時どのようにエラーを取り扱うかの例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how Swift imports it:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにスウィフトがそれをインポートする方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how Swift imports them as type members:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにどのようにスウィフトがそれらを型メンバとしてインポートするかがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how Swift imports them:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにどのようにスウィフトがそれらをインポートするかがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how it’s imported by Objective-C:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにそれがObjective-Cによってインポートされる方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how they’re imported by Swift:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、どのようにそれらがスウィフトにインポートされるかがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how to write a Swift type that represents a grocery product and can be used with any serialization format that provides encoders and decoders:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにあるのは、日用製品を表して、エンコーダおよびデコーダで提供される何らかのシリアライズ形式で使用できるスウィフト型を書く方法です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s the corresponding Objective-C declaration in the generated header:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに生成ヘッダにおける対応するObjective-C宣言があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s the corresponding Swift type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに対応するスウィフト型があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s the previous example, in Swift:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにスウィフトでの以前の例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, because passing an optional when an Any was expected is uncommon, the optionals passed into the logSomeValue(_:) class method are explicitly cast to the Any type, which silences a compiler warning.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、Anyが期待された時オプショナルを渡すことは普通でないため、logSomeValue(_:)メソッドへと渡されるオプショナルは明示的にAny型へキャストされます、それはコンパイラ警告を黙らせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, because the Any type can refer to any type, a downcast to a more specific type is not guaranteed to succeed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、Any型はあらゆる型を参照できることから、より具体的な型へダウンキャウトすることは成功することを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if a forced downcast fails, a runtime error is triggered:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、強制型キャストが失敗するならば、実行時エラーが引き起こされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if your product name has any nonalphanumeric characters, such as a period (.), they are replaced with an underscore (_) in your product module name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたの製品名がアルファベットでない文字、例えばピリオド（.）を持つならば、それらはあなたの製品モジュール名においてアンダーライン（_）と取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is necessary when using APIs like key–value observing or the method_exchangeImplementations function in the Objective-C runtime, which dynamically replace the implementation of a method at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、それが必要であるのは、キー値監視またはmethod_exchangeImplementations関数のようなAPIをObjective-Cランタイムにおいて使う時です、それはあるメソッドの実装を実行時に動的に置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, macros can make debugging and refactoring difficult.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、マクロはデバッグやリファクタリングを難しくすることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the availability of dynamic dispatch doesn’t prevent the Swift compiler from selecting a more efficient dispatch approach when those APIs are called from Swift code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、動的ディスパッチの利用可能性は、それらのAPIがスウィフトコードから呼び出される時に、スウィフトコンパイラがもっと効果的なディスパッチ取り組みを選択することを妨げはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there is an exception if the compilation condition includes a swift() platform condition: The statements are parsed only if the compiler’s version of Swift matches what is specified in the platform condition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、例外があります、それはコンパイル条件がswift()プラットホーム条件を含む場合です：文はスウィフトのコンパイラのバージョンがプラットホーム条件において指定されるものと合致する場合にのみ構文解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there is no implicit conversion between these types and core Swift integer types, such as Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、これらの型と中心的なスウィフト整数型、例えばIntとの間に暗黙的な変換はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, these are imported by Swift as instance methods, as only Objective-C @property declarations are imported by Swift as properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、それらはスウィフトによってインスタンスメソッドのようにインポートされます、Objective-Cの@property宣言だけはスウィフトによってプロパティとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, these properties must be computed; extensions can’t add stored properties to classes, structures, or enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、これらのプロパティは、計算されなければなりません；拡張は、格納プロパティをクラス、構造体、または列挙に加えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, they are not accessible at compile time and do not appear in the generated header for a framework target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、それらはコンパイル時にアクセス可能ではありません、そしてフレームワークターゲットのための生成ヘッダの中に現れません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, to avoid cyclical references, don’t import Swift code from within the same module into an Objective-C header (.h) file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、循環参照を防ぐために、スウィフトコードを同じモジュール内部からObjective-Cヘッダ（.h）ファイルへとインポートしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can also open an app programmatically and pass command-line arguments from Terminal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、あなたはまたアプリをプログラムに基づきそしてコマンドライン引数を渡してTerminalから開くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you might not need to implement an initializer for types that are expected to or cannot be instantiated in this way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、あなたはこの方法でインスタンス化されることが出来ないかそうするつもりでない型のためにイニシャライザを実装する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If 1 and 2 hold true, invoke the method and assign the result of the method to the value named fullScreenSize.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１と２が当てはまるならば、そのメソッドを呼び出して、メソッドの結果をfullScreenSizeと名前をつけられる値に代入する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If self maintains a strong reference to the block, such as a copying property, this would create a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>selfがブロックに対する強い参照を管理するならば、これは強い参照循環を作り出すでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If Objective-C code calls a Swift method that throws an error, the error is automatically propagated to the error pointer argument of the bridged Objective-C method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cコードがエラーをスローするスウィフトメソッドを呼ぶならば、そのエラーは橋渡しされたObjective-Cメソッドのエラーポインタ引数に自動的に伝達されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a Swift method does not specify a return type, the corresponding Objective-C method has a BOOL return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのスウィフトメソッドが戻り型を指定しないならば、対応するObjective-CメソッドはBOOLの戻り型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a lazy property has not yet been initialized and is accessed by more than one thread at the same time, there is no guarantee that the property will be initialized only once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延プロパティがまだ初期化されてしまわないのに１つ以上のスレッドによって同時にアクセスされるならば、そのプロパティがただ一度だけ初期化されるとは保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If all of the imported members have default values, Swift also provides a default initializer that takes no arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポートされたメンバのすべてが省略時の値を持つならば、スウィフトもまた引数を取らない省略時のイニシャライザをひとつ提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an NSArray object does not specify a parameterized type, it is bridged to a Swift array of type [Any].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NSArrayオブジェクトがパラメータ化された型を指定しないならば、それは型[Any]のスウィフト配列に橋渡しされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an NSDictionary object does not specify parameterized types, it is bridged to a Swift dictionary of type [AnyHashable: Any].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NSDictionaryオブジェクトがパラメーター化された型を指定しないならば、それは型[AnyHashable: Any]のスウィフト辞書に橋渡しされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an NSSet object does not specify a parameterized type, it is bridged to a Swift set of type Set&lt;AnyHashable&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NSSetオブジェクトがパラメーター化された型を指定しないならば、それは型Set&lt;AnyHashable&gt;のスウィフト集合に橋渡しされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an NSDictionary or NSSet declaration does parameterize its key or object type, respectively, that type is used instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるNSDictionaryまたはNSSet宣言がそれのキーまたはオブジェクト型をパラメータ化するならば、それぞれ、その型が代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an Objective-C method is overridden by a Swift method that cannot be represented in Objective-C, such as by specifying a parameter to be a variable, that method must be marked @nonobjc.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるObjective-Cメソッドが、Objective-Cでは表現できないスウィフトメソッドによって、たとえばあるパラメータを変数であるとして指定することなどによって、オーバーライドされるならば、そのメソッドは@nonobjcと印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an Objective-C method throws an exception during runtime, Swift triggers a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cメソッドが実行時に例外をスローするならば、スウィフトは実行時エラーの引き金を引きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error occurs in a Swift method, the error is thrown, and automatically propagated to the caller:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーがスウィフトメソッドにおいて起こるならば、そのエラーはスローされます、そして自動的に呼び出し側に伝達されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error occurs in an Objective-C method, that error is used to populate the error pointer argument of that method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーがObjective-Cメソッドにおいて起こるならば、そのエラーはそのメソッドのエラーポインター引数に入れられるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error producing Objective-C method returns a BOOL value to indicate the success or failure of a method call, Swift changes the return type of the function to Void.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーを生成しているObjective-CメソッドがBOOL値を返してメソッド呼び出しが成功か失敗かを指し示すならば、スウィフトは関数の戻り型をVoidに変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If another method is declared with the resulting selector, the method name is not changed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として生じるセレクタで別のメソッドが宣言されるならば、メソッド名は変更されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no nullability information is provided for a type, Swift cannot distinguish between optional and nonoptional references, and imports it as an implicitly unwrapped optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ヌル許可情報がある型に提供されないならば、スウィフトはオプショナル参照と非オプショナル参照とを見分けることができません、そしてそれを暗黙的にアンラップされるオプショナルとしてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Objective-C generic parameterization specifies a class qualification, the imported Swift class has a constraint that requires that type to be a subclass of the specified class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラス資格をObjective-C総称体パラメータ化が指定するならば、インポートされたスウィフトクラスはある制約を持ちます、それは指定されたクラスのサブクラスであることをその型に要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Objective-C generic parameterization specifies a protocol qualification, the imported Swift class has a constraint that requires that type to conform to the specified protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコル資格をObjective-C総称体パラメータ化が指定するならば、インポートされたスウィフトクラスはある制約を持ちます、それは指定されたプロトコルに準拠することをその型に要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Objective-C method’s error parameter is also its first parameter, Swift attempts to simplify the method name further, by removing the “WithError” or “AndReturnError” suffix, if present, from the first part of the selector.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cメソッドのエラーパラメーターがまたそれの最初のパラメーターでもあるならば、スウィフトは「WithError」または「AndReturnError」接尾辞を、もしあるならば、セレクタの最初の部分から取り除くことで、メソッド名をいっそう単純化することを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Swift compiler fails to identify a class factory method, you can use the NS_SWIFT_NAME macro, passing the Swift signature of the initializer to have it imported correctly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコンパイラがクラスファクトリメソッドを識別するのを失敗したならば、あなたはNS_SWIFT_NAMEマクロを使うことができ、イニシャライザのスウィフトシグネチャを渡すことでそれは正しくインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Swift compiler mistakenly identifies a method as a class factory method, you can use the NS_SWIFT_NAME macro, passing the Swift signature of the method to have it imported correctly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコンパイラが間違ってあるメソッドをクラスファクトリメソッドと識別するならば、あなたはNS_SWIFT_NAMEマクロを使うことができ、そのメソッドのスウィフトシグネチャを渡すことでそれは正しくインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Swift method has no parameters, AndReturnError: is appended to the Objective-C method name, otherwise error: is appended.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのスウィフトメソッドがパラメータを持たないならば、AndReturnError:がObjective-Cメソッド名に加えられ、そうでないならばerror:が加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Swift method returns a nonoptional type, the corresponding Objective-C method has an optional return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのスウィフトメソッドが非オプショナル型を返すならば、対応するObjective-Cメソッドはオプショナルの戻り型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the app targets a version of iOS prior to 8.0 or macOS prior to 10.10, requestWhenInUseAuthorization() is unavailable, so the compiler reports an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アプリがiOSの8.0より前のまたはmacOSの10.10より前のあるバージョンをターゲットにするならば、requestWhenInUseAuthorization()は利用可能でありません、それでコンパイラはエラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the initializer takes an argument, the With is removed and the rest of the selector is divided up into named parameters accordingly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザが引数をとるならば、Withは取り除かれて残りのセレクタが名前付きパラメーターへとそれらしく分離されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the last non-block parameter of an Objective-C method is of type NSError **, Swift replaces it with the throws keyword, to indicate that the method can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cメソッドの最後の非ブロックパラメーターが型NSError **ならば、スウィフトはそれをthrowsキーワードで置き換えて、そのメソッドがエラーをスローできることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the method is called from Objective-C code, the error instead populates the error pointer argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドがObjective-Cコードから呼ばれるならば、代わりにエラーはエラーポインタ引数に入れられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the method is called from Swift code, the error is propagated to its calling scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドがスウィフトコードから呼ばれるならば、エラーはそれを呼び出しているスコープに伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the method is unable to create an object with the regular file contents of the document, it throws an NSError object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドがオブジェクトを書類の標準ファイル内容で作成することができないならば、それはNSErrorオブジェクトをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the name begins with a number, the first number is replaced with an underscore.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前が数で始まるならば、最初の数はアンダーラインと取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the optional is nil, Swift bridges the nil value as an NSNull instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのオプショナルがnilならば、スウィフトはそのnil値をNSNullインスタンスとしてブリッジします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the protocol is defined in Swift, you can also add conformance to it to structures or enumerations, whether defined in Swift or Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのプロトコルがスウィフトにおいて定義されるならば、スウィフトまたはObjective-Cで定義されるかに関係なく、あなたは同様にそれに対する準拠を構造体または列挙に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type of the value pointed to by a C pointer cannot be represented by Swift, such as an incomplete struct type, the pointer is imported as an OpaquePointer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cポインタによって指し示される値の型がスウィフトによって表されることができないならば、たとえば不完全なstruct型など、そのポインタはOpaquePointerとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you accept, Xcode creates the header file along with the file you were creating, and names it by your product module name followed by adding "-Bridging-Header.h".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが承諾するならば、Xcodeはヘッダ・ファイルをあなたがつくっていたファイルと一緒に作成して、あなたの製品モジュール名に続けて"-Bridging-Header.h"を加わることによってそれに名前をつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are certain of the type of the object, you can use the forced downcast operator (as!) instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがそのオプジェクトの型について確信をもつならば、あなたは強制ダウンキャスト演算子（as!）を代わりに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do need to use a bridged Foundation object, you can cast between bridged types using the as type casting operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがブリッジFoundationオブジェクトを使うことをどうしても必要とするならば、あなたはブリッジ型の間でキャストすることがas型キャスト演算子を使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have declared a function like this one:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこのような関数を宣言したならば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to change the name imported by Swift of an Objective-C method, enumeration case, or option set value, you can use the NS_SWIFT_NAME macro to customize how a declaration is imported.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがObjective-Cメソッド、列挙ケース節、またはオプションセット値のスウィフトによってインポートされた名前を変更する必要があるならば、あなたはNS_SWIFT_NAMEマクロを使ってどのようにある宣言がインポートされるかをカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to perform additional setup beyond initialization, you can assign the result of the invocation of a closure to the global constant:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが追加的な準備を初期化が済んだら実行する必要があるならば、あなたはあるクロージャの発動の結果をグローバル定数に割り当てることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you provide an Objective-C name for a Swift function, use Objective-C selector syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあるObjective-C名をスウィフト関数のために用意する場合は、Objective-Cセレクタ構文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you return Core Foundation objects from your own C functions and Objective-C methods, you can annotate them with either the CF_RETURNS_RETAINED or CF_RETURNS_NOT_RETAINED macro to automatically insert memory management calls.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがコアファウンデーション・オブジェクトをあなた独自のC関数およびObjective-Cメソッドから返すならば、あなたはそれらにCF_RETURNS_RETAINEDまたはCF_RETURNS_NOT_RETAINEDマクロのどちらかで注釈をつけて、自動的にメモリ管理呼び出しを差し込むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use only annotated APIs that do not indirectly return Core Foundation objects, you can skip the rest of this section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがコアファウンデーション・オブジェクトを間接的に返さない注釈をつけられたAPIだけを使うならば、あなたはこの節の残りをスキップすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use your own Objective-C types in your Swift code, make sure to import the Objective-C headers for those types before importing the Swift generated header into the Objective-C .m file you want to access the Swift code from.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあなた独自のObjective-C型をあなたのスウィフトコードにおいて使うならば、必ずそれらの型のためのObjective-Cヘッダをインポートするようにするようにしてください、スウィフトの生成ヘッダをあなたがそれからスウィフトコードにアクセスすることを望むObjective-Cの.mファイルにインポートする前にです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use your own Objective-C types in your Swift code, make sure to import the Objective-C headers for those types before importing the Swift generated header into the Objective-C .m file you want to use your Swift code from.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあなたのスウィフトコードにおいてあなた独自のObjective-C型を使うならば、スウィフト生成のヘッダをあなたがそれからスウィフトコードにアクセスすることを望むObjective-C .mファイルにインポートする前に、必ずそれらの型のためのObjective-Cヘッダをインポートするようにするようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your app target is compiled with testing enabled, a unit test target can access any declaration with the internal modifier as if they were declared with the public modifier by prepending @testable to the product module import statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのアプリターゲットがテスト可能にされてコンパイルされるならば、ユニットテストターゲットはinternal修飾子を持つあらゆる宣言にアクセスできます、まるでそれらが、@testableを製品モジュールインポート文の先頭に付けることで、public修飾子とともに宣言をされたかのようにです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you’re calling a method with no arguments, you must still include parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが引数なしでメソッドを呼んでいる場合、あなたはそれでも括弧を含めなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you’re working with frameworks, make sure the Defines Module (DEFINES_MODULE) build setting under Packaging is set to “Yes”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがフレームワークを扱ってならば、「Packaging」の下の「Defines Module（DEFINES_MODULE）」ビルド設定が「Yes」に設定されることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you’re working with the Objective-C bridging header, make sure the Objective-C Bridging Header (SWIFT_OBJC_BRIDGING_HEADER) build setting under Swift Compiler - Code Generation is set to a path to the bridging header file relative to your project (for example, “MyApp/MyApp-Bridging-Header.h”).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがObjective-C橋渡しヘッダを扱っているならば、「Swift Compiler - Code Generation」下の「Objective-C Bridging Header（SWIFT_OBJC_BRIDGING_HEADER）」ビルド設定が、あなたのプロジェクトに関連する橋渡しヘッダファイルへのパスを持つことを確認してください（例えば、「MyApp/MyApp-Bridging-Header.h」）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you’re writing a mixed-language app, you may need to access your Objective-C code from Swift and your Swift code from Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが混合言語のアプリを書いているならば、あなたは、あなたのObjective-Cコードにスウィフトから、そしてあなたのスウィフトコードにObjective-Cからアクセスする必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you’re writing a mixed-language framework, you may need to access your Objective-C code from Swift and your Swift code from Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが混合言語のフレームワークを書いているならば、あなたはObjective-Cコードにあなたのスウィフトから、そしてあなたのスウィフトコードにObjective-Cからアクセスする必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementing Core Data Managed Object Subclasses</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コアデータ管理オブジェクトのサブクラスを実装する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import into Objective-C</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cへインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import into Swift</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトへインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import relevant system frameworks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連するシステム・フレームワークをインポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import the Swift code from that framework target into any Objective-C .m file within that framework target using this syntax and substituting the appropriate names:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコードをそのフレームワークターゲットから、そのフレームワークターゲット内の何らかのObjective-C .mファイルにこの構文を使って、適切な名前で置き換えて、インポートしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import the Swift code from that target into any Objective-C .m file within that target using this syntax and substituting the appropriate name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのターゲットからスウィフトコードを何らかのObjective-Cの.mファイルへ、この構文を使って、適切な名前で置き換えて、インポートしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imported Constant Enumerations and Structures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポートされる定数列挙と構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imported Foundation classes and protocols drop their NS prefix, with the following exceptions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポートされたFoundationのクラスおよびプロトコルは、それらのNS接頭辞を外します、以下の例外を除いては：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Importing Code from Within the Same App Target</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コードを同じアプリターゲットからインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Importing Code from Within the Same Framework Target</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コードを同じフレームワークターゲット内からインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Importing External Frameworks</seg>
      </tuv>
      <tuv lang="JA">
        <seg>外部のフレームワークをインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Importing Functions as Type Members</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数を型メンバとしてインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Importing Objective-C into Swift</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cをスウィフトにインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Importing Swift into Objective-C</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトをObjective-Cにインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Build Settings, in Swift Compiler - Code Generation, make sure the Objective-C Bridging Header build setting has a path to the bridging header file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Build Settingsにおいて、Swift Compiler - Code Generationにおいて、Objective-C Bridging Headerビルド設定がブリッジしているヘッダファイルへのパスを持つことを確実にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In C, the pthread_once() function in POSIX and the dispatch_once() and dispatch_once_f() functions in Grand Central Dispatch provide mechanisms for executing initialization code exactly once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cでは、POSIXでのpthread_once()関数およびGrand Central Dispatchでのdispatch_once()とdispatch_once_f()関数は、厳密に一度だけ初期化コードを実行する仕組みを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In C, the sizeof and alignof operators return the size and alignment of any variable or data type, In Swift, you use MemoryLayout&lt;T&gt; to access the memory layout of the parameterized type T through the size, stride, and alignment properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cでは、sizeofおよびalignof演算子はあらゆる変数またはデータ型のサイズとアラインメントを返します、スウィフトでは、あなたはMemoryLayout&lt;T&gt;を使って、パラメータ化された型Tのメモリレイアウトにsize、stride、そしてalignmentプロパティを通してアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Cocoa, methods that produce errors take an NSError pointer parameter as their last parameter, which populates its argument with an NSError object if an error occurs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cocoaでは、エラーを生成するメソッドは、それの最後のパラメーターとしてNSErrorポインターパラメーターを取ります、エラーが起こるならばその引数にNSErrorオブジェクトが入ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Cocoa, you register operations with NSUndoManager to allow users to reverse that operation’s effect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cocoaでは、あなたはそれぞれの操作をNSUndoManagerに登録して、ユーザがその操作の効果を取り消せるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, a key is a string that identifies a specific property of an object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、keyはオプジェクトの特定のプロパティを識別するある文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, a pointer type declaration can use the _Nullable and _Nonnull annotations to specify whether or not that pointer may have a nil or NULL value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、ボインタ型宣言は_Nullableおよび_Nonnull注釈を使うことで、そのポインタがnilまたはNULL値を持つかどうか指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, a property may override its synthesized getter method such that the underlying instance variable is conditionally initialized if its value is nil:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、プロパティは、それの合成されたゲッターメソッドをオーバーライドできます、例えば、裏に潜んだインスタンス変数が、それの値がnilかどうかで、条件付きで初期化されるように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, a selector is a type that refers to the name of an Objective-C method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Ojbective-Cでは、セレクタはObjective-Cメソッドの名前を参照するある型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, an option set is a bit mask of integer values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、オプションセットは整数値のビットマスクです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, autorelease pool blocks are marked using @autoreleasepool.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、オートリリース・ブロックは@autoreleasepoolを使って印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, constants are often used to provide a list of possible values for properties and method parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、プロパティおよびメソッドパラメータに対する候補の値のリストを提供するためにしばしば定数が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, error handling is opt-in, meaning that errors produced by calling a method are ignored unless an error pointer is provided.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、エラー処理はオプトインです、それはメソッドを呼び出すことで生成されたエラーはエラーポインターが提供されない限りは無視されるということを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, error handling is opt-in, meaning that errors produced by calling a method are ignored unless you provide an error pointer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、エラー処理はオプトインです、それはメソッドを呼び出すことで生成されたエラーはあなたがエラーポインターを提供しない限りは無視されるということを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, if you need to capture self in a block, it’s important to consider the memory management implications.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cにおいて、あなたがselfをあるブロックにおいてキャプチャする必要があるならば、メモリ管理の影響を考慮することが重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, initializers directly return the object they initialize.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、イニシャライザは直接にそれが初期化したオブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, properties have a range of potential attributes that specify additional information about a property’s behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cにおいて、プロパティたちは、あるプロパティの挙動に関する追加の情報を指定する多種多様な潜在的な属性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, the success or failure of the method can be determined by whether an NSURL object is returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、メソッドの成功や失敗は、NSURLオブジェクトが返されるかどうかによって判断されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, this method’s last parameter is of type NSError **.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、このメソッドの最後のパラメーターは型NSError **です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, you can ensure that only one instance of a singleton object is created by wrapping its initialization in a call the dispatch_once function, which executes a block once and only once for the lifetime of an app:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、あなたはあるシングルトンオブジェクトにただ１つのインスタンスが作成されることを、それの初期化を、あるプロックをあるアプリのライフタイムに対していっぺんこっきり実行するdispatch_once関数呼び出しの中にラップする（包む）ことによって確実にできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, you can use the Foundation framework classes NSJSONSerialization and NSPropertyListSerialization to initialize objects from a decoded JSON or property list serialization value—usually an object of type NSDictionary&lt;NSString *, id&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、あなたはFoundationフレームワーククラスのNSJSONSerializationとNSPropertyListSerializationを使って、復号化されたJSONまたはプロパティリストのシリアライズ値 ― 通常は型NSDictionary&lt;NSString *, id&gt;のオブジェクトから各オブジェクトを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, you do this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、あなたはこうします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, you pass NULL for the error parameter when you only care whether there was an error, not what specific error occurred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、あなたはNULLをエラーパラメータのために渡すことが、あなたが心配するのがただエラーがあったかどうかだけであり、特定のエラーに出くわしたことではない時に行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, you typically use the NSLocalizedString family of macros to localize strings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、あなたは一般的に文字列を現地語化するためにマクロのNSLocalizedStringファミリーを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, you use the isKindOfClass: method to check whether an object is of a certain class type, and the conformsToProtocol: method to check whether an object conforms to a specified protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、あるオブジェクトが特定のクラス型かどうか調べるためにisKindOfClass:を、そしてオブジェクトが指定されたプロトコルに準拠するかどうか調べるためにconformsToProtocol:を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, you use the respondsToSelector: and instancesRespondToSelector: methods to check for the availability of a class or instance method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、あなたはrespondsToSelector:とinstancesRespondToSelector:メソッドを使ってクラスおよびインスタンス・メソッドの有効性を確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, you work with references to objects using raw pointers that could be NULL (referred to as nil in Objective-C).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、あなたはオブジェクトへの参照を、NULL（Objective-Cではnilと呼ばれます）であることができる生のポインターを使って扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift as well as Objective-C, attempting to call a method that does not exist triggers an unrecognized selector error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトではObjective-C同様に、存在しないメソッドを呼び出す試みは、識別不能セレクタエラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, Objective-C selectors are represented by the Selector structure, and can be constructed using the #selector expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、Objective-CセレクタはSelector構造体によって表されます、そして#selector式を使って組み立てられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, a null pointer is represented by a nil value of an optional pointer type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、ヌルポインタはオプショナルポインタ型のnil値によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, a stored property with an initial value can be declared with the lazy modifier to have the expression calculating the initial value only evaluated when the property is first accessed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、初期値を持つ格納プロパティがlazy修飾子を使って宣言されると、初期値を計算する式は、そのプロパティが最初にアクセスされる時に初めて数値を求められるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, all values—including structures and object references—are guaranteed to be non–null.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、すべての値は ― 構造体やオブジェクト参照を含めて ― 非nullであることを保証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, attempting to call a method that is not supported on all targeted platform versions causes a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、ターゲットにされるすべてのプラットホーム上でサポートされないメソッドを呼び出す試みは、コンパイル時エラーを生じさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, calling a method that throws requires explicit error handling.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、スローするメソッドを呼び出すことは明確にエラー処理することを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, global constants and stored type properties are guaranteed to be initialized only once, even when accessed across multiple threads simultaneously.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、グローバル定数と格納型プロパティは、ただ一度だけ初期化されることを保証されます、複数のスレッドをまたいで同時にアクセスされた時でさえもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, it’s imported like this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、それはこのようにインポートされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, option sets are represented by structures conforming to the OptionSet protocol, with static variables for each option value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、オプションセットはOptionSetプロトコルに準拠している構造体によって表され、静的変数を各オプション値に対して持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, the Objective-C copy property attribute translates to @NSCopying.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、Objective-Cのcopyプロパティ属性は、@NSCopyingとして解釈します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, the functionality of these macros is made available through a single function: NSLocalizedString(_:tableName:bundle:value:comment:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、これらのマクロの機能性は、ただ１つの関数：NSLocalizedString(_:tableName:bundle:value:comment:)を通して利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, the standard library defines a standardized approach to data encoding and decoding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、標準ライブラリが標準化された取り組みをデータのエンコーディングとデコーディングに対して定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, there are no readwrite and readonly attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、readwriteとreadonly属性はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, this pattern is built into a language feature called failable initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、このよくある操作は失敗できる初期化と呼ばれる言語機能に組み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, those header files are compiled down to Objective-C modules, which are then imported into Swift as Swift APIs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、それらのヘッダ・ファイルはObjective-Cモジュールに至るまでコンパイルされます、それらは、それからスウィフトにスウィフト APIとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you accomplish this task by using the is operator to check for a type, or the as? operator to downcast to that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたは、ある型か調べるis演算子、またはその型にダウンキャストするas?演算子を使うことによってこの作業を達成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you call it like this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたはそれをこのように呼び出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can also use the #keyPath string expression to create compiler-checked keys and key paths that can be used by KVC methods like value(forKey:) and value(forKeyPath:), and KVO methods like addObserver(_:forKeyPath:options:context:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたは#keyPath文字列式を使うことでコンパイラチェック済みのキーやキーパスを作成できます、それらはvalue(forKey:)とvalue(forKeyPath:)のようなKVCメソッドおよびaddObserver(_:forKeyPath:options:context:)のようなKVOメソッドによって使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can call C variadic functions, such as vasprintf, using the getVaList(_:) or withVaList(_:_:) functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、あなたはCの可変長引数関数、例えばvasprintfなどを呼び出すことがgetVaList(_:)またはwithVaList(_:_:)関数を使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can define protocols that Objective-C classes can conform to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、あなたはObjective-Cクラスが準拠できるプロトコルを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can define subclasses of Objective-C classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、あなたはObjective-Cクラスのサブクラスを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can interact with the unified logging system using the top level os_log(_:dso:log:type:_:) function, found in the log submodule of the os module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたは統合ログシステムとトップレベルのos_log(_:dso:log:type:_:)関数、osモジュールのlogサブモジュールで見つかります、を使ってやり取りできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can simply use a static type property, which is guaranteed to be lazily initialized only once, even when accessed across multiple threads simultaneously:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたは単にstatic型プロパティを使うことができます、それは、複数のスレッドから同時にアクセスされる時でさえも、ただ一度だけ遅延初期化されることを保証します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can use a key-path expression to create key paths for accessing properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたはキーパス式を使うことで、プロパティにアクセスするためのキーパスを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can use each pair of toll-free bridged Foundation and Core Foundation types interchangeably.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、あなたは、無料の橋渡しされたファウンデーションとコアファウンデーション型のそれぞれの対を入れ替えて使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can use functions and generics to achieve the same results without any compromises.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたはどんな妥協もなしで同じ結果を成し遂げるために、関数と総称体を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can use optional chaining to invoke an optional protocol method on a possibly nil object and unwrap the possible result using if–let syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたはオプショナル連鎖を使用することで、オプショナルのプロトコルメソッドをもしかするとnilであるオブジェクト上で呼び出してif–let構文を使って可能な結果をアンラップすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can use the autoreleasepool(_:) function to execute a closure within an autorelease pool block.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたはautoreleasepool(_:)関数を使って、あるクロージャをオートリリース・ブロックの内部で実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you do this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたはこうします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you must use the full name of your document subclass, including the module name derived from the name of your app or framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、あなたは、あなたのアプリまたはフレームワークの名前から引き出されるモジュール名を含めて、あなたのドキュメントサブクラスの完全な名前を使う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you specify these property attributes in a different way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、あなたは異なる方法でこれらのプロパティ属性を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you use the @available attribute to control whether a declaration is available to use when building an app for a particular target platform.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたは@available属性を使うことで、ある宣言が利用可能であるかどうかを制御して、特定の対象プラットホームのためにアプリをビルドするときに使うようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you use the Selector type to refer to Objective-C selectors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、あなたはObjective-Cセレクタに言及するためにSelector型を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you write try? to change a throwing expression into one that returns an optional value, and then check whether the value is nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたはtry?を書くことで、スローする式をオプショナルの値を返すものへと変えて、それからその値がnilかどうかを調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to arrays, Swift bridges between the Set type and the NSSet class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列に加えて、スウィフトはSet型とNSSetクラスの間を橋渡しします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, many of the Cocoa frameworks, including Foundation, AppKit, and UIKit refine their APIs to be more natural in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて、Foundation、AppKit、そしてUIKitを含む、多くのCocoaフレームワークは、それらのAPIをSwiftにおいてより自然なものに改良されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both Swift and Objective-C, delegation is often expressed with a protocol that defines the interaction and a conforming delegate property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトとObjective-Cの両方で、委任は、相互作用を定義するプロトコルと準拠している委任プロパティでたいてい表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast with condition compilation in the C preprocessor, conditional compilation blocks in Swift must completely surround blocks of code that are self-contained and syntactically valid.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cプリプロセッサでの条件コンパイルと対照的に、スウィフトでの条件コンパイルブロックは、自給自足で統語論的に有効であるコードのブロックを完全に伴っていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, the methods that perform a selector on a specific thread or after a delay, such as perform(_:on:with:waitUntilDone:modes:) and perform(_:with:afterDelay:), don’t return a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、セレクタを特定のスレッド上やある猶予の後で実行するメソッド、例えばperform(_:on:with:waitUntilDone:modes:)そしてperform(_:with:afterDelay:)は、値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, when Swift code imports Objective-C APIs, the importer replaces Objective-C reference types with their corresponding value types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際、スウィフトコードがObjective-C APIをインポートするとき、インポーターはObjective-C参照型をそれらの対応する値型と置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many cases, you can use Swift language features to extend or simplify existing Cocoa patterns, making them more powerful and easier to use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多くの場合に、あなたは既存のココア・パターンを拡張したり、単純化するためにスウィフト言語の特徴を働かせることができます。そして、それらをより強力でより使いやすくします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most cases, it’s safer and more convenient to cast the object to AnyObject and use optional chaining with a method call as described in id Compatibility.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの場合には、より安全でいっそう便利なのはそのオブジェクトをAnyObjectにキャストして、メソッド呼び出しとともにオプショナル連鎖を使うことです、id互換性で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most cases, you should not need to modify this setting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの場合、あなたはこの説定を修正する必要がないはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to preserve namespacing when a Swift class is used in Objective-C code, Swift classes are exposed to the Objective-C runtime with their fully qualified names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトクラスがObjective-Cコードの中で使用されるときに名前空間を保護する目的で、スウィフトクラスたちはそれらの完全修飾名を使ってObjective-Cランタイムに露出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to retrieve a Swift class, the fully qualified name, including the name of the app, is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるスウィフトクラスを取り出すために、その完全修飾名が、そのアプリの名前を含めて、使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, the behavior of __block in Objective-C is the default behavior for variables in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言い換えると、Objective-Cでの__blockの挙動は、スウィフトの中の変数のための初期状態での挙動です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, you need finer grained control over how your Swift API is exposed to Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの場合に、あなたはよりきめ細かな管理をあなたのスウィフト APIがObjective-Cに露出される方法に対して必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the CFArrayCallBacks initializer uses nil values as arguments for the retain and release parameters, the customCopyDescription(_:) function as the argument for the customCopyDescription parameter, and a closure literal as the argument for the equal parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、CFArrayCallBacksイニシャライザはnil値をretainとreleaseパラメーターに対する引数として、customCopyDescription(_:)関数をcustomCopyDescriptionパラメーターに対する引数として、そしてクロージャリテラルをequalパラメーターに対する引数として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, changing the value of the isAlive computed property on an instance of the SchroedingersCat structure also changes the value of the instance’s isDead computed property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例において、isAlive計算プロパティの値をSchroedingersCat構造体のインスタンス上で変更することは、またそのインスタンスのisDead計算プロパティの値も変更します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the NSClassFromString(_:) function is used to retrieve a reference to a class from its string representation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例において、NSClassFromString(_:)関数は、あるクラスへの参照をそれの文字列表現から取り出すために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In your Objective-C bridging header file, import every Objective-C header you want to expose to Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのObjective-C橋渡しヘッダ・ファイルにおいて、あなたがスウィフトに露出したいあらゆるObjective-Cヘッダをインポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In your umbrella header file, import every Objective-C header you want to expose to Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのアンブレラヘッダ・ファイルにおいて、あなたがスウィフトに露出したいあらゆるObjective-Cヘッダをインポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Individual type declarations can be audited using the _Nullable and _Nonnull annotations, individual property declarations can be audited using the nullable, nonnull and null_resettable property attributes, or entire regions can be audited for nullability using the NS_ASSUME_NONNULL_BEGIN and NS_ASSUME_NONNULL_END macros.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>個々の型宣言は_Nullableと_Nonnull注釈を使って監査されることができます、個々のプロパティ宣言はnullable、nonnull、そしてnull_resettableプロパティ属性を使って監査されることができます、または領域全体がヌル許可について監査されることがNS_ASSUME_NONNULL_BEGINとNS_ASSUME_NONNULL_ENDマクロを使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inheriting from Objective-C Classes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cクラスから継承する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer methods are imported by Swift with double underscores (__) prepended to their first argument labels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザメソッドは、二重アンダースコア（__）をそれの最初の引数ラベルの前に付けられてスウィフトによってインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, create an Objective-C or C wrapper for C++ code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、C++コードのためにObjective-CまたはCラッパーをつくってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, import the Xcode-generated header file for your Swift code into any Objective-C .m file you want to use your Swift code from.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、あなたのスウィフトコードのためのXcode生成のヘッダ・ファイルを、あなたがそのコードを使いたい何らかのObjective-C .mファイルにインポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it takes advantage of compile-time attributes, conditional compilation blocks, and language features to accomplish the same functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、それは同じ機能性を達成するために、さまざまなコンパイル時属性、条件コンパイルブロック、そして言語機能を活用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, use the Int.init(bitPattern:) initializer to interpret the optional pointer as an Int, which has the same C variadic calling conventions as a pointer on all supported platforms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、Int.init(bitPattern:)イニシャライザを使ってオプショナルポインタをIntとして解釈してください、それはすべてのプラットホーム上でポインタと同じCの可変長引数呼び出し取り決めを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, you can forward declare a Swift class or protocol to reference it in an Objective-C interface.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、あなたはスウィフトのクラスやプロトコルを先に宣言して、Objective-Cインターフェイスにおいてそれを参照することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, you represent a value that could be missing by wrapping the type of the value in an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに、あなたは見つからない値を、その型の値をオプショナル型の中にラップすることによって表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integrating with Interface Builder</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インタフェースビルダーと統合する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interacting with C APIs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C APIとの相互作用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interacting with Objective-C APIs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C APIとの相互作用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interoperability</seg>
      </tuv>
      <tuv lang="JA">
        <seg>相互運用性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interoperability lets you write Swift code that incorporates Objective-C behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>相互運用性は、あなたにObjective-C挙動を取り入れるスウィフトコードを書かせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interoperability makes it possible to integrate those features back into Objective-C code with no hassle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>相互運用性は、それらの特徴をObjective-Cコードに逆に戻って統合することを面倒なしで可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introspection</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自己観察</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Invoking a method using a selector is inherently unsafe, because the compiler cannot make any guarantees about the result, or even guarantee whether the object responds to the selector.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドをセレクタを使って発動することは、本質的に安全ではありません、なぜならコンパイラはその結果についてどんな保証も、またはオブジェクトがセレクタに応答するかどうかの保証さえもすることが不可能だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also contains those marked with the internal modifier if your app target has an Objective-C bridging header.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、あなたのアプリターゲットがObjective-C橋渡しヘッダを持つならば、それらをinternal修飾子で印して含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also supports chaining through optional values within a chain, such as #keyPath(Person.bestFriend.name).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、ある数珠つなぎ内でオプショナル値を通した連鎖をサポートします、例えば#keyPath(Person.bestFriend.name)など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be thought of as an umbrella header for your Swift code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、あなたのスウィフトコードのためのアンブレラヘッダとみなされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It imports Objective-C class factory methods as Swift initializers, and Objective-C enumeration cases truncated names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはObjective-Cファクトリメソッドをスウィフトイニシャライザとして、そして名前の先端を切ったObjective-C列挙をインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as in Objective-C, before you send a message that a delegate may not respond to, you ask the delegate whether it responds to the selector.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ちょうどObjective-Cでのように、あなたが委任先が応答しないかもしれないメッセージを送る前に、あなたはその委任先にそれがセレクタに応答するかどうか尋ねます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key paths created using key-path expressions include type information about the properties they reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパス式を使って作成されるキーパスは、それらが参照するプロパティについての型情報を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key-Value Observing</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キー値監視</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key-value observing is a mechanism that allows objects to be notified of changes to specified properties of other objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キー値監視は、オブジェクトが他のオブジェクトの指定されたプロパティに対する変更を通知されるようにする仕組みです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keys and Key Paths</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーとキーパス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keys and key paths are also used for key-value observing (KVO), a mechanism that enables an object to be notified directly when a property of another object changes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーとキーパスはまた、他のオブジェクトのプロパティが変化した時にあるオブジェクトが直接に通知されることを可能にする仕組み、キー値監視（KVO）のためにも使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keys and key paths are frequently used for key-value coding (KVC), a mechanism for indirectly accessing an object’s attributes and relationships using string identifiers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーとキーパスは、文字列識別子を使ってオブジェクトの属性および関連付け（リレーションシップ）に間接的にアクセスするための仕組み、キー値コーディング（KVC）のためにしばしば使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lazy Initialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lazy properties are useful when the initial value for a property either requires complex or computationally expensive setup, or cannot be determined until after an instance’s initialization is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延プロパティが便利なのは、あるプロパティに対する初期値が、複雑なもしくは計算的に高くつく準備を必要とする、またはあるインスタンスの初期化が完了する後まで決定されることが出来ない、このどちらかである場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lightweight Generics</seg>
      </tuv>
      <tuv lang="JA">
        <seg>軽量総称体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like a C function pointer, a Swift function type with the @convention(c) attribute does not capture the context of its surrounding scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C関数ポインタのように、@convention(c)属性を持つスウィフト関数型は、それを取り囲んでいるスコープのコンテキストをキャプチャしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like blocks in Objective-C, closures in Swift also maintain strong references to any captured objects, including self.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでのブロックのように、スウィフトでのクロージャもまた、selfを含めて、あらゆるキャプチャされたオブジェクトに対する強い参照を管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, when Objective-C code imports Swift APIs, the importer also replaces Swift value types with their corresponding Objective-C reference types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、Objective-Cコードがスウィフト APIをインポートするとき、インポーターはまたスウィフト値型をそれらの対応するObjective-C参照型と置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Live Rendering</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ライブレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Localization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現地語化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Making Objective-C Interfaces Unavailable in Swift</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cインターフェイスをスウィフトで利用できなくする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many Objective-C initializers in system frameworks have been audited to indicate whether initialization can fail.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>システムフレームワークの中の多くのObjective-Cイニシャライザは、初期化が失敗する可能性があるかどうか検査されてしまっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of these patterns rely on classes defined in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのパターンの多くは、Objective-Cで定義されるクラスに頼ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Memory Managed Objects</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリ管理オブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods are imported and called as described in Working with Methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドは、メソッドを扱うで記述されるように、インポートされ呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods that consume errors, such as delegate methods or methods that take a completion handler with an NSError object argument, do not become methods that throw when imported by Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーを食べ尽くすメソッド、例えば委任先メソッドたちや完了ハンドラをNSErrorオブジェクト引数で取るメソッドたちは、スウィフトによってインポートされる時にスローするメソッドになりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Migrating Your Objective-C Code to Swift</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのObjective-Cコードのスウィフトへの移行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Migration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>移行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mix and Match</seg>
      </tuv>
      <tuv lang="JA">
        <seg>混合と適合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mix and Match Overview</seg>
      </tuv>
      <tuv lang="JA">
        <seg>混合と適合の概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mix-and-match functionality makes it easy to choose which features and functionality to implement in Swift, and which to leave in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>混合と適合の機能性は、どの特徴と機能性をスウィフトにおいて実装するか、そしてどれをObjective-Cのままにしておくべきかを選択をするのを容易にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the Objective-C system frameworks, including Foundation, already provide nullability annotations, allowing you to work with values in an idiomatic and type-safe manner.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどのObjective-Cシステムフレームワーク、Foundationを含む、は、すでにヌル可能注釈を提供し、あなたに慣用句的な型安全な手法で値を扱えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mutable Pointers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変ポインター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NSCoding</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NSCodingプロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>NSUndoManager supports two ways to register undo operations: a “simple undo”, which performs a selector with a single object argument, and an “invocation-based undo”, which uses an NSInvocation object that takes any number and any type of arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NSUndoManagerは、取り消し操作を登録する２つの方法をサポートします：ただ１つのオブジェクト引数を使ってセレクタを実行する「単純な取り消し」、そして随意の数の随意の型の引数を取るNSInvocationオブジェクトを使う「呼び出し基盤の取り消し」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naming Your Product Module</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたの製品モジュールに名前をつける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New document that describes various aspects of Swift 1.0 and its compatibility with the Objective-C language and Cocoa/Cocoa Touch frameworks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのObjective-C言語やCocoa／Cocoa Touchフレームワークとの互換性の様々な面を解説する新しい文書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No import statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポート文なし</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No import statement; Objective-C bridging header required</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポート文なし；Objective-Cブリッジヘッダ必須</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No import statement; Objective-C umbrella header required</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポート文なし；Objective-Cアンブレラヘッダ必須</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that after this cast, the dataSource constant is of type UITableViewDataSource, so you can only call methods and access properties defined on the UITableViewDataSource protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このキャストの後で、dataSource定数は型UITableViewDataSourceである点に注意してください、なのであなたはUITableViewDataSourceプロトコル上で定義されるメソッド呼び出しとプロパティアクセスができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the Swift interfaces in the generated header include references to all of the Objective-C types used in them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生成されたヘッダの中のスウィフトインタフェースたちが、それらの中で使われるObjective-C型への全ての参照を含む点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this list does not include arrays.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このリストが配列を含まない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Noted that C function pointers are now imported as CFunctionPointer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C関数ポインターは現在はCFunctionPointerとしてインポートされることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Noted that the compiler does not implicitly synthesize the @objc attribute for private methods and properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラはプライペートなメソッドおよびプロパティのための@objc属性を暗黙的に合成して作り出さないことを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Noted that types that are pointed to, like NSString **, are not bridged.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポインターを付けられる型、NSString **のようなものは、ブリッジされないことを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice also that “init” doesn’t appear anywhere when calling the Swift-style initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>またスウィフト形式のイニシャライザを呼ぶとき「init」がどこにも現れないことに注目してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that the removeItem(at:) method is imported by Swift with a Void return type, no error parameter, and a throws declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>removeItem(at:)メソッドがスウィフトによってVoidの戻り型で、errorパラメーターなしで、そしてthrows宣言でインポートされることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that you don’t need to call alloc; Swift handles this for you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがallocを呼ぶ必要がないことに注意してください；スウィフトは、これをあなたの代わりに処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Null Pointers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ヌルポインタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nullability and Optionals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ヌル許可とオプショナル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numbers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Object Comparison</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクト比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Object subscripting methods are imported by Swift as methods with double underscores (__) prepended to their base names, rather than as a Swift subscript, if either the getter or setter method is marked as NS_REFINED_FOR_SWIFT.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクト添え字メソッドは、二重アンダースコア（__）をそれのベース名の前に付けられてスウィフトによってメソッドとしてインポートされます、スウィフト添え字としてではなく、もしゲッターとセッターメソッドの両方がNS_REFINED_FOR_SWIFTと印付けされるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C Reference Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C参照型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C and Swift files can coexist in a single project, whether the project was originally an Objective-C or Swift project.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロジェクトが元々はObjective-Cかスウィフトのプロジェクトであったかどうかに関係なく、Objective-Cとスウィフトのファイルは一つのプロジェクトにおいて共存することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C blocks are automatically imported as Swift closures with Objective-C block calling convention, denoted by the @convention(block) attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cのブロックは、Objective-Cのブロック呼出規約をもつスウィフトのクロージャとして自動的にインポートされ、それは@convention(block)属性で分かります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C can use nullability annotations to designate whether a parameter type, property type, or return type, can have a NULL or nil value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cは、ヌル許可注釈を使って、あるパラメーター型、プロパティ型、または戻り値型がNULLまたはnil値を持つことが可能かどうか任命できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C classes qualified by one or more protocols are imported by Swift as protocol composition types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つ以上のプロトコルによって適格にされるObjective-Cクラスは、スウィフトによってプロトコル合成型としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C code</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C frameworks can use custom error domains and enumerations to group related categories of errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cフレームワークは、カスタムエラードメインと列挙を使って、エラーの関連カテゴリをグループ化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C frameworks vend APIs in header files.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cフレームワークは、ヘッダ・ファイルの中のAPIを販売します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C initializers begin with init, or initWith: if the initializer takes one or more arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cイニシャライザは、initで、またはイニシャライザがひとつ以上の引数をとるならばinitWith:で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C initializers that indicate whether they’re failable are imported as either init(...)—if initialization cannot fail—or init?(...)—if initialization can fail.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが失敗できるかどうか指し示すObjective-Cイニシャライザは、初期化が失敗できないならば ― init(...)、または初期化が失敗できるならば ― init?(...)、このどちらかでインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C methods that return a value and take no arguments can be called like an Objective-C property using dot syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値を返して引数を取らないObjective-Cメソッドは、Objective-Cプロパティのように呼び出すことがドット構文を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C platform-adaptive integer types, such as NSUInteger and NSInteger, are bridged to Int.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cのプラットホーム順応性の整数型、例えばNSUIntegerとNSIntegerなどは、Intにブリッジされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C property declarations using the @property syntax are imported as Swift properties in the following way:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cプロパティ宣言で@property構文を使っているものは、スウィフトプロパティとして以下の方法でインポートされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C protocol-qualified metaclasses are imported by Swift as protocol metatypes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cのプロトコル適格メタクラスは、スウィフトによってプロトコルメタタイプとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C protocols are imported as Swift protocols, which can be adopted by a class in a comma-separated list following the name of a class’s superclass, if any.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cプロトコルは、スウィフトプロトコルとしてインポートされます、そしてそれは、クラスによって採用されることが、もしあればクラスのもつスーパークラスの名前に続けて、コンマ区切りのリストに入れて、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objective-C type declarations using lightweight generic parameterization are imported by Swift with information about the type of their contents preserved.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>軽量総称体パラメーター化を使っているObjective-C宣言は、それらの保管される内容についての情報を使ってスウィフトによってインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objects in an app’s responder chain—that is, subclasses of NSResponder on macOS and UIResponder on iOS—have a read-only undoManager property that returns an optional NSUndoManager value, which manages the undo stack for the app.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アプリのレスポンダ連鎖の中のオブジェクト ― すなわち、macOSでのNSResponderそしてiOSでのUIResponderのサブクラス ― は、読み出し専用のundoManagerプロパティを持ちます、それはオプショナルのNSUndoManager値を返します、そして取り消しスタックをアプリのために管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On macOS, you typically open an app by clicking its icon in the Dock or Launchpad, or by double-clicking its icon from the Finder.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>macOSでは、あなたは通常はアプリをそれのアイコンをDockまたはLaunchpadでクリックすることで、またはそれのアイコンをFinderからダブルクリックすることで開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you import your Swift code into Objective-C, use regular Objective-C syntax for working with Swift classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦あなたがObjective-Cにあなたのスウィフトコードをインポートするならば、一般的なObjective-C構文をスウィフトクラスを扱うために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you migrate a class to Swift, you must remove the corresponding .m file from the target before building to avoid a duplicate symbol error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦あなたがあるクラスをスウィフトに移行したならば、あなたは、ビルドの前にそのターゲットから対応する.mファイルを取り除いて重複シンボル・エラーを避けなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One aid in writing well-designed, resilient apps is to use Cocoa’s established design patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>よく設計された、溌剌としたアプリを記述することでの１つの援助は、ココアのいくつかの確立したデザインパターンを使うことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One important aspect of interoperability is that it lets you work with Objective-C APIs when writing Swift code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>相互運用性の１つの重要な面は、スウィフトコードを書くとき、それがあなたにObjective-C APIを扱わせるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the primary advantages of value types over reference types is that they make it easier to reason about your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>参照型を超える値型の主要な利点の１つは、それらがあなたのコードについて考えるのをより簡単にすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One-Time Initialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ワンタイム初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only Swift function types with C function reference calling convention may be used for function pointer arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C関数参照呼出手法を持つスウィフト関数型だけが、関数ポインタ引数のために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Option Sets</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプションセット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Option sets behave like Swift’s Set collection type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプションセットは、スウィフトのSetコレクション型に似た振る舞いをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Option sets behave similarly to imported enumerations by truncating their prefixes to option value names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプションセットは、それらのオプション値名の接頭辞を切り取ることでインポートされた列挙と同じように振舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Option-click a symbol to see implicit information about it, like its type, attributes, and documentation comments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シンボルをオプション-クリックして、それに関する暗黙表示の情報、その型、属性、そして注釈文書などを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional pointers cannot be passed to the withVaList(_:invoke:) function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルポインタは、withVaList(_:invoke:)関数に渡されることが可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or, an app may require more complex usage in order to use localization resources from a separate bundle:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>または、独立したバンドルから現地語化リソースを使うために、アプリはより複雑な語法を必要とするかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other methods are imported with double underscores (__) prepended to their base names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のメソッドは、二重アンダースコア（__）をそれのベース名の前に付けられてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, Objective-C initializers are imported as init!(...).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それ以外では、Objective-Cイニシャライザは、init!(...)としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, Swift bridges the optional as its unwrapped value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、スウィフトはそのオプショナルをそれのアンラップされた値としてブリッジします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, continue on to learn about working with unmanaged Core Foundation objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一方で、管理されないコアファウンデーション・オブジェクトを扱うことについて学ぶためには続けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, if no convention can be inferred, the method is left intact.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それ以外では、推論されることができる慣行がないならば、メソッドは元のままにしておかれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Outlets and actions allow you to connect your source code to user interface objects in Interface Builder.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アウトレットとアクションによって、あなたは、あなたのソース・コードをインタフェースビルダーのユーザー・インタフェースオブジェクトに接続することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding Swift Names for Objective-C Interfaces</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cインターフェイスのためのスウィフト名のオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Platform-specific classes, such as NSBackgroundActivity, NSUserNotification, and NSXPCConnection</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プラットホーム特有のクラス、例えばNSBackgroundActivity、NSUserNotification、そしてNSXPCConnectionなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pointer Arithmetic</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポインタ算術</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pointer initializers taking the integer representation of an address in memory are failable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリ中のあるアドレスの整数表現をとるポインタイニシャライザは失敗可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pointers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポインター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preparing Your Objective-C Code for Migration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>移動のためのあなたのObjective-Cコードの準備</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preprocessor Directives</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プリプロセッサ指令</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primitive Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Print the return value of the method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドの戻り値を出力する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Private declarations are not exposed to Objective-C unless they are explicitly marked with @IBAction, @IBOutlet, or @objc.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プライベートな宣言はObjective-Cにさらされません、それらが明示的に@IBAction、@IBOutlet、または@objcで印されない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Private declarations are not exposed to Objective-C unless they are explicitly marked with @IBAction, @IBOutlet, or @objc.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プライベートな宣言はObjective-Cにさらされません、それらが明示的に@IBAction、@IBOutlet、または@objcで印されない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing Command-Line Arguments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コマンドライン引数の処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties with an ownership property attribute other than weak (that is, assign, copy, strong, or unsafe_unretained) are imported as Swift properties with the appropriate storage.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>weakとは別の所有者プロパティ属性（すなわち、assign、copy、strong、またはunsafe_unretained）を持つプロパティは、スウィフトプロパティとしてインポートされるのに適切なストレージを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties with the class property attribute are imported as Swift type properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>classプロパティ属性を持つプロパティは、スウィフト型プロパティとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties with the readonly property attribute are imported as Swift computed properties with a getter ({ get }).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>readonlyプロパティ属性を使うプロパティは、スウィフト計算プロパティとしてインポートされるのにゲッター（{ get }）を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties with the weak property attribute are imported as Swift properties marked with the weak keyword (weak var).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>weakプロパティ属性を使うプロパティは、weakキーワード（weak var）で印されるスウィフトプロパティとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties with the nullability property attributes (nonnull, nullable, and null_resettable) are imported as Swift properties with optional or nonoptional type as described in Nullability and Optionals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ヌル許可プロパティ属性（nonnull、nullable、そしてnull_resettable）を使ったプロパティは、スウィフトプロパティとしてインポートされるのにオプショナルまたは非オプショナル型を使います、ヌル許可とオプショナルで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol-Qualified Classes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル適格クラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than defining separate functions that correspond to each Objective-C macro, the Swift NSLocalizedString(_:tableName:bundle:value:) function specifies default values for the tableName, bundle, and value arguments, so that they may be overridden as necessary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのObjective-Cマクロに対応した独立した関数を定義するのではなく、スウィフトのNSLocalizedString(_:tableName:bundle:value:)関数はtableName、bundle、そしてvalue引数に省略時の値を指定します、それでそれらは必要に応じてオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read/Write and Read-Only</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「読み/書き」と「読み出し専用」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Referencing a Swift Class or Protocol in an Objective-C Header</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのクラスやプロトコルをObjective-Cヘッダにおいて参照する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Refining Objective-C Declarations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C宣言を改良する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remap certain Objective-C concepts to matching concepts in Swift, like pointers to optionals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定のObjective-C概念をスウィフトでの匹敵する概念にリマップします、ポインターをオプショナルへ、のように</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remap certain Objective-C core types to their alternatives in Swift, like NSString to String</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定のObjective-Cコア型をスウィフトでのそれらの代替物にリマップします、NSStringをStringへ、のように</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remap certain Objective-C types to their equivalents in Swift, like id to Any</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定のObjective-C型をそれらのスウィフトでの等価物にリマップ（関数を別のキーに割り当てる）します、idをAnyに、のように</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remapped Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リマップされた型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember that you cannot subclass a Swift class in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがObjective-Cにおいてスウィフトクラスをサブクラス化することができないことを忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remember to add a colon (:) wherever a parameter follows a selector piece.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるセレクタ片にパラメータが続くところはどこにでも、コロン（:）を加えるのを忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remove the original Objective-C .m file from the target by deselecting the target membership checkbox.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ターゲットから本来のObjective-C .mファイルを、ターゲットメンバーシップ・チェックボックスの選択を外すことによって取り除いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Renamed Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>改名された型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requiring Dynamic Dispatch</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動的なディスパッチを要求する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requiring this kind of dynamic dispatch is rarely necessary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この種の動的なディスパッチの要請は、めったに必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Revision History</seg>
      </tuv>
      <tuv lang="JA">
        <seg>改訂履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Data Type Size Calculation for more information about how Swift calculates the sizes of data types and values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>データ型サイズ計算をスウィフトがデータ型と値の大きさを計算する方法についての詳細のために見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Unmanaged Objects for more information.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として管理されないオブジェクトを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Selectors</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セレクタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Serialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シリアライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Serialization allows you to encode and decode objects in your app to and from architecture-independent representations, such as JSON or property lists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シリアライズは、オブジェクトをあなたのアプリにおいてアーキテクチャ非依存の表現、例えばJSONやプロパティリストなどに符号化および復号化できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Up Your Swift Environment</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのスウィフト環境を設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, NSSet declarations without a class-qualified object type are imported by Swift as a Set with the Element type AnyHashable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、クラス適格オブジェクト型なしでのNSSet宣言は、スウィフトによってElement型AnyHashableを持つSetとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if an error producing Objective-C method returns a nil value to indicate the failure of a method call, Swift changes the return type of the function to a nonoptional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、エラーを生成しているObjective-Cメソッドがnil値を返してメソッド呼び出しの失敗を指し示すならば、スウィフトは関数の戻り型を非オプショナル型に変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, you can use the JSONDecoder and PropertyListDecoder classes to decode and initialize instances from JSON or property list data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、あなたはJSONDecoderとPropertyListDecoderクラスを使って、インスタンスをJSONまたはプロパティリストデータからデコードして初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, you use the availability condition #available to execute code conditionally based on required platform and version conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、あなたは利用可能性条件#availableを使うことで、必要なプラットホームおよびバージョン条件に基づいて、条件付きでコードを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simple Macros</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単純なマクロ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simplified the instructions in the Basic Setup chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの指示を基本の準備章において簡略化した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simply import the appropriate module, and refer to the class, structure, or enumeration by the same name that you would use in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単に適切なモジュールをインポートしてください、そしてあなたがObjective-Cで使うだろうのと同じ名前によって、そのクラス、構造体、または列挙を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Singleton</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シングルトン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Singletons provide a globally accessible, shared instance of an object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シングルトンは、全体で利用できる、共有されるひとつのインスタンスを、あるオブジェクトに提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Objective-C interfaces may not be suitable or necessary to be exposed as Swift interfaces.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかのObjective-Cインターフェイスは、スウィフトインターフェイスとして露出されるのにふさわしくないもしくは必要でない可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Swift APIs do not map back to Objective-C because they leverage language features that are not available in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト若干のAPIは、Objective-Cへと逆にマップされません、なぜならそれらがObjective-Cで利用できない言語機能に影響を及ぼすからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some classes and methods are not available to all versions of all platforms that your app targets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかのクラスやメソッドは、あなたのアプリターゲットであるすべてのプラットホームのすべてのバージョンで利用可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying Property Attributes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティ属性を指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strong and Weak</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強い、弱い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures defined in Swift</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて定義される構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subclasses of classes that adopt NSCoding that have one or more custom initializers or any properties without initial values must also implement this method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NSCodingを採用するクラスのサブクラスで１つ以上のカスタムイニシャライザまたはなんらかの初期値なしのプロパティを持つものは、同様にこのメソッドを実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift APIs are translated into Objective-C similar to how Objective-C APIs are translated into Swift, but in reverse:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのAPIは、Objective-C APIがスウィフトへと翻訳される方法と同じように、しかし逆に、Objective-Cへと翻訳されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift APIs that are callable from Objective-C must be available through dynamic dispatch.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cから呼び出し可能なスウィフトAPIは、動的ディスパッチを通して利用可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift Type Compatibility</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト型互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift Value Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト値型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also bridges between the Dictionary type and the NSDictionary class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、Dictionary型からNSDictionaryクラスへ橋渡しします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also imports C enumerations marked with the NS_OPTIONS macro as a Swift option set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、NS_OPTIONSマクロで印を付けられるCの列挙をスウィフトオプションセットとしてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also includes an AnyObject type that represents some kind of object and has the special ability to look up any @objc method dynamically.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまたAnyObject型を含んでいます。それは何かわからないある種類のオブジェクトを表します、そしてどれかの@objcメソッドを動的に検索する特別な能力を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also provides a way of working with common C constructs and patterns, in case your code requires it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、あなたのコードがそれを必要とする場合に備えて、一般的なC構造物とパターンを扱う方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also provides pointer types for working with buffers, which are discussed in Buffer Pointers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまたバッファを扱うためにいくつかのポインタ型を提供します、それらはバッファポインタにおいて解説されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift and Objective-C in the Same Project</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じプロジェクト中のスウィフトとObjective-C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift automatically calls the superclass deinitializer after invoking your subclass’ deinitializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、あなたのサブクラスのデイニシャライザを呼び出した後、自動的にスーパークラスのデイニシャライザを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift automatically converts some Objective-C types to Swift types, and some Swift types to Objective-C types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、いくつかのObjective-C型をスウィフト型に、そしていくつかのスウィフト型をObjective-C型に自動的に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift automatically provides implementations for the logical complements of the equality and identity operators (!= and !==).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、同等性と同一性演算子の論理上当然な補完物（!=と!==）に対する実装を自動的に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift automatically synthesizes conformance to the Equatable protocol for imported C enumeration types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、インポートされたC列挙型に対して自動的にEquatableプロトコルへの準拠を合成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift automatically translates Objective-C methods that produce errors into methods that throw an error according to Swift’s native error handling functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、自動的にエラーを生成するObjective-Cメソッドを、スウィフト固有のエラー処理機能に従ってエラーをスローするメソッドに翻訳します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift bridges between the Array type and the NSArray class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、Array型とNSArrayクラスの間での橋渡しをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift bridges between the NSNumber class and Swift numeric types, including Int, Double, and Bool.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはNSNumberクラスと、Int、Double、およびBoolを含むスウィフト数値型の間をブリッジします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift bridges between the String type and the NSString class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スフィフトは、String型とNSStringクラスの間をブリッジします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift bridges optional values to nonnullable Objective-C objects according to whether the optional contains an underlying, wrapped value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、オプショナル値をnull不可Objective-Cオブジェクトへと、そのオプショナルがその下に隠している、ラップされた値を持つかどうかに従ってブリッジします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift classes are namespaced based on the module they are compiled in, even when used from Objective-C code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトクラスは、それらがコンパイルされているモジュールに基づく名前空間に置かれます、Objective-Cコードから使用される時でさえもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift closures and Objective-C blocks are compatible, so you can pass Swift closures to Objective-C methods that expect blocks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのクロージャとObjective-Cのブロックは互換性を持つので、ブロックを要求するObjective-Cメソッドに、あなたはスウィフトクロージャを渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift closures and functions have the same type, so you can even pass the name of a Swift function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのクロージャと関数は同じ型を持つので、あなたはスウィフト関数の名前を渡しさえすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift code</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift code and Objective-C code are conditionally compiled in different ways.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコードとObjective-Cコードは、異なる方法で条件付きコンパイルされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift code can be conditionally compiled using conditional compilation blocks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコードは、条件コンパイルブロックを使って条件付きコンパイルされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift code can use the availability of APIs as a condition at run-time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコードは、APIの有効性をひとつの条件として使うことが実行時に可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift code uses var and let to control mutability, so it doesn’t need both classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコードは、varとletを使って可変性を制御します、それでそれは両方のクラスを必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift constant stored properties and computed properties become read-only Objective-C properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの定数格納プロパティと計算プロパティは、読出し専用Objecive-Cプロパティになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift declarations marked with the private or fileprivate modifier do not appear in the generated header.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>privateまたはfileprivate修飾子で印される宣言は、生成されたヘッダの中に現れません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift deinitializers are called automatically, just before instance deallocation happens.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトデイニシャライザは、ちょうどインスタンスの割り当て解除が起こる前に、自動的に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift enumerations conforming to the Error protocol and declared with the @objc attribute produce an NS_ENUM declaration, as well as an NSString constant for the corresponding error domain in the generated header.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Errorプロトコルに準拠していて@objc属性で印されるスウィフト列挙は、生成ヘッダにおいてNS_ENUM宣言、それだけでなく対応するエラードメインに対するNSString定数を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has the following buffer pointer types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、以下のバッファポインタ型を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift imports C unions as Swift structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、C共用体をスウィフト構造体としてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift imports Objective-C declarations of NSDictionary that don’t specify a class qualification for the key type as a Dictionary with the Key type AnyHashable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、キー型に対してクラス資格を指定しないNSDictionaryのObjective-C宣言を、Key型AnyHashableを持つDictionaryとしてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift imports any C enumeration marked with the NS_ENUM macro as a Swift enumeration with an Int raw value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、NS_ENUMマクロで印を付けられるどんなCの列挙でも、生の値型Intを持つスウィフト列挙としてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift imports any C structure declared in a C header as a Swift structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、Cヘッダにおいて宣言されるどんなC構造体もスウィフト構造体としてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift imports any function declared in a C header as a Swift global function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、Cヘッダにおいて宣言されるどんな関数もスウィフトのグローバルな関数としてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift imports bit fields in structures, such those found in Foundation’s NSDecimal type, as computed properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、構造体においてビットフィールド、FoundationのNSDecimal型において見つけられるものなどを、計算プロパティとしてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift initializers and instance methods become Objective-C instance methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのイニシャライザとインスタンスメソッドは、Objective-Cインスタンスメソッドになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift is designed to provide seamless compatibility with Cocoa and Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、ココアとObjective-Cに継ぎ目のない互換性を提供するように設計されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift methods and properties that are marked with the internal modifier and declared within a class that inherits from an Objective-C class are accessible to the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cクラスから継承するクラスの内部で宣言されてinternal修飾子で印されるスウィフトのメソッドとプロパティは、Objective-Cランタイムへとアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift methods that throw errors become Objective-C methods with an NSError ** parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーをスローするスウィフトメソッドは、NSError **パラメータを持つObjective-Cメソッドになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift nonoptional types are annotated as __nonnull.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの非オプショナル型は、__nonnullとして注釈を付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift numeric types (Int, Float, and so on.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト数値型（Int、Float、など）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift optional types are annotated as __nullable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのオプショナル型は、__nullableとして注釈を付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift properties are strong by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトプロパティは、特に何もしなければ強いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides default implementations of the == and === operators and adopts the Equatable protocol for objects that derive from the NSObject class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、==と===演算子の省略時の実装を提供します、そしてEquatableプロトコルをNSObjectクラス由来のオブジェクトに対して採用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides equivalents of C primitive integer types—for example, char, int, float, and double.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、Cの基本の整数型の等価物を提供します ― 例えば、char、int、float、そしてdouble。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift type methods become Objective-C class methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの型メソッドは、Objective-Cクラスメソッドになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift type properties become Objective-C properties with the class property attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト型プロパティは、classプロパティ属性を持つObjective-Cプロパティになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift uses optionals to guard against such unsafe behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、オプショナルを使用してこのような安全でない挙動の発生を防ぐことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift variable stored properties become read-write Objective-C properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの変数格納プロパティは、読み書き両用のObjective-Cプロパティになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift vends its APIs—such as from a framework—as Swift modules.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、そのAPIを  ― 例えばフレームワークから ― スウィフトモジュールとして売り渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift will see every header you expose publicly in your umbrella header.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、あなたがあなたのアンブレラヘッダにおいて公的に露出するあらゆるヘッダを見るようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift wraps these returned Core Foundation objects in an Unmanaged&lt;Instance&gt; structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、これらの返されたコアファウンデーション・オブジェクトをUnmanaged&lt;T&gt;構造体に包みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift-style variadics</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト形式の可変長引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s compatibility with Objective-C lets you create a project that contains files written in either language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cとのスウィフトの互換性は、あなたにどちらの言語ででも記述されるファイルを含むプロジェクトをつくらせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Taking the previous example, you can check availability in an if statement to call requestWhenInUseAuthorization() only if the method is available at runtime:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以前の例をとって、あなたは有効性をif文の中で確認して、requestWhenInUseAuthorization()をそのメソッドが実行時に有効である場合にのみ呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Target-Action</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ターゲット-アクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Target-action is a common Cocoa design pattern in which one object sends a message to another object when a specific event occurs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ターゲット-アクションは、特定のイベントが起こる時にあるオブジェクトが別のオブジェクトにメッセージを送る場合の、一般的なココア・デザインパターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That way, Swift can handle memory management for you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのように、スウィフトはあなたの代わりにメモリ管理をうまく取り扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The @IBOutlet attribute no longer implicitly declares a property as optional and weak.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@IBOutlet属性はもはやプロパティを暗黙的にオプショナルや弱いとして宣言しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The AnyHashable type is used by Swift when importing Objective-C declarations with an unspecified or id type that cannot be otherwise be imported as Any because the type needs to conform to the Hashable protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AnyHashable型は、スウィフトによって、idまたは未指定型を持つObjective-C宣言をインポートする時に使われます、それはそうでなければAnyとしてインポートされることができません、なぜならその型はHashableプロトコルに準拠する必要があるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Cake structure is imported with a memberwise initializer that you can use to initialize the structure with custom values for its fields, as seen below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cake構造体は、メンバー関連イニシャライザでインポートされます、それはあなたが構造体をそれのフィールドに誂えの値を使って初期化するのに使うことができるものです、下で見られるように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The NSCoding protocol requires that conforming types implement the required initializer init(coder:) and the required method encode(with:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NSCodingプロトコルは、準拠している型が必須イニシャライザinit(coder:)および必須メソッドencode(with:)を実装することを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Unmanaged&lt;Instance&gt; structure provides two methods to convert an unmanaged object to a memory managed object—takeUnretainedValue() and takeRetainedValue().</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Unmanaged&lt;T&gt;構造体は、管理されないオブジェクトをメモリ管理されたオブジェクトに変換するために、２つのメソッドを提供します ― takeUnretainedValue()とtakeRetainedValue()。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The arch(arm) platform condition does not return true for ARM 64 devices.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>arch(arm)プラットホーム条件は、ARM 64機器に対してtrueを返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name and friends properties are both declared with the @NSManaged attribute to indicate that Core Data provides their implementation and storage at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>nameとfriendsプロパティは、両方とも@NSManaged属性を使って宣言され、コアデータがそれらの実装とストレージを実行時に提供することを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The prepare(withInvocationTarget:) method returns a proxy to the specified target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>prepare(withInvocationTarget:)メソッドは、措定されたtargetに対する代理を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The @available attribute uses the same syntax as the #available runtime check, with the platform version requirements provided as comma-delimited arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@available属性は、コンマ区切り引数として提供されるプラットホームバージョン要件を使う、#available実行時確認と同じ構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The NSString class encodes a Unicode-compliant text string, represented as a sequence of UTF–16 code units.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NSStringクラスは、一連のUTF–16コード単位として表される、あるユニコード遵守テキスト文字列を符号化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The as? operator returns an optional value that can be bound to a constant using an if-let statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>as?演算子は、if-let文を使って定数に束縛されることができるオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The is operator returns true if the instance is of that subclass type, and false if it is not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>is演算子は、そのインスタンスがそのサブクラス型であるならばtrueを、それがそうでないならばfalse返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CFArrayCreateMutable(_:_:_:) function takes a CFArrayCallBacks structure, which is initialized with function pointer callbacks:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CFArrayCreateMutable(_:_:_:)関数は、ひとつのCFArrayCallBacks構造体を取ります、それは関数ポインタコールバックで初期化されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The arch(i386) platform condition returns true when code is compiled for the 32–bit iOS simulator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>arch(i386)プラットホーム条件は、コードが32ビットiOSシミュレーターに対してコンパイルされるときtrueを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The getVaList(_:) function takes an array of CVarArg values and returns a CVaListPointer value, whereas the withVaList(_:_:) provides this value within the body a closure parameter rather than returning it directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>getVaList(_:)関数は、CVarArg値からなるひとつの配列をとってCVaListPointer値を返します、一方でwithVaList(_:_:)は、この値を本文内部でクロージャパラメータに提供します、それを直接返すのではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The myCount constant is inferred to be an optional Int, and is set to nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>myCount定数は、オプショナルのIntであると推論されて、nilに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The #keyPath string expression accepts chained method or property references.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>#keyPath文字列式は、数珠つなぎにされたメソッドまたはプロパティ参照を受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The AnyHashable type is implicitly converted from any Hashable type, and you can use the as? and as! operators to cast from AnyHashable to a more specific type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AnyHashable型は暗黙的に何らかのHashable型から変換されます、そしてあなたはas?およびas!演算子を使ってAnyHashableからより具体的な型へキャストできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Core Foundation CFTypeRef type completely remaps to the AnyObject type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コアファウンデーションのCFTypeRef型は、AnyObject型に完全にリマップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Foundation framework provides a base layer of functionality for apps and frameworks, including data storage, text processing, dates and times, sorting and filtering, persistence, and networking.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Foundationフレームワークは、ある基盤階層をアプリとフレームワークのための機能性に関して提供していて、データストレージ、テキスト処理、日付と時刻、ソートとフィルタ、永続、そしてネートワーク処理を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Migration Process</seg>
      </tuv>
      <tuv lang="JA">
        <seg>移動プロセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Objective-C id type is imported by Swift as the Any type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C id型は、スウィフトによってAny型としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Objective-C functionality will be available in any Swift file within that target automatically, without any import statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C機能性は、まったくインポート文なしで、自動的にそのターゲット内のどんなスウィフトファイルにおいても利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift String type is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのString型は、符号化非依存のユニコード文字から構成されます、そしてそれらの文字に様々なユニコード表現においてアクセスするための支援を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift Foundation overlay provides the following bridged value types for the following Objective-C reference types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト Foundationオーバーレイは、以下のブリッジ値型を以下のObjective-C参照型に対して提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift Foundation overlay renames classes and protocols, as well as related enumerations and constants.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト Foundationオーバーレイは、クラスおよびプロトコルを改名します、それだけでなく関連した列挙と定数も。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift compiler automatically imports Objective-C code as conventional Swift code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコンパイラは、自動的にObjective-Cコードを普通の意味でのスウィフトコードとしてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift compiler does not include a preprocessor.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコンパイラは、プリプロセッサを含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift compiler ensures that your initializers do not leave any properties in your class uninitialized to increase the safety and predictability of your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコンパイラは、あなたのコードの安全性と予測可能性を高めるためにあなたのイニシャライザたちがアンイニシャライズされるあなたのクラスにおいて１つのプロパティもそのままにしておかないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift compiler includes attributes that enable Interface Builder features for your Swift classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコンパイラは、あなたのスウィフトクラスのためにインタフェースビルダー機能を可能にする属性を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift files in your framework target will be visible in Objective-C .m files containing this import statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのフレームワークターゲットの中のスウィフトファイルは、このインポート文を含んでいるObjective-C .mファイルにおいて見えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift files in your target will be visible in Objective-C .m files containing this import statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのターゲットの中のスウィフトファイルは、このインポート文を含んでいるObjective-C .mファイルにおいて見えるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The address of that buffer is passed to the callee, and on return, the value in the buffer is loaded, retained, and reassigned into the operand.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのバッファのアドレスは呼び出される側に渡されます、そして戻る時に、バッファの値はロードされ、保持され、演算数に再割り当てされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The argument passed to the CF_SWIFT_NAME macro uses the same syntax as the #selector expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CF_SWIFT_NAMEマクロに渡された引数は、#selector式と同じ構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The base implementation of the isEqual: provided by the NSObject class is equivalent to an identity check by pointer equality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NSObjectクラスによって提供されるisEqual:の基本実装は、ポインタ同等性による同一性確認に等しいものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code listing below illustrates the following process:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記のコード出力は、次の過程を例示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler automatically infers the name of the overridden Objective-C method that matches the Swift method name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラは、そのスウィフトメソッド名と適合するオーバーライドされたObjective-Cメソッドの名前を自動的に推論します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler removes Ref from the end of each type name because all Swift classes are reference types, therefore the suffix is redundant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラは各型名の終わりからRefを削除します、なぜなら全てのスウィフトクラスが参照型であり、したがってこの接尾辞は冗長です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The contents of the Objective-C files in that framework will be available in any Swift file within that framework target automatically, without any import statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのフレームワークの中のObjective-Cファイルの中身は、まったくインポート文なしで、そのフレームワークターゲット内のあらゆるスウィフトファイルにおいて自動的に利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corresponding reference types can be accessed with their original NS class name prefix.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対応する参照型は、それら本来のNSクラス名接頭辞でアクセスされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default implementation of the == operator invokes the isEqual: method, and the default implementation of the === operator checks pointer equality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>==演算子の省略時の実装は、isEqual:メソッドを発動します、そして===演算子の省略時の実装はポインタの同等性を調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The differences between Objective-C and Swift syntax are all the more apparent when instantiating objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cとスウィフト構文の間の違いは、オブジェクトをインスタンス化するとき全て明らかになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a customized error type defined using the NS_ERROR_ENUM macro in Objective-C:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、Objective-CにおいてNS_ERROR_ENUMを使ってカスタマイズされたエラー型を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows availability information used in a conditional statement in Swift:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、スウィフトでの条件文で使われる利用可能性情報を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first argument appears immediately inside the parentheses, without a name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の引数は、名前なしで、丸括弧の直ぐ内側に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first element in CommandLine.arguments is a path to the executable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CommandLine.argumentsの中の最初の項目は、常に実行ファイルへのパスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first, equality (==), compares the contents of the objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つめ、同等性（==）は、オブジェクトの内容を比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code shows how String? instances bridge to Objective-C depending on their value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のコードは、どのようにString?インスタンスがObjective-Cへとそれの値に基づいてブリッジするかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following mappings apply:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のマッピングを適用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following tables use Type as a placeholder type name to indicate syntax for the mappings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の表は、Typeをプレースホルダー型名として使ってマップのための構文を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The general import model for working with both languages within the same target is depicted below and described in more detail in the following sections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じターゲット内で両方の言語を扱う一般的なインポートモデルは下で表され、更に詳細に以下の節において記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The import process is straightforward.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポートプロセスは単刀直入です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The imported Swift structure contains a stored property for each C structure field and an initializer whose parameters correspond to the stored properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポートされたスウィフト構造体は、各C構造体フィールドに対してひとつの格納プロパティを、そしてそれのパラメータが格納プロパティと対応するひとつのイニシャライザを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The importing process determines how functions, classes, methods, and types declared in Objective-C code appear in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このインポートブロセスは、Objective-Cコードにおいて宣言した関数、クラス、メソッド、そして型が、スウィフトの中にどのように現れるかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last argument is an asterisk (*), which is used to handle potential future platforms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後の引数は、ひとつのアスタリスクです（*）、それは潜在的な将来のプラットホームを取り扱うために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The macro behaves just like the NS_SWIFT_UNAVAILABLE macro except that it omits the customizable error message and it restricts compile-time access to the declaration in Objective-C code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このマクロはちょうどNS_SWIFT_UNAVAILABLEマクロのように振舞います、しかしそれがカスタマイズ可能なエラーメッセージを省略することと、それがコンパイル時アクセスをObjective-Cコードの中の宣言に制限することを除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The methods that perform a selector synchronously, such as perform(_:), return an implicitly unwrapped optional unmanaged pointer to an AnyObject instance (Unmanaged&lt;AnyObject&gt;!), because the type and ownership of the value returned by performing the selector can’t be determined at compile time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セレクタを同期的に実行するメソッド、例えばperform(_:)は、AnyObjectインスタンス（Unmanaged&lt;AnyObject&gt;!）に対する暗黙的にアンラップされたオプショナルの非管理ボインタを返します、なぜならセレクタ実行によって返される値の型と所有権はコンパイル時に確定されることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The model for importing Swift into Objective-C is similar to the one used for importing Objective-C into Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトをObjective-Cにインポートすることの原型は、Objective-Cをスウィフトにインポートするために使われるものに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most effective approach for migrating code to Swift is on a per-file basis—that is, one class at a time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトへの移っているコードのために最も効果的なアプローチは、ファイル毎原則の上にあります ― すなわち、一度にひとつのクラス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of the Xcode-generated header for Swift code, and the name of the Objective-C bridging header that Xcode creates for you, are generated from your product module name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコードのためのXcode生成のヘッダの名前、そしてXcodeがあなたの代わりにつくるObjective-C橋渡しヘッダのの名前は、あなたの製品モジュール名から生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of this header is your product module name followed by adding "-Swift.h".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このヘッダの名前は、あなたの製品モジュール名に続けて"-Swift.h"を加えたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The path should be relative to your project, similar to the way your Info.plist path is specified in Build Settings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パスは、あなたのプロジェクトに相対的でなければなりません、あなたのInfo.plistパスが「Build Settings」において指定される方法に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pointer passed to the function is guaranteed to be valid only for the duration of the function call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数に渡されるポインタは、その関数呼び出しの継続期間に対してのみ有効であることを保証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The prefixes to C enumeration case names are removed when they are imported into Swift, whether they’re defined in system frameworks or in custom code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C列挙ケース節名への接頭辞は、それらがスウィフトにインポートされるとき削除されます、それらがシステムフレームワークでまたはあつらえのコードで定義されるかに関係なくです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process described in this section applies to non-framework targets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この節で記述されるプロセスは、非フレームワークターゲットにあてはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process for importing an external framework is the same whether the framework is written in a single language or contains files from both languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>外部フレームワークをインポートするプロセスは、そのフレームワークが１つだけの言語で書かれるか、両方の言語からのファイルを含むかに関係なく、同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process for working with mixed-language targets differs slightly depending on whether you’re writing an app or a framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>混合言語のターゲットを扱う過程は、あなたがアプリを書いているかフレームワークを書いているかに従い、わずかに異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The raw buffer pointer types, UnsafeRawBufferPointer and UnsafeMutableRawBufferPointer, let you view or mutate a contiguous block of memory as a collection of UInt8 values, where each value corresponds to a byte of memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生のバッファポインタ型、UnsafeRawBufferPointerおよびUnsafeMutableRawBufferPointerは、あなたにメモリの隣接ブロックをUInt8値のコレクションとして眺めさせたり変化させたりします、そこで各値はメモリのあるバイトに対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rest of the selector pieces correspond to argument names and appear inside the parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>残りのセレクタ片は、引数名に相当して、括弧の内側に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The resulting CVaListPointer value is then passed to the va_list argument of the C variadic function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果のCVaListPointer値は、それからC可変長引数関数のva_list引数に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second, identity (===), determines whether or not the constants or variables refer to the same object instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つめ、同一性（===）は、定数または変数が同じオブジェクトインスタンスに言及するかどうかを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string will automatically be converted to UTF8 in a buffer, and a pointer to that buffer is passed to the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その文字列は、あるバッファにおいて自動的にUTF8に変換されます、そしてそのバッファへのポインタが関数へ渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax of a #keyPath string expression is similar to the syntax of a #selector expression, as described in Selectors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>#keyPath文字列式の構文は、#selector式の構文に似ています、セレクタで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The target-action model is fundamentally similar in Swift and Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ターゲット-アクションの雛形は、スウィフトとObjective-Cで基本的に類似しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the property must conform to the NSCopying protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティの型は、NSCopyingプロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The typed buffer pointer types, UnsafeBufferPointer and UnsafeMutableBufferPointer, let you view or mutate a contiguous block of memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型付きバッファポインタ型、UnsafeBufferPointerおよびUnsafeMutableBufferPointerは、あなたにメモリの隣接ブロックを眺めさせたり変化させたりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unified logging system provides an API for capturing messaging across all levels of the system, and is a replacement for the NSLog function in the Foundation framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>統合ログシステムは、システムのすべての水準にまたがってメッセージを捕らえるためにAPIを提供します、そしてFoundationフレームワークにおけるNSLog関数に対する置き換えです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of self in a CF_SWIFT_NAME argument is used for instance methods to refer to the method receiver.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CF_SWIFT_NAME引数におけるselfの使用は、インスタンスメソッドに対して使われてメソッドのレシーバを参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two distinct types of comparison you can make between two objects in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがスウィフトにおいて２つのオブジェクトの間に作ることができる比較には２つの別個の型があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are, however, various pointer types available for your use when you need direct access to memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたがメモリへの直接のアクセスを必要とするとき、あなたの利用に応じられるいろいろなポインター型があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no explicit delineation between the implementation and the interface—all of the information about a class, function, or constant resides in a single .swift file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明確な境界線が実装とインタフェースの間にありません ― クラス、関数、または定数に関する全ての情報は１つの.swiftファイルに属します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no way to recover from Objective-C exceptions directly in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトには直接にObjective-C例外から回復する方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may be edge cases in your code that are not automatically handled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動的に処理されることが際どい場合があなたのコードであるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the class you migrate cannot have any Objective-C subclasses in your app.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、あなたが移行するクラスは、あなたのアプリにおいて１つもObjective-Cサブクラスを持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the complex macros that are in C and Objective-C source files are not made available to your Swift code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、CとObjective-Cソース・ファイルの中にある複雑なマクロは、あなたのスウィフトコードで利用可能にされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, use these types if your code specifically requires them, but use Int wherever possible otherwise.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、あなたのコードが特にそれらを必要とする場合にこれらの型を使ってください、しかし一方で可能な場合にはいつでもIntを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, using these APIs is strongly discouraged unless your code specifically relies on the dynamic method resolution provided by the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それゆえに、これらのAPIを使うことは強く反対されます、あなたのコードがObjective-Cランタイムによって提供される動的メソッド解決を特別に当てにするのでない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, when you work with APIs that operate on the string representation of a Swift class, you must include the fully qualified name of the class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それゆえに、あなたがあるスウィフトクラスの文字列表現で作動するAPIを扱うとき、あなたはそのクラスの完全修飾名を含めなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These UITableView and UITextField objects are the same objects that you’d instantiate in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのUITableViewとUITextFieldオブジェクトは、それらがObjective-Cでインスタンス化するのと同じオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These headers vend the APIs that can be mapped back to Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのヘッダは、Objective-Cに逆にマップされることができるAPIを売り歩きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include NSLocalizedString, NSLocalizedStringFromTable, NSLocalizedStringFromTableInBundle, and NSLocalizedStringWithDefaultValue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、NSLocalizedString, NSLocalizedStringFromTable, NSLocalizedStringFromTableInBundle, そしてNSLocalizedStringWithDefaultValueを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These representations can then be written to a file, or transmitted to another process locally or over a network.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの表現は、それからファイルに書き出されたり、別のプロセスにローカルにまたはそのネットワークを超えて送られたりができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These should not be overridden.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらはオーバーライドされるべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These types let you access the memory as a collection, where each item is an instance of the buffer type’s Element generic type parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型は、あなたにコレクションとしてメモリにアクセスさせます、そこで各項目はそのバッファ型のもつElement総称体型パラメータのインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These types let you use low-level programming patterns, such as operating on raw memory without compiler-checked type safety, or switching between several different typed interpretations of the same memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型はあなたに低水準プログラミングパターンを使用させます、たとえばコンパイラ確認の型安全なしの生の値上での演算など、または同じメモリのいくつかの異なる型での実装の間での切り替えなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These value types have the same functionality as their corresponding reference types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの値型は、それらの対応する参照型と同じ機能性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows them to be used with the same syntax as initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、それらにイニシャライザと同じ構文で使用されることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to write maintain flexibility of untyped access to Objective-C APIs that return id values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これがあなたに書くことを可能にするのは、id値を返すObjective-C APIに対する型なしでのアクセスの柔軟性の維持です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach simplifies the logic of handling different platform capabilities.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この取り組みは、異なるプラットホーム適応性の取り扱い論理を単純にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This automatically generated file is an Objective-C header that declares the Swift interfaces in your target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この自動的に生成されるファイルは、あなたのターゲットの中のスウィフトインタフェースを宣言するObjective-Cヘッダです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This documentation contains preliminary information about an API or technology in development.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example extends the CGRect structure to contain a computed area property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、CGRect構造体を拡張して、計算areaプロパティを含むようにします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example shows availability information used on a declaration in Swift:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、スウィフトでのある宣言で使われる利用可能性情報を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example shows how to generate errors using that custom error type in Swift:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、そのあつらえのエラー型をスウィフトにおいて使うことでエラーを生成する方法を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This exception ensures that an older compiler doesn’t attempt to parse syntax introduced in a newer version of Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例外は、古いコンパイラがより新しいバージョンのスウィフトで導入される構文の解析を試みないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This excludes Swift-only features, such as those listed here:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、ここに一覧にされるようなスウィフトのみの機能を除外します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This guide covers three important aspects of Swift and Objective-C compatibility that you can use to your advantage when developing Cocoa apps:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このガイドは、この互換性の３つの重要な面を扱います、それは、あなたがココア・アプリを開発するときあなたの強みとして使うことができるものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes all of the Objective-C system frameworks—such as Foundation, UIKit, and SpriteKit—as well as common C libraries supplied with the system.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、Objective-Cシステムフレームワークの全て ― Foundation、UIKit、そしてSpriteKitなど ― それだけでなくシステムで供給される一般的なCライブラリをも含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because all Swift code is syntax checked, even when it is not compiled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは全てのスウィフトコードが、それがコンパイルされないときでも、構文チェックされるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is discussed in more detail in Swift and Objective-C in the Same Project.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、より詳細に同じプロジェクト中のスウィフトとObjective-Cで議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is done for compatibility with C, which allows any value to be stored in an enumeration, including values used internally but not exposed in headers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、Cとの互換性のために行われます、それはどんな値も列挙に格納されることを許します、内部的に使われるがヘッダに暴露されない値も含めて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is true even though the instance’s defining type is bridged to Swift as a structure type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、たとえそのインスタンスのもつ定義型がスウィフトへ構造体型としてブリッジされるとしても当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This keyword can be used only for properties that are optional class types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルのクラス型であるプロパティだけに対して、このキーワードは使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This lets you take advantage of the functionality available on the reference type’s implementation in a way that is natural in Swift code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたに参照型の実装上で利用可能な機能性を、スウィフトコードにおける自然な方法で利用させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This limitation no longer exists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この制限はもはや存在しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes Swift an easy, convenient, and powerful tool to integrate into your development workflow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、スウィフトを簡単で、便利で、強力なツールにして、あなたの開発ワークフローへと統合させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you can create classes and protocols based on familiar, established behavior in Objective-C and enhance them with Swift’s modern and powerful language features.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたがObjective-Cでのお馴染みの、確立された挙動に基づいてクラスおよびプロトコルを作成して、それらをスウィフトの現代的で強力な言語機能で強化することができることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means tidying up and modernizing your existing Objective-C codebase.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたの既存のObjective-Cコードベースを整えて、現代化することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This natural workflow makes creating mixed-language app and framework targets as straightforward as creating an app or framework target written in a single language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この自然なワークフローは、一つの言語で書かれるアプリまたはフレームワーク・ターゲットをつくるのと同じくらい直接的に、混合言語のアプリとフレームワーク・ターゲットを作成することをもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This table describes the changes to Using Swift with Cocoa and Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この表は「CocoaとObjective-Cとともにスウィフトを使う」に対する変更点を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This way, you can let the storyboard connect the outlets at runtime, after initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうして、あなたは、初期化の後で、実行時にストーリーボードをアウトレットたちに接続させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throwing an Error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーをスローする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid this, you can instead have the block capture a weak reference to self:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを避けるために、あなたは代わりにブロックがselfに対する弱い参照をキャプチャするようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be accessible and usable in Objective-C, a Swift class must be a descendant of an Objective-C class or it must be marked @objc.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでアクセス可能にされて利用可能にされるために、スウィフトクラスはObjective-Cクラスの子孫でなければなりません、あるいは、それは@objcで印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be accessible and usable in Objective-C, a Swift class must be a descendant of an Objective-C class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでアクセス可能で利用可能であるために、スウィフトクラスはObjective-Cクラスの子孫でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To configure a Swift subclass of NSManagedObject for use by a Core Data model entity, open the model entity inspector in Xcode, enter the class name into the Class field, and choose “Current Product Module” from the Module field drop-down list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるコアデータ・エントリによって使うためにNSManagedObjectのスウィフトサブクラスを構成するには、そのモデルのEntityインスペクタをXcodeにおいて開いて、クラス名をClass欄に入力して、「Current Product Module」をModule欄ポップダウンリストから選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To construct a selector for a property’s Objective-C getter or setter method, pass the property name prefixed by the getter: or setter: label, such as #selector(getter: MyViewController.myButton).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロパティの持つObjective-Cゲッターまたはセッターメソッドに対してセレクタを組み立てるには、getter:またはsetter:接頭辞を付けられたプロパティ名を渡してください、例えば#selector(getter: MyViewController.myButton)のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create a Swift class that inherits from an Objective-C class, add a colon (:) after the name of the Swift class, followed by the name of the Objective-C class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cクラスから継承するスウィフトクラスを作成するために、スウィフトクラスの名前の後にコロン（:）、それに続けてObjective-Cクラスの名前を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create a Swift project in Xcode</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Xcodeにおいてスウィフトプロジェクトを作成します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create a Swift protocol that can be adopted by an Objective-C class, mark the protocol declaration with the @objc attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cクラスによって採用されることができるスウィフトプロトコルを宣言するには、protocol宣言を@objc属性で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create a selector for a method that can be called from Objective-C, pass the name of the method, such as #selector(MyViewController.tappedButton(_:)).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cから呼び出されることができるメソッドに対してセレクタを作成するには、そのメソッドの名前を渡してください、例えば#selector(MyViewController.tappedButton(_:))のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To customize the name of an enumeration case, you can use the NS_SWIFT_NAME macro, passing the Swift enumeration case name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節の名前をカスタマイズするために、あなたはスウィフト列挙ケース節名を渡して、NS_SWIFT_NAMEマクロを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a type that conforms to a single protocol in Swift code, use the protocol name directly as its type (as compared to id&lt;SomeProtocol&gt; in Objective-C).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ただ１つのプロトコルに準拠する型をスウィフトコードにおいて定義するには、そのプロトコル名を直接にそれの型として使ってください（Objective-Cでのid&lt;SomeProtocol&gt;になぞらえられる）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a type that conforms to multiple protocols in Swift code, use a protocol composition, which takes the form SomeProtocol &amp; AnotherProtocol (as compared to id&lt;SomeProtocol, AnotherProtocol&gt; in Objective-C).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のプロトコルに準拠する型をスウィフトコードにおいて定義するには、プロトコル合成物を使ってください、それは形式SomeProtocol &amp; AnotherProtocolをとります（Objective-Cでのid&lt;SomeProtocol, AnotherProtocol&gt;になぞらえられる）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do this, change the Product Module Name build setting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これをするために、「Product Module Name」ビルド設定を変更してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ensure that your app can accommodate any differences in functionality, you check the availability those APIs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのアプリが機能性でのどんな違いでも調整できることを確実にするために、あなたはそれらのAPIの有効性を確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To import Objective-C code into Swift from the same framework</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じフレームワークからスウィフトにObjective-Cコードをインポートするには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To import Objective-C code into Swift from the same target</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じターゲットからObjective-Cコードをスウィフトにインポートするには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To import Swift code into Objective-C from the same framework</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコードを同じフレームワークからObjective-Cにインポートするには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To import Swift code into Objective-C from the same target</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じターゲットからObjective-Cにスウィフトコードをインポートするには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To import a set of Objective-C files in the same app target as your Swift code, you rely on an Objective-C bridging header to expose those files to Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのスウィフトコードと同じアプリターゲットにひとそろいのObjective-Cファイルをインポートするために、あなたはObjective-C橋渡しヘッダを当てにしてそれらのファイルをスウィフトに露出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To import a set of Objective-C files in the same framework target as your Swift code, you’ll need to import those files into the Objective-C umbrella header for the framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとそろいのObjective-Cファイルをあなたのスウィフトコードと同じフレームワークターゲットにインポートするために、あなたはそれらのファイルをそのフレームワークのためのObjective-Cアンブレラヘッダにインポートする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To import a set of Swift files in the same framework target as your Objective-C code, you don’t need to import anything into the umbrella header for the framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとそろいのスウィフトファイルをあなたのObjective-Cコードと同じフレームワークターゲットにインポートするために、あなたはそのフレームワークのためのアンブレラヘッダに何もインポートする必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To inform the caller when initialization has failed, an Objective-C initializer can return nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化が失敗した時に呼び出し側に報告するために、Objective-Cイニシャライザはnilを返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To instantiate an Objective-C class in Swift, you call one of its initializers using Swift initializer syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cクラスをスウィフトにおいてインスタンス化するために、あなたはそれのイニシャライザのうちの１つをスウィフト初期化構文を使って呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To log a message to a specific subsystem, you can create a new OSLog object, specifying the subsystem and category, and pass it as a parameter to the os_log function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある特定のサブシステムに対するメッセージをログするには、あなたは新しいOSLogオブジェクトを作成して、そのサブシステムとカテゴリを指定します、そしてそれをパラメータとしてos_log関数に渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make an Objective-C declaration unavailable at compile time in both Swift and Objective-C, use the NS_UNAVAILABLE macro.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C宣言をコンパイル時にSwiftとObjective-Cの両方で利用できなくするには、NS_UNAVAILABLEマクロを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make your Swift class accessible and usable back in Objective-C, make it a descendant of an Objective-C class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのスウィフトクラスをObjective-Cから逆にアクセス可能および使用可能にするために、それをObjective-Cクラスの子孫にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent a strong reference cycle, you can specify self to be unowned in a closure’s capture list:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強い参照循環を防ぐために、あなたはselfをunownedであるとクロージャのキャプチャリストにおいて指定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent an Objective-C declaration from being imported by Swift, use the NS_SWIFT_UNAVAILABLE macro, passing a message directing API consumers to any alternatives that may exist.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるObjective-C宣言がスウィフトによってインポートされるのを防止するために、NS_SWIFT_UNAVAILABLEマクロを使って、API消費者に存在するであろう何らかの代替手段を指示するメッセージを渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To provide a refined Swift interface to C functionality, create an overlay by declaring new Swift functions that make the necessary C function calls in their implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>洗練されたスウィフトインターフェイスをCの機能性に提供するには、必要なC関数をそれの実装において呼び出すようにする新しいスウィフト関数を定義することによって、オーバーレイを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To provide your own implementations of the superclass’s methods, use the override modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのスーパークラスの持つメソッドのあなた独自の実装を提供するには、override修飾子を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To specify a particular name for the class to use in Objective-C, mark it with @objc(name), where name is the name that your Objective-C code uses to reference the Swift class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスに対してObjective-Cで使うために特定の名前を指定するために、それを@objc(name)で印してください、そこにおいてnameはあなたのObjective-Cコードがスウィフトクラスを参照するために使う名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To start experimenting with Cocoa app development using Swift, create a new Swift project from one of the provided Xcode templates.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトを使うCocoaアプリ開発の実験を始めるために、提供されるXcodeテンプレートの１つから新規スウィフトプロジェクトを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To start using the object, you use the takeUnretainedValue() function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのオブジェクトを使い始めるために、あなたはtakeUnretainedValue()関数を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use outlets and actions in Swift, insert @IBOutlet or @IBAction just before the property or method declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいてアウトレットとアクションを使うために、プロパティまたはメソッド宣言の直前に@IBOutletまたは@IBActionを書き込んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Top-level functions defined in Swift</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて定義されるトップレベル関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Treat your Swift and Objective-C files as the same collection of code, and watch out for naming collisions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのスウィフトとObjective-Cファイルを同じコードのコレクションとみなしてください、そして名前衝突に気をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Troubleshooting Tips and Reminders</seg>
      </tuv>
      <tuv lang="JA">
        <seg>問題解決の秘訣と注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typealiases defined in Swift</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて定義される型エイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types declared to be nonnullable, either with a _Nonnull annotation or in an audited region, are imported by Swift as a nonoptional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非ヌル可能として定義された型、_Nonnull注釈を使ってまたはある監査された領域の中の両方、は、スウィフトによって非オプショナルとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types declared to be nullable with a _Nullable annotation, are imported by Swift as an optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ヌル可能として_Nullable注釈を使って定義された型は、スウィフトによってオプショナルとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types declared without a nullability annotation are imported by Swift as an implicitly unwrapped optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ヌル可能注釈を使わずに定義された型は、スウィフトによって暗黙的にアンラップされるオプショナルとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types that are pointed to are not bridged.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポインターで指される型は、橋渡しされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types that can be converted between Objective-C and Swift are referred to as bridged types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cとスウィフトの間で変換されることが可能な型は、ブリッジ（橋渡しされる）型と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, you don’t need to create your own autorelease pool blocks, but there are some situations in which either you must—such as when spawning a secondary thread—or it is beneficial to do so—such as when writing a loop that creates many temporary objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>概して、あなたはあなた独自のオートリリース・ブロックを作成する必要はありません、しかしいくつかの状況があり、そこにおいては、あなたが必要とする—例えば副次的スレッドを生み出す時など—もしくはそうすることが利益をもたらす—例えば多くの一時的オブジェクトを作成するあるループを書く時など—のいずれかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Under Build Settings, in Packaging, make sure the Defines Module setting for that framework target is set to “Yes”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「Build Settings」において、「Packaging」の中で、そのフレームワークターゲットのための「Defines Module」設定が「Yes」に設定されることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Understanding the Swift Import Process</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのインポートプロセスを理解する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Undo</seg>
      </tuv>
      <tuv lang="JA">
        <seg>取り消し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unified Logging</seg>
      </tuv>
      <tuv lang="JA">
        <seg>統合ログ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unified logging is available in iOS 10.0 and later, macOS 10.12 and later, tvOS 10.0 and later, and watchOS 3.0 and later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>統合ログは、iOS 10.0以降、macOS 10.12以降、tvOS 10.0以降、そしてwatchOS 3.0以降で利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>共用体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike Objective-C, where all classes are part of a global namespace–and must not have the same name–Swift classes can be disambiguated based on the module they reside in.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cとは違い、全てのクラスがグローバルな名前空間の一部である ― それゆえ同じ名前を持ってはならない ― ところで、スウィフトクラスは、それらが属するモジュールに基づいて違いを明らかにされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike key paths created using key-path expressions, key paths created using the #keyPath string expression don’t pass type information about the properties or methods they reference to the APIs that accept key paths.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパス式を使って作成されるキーパスと違い、#keyPath文字列式を使って作成されるキーパスは、それらが参照するプロパティやメソッドについての型情報をキーパスを受け入れるAPIへ伝えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unmanaged Objects</seg>
      </tuv>
      <tuv lang="JA">
        <seg>管理されないオブジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unnamed Structure and Union Fields</seg>
      </tuv>
      <tuv lang="JA">
        <seg>無名の構造体と共用体フィールド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unnamed fields consist of a nested struct or union type with named fields.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>無名フィールドは、入れ子にされたstructまたはunionで名前付きフィールドを持つものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unrecognized Selectors and Optional Chaining</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別不能セレクタとオプショナル連鎖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unsafe Invocation of Objective-C Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cメソッドの安全でない発動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Update import statements in your Objective-C code (to #import "ProductModuleName-Swift.h"), as described in Importing Code from Within the Same App Target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのObjective-Cコードにおいてインポート文を更新してください（#import "ProductModuleName-Swift.h"へと）、コードを同じアプリターゲットからインポートするで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Update your code to use the Swift class name instead of the Objective-C name if you gave the Swift class a different name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがスウィフトクラスに異なる名前を与えるならば、Objective-C名でなくてスウィフトクラス名を使用するようにあなたのコードを更新してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated Constant Pointers section with information about bridging Swift String values to C pointers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>章定数ポインターをスウィフトのString値からCポインターへの橋渡しについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated an example in the Key-Value Observing section to use #keyPath instead of string literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キー値監視の節の例を更新して、#keyPathを文字列リテラルの代わりに使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated and expanded the Swift Type Compatibility section in the Interacting with Objective-C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト型互換性節をC APIとの相互作用章において更新および拡張した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated and expanded the Bridging Collections section in the Working with Cocoa Frameworks chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブリッジコレクション節をココアフレームワークを扱う章において更新および拡張した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 1.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 1.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 1.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 1.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 2.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 2.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 2.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 2.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 2.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 2.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 3.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 3.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 3.0.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 3.0.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 3.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 3.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 4.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 4.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated screenshots of Xcode user interface.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Xcodeユーザインターフェイスのスクリーンショットを更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the CFArrayCreateMutable code sample in the Function Pointers section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CFArrayCreateMutableコードサンプルを関数ポインター節において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the API Availability section and the Conditional Compilation Blocks section with information about tvOS.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>API有効性節と条件コンパイルブロック節をtvOSについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Accessing Properties section with additional information about how Objective-C property attributes are imported by Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティにアクセスする節をどのようにObjective-Cプロパティ属性がスウィフトによってインポートされるかについての追加情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Adopting Protocols section to describe how to constrain the type of a variable or constant to multiple protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルを採用するの節を更新して、どのように変数や定数の型に対して複数のプロトコルの制約を加えるかについて記述した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Conditional Compilation Blocks section with information about the swift build configuration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件コンパイルブロック節をswiftビルド構成についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Configuring Swift Interfaces in Objective-C section with information about the @nonobjc attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節スウィフトインターフェイスをObjective-Cにおいて構成するを@nonobjc属性についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Configuring Swift Interfaces in Objective-C section with information about using the @objc(name) attribute with Swift enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトインターフェイスをObjective-Cにおいて構成する節をスウィフト列挙とともに@objc(name)属性を使用することについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Configuring Swift Interfaces in Objective-C section with information about using the @objc attribute for Swift enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトインターフェイスをObjective-Cにおいて構成するの節をスウィフト列挙に@objc属性を使うことについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Data Type Size Calculation section with information about the MemoryLayout type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>データ型サイズ計算の節を更新して、MemoryLayout型についての情報を含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Enumerations section with information about how C enumerations not marked with the NS_ENUM or NS_OPTIONS macro are imported by Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙節を、どのようにNS_ENUMまたはNS_OPTIONSマクロで印されないC列挙がスウィフトによってインポートされるかについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Error Handling section to reflect that Swift removes the WithError suffix from the selector of an error-producing Objective-C method, when that method is imported as a Swift method that throws.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節エラーの処理を更新して、「エラーを生じる」Objective-Cメソッドのセレクタから、そのメソッドがスローするスウィフトメソッドとしてインポートされる時に、スウィフトがWithError接尾辞を取り除いたことを反映した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Error Handling section with information about the NS_ERROR_RESULT Objective-C macro.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーの処理節をNS_ERROR_RESULT Objective-Cマクロについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Failable Initialization section with information about nullability annotations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節失敗できる初期化をヌル許可注釈についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Function Pointers section with information about bridging Swift function and closure values with C function pointers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数ポインターの章をスウィフト関数やクロージャとC関数ポインタとの橋渡しについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Hashing section with information about the AnyHashable type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ハッシュ化の節を更新して、AnyHashable型についての情報を含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Interacting with Objective-C APIs chapter with information about how Swift imports Objective-C id types as Any.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C APIとの相互作用の章を更新して、どのようにスウィフトがObjective-C id型をAnyとしてインポートするかの情報を含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Object Comparison section and Hashing section in the Interacting with Objective-C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクト比較節とハッシュ化節をC APIとの相互作用章において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Pointers section to reflect that CMutablePointer and CMutableVoidPointer have been replaced with UnsafePointer, and CConstPointer and CConstVoidPointer have been replaced with ConstUnsafePointer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節ポインターを更新して、CMutablePointerとCMutableVoidPointerがUnsafePointerと置き換えられ、CConstPointerとCConstVoidPointerがConstUnsafePointerと置き換えられたことを反映するようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Pointers section to reflect that UnsafePointer has been replaced with UnsafeMutablePointer, ConstUnsafePointer has been replaced with UnsafePointer, and AutoreleasingUnsafePointer has been replaced with AutoreleasingUnsafeMutablePointer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節ポインターを更新して、UnsafePointerがUnsafeMutablePointerと置き換えられ、ConstUnsafePointerがUnsafePointerと置き換えられ、そしてAutoreleasingUnsafePointerがAutoreleasingUnsafeMutablePointerと置き換えられることを反映するようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Pointers section with information about the UnsafeRawPointer and UnsafeMutableRawPointer types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポインターの節を更新して、UnsafeRawPointerとUnsafeMutableRawPointer型の情報を含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Pointers section with information about the duration of pointers passed to inout parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポインター節をinoutパラメータに渡されたポインタの継続期間についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Selectors section with information about the Swift #selector expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セレクタ節をスウィフトの#selector式についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Setting Up Your Swift Environment section with information about base SDK requirements for Swift apps.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのスウィフト環境を設定する節をスウィフトアプリに対する基盤SDK要件についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Swift Type Compatibility and Configuring Swift Interfaces in Objective-C sections now that the @objc attribute can only be applied to classes that descend from NSObject.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト型互換性とスウィフトインターフェイスをObjective-Cにおいて構成する節を更新した、今では@objc属性はただNSObjectの系統を引くクラスにだけ適用されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Swift and Objective-C in the Same Project chapter with information about access control in mixed-language targets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>章同じプロジェクト内のスウィフトとObjective-Cを混合言語ターゲットでのアクセス制御ついての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Swift and Objective-C in the Same Project chapter with information about the @testable attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じプロジェクト中のスウィフトとObjective-Cの章を@testable属性についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Swift and Objective-C in the Same Project chapter with information about the open and fileprivate access modifiers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じプロジェクト中のスウィフトとObjective-Cの章を更新して、openとfileprivateアクセス修飾子についての情報を含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Working with Cocoa Frameworks chapter to use the as! operator and bridging semantics in Swift 1.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>章ココアフレームワークを扱うをas!演算子の利用とスウィフト 1.2における意味論との溝を埋めるために更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Bridging Collections section to discuss Swift bridging of parameterized Objective-C collection classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「ブリッジコレクション」節をパラメーター化されたObjective-Cコレクションクラスのスウィフト橋渡しについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the Core Data section to include directions to configure the managed object model.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コアデータの節を更新してオブジェクトモデル管理のための指針を含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in Processing Command-Line Arguments, now that Process has been renamed to CommandLine.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コマンドライン引数の処理での議論を更新した、今ではProcessはCommandLineと改名されてしまっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the Numbers section of the Working with Cocoa Frameworks chapter, now that as? casts fail when attempting to convert an NSNumber to a numeric type that isn’t large enough to fit the entire number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数の節での議論をCocoaフレームワークを扱うの章で更新した、今ではas?キャストはNSNumberをその数全体をはめ込むには十分に大きくない数値型に変換する場合に失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the Protocol-Qualified Classes section now that classes are imported as part of protocol compositions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル適格クラスの節での議論を更新した、今ではクラスはプロトコル合成の一部としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the Requiring Dynamic Dispatch and Inheriting from Objective-C Classes sections, now that the @objc attribute is inferred in fewer contexts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動的なディスパッチを要求するとObjective-Cクラスから継承するの節での議論を更新した、今では@objc属性はより新しい文脈において継承されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the Serialization section to include the new encoders and decoders for JSON and property list data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シリアライズの節での議論を更新して、新しいJSONおよびプロパティリストデータのためのエンコーダとデコーダを含めた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the Unions and Unnamed Structure and Union Fields sections, now that unnamed fields from C structures and unions are always imported.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>共用体と無名構造体と共用体フィールドの節での議論を更新した、今ではC構造体と共用体からの無名フィールドは常にインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of the @NSManaged attribute in the Implementing Core Data Managed Object Subclasses section, now that the attribute can be applied to certain instance methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@NSManaged属性の説明をコアデータ管理オブジェクトのサブクラスを実装するの節において更新した、今ではこの属性は特定のインスタンスメソッドに適用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the example in the Key-Value Observing section, now that the key-value observing APIs accept key-path expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キー値監視の節での例を更新した、今ではキー値監視APIはキーパス式を受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the introductions of the Interacting with Objective-C APIs chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>導入部をObjective-C APIとの相互作用章において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use NS_TYPED_ENUM and NS_TYPED_EXTENSIBLE_ENUM when grouping related constants of any type, including string constants.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NS_TYPED_ENUMおよびNS_TYPED_EXTENSIBLE_ENUMを、文字列定数を含む、任意の型の関連する定数をグループにする場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use NS_TYPED_ENUM for sets of values that can’t logically have values added in a Swift extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NS_TYPED_ENUMを、一揃いの値で論理的に値を追加することがスウィフト拡張において不可能なものに対して使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use NS_TYPED_EXTENSIBLE_ENUM for sets of values that can be expanded in an extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NS_TYPED_EXTENSIBLE_ENUMを、一揃いの値で拡張において拡張可能なものに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the @objc(name) attribute to provide Objective-C names for properties and methods when necessary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>@objc(name)属性をObjective-C名をプロパティとメソッドに必要に応じて用意するために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the NS_SWIFT_NOTHROW macro on an Objective-C method declaration that produces an NSError to prevent it from being imported by Swift as a method that throws.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NS_SWIFT_NOTHROWマクロをNSErrorを生み出すObjective-Cメソッド宣言上で使って、それがスウィフトによってスローするメソッドとしてインポートされるのを防止してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the weak keyword to indicate that a property has a weak reference to the object stored as its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>weakキーワードを使用して、あるプロパティがその値として格納しておくオブジェクトへの弱い参照を持つことを示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use these tools to explore Swift’s extensive functionality and integrate it back into your existing Objective-C app without having to rewrite the entire app in Swift at once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのツールを使用して、スウィフトの広大な機能性を調査して、いっぺんにスウィフトでアプリ全体を書き直ししなくとも、それをあなたの既存のObjective-Cアプリに逆に組み込んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use your custom Objective-C code with the same Swift syntax you use with system classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのあつらえのObjective-Cコードを、あなたがシステム・クラスで使うのと同じスウィフト構文で使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Swift Class Names with Objective-C APIs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトクラス名をObjective-C APIで使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Swift from Objective-C</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトをObjective-Cから使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using mix and match, you can implement part of your app’s functionality using the latest Swift features and seamlessly incorporate it back into your existing Objective-C codebase.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>混合と適合を使って、あなたは最新のスウィフト特徴を使ってあなたのアプリの機能性の一部を実施して、継ぎ目なくそれをあなたの既存のObjective-Cコードベースにさかのぼって組み込むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Valid arguments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効な引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variadic Functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長引数関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When id values are imported into Swift as Any, the runtime automatically handles bridging back to either class references or Swift value types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>id値がスウィフトへAnyとしてインポートされる時、ランタイムは自動的にクラス参照またはスウィフト値型のどちらかへ戻すブリッジを取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Objective-C methods are imported into Swift, the first part of the Objective-C selector becomes the base method name and appears before the parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cメソッドがスウィフトにインポートされるとき、Objective-Cセレクタの最初の部分は、基盤となるメソッド名になって、丸括弧の前に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Swift imports APIs that have not been annotated, the compiler cannot automatically memory manage the returned Core Foundation objects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注釈をつけられなかったAPIをスウィフトがインポートするとき、コンパイラは返されたコアファウンデーション・オブジェクトを自動的にメモリ管理できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Swift imports Core Foundation types, the compiler remaps the names of these types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトがコアファウンデーション型をインポートするとき、コンパイラはこれらの型の名前をリマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a Swift class introduces many new methods or properties that require behavior from the Objective-C runtime, use the @objcMembers attribute in the declaration of that class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるスウィフトクラスがObjective-Cランタイムからの挙動を要求する多くの新しいメソッドまたはプロパティを導入するならば、@objcMembers属性をそのクラスの宣言において使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a Swift initializer, property, subscript, or method is used to satisfy a requirement of an Objective-C protocol, the compiler automatically infers the name to match the requirement, similar to what is done for overridden methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのイニシャライザ、プロパティ、添え字、またはメソッドがObjective-Cプロトコルのある要件を満たすために使われる場合、コンパイラは自動的にその要件と適合する名前を推論します、オーバーライドされたメソッドに対して行われることと同じように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function is declared as taking an AutoreleasingUnsafeMutablePointer&lt;Type&gt;, it can accept any of the following:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数がAutoreleasingUnsafeMutablePointer&lt;Type&gt;を取るとして宣言されるとき、それは以下の何でも受け入れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function is declared as taking an UnsafeMutablePointer&lt;Type&gt; argument, it can accept any of the following:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数がUnsafeMutablePointer&lt;Type&gt;引数を取るとして宣言されるとき、それは以下の何でも受け入れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function is declared as taking an UnsafeMutableRawPointer argument, it can accept the same operands as UnsafeMutablePointer&lt;Type&gt; for any type Type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数がUnsafeMutableRawPointer引数を取るとして宣言されるとき、それは何らかの型Typeに対するUnsafeMutablePointer&lt;Type&gt;と同じ演算数を受け入れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function is declared as taking an UnsafePointer&lt;Type&gt; argument, it can accept any of the following:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数がUnsafePointer&lt;Type&gt;引数を取るとして宣言されるとき、それは以下の何でも受け入れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function is declared as taking an UnsafeRawPointer argument, it can accept the same operands as UnsafePointer&lt;Type&gt; for any type Type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数がUnsafeRawPointer引数を取るとして宣言されるとき、それは何らかの型Typeに対するUnsafePointer&lt;Type&gt;と同じ演算数を受け入れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When accessing a computed property corresponding to a bit field, Swift automatically converts the value to and from compatible Swift types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるビットフィールドに対応している計算プロパティにアクセスするとき、スウィフトはその値を自動的に互換性のあるスウィフト型へと、またはそれから、変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an Objective-C initializer is imported by Swift, the init prefix becomes an init keyword to indicate that the method is a Swift initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cイニシャライザがスウィフトによってインポートされる時、init接頭辞はinitキーワードになって、そのメソッドがスウィフトイニシャライザであることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When bridging from Swift code back into Objective-C code, built-in structures from Cocoa and Foundation are bridged as NSValue instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコードから逆にObjective-Cコードへとブリッジする場合、CocoaおよびFoundation由来の組み込みの構造体はNSValueインスタンスとしてブリッジされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When calling a function that takes a function pointer argument, you can pass a top-level Swift function, a closure literal, or nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数ポインタ引数を取る関数を呼び出しているとき、あなたはトップレベルスウィフト関数、クロージャリテラル、またはnilを渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When declaring a computed property, provide a getter only to make it read-only and provide both a getter and setter to make it read/write.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある計算プロパティを宣言するとき、それを読み出し専用にするためにゲッターのみを提供してください、そしてそれを読み／書きにするためにゲッターとセッターの両方を提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When declaring a stored property, use let to make it read-only, and use var to make it read/write.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある格納プロパティを宣言するとき、それを読み出し専用にするためにletを、そしてそれを読み／書きにするためにvarを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When importing C enumeration marked with the NS_OPTIONS macro, Swift marks any members that have a value of 0 as unavailable, because Swift uses an empty option set to specify no options.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>NS_OPTIONSマクロで印されたC列挙をインポートするとき、スウィフトは0の値を持つメンバはなんであれ利用不可として印します、なぜならスウィフトは空のオプションセットをオプション無しを指定するために使うからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When importing these types, Swift moves them to be nested types of their related types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの型をインポートするとき、スウィフトはそれらを移動して、それらの関連型の入れ子にされた型にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When overriding this method in a Swift subclass of NSDocument, the method replaces its error parameter and throws instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドをNSDocumentのスウィフトのサブクラスにおいてオーバーライドする時、メソッドはそれのエラーパラメーターを置き替えて、代わりにスローをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When working with objects of type Any where the underlying type is known or could be reasonably determined, it is often useful to downcast those objects to a more specific type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基礎をなす型が知られているかまずまず判定されることができるところの型Anyのオブジェクトを扱う時、そのようなオブジェクトをもっとはっきりした型へダウンキャストするのはしばしば便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When working with opaque data types, you may need to perform unsafe pointer operations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明データ型を扱うとき、あなたは非安全ポインタ演算を行う必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When writing Swift code that incorporates Cocoa frameworks, remember that certain types are bridged, which means you can work with Swift types in place of Objective-C types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ココア・フレームワークを取り入れるスウィフトコードを書くとき、特定の型が橋渡しをされるのを思い出してください、それはあなたがスウィフト型をObjective-C型の代わりに扱うことができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you are working with an Objective-C class or your Swift class inherits from an Objective-C class, Swift calls your class’s superclass dealloc method for you as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがObjective-CクラスまたはObjective-Cクラスから継承するあなたのスウィフトクラスを扱ってとき、スウィフトはあなたのクラスのスーパークラスのdeallocメソッドもまたあなたの代わりに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you bridge from an NSArray object with a parameterized type to a Swift array, the element type of the resulting array is bridged as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあるパラメーター化された型を使うNSArrayオブジェクトからスウィフト配列へとブリッジするとき、結果として生じる配列の要素型も同様にブリッジされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you bridge from an NSDictionary object with parameterized types to a Swift dictionary, the resulting dictionary is of type [Key: Value].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがパラメーター化された型たちを使うあるNSDictionaryオブジェクトからスウィフト辞書へ橋渡しするとき、結果として得られる辞書は型[Key: Value]です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you bridge from an NSSet object with a parameterized type to a Swift set, the resulting set is of type Set&lt;ObjectType&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあるパラメーター化された型を使うNSSetオブジェクトからスウィフト集合へ橋渡しするとき、結果として生じる集合は型Set&lt;ObjectType&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you bring Swift code into Objective-C, remember that Objective-C won’t be able to translate certain features that are specific to Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがObjective-Cにスウィフトコードを連れて来るとき、Objective-Cがスウィフトに特有である特定の特徴を翻訳することができないのを思い出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you call a method on a value of AnyObject type, that method call behaves like an implicitly unwrapped optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがAnyObject型の値上でメソッドを呼ぶとき、そのメソッド呼び出しは暗黙的にアンラップされるオプショナルのように振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you create a Swift class that descends from an Objective-C class, the class and its members—properties, methods, subscripts, and initializers—that are compatible with Objective-C are automatically available from Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがObjective-Cクラス由来のスウィフトクラスを作成するとき、そのクラスおよびObjective-C互換のそれのメンバー ― プロパティ、メソッド、添え字、そしてイニシャライザ ― は、自動的にObjective-Cから利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you create a custom view that inherits from the UIView class or the NSView class, you can add the @IBDesignable attribute just before the class declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがUIViewクラスまたはNSViewクラスから継承するカスタムメイドのビューをつくるとき、あなたは@IBDesignable属性をクラス宣言の直前に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you declare an outlet in Swift, you should make the type of the outlet an implicitly unwrapped optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがスウィフトにおいてアウトレットを宣言するとき、あなたはそのアウトレットの型を暗黙的にアンラップされるオプショナルにしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you explicitly type a constant or variable as an NSArray object and assign it an array literal, Swift creates an NSArray object instead of a Swift array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが明示的に定数または変数をNSArrayオブジェクトとして型指定して、それに配列リテラルを代入するとき、スウィフトはスウィフト配列でなくてNSArrayオブジェクトをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you explicitly type a constant or variable as an NSDictionary object and assign it a dictionary literal, Swift creates an NSDictionary object instead of a Swift dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが明示的に定数または変数をNSDictionaryオブジェクトとして型指定して、それに辞書リテラルを代入するとき、スウィフトはスウィフト辞書でなくてNSDictionaryオブジェクトをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you explicitly type a constant or variable as an NSSet object and assign it an array literal, Swift creates an NSSet object instead of a Swift set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが明示的に定数または変数をNSSetオブジェクトとして型指定して、それに配列リテラルを代入するとき、スウィフトはスウィフト集合でなくてNSSetオブジェクトをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you import Swift code into Objective-C, you rely on an Xcode-generated header file to expose those files to Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがスウィフトコードをObjective-Cにインポートするとき、あなたはそれらのファイルをObjective-CにさらすためにXcode生成のヘッダファイルに頼ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you import an external framework, make sure the Defines Module build setting for the framework you’re importing is set to “Yes”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが外部のフレームワークをインポートするとき、あなたがインポートしているフレームワークのための「Defines Module」ビルド設定が「Yes」に設定されることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you need to indicate that a value is missing, you use the value nil.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある値が見つからないことを指し示す必要があるならば、あなたは値nilを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you receive an unmanaged object from an unannotated API, you should immediately convert it to a memory managed object before you work with it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが注釈をつけられなかったAPIから管理されないオブジェクトを受け取るとき、あなたがそれを扱う前に、あなたは直ちにそれをメモリ管理されたオブジェクトに変換しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you refer to an enumeration value, use the value name with a leading dot (.).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが列挙値に言及するとき、前にドット（.）をつけた値名を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you use the @objc(name) attribute on a Swift class, the class is made available in Objective-C without any namespacing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがスウィフトクラス上で@objc(name)属性を使うとき、そのクラスは何ら名前空間操作なしにObjective-Cで利用できるようにされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you want to perform additional clean-up before your class is deallocated, you can implement a deninitializer instead of the dealloc method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのクラスがメモリ割り当て解除される前に、あなたが追加の掃除をしたいときは、あなたはdeallocメソッドでなくてデイニシャライザを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When your class is initialized from a storyboard or xib file, you can assume that the outlet has been connected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのクラスがストーリーボードまたはxibファイルから初期化されるときは、あなたはアウトレットが接続されてしまっていることを確信できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When your code refers to a Swift class or protocol that comes from a different module, you import the Swift module into your Objective-C header using @import.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードが異なるモジュールから来るスウィフトクラスやプロトコルを参照する場合、あなたはスウィフトモジュールをあなたのObjective-Cヘッダへと@importを使ってインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever an action is taken by the user, such as editing the text in a control or deleting an item at a selected row, an undo operation can be registered with the undo manager to allow the user to reverse the effect of that operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるアクションがユーザによってとられる時はいつでも、例えばテキストのカラーの編集や選択行での項目の削除などで、取り消し操作は取り消しマネージャを使って登録されることで、ユーザがその操作の効果を取り消せるようにされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever possible, Swift avoids giving you direct access to pointers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可能なときはいつでも、スウィフトはあなたにポインターへの直接のアクセスを与えることを避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where you typically used the #define directive to define a primitive constant in C and Objective-C, in Swift you use a global constant instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがCとObjective-Cでプリミティブ定数を定義するために概して#define指令を使ったところを、スウィフトでは、あなたはその代わりにグローバル定数を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wherever memory management annotations have been provided, Swift automatically manages the memory of Core Foundation objects, including Core Foundation objects that you instantiate yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリ管理注釈が提供されているどこででも、あなた自身でインスタンス化するコアファウンデーション・オブジェクトを含めて、スウィフトは自動的にコアファウンデーション・オブジェクトのメモリを管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wherever you would use CFTypeRef, you should now use AnyObject in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがCFTypeRefを使うどこであろうとも、あなたは現在あなたのコードにおいてAnyObjectを使わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this import statement, that Swift file can now access all of Foundation’s classes, protocols, methods, properties, and constants.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このインポート文で、このスウィフトファイルは今や全てのFoundationのクラス、プロトコル、メソッド、プロパティ、そして定数にアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without a check, the method call throws an NSInvalidArgumentException “unrecognized selector sent to instance” exception.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>確認なしでは、メソッド呼び出しはNSInvalidArgumentException「認識不能セレクタがインスタンスに送られます」例外をスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Working with Cocoa Frameworks</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cocoaフレームワークを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Working with Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Working with Outlets and Actions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アウトレットとアクションを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing Initializers and Deinitializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザとデイニシャライザを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing Swift Classes and Protocols with Objective-C Behavior</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのクラスとプロトコルをObjective-C挙動で書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Xcode offers to create this header file when you add a Swift file to an existing Objective-C app, or an Objective-C file to an existing Swift app.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Xcodeは、あなたがスウィフトファイルを既存のObjective-Cアプリに、またはObjective-Cファイルを既存のスウィフトアプリに加えるとき、このヘッダ・ファイルを作成することを提案します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Xcode uses your product module name (PRODUCT_MODULE_NAME)—not your target name (TARGET_NAME)—when naming the Objective-C bridging header and the generated header for your Swift code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Xcodeは、あなたのスウィフトコードのためのObjective-C橋渡しヘッダと生成ヘッダに名前をつける時、あなたの製品モジュール名（PRODUCT_MODULE_NAME）を使います ― あなたのターゲット名（TARGET_NAME）でなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You access properties on Objective-C objects in Swift using dot syntax, using the name of the property without parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、Objective-Cオブジェクト上のプロパティにスウィフトにおいてドット構文によって、そのプロパティの名前を丸括弧なして使ってアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You adopt this approach by making your types conform to the Encodable or Decodable protocols, or by conforming to Codable as shorthand for conforming to both protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこの取り組み方を、あなたの型をEncodableまたはDecodableプロトコルに準拠するようにして、または両方のプロトコルへの準拠の簡略法としてCodableに準拠することによって採用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also add the @IBInspectable attribute to properties with types compatible with user defined runtime attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、ユーザー定義のランタイム属性と互換性を持つ型をもつプロパティへ@IBInspectable属性を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also bridge some toll-free bridged Core Foundation types to Swift standard library types if you cast to a bridging Foundation type first.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、いくつかの無料の橋渡しされたコアファウンデーション型をスウィフト標準のライブラリ型に橋渡しをすることが、橋渡ししているファウンデーション型にあなたが最初にキャストするならば、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also call any Objective-C method and access any property on an AnyObject value without casting to a more specific class type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、あらゆるObjective-Cメソッドを呼び出すこと、そしてAnyObject値上のあらゆるプロパティにアクセスすることが、より具体的なクラス型にキャストすることなしに可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also create an NSArray object directly from a Swift array literal, following the same bridging rules outlined above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、スウィフト配列リテラルから直接NSArrayオブジェクトをつくることが、上で概説されるのと同じ橋渡し規則にしたがって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also create an NSDictionary object directly from a Swift dictionary literal, following the same bridging rules outlined above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、NSDictionaryオブジェクトを直接にスウィフト辞書リテラルから作成することが、上で概説されるのと同じ橋渡し規則にしたがって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also create an NSNumber object using a floating-point, integer, or Boolean literal by explicitly providing a type annotation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、NSNumberオブジェクトを作成することが、浮動小数点、整数、またはブールのリテラルを使って明示的に型注釈を提供することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also create an NSSet object directly from a Swift array literal, following the same bridging rules outlined above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、NSSetオブジェクトを直接にスウィフト配列リテラルから作成することが、上で概説されるのと同じ橋渡し規則にしたがって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also create an NSString object using a string literal by explicitly providing a type annotation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、明示的に型注釈を提供することによって文字列リテラルを使ってNSStringオブジェクトを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also invoke the retain(), release(), and autorelease() methods on unmanaged objects, but this approach is not recommended.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、管理されないオブジェクトの上でretain()、release()、そしてautorelease()メソッドを呼び出すことができます、しかしこの取り組みは推薦されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also nest conditional compilation blocks within other conditional compilation blocks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、条件コンパイルブロックを他の条件コンパイルブロックの内部に入れ子にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also pass a closure property of a generic type or a generic method as long as no generic type parameters are referenced in the closure’s argument list or body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、ひとつの総称体型のクロージャプロパティまたは総称体メソッドを渡すことが、いくつかの総称体型パラメータがクロージャの引数リストまたは本文において参照されるのでない限りは可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also provide a custom name for the product module name and Xcode will use this when naming the bridging and generated headers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、あつらえの名前を製品モジュール名のために用意することができます、そしてXcodeはこれを橋渡しおよび生成ヘッダに名前をつけるとき使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also specify a log level defined by the logging system, such as Info, Debug, or Error, in order to control how log messages are handled according to the importance of the logging event.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、ログイベントの重要性にそってどのようにログメッセージが取り扱われるか制御するために、ログシステムによって定義されるログ水準、例えばInfo、Debug、またはErrorを指定することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also try and downcast to the subclass type by using the as? operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、as?演算子を使うことによって、そのサブクラス型へのダウンキャストを試みることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use an if–let statement to conditionally unwrap the result of a method that the object may not respond to, as shown on line three.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまたif–let文を使用して、３行目で示されるように、条件付きでオブジェクトが応答しないかもしれないメソッドの結果をアンラップすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use extensions to add protocol conformance to a class without subclassing it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた拡張を使って、プロトコル準拠をあるクラスに、それをサブクラス化することなく加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use the CF_IMPLICIT_BRIDGING_ENABLED and CF_IMPLICIT_BRIDGING_DISABLED macros to enclose C function declarations that follow Core Foundation ownership policy naming policy in order to infer memory management from naming.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、CF_IMPLICIT_BRIDGING_ENABLEDとCF_IMPLICIT_BRIDGING_DISABLEDマクロを使って、C関数宣言たち、それらは名前の付け方からメモリ管理を推測するためのコアファウンデーション所有者方針の命名方針に従うもの、を取り囲むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can annotate an Objective-C typedef declaration with the NS_TYPED_ENUM or NS_TYPED_EXTENSIBLE_ENUM macro to have constants of that type imported by Swift as members of a common type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、Objective-Cのtypedef宣言にNS_TYPED_ENUMまたはNS_TYPED_EXTENSIBLE_ENUMマクロで注釈をつけることで、その型の定数をスウィフトによって普通の型のメンバとしてインポートされるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call Objective-C methods from Swift using dot syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、Objective-Cメソッドをスウィフトからドット構文を使って呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call it in any of the following ways:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、以下の方法の何ででもそれを呼ぶことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call it in the following way:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、以下の方法でそれを呼ぶことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can check whether an instance is of a certain subclass type by using the is operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるインスタンスが特定のサブクラス型であるかどうか、is演算子を使うことによって調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can combine compilation conditions using the &amp;&amp; and || operators, negate them with the ! operator, and add branches with #elseif and #else compilation directives.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、コンパイル条件を&amp;&amp;と||を使って結合すること、!演算子でそれらを無効にすること、そして#elseifと#else条件指示子で分岐を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create a GroceryProduct from a JSON representation by creating a JSONDecoder instance and passing it the GroceryProduct.self type along with the JSON data:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはGroceryProductをJSON表現から作成することがJSONDecoderインスタンスを作成してそれをGroceryProduct.self型にそのJSONデータとともに渡すことによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create a new option set value using an array literal, and access option values with a leading dot (.), similar to an enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、新しいオプションセット値を配列リテラルを使って作成すること、そしてオプション値へ前に付けたドット（.）で、列挙のようにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create an NSNumber object by casting a Swift number value using the as operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、NSNumberオブジェクトを作成することが、スウィフト数値をas演算子を使ってキャストすることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create an NSString object by casting a String value using the as operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、NSStringオブジェクトの作成が、String値をas演算子を使ってキャストすることで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create your own singletons as a way to provide a unified access point to a resource or service that’s shared across an app, such as an audio channel to play sound effects or a network manager to make HTTP requests.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるアプリ全体で共有されるリソースやサービス、例えばサウンドエフェクトを再生するオーディオチャンネルやHTTPリクエストを行うネットワークマネージャなどへの一本化されたアクセスポイントを提供する方法として、あなた自身のシングルトンを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define an extension on a type from either a system framework or one of your own custom types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、システム・フレームワークから、またはあなた独自のあつらえの型の１つから、そのどちらかの型の上で拡張を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can denote the availability of your own APIs by annotating declarations with the @available attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、宣言に@available属性で注釈を付けることによって、あなたの独自APIの有効性を示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can do the same in Swift as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、同じことをスウィフトにおいて以下のように行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can format a log message using an NSString or printf format string along with one or more trailing arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはログメッセージをフォーマットすることが、NSStringまたはprintfフォーマット文字列を１つ以上の後に続く引数とともに使うことで行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can get a list of any command-line arguments that are specified at launch by accessing the CommandLine.arguments type property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、起動時にCommandLine.arguments型プロパティにアクセスすることによって指定される、あらゆるコマンドライン引数のリストを得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can import a framework into any Objective-C .m file within a different target using the following syntax:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、フレームワークを異なるターゲット内のどんなObjective-C .mファイルにでも以下の構文を使ってインポートすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can import a framework into any Swift file within a different target using the following syntax:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはフレームワークをある異なるターゲット内のどんなスウィフトファイルにでも、以下の構文を使ってインポートすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can import external frameworks that have a pure Objective-C codebase, a pure Swift codebase, or a mixed-language codebase.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、純粋なObjective-Cコードベース、純粋なスウィフトコードベース、または混合言語のコードベースを持つ外部のフレームワークをインポートすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can indicate whether initializers in your own Objective-C classes can fail using nullability annotations, as described in Nullability and Optionals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなた独自のObjective-Cクラスの中のイニシャライザが失敗できるかどうかをヌル許可注釈を使って指し示すことができます、それはヌル許可とオプショナルで記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can invoke an Objective-C method on an Objective-C compatible object using a selector with the perform(_:) method or one of its variants.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはObjective-CメソッドをObjective-C互換オブジェクト上で発動することがperform(_:)メソッドやそれの変種の１つを持つセレクタを使うことで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override isEqual: in a subclass to have Swift and Objective-C APIs determine equality based on the contents of objects rather than their identities.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、isEqual:をサブクラスにおいてオーバーライドして、それらの同一性ではなくてオブジエクトの内容に基づいて同等性を判断するスウィフトとObjective-C APIを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide a refined Swift interface in an extension like this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、改良スウィフトインターフェイスをある拡張においてこのように提供することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide an explicit type when assigning to a constant or variable, or you can omit the type and have Swift infer the type automatically from the initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、定数または変数に割り当てする時に明示的な型を提供することができます、またはあなたは型を省略してスウィフトに型をイニシャライザから自動的に推論させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set up your Swift class to integrate Objective-C behavior by subclassing Objective-C classes, adopting Objective-C protocols, and more.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたのスウィフトクラスをObjective-Cクラスのサブクラスにすること、Objective-Cプロトコルを採用すること、そしてもっと多くのことによって、Objective-C挙動に溶け込むように準備することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can simply add a file of the other language directly to an existing project.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、単に既存のプロジェクトに直接他の言語のファイルを加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can still use Swift methods and properties that are marked with the internal modifier from within the Objective-C part of your framework, as long they are declared within a class that inherits from an Objective-C class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは依然としてinternal修飾子で印されるスウィフトのメソッドとプロパティをあなたのフレームワークのObjecctive-C部分の内部から使うことができます、それらがObjective-Cクラスから継承するクラスの内部で宣言される限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can subclass Objective-C classes, declare and adopt Objective-C protocols, and take advantage of other Objective-C functionality when writing Swift code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、スウィフトコードを記述する時に、Objective-Cクラスのサブクラス作成、Objective-Cプロトコルの宣言と採用、そして他のObjective-C機能性の利用が可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can take advantage of Cocoa’s undo architecture in Swift just as you would in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、Cocoaの取り消し機構の長所をスウィフトにおいてまさにあなたがObjective-Cでするように利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use Objective-C APIs in Swift, and you can use Swift APIs in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはObjective-CのAPIをスウィフトにおいて使うことができます、そしてあなたはスウィフト APIをObjective-Cにおいて使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use extensions to add properties (including class and static properties).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、拡張を使ってプロパティ（クラスや静的なプロパティを含む）を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use it to resolve circularity for bridging methods and to allow overloading of methods for classes imported by Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはそれを使って、メソッドをブリッジすることの循環性を解決して、Objective-Cでインポートされるクラスに対してメソッドのオーバーロードを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use key-value observing with a Swift class, as long as the class inherits from the NSObject class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、そのクラスがNSObjectクラスから継承する限り、スウィフトクラスでキー値監視を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use optional binding to unwrap the result of a failable initializer if initialization is successful.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはオプショナル束縛を使って、初期化がうまくいったならば失敗できるイニシャライザの結果をアンラップすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the @objc(name) attribute to change the name of a class, property, method, enumeration type, or enumeration case declaration in your interface as it’s exposed to Objective-C code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、@objc(name)属性を使うことで、あなたのインターフェイスにおいてクラス、プロパティ、メソッド、列挙型、または列挙ケース宣言の名前を変更することがそれがObjective-Cコードに露出されるときに可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the @objc(name) attribute to explicitly specify the corresponding Objective-C symbol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&gt;@objc(name)属性を使うことで、対応するObjective-Cシンボルを明示的に指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the CF_SWIFT_NAME macro in your own code to have Swift import C functions as members of the imported structure type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、CF_SWIFT_NAMEマクロをあなた自身のコードにおいて使うことで、スウィフトがC関数をインポートされた構造体型のメンバとしてインポートするようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the NS_REFINED_FOR_SWIFT macro on an Objective-C method declaration to provide a refined Swift interface in an extension, while keeping the original implementation available to be called from the refined interface.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、NS_REFINED_FOR_SWIFTマクロをObjective-Cメソッド宣言上で使って、ある拡張において改良スウィフトインターフェイスを提供して、オリジナル実装を利用可能に保ったまま、その改良インターフェイスから呼び出されるようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the @objc(name) attribute to explicitly specify the corresponding Objective-C symbol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、@objc(name)属性を使うことで、対応するObjective-Cシンボルを明示的に指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the Foundation framework classes JSONEncoder and PropertyListEncoder to convert instances to JSON or property list data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、FoundationフレームワーククラスJSONEncoderとPropertyListEncoderを使って、インスタンスをJSONまたはプロパティリストデータへ変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the arithmetic operators on Swift pointer values to create new pointers at a specified offset.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは算術演算子をスウィフトポインタ値上で使って、新しいポインタを指定されたオフセットで作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the conditional type cast operator (as?), which returns an optional value of the type you are trying to downcast to:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、条件型キャスト演算子（as?）を使うことができます、それは、あなたがそれへとダウンキャストを試みている型のオプショナルの値を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the same optional chaining syntax you would use for optional methods in protocols to optionally invoke a method on AnyObject.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロトコルにおいてオプショナルメソッドに対して使う同じオプショナル連鎖構文を使って、AnyObject上でメソッドを随意なものとして発動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the same or a different name than your Objective-C class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたのObjective-Cクラスと同じまたは異なる名前を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use them in the same way you would in Objective-C, accessing any properties and calling any methods defined on their respective types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それらをあなたがObjective-Cでするのと同じ方法で使って、それらの各自の型上で定義される、どんなプロパティにでもアクセスして、どんなメソッドでも呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use these two steps to implement key-value observing in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、これら２つの手順を使ってキー値監視をスウィフトにおいて実装できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this feature, called mix and match, to write apps that have a mixed-language codebase.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこの特徴、混合と適合と呼ばれるものを働かせて、混合言語のコードベースを持つアプリを記述することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use two different attributes—@IBDesignable and @IBInspectable—to enable live, interactive custom view design in Interface Builder.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、インタフェースビルダーにおいて、生の、双方向のあつらえのビュー設計をできるように、２つの異なる属性 ― @IBDesignableと@IBInspectable ― を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot import C++ code directly into Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、スウィフトに直接C++コードをインポートすることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot override the product module name of a framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、フレームワークの製品モジュール名をオーバーライドすることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot reorder or change the number of arguments for type members imported using the CF_SWIFT_NAME macro.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、CF_SWIFT_NAMEマクロを使ってインポートされる型メンバのための引数の数を変更したり順番を変えたりできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot subclass a Swift class in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、スウィフトクラスのサブクラスをObjective-Cにおいて作成できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot use extensions to override existing methods or properties on Objective-C types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、Objective-C型上での既存のメソッドまたはプロパティをオーバーライドするために拡張を使うことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You choose which method to use based on whether the API you are invoking returns an unretained or retained object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたが呼んでいるAPIが保有されない、または保有されるオブジェクトを返すかに基づいて、どちらかのメソッドを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You create a new option set from a constant value or expression, An empty option set is represented by the constant zero (0).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、新しいオプションセットを定数値または式から作成します。空のオプションセットは定数ゼロ（0）で表現されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don’t need to do anything special to create the generated header file—just import it to use its contents in your Objective-C code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、生成ヘッダ・ファイルを作成するために特に何もする必要がありません ― あなたは、単にあなたのObjective-Cコードにおいてその内容を使うためにそれをインポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might encounter Objective-C code that uses the older NS_STRING_ENUM and NS_EXTENSIBLE_STRING_ENUM macros, which were used to group string constants.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、より古いNS_STRING_ENUMおよびNS_EXTENSIBLE_STRING_ENUMマクロを使うObjective-Cコードに直面するかもしれません、それは文字列定数をグループにするために使われました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must cast it back to another type to perform other operations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、他の操作を実行するために再び別の型へそれをキャストしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should not override the equality or identity operators for types imported from Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、Objective-Cからインポートされた型に対する同等性または同一性演算子をオーバーライドすべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use complex macros in C and Objective-C to avoid type-checking constraints or to avoid retyping large amounts of boilerplate code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、複雑なマクロをCとObjective-Cにおいて型チェック制約を避けたり、常用文コードの大きな塊を繰り返しタイピングすることを避けるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use native Swift initialization syntax even when you are working with Objective-C classes—Swift converts Objective-C initialization methods to Swift initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがObjective-Cクラスを扱っているときでも、あなたは生粋のスウィフト初期化構文を使います ― スウィフトは、Objective-C初期化メソッドをスウィフトイニシャライザに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the @objc attribute along with the dynamic modifier to require that access to members be dynamically dispatched through the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、@objc属性に加えてdynamic修飾子を使うことで、メンバへのアクセスがObjective-Cランタイムを通して動的にディスパッチされることを要請します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the @NSManaged attribute to inform the Swift compiler that Core Data provides the storage and implementation of a declaration at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、@NSManaged属性を使って、コアデータがある宣言のストレージと実装を実行時に提供することをスウィフトコンパイラに知らせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the insert(_:) or formUnion(_:) methods to add option values, the remove(_:) or subtract(_:) methods to remove option values, and the contains(_:) method to check for an option value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはinsert(_:)またはformUnion(_:)メソッドを使ってオプション値を付け加え、remove(_:)またはsubtract(_:)メソッドを使ってオプション値を削除し、そしてcontains(_:)メソッドを使ってあるオプション値を調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the bitwise OR operator (|) to combine option values, and the bitwise AND operator (&amp;) to check for option values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはビット単位OR演算子（|）をオプション値を結合するために、そしてビット単位AND演算子（&amp;）をオプション値の確認に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the same @IBOutlet attribute to declare an outlet collection—just specify an array for the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、同じ@IBOutlet属性をアウトレット・コレクションを宣言するために使います ― ちょうどある配列に型を指定するように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use this when calling C functions from Swift that take the size of a type or value as an argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこれを使うのは、ある型や値のサイズを引数としてとるC関数をスウィフトから呼び出している時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You won’t create a header file; Xcode generates a header automatically in case you need to reference it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはヘッダ・ファイルを作成しません；あなたがそれに参照をつける必要がある場合に備えて、Xcodeが自動的にヘッダを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your existing code should follow modern coding practices to make it easier to interact with Swift seamlessly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたの既存のコードは、継ぎ目なくスウィフトと相互に作用することをより簡単にするために、現代のコード記述慣行に従わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You’ll need to edit the bridging header file to expose your Objective-C code to your Swift code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたのObjective-Cコードをあなたのスウィフトコードに露出するためにこのファイルを編集する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You’ll replace the .m and .h files for that class with a single .swift file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、そのクラスのための.mと.hファイルを単一の.swiftファイルで置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>id Compatibility</seg>
      </tuv>
      <tuv lang="JA">
        <seg>id互換性</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
