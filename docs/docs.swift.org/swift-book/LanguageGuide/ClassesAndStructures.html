

<!DOCTYPE html>



<head>
    <meta charset="utf-8" />
    <meta name="author" content="Apple Inc." />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    
    <title>Structures and Classes &mdash; The Swift Programming Language (Swift 4.2)</title>
    
    <link rel="license" href="/LICENSE.txt" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css" />
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" /> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 4.2</div></h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Welcome to Swift<br><span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="TheBasics.html">Language Guide<br><span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html">The Basics<br><span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html">Basic Operators<br><span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html">Strings and Characters<br><span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html">Collection Types<br><span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html">Control Flow<br><span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html">Functions<br><span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html">Closures<br><span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html">Enumerations<br><span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Structures and Classes<br><span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html">Properties<br><span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html">Methods<br><span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html">Subscripts<br><span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html">Inheritance<br><span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html">Initialization<br><span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html">Deinitialization<br><span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html">Optional Chaining<br><span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html">Error Handling<br><span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html">Type Casting<br><span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html">Nested Types<br><span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html">Extensions<br><span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html">Protocols<br><span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html">Generics<br><span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html">Automatic Reference Counting<br><span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html">Memory Safety<br><span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html">Access Control<br><span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html">Advanced Operators<br><span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html">Language Reference<br><span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html">Revision History<br><span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="https://swift.org/">← Return to Swift.org</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
                <ul>
<li><a class="reference internal" href="#">Structures and Classes<br><span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID83">Comparing Structures and Classes<br><span class="jpstr">
構造体とクラスを比較する
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID84">Definition Syntax<br><span class="jpstr">
定義構文
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID85">Structure and Class Instances<br><span class="jpstr">
構造体とクラスのインスタンス
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID86">Accessing Properties<br><span class="jpstr">
プロパティにアクセスする
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID87">Memberwise Initializers for Structure Types<br><span class="jpstr">
構造体型のためのメンバー関連イニシャライザ
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID88">Structures and Enumerations Are Value Types<br><span class="jpstr">
構造体と列挙は値型です
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID89">Classes Are Reference Types<br><span class="jpstr">
クラスは、参照型です
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID90">Identity Operators<br><span class="jpstr">
同一性演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID91">Pointers<br><span class="jpstr">
ポインター
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="structures-and-classes">
<h1>Structures and Classes<a class="headerlink" href="#structures-and-classes" title="Permalink to this headline">¶</a><br><span class="jpstr">
構造体とクラス<a class="headerlink" href="#structures-and-classes" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h1>
<p><em>Structures</em> and <em>classes</em> are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions.<br><span class="jpstr">
<em>構造体</em>および<em>クラス</em>は、あなたのプログラムのコードの建築ブロックになる、万能で、柔軟な構造物です。あなたはプロパティとメソッドを定義することで、あなたの構造体およびクラスに機能性を加えます、それには定数、変数、そして関数を定義するのにあなたが使うのと同じ構文を使います。
</span><!--end_jpstr-->
</p>
<p>Unlike other programming languages, Swift doesn’t require you to create separate interface and implementation files for custom structures and classes. In Swift, you define a structure or class in a single file, and the external interface to that class or structure is automatically made available for other code to use.<br><span class="jpstr">
他のプログラミング言語と違って、スウィフトはあなたにあつらえの構造体およびクラスのために別々のインタフェースおよび実装ファイルを作成することを要求しません。スウィフトでは、あなたはある構造体またはクラスをある単一のファイルの中で定義します、そして、そのクラスまたは構造体への外部インタフェースは自動的に他のコードが使うことが可能にされます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">An instance of a class is traditionally known as an <em>object</em>. However, Swift structures and classes are much closer in functionality than in other languages, and much of this chapter describes functionality that applies to instances of <em>either</em> a class or a structure type. Because of this, the more general term <em>instance</em> is used.<br><span class="jpstr">
クラスのインスタンスは、伝統的に<em>オブジェクト</em>として知られています。しかし、スウィフトの構造体とクラスは他の言語においてよりも機能性において非常に近いものです、したがってこの章の多くはクラスまたは構造体型の<em>両方の</em>インスタンスに適用される機能性を記述します。これのため、より一般的な語<em>インスタンス</em>が使われます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID83">
<h2>Comparing Structures and Classes<a class="headerlink" href="#ID83" title="Permalink to this headline">¶</a><br><span class="jpstr">
構造体とクラスを比較する<a class="headerlink" href="#ID83" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>Structures and classes in Swift have many things in common. Both can:<br><span class="jpstr">
スウィフトでの構造体とクラスは、多くのものを共通して持ちます。両方とも以下のことができます：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>Define properties to store values<br><span class="jpstr">
値を格納するために、プロパティを定義します
</span><!--end_jpstr-->
</li>
<li>Define methods to provide functionality<br><span class="jpstr">
機能性を提供するために、メソッドを定義します
</span><!--end_jpstr-->
</li>
<li>Define subscripts to provide access to their values using subscript syntax<br><span class="jpstr">
添え字構文を使用してそれらの値の利用することを提供するために、添え字を定義します
</span><!--end_jpstr-->
</li>
<li>Define initializers to set up their initial state<br><span class="jpstr">
それらの初期状態を設定するために、イニシャライザを定義します
</span><!--end_jpstr-->
</li>
<li>Be extended to expand their functionality beyond a default implementation<br><span class="jpstr">
それらの機能性を元の実装を越えて広げるために、拡張されます
</span><!--end_jpstr-->
</li>
<li>Conform to protocols to provide standard functionality of a certain kind<br><span class="jpstr">
特定の種類の標準の機能性を提供するために、プロトコルに準拠します
</span><!--end_jpstr-->
</li>
</ul>
<p>For more information, see <a class="reference internal" href="Properties.html"><span class="doc">Properties</span></a>, <a class="reference internal" href="Methods.html"><span class="doc">Methods</span></a>, <a class="reference internal" href="Subscripts.html"><span class="doc">Subscripts</span></a>, <a class="reference internal" href="Initialization.html"><span class="doc">Initialization</span></a>, <a class="reference internal" href="Extensions.html"><span class="doc">Extensions</span></a>, and <a class="reference internal" href="Protocols.html"><span class="doc">Protocols</span></a>.<br><span class="jpstr">
詳細は、<a class="reference internal" href="Properties.html"><span class="doc">プロパティ</span></a>, <a class="reference internal" href="Methods.html"><span class="doc">メソッド</span></a>、<a class="reference internal" href="Subscripts.html"><span class="doc">添え字</span></a>、<a class="reference internal" href="Initialization.html"><span class="doc">初期化</span></a>、<a class="reference internal" href="Extensions.html"><span class="doc">拡張</span></a>、そして<a class="reference internal" href="Protocols.html"><span class="doc">プロトコル</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>Classes have additional capabilities that structures don’t have:<br><span class="jpstr">
クラスは以下の追加の能力を持ちます、それは構造体が持たないものです：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>Inheritance enables one class to inherit the characteristics of another.<br><span class="jpstr">
継承は、あるクラスが他のものの特徴を受け継ぐのを可能にします。
</span><!--end_jpstr-->
</li>
<li>Type casting enables you to check and interpret the type of a class instance at runtime.<br><span class="jpstr">
型キャストは、あなたにクラスインスタンスの型を実行時に調べて解釈することを可能にします。
</span><!--end_jpstr-->
</li>
<li>Deinitializers enable an instance of a class to free up any resources it has assigned.<br><span class="jpstr">
デイニシャライザは、クラスのインスタンスにそれが代入したどんなリソースでも解放するのを可能にします。
</span><!--end_jpstr-->
</li>
<li>Reference counting allows more than one reference to a class instance.<br><span class="jpstr">
参照カウントは、あるクラスインスタンスに対する１つ以上の参照を許します。
</span><!--end_jpstr-->
</li>
</ul>
<p>For more information, see <a class="reference internal" href="Inheritance.html"><span class="doc">Inheritance</span></a>, <a class="reference internal" href="TypeCasting.html"><span class="doc">Type Casting</span></a>, <a class="reference internal" href="Deinitialization.html"><span class="doc">Deinitialization</span></a>, and <a class="reference internal" href="AutomaticReferenceCounting.html"><span class="doc">Automatic Reference Counting</span></a>.<br><span class="jpstr">
詳細は、<a class="reference internal" href="Inheritance.html"><span class="doc">継承</span></a>、<a class="reference internal" href="TypeCasting.html"><span class="doc">型キャスト</span></a>、<a class="reference internal" href="Deinitialization.html"><span class="doc">デイニシャライズ</span></a>、そして<a class="reference internal" href="AutomaticReferenceCounting.html"><span class="doc">自動参照カウント</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>The additional capabilities that classes support come at the cost of increased complexity. As a general guideline, prefer structures and enumerations because they’re easier to reason about, and use classes when they’re appropriate or necessary. In practice, this means most of the custom data types you define will be structures and enumerations. For a more detailed comparison, see <a class="reference external" href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes">Choosing Between Structures and Classes</a>.<br><span class="jpstr">
クラスがサポートする追加の能力は、複雑さの増加という犠牲を伴います。一般的な指針として、構造体や列挙を選んでください、なぜならそれらは推論するのがより簡単だからです、そしてそれが適切または必要である場合はクラスを使ってください。実際問題としては、これは、あなたが定義するほとんどのあつらえのデータ型は構造体や列挙になることを意味します。詳細な比較は、<a class="reference external" href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes">構造体とクラスから選ぶ</a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID84">
<h3>Definition Syntax<a class="headerlink" href="#ID84" title="Permalink to this headline">¶</a><br><span class="jpstr">
定義構文<a class="headerlink" href="#ID84" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>Structures and classes have a similar definition syntax. You introduce structures with the <code class="docutils literal notranslate"><span class="pre">struct</span></code> keyword and classes with the <code class="docutils literal notranslate"><span class="pre">class</span></code> keyword. Both place their entire definition within a pair of braces:<br><span class="jpstr">
構造体とクラスは、類似した定義構文を持ちます。あなたは、<code class="docutils literal notranslate"><span class="pre">struct</span></code>キーワードで構造体を、そして<code class="docutils literal notranslate"><span class="pre">class</span></code>キーワードでクラスを始めます。両方とも、それらの全ての定義を一対の波括弧の範囲内に置きます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">SomeStructure</span> {
</li><li>    <span class="c">// structure definition goes here&nbsp;<span class="jpstr">（構造体定義が、ここにきます）</span><!--end_jpstr-->
</span>
</li><li>}
</li><li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li><li>    <span class="c">// class definition goes here&nbsp;<span class="jpstr">（クラス定義が、ここにきます）</span><!--end_jpstr-->
</span>
</li><li>}
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">Whenever you define a new structure or class, you define a new Swift type. Give types <code class="docutils literal notranslate"><span class="pre">UpperCamelCase</span></code> names (such as <code class="docutils literal notranslate"><span class="pre">SomeStructure</span></code> and <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code> here) to match the capitalization of standard Swift types (such as <code class="docutils literal notranslate"><span class="pre">String</span></code>, <code class="docutils literal notranslate"><span class="pre">Int</span></code>, and <code class="docutils literal notranslate"><span class="pre">Bool</span></code>). Give properties and methods <code class="docutils literal notranslate"><span class="pre">lowerCamelCase</span></code> names (such as <code class="docutils literal notranslate"><span class="pre">frameRate</span></code> and <code class="docutils literal notranslate"><span class="pre">incrementCount</span></code>) to differentiate them from type names.<br><span class="jpstr">
あなたが新しいクラスまたは構造体を定義するときはいつでも、あなたはある新しいスウィフト型を定義します。それら型に<code class="docutils literal notranslate"><span class="pre">UpperCamelCase アッパーキャメルケース</span></code>名（ここでの<code class="docutils literal notranslate"><span class="pre">SomeStructure</span></code>や<code class="docutils literal notranslate"><span class="pre">SomeClass</span></code>のような）を与えて、標準のスウィフト型（例えば<code class="docutils literal notranslate"><span class="pre">String</span></code>、<code class="docutils literal notranslate"><span class="pre">Int</span></code>、そして<code class="docutils literal notranslate"><span class="pre">Bool</span></code>など）の大文字の使用法に合わせてください。プロパティとメソッドに<code class="docutils literal notranslate"><span class="pre">lowerCamelCase ローワーキャメルケース</span></code>名（例えば<code class="docutils literal notranslate"><span class="pre">frameRate</span></code>や<code class="docutils literal notranslate"><span class="pre">incrementCount</span></code>など）を与えて、それらを型名と区別するようにしてください。
</span><!--end_jpstr-->
</p>
</div>
<p>Here’s an example of a structure definition and a class definition:<br><span class="jpstr">
構造体定義とクラス定義の例は、ここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Resolution</span> {
</li><li>    <span class="k">var</span> <span class="nv">width</span> = <span class="m">0</span>
</li><li>    <span class="k">var</span> <span class="nv">height</span> = <span class="m">0</span>
</li><li>}
</li><li><span class="k">class</span> <span class="nv">VideoMode</span> {
</li><li>    <span class="k">var</span> <span class="nv">resolution</span> = <span class="nv">Resolution</span>()
</li><li>    <span class="k">var</span> <span class="nv">interlaced</span> = <span class="k">false</span>
</li><li>    <span class="k">var</span> <span class="nv">frameRate</span> = <span class="m">0.0</span>
</li><li>    <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>?
</li><li>}
</li></ol></div></div></div>
<p>The example above defines a new structure called <code class="docutils literal notranslate"><span class="pre">Resolution</span></code>, to describe a pixel-based display resolution. This structure has two stored properties called <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code>. Stored properties are constants or variables that are bundled up and stored as part of the structure or class. These two properties are inferred to be of type <code class="docutils literal notranslate"><span class="pre">Int</span></code> by setting them to an initial integer value of <code class="docutils literal notranslate"><span class="pre">0</span></code>.<br><span class="jpstr">
上の例は、ピクセルに基づくディスプレイ解像度を記述するために、<code class="docutils literal notranslate"><span class="pre">Resolution</span></code>と呼ばれる新しい構造体を定義します。この構造体は、２つの格納プロパティ、<code class="docutils literal notranslate"><span class="pre">width</span></code>と<code class="docutils literal notranslate"><span class="pre">height</span></code>と呼ばれるものを持ちます。格納プロパティは、構造体またはクラスの一部としてまとめられて格納される定数または変数です。これらの２つのプロパティは、それらを最初の整数値<code class="docutils literal notranslate"><span class="pre">0</span></code>に設定することによって型<code class="docutils literal notranslate"><span class="pre">Int</span></code>であると推論されます。
</span><!--end_jpstr-->
</p>
<p>The example above also defines a new class called <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>, to describe a specific video mode for video display. This class has four variable stored properties. The first, <code class="docutils literal notranslate"><span class="pre">resolution</span></code>, is initialized with a new <code class="docutils literal notranslate"><span class="pre">Resolution</span></code> structure instance, which infers a property type of <code class="docutils literal notranslate"><span class="pre">Resolution</span></code>. For the other three properties, new <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> instances will be initialized with an <code class="docutils literal notranslate"><span class="pre">interlaced</span></code> setting of <code class="docutils literal notranslate"><span class="pre">false</span></code> (meaning “noninterlaced video”), a playback frame rate of <code class="docutils literal notranslate"><span class="pre">0.0</span></code>, and an optional <code class="docutils literal notranslate"><span class="pre">String</span></code> value called <code class="docutils literal notranslate"><span class="pre">name</span></code>. The <code class="docutils literal notranslate"><span class="pre">name</span></code> property is automatically given a default value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, or “no <code class="docutils literal notranslate"><span class="pre">name</span></code> value”, because it’s of an optional type.<br><span class="jpstr">
上の例は、また、ビデオ・ディスプレイのために特定のビデオ・モードを記述するために、<code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>と呼ばれる新しいクラスを定義します。このクラスは、４つの変数の格納プロパティを持ちます。一番目、<code class="docutils literal notranslate"><span class="pre">resolution</span></code>は、新しい<code class="docutils literal notranslate"><span class="pre">Resolution</span></code>構造体インスタンスで初期化されます、そしてそれは、<code class="docutils literal notranslate"><span class="pre">Resolution</span></code>のプロパティ型を暗に意味します。他の３つのプロパティのために、新しい<code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>インスタンスは、<code class="docutils literal notranslate"><span class="pre">false</span></code>に設定される<code class="docutils literal notranslate"><span class="pre">interlaced</span></code>（「ノンインタレース・ビデオ」を意味します）、<code class="docutils literal notranslate"><span class="pre">0.0</span></code>の再生フレームレート、<code class="docutils literal notranslate"><span class="pre">name</span></code>というオプショナルの<code class="docutils literal notranslate"><span class="pre">String</span></code>値で初期化されます。<code class="docutils literal notranslate"><span class="pre">name</span></code>プロパティは省略時の値の<code class="docutils literal notranslate"><span class="pre">nil</span></code>、つまり「<code class="docutils literal notranslate"><span class="pre">name</span></code>値なし」を自動的に与えられます、なぜならそれがオプショナル型であるからです。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID85">
<h3>Structure and Class Instances<a class="headerlink" href="#ID85" title="Permalink to this headline">¶</a><br><span class="jpstr">
構造体およびクラスのインスタンス<a class="headerlink" href="#ID85" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Resolution</span></code> structure definition and the <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> class definition only describe what a <code class="docutils literal notranslate"><span class="pre">Resolution</span></code> or <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> will look like. They themselves don’t describe a specific resolution or video mode. To do that, you need to create an instance of the structure or class.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Resolution</span></code>構造体定義と<code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>クラス定義は、<code class="docutils literal notranslate"><span class="pre">Resolution</span></code>または<code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>がどのようなものかについて記述するだけです。それらはそれら自体で、特定の解像度またはビデオ・モードを記述しません。それをするために、あなたは構造体またはクラスのインスタンスをつくる必要があります。
</span><!--end_jpstr-->
</p>
<p>The syntax for creating instances is very similar for both structures and classes:<br><span class="jpstr">
インスタンスをつくるための構文は、構造体とクラスの両方で非常に類似しています：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someResolution</span> = <span class="nv">Resolution</span>()
</li><li><span class="k">let</span> <span class="nv">someVideoMode</span> = <span class="nv">VideoMode</span>()
</li></ol></div></div></div>
<p>Structures and classes both use initializer syntax for new instances. The simplest form of initializer syntax uses the type name of the class or structure followed by empty parentheses, such as <code class="docutils literal notranslate"><span class="pre">Resolution()</span></code> or <code class="docutils literal notranslate"><span class="pre">VideoMode()</span></code>. This creates a new instance of the class or structure, with any properties initialized to their default values. Class and structure initialization is described in more detail in <a class="reference internal" href="Initialization.html"><span class="doc">Initialization</span></a>.<br><span class="jpstr">
構造体とクラスは両方とも、新しいインスタンスのためにイニシャライザ構文を使います。イニシャライザ構文の最も単純な形式は、クラスまたは構造体の型名を使用して、それに空の丸括弧を続けます、例えば<code class="docutils literal notranslate"><span class="pre">Resolution()</span></code>または<code class="docutils literal notranslate"><span class="pre">VideoMode()</span></code>のように。これは、クラスまたは構造体の新しいインスタンスをつくり、どんなプロパティでもそれらの省略時の値に初期化されます。クラスと構造体の初期化は、更に詳細に<a class="reference internal" href="Initialization.html"><span class="doc">初期化</span></a>で記述されます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID86">
<h3>Accessing Properties<a class="headerlink" href="#ID86" title="Permalink to this headline">¶</a><br><span class="jpstr">
プロパティにアクセスする<a class="headerlink" href="#ID86" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>You can access the properties of an instance using <em>dot syntax</em>. In dot syntax, you write the property name immediately after the instance name, separated by a period (<code class="docutils literal notranslate"><span class="pre">.</span></code>), without any spaces:<br><span class="jpstr">
あなたは、<em>ドット構文</em>を使ってインスタンスのプロパティにアクセスすることができます。ドット構文において、あなたはプロパティ名をインスタンス名の直後に、終止符（<code class="docutils literal notranslate"><span class="pre">.</span></code>）で区切り、どんな空白もなしで、書きます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">&quot;The width of someResolution is </span>\<span class="p">(</span><span class="nv">someResolution</span>.<span class="nv">width</span><span class="p">)</span><span class="s">&quot;</span>)
</li><li><span class="c">// Prints &quot;The width of someResolution is 0&quot;&nbsp;<span class="jpstr">（「someResolutionの幅は0です」を出力します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">someResolution.width</span></code> refers to the <code class="docutils literal notranslate"><span class="pre">width</span></code> property of <code class="docutils literal notranslate"><span class="pre">someResolution</span></code>, and returns its default initial value of <code class="docutils literal notranslate"><span class="pre">0</span></code>.<br><span class="jpstr">
この例では、<code class="docutils literal notranslate"><span class="pre">someResolution.width</span></code>は<code class="docutils literal notranslate"><span class="pre">someResolution</span></code>の<code class="docutils literal notranslate"><span class="pre">width</span></code>プロパティに言及して、その省略時の初期値の<code class="docutils literal notranslate"><span class="pre">0</span></code>を返します。
</span><!--end_jpstr-->
</p>
<p>You can drill down into subproperties, such as the <code class="docutils literal notranslate"><span class="pre">width</span></code> property in the <code class="docutils literal notranslate"><span class="pre">resolution</span></code> property of a <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>:<br><span class="jpstr">
あなたは、下位プロパティへと掘り下っていくことができます、例えば、ある<code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>の<code class="docutils literal notranslate"><span class="pre">resolution</span></code>プロパティの中の<code class="docutils literal notranslate"><span class="pre">width</span></code>プロパティ：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">&quot;The width of someVideoMode is </span>\<span class="p">(</span><span class="nv">someVideoMode</span>.<span class="nv">resolution</span>.<span class="nv">width</span><span class="p">)</span><span class="s">&quot;</span>)
</li><li><span class="c">// Prints &quot;The width of someVideoMode is 0&quot;&nbsp;<span class="jpstr">（「someVideoModeの幅は0です」を出力します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>You can also use dot syntax to assign a new value to a variable property:<br><span class="jpstr">
あなたは、また、新しい値を変数プロパティに代入するためにドット構文を使うことができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">someVideoMode</span>.<span class="nv">resolution</span>.<span class="nv">width</span> = <span class="m">1280</span>
</li><li><span class="nv">print</span>(<span class="s">&quot;The width of someVideoMode is now </span>\<span class="p">(</span><span class="nv">someVideoMode</span>.<span class="nv">resolution</span>.<span class="nv">width</span><span class="p">)</span><span class="s">&quot;</span>)
</li><li><span class="c">// Prints &quot;The width of someVideoMode is now 1280&quot;&nbsp;<span class="jpstr">（「someVideoModeの幅は、現在は1280です」を出力します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID87">
<h3>Memberwise Initializers for Structure Types<a class="headerlink" href="#ID87" title="Permalink to this headline">¶</a><br><span class="jpstr">
構造体型のためのメンバー関連イニシャライザ<a class="headerlink" href="#ID87" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>All structures have an automatically generated <em>memberwise initializer</em>, which you can use to initialize the member properties of new structure instances. Initial values for the properties of the new instance can be passed to the memberwise initializer by name:<br><span class="jpstr">
全ての構造体は自動的に生成される<em>メンバー関連イニシャライザ</em>を持ちます、それはあなたが新しい構造体インスタンスのメンバープロパティを初期化するために使うことが可能です。新しいインスタンスのプロパティのための最初の値は、名前によってメンバー関連イニシャライザに渡されることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">vga</span> = <span class="nv">Resolution</span>(<span class="nv">width</span>: <span class="m">640</span>, <span class="nv">height</span>: <span class="m">480</span>)
</li></ol></div></div></div>
<p>Unlike structures, class instances don’t receive a default memberwise initializer. Initializers are described in more detail in <a class="reference internal" href="Initialization.html"><span class="doc">Initialization</span></a>.<br><span class="jpstr">
構造体と違って、クラスインスタンスは、自動生成のメンバー関連イニシャライザを授けられません。イニシャライザは、更に詳細に<a class="reference internal" href="Initialization.html"><span class="doc">初期化</span></a>で記述されます。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID88">
<h2>Structures and Enumerations Are Value Types<a class="headerlink" href="#ID88" title="Permalink to this headline">¶</a><br><span class="jpstr">
構造体と列挙は値型です<a class="headerlink" href="#ID88" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A <em>value type</em> is a type whose value is <em>copied</em> when it’s assigned to a variable or constant, or when it’s passed to a function.<br><span class="jpstr">
<em>値型</em>は、それが変数または定数に代入される時に、あるいは、それが関数に渡されるときに、値が<em>コピー</em>される型です。
</span><!--end_jpstr-->
</p>
<p>You’ve actually been using value types extensively throughout the previous chapters. In fact, all of the basic types in Swift—integers, floating-point numbers, Booleans, strings, arrays and dictionaries—are value types, and are implemented as structures behind the scenes.<br><span class="jpstr">
あなたは、実際に前の章を通して広く値型を使っていました。実際、スウィフトにおける基本の型の全て ― 整数、浮動小数点数、ブール、文字列、配列および辞書 ― は、値型であり、そして舞台裏では構造体として実装されます。
</span><!--end_jpstr-->
</p>
<p>All structures and enumerations are value types in Swift. This means that any structure and enumeration instances you create—and any value types they have as properties—are always copied when they are passed around in your code.<br><span class="jpstr">
全ての構造体と列挙は、スウィフトでは値型です。これは、あなたがつくるあらゆる構造体や列挙のインスタンス ― そして、それらがプロパティとして持つあらゆる値型 ― は、あなたのコードの中であちこち渡される時に常にコピーされることを意味します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">Collections defined by the standard library like arrays, dictionaries, and strings use an optimization to reduce the performance cost of copying. Instead of making a copy immediately, these collections share the memory where the elements are stored between the original instance and any copies. If one of the copies of the collection is modified, the elements are copied just before the modification. The behavior you see in your code is always as if a copy took place immediately.<br><span class="jpstr">
配列、辞書、そして文字列のような、標準ライブラリによって定義されるコレクションは、ある最適化を使うことでコピーすることによる性能損失を減らします。あるコピーを直接に作る代わりに、それらコレクションは要素が格納されるところのメモリを、元のインスタンスと何らかのコピーの間で共有します。そのコレクションのいくつかのコピーのうちの１つが修正されるならば、それら要素はその修正の直前にコピーされます。あなたがあなたのコードで見るこの挙動は、常にまるである１つのコピーが直ちに生じたかのようです。
</span><!--end_jpstr-->
</p>
</div>
<p>Consider this example, which uses the <code class="docutils literal notranslate"><span class="pre">Resolution</span></code> structure from the previous example:<br><span class="jpstr">
この例を考慮してください、それは、前の例から<code class="docutils literal notranslate"><span class="pre">Resolution</span></code>構造体を使用します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">hd</span> = <span class="nv">Resolution</span>(<span class="nv">width</span>: <span class="m">1920</span>, <span class="nv">height</span>: <span class="m">1080</span>)
</li><li><span class="k">var</span> <span class="nv">cinema</span> = <span class="nv">hd</span>
</li></ol></div></div></div>
<p>This example declares a constant called <code class="docutils literal notranslate"><span class="pre">hd</span></code> and sets it to a <code class="docutils literal notranslate"><span class="pre">Resolution</span></code> instance initialized with the width and height of full HD video (1920 pixels wide by 1080 pixels high).<br><span class="jpstr">
この例は、<code class="docutils literal notranslate"><span class="pre">hd</span></code>と呼ばれる定数を宣言して、それをフルHDビデオの幅と高さ（1920ピクセル幅の広さで1080ピクセルの高さ）で初期化される<code class="docutils literal notranslate"><span class="pre">Resolution</span></code>インスタンスに対して設定します。
</span><!--end_jpstr-->
</p>
<p>It then declares a variable called <code class="docutils literal notranslate"><span class="pre">cinema</span></code> and sets it to the current value of <code class="docutils literal notranslate"><span class="pre">hd</span></code>. Because <code class="docutils literal notranslate"><span class="pre">Resolution</span></code> is a structure, a <em>copy</em> of the existing instance is made, and this new copy is assigned to <code class="docutils literal notranslate"><span class="pre">cinema</span></code>. Even though <code class="docutils literal notranslate"><span class="pre">hd</span></code> and <code class="docutils literal notranslate"><span class="pre">cinema</span></code> now have the same width and height, they are two completely different instances behind the scenes.<br><span class="jpstr">
それは、それから<code class="docutils literal notranslate"><span class="pre">cinema</span></code>と呼ばれる変数を宣言して、それを<code class="docutils literal notranslate"><span class="pre">hd</span></code>の現在の値に設定します。<code class="docutils literal notranslate"><span class="pre">Resolution</span></code>が構造体であるので、既存のインスタンスの<em>コピー</em>が作成されます、そして、この新しいコピーは<code class="docutils literal notranslate"><span class="pre">cinema</span></code>に代入されます。たとえ<code class="docutils literal notranslate"><span class="pre">hd</span></code>と<code class="docutils literal notranslate"><span class="pre">cinema</span></code>が現在同じ幅と高さを持つとしても、それらは舞台裏では２つの完全に異なるインスタンスです。
</span><!--end_jpstr-->
</p>
<p>Next, the <code class="docutils literal notranslate"><span class="pre">width</span></code> property of <code class="docutils literal notranslate"><span class="pre">cinema</span></code> is amended to be the width of the slightly wider 2K standard used for digital cinema projection (2048 pixels wide and 1080 pixels high):<br><span class="jpstr">
次に、<code class="docutils literal notranslate"><span class="pre">cinema</span></code>の<code class="docutils literal notranslate"><span class="pre">width</span></code>プロパティは、デジタル映画館投影のために使われるわずかにより広い2Kの標準の幅（2048ピクセル幅の広さで1080ピクセルの高さ）になるように改められます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">cinema</span>.<span class="nv">width</span> = <span class="m">2048</span>
</li></ol></div></div></div>
<p>Checking the <code class="docutils literal notranslate"><span class="pre">width</span></code> property of <code class="docutils literal notranslate"><span class="pre">cinema</span></code> shows that it has indeed changed to be <code class="docutils literal notranslate"><span class="pre">2048</span></code>:<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">cinema</span></code>の<code class="docutils literal notranslate"><span class="pre">width</span></code>プロパティをチェックすると、<code class="docutils literal notranslate"><span class="pre">2048</span></code>になるように変えられたことを示します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">&quot;cinema is now </span>\<span class="p">(</span><span class="nv">cinema</span>.<span class="nv">width</span><span class="p">)</span><span class="s"> pixels wide&quot;</span>)
</li><li><span class="c">// Prints &quot;cinema is now 2048 pixels wide&quot;&nbsp;<span class="jpstr">（「cinemaは、現在2048のピクセルの幅です」を出力します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>However, the <code class="docutils literal notranslate"><span class="pre">width</span></code> property of the original <code class="docutils literal notranslate"><span class="pre">hd</span></code> instance still has the old value of <code class="docutils literal notranslate"><span class="pre">1920</span></code>:<br><span class="jpstr">
しかし、最初の<code class="docutils literal notranslate"><span class="pre">hd</span></code>インスタンスの<code class="docutils literal notranslate"><span class="pre">width</span></code>プロパティは、まだ<code class="docutils literal notranslate"><span class="pre">1920</span></code>の古い値を持ちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">&quot;hd is still </span>\<span class="p">(</span><span class="nv">hd</span>.<span class="nv">width</span><span class="p">)</span><span class="s"> pixels wide&quot;</span>)
</li><li><span class="c">// Prints &quot;hd is still 1920 pixels wide&quot;&nbsp;<span class="jpstr">（「hdは、依然として1920のピクセルの幅です」を出力します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>When <code class="docutils literal notranslate"><span class="pre">cinema</span></code> was given the current value of <code class="docutils literal notranslate"><span class="pre">hd</span></code>, the <em>values</em> stored in <code class="docutils literal notranslate"><span class="pre">hd</span></code> were copied into the new <code class="docutils literal notranslate"><span class="pre">cinema</span></code> instance. The end result is two completely separate instances that contain the same numeric values. However, because they are separate instances, setting the width of <code class="docutils literal notranslate"><span class="pre">cinema</span></code> to <code class="docutils literal notranslate"><span class="pre">2048</span></code> doesn’t affect the width stored in <code class="docutils literal notranslate"><span class="pre">hd</span></code>, as shown in the figure below:<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">cinema</span></code>が<code class="docutils literal notranslate"><span class="pre">hd</span></code>の現在の値を与えられたとき、<code class="docutils literal notranslate"><span class="pre">hd</span></code>に格納される<em>値</em>は新しい<code class="docutils literal notranslate"><span class="pre">cinema</span></code>インスタンスにコピーされました。最終的な結果は２つの完全に別々のインスタンスです、そしてそれらは同じ数値を含みます。しかしながら、それらが別々のインスタンスであるので、<code class="docutils literal notranslate"><span class="pre">cinema</span></code>の幅を<code class="docutils literal notranslate"><span class="pre">2048</span></code>に設定することは<code class="docutils literal notranslate"><span class="pre">hd</span></code>に格納される幅に影響を及ぼしません、下の図で示されるように：
</span><!--end_jpstr-->
</p>
<img alt="../_images/sharedStateStruct_2x.png" class="align-center" src="../images/sharedStateStruct_2x.png" style="width: 650px;" />
<p>The same behavior applies to enumerations:<br><span class="jpstr">
同じ挙動は、列挙にもあてはまります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">CompassPoint</span> {
</li><li>    <span class="k">case</span> <span class="nv">north</span>, <span class="nv">south</span>, <span class="nv">east</span>, <span class="nv">west</span>
</li><li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">turnNorth</span>() {
</li><li>        <span class="k">self</span> = .<span class="nv">north</span>
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">currentDirection</span> = <span class="nv">CompassPoint</span>.<span class="nv">west</span>
</li><li><span class="k">let</span> <span class="nv">rememberedDirection</span> = <span class="nv">currentDirection</span>
</li><li><span class="nv">currentDirection</span>.<span class="nv">turnNorth</span>()
</li><li>
</li><li><span class="nv">print</span>(<span class="s">&quot;The current direction is </span>\<span class="p">(</span><span class="nv">currentDirection</span><span class="p">)</span><span class="s">&quot;</span>)
</li><li><span class="nv">print</span>(<span class="s">&quot;The remembered direction is </span>\<span class="p">(</span><span class="nv">rememberedDirection</span><span class="p">)</span><span class="s">&quot;</span>)
</li><li><span class="c">// Prints &quot;The current direction is north&quot;</span>
</li><li><span class="c">// Prints &quot;The remembered direction is west&quot;</span>
</li></ol></div></div></div>
<p>When <code class="docutils literal notranslate"><span class="pre">rememberedDirection</span></code> is assigned the value of <code class="docutils literal notranslate"><span class="pre">currentDirection</span></code>, it’s actually set to a copy of that value. Changing the value of <code class="docutils literal notranslate"><span class="pre">currentDirection</span></code> thereafter doesn’t affect the copy of the original value that was stored in <code class="docutils literal notranslate"><span class="pre">rememberedDirection</span></code>.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">rememberedDirection</span></code>が<code class="docutils literal notranslate"><span class="pre">currentDirection</span></code>の値を代入されるとき、それは実際にはその値のコピーに設定されます。それ以降に<code class="docutils literal notranslate"><span class="pre">currentDirection</span></code>の値を変えることは、本来の値のコピーに、<code class="docutils literal notranslate"><span class="pre">rememberedDirection</span></code>に格納されたものに影響を及ぼしません。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID89">
<h2>Classes Are Reference Types<a class="headerlink" href="#ID89" title="Permalink to this headline">¶</a><br><span class="jpstr">
クラスは、参照型です<a class="headerlink" href="#ID89" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>Unlike value types, <em>reference types</em> are <em>not</em> copied when they are assigned to a variable or constant, or when they are passed to a function. Rather than a copy, a reference to the same existing instance is used.<br><span class="jpstr">
値型とは異なり、<em>参照型</em>は、それが変数や定数に代入される時に、あるいはそれが関数に渡される時に、コピーされ<em>ません</em>。コピーではなく、既存の同じインスタンスに対する参照が使われます。
</span><!--end_jpstr-->
</p>
<p>Here’s an example, using the <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> class defined above:<br><span class="jpstr">
上で定義される<code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>クラスを使用している例がここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">tenEighty</span> = <span class="nv">VideoMode</span>()
</li><li><span class="nv">tenEighty</span>.<span class="nv">resolution</span> = <span class="nv">hd</span>
</li><li><span class="nv">tenEighty</span>.<span class="nv">interlaced</span> = <span class="k">true</span>
</li><li><span class="nv">tenEighty</span>.<span class="nv">name</span> = <span class="s">&quot;1080i&quot;</span>
</li><li><span class="nv">tenEighty</span>.<span class="nv">frameRate</span> = <span class="m">25.0</span>
</li></ol></div></div></div>
<p>This example declares a new constant called <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> and sets it to refer to a new instance of the <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> class. The video mode is assigned a copy of the HD resolution of <code class="docutils literal notranslate"><span class="pre">1920</span></code> by <code class="docutils literal notranslate"><span class="pre">1080</span></code> from before. It’s set to be interlaced, and is given a name of <code class="docutils literal notranslate"><span class="pre">&quot;1080i&quot;</span></code>. Finally, it’s set to a frame rate of <code class="docutils literal notranslate"><span class="pre">25.0</span></code> frames per second.<br><span class="jpstr">
この例は、<code class="docutils literal notranslate"><span class="pre">tenEighty</span></code>と呼ばれる新しい定数を宣言して、それを<code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>クラスの新しいインスタンスに言及するように設定します。ビデオ・モードは、以前にHD解像度<code class="docutils literal notranslate"><span class="pre">1920</span></code>×<code class="docutils literal notranslate"><span class="pre">1080</span></code>のコピーを代入されます。それは、インターレースに設定され、<code class="docutils literal notranslate"><span class="pre">"1080i"</span></code>の名前を与えられます。最後に、それは１秒につき<code class="docutils literal notranslate"><span class="pre">25.0</span></code>フレームのフレームレートに設定されます。
</span><!--end_jpstr-->
</p>
<p>Next, <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> is assigned to a new constant, called <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code>, and the frame rate of <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code> is modified:<br><span class="jpstr">
次に、<code class="docutils literal notranslate"><span class="pre">tenEighty</span></code>は、新しい定数、<code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code>と呼ばれるものに代入されます、そして<code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code>のフレームレートが修正されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">alsoTenEighty</span> = <span class="nv">tenEighty</span>
</li><li><span class="nv">alsoTenEighty</span>.<span class="nv">frameRate</span> = <span class="m">30.0</span>
</li></ol></div></div></div>
<p>Because classes are reference types, <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> and <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code> actually both refer to the <em>same</em> <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> instance. Effectively, they are just two different names for the same single instance, as shown in the figure below:<br><span class="jpstr">
クラスが参照型であるので、<code class="docutils literal notranslate"><span class="pre">tenEighty</span></code>と<code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code>は両方とも実際に<em>同じ</em><code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>インスタンスに言及します。事実上、それらは同じ一つのインスタンスに対する単なる２つの異なる名前です、以下の図で示されるように：
</span><!--end_jpstr-->
</p>
<img alt="../_images/sharedStateClass_2x.png" class="align-center" src="../images/sharedStateClass_2x.png" style="width: 670px;" />
<p>Checking the <code class="docutils literal notranslate"><span class="pre">frameRate</span></code> property of <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> shows that it correctly reports the new frame rate of <code class="docutils literal notranslate"><span class="pre">30.0</span></code> from the underlying <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> instance:<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">tenEighty</span></code>の<code class="docutils literal notranslate"><span class="pre">frameRate</span></code>プロパティを調べてみると、それが根底にある<code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>インスタンス由来の新しいフレームレートの<code class="docutils literal notranslate"><span class="pre">30.0</span></code>を正しく報告することがわかります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">&quot;The frameRate property of tenEighty is now </span>\<span class="p">(</span><span class="nv">tenEighty</span>.<span class="nv">frameRate</span><span class="p">)</span><span class="s">&quot;</span>)
</li><li><span class="c">// Prints &quot;The frameRate property of tenEighty is now 30.0&quot;&nbsp;<span class="jpstr">（「tenEightyのframeRateプロパティは、現在は30.0です」を出力します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>This example also shows how reference types can be harder to reason about. If <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> and <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code> were far apart in your program’s code, it could be difficult to find all the ways that the video mode is changed. Wherever you use <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code>, you also have to think about the code that uses <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code>, and vice versa. In contrast, value types are easier to reason about because all of the code that interacts with the same value is close together in your source files.<br><span class="jpstr">
この例はまた、どれくらい参照型が推論するのがより困難になりうるかを示します。<code class="docutils literal notranslate"><span class="pre">tenEighty</span></code>と<code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code>があなたのプログラムの持つコードにおいてかけ離れたものになったならば、ビデオモードが変更される全ての方法を見つけるのは難しくなるでしょう。あなたが<code class="docutils literal notranslate"><span class="pre">tenEighty</span></code>を使うどこであれ、あなたはまた<code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code>を使うコードについて頭を働かせなければなりません、そして逆もまた同様に。対照的に、値型は推論するのがより簡単です、なぜなら同じ値と相互作用するコードの全ては、あなたのソースファイルにおいて近接するからです。
</span><!--end_jpstr-->
</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> and <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code> are declared as <em>constants</em>, rather than variables. However, you can still change <code class="docutils literal notranslate"><span class="pre">tenEighty.frameRate</span></code> and <code class="docutils literal notranslate"><span class="pre">alsoTenEighty.frameRate</span></code> because the values of the <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> and <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code> constants themselves don’t actually change. <code class="docutils literal notranslate"><span class="pre">tenEighty</span></code> and <code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code> themselves don’t “store” the <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> instance—instead, they both <em>refer</em> to a <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> instance behind the scenes. It’s the <code class="docutils literal notranslate"><span class="pre">frameRate</span></code> property of the underlying <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code> that is changed, not the values of the constant references to that <code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">tenEighty</span></code>と<code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code>が、変数ではなく、<em>定数</em>として宣言される点に注意してください。しかし、あなたはそれでもなお<code class="docutils literal notranslate"><span class="pre">tenEighty.frameRate</span></code>と<code class="docutils literal notranslate"><span class="pre">alsoTenEighty.frameRate</span></code>を変更することができます、なぜなら<code class="docutils literal notranslate"><span class="pre">tenEighty</span></code>および<code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code>定数それら自身の値は実のところ変わらないからです。<code class="docutils literal notranslate"><span class="pre">tenEighty</span></code>および<code class="docutils literal notranslate"><span class="pre">alsoTenEighty</span></code>それら自身は<code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>インスタンスを格納しません ― そうではなく、それらが両方とも<em>言及する</em>のは舞台裏で<code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>インスタンスです。それは、根底にある<code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>の<code class="docutils literal notranslate"><span class="pre">frameRate</span></code>プロパティです、それは変更可能です、その<code class="docutils literal notranslate"><span class="pre">VideoMode</span></code>に対する参照をもつこれら定数の値ではありません。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID90">
<h3>Identity Operators<a class="headerlink" href="#ID90" title="Permalink to this headline">¶</a><br><span class="jpstr">
同一性演算子<a class="headerlink" href="#ID90" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>Because classes are reference types, it’s possible for multiple constants and variables to refer to the same single instance of a class behind the scenes. (The same isn’t true for structures and enumerations, because they are always copied when they are assigned to a constant or variable, or passed to a function.)<br><span class="jpstr">
クラスが参照型であるので、複数の定数と変数があるクラスの同じ一つのインスタンスに言及することが舞台裏で可能です。（同じことは構造体と列挙にあてはまりません、なぜなら、それらが値型であって、それらが定数または変数に代入されるか関数に渡される時に、常にコピーされるからです）。
</span><!--end_jpstr-->
</p>
<p>It can sometimes be useful to find out whether two constants or variables refer to exactly the same instance of a class. To enable this, Swift provides two identity operators:<br><span class="jpstr">
２つの定数または変数が正確にあるクラスの同じインスタンスに言及するかどうかについて、探り出すことは時々役に立つことがあります。これを可能にするために、スウィフトは２つの同一性演算子を提供します：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>Identical to (<code class="docutils literal notranslate"><span class="pre">===</span></code>)<br><span class="jpstr">
同一である（<code class="docutils literal notranslate"><span class="pre">===</span></code>）
</span><!--end_jpstr-->
</li>
<li>Not identical to (<code class="docutils literal notranslate"><span class="pre">!==</span></code>)<br><span class="jpstr">
同一でない（<code class="docutils literal notranslate"><span class="pre">!==</span></code>）
</span><!--end_jpstr-->
</li>
</ul>
<p>Use these operators to check whether two constants or variables refer to the same single instance:<br><span class="jpstr">
２つの定数または変数が同じ一つのインスタンスに言及するかどうか調べるためにこれらの演算子を使用してください：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="nv">tenEighty</span> === <span class="nv">alsoTenEighty</span> {
</li><li>    <span class="nv">print</span>(<span class="s">&quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;</span>)
</li><li>}
</li><li><span class="c">// Prints &quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;&nbsp;<span class="jpstr">（「tenEightyとalsoTenEightyは、同じVideoModeインスタンスに言及します。」を出力します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>Note that <em>identical to</em> (represented by three equals signs, or <code class="docutils literal notranslate"><span class="pre">===</span></code>) doesn’t mean the same thing as <em>equal to</em> (represented by two equals signs, or <code class="docutils literal notranslate"><span class="pre">==</span></code>). <em>Identical to</em> means that two constants or variables of class type refer to exactly the same class instance. <em>Equal to</em> means that two instances are considered equal or equivalent in value, for some appropriate meaning of <em>equal</em>, as defined by the type’s designer.<br><span class="jpstr">
<em>同一である</em>（３つの等号、つまり<code class="docutils literal notranslate"><span class="pre">===</span></code>によって表されるもの）は<em>同等である</em>（２つの等号、つまり<code class="docutils literal notranslate"><span class="pre">==</span></code>によって表されるもの）と同じことを意味しないのに注意してください：<em>同一</em>は、クラス型の２つの定数または変数が、正確に同じクラスインスタンスに言及することを意味します。<em>同等</em>は、２つのインスタンスが、値で「等しい」あるいは「相当する」と、ある適切な<em>等しい</em>の意味で、型の設計者によって定義されたとおりに、考慮されることを意味します。
</span><!--end_jpstr-->
</p>
<p>When you define your own custom structures and classes, it’s your responsibility to decide what qualifies as two instances being equal. The process of defining your own implementations of the “equal to” and “not equal to” operators is described in <a class="reference internal" href="AdvancedOperators.html#ID45"><span class="std std-ref">Equivalence Operators</span></a>.<br><span class="jpstr">
あなたが独自のあつらえのクラスと構造体を定義するとき、２つのインスタンスが等しくなる基準は何かを決めるのはあなたの責任です。「同等」および「不等」演算子のあなた独自の実施を定義する過程は、<a class="reference internal" href="AdvancedOperators.html#ID45"><span class="std std-ref">同等演算子</span></a>で記述されます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID91">
<h3>Pointers<a class="headerlink" href="#ID91" title="Permalink to this headline">¶</a><br><span class="jpstr">
ポインター<a class="headerlink" href="#ID91" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>If you have experience with C, C++, or Objective-C, you may know that these languages use <em>pointers</em> to refer to addresses in memory. A Swift constant or variable that refers to an instance of some reference type is similar to a pointer in C, but isn’t a direct pointer to an address in memory, and doesn’t require you to write an asterisk (<code class="docutils literal notranslate"><span class="pre">*</span></code>) to indicate that you are creating a reference. Instead, these references are defined like any other constant or variable in Swift. The standard library provides pointer and buffer types that you can use if you need to interact with pointers directly—see <a class="reference external" href="https://developer.apple.com/documentation/swift/swift_standard_library/manual_memory_management">Manual Memory Management</a>.<br><span class="jpstr">
あなたがC、C++、またはObjective-Cで経験を持つならば、あなたはこれらの言語がメモリのアドレスに言及するために<em>ポインター</em>を使用するということを知っているかもしれません。ある参照型のインスタンスに言及するスウィフト定数または変数はCの中のポインターに似ています、しかしメモリ中のアドレスへの直接のポインターでなくて、あなたに参照をつくっていることを示すために星印（<code class="docutils literal notranslate"><span class="pre">*</span></code>）を書くことを要求しません。その代わりに、これらの参照は、スウィフトにおけるあらゆる他の定数または変数と同じように定義されます。標準ライブラリは、ポインタとバッファ型を提供します、それはあなたが直接にポインタと相互作用する必要があるならばあなたが使用できます — <a class="reference external" href="https://developer.apple.com/documentation/swift/swift_standard_library/manual_memory_management">手動メモリ管理</a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="Enumerations.html">Enumerations<br><span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="Properties.html">Properties<br><span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></p>
    </div>

    <div class="admonition-beta admonition">
        <p class="first admonition-title">Beta Software</p>
        <p>
          This documentation contains preliminary information about an API or technology in development.
          This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.
        <br><span class="jpstr">
この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。
          この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。
</span><!--end_jpstr-->
</p>
        <p class="last"><a class="reference external" href="https://developer.apple.com/support/beta-software/">Learn more about using Apple's beta software</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright &copy; 2018 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  </body>
</html>
