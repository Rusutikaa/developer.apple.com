

<!DOCTYPE html>



<head>
    <meta charset="utf-8" />
    <meta name="author" content="Apple Inc." />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    
    <title>Inheritance &mdash; The Swift Programming Language (Swift 4.2)</title>
    
    <link rel="license" href="/LICENSE.txt" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css" />
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" /> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 4.2</div></h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Welcome to Swift<br><span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="TheBasics.html">Language Guide<br><span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html">The Basics<br><span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html">Basic Operators<br><span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html">Strings and Characters<br><span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html">Collection Types<br><span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html">Control Flow<br><span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html">Functions<br><span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html">Closures<br><span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html">Enumerations<br><span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html">Structures and Classes<br><span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html">Properties<br><span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html">Methods<br><span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html">Subscripts<br><span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Inheritance<br><span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html">Initialization<br><span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html">Deinitialization<br><span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html">Optional Chaining<br><span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html">Error Handling<br><span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html">Type Casting<br><span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html">Nested Types<br><span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html">Extensions<br><span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html">Protocols<br><span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html">Generics<br><span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html">Automatic Reference Counting<br><span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html">Memory Safety<br><span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html">Access Control<br><span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html">Advanced Operators<br><span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html">Language Reference<br><span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html">Revision History<br><span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="https://swift.org/">← Return to Swift.org</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
                <ul>
<li><a class="reference internal" href="#">Inheritance<br><span class="jpstr">
継承
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID194">Defining a Base Class<br><span class="jpstr">
基盤クラスを定義すること
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID195">Subclassing<br><span class="jpstr">
サブクラスをつくる
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID196">Overriding<br><span class="jpstr">
オーバーライド
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID197">Accessing Superclass Methods, Properties, and Subscripts<br><span class="jpstr">
スーパークラスメソッド、プロパティ、そして添え字へのアクセス
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID198">Overriding Methods<br><span class="jpstr">
メソッドのオーバーライド
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID199">Overriding Properties<br><span class="jpstr">
プロパティのオーバーライド
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID200">Overriding Property Getters and Setters<br><span class="jpstr">
プロパティゲッターとセッターのオーバーライド
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID201">Overriding Property Observers<br><span class="jpstr">
プロパティオブザーバーのオーバーライド
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#ID202">Preventing Overrides<br><span class="jpstr">
オーバーライドを防ぐ
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>

            </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="inheritance">
<h1>Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this headline">¶</a><br><span class="jpstr">
継承<a class="headerlink" href="#inheritance" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h1>
<p>A class can <em>inherit</em> methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a <em>subclass</em>, and the class it inherits from is known as its <em>superclass</em>. Inheritance is a fundamental behavior that differentiates classes from other types in Swift.<br><span class="jpstr">
クラスは、メソッド、プロパティ、および他の特徴を別のクラスから<em>継承</em>することができます。あるクラスが他のものから継承するとき、継承を受けているクラスは<em>サブクラス</em>として知られています、そして、そこからそれが譲り受ける原点のクラスは、それの<em>スーパークラス</em>として知られています。継承は、スウィフトにおいてクラスを他の型と区別する基本的挙動です。
</span><!--end_jpstr-->
</p>
<p>Classes in Swift can call and access methods, properties, and subscripts belonging to their superclass and can provide their own overriding versions of those methods, properties, and subscripts to refine or modify their behavior. Swift helps to ensure your overrides are correct by checking that the override definition has a matching superclass definition.<br><span class="jpstr">
スウィフトのクラスは、それらのスーパークラスに属しているメソッド、プロパティ、そして添え字の呼び出しやアクセスが行えて、それらのメソッド、プロパティ、そして添え字の独自の優先的に使われる改変板を提供することでそれらの挙動の洗練や修正を行えます。スウィフトは、あなたの無効化が正しいものであることを、その無効化定義がスーパークラス定義に合致するのを確認することによって確実にします。
</span><!--end_jpstr-->
</p>
<p>Classes can also add property observers to inherited properties in order to be notified when the value of a property changes. Property observers can be added to any property, regardless of whether it was originally defined as a stored or computed property.<br><span class="jpstr">
クラスはまた、プロパティの値が変化するとき通知されるように継承されたプロパティにプロパティオブザーバー（監視者）を加えることができます。プロパティオブザーバーは、どんなプロパティにでも加えられることができます、それが格納または計算プロパティとして元々定義されたかどうかは関係ありません。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID194">
<h2>Defining a Base Class<a class="headerlink" href="#ID194" title="Permalink to this headline">¶</a><br><span class="jpstr">
基盤クラスを定義すること<a class="headerlink" href="#ID194" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>Any class that does not inherit from another class is known as a <em>base class</em>.<br><span class="jpstr">
別のクラスから継承しない何らかのクラスは、<em>基盤クラス</em>として知られています。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">Swift classes do not inherit from a universal base class. Classes you define without specifying a superclass automatically become base classes for you to build upon.<br><span class="jpstr">
スウィフトのクラスたちは、ひとつの共通の基盤クラスから継承はしません。スーパークラスを指定することなくあなたが定義するクラスは、自動的に基盤クラスになり、あなたが基礎とするために使えます。
</span><!--end_jpstr-->
</p>
</div>
<p>The example below defines a base class called <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>. This base class defines a stored property called <code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code>, with a default value of <code class="docutils literal notranslate"><span class="pre">0.0</span></code> (inferring a property type of <code class="docutils literal notranslate"><span class="pre">Double</span></code>). The <code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code> property’s value is used by a read-only computed <code class="docutils literal notranslate"><span class="pre">String</span></code> property called <code class="docutils literal notranslate"><span class="pre">description</span></code> to create a description of the vehicle.<br><span class="jpstr">
下の例は、<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>と呼ばれる基盤クラスを定義します。この基盤クラスは、<code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code>と呼ばれる格納プロパティを定義します、それは<code class="docutils literal notranslate"><span class="pre">0.0</span></code>の省略時の値を持ちます（<code class="docutils literal notranslate"><span class="pre">Double</span></code>の型のプロパティと推論されます）。<code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code>プロパティの値は、<code class="docutils literal notranslate"><span class="pre">description</span></code>と呼ばれる読み込み専用の計算<code class="docutils literal notranslate"><span class="pre">String</span></code>プロパティによってその乗り物の解説を作成するために使用されます：
</span><!--end_jpstr-->
</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> base class also defines a method called <code class="docutils literal notranslate"><span class="pre">makeNoise</span></code>. This method does not actually do anything for a base <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> instance, but will be customized by subclasses of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> later on:<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>クラスはまた、<code class="docutils literal notranslate"><span class="pre">makeNoise</span></code>と呼ばれるメソッドを定義します。このメソッドは実際に何かを基盤<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>インスタンスのために行うわけではありません、しかし後で<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>のサブクラスによって目的に合わせて作り変えられます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Vehicle</span> {
</li><li>    <span class="k">var</span> <span class="nv">currentSpeed</span> = <span class="m">0.0</span>
</li><li>    <span class="k">var</span> <span class="nv">description</span>: <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="s">&quot;traveling at </span>\<span class="p">(</span><span class="nv">currentSpeed</span><span class="p">)</span><span class="s"> miles per hour&quot;</span>
</li><li>    }
</li><li>    <span class="k">func</span> <span class="nv">makeNoise</span>() {
</li><li>        <span class="c">// do nothing - an arbitrary vehicle doesn&#39;t necessarily make a noise&nbsp;<span class="jpstr">（何もしない - ある任意の乗り物が必ず音を出すわけではない）</span><!--end_jpstr-->
</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>You create a new instance of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> with <em>initializer syntax</em>, which is written as a type name followed by empty parentheses:<br><span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>の新しいインスタンスを<em>初期化構文</em>を使って作成します、それは１つの型名に続く空の丸括弧として書かれます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someVehicle</span> = <span class="nv">Vehicle</span>()
</li></ol></div></div></div>
<p>Having created a new <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> instance, you can access its <code class="docutils literal notranslate"><span class="pre">description</span></code> property to print a human-readable description of the vehicle’s current speed:<br><span class="jpstr">
新しい<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>インスタンスを作成したら、あなたはそれの<code class="docutils literal notranslate"><span class="pre">description</span></code>プロパティにアクセスして、その乗り物の現在速度の説明を人の読めるように出力することが出来ます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">&quot;Vehicle: </span>\<span class="p">(</span><span class="nv">someVehicle</span>.<span class="nv">description</span><span class="p">)</span><span class="s">&quot;</span>)
</li><li><span class="c">// Vehicle: traveling at 0.0 miles per hour&nbsp;<span class="jpstr">（Vehicle: 時速0.0マイルで運行中）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> class defines common characteristics for an arbitrary vehicle, but is not much use in itself. To make it more useful, you need to refine it to describe more specific kinds of vehicles.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>クラスは、任意の乗物のためのありふれた特徴を定義します、しかしそれ自体では余り役に立ちません。それをより役に立つようにするために、あなたはそれを改良してより具体的な乗物の種類を記述する必要があります。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID195">
<h2>Subclassing<a class="headerlink" href="#ID195" title="Permalink to this headline">¶</a><br><span class="jpstr">
サブクラスをつくる<a class="headerlink" href="#ID195" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><em>Subclassing</em> is the act of basing a new class on an existing class. The subclass inherits characteristics from the existing class, which you can then refine. You can also add new characteristics to the subclass.<br><span class="jpstr">
<em>サブクラスをつくる</em>ことは、既存のクラスをもとに新しいクラスを構築する行為です。サブクラスは既存のクラスから特徴を受け継ぎます、あなたはそのとき改良することができます。あなたは、また、新しい特徴をサブクラスに加えることができます。
</span><!--end_jpstr-->
</p>
<p>To indicate that a subclass has a superclass, write the subclass name before the superclass name, separated by a colon:<br><span class="jpstr">
あるサブクラスがあるスーパークラスを持つことを表わすには、サブクラスの名前をスーパークラスの名前の前に、コロンで区切って書きます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeSubclass</span>: <span class="nc">SomeSuperclass</span> {
</li><li>    <span class="c">// subclass definition goes here&nbsp;<span class="jpstr">（サブクラス定義がここに来ます）</span><!--end_jpstr-->
</span>
</li><li>}
</li></ol></div></div></div>
<p>The following example defines a subclass called <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>, with a superclass of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>:<br><span class="jpstr">
以下の例は、<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>のスーパークラスを持つ、<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>と呼ばれるサブクラスを定義します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Bicycle</span>: <span class="nc">Vehicle</span> {
</li><li>    <span class="k">var</span> <span class="nv">hasBasket</span> = <span class="k">false</span>
</li><li>}
</li></ol></div></div></div>
<p>The new <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> class automatically gains all of the characteristics of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>, such as its <code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code> and <code class="docutils literal notranslate"><span class="pre">description</span></code> properties and its <code class="docutils literal notranslate"><span class="pre">makeNoise()</span></code> method.<br><span class="jpstr">
この新しい<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>クラスは、自動的に<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>のすべての特徴を獲得します、例えばそれの<code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code>および<code class="docutils literal notranslate"><span class="pre">description</span></code>プロパティやそれの<code class="docutils literal notranslate"><span class="pre">makeNoise()</span></code>メソッドなど。
</span><!--end_jpstr-->
</p>
<p>In addition to the characteristics it inherits, the <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> class defines a new stored property, <code class="docutils literal notranslate"><span class="pre">hasBasket</span></code>, with a default value of <code class="docutils literal notranslate"><span class="pre">false</span></code> (inferring a type of <code class="docutils literal notranslate"><span class="pre">Bool</span></code> for the property).<br><span class="jpstr">
それが継承する特徴に加えて、<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>クラスは新しい格納プロパティ、<code class="docutils literal notranslate"><span class="pre">hasBasket</span></code>を、<code class="docutils literal notranslate"><span class="pre">false</span></code>の省略時の値を使って定義します（このプロパティに対しては<code class="docutils literal notranslate"><span class="pre">Bool</span></code>の型が推論されます）。
</span><!--end_jpstr-->
</p>
<p>By default, any new <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> instance you create will not have a basket. You can set the <code class="docutils literal notranslate"><span class="pre">hasBasket</span></code> property to <code class="docutils literal notranslate"><span class="pre">true</span></code> for a particular <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> instance after that instance is created:<br><span class="jpstr">
特に何もしなければ、あなたが作成するあらゆる新しい<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>インスタンスは、入れ物かごを持ちません。あなたは、特定の<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>インスタンスに対して<code class="docutils literal notranslate"><span class="pre">hasBasket</span></code>プロパティを<code class="docutils literal notranslate"><span class="pre">true</span></code>に設定することが、そのインスタンスを作成した後で行えます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">bicycle</span> = <span class="nv">Bicycle</span>()
</li><li><span class="nv">bicycle</span>.<span class="nv">hasBasket</span> = <span class="k">true</span>
</li></ol></div></div></div>
<p>You can also modify the inherited <code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code> property of a <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> instance, and query the instance’s inherited <code class="docutils literal notranslate"><span class="pre">description</span></code> property:<br><span class="jpstr">
あなたはまた、ある<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>インスタンスの継承された<code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code>プロパティを変更することが出来ます、そしてそのインスタンスの持つ継承された<code class="docutils literal notranslate"><span class="pre">description</span></code>プロパティについて問い合わせることが出来ます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">bicycle</span>.<span class="nv">currentSpeed</span> = <span class="m">15.0</span>
</li><li><span class="nv">print</span>(<span class="s">&quot;Bicycle: </span>\<span class="p">(</span><span class="nv">bicycle</span>.<span class="nv">description</span><span class="p">)</span><span class="s">&quot;</span>)
</li><li><span class="c">// Bicycle: traveling at 15.0 miles per hour&nbsp;<span class="jpstr">（自転車：時速15マイルで運行中）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>Subclasses can themselves be subclassed. The next example creates a subclass of <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> for a two-seater bicycle known as a “tandem”:<br><span class="jpstr">
サブクラスは、それ自身サブクラスを作られることが出来ます。次の例は、「タンデム」として知られる２座席自転車のために、<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>のサブクラスを作成します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Tandem</span>: <span class="nc">Bicycle</span> {
</li><li>    <span class="k">var</span> <span class="nv">currentNumberOfPassengers</span> = <span class="m">0</span>
</li><li>}
</li></ol></div></div></div>
<p><code class="docutils literal notranslate"><span class="pre">Tandem</span></code> inherits all of the properties and methods from <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>, which in turn inherits all of the properties and methods from <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>. The <code class="docutils literal notranslate"><span class="pre">Tandem</span></code> subclass also adds a new stored property called <code class="docutils literal notranslate"><span class="pre">currentNumberOfPassengers</span></code>, with a default value of <code class="docutils literal notranslate"><span class="pre">0</span></code>.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Tandem</span></code>は、すべてのプロパティとメソッドを<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>から継承します、そして今度はそれがすべてのプロパティとメソッドを<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>から継承します。<code class="docutils literal notranslate"><span class="pre">Tandem</span></code>サブクラスはまた、<code class="docutils literal notranslate"><span class="pre">currentNumberOfPassengers</span></code>と呼ばれる新しい格納プロパティを、<code class="docutils literal notranslate"><span class="pre">0</span></code>の省略時の値を使って追加します。
</span><!--end_jpstr-->
</p>
<p>If you create an instance of <code class="docutils literal notranslate"><span class="pre">Tandem</span></code>, you can work with any of its new and inherited properties, and query the read-only <code class="docutils literal notranslate"><span class="pre">description</span></code> property it inherits from <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>:<br><span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">Tandem</span></code>のインスタンスを作成するならば、あなたはそれの新規および継承するプロパティを扱うことができて、それが<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>から継承する読み込み専用の<code class="docutils literal notranslate"><span class="pre">description</span></code>プロパティについて問い合わせることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">tandem</span> = <span class="nv">Tandem</span>()
</li><li><span class="nv">tandem</span>.<span class="nv">hasBasket</span> = <span class="k">true</span>
</li><li><span class="nv">tandem</span>.<span class="nv">currentNumberOfPassengers</span> = <span class="m">2</span>
</li><li><span class="nv">tandem</span>.<span class="nv">currentSpeed</span> = <span class="m">22.0</span>
</li><li><span class="nv">print</span>(<span class="s">&quot;Tandem: </span>\<span class="p">(</span><span class="nv">tandem</span>.<span class="nv">description</span><span class="p">)</span><span class="s">&quot;</span>)
</li><li><span class="c">// Tandem: traveling at 22.0 miles per hour&nbsp;<span class="jpstr">（２人乗り：時速22.0マイルで運行中）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID196">
<h2>Overriding<a class="headerlink" href="#ID196" title="Permalink to this headline">¶</a><br><span class="jpstr">
オーバーライド<a class="headerlink" href="#ID196" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A subclass can provide its own custom implementation of an instance method, type method, instance property, type property, or subscript that it would otherwise inherit from a superclass. This is known as <em>overriding</em>.<br><span class="jpstr">
サブクラスは、それ独自のあつらえの実装のインスタンスメソッド、型メソッド、インスタンスプロパティ、型プロパティ、または添え字を提供することができます、それらはそれがそうしなければスーパークラスから継承するものです。これは、<em>オーバーライド</em>として知られています。
</span><!--end_jpstr-->
</p>
<p>To override a characteristic that would otherwise be inherited, you prefix your overriding definition with the <code class="docutils literal notranslate"><span class="pre">override</span></code> keyword. Doing so clarifies that you intend to provide an override and have not provided a matching definition by mistake. Overriding by accident can cause unexpected behavior, and any overrides without the <code class="docutils literal notranslate"><span class="pre">override</span></code> keyword are diagnosed as an error when your code is compiled.<br><span class="jpstr">
そうしなければ継承される特徴をオーバーライドするために、あなたは、あなたのオーバーライド定義の前に<code class="docutils literal notranslate"><span class="pre">override</span></code>キーワードを置きます。そうすることは、あなたがオーバーライドを提供するつもりであって、誤って同じ定義を提供したのでないことを明らかにします。誤って偶然にオーバーライドすることは予想外の挙動を引き起こすことがありえます、なので、あなたのコードがコンパイルされるとき、<code class="docutils literal notranslate"><span class="pre">override</span></code>キーワードのないどんなオーバーライドもエラーとして診断されます。
</span><!--end_jpstr-->
</p>
<p>The <code class="docutils literal notranslate"><span class="pre">override</span></code> keyword also prompts the Swift compiler to check that your overriding class’s superclass (or one of its parents) has a declaration that matches the one you provided for the override. This check ensures that your overriding definition is correct.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">override</span></code>キーワードはまた、あなたのオーバーライドしているクラスのスーパークラス（またはその親のうちの１つ）が、そのオーバーライドのためにあなたが提供するものと合致する宣言を持っていることを確認するように、スウィフトのコンパイラを促します。この調査は、あなたのオーバーライドの定義が正しいことを確実にします。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID197">
<h3>Accessing Superclass Methods, Properties, and Subscripts<a class="headerlink" href="#ID197" title="Permalink to this headline">¶</a><br><span class="jpstr">
スーパークラスメソッド、プロパティ、そして添え字へのアクセス<a class="headerlink" href="#ID197" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>When you provide a method, property, or subscript override for a subclass, it is sometimes useful to use the existing superclass implementation as part of your override. For example, you can refine the behavior of that existing implementation, or store a modified value in an existing inherited variable.<br><span class="jpstr">
あなたがサブクラスのためにメソッド、プロパティ、または添え字のオーバーライドを提供する時、既存のスーパークラスの実装をあなたのオーバーライドの一部として使うことは時々役に立ちます。例えば、あなたはその既存の実施の挙動を洗練させたり、既存の継承された変数に修正された値を格納することができます。
</span><!--end_jpstr-->
</p>
<p>Where this is appropriate, you access the superclass version of a method, property, or subscript by using the <code class="docutils literal notranslate"><span class="pre">super</span></code> prefix:<br><span class="jpstr">
これがふさわしい所で、あなたは<code class="docutils literal notranslate"><span class="pre">super</span></code>接頭辞を使用することによってスーパークラス版のメソッド、プロパティ、または添え字にアクセスします：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>An overridden method named <code class="docutils literal notranslate"><span class="pre">someMethod()</span></code> can call the superclass version of <code class="docutils literal notranslate"><span class="pre">someMethod()</span></code> by calling <code class="docutils literal notranslate"><span class="pre">super.someMethod()</span></code> within the overriding method implementation.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">someMethod()</span></code>という名前のオーバーライドされたメソッドは、オーバーライドしているメソッド実装内で<code class="docutils literal notranslate"><span class="pre">super.someMethod()</span></code>を呼ぶことによって、スーパークラス版の<code class="docutils literal notranslate"><span class="pre">someMethod()</span></code>を呼ぶことができます。
</span><!--end_jpstr-->
</li>
<li>An overridden property called <code class="docutils literal notranslate"><span class="pre">someProperty</span></code> can access the superclass version of <code class="docutils literal notranslate"><span class="pre">someProperty</span></code> as <code class="docutils literal notranslate"><span class="pre">super.someProperty</span></code> within the overriding getter or setter implementation.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">someProperty</span></code>と呼ばれるオーバーライドされたプロパティは、オーバーライドしているゲッターまたはセッター実装内で、<code class="docutils literal notranslate"><span class="pre">super.someProperty</span></code>のようにしてスーパークラス版の<code class="docutils literal notranslate"><span class="pre">someProperty</span></code>にアクセスすることができます。
</span><!--end_jpstr-->
</li>
<li>An overridden subscript for <code class="docutils literal notranslate"><span class="pre">someIndex</span></code> can access the superclass version of the same subscript as <code class="docutils literal notranslate"><span class="pre">super[someIndex]</span></code> from within the overriding subscript implementation.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">someIndex</span></code>のためのオーバーライドされた添え字は、オーバーライドしている添え字実装内から<code class="docutils literal notranslate"><span class="pre">super[someIndex]</span></code>のようにしてスーパークラス版の同じ添え字にアクセスすることができます。
</span><!--end_jpstr-->
</li>
</ul>
</div>
<div class="section" id="ID198">
<h3>Overriding Methods<a class="headerlink" href="#ID198" title="Permalink to this headline">¶</a><br><span class="jpstr">
メソッドのオーバーライド<a class="headerlink" href="#ID198" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>You can override an inherited instance or type method to provide a tailored or alternative implementation of the method within your subclass.<br><span class="jpstr">
あなたは、ある継承されたインスタンスまたは型メソッドをオーバーライドすることで、あなたのサブクラス内部でそのメソッドの特注のまたは代替の実装を提供することができます。
</span><!--end_jpstr-->
</p>
<p>The following example defines a new subclass of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> called <code class="docutils literal notranslate"><span class="pre">Train</span></code>, which overrides the <code class="docutils literal notranslate"><span class="pre">makeNoise()</span></code> method that <code class="docutils literal notranslate"><span class="pre">Train</span></code> inherits from <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>:<br><span class="jpstr">
以下の例は、<code class="docutils literal notranslate"><span class="pre">Train</span></code>と呼ばれる<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>の新しいサブクラスを定義します、それは、<code class="docutils literal notranslate"><span class="pre">Train</span></code>が<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>から受け継ぐ<code class="docutils literal notranslate"><span class="pre">makeNoise()</span></code>メソッドをオーバーライドします：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Train</span>: <span class="nc">Vehicle</span> {
</li><li>    <span class="k">override</span> <span class="k">func</span> <span class="nv">makeNoise</span>() {
</li><li>        <span class="nv">print</span>(<span class="s">&quot;Choo Choo&quot;</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>If you create a new instance of <code class="docutils literal notranslate"><span class="pre">Train</span></code> and call its <code class="docutils literal notranslate"><span class="pre">makeNoise()</span></code> method, you can see that the <code class="docutils literal notranslate"><span class="pre">Train</span></code> subclass version of the method is called:<br><span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">Train</span></code>の新しいインスタンスを作成してそれの<code class="docutils literal notranslate"><span class="pre">makeNoise()</span></code>メソットを呼び出すならば、あなたはサブクラス板の<code class="docutils literal notranslate"><span class="pre">Train</span></code>メソッドが呼び出されるのを見ることができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">train</span> = <span class="nv">Train</span>()
</li><li><span class="nv">train</span>.<span class="nv">makeNoise</span>()
</li><li><span class="c">// Prints &quot;Choo Choo&quot;&nbsp;<span class="jpstr">（「シュッシュッ」を出力します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID199">
<h3>Overriding Properties<a class="headerlink" href="#ID199" title="Permalink to this headline">¶</a><br><span class="jpstr">
プロパティのオーバーライド<a class="headerlink" href="#ID199" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>You can override an inherited instance or type property to provide your own custom getter and setter for that property, or to add property observers to enable the overriding property to observe when the underlying property value changes.<br><span class="jpstr">
あなたは継承されたインスタンスまたは型プロパティをオーバーライドして、そのプロパティのためにあなた独自のあつらえのゲッターとセッターを用意したり、根底にあるプロパティ値がいつ変化するか監視することをオーバーライドしているプロパティに可能にするプロパティオブザーバーを加えることができます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID200">
<h4>Overriding Property Getters and Setters<a class="headerlink" href="#ID200" title="Permalink to this headline">¶</a><br><span class="jpstr">
プロパティゲッターとセッターのオーバーライド<a class="headerlink" href="#ID200" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h4>
<p>You can provide a custom getter (and setter, if appropriate) to override <em>any</em> inherited property, regardless of whether the inherited property is implemented as a stored or computed property at source. The stored or computed nature of an inherited property is not known by a subclass—it only knows that the inherited property has a certain name and type. You must always state both the name and the type of the property you are overriding, to enable the compiler to check that your override matches a superclass property with the same name and type.<br><span class="jpstr">
あなたは、あつらえのゲッターを（そして適切ならば、セッターも）提供することで、<em>あらゆる</em>継承されたプロパティをオーバーライドできます、継承されたプロパティがその発生源で格納プロパティもしくは計算プロパティとして実装されるかは関係しません。継承されたプロパティの格納または計算の種別は、サブクラスには知られません ― それは、継承されたプロパティが特定の名前と型を持つということを知っているだけです。あなたは、常にあなたがオーバーライドしているプロパティの名前と型を明確に述べなければなりません、そうすることであなたのオーバーライドがスーパークラスの同じ名前と型をもつプロパティと合致することをコンパイラが確認できるようになります。
</span><!--end_jpstr-->
</p>
<p>You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override. You cannot, however, present an inherited read-write property as a read-only property.<br><span class="jpstr">
あなたのサブクラスプロパティオーバーライドにおいてゲッターとセッターの両方を提供することによって、あなたは継承された読み出し専用のプロパティを、読み書き両用のプロパティとして提供することができます。あなたは、しかし、継承された読み書き両用プロパティを、読み出し専用のプロパティとして提示することができません。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">If you provide a setter as part of a property override, you must also provide a getter for that override. If you don’t want to modify the inherited property’s value within the overriding getter, you can simply pass through the inherited value by returning <code class="docutils literal notranslate"><span class="pre">super.someProperty</span></code> from the getter, where <code class="docutils literal notranslate"><span class="pre">someProperty</span></code> is the name of the property you are overriding.<br><span class="jpstr">
あなたがプロパティオーバーライドの一部としてセッターを提供するならば、あなたはまたそのオーバーライドのためにゲッターも提供しなければなりません。あなたがオーバーライドのゲッター内で継承されたプロパティの値を修正したくないならば、あなたは、そのゲッターから<code class="docutils literal notranslate"><span class="pre">super.someProperty</span></code>を返すことによって、単に継承された値を通り抜けさせることができます、ここで<code class="docutils literal notranslate"><span class="pre">someProperty</span></code>はあなたがオーバーライドしているプロパティの名前です。
</span><!--end_jpstr-->
</p>
</div>
<p>The following example defines a new class called <code class="docutils literal notranslate"><span class="pre">Car</span></code>, which is a subclass of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>. The <code class="docutils literal notranslate"><span class="pre">Car</span></code> class introduces a new stored property called <code class="docutils literal notranslate"><span class="pre">gear</span></code>, with a default integer value of <code class="docutils literal notranslate"><span class="pre">1</span></code>. The <code class="docutils literal notranslate"><span class="pre">Car</span></code> class also overrides the <code class="docutils literal notranslate"><span class="pre">description</span></code> property it inherits from <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>, to provide a custom description that includes the current gear:<br><span class="jpstr">
以下の例は、<code class="docutils literal notranslate"><span class="pre">Car</span></code>と呼ばれる新しいクラスを定義します、それは、<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>のサブクラスです。<code class="docutils literal notranslate"><span class="pre">Car</span></code>クラスは、<code class="docutils literal notranslate"><span class="pre">gear</span></code>と呼ばれる、<code class="docutils literal notranslate"><span class="pre">1</span></code>の省略時の値を持つ、新しい格納プロパティを導入します。<code class="docutils literal notranslate"><span class="pre">Car</span></code>クラスはまた、それが<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>から継承する<code class="docutils literal notranslate"><span class="pre">description</span></code>プロパティをオーバーライドして、現在のギアーを示すあつらえの説明を提供します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Car</span>: <span class="nc">Vehicle</span> {
</li><li>    <span class="k">var</span> <span class="nv">gear</span> = <span class="m">1</span>
</li><li>    <span class="k">override</span> <span class="k">var</span> <span class="nv">description</span>: <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="k">super</span>.<span class="nv">description</span> + <span class="s">&quot; in gear </span>\<span class="p">(</span><span class="nv">gear</span><span class="p">)</span><span class="s">&quot;</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The override of the <code class="docutils literal notranslate"><span class="pre">description</span></code> property starts by calling <code class="docutils literal notranslate"><span class="pre">super.description</span></code>, which returns the <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> class’s <code class="docutils literal notranslate"><span class="pre">description</span></code> property. The <code class="docutils literal notranslate"><span class="pre">Car</span></code> class’s version of <code class="docutils literal notranslate"><span class="pre">description</span></code> then adds some extra text onto the end of this description to provide information about the current gear.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">description</span></code>プロパティのオーバーライドは、<code class="docutils literal notranslate"><span class="pre">super.description</span></code>を呼び出すことで始まります、それは<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>クラスの<code class="docutils literal notranslate"><span class="pre">description</span></code>プロパティを返します。<code class="docutils literal notranslate"><span class="pre">Car</span></code>クラス版の<code class="docutils literal notranslate"><span class="pre">description</span></code>は、それからこの説明の最後に現在のギアーについての情報を提供するために追加のテキストを加えられます。
</span><!--end_jpstr-->
</p>
<p>If you create an instance of the <code class="docutils literal notranslate"><span class="pre">Car</span></code> class and set its <code class="docutils literal notranslate"><span class="pre">gear</span></code> and <code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code> properties, you can see that its <code class="docutils literal notranslate"><span class="pre">description</span></code> property returns the tailored description defined within the <code class="docutils literal notranslate"><span class="pre">Car</span></code> class:<br><span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">Car</span></code>クラスのインスタンスを作成して、それの<code class="docutils literal notranslate"><span class="pre">gear</span></code>と<code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code>プロパティを設定するならば、あなたはそれの<code class="docutils literal notranslate"><span class="pre">description</span></code>プロパティが<code class="docutils literal notranslate"><span class="pre">Car</span></code>クラス内で定義される特注の説明を返すのを見ることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">car</span> = <span class="nv">Car</span>()
</li><li><span class="nv">car</span>.<span class="nv">currentSpeed</span> = <span class="m">25.0</span>
</li><li><span class="nv">car</span>.<span class="nv">gear</span> = <span class="m">3</span>
</li><li><span class="nv">print</span>(<span class="s">&quot;Car: </span>\<span class="p">(</span><span class="nv">car</span>.<span class="nv">description</span><span class="p">)</span><span class="s">&quot;</span>)
</li><li><span class="c">// Car: traveling at 25.0 miles per hour in gear 3&nbsp;<span class="jpstr">（Car: ３速ギアで時速25.0マイルで運行中）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID201">
<h4>Overriding Property Observers<a class="headerlink" href="#ID201" title="Permalink to this headline">¶</a><br><span class="jpstr">
プロパティオブザーバーのオーバーライド<a class="headerlink" href="#ID201" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h4>
<p>You can use property overriding to add property observers to an inherited property. This enables you to be notified when the value of an inherited property changes, regardless of how that property was originally implemented. For more information on property observers, see <a class="reference internal" href="Properties.html#ID262"><span class="std std-ref">Property Observers</span></a>.<br><span class="jpstr">
あなたは、プロパティをオーバーライドすることを継承されたプロパティにプロパティオブザーバーを追加するために使用できます。これはあなたに、そのプロパティが元々どのように実装されるかに関係なく、継承されたプロパティの値が変わるとき通知されることを可能にします。プロパティオブザーバーの詳細については、<a class="reference internal" href="Properties.html#ID262"><span class="std std-ref">プロパティオブザーバー</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p>You cannot add property observers to inherited constant stored properties or inherited read-only computed properties. The value of these properties cannot be set, and so it is not appropriate to provide a <code class="docutils literal notranslate"><span class="pre">willSet</span></code> or <code class="docutils literal notranslate"><span class="pre">didSet</span></code> implementation as part of an override.<br><span class="jpstr">
あなたは、プロパティオブザーバーを、継承された定数格納プロパティに、または継承された読み出し専用の計算プロパティに加えることができません。これらのプロパティの値は設定されることができません、なのでオーバーライドの一部として<code class="docutils literal notranslate"><span class="pre">willSet</span></code>または<code class="docutils literal notranslate"><span class="pre">didSet</span></code>の実装を提供することは適切ではありません。
</span><!--end_jpstr-->
</p>
<p class="last">Note also that you cannot provide both an overriding setter and an overriding property observer for the same property. If you want to observe changes to a property’s value, and you are already providing a custom setter for that property, you can simply observe any value changes from within the custom setter.<br><span class="jpstr">
あなたが同じプロパティに対してオーバーライドしたセッターとオーバーライドしたプロパティオブザーバーの両方を提供することができない点にまた、注意してください。あなたがあるプロパティの値に対する変更を監視したい、そしてあなたが既にあつらえのセッターをそのプロパティのために提供しているならば、あなたは簡単にあつらえのセッター内からどんな値の変化でも監視することができます。
</span><!--end_jpstr-->
</p>
</div>
<p>The following example defines a new class called <code class="docutils literal notranslate"><span class="pre">AutomaticCar</span></code>, which is a subclass of <code class="docutils literal notranslate"><span class="pre">Car</span></code>. The <code class="docutils literal notranslate"><span class="pre">AutomaticCar</span></code> class represents a car with an automatic gearbox, which automatically selects an appropriate gear to use based on the current speed:<br><span class="jpstr">
以下の例は<code class="docutils literal notranslate"><span class="pre">AutomaticCar</span></code>と呼ばれる新しいクラスを定義します、それは、<code class="docutils literal notranslate"><span class="pre">Car</span></code>のサブクラスです。<code class="docutils literal notranslate"><span class="pre">AutomaticCar</span></code>クラスはオートマチック・ギアボックスをもつ車を表します、それは、現在の速度に基づいて自動的に使用するのに適切なギアを選びます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">AutomaticCar</span>: <span class="nc">Car</span> {
</li><li>    <span class="k">override</span> <span class="k">var</span> <span class="nv">currentSpeed</span>: <span class="nc">Double</span> {
</li><li>        <span class="k">didSet</span> {
</li><li>            <span class="nv">gear</span> = <span class="nv">Int</span>(<span class="nv">currentSpeed</span> / <span class="m">10.0</span>) + <span class="m">1</span>
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>Whenever you set the <code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code> property of an <code class="docutils literal notranslate"><span class="pre">AutomaticCar</span></code> instance, the property’s <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer sets the instance’s <code class="docutils literal notranslate"><span class="pre">gear</span></code> property to an appropriate choice of gear for the new speed. Specifically, the property observer chooses a gear that is the new <code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code> value divided by <code class="docutils literal notranslate"><span class="pre">10</span></code>, rounded down to the nearest integer, plus <code class="docutils literal notranslate"><span class="pre">1</span></code>. A speed of <code class="docutils literal notranslate"><span class="pre">35.0</span></code> produces a gear of <code class="docutils literal notranslate"><span class="pre">4</span></code>:<br><span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">AutomaticCar</span></code>インスタンスの<code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code>プロパティを設定したときはいつでも、そのプロパティの<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーは、そのインスタンスの<code class="docutils literal notranslate"><span class="pre">gear</span></code>プロパティを新しい速度のために適切な選択に設定します。具体的には、プロパティオブザーバーは、新しい<code class="docutils literal notranslate"><span class="pre">currentSpeed</span></code>値を<code class="docutils literal notranslate"><span class="pre">10</span></code>で割って、最も近い整数に丸めて、<code class="docutils literal notranslate"><span class="pre">1</span></code>を加えたギアを選びます。速度<code class="docutils literal notranslate"><span class="pre">35.0</span></code>はギア<code class="docutils literal notranslate"><span class="pre">4</span></code>を示します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">automatic</span> = <span class="nv">AutomaticCar</span>()
</li><li><span class="nv">automatic</span>.<span class="nv">currentSpeed</span> = <span class="m">35.0</span>
</li><li><span class="nv">print</span>(<span class="s">&quot;AutomaticCar: </span>\<span class="p">(</span><span class="nv">automatic</span>.<span class="nv">description</span><span class="p">)</span><span class="s">&quot;</span>)
</li><li><span class="c">// AutomaticCar: traveling at 35.0 miles per hour in gear 4&nbsp;<span class="jpstr">（AutomaticCar: 時速35.0マイル、４速ギアで運行中）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
</div>
</div>
</div>
<div class="section" id="ID202">
<h2>Preventing Overrides<a class="headerlink" href="#ID202" title="Permalink to this headline">¶</a><br><span class="jpstr">
オーバーライドを防ぐ<a class="headerlink" href="#ID202" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>You can prevent a method, property, or subscript from being overridden by marking it as <em>final</em>. Do this by writing the <code class="docutils literal notranslate"><span class="pre">final</span></code> modifier before the method, property, or subscript’s introducer keyword (such as <code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">var</span></code>, <code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">func</span></code>, <code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">class</span> <span class="pre">func</span></code>, and <code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">subscript</span></code>).<br><span class="jpstr">
あなたはメソッド、プロパティ、または添え字がオーバーライドされるのを、それを<em>最終版（final）</em>と印することによって妨げることができます。メソッド、プロパティ、または添え字の導入子キーワードの前に<code class="docutils literal notranslate"><span class="pre">final</span></code>修飾子を書くことによって、これをしてください（例えば、<code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">var</span></code>、<code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">func</span></code>、<code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">class</span> <span class="pre">func</span></code>、そして<code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">subscript</span></code>など）。
</span><!--end_jpstr-->
</p>
<p>Any attempt to override a final method, property, or subscript in a subclass is reported as a compile-time error. Methods, properties, or subscripts that you add to a class in an extension can also be marked as final within the extension’s definition.<br><span class="jpstr">
あるサブクラスの中の最終的なメソッド、プロパティ、または添え字をオーバーライドするどんな試みも、コンパイル時エラーとして報告されます。あなたがある拡張においてクラスに加えるメソッド、プロパティ、または添え字は、また、拡張の定義内で最終版として印されることができます。
</span><!--end_jpstr-->
</p>
<p>You can mark an entire class as final by writing the <code class="docutils literal notranslate"><span class="pre">final</span></code> modifier before the <code class="docutils literal notranslate"><span class="pre">class</span></code> keyword in its class definition (<code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">class</span></code>). Any attempt to subclass a final class is reported as a compile-time error.<br><span class="jpstr">
あなたは、そのクラス定義において<code class="docutils literal notranslate"><span class="pre">class</span></code>キーワードの前に<code class="docutils literal notranslate"><span class="pre">final</span></code>修飾子を書くことによって（<code class="docutils literal notranslate"><span class="pre">final</span> <span class="pre">class</span></code>）、そのクラス全体を最終版として印することができます。最終版クラスにサブクラスを作る試みは何であれ、コンパイル時エラーを報告します。
</span><!--end_jpstr-->
</p>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="Subscripts.html">Subscripts<br><span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="Initialization.html">Initialization<br><span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></p>
    </div>

    <div class="admonition-beta admonition">
        <p class="first admonition-title">Beta Software</p>
        <p>
          This documentation contains preliminary information about an API or technology in development.
          This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.
        <br><span class="jpstr">
この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。
          この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。
</span><!--end_jpstr-->
</p>
        <p class="last"><a class="reference external" href="https://developer.apple.com/support/beta-software/">Learn more about using Apple's beta software</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright &copy; 2018 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../_static/javascripts/application.js"></script>
  </body>
</html>
