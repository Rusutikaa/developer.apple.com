

<!DOCTYPE html>



<head>
    <meta charset="utf-8" />
    <meta name="author" content="Apple Inc." />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    
    <title>Expressions &mdash; The Swift Programming Language (Swift 4.2)</title>
    
    <link rel="license" href="/LICENSE.txt" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css" />
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" /> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 4.2</div></h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Welcome to Swift<br><span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LanguageGuide/TheBasics.html">Language Guide<br><span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="AboutTheLanguageReference.html">Language Reference<br><span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="AboutTheLanguageReference.html">About the Language Reference<br><span class="jpstr">
言語リファレンスについて
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="LexicalStructure.html">Lexical Structure<br><span class="jpstr">
語彙の構造
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types<br><span class="jpstr">
型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Expressions<br><span class="jpstr">
式
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Statements.html">Statements<br><span class="jpstr">
文
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Declarations.html">Declarations<br><span class="jpstr">
宣言
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Attributes.html">Attributes<br><span class="jpstr">
属性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Patterns.html">Patterns<br><span class="jpstr">
パターン
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="GenericParametersAndArguments.html">Generic Parameters and Arguments<br><span class="jpstr">
総称体パラメータと引数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="zzSummaryOfTheGrammar.html">Summary of the Grammar<br><span class="jpstr">
文法の概要
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html">Revision History<br><span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
                <ul>
<li><a class="reference internal" href="#">Expressions<br><span class="jpstr">
式
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID384">Prefix Expressions<br><span class="jpstr">
接頭辞式
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID516">Try Operator<br><span class="jpstr">
try演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID385">Binary Expressions<br><span class="jpstr">
二項式
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID386">Assignment Operator<br><span class="jpstr">
代入演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID387">Ternary Conditional Operator<br><span class="jpstr">
三項条件演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID388">Type-Casting Operators<br><span class="jpstr">
型キャスト演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID389">Primary Expressions<br><span class="jpstr">
基本式
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID390">Literal Expression<br><span class="jpstr">
リテラル式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID391">Self Expression<br><span class="jpstr">
self式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID392">Superclass Expression<br><span class="jpstr">
スーパークラス式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID393">Closure Expression<br><span class="jpstr">
クロージャ式
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID544">Capture Lists<br><span class="jpstr">
キャプチャリスト
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID394">Implicit Member Expression<br><span class="jpstr">
暗黙のメンバー式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID395">Parenthesized Expression<br><span class="jpstr">
括弧に入れられた式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID552">Tuple Expression</a></li>
<li><a class="reference internal" href="#ID396">Wildcard Expression<br><span class="jpstr">
ワイルドカード式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID563">Key-Path Expression<br><span class="jpstr">
キーパス式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID547">Selector Expression<br><span class="jpstr">
セレクタ式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID549">Key-Path String Expression<br><span class="jpstr">
キーパス文字列式
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID397">Postfix Expressions<br><span class="jpstr">
接尾辞表現
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID398">Function Call Expression<br><span class="jpstr">
関数呼び出し式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID399">Initializer Expression<br><span class="jpstr">
イニシャライザ式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID400">Explicit Member Expression<br><span class="jpstr">
明示的メンバー式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID401">Postfix Self Expression<br><span class="jpstr">
接尾辞self式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID403">Subscript Expression<br><span class="jpstr">
添え字式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID404">Forced-Value Expression<br><span class="jpstr">
強制された値式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID405">Optional-Chaining Expression<br><span class="jpstr">
オプショナル連鎖式
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="expressions">
<h1>Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a><br><span class="jpstr">
式<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h1>
<p>In Swift, there are four kinds of expressions: prefix expressions, binary expressions, primary expressions, and postfix expressions. Evaluating an expression returns a value, causes a side effect, or both.<br><span class="jpstr">
スウィフトには、４種類の式があります：接頭辞式、二項式、基本式、そして接尾辞式。ある式を評価することは、ひとつの値を返す、ある副作用を引き起こす、あるいはその両方です。
</span><!--end_jpstr-->
</p>
<p>Prefix and binary expressions let you apply operators to smaller expressions. Primary expressions are conceptually the simplest kind of expression, and they provide a way to access values. Postfix expressions, like prefix and binary expressions, let you build up more complex expressions using postfixes such as function calls and member access. Each kind of expression is described in detail in the sections below.<br><span class="jpstr">
接頭辞と二項式は、あなたに演算子をより小さい式に適用させます。基本式は、概念的に最も単純な種類の式で、それらはアクセス手段をさまざまな値に提供します。接尾辞式は、接頭辞や二項の式に似て、関数呼び出しやメンバー・アクセスのような接尾辞を使うことで、あなたにより複雑な式を組み立てさせます。各種類の式は、以下の節において詳細に記述されます。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of an expression<br><span class="jpstr">
式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_expression"></a>expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_try-operator">try-operator</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_prefix-expression">prefix-expression</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_binary-expressions">binary-expressions</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_expression-list"></a>expression-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression-list">expression-list</a></span> </p></div></div><div class="section" id="ID384">
<h2>Prefix Expressions<a class="headerlink" href="#ID384" title="Permalink to this headline">¶</a><br><span class="jpstr">
接頭辞式<a class="headerlink" href="#ID384" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><em>Prefix expressions</em> combine an optional prefix operator with an expression. Prefix operators take one argument, the expression that follows them.<br><span class="jpstr">
<em>接頭辞式</em>では、ある任意の接頭辞演算子をひとつの式と組み合わせます。接頭辞演算子は、１つの引数（それらの後に続く式）をとります。
</span><!--end_jpstr-->
</p>
<p>For information about the behavior of these operators, see <a class="reference internal" href="../LanguageGuide/BasicOperators.html"><span class="doc">Basic Operators</span></a> and <a class="reference internal" href="../LanguageGuide/AdvancedOperators.html"><span class="doc">Advanced Operators</span></a>.<br><span class="jpstr">
これらの演算子の挙動に関して詳しくは、<a class="reference internal" href="../LanguageGuide/BasicOperators.html"><span class="doc">基本の演算子</span></a>と<a class="reference internal" href="../LanguageGuide/AdvancedOperators.html"><span class="doc">先進の演算子</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>For information about the operators provided by the Swift standard library, see <a class="reference external" href="https://developer.apple.com/documentation/swift/operator_declarations">Operator Declarations</a>.<br><span class="jpstr">
スウィフト標準ライブラリによって提供される演算子についての情報のために、<a class="reference external" href="../../../developer.apple.com/documentation/swift/swift_standard_library/operator_declarations.html">さまざまな演算子宣言</a>を見てください。
</span><!--end_jpstr-->
</p>
<p>In addition to the standard library operators, you use <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> immediately before the name of a variable that’s being passed as an in-out argument to a function call expression. For more information and to see an example, see <a class="reference internal" href="../LanguageGuide/Functions.html#ID173"><span class="std std-ref">In-Out Parameters</span></a>.<br><span class="jpstr">
標準ライブラリ演算子に加えて、あなたは<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>を変数の名前の直前で使います、それはin-out引数として関数呼び出し式に渡されています。より多くの情報のために、そして、例を見るために、<a class="reference internal" href="../LanguageGuide/Functions.html#ID173"><span class="std std-ref">In-Outパラメータ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a prefix expression<br><span class="jpstr">
接頭辞式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_prefix-expression"></a>prefix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_prefix-operator">prefix-operator</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_prefix-expression_1058"></a>prefix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_in-out-expression">in-out-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_in-out-expression"></a>in-out-expression</span><span class="arrow"> → </span> <code>&amp;</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p></div></div><div class="section" id="ID516">
<h3>Try Operator<a class="headerlink" href="#ID516" title="Permalink to this headline">¶</a><br><span class="jpstr">
try演算子<a class="headerlink" href="#ID516" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A <em>try expression</em> consists of the <code class="docutils literal notranslate"><span class="pre">try</span></code> operator followed by an expression that can throw an error. It has the following form:<br><span class="jpstr">
<em>try式</em>は、<code class="docutils literal notranslate"><span class="pre">try</span></code>演算子と後につづくエラーをスローできる１つの式から成ります。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">try</span> <span class="gi">expression</span>
</li></ol></div></div></div>
<p>An <em>optional-try expression</em> consists of the <code class="docutils literal notranslate"><span class="pre">try?</span></code> operator followed by an expression that can throw an error. It has the following form:<br><span class="jpstr">
<em>オプショナルtry式</em>は、<code class="docutils literal notranslate"><span class="pre">try?</span></code>演算子と後につづくエラーをスローできる１つの式から成ります。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">try</span>? <span class="gi">expression</span>
</li></ol></div></div></div>
<p>If the <em>expression</em> does not throw an error, the value of the optional-try expression is an optional containing the value of the <em>expression</em>. Otherwise, the value of the optional-try expression is <code class="docutils literal notranslate"><span class="pre">nil</span></code>.<br><span class="jpstr">
この<em>expression（式）</em>がエラーをスローしないならば、オプショナルtry式の値はひとつのオプショナルになり、その<em>expression（式）</em>の値を含んでいます。そうでなければ、オプショナルtry式の値は<code class="docutils literal notranslate"><span class="pre">nil</span></code>です。
</span><!--end_jpstr-->
</p>
<p>A <em>forced-try expression</em> consists of the <code class="docutils literal notranslate"><span class="pre">try!</span></code> operator followed by an expression that can throw an error. It has the following form:<br><span class="jpstr">
<em>強制try式</em>は、<code class="docutils literal notranslate"><span class="pre">try!</span></code>演算子と後につづくエラーをスローできる１つの式から成ります。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">try</span>! <span class="gi">expression</span>
</li></ol></div></div></div>
<p>If the <em>expression</em> throws an error, a runtime error is produced.<br><span class="jpstr">
この<em>expression（式）</em>がエラーをスローするならば、実行時エラーが生み出されます。
</span><!--end_jpstr-->
</p>
<p>When the expression on the left-hand side of a binary operator is marked with <code class="docutils literal notranslate"><span class="pre">try</span></code>, <code class="docutils literal notranslate"><span class="pre">try?</span></code>, or <code class="docutils literal notranslate"><span class="pre">try!</span></code>, that operator applies to the whole binary expression. That said, you can use parentheses to be explicit about the scope of the operator’s application.<br><span class="jpstr">
ある二項演算子の左手側での式が<code class="docutils literal notranslate"><span class="pre">try</span></code>、<code class="docutils literal notranslate"><span class="pre">try?</span></code>、または<code class="docutils literal notranslate"><span class="pre">try!</span></code>で印される場合、その演算子は二項式全体に適用されます。とは言うものの、あなたは丸括弧を使って演算子の適用範囲について明確にすることができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">sum</span> = <span class="k">try</span> <span class="nv">someThrowingFunction</span>() + <span class="nv">anotherThrowingFunction</span>()   <span class="c">// try applies to both function calls&nbsp;<span class="jpstr"><span class="c">（tryは、両方の関数呼び出しに適用されます）</span></span><!--end_jpstr--></span>
</li><li><span class="nv">sum</span> = <span class="k">try</span> (<span class="nv">someThrowingFunction</span>() + <span class="nv">anotherThrowingFunction</span>()) <span class="c">// try applies to both function calls&nbsp;<span class="jpstr"><span class="c">（tryは、両方の関数呼び出しに適用されます）</span></span><!--end_jpstr--></span>
</li><li><span class="nv">sum</span> = (<span class="k">try</span> <span class="nv">someThrowingFunction</span>()) + <span class="nv">anotherThrowingFunction</span>() <span class="c">// Error: try applies only to the first function call&nbsp;<span class="jpstr"><span class="c">（エラー：tryは、最初の関数呼び出しだけに適用されます）</span></span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p>A <code class="docutils literal notranslate"><span class="pre">try</span></code> expression can’t appear on the right-hand side of a binary operator, unless the binary operator is the assignment operator or the <code class="docutils literal notranslate"><span class="pre">try</span></code> expression is enclosed in parentheses.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">try</span></code>式が二項演算子の右手側に現れることは、その二項演算子が代入演算子であるか<code class="docutils literal notranslate"><span class="pre">try</span></code>式が丸括弧の中に入れられるかしない限りはできません。
</span><!--end_jpstr-->
</p>
<p>For more information and to see examples of how to use <code class="docutils literal notranslate"><span class="pre">try</span></code>, <code class="docutils literal notranslate"><span class="pre">try?</span></code>, and <code class="docutils literal notranslate"><span class="pre">try!</span></code>, see <a class="reference internal" href="../LanguageGuide/ErrorHandling.html"><span class="doc">Error Handling</span></a>.<br><span class="jpstr">
より多くの情報のために、そして<code class="docutils literal notranslate"><span class="pre">try</span></code>、<code class="docutils literal notranslate"><span class="pre">try?</span></code>、そして<code class="docutils literal notranslate"><span class="pre">try!</span></code>文を使う方法の例を見るために、<a class="reference internal" href="../LanguageGuide/ErrorHandling.html"><span class="doc">エラーを処理する</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a try expression<br><span class="jpstr">
try式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_try-operator"></a>try-operator</span><span class="arrow"> → </span> <code>try</code> |  <code>try</code> <code>?</code> |  <code>try</code> <code>!</code></p></div></div></div>
</div>
<div class="section" id="ID385">
<h2>Binary Expressions<a class="headerlink" href="#ID385" title="Permalink to this headline">¶</a><br><span class="jpstr">
二項式<a class="headerlink" href="#ID385" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><em>Binary expressions</em> combine an infix binary operator with the expression that it takes as its left-hand and right-hand arguments. It has the following form:<br><span class="jpstr">
<em>二項式</em>は、接中辞二進数演算子を、それがその左手側と右手側の引数としてとる式と組み合わせます。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">left-hand argument</span> <span class="gi">operator</span> <span class="gi">right-hand argument</span>
</li></ol></div></div></div>
<p>For information about the behavior of these operators, see <a class="reference internal" href="../LanguageGuide/BasicOperators.html"><span class="doc">Basic Operators</span></a> and <a class="reference internal" href="../LanguageGuide/AdvancedOperators.html"><span class="doc">Advanced Operators</span></a>.<br><span class="jpstr">
これらの演算子の挙動に関して詳しくは、<a class="reference internal" href="../LanguageGuide/BasicOperators.html"><span class="doc">基本の演算子</span></a>と<a class="reference internal" href="../LanguageGuide/AdvancedOperators.html"><span class="doc">先進の演算子</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>For information about the operators provided by the Swift standard library, see <a class="reference external" href="https://developer.apple.com/documentation/swift/operator_declarations">Operator Declarations</a>.<br><span class="jpstr">
スウィフト標準ライブラリによって提供される演算子についての情報のために、<a class="reference external" href="../../../developer.apple.com/documentation/swift/swift_standard_library/operator_declarations.html">さまざまな演算子宣言</a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">At parse time, an expression made up of binary operators is represented as a flat list. This list is transformed into a tree by applying operator precedence. For example, the expression <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">5</span></code> is initially understood as a flat list of five items, <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, and <code class="docutils literal notranslate"><span class="pre">5</span></code>. This process transforms it into the tree (2 + (3 * 5)).<br><span class="jpstr">
構文解析の時、二項演算子から成り立つ式は、平坦なリストとして表わされます。このリストは、演算子優先順位を適用することによって、ツリー（木構造）に変えられます。例えば、式<code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">5</span></code>は、最初に５つの項目、<code class="docutils literal notranslate"><span class="pre">2</span></code>、<code class="docutils literal notranslate"><span class="pre">+</span></code>、<code class="docutils literal notranslate"><span class="pre">3</span></code>、<code class="docutils literal notranslate"><span class="pre">*</span></code>、そして<code class="docutils literal notranslate"><span class="pre">5</span></code>の平坦なリストとして理解されます。この処理は、それをツリー(2 + (3 * 5))に変えます。
</span><!--end_jpstr-->
</p>
</div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a binary expression<br><span class="jpstr">
二項式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_binary-expression"></a>binary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_binary-operator">binary-operator</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_prefix-expression">prefix-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_binary-expression_1059"></a>binary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_assignment-operator">assignment-operator</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_try-operator">try-operator</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_prefix-expression">prefix-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_binary-expression_1060"></a>binary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_conditional-operator">conditional-operator</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_try-operator">try-operator</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_prefix-expression">prefix-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_binary-expression_1061"></a>binary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_type-casting-operator">type-casting-operator</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_binary-expressions"></a>binary-expressions</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_binary-expression">binary-expression</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_binary-expressions">binary-expressions</a></span> <sub>opt</sub></p></div></div><div class="section" id="ID386">
<h3>Assignment Operator<a class="headerlink" href="#ID386" title="Permalink to this headline">¶</a><br><span class="jpstr">
代入演算子<a class="headerlink" href="#ID386" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>The <em>assignment operator</em> sets a new value for a given expression. It has the following form:<br><span class="jpstr">
<em>代入演算子</em>は、指定された式に対してある新しい値を設定します。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">expression</span> = <span class="gi">value</span>
</li></ol></div></div></div>
<p>The value of the <em>expression</em> is set to the value obtained by evaluating the <em>value</em>. If the <em>expression</em> is a tuple, the <em>value</em> must be a tuple with the same number of elements. (Nested tuples are allowed.) Assignment is performed from each part of the <em>value</em> to the corresponding part of the <em>expression</em>. For example:<br><span class="jpstr">
<em>式</em>の値は、<em>値</em>を評価することによって得られる値に設定されます。<em>式</em>がタプルであるならば、<em>値</em>は同じ数の要素をもつタプルでなければなりません。（入れ子にされたタプルは、認められます）。代入は、<em>値</em>の各部分から<em>式</em>の対応する部分へと実行されます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>(<span class="nv">a</span>, <span class="k">_</span>, (<span class="nv">b</span>, <span class="nv">c</span>)) = (<span class="s">&quot;test&quot;</span>, <span class="m">9.45</span>, (<span class="m">12</span>, <span class="m">3</span>))
</li><li><span class="c">// a is &quot;test&quot;, b is 12, c is 3, and 9.45 is ignored&nbsp;<span class="jpstr">（aは「test」です、bは12です、cは３です、そして9.45は無視されます）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>The assignment operator does not return any value.<br><span class="jpstr">
代入演算子は、少しの値も返しません。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of an assignment operator<br><span class="jpstr">
代入演算子の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_assignment-operator"></a>assignment-operator</span><span class="arrow"> → </span> <code>=</code></p></div></div></div>
<div class="section" id="ID387">
<h3>Ternary Conditional Operator<a class="headerlink" href="#ID387" title="Permalink to this headline">¶</a><br><span class="jpstr">
三項条件演算子<a class="headerlink" href="#ID387" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>The <em>ternary conditional operator</em> evaluates to one of two given values based on the value of a condition. It has the following form:<br><span class="jpstr">
<em>三項条件演算子</em>は、ある条件の値に基づいて、２つの与えられた値のうちの１つへと評価されます。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">condition</span> ? <span class="gi">expression used if true</span> : <span class="gi">expression used if false</span>
</li></ol></div></div></div>
<p>If the <em>condition</em> evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code>, the conditional operator evaluates the first expression and returns its value. Otherwise, it evaluates the second expression and returns its value. The unused expression is not evaluated.<br><span class="jpstr">
<em>条件</em>が<code class="docutils literal notranslate"><span class="pre">true</span></code>に評価されるならば、条件演算子は最初の式を評価して、その値を返します。そうでなければ、それは第二の式を評価して、その値を返します。使っていない式は、評価されません。
</span><!--end_jpstr-->
</p>
<p>For an example that uses the ternary conditional operator, see <a class="reference internal" href="../LanguageGuide/BasicOperators.html#ID71"><span class="std std-ref">Ternary Conditional Operator</span></a>.<br><span class="jpstr">
三項条件演算子を使用する例のために、<a class="reference internal" href="../LanguageGuide/BasicOperators.html#ID71"><span class="std std-ref">三項条件演算子</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a conditional operator<br><span class="jpstr">
条件演算子の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_conditional-operator"></a>conditional-operator</span><span class="arrow"> → </span> <code>?</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>:</code></p></div></div></div>
<div class="section" id="ID388">
<h3>Type-Casting Operators<a class="headerlink" href="#ID388" title="Permalink to this headline">¶</a><br><span class="jpstr">
型キャスト演算子<a class="headerlink" href="#ID388" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>There are four type-casting operators: the <code class="docutils literal notranslate"><span class="pre">is</span></code> operator, the <code class="docutils literal notranslate"><span class="pre">as</span></code> operator, the <code class="docutils literal notranslate"><span class="pre">as?</span></code> operator, and the <code class="docutils literal notranslate"><span class="pre">as!</span></code> operator.<br><span class="jpstr">
４つの型キャスト演算子、<code class="docutils literal notranslate"><span class="pre">is</span></code>演算子、<code class="docutils literal notranslate"><span class="pre">as</span></code>演算子、<code class="docutils literal notranslate"><span class="pre">as?</span></code>演算子、そして<code class="docutils literal notranslate"><span class="pre">as!</span></code>演算子があります。
</span><!--end_jpstr-->
</p>
<p>They have the following form:<br><span class="jpstr">
これらは以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">expression</span> <span class="k">is</span> <span class="gi">type</span>
</li><li><span class="gi">expression</span> <span class="k">as</span> <span class="gi">type</span>
</li><li><span class="gi">expression</span> <span class="k">as</span>? <span class="gi">type</span>
</li><li><span class="gi">expression</span> <span class="k">as</span>! <span class="gi">type</span>
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">is</span></code> operator checks at runtime whether the <em>expression</em> can be cast to the specified <em>type</em>. It returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the <em>expression</em> can be cast to the specified <em>type</em>; otherwise, it returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">is</span></code>演算子は実行時に<em>式</em>が指定された<em>型</em>へとキャスト可能かどうかを調べます。それは、<em>式</em>が指定された<em>型</em>へキャストできるならば<code class="docutils literal notranslate"><span class="pre">true</span></code>を返します；そうでなければ<code class="docutils literal notranslate"><span class="pre">false</span></code>を返します。
</span><!--end_jpstr-->
</p>
<p>The <code class="docutils literal notranslate"><span class="pre">as</span></code> operator performs a cast when it is known at compile time that the cast always succeeds, such as upcasting or bridging. Upcasting lets you use an expression as an instance of its type’s supertype, without using an intermediate variable. The following approaches are equivalent:<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">as</span></code>演算子は、コンパイル時にそのキャストが常に成功することを知られているキャストを実行します、例えばアップキャストやブリッジなど。アップキャストは、あなたにある式をそれのスーパータイプのインスタンスとして使用させます、中間生成物の変数の使用なしに。以下の各取り組みは同等です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">f</span>(<span class="k">_</span> <span class="nv">any</span>: <span class="k">Any</span>) { <span class="nv">print</span>(<span class="s">&quot;Function for Any&quot;</span>) }
</li><li><span class="k">func</span> <span class="nv">f</span>(<span class="k">_</span> <span class="nv">int</span>: <span class="nc">Int</span>) { <span class="nv">print</span>(<span class="s">&quot;Function for Int&quot;</span>) }
</li><li><span class="k">let</span> <span class="nv">x</span> = <span class="m">10</span>
</li><li><span class="nv">f</span>(<span class="nv">x</span>)
</li><li><span class="c">// Prints &quot;Function for Int&quot;</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">y</span>: <span class="k">Any</span> = <span class="nv">x</span>
</li><li><span class="nv">f</span>(<span class="nv">y</span>)
</li><li><span class="c">// Prints &quot;Function for Any&quot;</span>
</li><li>
</li><li><span class="nv">f</span>(<span class="nv">x</span> <span class="k">as</span> <span class="k">Any</span>)
</li><li><span class="c">// Prints &quot;Function for Any&quot;</span>
</li></ol></div></div></div>
<p>Bridging lets you use an expression of a Swift standard library type such as <code class="docutils literal notranslate"><span class="pre">String</span></code> as its corresponding Foundation type such as <code class="docutils literal notranslate"><span class="pre">NSString</span></code> without needing to create a new instance. For more information on bridging, see <a class="reference external" href="https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types">Working with Foundation Types</a>.<br><span class="jpstr">
ブリッジは、あなたに<code class="docutils literal notranslate"><span class="pre">String</span></code>のようなスウィフト標準ライブラリ型の式を、<code class="docutils literal notranslate"><span class="pre">NSString</span></code>のようなそれの対応しているFoundation型として使用させます、新しいインスタンスを作成する必要なしに。ブリッジに関するより多くの情報のために、<a class="reference external" href="../../../developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/working_with_foundation_types.html">Foundation型を扱う</a>を見てください。
</span><!--end_jpstr-->
</p>
<p>The <code class="docutils literal notranslate"><span class="pre">as?</span></code> operator performs a conditional cast of the <em>expression</em> to the specified <em>type</em>. The <code class="docutils literal notranslate"><span class="pre">as?</span></code> operator returns an optional of the specified <em>type</em>. At runtime, if the cast succeeds, the value of <em>expression</em> is wrapped in an optional and returned; otherwise, the value returned is <code class="docutils literal notranslate"><span class="pre">nil</span></code>. If casting to the specified <em>type</em> is guaranteed to fail or is guaranteed to succeed, a compile-time error is raised.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">as?</span></code>演算子は<em>式</em>の指定された<em>型</em>への条件付きキャストを実行します。<code class="docutils literal notranslate"><span class="pre">as?</span></code>演算子は、指定された<em>型</em>のオプショナルを返します。実行時に、キャストが成功したならば、<em>式</em>の値がひとつのオプショナルの中にラップされて返されます；そうでなければ返される値は<code class="docutils literal notranslate"><span class="pre">nil</span></code>です。指定された<em>型</em>へのキャストが失敗すると保証されるまたは成功すると保証される場合には、コンパイル時エラーが引き起こされます。
</span><!--end_jpstr-->
</p>
<p>The <code class="docutils literal notranslate"><span class="pre">as!</span></code> operator performs a forced cast of the <em>expression</em> to the specified <em>type</em>. The <code class="docutils literal notranslate"><span class="pre">as!</span></code> operator returns a value of the specified <em>type</em>, not an optional type. If the cast fails, a runtime error is raised. The behavior of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">as!</span> <span class="pre">T</span></code> is the same as the behavior of <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">as?</span> <span class="pre">T)!</span></code>.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">as!</span></code>演算子は<em>式</em>の指定された<em>型</em>への強制的なキャストを実行します。<code class="docutils literal notranslate"><span class="pre">as!</span></code>演算子は指定された<em>型</em>の値を返します、オプショナル型ではなく。キャストが失敗したならば、実行時エラーが引き起こされます。<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">as!</span> <span class="pre">T</span></code>の挙動は、<code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">as?</span> <span class="pre">T)!</span></code>の挙動と同じです。
</span><!--end_jpstr-->
</p>
<p>For more information about type casting and to see examples that use the type-casting operators, see <a class="reference internal" href="../LanguageGuide/TypeCasting.html"><span class="doc">Type Casting</span></a>.<br><span class="jpstr">
型キャストに関するより多くの情報のために、そして、型キャスト演算子を使用する例をより多く見るために、<a class="reference internal" href="../LanguageGuide/TypeCasting.html"><span class="doc">型キャスト</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a type-casting operator<br><span class="jpstr">
型キャスト演算子の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type-casting-operator"></a>type-casting-operator</span><span class="arrow"> → </span> <code>is</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type-casting-operator_1062"></a>type-casting-operator</span><span class="arrow"> → </span> <code>as</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type-casting-operator_1063"></a>type-casting-operator</span><span class="arrow"> → </span> <code>as</code> <code>?</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type-casting-operator_1064"></a>type-casting-operator</span><span class="arrow"> → </span> <code>as</code> <code>!</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p></div></div></div>
</div>
<div class="section" id="ID389">
<h2>Primary Expressions<a class="headerlink" href="#ID389" title="Permalink to this headline">¶</a><br><span class="jpstr">
基本式<a class="headerlink" href="#ID389" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><em>Primary expressions</em> are the most basic kind of expression. They can be used as expressions on their own, and they can be combined with other tokens to make prefix expressions, binary expressions, and postfix expressions.<br><span class="jpstr">
<em>基本式</em>は、最も基本的な種類の式です。それらはそれら自身で式として使われることができます、そしてそれらは接頭辞式、二項式、そして接尾辞式を作るために別のトークンと組み合わされることができます。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a primary expression<br><span class="jpstr">
基本式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-argument-clause">generic-argument-clause</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1065"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_literal-expression">literal-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1066"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_self-expression">self-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1067"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_superclass-expression">superclass-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1068"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-expression">closure-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1069"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_parenthesized-expression">parenthesized-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1070"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_tuple-expression">tuple-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1071"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_implicit-member-expression">implicit-member-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1072"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_wildcard-expression">wildcard-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1073"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-expression">key-path-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1074"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_selector-expression">selector-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1075"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-string-expression">key-path-string-expression</a></span> </p></div></div><div class="section" id="ID390">
<h3>Literal Expression<a class="headerlink" href="#ID390" title="Permalink to this headline">¶</a><br><span class="jpstr">
リテラル式<a class="headerlink" href="#ID390" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A <em>literal expression</em> consists of either an ordinary literal (such as a string or a number), an array or dictionary literal, a playground literal, or one of the following special literals:<br><span class="jpstr">
<em>リテラル式</em>は、普通のリテラル（例えば、ある文字列または数）、配列または辞書リテラル、プレイグラウンドリテラル、または以下の特別なリテラルのうちの１つから成ります：
</span><!--end_jpstr-->
</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="21%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Literal<br><span class="jpstr">
リテラル
</span><!--end_jpstr-->
</th>
<th class="head">Type<br><span class="jpstr">
型
</span><!--end_jpstr-->
</th>
<th class="head">Value<br><span class="jpstr">
値
</span><!--end_jpstr-->
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">#file</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">String</span></code></td>
<td>The name of the file in which it appears.<br><span class="jpstr">
それが現れるファイルの名前。
</span><!--end_jpstr-->
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">#line</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">Int</span></code></td>
<td>The line number on which it appears.<br><span class="jpstr">
それが現れる行番号。
</span><!--end_jpstr-->
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">#column</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">Int</span></code></td>
<td>The column number in which it begins.<br><span class="jpstr">
それが開始するコラム番号。
</span><!--end_jpstr-->
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">#function</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">String</span></code></td>
<td>The name of the declaration in which it appears.<br><span class="jpstr">
それが現れる宣言の名前。
</span><!--end_jpstr-->
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">#dsohandle</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">UnsafeRawPointer</span></code></td>
<td>The DSO (dynamic shared object) handle in use where it appears.<br><span class="jpstr">
DSO（動的共有オブジェクト）は、使用されている場所で取り扱われます。
</span><!--end_jpstr-->
</td>
</tr>
</tbody>
</table>
<p>Inside a function, the value of <code class="docutils literal notranslate"><span class="pre">#function</span></code> is the name of that function, inside a method it is the name of that method, inside a property getter or setter it is the name of that property, inside special members like <code class="docutils literal notranslate"><span class="pre">init</span></code> or <code class="docutils literal notranslate"><span class="pre">subscript</span></code> it is the name of that keyword, and at the top level of a file it is the name of the current module.<br><span class="jpstr">
関数の内側では、<code class="docutils literal notranslate"><span class="pre">#function</span></code>の値は、その関数の名前であり、メソッドの内側ではそれはそのメソッドの名前であり、プロパティゲッターやセッターの内側ではそれはそのプロパティの名前であり、<code class="docutils literal notranslate"><span class="pre">init</span></code>または<code class="docutils literal notranslate"><span class="pre">subscript</span></code>のような特別なメンバーの内側ではそれはそのキーワードの名前であり、そしてあるファイルのトップレベルではそれは現在のモジュールの名前です。
</span><!--end_jpstr-->
</p>
<p>When used as the default value of a function or method parameter, the special literal’s value is determined when the default value expression is evaluated at the call site.<br><span class="jpstr">
関数およびメソッドのパラメータの省略時の値として使われる時、特殊リテラルの値は、省略時値式が呼び出し現場で評価される場合は決定されます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">logFunctionName</span>(<span class="nv">string</span>: <span class="nc">String</span> = <span class="k">#function</span>) {
</li><li>    <span class="nv">print</span>(<span class="nv">string</span>)
</li><li>}
</li><li><span class="k">func</span> <span class="nv">myFunction</span>() {
</li><li>    <span class="nv">logFunctionName</span>() <span class="c">// Prints &quot;myFunction()&quot;.</span>
</li><li>}
</li></ol></div></div></div>
<p>An <em>array literal</em> is an ordered collection of values. It has the following form:<br><span class="jpstr">
<em>配列リテラル</em>は、順序付けられた値のコレクションです。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>[<span class="gi">value 1</span>, <span class="gi">value 2</span>, <span class="gi">...</span>]
</li></ol></div></div></div>
<p>The last expression in the array can be followed by an optional comma. The value of an array literal has type <code class="docutils literal notranslate"><span class="pre">[T]</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> is the type of the expressions inside it. If there are expressions of multiple types, <code class="docutils literal notranslate"><span class="pre">T</span></code> is their closest common supertype. Empty array literals are written using an empty pair of square brackets and can be used to create an empty array of a specified type.<br><span class="jpstr">
配列の最後の式の後に、１つの任意のコンマが続くことができます。配列リテラルの値は型<code class="docutils literal notranslate"><span class="pre">[T]</span></code>を持ちます、そこで、<code class="docutils literal notranslate"><span class="pre">T</span></code>はそれの内部の式の型です。複数の型の式があるならば、<code class="docutils literal notranslate"><span class="pre">T</span></code>はそれらの最も近い共通のスーパー型です。空の配列リテラルは、空の角括弧の対を使って書かれて、指定された型の空の配列をつくるために使われることができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">emptyArray</span>: [<span class="nc">Double</span>] = []
</li></ol></div></div></div>
<p>A <em>dictionary literal</em> is an unordered collection of key-value pairs. It has the following form:<br><span class="jpstr">
<em>辞書リテラル</em>は、「キーと値」の対の順序付けされないコレクションです。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>[<span class="gi">key 1</span>: <span class="gi">value 1</span>, <span class="gi">key 2</span>: <span class="gi">value 2</span>, <span class="gi">...</span>]
</li></ol></div></div></div>
<p>The last expression in the dictionary can be followed by an optional comma. The value of a dictionary literal has type <code class="docutils literal notranslate"><span class="pre">[Key:</span> <span class="pre">Value]</span></code>, where <code class="docutils literal notranslate"><span class="pre">Key</span></code> is the type of its key expressions and <code class="docutils literal notranslate"><span class="pre">Value</span></code> is the type of its value expressions. If there are expressions of multiple types, <code class="docutils literal notranslate"><span class="pre">Key</span></code> and <code class="docutils literal notranslate"><span class="pre">Value</span></code> are the closest common supertype for their respective values. An empty dictionary literal is written as a colon inside a pair of brackets (<code class="docutils literal notranslate"><span class="pre">[:]</span></code>) to distinguish it from an empty array literal. You can use an empty dictionary literal to create an empty dictionary literal of specified key and value types.<br><span class="jpstr">
辞書の最後の式の後に、１つの任意のコンマが続くことができます。辞書リテラルの値は、型<code class="docutils literal notranslate"><span class="pre">[Key:</span> <span class="pre">Value]</span></code>を持ちます、そこで、<code class="docutils literal notranslate"><span class="pre">Key</span></code>はそのキーの式の型です、そして、<code class="docutils literal notranslate"><span class="pre">Value</span></code>はその値の式の型です。複数の型の式があるならば、<code class="docutils literal notranslate"><span class="pre">Key</span></code>と<code class="docutils literal notranslate"><span class="pre">Value</span></code>はそれらめいめいの値に対して最も近い共通のスーパー型です。空の辞書リテラルは、一対の角括弧の中のコロン（<code class="docutils literal notranslate"><span class="pre">[:]</span></code>）として書かれることで、空の配列リテラルからそれを区別します。あなたは、空の辞書リテラルを使って、指定されたキーと値型の空の辞書リテラルを作成できます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">emptyDictionary</span>: [<span class="nc">String</span>: <span class="nc">Double</span>] = [:]
</li></ol></div></div></div>
<p>A <em>playground literal</em> is used by Xcode to create an interactive representation of a color, file, or image within the program editor. Playground literals in plain text outside of Xcode are represented using a special literal syntax.<br><span class="jpstr">
<em>プレイグラウンドリテラル</em>は、Xcodeによって使われて、プログラムエディタ内でいろ、ファイル、または画像の双方向の表現を作成します。Xcodeの外部のプレーンテキストの中のプレイグラウンドリテラルは、特別なリテラル構文を使って表されます。
</span><!--end_jpstr-->
</p>
<p>For information on using playground literals in Xcode, see <a class="reference external" href="https://help.apple.com/xcode/mac/current/#/dev4c60242fc">Add a color, file, or image literal</a> in Xcode Help.<br><span class="jpstr">
Xcodeにおけるプレイグラウンドリテラルの使用に関するさらなる情報として、<a class="reference external" href="https://help.apple.com/xcode/mac/current/#/dev4c60242fc">Add a color, file, or image literal</a>をXcodeヘルプで見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a literal expression<br><span class="jpstr">
リテラル式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_literal-expression"></a>literal-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_literal">literal</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_literal-expression_1076"></a>literal-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_array-literal">array-literal</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_dictionary-literal">dictionary-literal</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_playground-literal">playground-literal</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_literal-expression_1077"></a>literal-expression</span><span class="arrow"> → </span> <code>#file</code> |  <code>#line</code> |  <code>#column</code> |  <code>#function</code> |  <code>#dsohandle</code></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_array-literal"></a>array-literal</span><span class="arrow"> → </span> <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_array-literal-items">array-literal-items</a></span> <sub>opt</sub> <code>]</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_array-literal-items"></a>array-literal-items</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_array-literal-item">array-literal-item</a></span>  <code>,</code><sub>opt</sub> |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_array-literal-item">array-literal-item</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_array-literal-items">array-literal-items</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_array-literal-item"></a>array-literal-item</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_dictionary-literal"></a>dictionary-literal</span><span class="arrow"> → </span> <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_dictionary-literal-items">dictionary-literal-items</a></span>  <code>]</code> |  <code>[</code> <code>:</code> <code>]</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_dictionary-literal-items"></a>dictionary-literal-items</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_dictionary-literal-item">dictionary-literal-item</a></span>  <code>,</code><sub>opt</sub> |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_dictionary-literal-item">dictionary-literal-item</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_dictionary-literal-items">dictionary-literal-items</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_dictionary-literal-item"></a>dictionary-literal-item</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_playground-literal"></a>playground-literal</span><span class="arrow"> → </span> <code>#colorLiteral</code> <code>(</code> <code>red</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>,</code> <code>green</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>,</code> <code>blue</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>,</code> <code>alpha</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_playground-literal_1078"></a>playground-literal</span><span class="arrow"> → </span> <code>#fileLiteral</code> <code>(</code> <code>resourceName</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_playground-literal_1079"></a>playground-literal</span><span class="arrow"> → </span> <code>#imageLiteral</code> <code>(</code> <code>resourceName</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p></div></div></div>
<div class="section" id="ID391">
<h3>Self Expression<a class="headerlink" href="#ID391" title="Permalink to this headline">¶</a><br><span class="jpstr">
self式<a class="headerlink" href="#ID391" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>The <code class="docutils literal notranslate"><span class="pre">self</span></code> expression is an explicit reference to the current type or instance of the type in which it occurs. It has the following forms:<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">self</span></code>式は、それがその中に現れているところの現在の型や型のインスタンスへの明確な参照です。それは、以下の各形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">self</span>
</li><li><span class="k">self</span>.<span class="gi">member name</span>
</li><li><span class="k">self</span>[<span class="gi">subscript index</span>]
</li><li><span class="k">self</span>(<span class="gi">initializer arguments</span>)
</li><li><span class="k">self</span>.<span class="nv">init</span>(<span class="gi">initializer arguments</span>)
</li></ol></div></div></div>
<p>In an initializer, subscript, or instance method, <code class="docutils literal notranslate"><span class="pre">self</span></code> refers to the current instance of the type in which it occurs. In a type method, <code class="docutils literal notranslate"><span class="pre">self</span></code> refers to the current type in which it occurs.<br><span class="jpstr">
イニシャライザ、添え字、またはインスタンスメソッドでは、<code class="docutils literal notranslate"><span class="pre">self</span></code>はそれが現れているところの型の現在のインスタンスに言及します。型メソッドでは、<code class="docutils literal notranslate"><span class="pre">self</span></code>はそれが現れているところの現在の型に言及します。
</span><!--end_jpstr-->
</p>
<p>The <code class="docutils literal notranslate"><span class="pre">self</span></code> expression is used to specify scope when accessing members, providing disambiguation when there is another variable of the same name in scope, such as a function parameter. For example:<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">self</span></code>式は、メンバーにアクセスする時にスコープを指定するために使われて、関数パラメータなど、同じ名前の別の変数がスコープ内にある場合に一義化を提供します。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li><li>    <span class="k">var</span> <span class="nv">greeting</span>: <span class="nc">String</span>
</li><li>    <span class="k">init</span>(<span class="nv">greeting</span>: <span class="nc">String</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">greeting</span> = <span class="nv">greeting</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>In a mutating method of a value type, you can assign a new instance of that value type to <code class="docutils literal notranslate"><span class="pre">self</span></code>. For example:<br><span class="jpstr">
値型の変更メソッドでは、あなたは<code class="docutils literal notranslate"><span class="pre">self</span></code>にその値型の新しいインスタンスを代入することができます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Point</span> {
</li><li>    <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li><li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">moveBy</span>(<span class="nv">x</span> <span class="nv">deltaX</span>: <span class="nc">Double</span>, <span class="nv">y</span> <span class="nv">deltaY</span>: <span class="nc">Double</span>) {
</li><li>        <span class="k">self</span> = <span class="nv">Point</span>(<span class="nv">x</span>: <span class="nv">x</span> + <span class="nv">deltaX</span>, <span class="nv">y</span>: <span class="nv">y</span> + <span class="nv">deltaY</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a self expression<br><span class="jpstr">
self式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_self-expression"></a>self-expression</span><span class="arrow"> → </span> <code>self</code> |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_self-method-expression">self-method-expression</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_self-subscript-expression">self-subscript-expression</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_self-initializer-expression">self-initializer-expression</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_self-method-expression"></a>self-method-expression</span><span class="arrow"> → </span> <code>self</code> <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_self-subscript-expression"></a>self-subscript-expression</span><span class="arrow"> → </span> <code>self</code> <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-list">function-call-argument-list</a></span>  <code>]</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_self-initializer-expression"></a>self-initializer-expression</span><span class="arrow"> → </span> <code>self</code> <code>.</code> <code>init</code></p></div></div></div>
<div class="section" id="ID392">
<h3>Superclass Expression<a class="headerlink" href="#ID392" title="Permalink to this headline">¶</a><br><span class="jpstr">
スーパークラス式<a class="headerlink" href="#ID392" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A <em>superclass expression</em> lets a class interact with its superclass. It has one of the following forms:<br><span class="jpstr">
<em>スーパークラス式</em>は、あるクラスをそのスーパークラスと相互に作用させます。それは、以下の書式のうちの１つを持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">super</span>.<span class="gi">member name</span>
</li><li><span class="k">super</span>[<span class="gi">subscript index</span>]
</li><li><span class="k">super</span>.<span class="nv">init</span>(<span class="gi">initializer arguments</span>)
</li></ol></div></div></div>
<p>The first form is used to access a member of the superclass. The second form is used to access the superclass’s subscript implementation. The third form is used to access an initializer of the superclass.<br><span class="jpstr">
最初の形式は、スーパークラスのメンバーにアクセスするために使われます。第２の形式は、スーパークラスの添え字実装にアクセスするために使われます。第３の形式は、スーパークラスのイニシャライザにアクセスするために使われます。
</span><!--end_jpstr-->
</p>
<p>Subclasses can use a superclass expression in their implementation of members, subscripting, and initializers to make use of the implementation in their superclass.<br><span class="jpstr">
サブクラスは、そのメンバー、添え字、そしてイニシャライザの実装においてスーパークラス式を使うことで、それらのスーバークラス内の実装を活用することができます。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a superclass expression<br><span class="jpstr">
スーパークラス式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_superclass-expression"></a>superclass-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_superclass-method-expression">superclass-method-expression</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_superclass-subscript-expression">superclass-subscript-expression</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_superclass-initializer-expression">superclass-initializer-expression</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_superclass-method-expression"></a>superclass-method-expression</span><span class="arrow"> → </span> <code>super</code> <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_superclass-subscript-expression"></a>superclass-subscript-expression</span><span class="arrow"> → </span> <code>super</code> <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-list">function-call-argument-list</a></span>  <code>]</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_superclass-initializer-expression"></a>superclass-initializer-expression</span><span class="arrow"> → </span> <code>super</code> <code>.</code> <code>init</code></p></div></div></div>
<div class="section" id="ID393">
<h3>Closure Expression<a class="headerlink" href="#ID393" title="Permalink to this headline">¶</a><br><span class="jpstr">
クロージャ式<a class="headerlink" href="#ID393" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A <em>closure expression</em> creates a closure, also known as a <em>lambda</em> or an <em>anonymous function</em> in other programming languages. Like a function declaration, a closure contains statements, and it captures constants and variables from its enclosing scope. It has the following form:<br><span class="jpstr">
<em>クロージャ式</em>はクロージャ、他のプログラミング言語ではまた<em>lambda</em>または<em>匿名関数</em>として知られるものをつくります。関数宣言の様に、クロージャはいくつかの文を含みます、そしてそれは、定数と変数をそれの取り囲むスコープからキャプチャします。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>{ (<span class="gi">parameters</span>) -&gt; <span class="gi">return type</span> <span class="k">in</span>
</li><li>    <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p>The <em>parameters</em> have the same form as the parameters in a function declaration, as described in <a class="reference internal" href="Declarations.html#ID362"><span class="std std-ref">Function Declaration</span></a>.<br><span class="jpstr">
<em>パラメータ</em>は、関数宣言で記述されるように、<a class="reference internal" href="Declarations.html#ID362"><span class="std std-ref">関数宣言でのパラメータ</span></a>と同じ形式を持ちます。
</span><!--end_jpstr-->
</p>
<p>There are several special forms that allow closures to be written more concisely:<br><span class="jpstr">
クロージャをより簡潔に書かれるようにする特別ないくつかの形式があります：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>A closure can omit the types of its parameters, its return type, or both. If you omit the parameter names and both types, omit the <code class="docutils literal notranslate"><span class="pre">in</span></code> keyword before the statements. If the omitted types can’t be inferred, a compile-time error is raised.<br><span class="jpstr">
クロージャは、そのパラメータの型、その戻り型、または両方を省略することができます。あなたがパラメータ名と両方の型を省略するならば、文の前の<code class="docutils literal notranslate"><span class="pre">in</span></code>キーワードを省略します。省略された型が推論されることができないならば、コンパイル時エラーが引き起こされます。
</span><!--end_jpstr-->
</li>
<li>A closure may omit names for its parameters. Its parameters are then implicitly named <code class="docutils literal notranslate"><span class="pre">$</span></code> followed by their position: <code class="docutils literal notranslate"><span class="pre">$0</span></code>, <code class="docutils literal notranslate"><span class="pre">$1</span></code>, <code class="docutils literal notranslate"><span class="pre">$2</span></code>, and so on.<br><span class="jpstr">
クロージャは、そのパラメータの名前を省略することができます。そのパラメータは、それから暗黙のうちに<code class="docutils literal notranslate"><span class="pre">$</span></code>の後にそれらの位置が続く名前：<code class="docutils literal notranslate"><span class="pre">$0</span></code>、<code class="docutils literal notranslate"><span class="pre">$1</span></code>、<code class="docutils literal notranslate"><span class="pre">$2</span></code>、などをつけられます。
</span><!--end_jpstr-->
</li>
<li>A closure that consists of only a single expression is understood to return the value of that expression. The contents of this expression are also considered when performing type inference on the surrounding expression.<br><span class="jpstr">
一つの式だけから成るクロージャは、その式の値を返すと理解されます。この式の内容はまた、型推論を実行する時に周囲の式上にあると見なされます。
</span><!--end_jpstr-->
</li>
</ul>
<p>The following closure expressions are equivalent:<br><span class="jpstr">
以下のクロージャ式は、等しいです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">myFunction</span> { (<span class="nv">x</span>: <span class="nc">Int</span>, <span class="nv">y</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> <span class="k">in</span>
</li><li>    <span class="k">return</span> <span class="nv">x</span> + <span class="nv">y</span>
</li><li>}
</li><li>
</li><li><span class="nv">myFunction</span> { <span class="nv">x</span>, <span class="nv">y</span> <span class="k">in</span>
</li><li>    <span class="k">return</span> <span class="nv">x</span> + <span class="nv">y</span>
</li><li>}
</li><li>
</li><li><span class="nv">myFunction</span> { <span class="k">return</span> <span class="nv">$0</span> + <span class="nv">$1</span> }
</li><li>
</li><li><span class="nv">myFunction</span> { <span class="nv">$0</span> + <span class="nv">$1</span> }
</li></ol></div></div></div>
<p>For information about passing a closure as an argument to a function, see <a class="reference internal" href="#ID398"><span class="std std-ref">Function Call Expression</span></a>.<br><span class="jpstr">
クロージャを引数として関数に渡すことに関する情報については、<a class="reference internal" href="#ID398"><span class="std std-ref">関数呼び出し式</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>Closure expressions can be used without being stored in a variable or constant, such as when you immediately use a closure as part of a function call. The closure expressions passed to <code class="docutils literal notranslate"><span class="pre">myFunction</span></code> in code above are examples of this kind of immediate use. As a result, whether a closure expression is escaping or nonescaping depends on the surrounding context of the expression. A closure expression is nonescaping if it is called immediately or passed as a nonescaping function argument. Otherwise, the closure expression is escaping.<br><span class="jpstr">
クロージャ式は、変数や定数の中に格納されることなく利用できます、例えばあなたが直接にクロージャを関数呼び出しの一部として使う場合など。上のコードにおいて<code class="docutils literal notranslate"><span class="pre">myFunction</span></code>に渡されるクロージャ式は、この種の直接的な利用の例です。結果として、あるクロージャ式が脱出または非脱出であるかどうかは、その式を取り囲んでいる前後関係に依存します。クロージャ式は、もしそれが直接に呼び出されるか、または非脱出関数引数として渡されるならば非脱出です。それ以外では、クロージャ式は脱出です。
</span><!--end_jpstr-->
</p>
<p>For more information about escaping closures, see <a class="reference internal" href="../LanguageGuide/Closures.html#ID546"><span class="std std-ref">Escaping Closures</span></a>.<br><span class="jpstr">
脱出クロージャについてのさらなる情報として、<a class="reference internal" href="../LanguageGuide/Closures.html#ID546"><span class="std std-ref">脱出クロージャ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID544">
<h4>Capture Lists<a class="headerlink" href="#ID544" title="Permalink to this headline">¶</a><br><span class="jpstr">
キャプチャリスト<a class="headerlink" href="#ID544" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h4>
<p>By default, a closure expression captures constants and variables from its surrounding scope with strong references to those values. You can use a <em>capture list</em> to explicitly control how values are captured in a closure.<br><span class="jpstr">
初期状態では、クロージャ式は、それの囲んでいるスコープから定数や変数をそれらの値への強い参照を使ってキャプチャします。あなたは<em>キャプチャリスト</em>を使って、どのようにあるクロージャにおいて値がキャプチャされるかを明示的に制御します。
</span><!--end_jpstr-->
</p>
<p>A capture list is written as a comma-separated list of expressions surrounded by square brackets, before the list of parameters. If you use a capture list, you must also use the <code class="docutils literal notranslate"><span class="pre">in</span></code> keyword, even if you omit the parameter names, parameter types, and return type.<br><span class="jpstr">
キャプチャリストは、いくらかの式の角括弧に囲まれてた「コンマ区切り」のリストとして、パラメータのリストの前に書かれます。あなたがキャプチャリストを使うならば、あなたはまた<code class="docutils literal notranslate"><span class="pre">in</span></code>キーワードも使わなければなりません、たとえあなたがパラメータ名、パラメータ型、そして戻り型を省略するとしてもです。
</span><!--end_jpstr-->
</p>
<p>The entries in the capture list are initialized when the closure is created. For each entry in the capture list, a constant is initialized to the value of the constant or variable that has the same name in the surrounding scope. For example in the code below, <code class="docutils literal notranslate"><span class="pre">a</span></code> is included in the capture list but <code class="docutils literal notranslate"><span class="pre">b</span></code> is not, which gives them different behavior.<br><span class="jpstr">
キャプチャリストの中の登録項目は、クロージャが作成されるときに初期化されます。キャプチャリストのそれぞれの登録項目に対して、その定数や変数の値へとひとつの定数が初期化されます、それは囲んでいるスコープの中で同じ名前を待ちます。例えば以下のコードにおいて、<code class="docutils literal notranslate"><span class="pre">a</span></code>はキャプチャリストに含まれますが<code class="docutils literal notranslate"><span class="pre">b</span></code>はそうではありません、そのことはそれらに異なる挙動を与えます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">a</span> = <span class="m">0</span>
</li><li><span class="k">var</span> <span class="nv">b</span> = <span class="m">0</span>
</li><li><span class="k">let</span> <span class="nv">closure</span> = { [<span class="nv">a</span>] <span class="k">in</span>
</li><li>    <span class="nv">print</span>(<span class="nv">a</span>, <span class="nv">b</span>)
</li><li>}
</li><li>
</li><li><span class="nv">a</span> = <span class="m">10</span>
</li><li><span class="nv">b</span> = <span class="m">10</span>
</li><li><span class="nv">closure</span>()
</li><li><span class="c">// Prints &quot;0 10&quot;</span>
</li></ol></div></div></div>
<p>There are two different things named <code class="docutils literal notranslate"><span class="pre">a</span></code>, the variable in the surrounding scope and the constant in the closure’s scope, but only one variable named <code class="docutils literal notranslate"><span class="pre">b</span></code>. The <code class="docutils literal notranslate"><span class="pre">a</span></code> in the inner scope is initialized with the value of the <code class="docutils literal notranslate"><span class="pre">a</span></code> in the outer scope when the closure is created, but their values are not connected in any special way. This means that a change to the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> in the outer scope does not affect the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> in the inner scope, nor does a change to <code class="docutils literal notranslate"><span class="pre">a</span></code> inside the closure affect the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> outside the closure. In contrast, there is only one variable named <code class="docutils literal notranslate"><span class="pre">b</span></code>—the <code class="docutils literal notranslate"><span class="pre">b</span></code> in the outer scope—so changes from inside or outside the closure are visible in both places.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">a</span></code>と名前をつけられる２つの異なるものがあります、囲んでいるスコープにおける変数とクロージャのスコープにおける定数、しかし<code class="docutils literal notranslate"><span class="pre">b</span></code>と名前をつけられる変数はただひとつのものです。内側のスコープの中の<code class="docutils literal notranslate"><span class="pre">a</span></code>は、クロージャが作成される時に外側のスコープの中の<code class="docutils literal notranslate"><span class="pre">a</span></code>の値で初期化されます、しかしそれらの値は何ら特別な方法で結びつけられません。これが意味するのは、外側のスコープの<code class="docutils literal notranslate"><span class="pre">a</span></code>の値に対する変更は内側のスコープの<code class="docutils literal notranslate"><span class="pre">a</span></code>の値に影響を及ぼさない、そしてまたクロージャ内部の<code class="docutils literal notranslate"><span class="pre">a</span></code>に対する変更はクロージャ外部の<code class="docutils literal notranslate"><span class="pre">a</span></code>に影響を及ぼさないということです。対照的に、<code class="docutils literal notranslate"><span class="pre">b</span></code>と名前を付けられるただ１つだけの変数があります ― 外側のスコープの中の<code class="docutils literal notranslate"><span class="pre">b</span></code> ― それでクロージャ内部および外部からの変更は、両方の場所で見ることができます。
</span><!--end_jpstr-->
</p>
<p>This distinction is not visible when the captured variable’s type has reference semantics. For example, there are two things named <code class="docutils literal notranslate"><span class="pre">x</span></code> in the code below, a variable in the outer scope and a constant in the inner scope, but they both refer to the same object because of reference semantics.<br><span class="jpstr">
この相違は、キャプチャされた変数の型が参照意味論を持つ場合には見られません。例えば、<code class="docutils literal notranslate"><span class="pre">x</span></code>と名前をつけられる２つのものが以下のコードにはあります、外側のスコープの中の変数と内側のスコープの中の定数、しかしそれらは両方とも同じオブジェクトを参照します、なぜなら参照意味論だからです。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SimpleClass</span> {
</li><li>    <span class="k">var</span> <span class="nv">value</span>: <span class="nc">Int</span> = <span class="m">0</span>
</li><li>}
</li><li><span class="k">var</span> <span class="nv">x</span> = <span class="nv">SimpleClass</span>()
</li><li><span class="k">var</span> <span class="nv">y</span> = <span class="nv">SimpleClass</span>()
</li><li><span class="k">let</span> <span class="nv">closure</span> = { [<span class="nv">x</span>] <span class="k">in</span>
</li><li>    <span class="nv">print</span>(<span class="nv">x</span>.<span class="nv">value</span>, <span class="nv">y</span>.<span class="nv">value</span>)
</li><li>}
</li><li>
</li><li><span class="nv">x</span>.<span class="nv">value</span> = <span class="m">10</span>
</li><li><span class="nv">y</span>.<span class="nv">value</span> = <span class="m">10</span>
</li><li><span class="nv">closure</span>()
</li><li><span class="c">// Prints &quot;10 10&quot;</span>
</li></ol></div></div></div>
<p>If the type of the expression’s value is a class, you can mark the expression in a capture list with <code class="docutils literal notranslate"><span class="pre">weak</span></code> or <code class="docutils literal notranslate"><span class="pre">unowned</span></code> to capture a weak or unowned reference to the expression’s value.<br><span class="jpstr">
この式の値の型がクラスならば、あなたはその式をキャプチャリストの中で<code class="docutils literal notranslate"><span class="pre">weak</span></code>または<code class="docutils literal notranslate"><span class="pre">unowned</span></code>を使って印を付けて、式の値に対する弱いまたは非所有の参照をキャプチャすることができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">myFunction</span> { <span class="nv">print</span>(<span class="k">self</span>.<span class="nv">title</span>) }                    <span class="c">// implicit strong capture</span>
</li><li><span class="nv">myFunction</span> { [<span class="k">self</span>] <span class="k">in</span> <span class="nv">print</span>(<span class="k">self</span>.<span class="nv">title</span>) }          <span class="c">// explicit strong capture</span>
</li><li><span class="nv">myFunction</span> { [<span class="nv">weak</span> <span class="k">self</span>] <span class="k">in</span> <span class="nv">print</span>(<span class="k">self</span>!.<span class="nv">title</span>) }    <span class="c">// weak capture&nbsp;<span class="jpstr"><span class="c">（弱いキャプチャ）</span></span><!--end_jpstr--></span>
</li><li><span class="nv">myFunction</span> { [<span class="nv">unowned</span> <span class="k">self</span>] <span class="k">in</span> <span class="nv">print</span>(<span class="k">self</span>.<span class="nv">title</span>) }  <span class="c">// unowned capture&nbsp;<span class="jpstr"><span class="c">（非所有者キャプチャ）</span></span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p>You can also bind an arbitrary expression to a named value in a capture list. The expression is evaluated when the closure is created, and the value is captured with the specified strength. For example:<br><span class="jpstr">
あなたはまた、ある任意の式を、キャプチャリストの中の名前をつけられた値と結び付けることができます。その式は、クロージャが作成される時に評価されます、そしてその値は、指定された強さでキャプチャされます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// Weak capture of &quot;self.parent&quot; as &quot;parent&quot;&nbsp;<span class="jpstr">（「parent」としての弱いキャプチャ「self.parent」）</span><!--end_jpstr-->
</span>
</li><li><span class="nv">myFunction</span> { [<span class="nv">weak</span> <span class="nv">parent</span> = <span class="k">self</span>.<span class="nv">parent</span>] <span class="k">in</span> <span class="nv">print</span>(<span class="nv">parent</span>!.<span class="nv">title</span>) }
</li></ol></div></div></div>
<p>For more information and examples of closure expressions, see <a class="reference internal" href="../LanguageGuide/Closures.html#ID95"><span class="std std-ref">Closure Expressions</span></a>. For more information and examples of capture lists, see <a class="reference internal" href="../LanguageGuide/AutomaticReferenceCounting.html#ID57"><span class="std std-ref">Resolving Strong Reference Cycles for Closures</span></a>.<br><span class="jpstr">
クロージャ式のより多くの情報と例のために、<a class="reference internal" href="../LanguageGuide/Closures.html#ID95"><span class="std std-ref">クロージャ式</span></a>を見てください。キャプチャリストのより多くの情報と例のために、<a class="reference internal" href="../LanguageGuide/AutomaticReferenceCounting.html#ID57"><span class="std std-ref">クロージャのための強い参照循環の解消</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a closure expression<br><span class="jpstr">
クロージャ式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-expression"></a>closure-expression</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-signature">closure-signature</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Statements.html#grammar_statements">statements</a></span> <sub>opt</sub> <code>}</code></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-signature"></a>closure-signature</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-list">capture-list</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-parameter-clause">closure-parameter-clause</a></span>  <code>throws</code><sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_function-result">function-result</a></span> <sub>opt</sub> <code>in</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-signature_1080"></a>closure-signature</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-list">capture-list</a></span>  <code>in</code></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-parameter-clause"></a>closure-parameter-clause</span><span class="arrow"> → </span> <code>(</code> <code>)</code> |  <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-parameter-list">closure-parameter-list</a></span>  <code>)</code> |  <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier-list">identifier-list</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-parameter-list"></a>closure-parameter-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-parameter">closure-parameter</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-parameter">closure-parameter</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-parameter-list">closure-parameter-list</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-parameter"></a>closure-parameter</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-parameter-name">closure-parameter-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-annotation">type-annotation</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-parameter_1081"></a>closure-parameter</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-parameter-name">closure-parameter-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-annotation">type-annotation</a></span>  <code>...</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-parameter-name"></a>closure-parameter-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_capture-list"></a>capture-list</span><span class="arrow"> → </span> <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-list-items">capture-list-items</a></span>  <code>]</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_capture-list-items"></a>capture-list-items</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-list-item">capture-list-item</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-list-item">capture-list-item</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-list-items">capture-list-items</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_capture-list-item"></a>capture-list-item</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-specifier">capture-specifier</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_capture-specifier"></a>capture-specifier</span><span class="arrow"> → </span> <code>weak</code> |  <code>unowned</code> |  <code>unowned(safe)</code> |  <code>unowned(unsafe)</code></p></div></div></div>
</div>
<div class="section" id="ID394">
<h3>Implicit Member Expression<a class="headerlink" href="#ID394" title="Permalink to this headline">¶</a><br><span class="jpstr">
暗黙のメンバー式<a class="headerlink" href="#ID394" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>An <em>implicit member expression</em> is an abbreviated way to access a member of a type, such as an enumeration case or a type method, in a context where type inference can determine the implied type. It has the following form:<br><span class="jpstr">
<em>暗黙のメンバー式</em>は、型推論が暗黙の型を決定することができる前後関係において、例えば列挙のケース節や型メソッドなど、ある型のメンバーにアクセスするための簡略された方法です。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>.<span class="gi">member name</span>
</li></ol></div></div></div>
<p>For example:<br><span class="jpstr">
例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">x</span> = <span class="nv">MyEnumeration</span>.<span class="nv">someValue</span>
</li><li><span class="nv">x</span> = .<span class="nv">anotherValue</span>
</li></ol></div></div></div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a implicit member expression<br><span class="jpstr">
暗黙的メンバー式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_implicit-member-expression"></a>implicit-member-expression</span><span class="arrow"> → </span> <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p></div></div></div>
<div class="section" id="ID395">
<h3>Parenthesized Expression<a class="headerlink" href="#ID395" title="Permalink to this headline">¶</a><br><span class="jpstr">
括弧に入れられた式<a class="headerlink" href="#ID395" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A <em>parenthesized expression</em> consists of an expression surrounded by parentheses. You can use parentheses to specify the precedence of operations by explicitly grouping expressions. Grouping parentheses don’t change an expression’s type—for example, the type of <code class="docutils literal notranslate"><span class="pre">(1)</span></code> is simply <code class="docutils literal notranslate"><span class="pre">Int</span></code>.<br><span class="jpstr">
<em>括弧に入れられた式</em>は、丸括弧で囲まれたある式から成ります。あなたは丸括弧を使って、明示的にいくらかの式をグループにまとめることによって演算の優先順位を指定することができます。グループ化括弧はある式のもつ型を変えません — 例えば、<code class="docutils literal notranslate"><span class="pre">(1)</span></code>の型は単に<code class="docutils literal notranslate"><span class="pre">Int</span></code>です。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a parenthesized expression<br><span class="jpstr">
丸括弧に入れられた式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_parenthesized-expression"></a>parenthesized-expression</span><span class="arrow"> → </span> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p></div></div></div>
<div class="section" id="ID552">
<h3>Tuple Expression<a class="headerlink" href="#ID552" title="Permalink to this headline">¶</a><br><span class="jpstr">
タプル式<a class="headerlink" href="#ID552" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A <em>tuple expression</em> consists of a comma-separated list of expressions surrounded by parentheses. Each expression can have an optional identifier before it, separated by a colon (<code class="docutils literal notranslate"><span class="pre">:</span></code>). It has the following form:<br><span class="jpstr">
<em>タプル式</em>は、丸括弧に囲まれているコンマ区切りの式のリストから成ります。各式はそれの前に、コロン（<code class="docutils literal notranslate"><span class="pre">:</span></code>）で区切られる任意の識別子を持つことができます。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>(<span class="gi">identifier 1</span>: <span class="gi">expression 1</span>, <span class="gi">identifier 2</span>: <span class="gi">expression 2</span>, <span class="gi">...</span>)
</li></ol></div></div></div>
<p>A tuple expression can contain zero expressions, or it can contain two or more expressions. A single expression inside parentheses is a parenthesized expression.<br><span class="jpstr">
タプル式はゼロ個の式を含むことができます、またはそれは２つまたはそれ以上の式を含むことができます。丸括弧で囲まれたただ１つだけの式は、括弧で囲まれた式です。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">Both an empty tuple expression and an empty tuple type are written <code class="docutils literal notranslate"><span class="pre">()</span></code> in Swift. Because <code class="docutils literal notranslate"><span class="pre">Void</span></code> is a type alias for <code class="docutils literal notranslate"><span class="pre">()</span></code>, you can use it to write an empty tuple type. However, like all type aliases, <code class="docutils literal notranslate"><span class="pre">Void</span></code> is always a type—you can’t use it to write an empty tuple expression.<br><span class="jpstr">
空のタプル式と空のタプル型は両方とも、<code class="docutils literal notranslate"><span class="pre">()</span></code>とスウィフトでは書かれます。<code class="docutils literal notranslate"><span class="pre">Void</span></code>が<code class="docutils literal notranslate"><span class="pre">()</span></code>に対する型エイリアスであることから、あなたはそれを使って空のタプル型を書くことができます。しかしながら、すべての型エイリアスのように、<code class="docutils literal notranslate"><span class="pre">Void</span></code>は常にある型です—あなたはそれを使って空のタプル式を書くことはできません。
</span><!--end_jpstr-->
</p>
</div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a tuple expression<br><span class="jpstr">
タプル式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_tuple-expression"></a>tuple-expression</span><span class="arrow"> → </span> <code>(</code> <code>)</code> |  <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_tuple-element">tuple-element</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_tuple-element-list">tuple-element-list</a></span>  <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_tuple-element-list"></a>tuple-element-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_tuple-element">tuple-element</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_tuple-element">tuple-element</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_tuple-element-list">tuple-element-list</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_tuple-element"></a>tuple-element</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span> </p></div></div></div>
<div class="section" id="ID396">
<h3>Wildcard Expression<a class="headerlink" href="#ID396" title="Permalink to this headline">¶</a><br><span class="jpstr">
ワイルドカード式<a class="headerlink" href="#ID396" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A <em>wildcard expression</em> is used to explicitly ignore a value during an assignment. For example, in the following assignment 10 is assigned to <code class="docutils literal notranslate"><span class="pre">x</span></code> and 20 is ignored:<br><span class="jpstr">
<em>ワイルドカード式</em>は、代入の間に明示的に値を無視するために使われます。例えば、以下の代入において、10は<code class="docutils literal notranslate"><span class="pre">x</span></code>に代入されて20は無視されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>(<span class="nv">x</span>, <span class="k">_</span>) = (<span class="m">10</span>, <span class="m">20</span>)
</li><li><span class="c">// x is 10, and 20 is ignored&nbsp;<span class="jpstr">（xは10です、そして20は無視されます）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a wildcard expression<br><span class="jpstr">
ワイルドカード式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_wildcard-expression"></a>wildcard-expression</span><span class="arrow"> → </span> <code>_</code></p></div></div></div>
<div class="section" id="ID563">
<h3>Key-Path Expression<a class="headerlink" href="#ID563" title="Permalink to this headline">¶</a><br><span class="jpstr">
キーパス式<a class="headerlink" href="#ID563" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A <em>key-path expression</em> refers to a property or subscript of a type. You use key-path expressions in dynamic programming tasks, such as key-value observing. They have the following form:<br><span class="jpstr">
<em>キーパス式</em>は、ある型のプロパティまたは添え字を参照します。あなたはキーパス式を動的なプログラミング作業、例えばキー値監視などにおいて使用します。これらは以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>\<span class="gi">type name</span>.<span class="gi">path</span>
</li></ol></div></div></div>
<p>The <em>type name</em> is the name of a concrete type, including any generic parameters, such as <code class="docutils literal notranslate"><span class="pre">String</span></code>, <code class="docutils literal notranslate"><span class="pre">[Int]</span></code>, or <code class="docutils literal notranslate"><span class="pre">Set&lt;Int&gt;</span></code>.<br><span class="jpstr">
<em>type name</em>は、ある具象型の名前で、何らかの総称体パラメータを含みます、例えば<code class="docutils literal notranslate"><span class="pre">String</span></code>、<code class="docutils literal notranslate"><span class="pre">[Int]</span></code>、または<code class="docutils literal notranslate"><span class="pre">Set&lt;Int&gt;</span></code>など。
</span><!--end_jpstr-->
</p>
<p>The <em>path</em> consists of property names, subscripts, optional chaining expressions, and forced unwrapping expressions. Each of these key-path components can be repeated as many times as needed, in any order.<br><span class="jpstr">
<em>path</em>は、プロパティ名、添え字、オプショナル連鎖式、そして強制アンラップ式からなります。これらキーパス構成要素のそれぞれは、必要なだけ、任意の順序で、何度も繰り返されることができます。
</span><!--end_jpstr-->
</p>
<p>At compile time, a key-path expression is replaced by an instance of the <a class="reference external" href="https://developer.apple.com/documentation/swift/keypath"><code class="docutils literal notranslate"><span class="pre">KeyPath</span></code></a> class.<br><span class="jpstr">
コンパイル時に、キーパス式は<a class="reference external" href="../../../developer.apple.com/documentation/swift/keypath.html"><code class="docutils literal notranslate"><span class="pre">KeyPath</span></code></a>クラスのインスタンスによって置き換えられます。
</span><!--end_jpstr-->
</p>
<p>To access a value using a key path, pass the key path to the <code class="docutils literal notranslate"><span class="pre">subscript(keyPath:)</span></code> subscript, which is available on all types. For example:<br><span class="jpstr">
キーパスを使ってある値にアクセスするには、そのキーパスを<code class="docutils literal notranslate"><span class="pre">subscript(keyPath:)</span></code>添え字に渡してください、それは全ての型で利用可能です。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">SomeStructure</span> {
</li><li>    <span class="k">var</span> <span class="nv">someValue</span>: <span class="nc">Int</span>
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">s</span> = <span class="nv">SomeStructure</span>(<span class="nv">someValue</span>: <span class="m">12</span>)
</li><li><span class="k">let</span> <span class="nv">pathToProperty</span> = \<span class="nv">SomeStructure</span>.<span class="nv">someValue</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">value</span> = <span class="nv">s</span>[<span class="nv">keyPath</span>: <span class="nv">pathToProperty</span>]
</li><li><span class="c">// value is 12&nbsp;<span class="jpstr">（valueは12です）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>The <em>type name</em> can be omitted in contexts where type inference can determine the implied type. The following code uses <code class="docutils literal notranslate"><span class="pre">\.someProperty</span></code> instead of <code class="docutils literal notranslate"><span class="pre">\SomeClass.someProperty</span></code>:<br><span class="jpstr">
<em>type name</em>は、型推論が暗黙の型を判定できるところの文脈では省略できます。以下のコードは、<code class="docutils literal notranslate"><span class="pre">\.someProperty</span></code>を<code class="docutils literal notranslate"><span class="pre">\SomeClass.someProperty</span></code>の代わりに使います：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeClass</span>: <span class="nc">NSObject</span> {
</li><li>    <span class="k">@objc</span> <span class="k">var</span> <span class="nv">someProperty</span>: <span class="nc">Int</span>
</li><li>    <span class="k">init</span>(<span class="nv">someProperty</span>: <span class="nc">Int</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">someProperty</span> = <span class="nv">someProperty</span>
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">c</span> = <span class="nv">SomeClass</span>(<span class="nv">someProperty</span>: <span class="m">10</span>)
</li><li><span class="nv">c</span>.<span class="nv">observe</span>(\.<span class="nv">someProperty</span>) { <span class="nv">object</span>, <span class="nv">change</span> <span class="k">in</span>
</li><li>    <span class="c">// ...</span>
</li><li>}
</li></ol></div></div></div>
<p>The <em>path</em> can contain multiple property names, separated by periods, to refer to a property of a property’s value. This code uses the key path expression <code class="docutils literal notranslate"><span class="pre">\OuterStructure.outer.someValue</span></code> to access the <code class="docutils literal notranslate"><span class="pre">someValue</span></code> property of the <code class="docutils literal notranslate"><span class="pre">OuterStructure</span></code> type’s <code class="docutils literal notranslate"><span class="pre">outer</span></code> property:<br><span class="jpstr">
<em>path</em>は、ピリオドで区切った複数のプロパティ名を含むことで、あるプロパティの持つ値に属するプロパティを参照できます。このコードは、キーパス式<code class="docutils literal notranslate"><span class="pre">\OuterStructure.outer.someValue</span></code>を使って、<code class="docutils literal notranslate"><span class="pre">someValue</span></code>プロパティにアクセスします、そのプロパティは<code class="docutils literal notranslate"><span class="pre">OuterStructure</span></code>型の持つ<code class="docutils literal notranslate"><span class="pre">outer</span></code>プロパティに属しています：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">OuterStructure</span> {
</li><li>    <span class="k">var</span> <span class="nv">outer</span>: <span class="nc">SomeStructure</span>
</li><li>    <span class="k">init</span>(<span class="nv">someValue</span>: <span class="nc">Int</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">outer</span> = <span class="nv">SomeStructure</span>(<span class="nv">someValue</span>: <span class="nv">someValue</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">nested</span> = <span class="nv">OuterStructure</span>(<span class="nv">someValue</span>: <span class="m">24</span>)
</li><li><span class="k">let</span> <span class="nv">nestedKeyPath</span> = \<span class="nv">OuterStructure</span>.<span class="nv">outer</span>.<span class="nv">someValue</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">nestedValue</span> = <span class="nv">nested</span>[<span class="nv">keyPath</span>: <span class="nv">nestedKeyPath</span>]
</li><li><span class="c">// nestedValue is 24</span>
</li></ol></div></div></div>
<p>The <em>path</em> can include subscripts using brackets, as long as the subscript’s parameter type conforms to the <code class="docutils literal notranslate"><span class="pre">Hashable</span></code> protocol. This example uses a subscript in a key path to access the second element of an array:<br><span class="jpstr">
<em>path</em>は角括弧を使う添え字を含むことができます、その添え字の持つパラメータ型が<code class="docutils literal notranslate"><span class="pre">Hashable</span></code>プロトコルに準拠する限りは。この例は、キーパス式において添え字を使って、配列の２番目の要素にアクセスします。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">greetings</span> = [<span class="s">&quot;hello&quot;</span>, <span class="s">&quot;hola&quot;</span>, <span class="s">&quot;bonjour&quot;</span>, <span class="s">&quot;안녕&quot;</span>]
</li><li><span class="k">let</span> <span class="nv">myGreeting</span> = <span class="nv">greetings</span>[<span class="nv">keyPath</span>: \[<span class="nv">String</span>].[<span class="m">1</span>]]
</li><li><span class="c">// myGreeting is &#39;hola&#39;</span>
</li></ol></div></div></div>
<p>The value used in a subscript can be a named value or a literal. Values are captured in key paths using value semantics. The following code uses the variable <code class="docutils literal notranslate"><span class="pre">index</span></code> in both a key-path expression and in a closure to access the third element of the <code class="docutils literal notranslate"><span class="pre">greetings</span></code> array. When <code class="docutils literal notranslate"><span class="pre">index</span></code> is modified, the key-path expression still references the third element, while the closure uses the new index.<br><span class="jpstr">
添え字の中で使われる値は、名前付きの値またはあるリテラルであることが可能です。様々な値は、キーパスの中に値意味論を使ってキャプチャされます。以下のコードは、変数<code class="docutils literal notranslate"><span class="pre">index</span></code>をキーパス式の中でそしてクロージャの中での両方で使うことで、<code class="docutils literal notranslate"><span class="pre">greetings</span></code>配列の３番目の要素にアクセスします：<code class="docutils literal notranslate"><span class="pre">index</span></code>が修正される時、キーパス式は依然として３番目の要素に参照を付けます、一方でクロージャは新しいインデックスを使用します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">index</span> = <span class="m">2</span>
</li><li><span class="k">let</span> <span class="nv">path</span> = \[<span class="nv">String</span>].[<span class="nv">index</span>]
</li><li><span class="k">let</span> <span class="nv">fn</span>: ([<span class="nc">String</span>]) -&gt; <span class="nc">String</span> = { <span class="nv">strings</span> <span class="k">in</span> <span class="nv">strings</span>[<span class="nv">index</span>] }
</li><li>
</li><li><span class="nv">print</span>(<span class="nv">greetings</span>[<span class="nv">keyPath</span>: <span class="nv">path</span>])
</li><li><span class="c">// Prints &quot;bonjour&quot;</span>
</li><li><span class="nv">print</span>(<span class="nv">fn</span>(<span class="nv">greetings</span>))
</li><li><span class="c">// Prints &quot;bonjour&quot;</span>
</li><li>
</li><li><span class="c">// Setting &#39;index&#39; to a new value doesn&#39;t affect &#39;path&#39;&nbsp;<span class="jpstr">（'index'を新しい値に設定することは、'path'に影響を与えない）</span><!--end_jpstr-->
</span>
</li><li><span class="nv">index</span> += <span class="m">1</span>
</li><li><span class="nv">print</span>(<span class="nv">greetings</span>[<span class="nv">keyPath</span>: <span class="nv">path</span>])
</li><li><span class="c">// Prints &quot;bonjour&quot;</span>
</li><li>
</li><li><span class="c">// Because &#39;fn&#39; closes over &#39;index&#39;, it uses the new value&nbsp;<span class="jpstr">（'fn'が'index'をしっかり掴むので、それは新しい値を使います）</span><!--end_jpstr-->
</span>
</li><li><span class="nv">print</span>(<span class="nv">fn</span>(<span class="nv">greetings</span>))
</li><li><span class="c">// Prints &quot;안녕&quot;</span>
</li></ol></div></div></div>
<p>The <em>path</em> can use optional chaining and forced unwrapping. This code uses optional chaining in a key path to access a property of an optional string:<br><span class="jpstr">
<em>path</em>は、オプショナル連鎖と強制アンラップを使うことができます。このコードは、オプショナル連鎖をキーパスの中で使うことで、あるオプショナル文字列に属するプロパティにアクセスします：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">firstGreeting</span>: <span class="nc">String</span>? = <span class="nv">greetings</span>.<span class="nv">first</span>
</li><li><span class="nv">print</span>(<span class="nv">firstGreeting</span>?.<span class="nv">count</span> <span class="k">as</span> <span class="k">Any</span>)
</li><li><span class="c">// Prints &quot;Optional(5)&quot;</span>
</li><li>
</li><li><span class="c">// Do the same thing using a key path.&nbsp;<span class="jpstr">（同じことをキーパスを使って行う。）</span><!--end_jpstr-->
</span>
</li><li><span class="k">let</span> <span class="nv">count</span> = <span class="nv">greetings</span>[<span class="nv">keyPath</span>: \[<span class="nv">String</span>].<span class="nv">first</span>?.<span class="nv">count</span>]
</li><li><span class="nv">print</span>(<span class="nv">count</span> <span class="k">as</span> <span class="k">Any</span>)
</li><li><span class="c">// Prints &quot;Optional(5)&quot;</span>
</li></ol></div></div></div>
<p>You can mix and match components of key paths to access values that are deeply nested within a type. The following code accesses different values and properties of a dictionary of arrays by using key-path expressions that combine these components.<br><span class="jpstr">
あなたは、キーパスの構成要素をうまく組み合わせることで、ある型の内部に深く入れ子にされた値にアクセスできます。以下のコードは、いくつかの配列からなる辞書に属する異なる値およびプロパティに、それらの構成要素を組み合わせるキーパス式を使うことでアクセスします。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">interestingNumbers</span> = [<span class="s">&quot;prime&quot;</span>: [<span class="m">2</span>, <span class="m">3</span>, <span class="m">5</span>, <span class="m">7</span>, <span class="m">11</span>, <span class="m">13</span>, <span class="m">17</span>],
</li><li>                          <span class="s">&quot;triangular&quot;</span>: [<span class="m">1</span>, <span class="m">3</span>, <span class="m">6</span>, <span class="m">10</span>, <span class="m">15</span>, <span class="m">21</span>, <span class="m">28</span>],
</li><li>                          <span class="s">&quot;hexagonal&quot;</span>: [<span class="m">1</span>, <span class="m">6</span>, <span class="m">15</span>, <span class="m">28</span>, <span class="m">45</span>, <span class="m">66</span>, <span class="m">91</span>]]
</li><li><span class="nv">print</span>(<span class="nv">interestingNumbers</span>[<span class="nv">keyPath</span>: \[<span class="nv">String</span>: [<span class="nv">Int</span>]].[<span class="s">&quot;prime&quot;</span>]] <span class="k">as</span> <span class="k">Any</span>)
</li><li><span class="c">// Prints &quot;Optional([2, 3, 5, 7, 11, 13, 17])&quot;</span>
</li><li><span class="nv">print</span>(<span class="nv">interestingNumbers</span>[<span class="nv">keyPath</span>: \[<span class="nv">String</span>: [<span class="nv">Int</span>]].[<span class="s">&quot;prime&quot;</span>]![<span class="m">0</span>]])
</li><li><span class="c">// Prints &quot;2&quot;&nbsp;<span class="jpstr">（「2」を出力します）</span><!--end_jpstr-->
</span>
</li><li><span class="nv">print</span>(<span class="nv">interestingNumbers</span>[<span class="nv">keyPath</span>: \[<span class="nv">String</span>: [<span class="nv">Int</span>]].[<span class="s">&quot;hexagonal&quot;</span>]!.<span class="nv">count</span>])
</li><li><span class="c">// Prints &quot;7&quot;&nbsp;<span class="jpstr">（「７」を出力します）</span><!--end_jpstr-->
</span>
</li><li><span class="nv">print</span>(<span class="nv">interestingNumbers</span>[<span class="nv">keyPath</span>: \[<span class="nv">String</span>: [<span class="nv">Int</span>]].[<span class="s">&quot;hexagonal&quot;</span>]!.<span class="nv">count</span>.<span class="nv">bitWidth</span>])
</li><li><span class="c">// Prints &quot;64&quot;&nbsp;<span class="jpstr">（「64」を出力します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>For more information about using key paths in code that interacts with Objective-C APIs, see <a class="reference external" href="https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift">Using Objective-C Runtime Features in Swift</a>. For information about key-value coding and key-value observing, see <a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i">Key-Value Coding Programming Guide</a> and <a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i">Key-Value Observing Programming Guide</a>.<br><span class="jpstr">
Objective-C APIと相互作用するコードにおけるキーパスの使用についてのさらなる情報として、<a class="reference external" href="../../../developer.apple.com/documentation/swift/using_objective-c_runtime_features_in_swift.html">Objective-Cランタイム機能をSwiftで使用する</a>を見てください。キー値コーディングとキー値監視についての情報として、<a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i">キー値コーディングプログラミングガイド</a>（日本語文書有り）と<a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i">キー値監視プログラミングガイド</a>（日本語文書有り）を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a key-path expression<br><span class="jpstr">
キーパス式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_key-path-expression"></a>key-path-expression</span><span class="arrow"> → </span> <code>\</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> <sub>opt</sub> <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-components">key-path-components</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_key-path-components"></a>key-path-components</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-component">key-path-component</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-component">key-path-component</a></span>  <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-components">key-path-components</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_key-path-component"></a>key-path-component</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-postfixes">key-path-postfixes</a></span> <sub>opt</sub> |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-postfixes">key-path-postfixes</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_key-path-postfixes"></a>key-path-postfixes</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-postfix">key-path-postfix</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-postfixes">key-path-postfixes</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_key-path-postfix"></a>key-path-postfix</span><span class="arrow"> → </span> <code>?</code> |  <code>!</code> |  <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-list">function-call-argument-list</a></span>  <code>]</code></p></div></div></div>
<div class="section" id="ID547">
<h3>Selector Expression<a class="headerlink" href="#ID547" title="Permalink to this headline">¶</a><br><span class="jpstr">
セレクタ式<a class="headerlink" href="#ID547" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A selector expression lets you access the selector used to refer to a method or to a property’s getter or setter in Objective-C. It has the following form:<br><span class="jpstr">
セレクタ式は、あなたに、Objective-Cにおけるあるメソッドをまたはあるプロパティの持つゲッターやセッターを参照するために使われるセレクタにアクセスをさせます。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">#selector</span>(<span class="gi">method name</span>)
</li><li><span class="k">#selector</span>(<span class="k">getter</span>: <span class="gi">property name</span>)
</li><li><span class="k">#selector</span>(<span class="k">setter</span>: <span class="gi">property name</span>)
</li></ol></div></div></div>
<p>The <em>method name</em> and <em>property name</em> must be a reference to a method or a property that is available in the Objective-C runtime. The value of a selector expression is an instance of the <code class="docutils literal notranslate"><span class="pre">Selector</span></code> type. For example:<br><span class="jpstr">
<em>method name</em>と<em>property name</em>は、あるメソッドおよびプロパティへの参照で、それはObjective-Cランタイムにおいて利用可能なものでなければなりません。セレクタ式の値は、<code class="docutils literal notranslate"><span class="pre">Selector</span></code>型のインスタンスです。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeClass</span>: <span class="nc">NSObject</span> {
</li><li>    <span class="k">@objc</span> <span class="k">let</span> <span class="nv">property</span>: <span class="nc">String</span>
</li><li>    <span class="k">@objc(doSomethingWithInt:)</span>
</li><li>    <span class="k">func</span> <span class="nv">doSomething</span>(<span class="k">_</span> <span class="nv">x</span>: <span class="nc">Int</span>) {}
</li><li>
</li><li>    <span class="k">init</span>(<span class="nv">property</span>: <span class="nc">String</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">property</span> = <span class="nv">property</span>
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">selectorForMethod</span> = <span class="k">#selector</span>(<span class="nv">SomeClass</span>.<span class="nv">doSomething</span>(<span class="k">_</span>:))
</li><li><span class="k">let</span> <span class="nv">selectorForPropertyGetter</span> = <span class="k">#selector</span>(<span class="k">getter</span>: <span class="nv">SomeClass</span>.<span class="nv">property</span>)
</li></ol></div></div></div>
<p>When creating a selector for a property’s getter, the <em>property name</em> can be a reference to a variable or constant property. In contrast, when creating a selector for a property’s setter, the <em>property name</em> must be a reference to a variable property only.<br><span class="jpstr">
プロパティのゲッターのためのセレクタを作成するとき、<em>property name</em>は変数または定数プロパティへの参照であることができます。対照的に、プロパティのセッターのためのセレクタを作成するとき、<em>property name</em>は必ず変数プロパティへの参照でなければなりません。
</span><!--end_jpstr-->
</p>
<p>The <em>method name</em> can contain parentheses for grouping, as well the <code class="docutils literal notranslate"><span class="pre">as</span></code> operator to disambiguate between methods that share a name but have different type signatures. For example:<br><span class="jpstr">
<em>method name</em>は、グループにまとめるための丸括弧、その上に、名前を共有するが異なる型シグネチャを持つメソッド間の違いを明確にするために<code class="docutils literal notranslate"><span class="pre">as</span></code>演算子を含むことができます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">SomeClass</span> {
</li><li>    <span class="k">@objc(doSomethingWithString:)</span>
</li><li>    <span class="k">func</span> <span class="nv">doSomething</span>(<span class="k">_</span> <span class="nv">x</span>: <span class="nc">String</span>) { }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">anotherSelector</span> = <span class="k">#selector</span>(<span class="nv">SomeClass</span>.<span class="nv">doSomething</span>(<span class="k">_</span>:) <span class="k">as</span> (<span class="nc">SomeClass</span>) -&gt; (<span class="nc">String</span>) -&gt; <span class="nc">Void</span>)
</li></ol></div></div></div>
<p>Because a selector is created at compile time, not at runtime, the compiler can check that a method or property exists and that they’re exposed to the Objective-C runtime.<br><span class="jpstr">
あるセレクタが作成されるのはコンパイル時であり、実行時でないので、コンパイラはそのメソッドまたはプロパティが存在すること、そしてそれらがObjective-Cランタイムに露出されていることを確かめることができます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">Although the <em>method name</em> and the <em>property name</em> are expressions, they’re never evaluated.<br><span class="jpstr">
<em>method name（メソッド名）</em>と<em>property name（プロパティ名）</em>は式であるけれども、それらは決して評価されません。
</span><!--end_jpstr-->
</p>
</div>
<p>For more information about using selectors in Swift code that interacts with Objective-C APIs, see <a class="reference external" href="https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift">Using Objective-C Runtime Features in Swift</a>.<br><span class="jpstr">
Objective-C APIと相互作用するSwiftコードにおけるセレクタの使用についてのさらなる情報として、<a class="reference external" href="../../../developer.apple.com/documentation/swift/using_objective-c_runtime_features_in_swift.html">Objective-Cランタイム機能をSwiftで使用する</a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a selector expression<br><span class="jpstr">
セレクタ式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_selector-expression"></a>selector-expression</span><span class="arrow"> → </span> <code>#selector</code> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_selector-expression_1082"></a>selector-expression</span><span class="arrow"> → </span> <code>#selector</code> <code>(</code> <code>getter:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_selector-expression_1083"></a>selector-expression</span><span class="arrow"> → </span> <code>#selector</code> <code>(</code> <code>setter:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p></div></div></div>
<div class="section" id="ID549">
<h3>Key-Path String Expression<a class="headerlink" href="#ID549" title="Permalink to this headline">¶</a><br><span class="jpstr">
キーパス文字列式<a class="headerlink" href="#ID549" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A key-path string expression lets you access the string used to refer to a property in Objective-C, for use in key-value coding and key-value observing APIs. It has the following form:<br><span class="jpstr">
キーパス文字列式は、あなたにObjective-Cでのプロパティを参照するために使われる文字列にアクセスさせます、キー値コーディングとキー値監視APIで使用するために。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">#keyPath</span>(<span class="gi">property name</span>)
</li></ol></div></div></div>
<p>The <em>property name</em> must be a reference to a property that is available in the Objective-C runtime. At compile time, the key-path string expression is replaced by a string literal. For example:<br><span class="jpstr">
<em>property name</em>は、Objective-Cランタイムにおいて利用可能であるプロパティへの参照でなければなりません。コンパイル時で、キーパス文字列式は文字列リテラルによって置き換えられます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeClass</span>: <span class="nc">NSObject</span> {
</li><li>    <span class="k">@objc</span> <span class="k">var</span> <span class="nv">someProperty</span>: <span class="nc">Int</span>
</li><li>    <span class="k">init</span>(<span class="nv">someProperty</span>: <span class="nc">Int</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">someProperty</span> = <span class="nv">someProperty</span>
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">c</span> = <span class="nv">SomeClass</span>(<span class="nv">someProperty</span>: <span class="m">12</span>)
</li><li><span class="k">let</span> <span class="nv">keyPath</span> = <span class="k">#keyPath</span>(<span class="nv">SomeClass</span>.<span class="nv">someProperty</span>)
</li><li>
</li><li><span class="k">if</span> <span class="k">let</span> <span class="nv">value</span> = <span class="nv">c</span>.<span class="nv">value</span>(<span class="nv">forKey</span>: <span class="nv">keyPath</span>) {
</li><li>    <span class="nv">print</span>(<span class="nv">value</span>)
</li><li>}
</li><li><span class="c">// Prints &quot;12&quot;</span>
</li></ol></div></div></div>
<p>When you use a key-path string expression within a class, you can refer to a property of that class by writing just the property name, without the class name.<br><span class="jpstr">
あなたがキーパス文字列式をあるクラス内で使う時、あなたはそのクラスのプロパティを参照することが、クラス名なしで単にそのプロパティ名を書くことによって可能です。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">SomeClass</span> {
</li><li>    <span class="k">func</span> <span class="nv">getSomeKeyPath</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="k">#keyPath</span>(<span class="nv">someProperty</span>)
</li><li>    }
</li><li>}
</li><li><span class="nv">print</span>(<span class="nv">keyPath</span> == <span class="nv">c</span>.<span class="nv">getSomeKeyPath</span>())
</li><li><span class="c">// Prints &quot;true&quot;&nbsp;<span class="jpstr">（「true」を出力します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>Because the key path string is created at compile time, not at runtime, the compiler can check that the property exists and that the property is exposed to the Objective-C runtime.<br><span class="jpstr">
キーパス文字列は実行時ではなく、コンパイル時に作成されるため、コンパイラはプロパティが存在することおよびプロパティがObjective-Cランタイムへと露出されることを確認できます。
</span><!--end_jpstr-->
</p>
<p>For more information about using key paths in Swift code that interacts with Objective-C APIs, see <a class="reference external" href="https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift">Using Objective-C Runtime Features in Swift</a>. For information about key-value coding and key-value observing, see <a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i">Key-Value Coding Programming Guide</a> and <a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i">Key-Value Observing Programming Guide</a>.<br><span class="jpstr">
Objective-C APIと相互作用するSwiftコードにおけるキーパスの使用についてのさらなる情報として、<a class="reference external" href="../../../developer.apple.com/documentation/swift/using_objective-c_runtime_features_in_swift.html">Objective-Cランタイム機能をSwiftで使用する</a>を見てください。キー値コーディングとキー値監視についての情報として、<a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i">キー値コーディングプログラミングガイド</a>（日本語文書有り）と<a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i">キー値監視プログラミングガイド</a>（日本語文書有り）を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">Although the <em>property name</em> is an expression, it is never evaluated.<br><span class="jpstr">
<em>property name（プロパティ名）</em>は式であるけれども、それは決して評価されません。
</span><!--end_jpstr-->
</p>
</div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a key-path string expression<br><span class="jpstr">
キーパス文字列式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_key-path-string-expression"></a>key-path-string-expression</span><span class="arrow"> → </span> <code>#keyPath</code> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p></div></div></div>
</div>
<div class="section" id="ID397">
<h2>Postfix Expressions<a class="headerlink" href="#ID397" title="Permalink to this headline">¶</a><br><span class="jpstr">
接尾辞表現<a class="headerlink" href="#ID397" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><em>Postfix expressions</em> are formed by applying a postfix operator or other postfix syntax to an expression. Syntactically, every primary expression is also a postfix expression.<br><span class="jpstr">
<em>接尾辞式</em>は、接尾辞演算子または他の接尾辞構文を式に適用することによって作り上げられます。統語論的に、あらゆる基本式は、また、接尾辞式です。
</span><!--end_jpstr-->
</p>
<p>For information about the behavior of these operators, see <a class="reference internal" href="../LanguageGuide/BasicOperators.html"><span class="doc">Basic Operators</span></a> and <a class="reference internal" href="../LanguageGuide/AdvancedOperators.html"><span class="doc">Advanced Operators</span></a>.<br><span class="jpstr">
これらの演算子の挙動に関して詳しくは、<a class="reference internal" href="../LanguageGuide/BasicOperators.html"><span class="doc">基本の演算子</span></a>と<a class="reference internal" href="../LanguageGuide/AdvancedOperators.html"><span class="doc">先進の演算子</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>For information about the operators provided by the Swift standard library, see <a class="reference external" href="https://developer.apple.com/documentation/swift/operator_declarations">Operator Declarations</a>.<br><span class="jpstr">
スウィフト標準ライブラリによって提供される演算子についての情報のために、<a class="reference external" href="../../../developer.apple.com/documentation/swift/swift_standard_library/operator_declarations.html">さまざまな演算子宣言</a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a postfix expression<br><span class="jpstr">
接尾辞式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_primary-expression">primary-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1084"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_postfix-operator">postfix-operator</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1085"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-expression">function-call-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1086"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_initializer-expression">initializer-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1087"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_explicit-member-expression">explicit-member-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1088"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-self-expression">postfix-self-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1089"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_subscript-expression">subscript-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1090"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_forced-value-expression">forced-value-expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1091"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_optional-chaining-expression">optional-chaining-expression</a></span> </p></div></div><div class="section" id="ID398">
<h3>Function Call Expression<a class="headerlink" href="#ID398" title="Permalink to this headline">¶</a><br><span class="jpstr">
関数呼び出し式<a class="headerlink" href="#ID398" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A <em>function call expression</em> consists of a function name followed by a comma-separated list of the function’s arguments in parentheses. Function call expressions have the following form:<br><span class="jpstr">
<em>関数呼び出し式</em>は、関数名の後にその関数の引数のコンマ区切りのリストを丸括弧の中に続けることから成ります。関数呼び出し式は、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">function name</span>(<span class="gi">argument value 1</span>, <span class="gi">argument value 2</span>)
</li></ol></div></div></div>
<p>The <em>function name</em> can be any expression whose value is of a function type.<br><span class="jpstr">
<em>関数名</em>は、値がその関数型であるどんな式でもかまいません
</span><!--end_jpstr-->
</p>
<p>If the function definition includes names for its parameters, the function call must include names before its argument values separated by a colon (<code class="docutils literal notranslate"><span class="pre">:</span></code>). This kind of function call expression has the following form:<br><span class="jpstr">
関数定義がそれのパラメータたちの名前を含むならば、関数呼び出しはそれらの引数値の前にその名前をコロン（<code class="docutils literal notranslate"><span class="pre">:</span></code>）で区切って含まなければなりません。この種類の関数呼び出し式は、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">function name</span>(<span class="gi">argument name 1</span>: <span class="gi">argument value 1</span>, <span class="gi">argument name 2</span>: <span class="gi">argument value 2</span>)
</li></ol></div></div></div>
<p>A function call expression can include a trailing closure in the form of a closure expression immediately after the closing parenthesis. The trailing closure is understood as an argument to the function, added after the last parenthesized argument. The following function calls are equivalent:<br><span class="jpstr">
関数呼び出し式は、終わりの括弧の直後にクロージャ式の形で後付クロージャを含むことができます。後付クロージャは関数に対する引数として理解されます、そして、最後に括弧に入れた引数の後に加えられます。以下の関数呼び出しは、等しいです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// someFunction takes an integer and a closure as its arguments&nbsp;<span class="jpstr">（someFunctionは、その引数として整数とクロージャをとります）</span><!--end_jpstr-->
</span>
</li><li><span class="nv">someFunction</span>(<span class="nv">x</span>: <span class="nv">x</span>, <span class="nv">f</span>: {<span class="nv">$0</span> == <span class="m">13</span>})
</li><li><span class="nv">someFunction</span>(<span class="nv">x</span>: <span class="nv">x</span>) {<span class="nv">$0</span> == <span class="m">13</span>}
</li></ol></div></div></div>
<p>If the trailing closure is the function’s only argument, the parentheses can be omitted.<br><span class="jpstr">
後付クロージャが関数のただ一つの引数であるならば、括弧は省略されることができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// someMethod takes a closure as its only argument&nbsp;<span class="jpstr">（someMethodは、そのただ一つの引数としてクロージャをとります）</span><!--end_jpstr-->
</span>
</li><li><span class="nv">myData</span>.<span class="nv">someMethod</span>() {<span class="nv">$0</span> == <span class="m">13</span>}
</li><li><span class="nv">myData</span>.<span class="nv">someMethod</span> {<span class="nv">$0</span> == <span class="m">13</span>}
</li></ol></div></div></div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a function call expression<br><span class="jpstr">
関数呼び出し式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-call-expression"></a>function-call-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-clause">function-call-argument-clause</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-call-expression_1092"></a>function-call-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-clause">function-call-argument-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_trailing-closure">trailing-closure</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-call-argument-clause"></a>function-call-argument-clause</span><span class="arrow"> → </span> <code>(</code> <code>)</code> |  <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-list">function-call-argument-list</a></span>  <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-call-argument-list"></a>function-call-argument-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument">function-call-argument</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument">function-call-argument</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-list">function-call-argument-list</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-call-argument"></a>function-call-argument</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-call-argument_1093"></a>function-call-argument</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_operator">operator</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_operator">operator</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_trailing-closure"></a>trailing-closure</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-expression">closure-expression</a></span> </p></div></div></div>
<div class="section" id="ID399">
<h3>Initializer Expression<a class="headerlink" href="#ID399" title="Permalink to this headline">¶</a><br><span class="jpstr">
イニシャライザ式<a class="headerlink" href="#ID399" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>An <em>initializer expression</em> provides access to a type’s initializer. It has the following form:<br><span class="jpstr">
あなたはまた、スーパークラスのイニシャライザに委任するために、<em>イニシャライザ式</em>を使います。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">expression</span>.<span class="nv">init</span>(<span class="gi">initializer arguments</span>)
</li></ol></div></div></div>
<p>You use the initializer expression in a function call expression to initialize a new instance of a type. You also use an initializer expression to delegate to the initializer of a superclass.<br><span class="jpstr">
あなたは、イニシャライザ式を関数呼び出し式において使うことで、ある型の新しいインスタンスを初期化します。あなたはまた、スーパークラスのイニシャライザに委任するために、イニシャライザ式を使います。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeSubClass</span>: <span class="nc">SomeSuperClass</span> {
</li><li>    <span class="k">override</span> <span class="k">init</span>() {
</li><li>        <span class="c">// subclass initialization goes here&nbsp;<span class="jpstr">（サブクラスの初期化が、ここにきます）</span><!--end_jpstr-->
</span>
</li><li>        <span class="k">super</span>.<span class="nv">init</span>()
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>Like a function, an initializer can be used as a value. For example:<br><span class="jpstr">
関数のように、イニシャライザは値として使われることができます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c">// Type annotation is required because String has multiple initializers.&nbsp;<span class="jpstr">（型注釈は必須です、なぜならStringは複数のイニシャライザを持つからです）</span><!--end_jpstr-->
</span>
</li><li><span class="k">let</span> <span class="nv">initializer</span>: (<span class="nc">Int</span>) -&gt; <span class="nc">String</span> = <span class="nv">String</span>.<span class="nv">init</span>
</li><li><span class="k">let</span> <span class="nv">oneTwoThree</span> = [<span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>].<span class="nv">map</span>(<span class="nv">initializer</span>).<span class="nv">reduce</span>(<span class="s">&quot;&quot;</span>, +)
</li><li><span class="nv">print</span>(<span class="nv">oneTwoThree</span>)
</li><li><span class="c">// Prints &quot;123&quot;</span>
</li></ol></div></div></div>
<p>If you specify a type by name, you can access the type’s initializer without using an initializer expression. In all other cases, you must use an initializer expression.<br><span class="jpstr">
あなたがある型を名前で指定するならば、あなたはその型のイニシャライザにイニシャライザ式を使うことなくアクセスすることができます。すべての他の場合では、あなたはイニシャライザ式を使う必要があります。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">s1</span> = <span class="nv">SomeType</span>.<span class="nv">init</span>(<span class="nv">data</span>: <span class="m">3</span>)  <span class="c">// Valid</span>
</li><li><span class="k">let</span> <span class="nv">s2</span> = <span class="nv">SomeType</span>(<span class="nv">data</span>: <span class="m">1</span>)       <span class="c">// Also valid</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">s3</span> = <span class="nv">type</span>(<span class="nv">of</span>: <span class="nv">someValue</span>).<span class="nv">init</span>(<span class="nv">data</span>: <span class="m">7</span>)  <span class="c">// Valid</span>
</li><li><span class="k">let</span> <span class="nv">s4</span> = <span class="nv">type</span>(<span class="nv">of</span>: <span class="nv">someValue</span>)(<span class="nv">data</span>: <span class="m">5</span>)       <span class="c">// Error</span>
</li></ol></div></div></div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of an initializer expression<br><span class="jpstr">
イニシャライザ式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_initializer-expression"></a>initializer-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>.</code> <code>init</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_initializer-expression_1094"></a>initializer-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>.</code> <code>init</code> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_argument-names">argument-names</a></span>  <code>)</code></p></div></div></div>
<div class="section" id="ID400">
<h3>Explicit Member Expression<a class="headerlink" href="#ID400" title="Permalink to this headline">¶</a><br><span class="jpstr">
明示的メンバー式<a class="headerlink" href="#ID400" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>An <em>explicit member expression</em> allows access to the members of a named type, a tuple, or a module. It consists of a period (<code class="docutils literal notranslate"><span class="pre">.</span></code>) between the item and the identifier of its member.<br><span class="jpstr">
<em>明示的メンバー式</em>は、名前付きの型、タプル、またはモジュールのメンバーに対するアクセスを可能にします。それは、その項目とそれのメンバーの識別子の間のピリオド（<code class="docutils literal notranslate"><span class="pre">.</span></code>）から成ります。
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">expression</span>.<span class="gi">member name</span>
</li></ol></div></div></div>
<p>The members of a named type are named as part of the type’s declaration or extension. For example:<br><span class="jpstr">
名前付きの型に属するメンバーは、型の宣言または拡張の一部として命名されます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li><li>    <span class="k">var</span> <span class="nv">someProperty</span> = <span class="m">42</span>
</li><li>}
</li><li><span class="k">let</span> <span class="nv">c</span> = <span class="nv">SomeClass</span>()
</li><li><span class="k">let</span> <span class="nv">y</span> = <span class="nv">c</span>.<span class="nv">someProperty</span>  <span class="c">// Member access</span>
</li></ol></div></div></div>
<p>The members of a tuple are implicitly named using integers in the order they appear, starting from zero. For example:<br><span class="jpstr">
タプルのメンバーは、整数を使って、それらが現れる順序で、ゼロから始めて、暗黙のうちに名前をつけられます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">t</span> = (<span class="m">10</span>, <span class="m">20</span>, <span class="m">30</span>)
</li><li><span class="nv">t</span>.<span class="m">0</span> = <span class="nv">t</span>.<span class="m">1</span>
</li><li><span class="c">// Now t is (20, 20, 30)&nbsp;<span class="jpstr">（tは、現在 (20, 20, 30)です）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>The members of a module access the top-level declarations of that module.<br><span class="jpstr">
モジュールのメンバーは、そのモジュールのトップレベルの宣言にアクセスします。
</span><!--end_jpstr-->
</p>
<p>Types declared with the <code class="docutils literal notranslate"><span class="pre">dynamicMemberLookup</span></code> attribute include members that are looked up at runtime, as described in <a class="reference internal" href="Attributes.html"><span class="doc">Attributes</span></a>.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">dynamicMemberLookup</span></code>属性とともに宣言される型は、実行時に捜されるメンバーを含みます、<a class="reference internal" href="Attributes.html"><span class="doc">属性</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<p>To distinguish between methods or initializers whose names differ only by the names of their arguments, include the argument names in parentheses, with each argument name followed by a colon (<code class="docutils literal notranslate"><span class="pre">:</span></code>). Write an underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) for an argument with no name. To distinguish between overloaded methods, use a type annotation. For example:<br><span class="jpstr">
名前がそれらの引数の名前でだけ異なるものであるメソッド間またはイニシャライザ間で識別を行うために、丸括弧の中に引数名を、各引数名にコロン（<code class="docutils literal notranslate"><span class="pre">:</span></code>）を続けることで含めて下さい。名前のない引数に対しては１つのアンダースコア（<code class="docutils literal notranslate"><span class="pre">_</span></code>）を書いてください。オーバーロードされたメソッド間で識別を行うには、型注釈を使ってください。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li><li>    <span class="k">func</span> <span class="nv">someMethod</span>(<span class="nv">x</span>: <span class="nc">Int</span>, <span class="nv">y</span>: <span class="nc">Int</span>) {}
</li><li>    <span class="k">func</span> <span class="nv">someMethod</span>(<span class="nv">x</span>: <span class="nc">Int</span>, <span class="nv">z</span>: <span class="nc">Int</span>) {}
</li><li>    <span class="k">func</span> <span class="nv">overloadedMethod</span>(<span class="nv">x</span>: <span class="nc">Int</span>, <span class="nv">y</span>: <span class="nc">Int</span>) {}
</li><li>    <span class="k">func</span> <span class="nv">overloadedMethod</span>(<span class="nv">x</span>: <span class="nc">Int</span>, <span class="nv">y</span>: <span class="nc">Bool</span>) {}
</li><li>}
</li><li><span class="k">let</span> <span class="nv">instance</span> = <span class="nv">SomeClass</span>()
</li><li>
</li><li><span class="k">let</span> <span class="nv">a</span> = <span class="nv">instance</span>.<span class="nv">someMethod</span>              <span class="c">// Ambiguous&nbsp;<span class="jpstr"><span class="c">（あいまい）</span></span><!--end_jpstr--></span>
</li><li><span class="k">let</span> <span class="nv">b</span> = <span class="nv">instance</span>.<span class="nv">someMethod</span>(<span class="nv">x</span>:<span class="nv">y</span>:)        <span class="c">// Unambiguous&nbsp;<span class="jpstr"><span class="c">（あいまいさ無し）</span></span><!--end_jpstr--></span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">d</span> = <span class="nv">instance</span>.<span class="nv">overloadedMethod</span>        <span class="c">// Ambiguous&nbsp;<span class="jpstr"><span class="c">（あいまい）</span></span><!--end_jpstr--></span>
</li><li><span class="k">let</span> <span class="nv">d</span> = <span class="nv">instance</span>.<span class="nv">overloadedMethod</span>(<span class="nv">x</span>:<span class="nv">y</span>:)  <span class="c">// Still ambiguous&nbsp;<span class="jpstr"><span class="c">（依然あいまい）</span></span><!--end_jpstr--></span>
</li><li><span class="k">let</span> <span class="nv">d</span>: (<span class="nc">Int</span>, <span class="nc">Bool</span>) -&gt; <span class="nc">Void</span>  = <span class="nv">instance</span>.<span class="nv">overloadedMethod</span>(<span class="nv">x</span>:<span class="nv">y</span>:)  <span class="c">// Unambiguous</span>
</li></ol></div></div></div>
<p>If a period appears at the beginning of a line, it is understood as part of an explicit member expression, not as an implicit member expression. For example, the following listing shows chained method calls split over several lines:<br><span class="jpstr">
ピリオドがある行の初めに現れたならば、それはある明示的なメンバー式の一部として理解されます、ひとつの明示的なメンバー式としてではなく。例えば、以下のコード出力は、連結されたメソッド呼び出しがいくつかの行に分けられるのを示します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">x</span> = [<span class="m">10</span>, <span class="m">3</span>, <span class="m">20</span>, <span class="m">15</span>, <span class="m">4</span>]
</li><li>    .<span class="nv">sorted</span>()
</li><li>    .<span class="nv">filter</span> { <span class="nv">$0</span> &gt; <span class="m">5</span> }
</li><li>    .<span class="nv">map</span> { <span class="nv">$0</span> * <span class="m">100</span> }
</li></ol></div></div></div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of an explicit member expression<br><span class="jpstr">
明示的メンバー式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_explicit-member-expression"></a>explicit-member-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_decimal-digits">decimal-digits</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_explicit-member-expression_1095"></a>explicit-member-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-argument-clause">generic-argument-clause</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_explicit-member-expression_1096"></a>explicit-member-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_argument-names">argument-names</a></span>  <code>)</code></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_argument-names"></a>argument-names</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_argument-name">argument-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_argument-names">argument-names</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_argument-name"></a>argument-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <code>:</code></p></div></div></div>
<div class="section" id="ID401">
<h3>Postfix Self Expression<a class="headerlink" href="#ID401" title="Permalink to this headline">¶</a><br><span class="jpstr">
接尾辞self式<a class="headerlink" href="#ID401" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A postfix <code class="docutils literal notranslate"><span class="pre">self</span></code> expression consists of an expression or the name of a type, immediately followed by <code class="docutils literal notranslate"><span class="pre">.self</span></code>. It has the following forms:<br><span class="jpstr">
接尾辞<code class="docutils literal notranslate"><span class="pre">self</span></code>式は、ある式または型の名前と、それに直ちに続く<code class="docutils literal notranslate"><span class="pre">.self</span></code>から成ります。それは、以下の各形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">expression</span>.<span class="k">self</span>
</li><li><span class="gi">type</span>.<span class="k">self</span>
</li></ol></div></div></div>
<p>The first form evaluates to the value of the <em>expression</em>. For example, <code class="docutils literal notranslate"><span class="pre">x.self</span></code> evaluates to <code class="docutils literal notranslate"><span class="pre">x</span></code>.<br><span class="jpstr">
最初の形式は、<em>式</em>の値に評価されます。例えば、<code class="docutils literal notranslate"><span class="pre">x.self</span></code>は<code class="docutils literal notranslate"><span class="pre">x</span></code>に評価されます。
</span><!--end_jpstr-->
</p>
<p>The second form evaluates to the value of the <em>type</em>. Use this form to access a type as a value. For example, because <code class="docutils literal notranslate"><span class="pre">SomeClass.self</span></code> evaluates to the <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code> type itself, you can pass it to a function or method that accepts a type-level argument.<br><span class="jpstr">
第二の形式は、<em>型</em>の値に評価されます。値として型にアクセスするために、この形式を使ってください。例えば、<code class="docutils literal notranslate"><span class="pre">SomeClass.self</span></code>は<code class="docutils literal notranslate"><span class="pre">SomeClass</span></code>型それ自体に評価されるので、あなたはそれを型レベルの引数を受け入れる関数またはメソッドへ渡すことができます。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a self expression<br><span class="jpstr">
self式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-self-expression"></a>postfix-self-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>.</code> <code>self</code></p></div></div></div>
<div class="section" id="ID403">
<h3>Subscript Expression<a class="headerlink" href="#ID403" title="Permalink to this headline">¶</a><br><span class="jpstr">
添え字式<a class="headerlink" href="#ID403" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A <em>subscript expression</em> provides subscript access using the getter and setter of the corresponding subscript declaration. It has the following form:<br><span class="jpstr">
<em>添え字式</em>は、対応する添え字宣言のゲッターとセッターを使用して、添え字アクセスを提供します。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">expression</span>[<span class="gi">index expressions</span>]
</li></ol></div></div></div>
<p>To evaluate the value of a subscript expression, the subscript getter for the <em>expression</em>’s type is called with the <em>index expressions</em> passed as the subscript parameters. To set its value, the subscript setter is called in the same way.<br><span class="jpstr">
添え字式の値を評価するために、この<em>式</em>のもつ型のための添え字ゲッターが、添え字パラメータとして渡される<em>インデックス式</em>を使って呼び出されます。その値を設定するために、添え字セッターが同様に呼ばれます。
</span><!--end_jpstr-->
</p>
<p>For information about subscript declarations, see <a class="reference internal" href="Declarations.html#ID373"><span class="std std-ref">Protocol Subscript Declaration</span></a>.<br><span class="jpstr">
添え字宣言に関して詳しくは、<a class="reference internal" href="Declarations.html#ID373"><span class="std std-ref">プロトコル添え字宣言</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a subscript expression<br><span class="jpstr">
添え字式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_subscript-expression"></a>subscript-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-list">function-call-argument-list</a></span>  <code>]</code></p></div></div></div>
<div class="section" id="ID404">
<h3>Forced-Value Expression<a class="headerlink" href="#ID404" title="Permalink to this headline">¶</a><br><span class="jpstr">
強制された値式<a class="headerlink" href="#ID404" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A <em>forced-value expression</em> unwraps an optional value that you are certain is not <code class="docutils literal notranslate"><span class="pre">nil</span></code>. It has the following form:<br><span class="jpstr">
<em>強制された値式</em>は、あなたが<code class="docutils literal notranslate"><span class="pre">nilで</span></code>ないことを確信しているオプショナルの値をアンラップします。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">expression</span>!
</li></ol></div></div></div>
<p>If the value of the <em>expression</em> is not <code class="docutils literal notranslate"><span class="pre">nil</span></code>, the optional value is unwrapped and returned with the corresponding nonoptional type. Otherwise, a runtime error is raised.<br><span class="jpstr">
<em>式</em>の値が<code class="docutils literal notranslate"><span class="pre">nil</span></code>でないならば、オプショナルの値は包装を取られて、対応する非オプショナル型で返されます。そうでなければ、実行時エラーが引き起こされます。
</span><!--end_jpstr-->
</p>
<p>The unwrapped value of a forced-value expression can be modified, either by mutating the value itself, or by assigning to one of the value’s members. For example:<br><span class="jpstr">
強制された値式のアンラップされた値は、値それ自体を変化させることによって、またはその値のメンバーの１つに代入することによってのどちらでも、修正されることができます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">x</span>: <span class="nc">Int</span>? = <span class="m">0</span>
</li><li><span class="nv">x</span>! += <span class="m">1</span>
</li><li><span class="c">// x is now 1</span>
</li><li>
</li><li><span class="k">var</span> <span class="nv">someDictionary</span> = [<span class="s">&quot;a&quot;</span>: [<span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>], <span class="s">&quot;b&quot;</span>: [<span class="m">10</span>, <span class="m">20</span>]]
</li><li><span class="nv">someDictionary</span>[<span class="s">&quot;a&quot;</span>]![<span class="m">0</span>] = <span class="m">100</span>
</li><li><span class="c">// someDictionary is now [&quot;a&quot;: [100, 2, 3], &quot;b&quot;: [10, 20]]</span>
</li></ol></div></div></div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a forced-value expression<br><span class="jpstr">
強制された値の式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_forced-value-expression"></a>forced-value-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>!</code></p></div></div></div>
<div class="section" id="ID405">
<h3>Optional-Chaining Expression<a class="headerlink" href="#ID405" title="Permalink to this headline">¶</a><br><span class="jpstr">
オプショナル連鎖式<a class="headerlink" href="#ID405" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>An <em>optional-chaining expression</em> provides a simplified syntax for using optional values in postfix expressions. It has the following form:<br><span class="jpstr">
<em>オプショナル連鎖式</em>は、オプショナルの値を使うために単純化された構文を接尾辞式において提供します。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">expression</span>?
</li></ol></div></div></div>
<p>The postfix <code class="docutils literal notranslate"><span class="pre">?</span></code> operator makes an optional-chaining expression from an expression without changing the expression’s value.<br><span class="jpstr">
接尾辞<code class="docutils literal notranslate"><span class="pre">?</span></code>演算子は、オプショナル連鎖式をある式から、その式の値を変更することなく作ります。
</span><!--end_jpstr-->
</p>
<p>Optional-chaining expressions must appear within a postfix expression, and they cause the postfix expression to be evaluated in a special way. If the value of the optional-chaining expression is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, all of the other operations in the postfix expression are ignored and the entire postfix expression evaluates to <code class="docutils literal notranslate"><span class="pre">nil</span></code>. If the value of the optional-chaining expression is not <code class="docutils literal notranslate"><span class="pre">nil</span></code>, the value of the optional-chaining expression is unwrapped and used to evaluate the rest of the postfix expression. In either case, the value of the postfix expression is still of an optional type.<br><span class="jpstr">
オプショナル連鎖式は、接尾辞式の中に現れなければなりません、そしてそれはその接尾辞式を特別なやり方で評価されるようにします。オプショナル連鎖式の値が<code class="docutils literal notranslate"><span class="pre">nil</span></code>ならば、接尾辞式での他の演算の全ては無視されます、そして接尾辞式の全体は<code class="docutils literal notranslate"><span class="pre">nil</span></code>に評価されます。オプショナル連鎖式の値が<code class="docutils literal notranslate"><span class="pre">nil</span></code>でないならば、オプショナル連鎖式の値はアンラップされて、接尾辞式の残りを評価するために使われます。いずれにせよ、接尾辞式の値は、依然としてオプショナル型です。
</span><!--end_jpstr-->
</p>
<p>If a postfix expression that contains an optional-chaining expression is nested inside other postfix expressions, only the outermost expression returns an optional type. In the example below, when <code class="docutils literal notranslate"><span class="pre">c</span></code> is not <code class="docutils literal notranslate"><span class="pre">nil</span></code>, its value is unwrapped and used to evaluate <code class="docutils literal notranslate"><span class="pre">.property</span></code>, the value of which is used to evaluate <code class="docutils literal notranslate"><span class="pre">.performAction()</span></code>. The entire expression <code class="docutils literal notranslate"><span class="pre">c?.property.performAction()</span></code> has a value of an optional type.<br><span class="jpstr">
オプショナル連鎖式を含む接尾辞式が、他の接尾辞式の内部に入れ子にされるならば、最も外部の式だけがオプショナル型を返します。下記の例で、<code class="docutils literal notranslate"><span class="pre">c</span></code>が<code class="docutils literal notranslate"><span class="pre">nil</span></code>でないとき、その値はアンラップされて<code class="docutils literal notranslate"><span class="pre">.property</span></code>を評価するために使われ、その値が<code class="docutils literal notranslate"><span class="pre">.performAction()</span></code>を評価するために使われます。式<code class="docutils literal notranslate"><span class="pre">c?.property.performAction()</span></code>の全体がオプショナル型の値を持ちます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">c</span>: <span class="nc">SomeClass</span>?
</li><li><span class="k">var</span> <span class="nv">result</span>: <span class="nc">Bool</span>? = <span class="nv">c</span>?.<span class="nv">property</span>.<span class="nv">performAction</span>()
</li></ol></div></div></div>
<p>The following example shows the behavior of the example above without using optional chaining.<br><span class="jpstr">
以下の例は、オプショナル連鎖を使うことなく上の例の挙動を示します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">result</span>: <span class="nc">Bool</span>?
</li><li><span class="k">if</span> <span class="k">let</span> <span class="nv">unwrappedC</span> = <span class="nv">c</span> {
</li><li>    <span class="nv">result</span> = <span class="nv">unwrappedC</span>.<span class="nv">property</span>.<span class="nv">performAction</span>()
</li><li>}
</li></ol></div></div></div>
<p>The unwrapped value of an optional-chaining expression can be modified, either by mutating the value itself, or by assigning to one of the value’s members. If the value of the optional-chaining expression is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, the expression on the right-hand side of the assignment operator is not evaluated. For example:<br><span class="jpstr">
オプショナル連鎖のアンラップされた値は、その値自体を変化させることによって、またはその値のメンバーの１つに値に代入することによってのどちらでも修正されることができます。オプショナル連鎖式の値が<code class="docutils literal notranslate"><span class="pre">nil</span></code>ならば、代入演算子の右手側での式は評価されません。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunctionWithSideEffects</span>() -&gt; <span class="nc">Int</span> {
</li><li>    <span class="k">return</span> <span class="m">42</span>  <span class="c">// No actual side effects.&nbsp;<span class="jpstr"><span class="c">（実際の副作用なし）</span></span><!--end_jpstr--></span>
</li><li>}
</li><li><span class="k">var</span> <span class="nv">someDictionary</span> = [<span class="s">&quot;a&quot;</span>: [<span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>], <span class="s">&quot;b&quot;</span>: [<span class="m">10</span>, <span class="m">20</span>]]
</li><li>
</li><li><span class="nv">someDictionary</span>[<span class="s">&quot;not here&quot;</span>]?[<span class="m">0</span>] = <span class="nv">someFunctionWithSideEffects</span>()
</li><li><span class="c">// someFunctionWithSideEffects is not evaluated&nbsp;<span class="jpstr">（someFunctionWithSideEffectsは、評価されません。）</span><!--end_jpstr-->
</span>
</li><li><span class="c">// someDictionary is still [&quot;a&quot;: [1, 2, 3], &quot;b&quot;: [10, 20]]</span>
</li><li>
</li><li><span class="nv">someDictionary</span>[<span class="s">&quot;a&quot;</span>]?[<span class="m">0</span>] = <span class="nv">someFunctionWithSideEffects</span>()
</li><li><span class="c">// someFunctionWithSideEffects is evaluated and returns 42&nbsp;<span class="jpstr">（someFunctionWithSideEffectsは、評価されて42を返します）</span><!--end_jpstr-->
</span>
</li><li><span class="c">// someDictionary is now [&quot;a&quot;: [42, 2, 3], &quot;b&quot;: [10, 20]]</span>
</li></ol></div></div></div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of an optional-chaining expression<br><span class="jpstr">
オプショナル連鎖式の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_optional-chaining-expression"></a>optional-chaining-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>?</code></p></div></div></div>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="Types.html">Types<br><span class="jpstr">
型
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="Statements.html">Statements<br><span class="jpstr">
文
</span><!--end_jpstr-->
</a></p>
    </div>

    <div class="admonition-beta admonition">
        <p class="first admonition-title">Beta Software</p>
        <p>
          This documentation contains preliminary information about an API or technology in development.
          This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.
        <br><span class="jpstr">
この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。
          この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。
</span><!--end_jpstr-->
</p>
        <p class="last"><a class="reference external" href="https://developer.apple.com/support/beta-software/">Learn more about using Apple's beta software</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright &copy; 2018 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  </body>
</html>
