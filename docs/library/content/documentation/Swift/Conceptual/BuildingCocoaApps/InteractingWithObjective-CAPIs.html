<!DOCTYPE html>
<html lang="en">
  <head>  
  <title>Using Swift with Cocoa and Objective-C (Swift 4): Interacting with Objective-C APIs</title>
  <link rel="stylesheet" type="text/css" href="../../../../Resources/1264/CSS/style-1.6.3.css" />
  <link rel="stylesheet" type="text/css" href="../../../../Resources/1264/CSS/feedback-1.6.3.css" />
  <meta charset='utf-8'> 
<meta id="j-version" name="j-version" content="" />
<meta id="build" name="build" content="dadaf8814eb04e8376a0501374bda6be" />
<meta id="document-version" name="document-version" content="9.0.4" />
<meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Topic/Swift}" />
<meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/TP40014216" />
<meta id="chapterId" name="chapterId" content="TP40014216-CH4">
<meta id="book-title" name="book-title" content="Using Swift with Cocoa and Objective-C (Swift 4)" />
<meta id="book-resource-type" name="book-resource-type" content="Guide" />
<meta id="book-root" name="book-root" content="./" />
<meta id="book-json" name="book-json" content="book.json">
<meta id="date" name="date" content="2017-06-05" />
<meta id="description" name="description" content="Describes various aspects of Swift&#39;s compatibility with the Objective-C language and Cocoa/Cocoa Touch frameworks." />
<meta id="IndexTitle" name="IndexTitle" content="" />
<meta id="resources-uri" name="resources-uri" content="../../../../Resources/1264">
<link id="book-index-page" rel="Start" title="" type="text/html" href="./index.html">
<!-- , next_chapter: next_chapter, previous_chapter: previous_chapter -->
<link id="next-page" rel="Next" type="text/html" href="">
<link id="previous-page" rel="Prev" type="text/html" href="">
<meta id="devcenter" name="devcenter" content="<!-- DEVCENTER_NAME -->" />
<meta id="devcenter-url" name="devcenter-url" content="<!-- DEVCENTER_URL -->" />
<meta id="reflib" name="reflib" content="<!-- REFLIB_NAME -->" />

<meta id="xcode-display" name="xcode-display" content="render" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<meta id="platforms" name="platforms" content="Xcode Developer Tools">
</head>

  <body id="conceptual_flow_with_tasks" class="jazz">
    
    <header id="ios_header" class="hideOnPrint hideInXcode">
  <div class="content-wrapper">
    <p class="header-text">
    	<a href="../../../../navigation/index.html">Guides and Sample Code
 		</a>
 </p>
    <p id="wwdr"><img id="apple_logo" src="../../../../Resources/1264/Images/apple2.png" height="14px" width="12px" aria-hidden="true" /><a href="https://developer.apple.com">Developer</a></p>
  </div>
</header>

    <section id="valence">
  <div class="content-wrapper">
    <p id="hierarchial_navigation">
      <span id="book_title">Using Swift with Cocoa and Objective-C (Swift 4)</span>
    </p>
    <form id="search" class="hideInXcode" method="get" action="/search/index.php" accept-charset="utf-8" autocomplete="off">
  <input type="search" id="ssi_SearchField" placeholder="Search Guides and Sample Code" name="q" autocomplete="off" tabindex="2" />
</form>

      
   
   




    <span class="download-text hideInXcode">
      <a href="https://itunes.apple.com/us/book/using-swift-cocoa-objective/id1002624212?mt=11">iBooks</a>
    </span>

    

    <img id="shortstack" src="../../../../Resources/1264/Images/shortstack_2x.png"/>
  </div>
</section>
    <div class="content-wrapper">
      <nav id="navigator" class="book-parts hideInXcode" role="navigation">
    <ul class="nav-parts">
        <li data-id="//apple_ref/doc/uid/TP40014216-CH1-ID5"
            class="part-name">
            <a href="index.html#//apple_ref/doc/uid/TP40014216-CH2-ID0" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH2-ID0">Getting Started<br><span class="jpstr">
初めに
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="index.html#//apple_ref/doc/uid/TP40014216-CH2-ID0" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH2-ID0">Basic Setup<br><span class="jpstr">
基本の準備
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014216-CH3-ID60"
            class="part-name nav-part-active open-part">
            <a href="#//apple_ref/doc/uid/TP40014216-CH4-ID35" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID35">Interoperability<br><span class="jpstr">
相互運用性
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter nav-current-chapter">
              	<a href="#//apple_ref/doc/uid/TP40014216-CH4-ID35" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID35">Interacting with Objective-C APIs<br><span class="jpstr">
Objective-C APIとの相互作用
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID86" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH5-ID86">Writing Swift Classes and Protocols with Objective-C Behavior<br><span class="jpstr">
スウィフトのクラスとプロトコルをObjective-C挙動で書く
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH6-ID61">Working with Cocoa Frameworks<br><span class="jpstr">
Cocoaフレームワークを扱う
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID6" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH7-ID6">Adopting Cocoa Design Patterns<br><span class="jpstr">
ココア・デザインパターンの採用
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID17" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH8-ID17">Interacting with C APIs<br><span class="jpstr">
C APIとの相互作用
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014216-CH9-ID141"
            class="part-name">
            <a href="MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH10-ID122">Mix and Match<br><span class="jpstr">
混合と適合
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH10-ID122">Swift and Objective-C in the Same Project<br><span class="jpstr">
同じプロジェクト中のスウィフトとObjective-C
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014216-CH11-ID121"
            class="part-name">
            <a href="Migration.html#//apple_ref/doc/uid/TP40014216-CH12-ID108" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH12-ID108">Migration<br><span class="jpstr">
移行
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="Migration.html#//apple_ref/doc/uid/TP40014216-CH12-ID108" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH12-ID108">Migrating Your Objective-C Code to Swift<br><span class="jpstr">
あなたのObjective-Cコードのスウィフトへの移行
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014216-CH13-ID143"
            class="part-name">
            <a href="RevisionHistory.html#//apple_ref/doc/uid/TP40014216-CH14-ID142" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH14-ID142">Revision History<br><span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="RevisionHistory.html#//apple_ref/doc/uid/TP40014216-CH14-ID142" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH14-ID142">Document Revision History<br><span class="jpstr">
文書改訂履歴
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
    </ul>
</nav>

      <menu id="bashful" type="toolbar">
  <div class="shield"></div>
  <menuitem id="jump_to" class="menu-bar-item closed">
  <span>On This Page</span>
  <div class="chevron">
    <div class="chevy chevron-left"></div>
    <div class="chevy chevron-right"></div>
  </div>
  <menu type="list" class="details">
      <ul class="list-bullet">
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH4-ID37">Initialization</a>
<br><span class="jpstr">
初期化
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH4-ID39">Accessing Properties</a>
<br><span class="jpstr">
プロパティにアクセスする
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH4-ID41">Working with Methods</a>
<br><span class="jpstr">
メソッドを扱う
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH4-ID42">id Compatibility</a>
<br><span class="jpstr">
id互換性
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH4-ID45">Nullability and Optionals</a>
<br><span class="jpstr">
ヌル許可とオプショナル
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH4-ID217">Protocol-Qualified Classes</a>
<br><span class="jpstr">
プロトコル適格クラス
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH4-ID173">Lightweight Generics</a>
<br><span class="jpstr">
軽量総称体
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH4-ID47">Extensions</a>
<br><span class="jpstr">
拡張
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH4-ID49">Closures</a>
<br><span class="jpstr">
クロージャ
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH4-ID51">Object Comparison</a>
<br><span class="jpstr">
オブジェクト比較
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH4-ID53">Swift Type Compatibility</a>
<br><span class="jpstr">
スウィフト型互換性
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH4-ID59">Selectors</a>
<br><span class="jpstr">
セレクタ
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH4-ID205">Keys and Key Paths</a>
<br><span class="jpstr">
キーとキーパス
</span><!--end_jpstr-->
          </li>
      </ul>
  </menu>
</menuitem>

</menu>
<div class="pixel-line"></div>
<div class="rubber-band-gap"></div>
<article class="chapter">
  <a name="//apple_ref/doc/uid/TP40014216-CH4"></a><a name="//apple_ref/doc/uid/TP40014216-CH4-ID35"></a>
      <a name="//apple_ref/doc/uid/TP40014216-CH3"></a><a name="//apple_ref/doc/uid/TP40014216-CH3-ID60"></a>

  <h2 class='chapter-name'>Interacting with Objective-C APIs<br><span class="jpstr">
Objective-C APIとの相互作用
</span><!--end_jpstr-->
</h2>


  
  	<section class="section">
  		<p class="para">
  <em>Interoperability</em> is the ability to interface between Swift and Objective-C in either direction, letting you access and use pieces of code written in one language in a file of the other language. As you begin to integrate Swift into your app development workflow, it’s a good idea to understand how you can leverage interoperability to redefine, improve, and enhance the way you write Cocoa apps.
<br><span class="jpstr">
<em>相互運用性</em>は、スウィフトとObjective-Cの間でどちらの方向からでも調和させ、あなたに一方の言語で書かれるコード断片を他方の言語のファイルの中でアクセスおよび使用させる能力です。あなたがスウィフトをあなたのアプリ開発ワークフローに組み込み始めるとき、あなたがあなたがココア・アプリを書く方法をとらえ直して、向上させて、強化するために、どのように相互運用性を使って小さな労力で大きな成果を得られるようにできるか理解することは良い考えです。
</span><!--end_jpstr-->
</p>
<p class="para">
  One important aspect of interoperability is that it lets you work with Objective-C APIs when writing Swift code. After you import an Objective-C framework, you can instantiate classes from it and interact with them using native Swift syntax.
<br><span class="jpstr">
相互運用性の１つの重要な面は、スウィフトコードを書くとき、それがあなたにObjective-C APIを扱わせるということです。あなたがObjective-Cフレームワークをインポートしたあと、あなたはそれからのクラスをインスタンス化することができて、スウィフト本来の構文を使ってそれらと相互に作用することができます。
</span><!--end_jpstr-->
</p>

		</section> 


  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID37"></a>
  <h3 class="section-name" tabindex="0">Initialization<br><span class="jpstr">
初期化
</span><!--end_jpstr-->
</h3>
  <p class="para">
  To instantiate an Objective-C class in Swift, you call one of its initializers using Swift initializer syntax.
<br><span class="jpstr">
Objective-Cクラスをスウィフトにおいてインスタンス化するために、あなたはそれのイニシャライザのうちの１つをスウィフト初期化構文を使って呼び出します。
</span><!--end_jpstr-->
</p><p class="para">
  Objective-C initializers begin with <code class="code-voice">init</code>, or <code class="code-voice">initWith:</code> if the initializer takes one or more arguments. When an Objective-C initializer is imported by Swift, the <code class="code-voice">init</code> prefix becomes an <code class="code-voice">init</code> keyword to indicate that the method is a Swift initializer. If the initializer takes an argument, the <code class="code-voice">With</code> is removed and the rest of the selector is divided up into named parameters accordingly.
<br><span class="jpstr">
Objective-Cイニシャライザは、<code class="code-voice">init</code>で、またはイニシャライザがひとつ以上の引数をとるならば<code class="code-voice">initWith:</code>で始まります。Objective-Cイニシャライザがスウィフトによってインポートされる時、<code class="code-voice">init</code>接頭辞は<code class="code-voice">init</code>キーワードになって、そのメソッドがスウィフトイニシャライザであることを指し示します。イニシャライザが引数をとるならば、<code class="code-voice">With</code>は取り除かれて残りのセレクタが名前付きパラメーターへとそれらしく分離されます。
</span><!--end_jpstr-->
</p><p class="para">
  Consider the following Objective-C initializer declarations:
<br><span class="jpstr">
以下のObjective-Cイニシャライザ宣言を考えてみてください：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nl">initWithFrame:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="n">frame</span>
</code></li>
            <li><code class="code-voice">                        <span class="nl">style:</span><span class="p">(</span><span class="n">UITableViewStyle</span><span class="p">)</span><span class="n">style</span><span class="p">;</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here are the equivalent Swift initializer declarations:
<br><span class="jpstr">
ここに同等のスウィフトイニシャライザ宣言があります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">init</span>() { <span class="c">/* ... */</span> }</code></li>
            <li><code class="code-voice"><span class="kt">init</span>(<span class="vc">frame</span>: <span class="n"><!-- a href="" -->CGRect<!-- /a --></span>, <span class="vc">style</span>: <span class="n"><!-- a href="" -->UITableViewStyle<!-- /a --></span>) { <span class="c">/* ... */</span> }</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The differences between Objective-C and Swift syntax are all the more apparent when instantiating objects.
<br><span class="jpstr">
Objective-Cとスウィフト構文の間の違いは、オブジェクトをインスタンス化するとき全て明らかになります。
</span><!--end_jpstr-->
</p><p class="para">
  In Objective-C, you do this:
<br><span class="jpstr">
Objective-Cでは、あなたはこうします：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="n">UITableView</span> <span class="o">*</span><span class="n">myTableView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UITableView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="n">CGRectZero</span> <span class="nl">style:</span><span class="n">UITableViewStyleGrouped</span><span class="p">];</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  In Swift, you do this:
<br><span class="jpstr">
スウィフトでは、あなたはこうします：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">myTableView</span>: <span class="n"><!-- a href="" -->UITableView<!-- /a --></span> = <span class="vc">UITableView</span>(<span class="vc">frame</span>: .<span class="vc">zero</span>, <span class="vc">style</span>: .<span class="vc">grouped</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Notice that you don’t need to call <code class="code-voice">alloc</code>; Swift handles this for you. Notice also that “init” doesn’t appear anywhere when calling the Swift-style initializer.
<br><span class="jpstr">
あなたが<code class="code-voice">alloc</code>を呼ぶ必要がないことに注意してください；スウィフトは、これをあなたの代わりに処理します。またスウィフト形式のイニシャライザを呼ぶとき「init」がどこにも現れないことに注目してください。
</span><!--end_jpstr-->
</p><p class="para">
  You can provide an explicit type when assigning to a constant or variable, or you can omit the type and have Swift infer the type automatically from the initializer.
<br><span class="jpstr">
あなたは、定数または変数に割り当てする時に明示的な型を提供することができます、またはあなたは型を省略してスウィフトに型をイニシャライザから自動的に推論させることができます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">myTextField</span> = <span class="vc">UITextField</span>(<span class="vc">frame</span>: <span class="vc">CGRect</span>(<span class="vc">x</span>: <span class="m">0.0</span>, <span class="vc">y</span>: <span class="m">0.0</span>, <span class="vc">width</span>: <span class="m">200.0</span>, <span class="vc">height</span>: <span class="m">40.0</span>))</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  These <code class="code-voice">UITableView</code> and <code class="code-voice">UITextField</code> objects are the same objects that you’d instantiate in Objective-C. You can use them in the same way you would in Objective-C, accessing any properties and calling any methods defined on their respective types.
<br><span class="jpstr">
これらの<code class="code-voice">UITableView</code>と<code class="code-voice">UITextField</code>オブジェクトは、それらがObjective-Cでインスタンス化するのと同じオブジェクトです。あなたは、それらをあなたがObjective-Cでするのと同じ方法で使って、それらの各自の型上で定義される、どんなプロパティにでもアクセスして、どんなメソッドでも呼び出すことができます。
</span><!--end_jpstr-->
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID192"></a>
  <h3 class="section-name" tabindex="0">Class Factory Methods and Convenience Initializers<br><span class="jpstr">
クラスファクトリメソッドと便宜イニシャライザ
</span><!--end_jpstr-->
</h3>
  <p class="para">
  For consistency and simplicity, Objective-C class factory methods are imported as convenience initializers in Swift. This allows them to be used with the same syntax as initializers.
<br><span class="jpstr">
一貫性と単純さのために、Objective-Cクラスファクトリメソッドは、便宜イニシャライザとしてスウィフトにインポートされます。これは、それらにイニシャライザと同じ構文で使用されることを可能にします。
</span><!--end_jpstr-->
</p><p class="para">
  For example, whereas in Objective-C you would call this factory method like this:
<br><span class="jpstr">
例えば、Objective-Cではあなたはこのクラスファクトリメソッドこのように呼び出しますが：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="n">UIColor</span> <span class="o">*</span><span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nl">colorWithRed:</span><span class="mf">0.5</span> <span class="nl">green:</span><span class="mf">0.0</span> <span class="nl">blue:</span><span class="mf">0.5</span> <span class="nl">alpha:</span><span class="mf">1.0</span><span class="p">];</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  In Swift, you call it like this:
<br><span class="jpstr">
スウィフトでは、あなたはそれをこのように呼び出します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">color</span> = <span class="vc">UIColor</span>(<span class="vc">red</span>: <span class="m">0.5</span>, <span class="vc">green</span>: <span class="m">0.0</span>, <span class="vc">blue</span>: <span class="m">0.5</span>, <span class="vc">alpha</span>: <span class="m">1.0</span>)</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID145"></a>
  <h3 class="section-name" tabindex="0">Failable Initialization<br><span class="jpstr">
失敗できる初期化
</span><!--end_jpstr-->
</h3>
  <p class="para">
  In Objective-C, initializers directly return the object they initialize. To inform the caller when initialization has failed, an Objective-C initializer can return <code class="code-voice">nil</code>. In Swift, this pattern is built into a language feature called <em>failable initialization</em>.
<br><span class="jpstr">
Objective-Cでは、イニシャライザは直接にそれが初期化したオブジェクトを返します。初期化が失敗した時に呼び出し側に報告するために、Objective-Cイニシャライザは<code class="code-voice">nil</code>を返すことができます。スウィフトでは、このよくある操作は<em>失敗できる初期化</em>と呼ばれる言語機能に組み込まれます。
</span><!--end_jpstr-->
</p><p class="para">
  Many Objective-C initializers in system frameworks have been audited to indicate whether initialization can fail. You can indicate whether initializers in your own Objective-C classes can fail using <em>nullability annotations</em>, as described in <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014216-CH4-ID45" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID45">Nullability and Optionals</a></span>. Objective-C initializers that indicate whether they’re failable are imported as either <code class="code-voice">init(...)</code>—if initialization cannot fail—or <code class="code-voice">init?(...)</code>—if initialization can fail. Otherwise, Objective-C initializers are imported as <code class="code-voice">init!(...)</code>.
<br><span class="jpstr">
システムフレームワークの中の多くのObjective-Cイニシャライザは、初期化が失敗する可能性があるかどうか検査されてしまっています。あなたは、あなた独自のObjective-Cクラスの中のイニシャライザが失敗できるかどうかを<em>ヌル許可注釈</em>を使って指し示すことができます、それは<span class="x-name"><a href="#//apple_ref/doc/uid/TP40014216-CH4-ID45" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID45">ヌル許可とオプショナル</a></span>で記述されます。それらが失敗できるかどうか指し示すObjective-Cイニシャライザは、初期化が失敗できないならば ― <code class="code-voice">init(...)</code>、または初期化が失敗できるならば ― <code class="code-voice">init?(...)</code>、このどちらかでインポートされます。それ以外では、Objective-Cイニシャライザは、<code class="code-voice">init!(...)</code>としてインポートされます。
</span><!--end_jpstr-->
</p><p class="para">
  For example, the <code class="code-voice">UIImage(contentsOfFile:)</code> initializer can fail to initialize a <code class="code-voice">UIImage</code> object if an image file doesn’t exist at the provided path. You can use optional binding to unwrap the result of a failable initializer if initialization is successful.
<br><span class="jpstr">
例えば、<code class="code-voice">UIImage(contentsOfFile:)</code>イニシャライザは、与えられたパスでファイルが存在しないならば、<code class="code-voice">UIImage</code>オブジェクトを初期化するのに失敗する可能性があります。あなたはオプショナル束縛を使って、初期化がうまくいったならば失敗できるイニシャライザの結果をアンラップすることができます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">image</span> = <span class="vc">UIImage</span>(<span class="vc">contentsOfFile</span>: <span class="s">&quot;MyImage.png&quot;</span>) {</code></li>
            <li><code class="code-voice">    <span class="c">// loaded the image successfully&nbsp;<span class="jpstr">（画像をうまく読み込んだ）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">} <span class="kt">else</span> {</code></li>
            <li><code class="code-voice">    <span class="c">// could not load the image&nbsp;<span class="jpstr">（画像を読み込めなかった）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID39"></a>
  <h3 class="section-name" tabindex="0">Accessing Properties<br><span class="jpstr">
プロパティにアクセスする
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Objective-C property declarations using the <code class="code-voice">@property</code> syntax are imported as Swift properties in the following way:
<br><span class="jpstr">
Objective-Cプロパティ宣言で<code class="code-voice">@property</code>構文を使っているものは、スウィフトプロパティとして以下の方法でインポートされます：
</span><!--end_jpstr-->
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  Properties with the nullability property attributes (<code class="code-voice">nonnull</code>, <code class="code-voice">nullable</code>, and <code class="code-voice">null_resettable</code>) are imported as Swift properties with optional or nonoptional type as described in <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014216-CH4-ID45" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID45">Nullability and Optionals</a></span>.
<br><span class="jpstr">
ヌル許可プロパティ属性（<code class="code-voice">nonnull</code>、<code class="code-voice">nullable</code>、そして<code class="code-voice">null_resettable</code>）を使ったプロパティは、スウィフトプロパティとしてインポートされるのにオプショナルまたは非オプショナル型を使います、<span class="x-name"><a href="#//apple_ref/doc/uid/TP40014216-CH4-ID45" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID45">ヌル許可とオプショナル</a></span>で記述されるように。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Properties with the <code class="code-voice">readonly</code> property attribute are imported as Swift computed properties with a getter (<code class="code-voice">{ get }</code>).
<br><span class="jpstr">
<code class="code-voice">readonly</code>プロパティ属性を使うプロパティは、スウィフト計算プロパティとしてインポートされるのにゲッター（<code class="code-voice">{ get }</code>）を使います。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Properties with the <code class="code-voice">weak</code> property attribute are imported as Swift properties marked with the <code class="code-voice">weak</code> keyword (<code class="code-voice">weak var</code>).
<br><span class="jpstr">
<code class="code-voice">weak</code>プロパティ属性を使うプロパティは、<code class="code-voice">weak</code>キーワード（<code class="code-voice">weak var</code>）で印されるスウィフトプロパティとしてインポートされます。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Properties with an ownership property attribute other than <code class="code-voice">weak</code> (that is, <code class="code-voice">assign</code>, <code class="code-voice">copy</code>, <code class="code-voice">strong</code>, or <code class="code-voice">unsafe_unretained</code>) are imported as Swift properties with the appropriate storage.
<br><span class="jpstr">
<code class="code-voice">weak</code>とは別の所有者プロパティ属性（すなわち、<code class="code-voice">assign</code>、<code class="code-voice">copy</code>、<code class="code-voice">strong</code>、または<code class="code-voice">unsafe_unretained</code>）を持つプロパティは、スウィフトプロパティとしてインポートされるのに適切なストレージを使います。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Properties with the <code class="code-voice">class</code> property attribute are imported as Swift type properties.
<br><span class="jpstr">
<code class="code-voice">class</code>プロパティ属性を持つプロパティは、スウィフト型プロパティとしてインポートされます。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Atomicity property attributes (<code class="code-voice">atomic</code> and <code class="code-voice">nonatomic</code>) are not reflected in the corresponding Swift property declaration, but the atomicity guarantees of the Objective-C implementation still hold when the imported property is accessed from Swift.
<br><span class="jpstr">
原子性プロパティ属性（<code class="code-voice">atomic</code>と<code class="code-voice">nonatomic</code>）は、スウィフトプロパティ宣言に反映されません、しかしObjective-C実装の原子性担保はインポートされたプロパティがスウィフトからアクセスされる時に依然として保持されます。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Accessor property attributes (<code class="code-voice">getter=</code> and <code class="code-voice">setter=</code>) are ignored by Swift.
<br><span class="jpstr">
アクセッサプロパティ属性（<code class="code-voice">getter=</code>と<code class="code-voice">setter=</code>）は、スウィフトによって無視されます。
</span><!--end_jpstr-->
</p>
</li>
</ul><p class="para">
  You access properties on Objective-C objects in Swift using dot syntax, using the name of the property without parentheses.
<br><span class="jpstr">
あなたは、Objective-Cオブジェクト上のプロパティにスウィフトにおいてドット構文によって、そのプロパティの名前を丸括弧なして使ってアクセスします。
</span><!--end_jpstr-->
</p><p class="para">
  For example, you can set the <code class="code-voice">textColor</code> and <code class="code-voice">text</code> properties of a <code class="code-voice">UITextField</code> object with the following code:
<br><span class="jpstr">
例えば、あなたはある<code class="code-voice">UITextField</code>オブジェクトの<code class="code-voice">textColor</code>と<code class="code-voice">text</code>プロパティを設定するにの以下のコードを使うことができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">myTextField</span>.<span class="vc">textColor</span> = .<span class="vc">darkGray</span></code></li>
            <li><code class="code-voice"><span class="vc">myTextField</span>.<span class="vc">text</span> = <span class="s">&quot;Hello world&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Objective-C methods that return a value and take no arguments can be called like an Objective-C property using dot syntax. However, these are imported by Swift as instance methods, as only Objective-C <code class="code-voice">@property</code> declarations are imported by Swift as properties. Methods are imported and called as described in <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014216-CH4-ID41" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID41">Working with Methods</a></span>.
<br><span class="jpstr">
値を返して引数を取らないObjective-Cメソッドは、Objective-Cプロパティのように呼び出すことがドット構文を使って行えます。しかしながら、それらはスウィフトによってインスタンスメソッドのようにインポートされます、Objective-Cの<code class="code-voice">@property</code>宣言だけはスウィフトによってプロパティとしてインポートされます。メソッドは、<span class="x-name"><a href="#//apple_ref/doc/uid/TP40014216-CH4-ID41" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID41">メソッドを扱う</a></span>で記述されるように、インポートされ呼び出されます。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID41"></a>
  <h3 class="section-name" tabindex="0">Working with Methods<br><span class="jpstr">
メソッドを扱う
</span><!--end_jpstr-->
</h3>
  <p class="para">
  You can call Objective-C methods from Swift using dot syntax.
<br><span class="jpstr">
あなたは、Objective-Cメソッドをスウィフトからドット構文を使って呼び出すことができます。
</span><!--end_jpstr-->
</p><p class="para">
  When Objective-C methods are imported into Swift, the first part of the Objective-C selector becomes the base method name and appears before the parentheses. The first argument appears immediately inside the parentheses, without a name. The rest of the selector pieces correspond to argument names and appear inside the parentheses. All selector pieces are required at the call site.
<br><span class="jpstr">
Objective-Cメソッドがスウィフトにインポートされるとき、Objective-Cセレクタの最初の部分は、基盤となるメソッド名になって、丸括弧の前に現れます。最初の引数は、名前なしで、丸括弧の直ぐ内側に現れます。残りのセレクタ片は、引数名に相当して、括弧の内側に現れます。全てのセレクタ片は、呼び出し現場で必須とされます。
</span><!--end_jpstr-->
</p><p class="para">
  For example, whereas in Objective-C you would do this:
<br><span class="jpstr">
例えば、Objective-Cではあなたがこうするのに対して：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="p">[</span><span class="n">myTableView</span> <span class="nl">insertSubview:</span><span class="n">mySubview</span> <span class="nl">atIndex:</span><span class="mi">2</span><span class="p">];</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  In Swift, you do this:
<br><span class="jpstr">
スウィフトでは、あなたはこうします：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">myTableView</span>.<span class="vc">insertSubview</span>(<span class="vc">mySubview</span>, <span class="vc">at</span>: <span class="m">2</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If you’re calling a method with no arguments, you must still include parentheses.
<br><span class="jpstr">
あなたが引数なしでメソッドを呼んでいる場合、あなたはそれでも括弧を含めなければなりません。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">myTableView</span>.<span class="vc">layoutIfNeeded</span>()</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID42"></a>
  <h3 class="section-name" tabindex="0">id Compatibility<br><span class="jpstr">
id互換性
</span><!--end_jpstr-->
</h3>
  <p class="para">
  The Objective-C <code class="code-voice">id</code> type is imported by Swift as the <code class="code-voice">Any</code> type. At compile time and runtime, the compiler introduces a universal bridging conversion operation when a Swift value or object is passed into Objective-C as an <code class="code-voice">id</code> parameter. When <code class="code-voice">id</code> values are imported into Swift as <code class="code-voice">Any</code>, the runtime automatically handles bridging back to either class references or Swift value types.
<br><span class="jpstr">
Objective-C <code class="code-voice">id</code>型は、スウィフトによって<code class="code-voice">Any</code>型としてインポートされます。コンパイル時および実行時に、コンパイラは全般的ブリッジ変換演算を、スウィフトの値やオブジェクトがObjective-Cへ<code class="code-voice">id</code>パラメータとして渡される時に導入します。<code class="code-voice">id</code>値がスウィフトへ<code class="code-voice">Any</code>としてインポートされる時、ランタイムは自動的にクラス参照またはスウィフト値型のどちらかへ戻すブリッジを取り扱います。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">x</span>: <span class="kt">Any</span> = <span class="s">&quot;hello&quot;</span> <span class="kt">as</span> <span class="n"><!-- a href="" -->String<!-- /a --></span></code></li>
            <li><code class="code-voice"><span class="vc">x</span> <span class="kt">as</span>? <span class="n"><!-- a href="" -->String<!-- /a --></span>   <span class="c">// String with value &quot;hello&quot;</span></code></li>
            <li><code class="code-voice"><span class="vc">x</span> <span class="kt">as</span>? <span class="n"><!-- a href="" -->NSString<!-- /a --></span> <span class="c">// NSString with value &quot;hello&quot;</span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">x</span> = <span class="s">&quot;goodbye&quot;</span> <span class="kt">as</span> <span class="n"><!-- a href="" -->NSString<!-- /a --></span></code></li>
            <li><code class="code-voice"><span class="vc">x</span> <span class="kt">as</span>? <span class="n"><!-- a href="" -->String<!-- /a --></span>   <span class="c">// String with value &quot;goodbye&quot;</span></code></li>
            <li><code class="code-voice"><span class="vc">x</span> <span class="kt">as</span>? <span class="n"><!-- a href="" -->NSString<!-- /a --></span> <span class="c">// NSString with value &quot;goodbye&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID194"></a>
  <h3 class="section-name" tabindex="0">Downcasting Any<br><span class="jpstr">
Anyのダウンキャスト
</span><!--end_jpstr-->
</h3>
  <p class="para">
  When working with objects of type <code class="code-voice">Any</code> where the underlying type is known or could be reasonably determined, it is often useful to downcast those objects to a more specific type. However, because the <code class="code-voice">Any</code> type can refer to any type, a downcast to a more specific type is not guaranteed to succeed.
<br><span class="jpstr">
基礎をなす型が知られているかまずまず判定されることができるところの型<code class="code-voice">Any</code>のオブジェクトを扱う時、そのようなオブジェクトをもっとはっきりした型へダウンキャストするのはしばしば便利です。しかしながら、<code class="code-voice">Any</code>型はあらゆる型を参照できることから、より具体的な型へダウンキャウトすることは成功することを保証されません。
</span><!--end_jpstr-->
</p><p class="para">
  You can use the conditional type cast operator (<code class="code-voice">as?</code>), which returns an optional value of the type you are trying to downcast to:
<br><span class="jpstr">
あなたは、条件型キャスト演算子（<code class="code-voice">as?</code>）を使うことができます、それは、あなたがそれへとダウンキャストを試みている型のオプショナルの値を返します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">userDefaults</span> = <span class="vc">UserDefaults</span>.<span class="vc">standard</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">lastRefreshDate</span> = <span class="vc">userDefaults</span>.<span class="vc">object</span>(<span class="vc">forKey</span>: <span class="s">&quot;LastRefreshDate&quot;</span>) <span class="c">// lastRefreshDate is of type Any?&nbsp;<span class="jpstr"><span class="c">（lastRefreshDateは型Any?です）</span></span><!--end_jpstr--></span>
</code></li>
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">date</span> = <span class="vc">lastRefreshDate</span> <span class="kt">as</span>? <span class="n"><!-- a href="" -->Date<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;</span>\(<span class="vc">date</span>.<span class="vc">timeIntervalSinceReferenceDate</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If you are certain of the type of the object, you can use the forced downcast operator (<code class="code-voice">as!</code>) instead.
<br><span class="jpstr">
あなたがそのオプジェクトの型について確信をもつならば、あなたは強制ダウンキャスト演算子（<code class="code-voice">as!</code>）を代わりに使うことができます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">myDate</span> = <span class="vc">lastRefreshDate</span> <span class="kt">as</span>! <span class="n"><!-- a href="" -->Date<!-- /a --></span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">timeInterval</span> = <span class="vc">myDate</span>.<span class="vc">timeIntervalSinceReferenceDate</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  However, if a forced downcast fails, a runtime error is triggered:
<br><span class="jpstr">
しかしながら、強制型キャストが失敗するならば、実行時エラーが引き起こされます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">myDate</span> = <span class="vc">lastRefreshDate</span> <span class="kt">as</span>! <span class="n"><!-- a href="" -->String<!-- /a --></span> <span class="c">// Error</span></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID218"></a>
  <h3 class="section-name" tabindex="0">Dynamic Method Lookup<br><span class="jpstr">
動的メソッド検索
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Swift also includes an <code class="code-voice">AnyObject</code> type that represents some kind of object and has the special ability to look up any <code class="code-voice">@objc</code> method dynamically. This allows you to write maintain flexibility of untyped access to Objective-C APIs that return <code class="code-voice">id</code> values.
<br><span class="jpstr">
スウィフトはまた<code class="code-voice">AnyObject</code>型を含んでいます。それは何かわからないある種類のオブジェクトを表します、そしてどれかの<code class="code-voice">@objc</code>メソッドを動的に検索する特別な能力を持ちます。これがあなたに書くことを可能にするのは、<code class="code-voice">id</code>値を返すObjective-C APIに対する型なしでのアクセスの柔軟性の維持です。
</span><!--end_jpstr-->
</p><p class="para">
  For example, you can assign an object of any class type to a constant or variable of <code class="code-voice">AnyObject</code> type and reassign a variable to an object of a different type. You can also call any Objective-C method and access any property on an <code class="code-voice">AnyObject</code> value without casting to a more specific class type.
<br><span class="jpstr">
例えば、あなたはどんなクラス型のオブジェクトでも<code class="code-voice">AnyObject</code>型の定数や変数に代入できます、そしてある変数を異なる型のオブジェクトへ再度代入できます。あなたはまた、あらゆるObjective-Cメソッドを呼び出すこと、そして<code class="code-voice">AnyObject</code>値上のあらゆるプロパティにアクセスすることが、より具体的なクラス型にキャストすることなしに可能です。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">myObject</span>: <span class="n"><!-- a href="" -->AnyObject<!-- /a --></span> = <span class="vc">UITableViewCell</span>()</code></li>
            <li><code class="code-voice"><span class="vc">myObject</span> = <span class="vc">NSDate</span>()</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">futureDate</span> = <span class="vc">myObject</span>.<span class="vc">addingTimeInterval</span>(<span class="m">10</span>)</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">timeSinceNow</span> = <span class="vc">myObject</span>.<span class="vc">timeIntervalSinceNow</span></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID193"></a>
  <h3 class="section-name" tabindex="0">Unrecognized Selectors and Optional Chaining<br><span class="jpstr">
識別不能セレクタとオプショナル連鎖
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Because the specific type of an <code class="code-voice">AnyObject</code> value is not known until runtime, it is possible to inadvertently write unsafe code. In Swift as well as Objective-C, attempting to call a method that does not exist triggers an unrecognized selector error.
<br><span class="jpstr">
<code class="code-voice">AnyObject</code>値の具体的な型は実行時まで知られないことから、不注意に安全でないコードを書くことは可能です。スウィフトではObjective-C同様に、存在しないメソッドを呼び出す試みは、識別不能セレクタエラーの引き金となります。
</span><!--end_jpstr-->
</p><p class="para">
  For example, the following code compiles without a compiler warning, but triggers an error at runtime:
<br><span class="jpstr">
例えば、以下のコードは警告なしにコンパイルします、しかし実行時にエラーの引き金となります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">myObject</span>.<span class="vc">character</span>(<span class="vc">at</span>: <span class="m">5</span>)</code></li>
            <li><code class="code-voice"><span class="c">// crash, myObject doesn&#39;t respond to that method&nbsp;<span class="jpstr">（失敗、myObjectはこのメソッドに応答することができません）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Swift uses optionals to guard against such unsafe behavior. When you call a method on a value of <code class="code-voice">AnyObject</code> type, that method call behaves like an implicitly unwrapped optional. You can use the same optional chaining syntax you would use for optional methods in protocols to optionally invoke a method on <code class="code-voice">AnyObject</code>.
<br><span class="jpstr">
スウィフトは、オプショナルを使用してこのような安全でない挙動の発生を防ぐことができます。あなたが<code class="code-voice">AnyObject</code>型の値上でメソッドを呼ぶとき、そのメソッド呼び出しは暗黙的にアンラップされるオプショナルのように振る舞います。あなたは、プロトコルにおいてオプショナルメソッドに対して使う同じオプショナル連鎖構文を使って、<code class="code-voice">AnyObject</code>上でメソッドを随意なものとして発動することができます。
</span><!--end_jpstr-->
</p><p class="para">
  For example, in the code listing below, the first and second lines are not executed because the <code class="code-voice">count</code> property and the <code class="code-voice">character(at:)</code> method do not exist on an <code class="code-voice">NSDate</code> object. The <code class="code-voice">myCount</code> constant is inferred to be an optional <code class="code-voice">Int</code>, and is set to <code class="code-voice">nil</code>. You can also use an <code class="code-voice">if</code>–<code class="code-voice">let</code> statement to conditionally unwrap the result of a method that the object may not respond to, as shown on line three.
<br><span class="jpstr">
例えば、下記のコード出力において、最初と２番目の行が実行されません、なぜなら、<code class="code-voice">count</code>プロパティと<code class="code-voice">character(at:)</code>メソッドは<code class="code-voice">NSDate</code>オブジェクトには存在しないからです。<code class="code-voice">myCount</code>定数は、オプショナルの<code class="code-voice">Int</code>であると推論されて、<code class="code-voice">nil</code>に設定されます。あなたはまた<code class="code-voice">if</code>–<code class="code-voice">let</code>文を使用して、３行目で示されるように、条件付きでオブジェクトが応答しないかもしれないメソッドの結果をアンラップすることができます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="c">// myObject has AnyObject type and NSDate value&nbsp;<span class="jpstr">（myObjectはAnyObject型でNSDate値を持ちます）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">myCount</span> = <span class="vc">myObject</span>.<span class="vc">count</span></code></li>
            <li><code class="code-voice"><span class="c">// myCount has Int? type and nil value&nbsp;<span class="jpstr">（myCountはInt?型でnil値を持ちます）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">myChar</span> = <span class="vc">myObject</span>.<span class="vc">character</span>?(<span class="vc">at</span>: <span class="m">5</span>)</code></li>
            <li><code class="code-voice"><span class="c">// myChar has unichar? type and nil value&nbsp;<span class="jpstr">（myCharはunichar?型でNSDatenilを持ちます）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">fifthCharacter</span> = <span class="vc">myObject</span>.<span class="vc">character</span>?(<span class="vc">at</span>: <span class="m">5</span>) {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;Found </span>\(<span class="vc">fifthCharacter</span>)<span class="s"> at index 5&quot;</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="c">// conditional branch not executed&nbsp;<span class="jpstr">（条件分岐は実行されません）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-NoLink_6"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Although Swift does not require forced unwrapping when calling methods on values of type <code class="code-voice">AnyObject</code>, it is recommended as a way to safeguard against unexpected behavior.
    	<br><span class="jpstr">
とは言え、スウィフトは<code class="code-voice">AnyObject</code>型の値の上でメソッドを呼び出しているとき強制アンラップを必要としません、それは予期しない挙動に対抗して安全を守るための方法として推奨されます。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID45"></a>
  <h3 class="section-name" tabindex="0">Nullability and Optionals<br><span class="jpstr">
ヌル許可とオプショナル
</span><!--end_jpstr-->
</h3>
  <p class="para">
  In Objective-C, you work with references to objects using raw pointers that could be <code class="code-voice">NULL</code> (referred to as <code class="code-voice">nil</code> in Objective-C). In Swift, all values—including structures and object references—are guaranteed to be non–null. Instead, you represent a value that could be missing by wrapping the type of the value in an <em>optional type</em>. When you need to indicate that a value is missing, you use the value <code class="code-voice">nil</code>. For more information about optionals, see <a href="../Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330" data-renderer-version="2" target="_self">Optionals</a> in <em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">The Swift Programming Language (Swift 4)</a></em>.
<br><span class="jpstr">
Objective-Cでは、あなたはオブジェクトへの参照を、<code class="code-voice">NULL</code>（Objective-Cでは<code class="code-voice">nil</code>と呼ばれます）であることができる生のポインターを使って扱います。スウィフトでは、すべての値は ― 構造体やオブジェクト参照を含めて ― 非nullであることを保証されます。代わりに、あなたは見つからない値を、その型の値を<em>オプショナル型</em>の中にラップすることによって表わします。あなたがある値が見つからないことを指し示す必要があるならば、あなたは値<code class="code-voice">nil</code>を使います。オプショナルについての更なる情報として、<a href="../Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330" data-renderer-version="2" target="_self">オプショナル</a>を<em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">スウィフトプログラミング言語（Swift 4）</a></em>において見てください。
</span><!--end_jpstr-->
</p><p class="para">
  Objective-C can use nullability annotations to designate whether a parameter type, property type, or return type, can have a <code class="code-voice">NULL</code> or <code class="code-voice">nil</code> value. Individual type declarations can be audited using the <code class="code-voice">_Nullable</code> and <code class="code-voice">_Nonnull</code> annotations, individual property declarations can be audited using the <code class="code-voice">nullable</code>, <code class="code-voice">nonnull</code> and <code class="code-voice">null_resettable</code> property attributes, or entire regions can be audited for nullability using the <code class="code-voice">NS_ASSUME_NONNULL_BEGIN</code> and <code class="code-voice">NS_ASSUME_NONNULL_END</code> macros. If no nullability information is provided for a type, Swift cannot distinguish between optional and nonoptional references, and imports it as an implicitly unwrapped optional.
<br><span class="jpstr">
Objective-Cは、ヌル許可注釈を使って、あるパラメーター型、プロパティ型、または戻り値型が<code class="code-voice">NULL</code>または<code class="code-voice">nil</code>値を持つことが可能かどうか任命できます。個々の型宣言は<code class="code-voice">_Nullable</code>と<code class="code-voice">_Nonnull</code>注釈を使って監査されることができます、個々のプロパティ宣言は<code class="code-voice">nullable</code>、<code class="code-voice">nonnull</code>、そして<code class="code-voice">null_resettable</code>プロパティ属性を使って監査されることができます、または領域全体がヌル許可について監査されることが<code class="code-voice">NS_ASSUME_NONNULL_BEGIN</code>と<code class="code-voice">NS_ASSUME_NONNULL_END</code>マクロを使って可能です。ヌル許可情報がある型に提供されないならば、スウィフトはオプショナル参照と非オプショナル参照とを見分けることができません、そしてそれを暗黙的にアンラップされるオプショナルとしてインポートします。
</span><!--end_jpstr-->
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  Types declared to be <em>nonnullable</em>, either with a <code class="code-voice">_Nonnull</code> annotation or in an audited region, are imported by Swift as a <em>nonoptional</em>.
<br><span class="jpstr">
<em>非ヌル可能</em>として定義された型、<code class="code-voice">_Nonnull</code>注釈を使ってまたはある監査された領域の中の両方、は、スウィフトによって<em>非オプショナル</em>としてインポートされます。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Types declared to be <em>nullable</em> with a <code class="code-voice">_Nullable</code> annotation, are imported by Swift as an <em>optional</em>.
<br><span class="jpstr">
<em>ヌル可能</em>として<code class="code-voice">_Nullable</code>注釈を使って定義された型は、スウィフトによって<em>オプショナル</em>としてインポートされます。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Types declared without a nullability annotation are imported by Swift as an <em>implicitly unwrapped optional</em>.
<br><span class="jpstr">
ヌル可能注釈を使わずに定義された型は、スウィフトによって<em>暗黙的にアンラップされるオプショナル</em>としてインポートされます。
</span><!--end_jpstr-->
</p>
</li>
</ul><p class="para">
  For example, consider the following Objective-C declarations:
<br><span class="jpstr">
例として、以下のObjective-C宣言を考えてください：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="k">@property</span> <span class="p">(</span><span class="n">nullable</span><span class="p">)</span> <span class="kt">id</span> <span class="n">nullableProperty</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@property</span> <span class="p">(</span><span class="n">nonnull</span><span class="p">)</span> <span class="kt">id</span> <span class="n">nonNullProperty</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@property</span> <span class="kt">id</span> <span class="n">unannotatedProperty</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"> 
</code></li>
            <li><code class="code-voice"><span class="n">NS_ASSUME_NONNULL_BEGIN</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">returnsNonNullValue</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">takesNonNullParameter:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">value</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="n">NS_ASSUME_NONNULL_END</span>
</code></li>
            <li><code class="code-voice"> 
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="n">nullable</span> <span class="kt">id</span><span class="p">)</span><span class="n">returnsNullableValue</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">takesNullableParameter:</span><span class="p">(</span><span class="n">nullable</span> <span class="kt">id</span><span class="p">)</span><span class="n">value</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"> 
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">returnsUnannotatedValue</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">takesUnannotatedParameter:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">value</span><span class="p">;</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how they’re imported by Swift:
<br><span class="jpstr">
ここに、どのようにそれらがスウィフトにインポートされるかがあります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">nullableProperty</span>: <span class="kt">Any</span>?</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">nonNullProperty</span>: <span class="kt">Any</span></code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">unannotatedProperty</span>: <span class="kt">Any</span>!</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">returnsNonNullValue</span>() -&gt; <span class="kt">Any</span></code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">takesNonNullParameter</span>(<span class="vc">value</span>: <span class="kt">Any</span>)</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">returnsNullableValue</span>() -&gt; <span class="kt">Any</span>?</code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">takesNullableParameter</span>(<span class="vc">value</span>: <span class="kt">Any</span>?)</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">returnsUnannotatedValue</span>() -&gt; <span class="kt">Any</span>!</code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">takesUnannotatedParameter</span>(<span class="vc">value</span>: <span class="kt">Any</span>!)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Most of the Objective-C system frameworks, including Foundation, already provide nullability annotations, allowing you to work with values in an idiomatic and type-safe manner.
<br><span class="jpstr">
ほとんどのObjective-Cシステムフレームワーク、Foundationを含む、は、すでにヌル可能注釈を提供し、あなたに慣用句的な型安全な手法で値を扱えるようにします。
</span><!--end_jpstr-->
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID220"></a>
  <h3 class="section-name" tabindex="0">Bridging Optionals to Nonnullable Objects<br><span class="jpstr">
オプショナルをnull不可オブジェクトへブリッジする
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Swift bridges optional values to nonnullable Objective-C objects according to whether the optional contains an underlying, wrapped value. If the optional is <code class="code-voice">nil</code>, Swift bridges the <code class="code-voice">nil</code> value as an <code class="code-voice">NSNull</code> instance. Otherwise, Swift bridges the optional as its unwrapped value. For example, you see this behavior when an optional is passed to an Objective-C API that takes a nonnull <code class="code-voice">id</code> and when an array of optional items (<code class="code-voice">[T?]</code>) is bridged to an <code class="code-voice">NSArray</code>.
<br><span class="jpstr">
スウィフトは、オプショナル値をnull不可Objective-Cオブジェクトへと、そのオプショナルがその下に隠している、ラップされた値を持つかどうかに従ってブリッジします。そのオプショナルが<code class="code-voice">nil</code>ならば、スウィフトはその<code class="code-voice">nil</code>値を<code class="code-voice">NSNull</code>インスタンスとしてブリッジします。そうでなければ、スウィフトはそのオプショナルをそれのアンラップされた値としてブリッジします。例えば、あなたはこの挙動を、あるオプショナルが非null <code class="code-voice">id</code>をとるObjective-C APIに渡される時、およびオプショナル項目（<code class="code-voice">[T?]</code>）からなる配列が<code class="code-voice">NSArray</code>へブリッジされる時に見ます。
</span><!--end_jpstr-->
</p><p class="para">
  The following code shows how <code class="code-voice">String?</code> instances bridge to Objective-C depending on their value.
<br><span class="jpstr">
以下のコードは、どのように<code class="code-voice">String?</code>インスタンスがObjective-Cへとそれの値に基づいてブリッジするかを示します。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="k">@implementation</span> <span class="nc">OptionalBridging</span>
</code></li>
            <li><code class="code-voice"><span class="o">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">logSomeValue:</span><span class="p">(</span><span class="n">nonnull</span> <span class="kt">id</span><span class="p">)</span><span class="n">valueFromSwift</span> <span class="p">{</span>
</code></li>
            <li><code class="code-voice">    <span class="k">if</span> <span class="p">([</span><span class="n">valueFromSwift</span> <span class="nl">isKindOfClass:</span> <span class="p">[</span><span class="n">NSNull</span> <span class="n">class</span><span class="p">]])</span> <span class="p">{</span>
</code></li>
            <li><code class="code-voice">        <span class="n">os_log</span><span class="p">(</span><span class="n">OS_LOG_DEFAULT</span><span class="p">,</span> <span class="s">&quot;Received an NSNull value.&quot;</span><span class="p">);</span>
</code></li>
            <li><code class="code-voice">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</code></li>
            <li><code class="code-voice">        <span class="n">os_log</span><span class="p">(</span><span class="n">OS_LOG_DEFAULT</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">valueFromSwift</span> <span class="n">UTF8String</span><span class="p">]);</span>
</code></li>
            <li><code class="code-voice">    <span class="p">}</span>
</code></li>
            <li><code class="code-voice"><span class="p">}</span>
</code></li>
            <li><code class="code-voice"><span class="k">@end</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Because the type of the <code class="code-voice">valueFromSwift</code> parameter is <code class="code-voice">id</code>, it’s imported in the Swift code below as the Swift type <code class="code-voice">Any</code>. However, because passing an optional when an <code class="code-voice">Any</code> was expected is uncommon, the optionals passed into the <code class="code-voice">logSomeValue(_:)</code> class method are explicitly cast to the <code class="code-voice">Any</code> type, which silences a compiler warning.
<br><span class="jpstr">
<code class="code-voice">valueFromSwift</code>パラメータの型は<code class="code-voice">id</code>であるので、それは以下のスウィフトコードにおいてスウィフト型<code class="code-voice">Any</code>としてインポートされます。しかしながら、<code class="code-voice">Any</code>が期待された時オプショナルを渡すことは普通でないため、<code class="code-voice">logSomeValue(_:)</code>メソッドへと渡されるオプショナルは明示的に<code class="code-voice">Any</code>型へキャストされます、それはコンパイラ警告を黙らせます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">someValue</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span>? = <span class="s">&quot;Bridge me, please.&quot;</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">nilValue</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span>? = <span class="kt">nil</span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">OptionalBridging</span>.<span class="vc">logSomeValue</span>(<span class="vc">someValue</span> <span class="kt">as</span> <span class="kt">Any</span>)  <span class="c">// Bridge me, please.</span></code></li>
            <li><code class="code-voice"><span class="vc">OptionalBridging</span>.<span class="vc">logSomeValue</span>(<span class="vc">nilValue</span> <span class="kt">as</span> <span class="kt">Any</span>)   <span class="c">// Received an NSNull value.&nbsp;<span class="jpstr"><span class="c">（NSNull値を受け取った。）</span></span><!--end_jpstr--></span>
</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID217"></a>
  <h3 class="section-name" tabindex="0">Protocol-Qualified Classes<br><span class="jpstr">
プロトコル適格クラス
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Objective-C protocol-qualified classes are imported by Swift as protocol type values. For example, given the following Objective-C method that performs an operation on the specified class:
<br><span class="jpstr">
Objective-Cのプロトコル適格クラスは、スウィフトによってプロトコル型値としてインポートされます。例えば、指定されたクラス上である演算を実行する以下のObjective-Cメソッドを与えられて：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">doSomethingForClass:</span><span class="p">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">NSCoding</span><span class="o">&gt;</span><span class="p">)</span><span class="n">codingClass</span><span class="p">;</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how Swift imports it:
<br><span class="jpstr">
ここにスウィフトがそれをインポートする方法があります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">doSomething</span>(<span class="vc">for</span> <span class="vc">codingClass</span>: <span class="n"><!-- a href="" -->NSCoding<!-- /a --></span>.<span class="vc">Type</span>)</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID173"></a>
  <h3 class="section-name" tabindex="0">Lightweight Generics<br><span class="jpstr">
軽量総称体
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Objective-C type declarations using lightweight generic parameterization are imported by Swift with information about the type of their contents preserved. For example, given the following Objective-C property declarations:
<br><span class="jpstr">
軽量総称体パラメーター化を使っているObjective-C宣言は、それらの保管される内容についての情報を使ってスウィフトによってインポートされます。例えば、以下のObjective-Cプロパティを与えられて：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="k">@property</span> <span class="n">NSArray</span><span class="o">&lt;</span><span class="n">NSDate</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">dates</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@property</span> <span class="n">NSCache</span><span class="o">&lt;</span><span class="n">NSObject</span> <span class="o">*</span><span class="p">,</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">NSDiscardableContent</span><span class="o">&gt;&gt;</span> <span class="o">*</span><span class="n">cachedData</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@property</span> <span class="n">NSDictionary</span> <span class="o">&lt;</span><span class="n">NSString</span> <span class="o">*</span><span class="p">,</span> <span class="n">NSArray</span><span class="o">&lt;</span><span class="n">NSLocale</span> <span class="o">*&gt;&gt;</span> <span class="o">*</span><span class="n">supportedLocales</span><span class="p">;</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how Swift imports them:
<br><span class="jpstr">
ここにどのようにスウィフトがそれらをインポートするかがあります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">dates</span>: [<span class="n"><!-- a href="" -->Date<!-- /a --></span>]</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">cachedData</span>: <span class="n"><!-- a href="" -->NSCache<!-- /a --></span>&lt;<span class="n"><!-- a href="" -->AnyObject<!-- /a --></span>, <span class="n"><!-- a href="" -->NSDiscardableContent<!-- /a --></span>&gt;</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">supportedLocales</span>: [<span class="n"><!-- a href="" -->String<!-- /a --></span>: [<span class="n"><!-- a href="" -->Locale<!-- /a --></span>]]</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  A parameterized class written in Objective-C is imported into Swift as a generic class with the same number of type parameters. All Objective-C generic type parameters imported by Swift have a type constraint that requires that type to be a class (<code class="code-voice">T: Any</code>). If the Objective-C generic parameterization specifies a class qualification, the imported Swift class has a constraint that requires that type to be a subclass of the specified class. If the Objective-C generic parameterization specifies a protocol qualification, the imported Swift class has a constraint that requires that type to conform to the specified protocol. For an unspecialized Objective-C type, Swift infers the generic parameterization for the imported class type constraints. For example, given the following Objective-C class and category declarations:
<br><span class="jpstr">
Objective-Cにおいて書かれたパラメータ化されたクラスは、同じ数の型パラメータを持つ総称体クラスとしスウィフトにインポートされます。スウィフトによってインポートされる全てのObjective-C総称体型パラメータは、ある型制約を持ちます、それはあるクラス（<code class="code-voice">T: Any</code>）であることをその型に要求します。あるクラス資格をObjective-C総称体パラメータ化が指定するならば、インポートされたスウィフトクラスはある制約を持ちます、それは指定されたクラスのサブクラスであることをその型に要求します。あるプロトコル資格をObjective-C総称体パラメータ化が指定するならば、インポートされたスウィフトクラスはある制約を持ちます、それは指定されたプロトコルに準拠することをその型に要求します。特殊化されないObjective-C型に対して、スウィフトは総称体パラメータ化をインポートされたクラス型制約に対して推測します。例えば、以下のObjective-Cクラスおよびカテゴリ定義を与えられて：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="k">@interface</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nl">T:</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">NSCopying</span><span class="o">&gt;&gt;</span> <span class="o">:</span> <span class="n">NSObject</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nl">listByAppendingItemsInList:</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">otherList</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@end</span>
</code></li>
            <li><code class="code-voice"> 
</code></li>
            <li><code class="code-voice"><span class="k">@interface</span> <span class="nc">ListContainer</span> : <span class="nc">NSObject</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">NSValue</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">listOfValues</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@end</span>
</code></li>
            <li><code class="code-voice"> 
</code></li>
            <li><code class="code-voice"><span class="k">@interface</span> <span class="nc">ListContainer</span> <span class="nl">(ObjectList)</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="n">List</span> <span class="o">*</span><span class="p">)</span><span class="n">listOfObjects</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@end</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how they’re imported by Swift:
<br><span class="jpstr">
ここに、どのようにそれらがスウィフトにインポートされるかがあります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">List</span>&lt;<span class="vc">T</span>: <span class="n"><!-- a href="" -->NSCopying<!-- /a --></span>&gt; : <span class="n"><!-- a href="" -->NSObject<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">func</span> <span class="vc">listByAppendingItemsInList</span>(<span class="vc">otherList</span>: <span class="n"><!-- a href="" -->List<!-- /a --></span>&lt;<span class="n"><!-- a href="" -->T<!-- /a --></span>&gt;) -&gt; <span class="n"><!-- a href="" -->List<!-- /a --></span>&lt;<span class="n"><!-- a href="" -->T<!-- /a --></span>&gt;</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">ListContainer</span> : <span class="n"><!-- a href="" -->NSObject<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">func</span> <span class="vc">listOfValues</span>() -&gt; <span class="n"><!-- a href="" -->List<!-- /a --></span>&lt;<span class="n"><!-- a href="" -->NSValue<!-- /a --></span>&gt;</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">extension</span> <span class="n"><!-- a href="" -->ListContainer<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">func</span> <span class="vc">listOfObjects</span>() -&gt; <span class="n"><!-- a href="" -->List<!-- /a --></span>&lt;<span class="n"><!-- a href="" -->NSCopying<!-- /a --></span>&gt;</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID47"></a>
  <h3 class="section-name" tabindex="0">Extensions<br><span class="jpstr">
拡張
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A Swift extension is similar to an Objective-C category. <em>Extensions</em> expand the behavior of existing classes, structures, and enumerations, including those defined in Objective-C. You can define an extension on a type from either a system framework or one of your own custom types. Simply import the appropriate module, and refer to the class, structure, or enumeration by the same name that you would use in Objective-C.
<br><span class="jpstr">
スウィフトの拡張は、Objective-Cのカテゴリーに似ています。<em>拡張</em>は、既存のクラス、構造体、そして列挙の挙動を、Objective-Cで定義されるそれらを含めて、発展させます。あなたは、システム・フレームワークから、またはあなた独自のあつらえの型の１つから、そのどちらかの型の上で拡張を定義することができます。単に適切なモジュールをインポートしてください、そしてあなたがObjective-Cで使うだろうのと同じ名前によって、そのクラス、構造体、または列挙を参照してください。
</span><!--end_jpstr-->
</p><p class="para">
  For example, you can extend the <code class="code-voice">UIBezierPath</code> class to create a simple Bézier path with an equilateral triangle, based on a provided side length and starting point.
<br><span class="jpstr">
例えば、あなたは<code class="code-voice">UIBezierPath</code>クラスを拡張して、二等辺三角形を使った単純な「ベジェ」パスを作成するようにできます、それは提供された辺長と開始点に基づきます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">extension</span> <span class="n"><!-- a href="" -->UIBezierPath<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">convenience</span> <span class="kt">init</span>(<span class="vc">triangleSideLength</span>: <span class="n"><!-- a href="" -->CGFloat<!-- /a --></span>, <span class="vc">origin</span>: <span class="n"><!-- a href="" -->CGPoint<!-- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="kt">init</span>()</code></li>
            <li><code class="code-voice">        <span class="kt">let</span> <span class="vc">squareRoot</span> = <span class="vc">CGFloat</span>(<span class="vc">sqrt</span>(<span class="m">3.0</span>))</code></li>
            <li><code class="code-voice">        <span class="kt">let</span> <span class="vc">altitude</span> = (<span class="vc">squareRoot</span> * <span class="vc">triangleSideLength</span>) / <span class="m">2</span></code></li>
            <li><code class="code-voice">        <span class="vc">move</span>(<span class="vc">to</span>: <span class="vc">origin</span>)</code></li>
            <li><code class="code-voice">        <span class="vc">addLine</span>(<span class="vc">to</span>: <span class="vc">CGPoint</span>(<span class="vc">x</span>: <span class="vc">origin</span>.<span class="vc">x</span> + <span class="vc">triangleSideLength</span>, <span class="vc">y</span>: <span class="vc">origin</span>.<span class="vc">y</span>))</code></li>
            <li><code class="code-voice">        <span class="vc">addLine</span>(<span class="vc">to</span>: <span class="vc">CGPoint</span>(<span class="vc">x</span>: <span class="vc">origin</span>.<span class="vc">x</span> + <span class="vc">triangleSideLength</span> / <span class="m">2</span>, <span class="vc">y</span>: <span class="vc">origin</span>.<span class="vc">y</span> + <span class="vc">altitude</span>))</code></li>
            <li><code class="code-voice">        <span class="vc">close</span>()</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can use extensions to add properties (including class and static properties). However, these properties must be computed; extensions can’t add stored properties to classes, structures, or enumerations.
<br><span class="jpstr">
あなたは、拡張を使ってプロパティ（クラスや静的なプロパティを含む）を加えることができます。しかし、これらのプロパティは、計算されなければなりません；拡張は、保存プロパティをクラス、構造体、または列挙に加えることができません。
</span><!--end_jpstr-->
</p><p class="para">
  This example extends the <code class="code-voice">CGRect</code> structure to contain a computed <code class="code-voice">area</code> property:
<br><span class="jpstr">
この例は、<code class="code-voice">CGRect</code>構造体を拡張して、計算<code class="code-voice">area</code>プロパティを含むようにします：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">extension</span> <span class="n"><!-- a href="" -->CGRect<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">area</span>: <span class="n"><!-- a href="" -->CGFloat<!-- /a --></span> {</code></li>
            <li><code class="code-voice">        <span class="kt">return</span> <span class="vc">width</span> * <span class="vc">height</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">rect</span> = <span class="vc">CGRect</span>(<span class="vc">x</span>: <span class="m">0.0</span>, <span class="vc">y</span>: <span class="m">0.0</span>, <span class="vc">width</span>: <span class="m">10.0</span>, <span class="vc">height</span>: <span class="m">50.0</span>)</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">area</span> = <span class="vc">rect</span>.<span class="vc">area</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can also use extensions to add protocol conformance to a class without subclassing it. If the protocol is defined in Swift, you can also add conformance to it to structures or enumerations, whether defined in Swift or Objective-C.
<br><span class="jpstr">
あなたはまた拡張を使って、プロトコル準拠をあるクラスに、それをサブクラス化することなく加えることができます。そのプロトコルがスウィフトにおいて定義されるならば、スウィフトまたはObjective-Cで定義されるかに関係なく、あなたは同様にそれに対する準拠を構造体または列挙に加えることができます。
</span><!--end_jpstr-->
</p><p class="para">
  You cannot use extensions to override existing methods or properties on Objective-C types.
<br><span class="jpstr">
あなたは、Objective-C型上での既存のメソッドまたはプロパティをオーバーライドするために拡張を使うことができません。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID49"></a>
  <h3 class="section-name" tabindex="0">Closures<br><span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Objective-C blocks are automatically imported as Swift closures with Objective-C block calling convention, denoted by the <code class="code-voice">@convention(block)</code> attribute. For example, here is an Objective-C block variable:
<br><span class="jpstr">
Objective-Cのブロックは、Objective-Cのブロック呼出規約をもつスウィフトのクロージャとして自動的にインポートされ、それは<code class="code-voice">@convention(block)</code>属性で分かります。例えば、ひとつのObjective-Cブロック変数がここにあります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">completionBlock</span><span class="p">)(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</code></li>
            <li><code class="code-voice">   <span class="c1">// ...</span>
</code></li>
            <li><code class="code-voice"><span class="p">}</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  And here’s what it looks like in Swift:
<br><span class="jpstr">
そして、それがスウィフトではどんなものになるかがここにあります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">completionBlock</span>: (<span class="n"><!-- a href="" -->Data<!-- /a --></span>) -&gt; <span class="n"><!-- a href="" -->Void<!-- /a --></span> = { <span class="vc">data</span> <span class="kt">in</span></code></li>
            <li><code class="code-voice">    <span class="c">// ...</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Swift closures and Objective-C blocks are compatible, so you can pass Swift closures to Objective-C methods that expect blocks. Swift closures and functions have the same type, so you can even pass the name of a Swift function.
<br><span class="jpstr">
スウィフトのクロージャとObjective-Cのブロックは互換性を持つので、ブロックを要求するObjective-Cメソッドに、あなたはスウィフトクロージャを渡すことができます。スウィフトのクロージャと関数は同じ型を持つので、あなたはスウィフト関数の名前を渡しさえすることができます。
</span><!--end_jpstr-->
</p><p class="para">
  Closures have similar capture semantics as blocks but differ in one key way: Variables are mutable rather than copied. In other words, the behavior of <code class="code-voice">__block</code> in Objective-C is the default behavior for variables in Swift.
<br><span class="jpstr">
クロージャは、ブロックとしての類似したキャプチャ意味論を持ちますが、１つの重要なやり方において異なります：変数は、コピーされるのではなく、可変です。言い換えると、Objective-Cでの<code class="code-voice">__block</code>の挙動は、スウィフトの中の変数のための初期状態での挙動です。
</span><!--end_jpstr-->
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID186"></a>
  <h3 class="section-name" tabindex="0">Avoiding Strong Reference Cycles When Capturing self<br><span class="jpstr">
強い参照循環を自身をキャプチャするときに避ける
</span><!--end_jpstr-->
</h3>
  <p class="para">
  In Objective-C, if you need to capture <code class="code-voice">self</code> in a block, it’s important to consider the memory management implications.
<br><span class="jpstr">
Objective-Cにおいて、あなたが<code class="code-voice">self</code>をあるブロックにおいてキャプチャする必要があるならば、メモリ管理の影響を考慮することが重要です。
</span><!--end_jpstr-->
</p><p class="para">
  Blocks maintain strong references to any captured objects, including <code class="code-voice">self</code>. If <code class="code-voice">self</code> maintains a strong reference to the block, such as a copying property, this would create a strong reference cycle. To avoid this, you can instead have the block capture a weak reference to <code class="code-voice">self</code>:
<br><span class="jpstr">
ブロックは、<code class="code-voice">self</code>を含めて、あらゆるキャプチャされるオブジェクトに対する強い参照を管理します。<code class="code-voice">self</code>がブロックに対する強い参照を管理するならば、これは強い参照循環を作り出すでしょう。これを避けるために、あなたは代わりにブロックが<code class="code-voice">self</code>に対する弱い参照をキャプチャするようにできます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="n">__weak</span> <span class="n">typeof</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="n">self</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</code></li>
            <li><code class="code-voice">   <span class="n">__strong</span> <span class="n">typeof</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice">   <span class="p">[</span><span class="n">strongSelf</span> <span class="n">doSomething</span><span class="p">];</span>
</code></li>
            <li><code class="code-voice"><span class="p">};</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Like blocks in Objective-C, closures in Swift also maintain strong references to any captured objects, including <code class="code-voice">self</code>. To prevent a strong reference cycle, you can specify <code class="code-voice">self</code> to be <code class="code-voice">unowned</code> in a closure’s capture list:
<br><span class="jpstr">
Objective-Cでのブロックのように、スウィフトでのクロージャもまた、<code class="code-voice">self</code>を含めて、あらゆるキャプチャされたオブジェクトに対する強い参照を管理します。強い参照循環を防ぐために、あなたは<code class="code-voice">self</code>を<code class="code-voice">unowned</code>であるとクロージャのキャプチャリストにおいて指定することができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">self</span>.<span class="vc">closure</span> = { [<span class="vc">unowned</span> <span class="kt">self</span>] <span class="kt">in</span></code></li>
            <li><code class="code-voice">    <span class="kt">self</span>.<span class="vc">doSomething</span>()</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  For more information, see <a href="../Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID57" data-renderer-version="2" target="_self">Resolving Strong Reference Cycles for Closures</a> in <em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">The Swift Programming Language (Swift 4)</a></em>.
<br><span class="jpstr">
更なる情報として、<a href="../Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID57" data-renderer-version="2" target="_self">クロージャのための強い参照循環の解消</a>を<em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">スウィフトプログラミング言語（Swift 4）</a></em>で見てください。
</span><!--end_jpstr-->
</p>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID51"></a>
  <h3 class="section-name" tabindex="0">Object Comparison<br><span class="jpstr">
オブジェクト比較
</span><!--end_jpstr-->
</h3>
  <p class="para">
  There are two distinct types of comparison you can make between two objects in Swift. The first, <em>equality</em> (<code class="code-voice">==</code>), compares the contents of the objects. The second, <em>identity</em> (<code class="code-voice">===</code>), determines whether or not the constants or variables refer to the same object instance.
<br><span class="jpstr">
あなたがスウィフトにおいて２つのオブジェクトの間に作ることができる比較には２つの別個の型があります。１つめ、<em>同等性</em>（<code class="code-voice">==</code>）は、オブジェクトの内容を比較します。２つめ、<em>同一性</em>（<code class="code-voice">===</code>）は、定数または変数が同じオブジェクトインスタンスに言及するかどうかを確認します。
</span><!--end_jpstr-->
</p><p class="para">
  Swift provides default implementations of the <code class="code-voice">==</code> and <code class="code-voice">===</code> operators and adopts the <code class="code-voice">Equatable</code> protocol for objects that derive from the <code class="code-voice">NSObject</code> class. The default implementation of the <code class="code-voice">==</code> operator invokes the <code class="code-voice">isEqual:</code> method, and the default implementation of the <code class="code-voice">===</code> operator checks pointer equality. You should not override the equality or identity operators for types imported from Objective-C.
<br><span class="jpstr">
スウィフトは、<code class="code-voice">==</code>と<code class="code-voice">===</code>演算子の省略時の実装を提供します、そして<code class="code-voice">Equatable</code>プロトコルを<code class="code-voice">NSObject</code>クラス由来のオブジェクトに対して採用します。<code class="code-voice">==</code>演算子の省略時の実装は、<code class="code-voice">isEqual:</code>メソッドを発動します、そして<code class="code-voice">===</code>演算子の省略時の実装はポインタの同等性を調べます。あなたは、Objective-Cからインポートされた型に対する同等性または同一性演算子をオーバーライドすべきではありません。
</span><!--end_jpstr-->
</p><p class="para">
  The base implementation of the <code class="code-voice">isEqual:</code> provided by the <code class="code-voice">NSObject</code> class is equivalent to an identity check by pointer equality. You can override <code class="code-voice">isEqual:</code> in a subclass to have Swift and Objective-C APIs determine equality based on the contents of objects rather than their identities. For more information about implementing comparison logic, see <a href="../../../General/Conceptual/DevPedia-CocoaCore/ObjectComparison.html#//apple_ref/doc/uid/TP40008195-CH37" data-renderer-version="1" target="_self">Object comparison</a> in <em>Cocoa Core Competencies</em>.
<br><span class="jpstr">
<code class="code-voice">NSObject</code>クラスによって提供される<code class="code-voice">isEqual:</code>の基本実装は、ポインタ同等性による同一性確認に等しいものです。あなたは、<code class="code-voice">isEqual:</code>をサブクラスにおいてオーバーライドして、それらの同一性ではなくてオブジエクトの内容に基づいて同等性を判断するスウィフトとObjective-C APIを持つことができます。比較ロジックの実装についての更なる情報として、<a href="../../../General/Conceptual/DevPedia-CocoaCore/ObjectComparison.html#//apple_ref/doc/uid/TP40008195-CH37" data-renderer-version="1" target="_self">Object comparison</a>を<em>Cocoa Core Competencies</em>で見てください。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-NoLink_7"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Swift automatically provides implementations for the logical complements of the equality and identity operators (<code class="code-voice">!=</code> and <code class="code-voice">!==</code>). These should not be overridden.
    	<br><span class="jpstr">
スウィフトは、同等性と同一性演算子の論理上当然な補完物（<code class="code-voice">!=</code>と<code class="code-voice">!==</code>）に対する実装を自動的に提供します。これらはオーバーライドされるべきではありません。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID197"></a>
  <h3 class="section-name" tabindex="0">Hashing<br><span class="jpstr">
ハッシュ化
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Swift imports Objective-C declarations of <code class="code-voice">NSDictionary</code> that don’t specify a class qualification for the key type as a <code class="code-voice">Dictionary</code> with the <code class="code-voice">Key</code> type <code class="code-voice">AnyHashable</code>. Similarly, <code class="code-voice">NSSet</code> declarations without a class-qualified object type are imported by Swift as a <code class="code-voice">Set</code> with the <code class="code-voice">Element</code> type <code class="code-voice">AnyHashable</code>. If an <code class="code-voice">NSDictionary</code> or <code class="code-voice">NSSet</code> declaration does parameterize its key or object type, respectively, that type is used instead. For example, given the following Objective-C declarations:
<br><span class="jpstr">
スウィフトは、キー型に対してクラス資格を指定しない<code class="code-voice">NSDictionary</code>のObjective-C宣言を、<code class="code-voice">Key</code>型<code class="code-voice">AnyHashable</code>を持つ<code class="code-voice">Dictionary</code>としてインポートします。同様に、クラス適格オブジェクト型なしでの<code class="code-voice">NSSet</code>宣言は、スウィフトによって<code class="code-voice">Element</code>型<code class="code-voice">AnyHashable</code>を持つ<code class="code-voice">Set</code>としてインポートされます。ある<code class="code-voice">NSDictionary</code>または<code class="code-voice">NSSet</code>宣言がそれのキーまたはオブジェクト型をパラメータ化するならば、それぞれ、その型が代わりに使われます。例えば、以下のObjective-C宣言を与えられて：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="k">@property</span> <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">unqualifiedDictionary</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@property</span> <span class="n">NSDictionary</span><span class="o">&lt;</span><span class="n">NSString</span> <span class="o">*</span><span class="p">,</span> <span class="n">NSDate</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">qualifiedDictionary</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"> 
</code></li>
            <li><code class="code-voice"><span class="k">@property</span> <span class="n">NSSet</span> <span class="o">*</span><span class="n">unqualifiedSet</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@property</span> <span class="n">NSSet</span><span class="o">&lt;</span><span class="n">NSString</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">qualifiedSet</span><span class="p">;</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how Swift imports them:
<br><span class="jpstr">
ここにどのようにスウィフトがそれらをインポートするかがあります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">unqualifiedDictionary</span>: [<span class="n"><!-- a href="" -->AnyHashable<!-- /a --></span>: <span class="kt">Any</span>]</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">qualifiedDictionary</span>: [<span class="n"><!-- a href="" -->String<!-- /a --></span>: <span class="n"><!-- a href="" -->Date<!-- /a --></span>]</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">unqualifiedSet</span>: <span class="n"><!-- a href="" -->Set<!-- /a --></span>&lt;<span class="n"><!-- a href="" -->AnyHashable<!-- /a --></span>&gt;</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">qualifiedSet</span>: <span class="n"><!-- a href="" -->Set<!-- /a --></span>&lt;<span class="n"><!-- a href="" -->String<!-- /a --></span>&gt;</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The <code class="code-voice">AnyHashable</code> type is used by Swift when importing Objective-C declarations with an unspecified or <code class="code-voice">id</code> type that cannot be otherwise be imported as <code class="code-voice">Any</code> because the type needs to conform to the <code class="code-voice">Hashable</code> protocol. The <code class="code-voice">AnyHashable</code> type is implicitly converted from any <code class="code-voice">Hashable</code> type, and you can use the <code class="code-voice">as?</code> and <code class="code-voice">as!</code> operators to cast from <code class="code-voice">AnyHashable</code> to a more specific type.
<br><span class="jpstr">
<code class="code-voice">AnyHashable</code>型は、スウィフトによって、<code class="code-voice">id</code>または未指定型を持つObjective-C宣言をインポートする時に使われます、それはそうでなければ<code class="code-voice">Any</code>としてインポートされることができません、なぜならその型は<code class="code-voice">Hashable</code>プロトコルに準拠する必要があるからです。<code class="code-voice">AnyHashable</code>型は暗黙的に何らかの<code class="code-voice">Hashable</code>型から変換されます、そしてあなたは<code class="code-voice">as?</code>および<code class="code-voice">as!</code>演算子を使って<code class="code-voice">AnyHashable</code>からより具体的な型へキャストできます。
</span><!--end_jpstr-->
</p><p class="para">
  For more information, see <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/anyhashable" class="urlLink">AnyHashable</a></code>.
<br><span class="jpstr">
詳細は、<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/anyhashable" class="urlLink">AnyHashable</a></code>を見てください。
</span><!--end_jpstr-->
</p>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID53"></a>
  <h3 class="section-name" tabindex="0">Swift Type Compatibility<br><span class="jpstr">
スウィフト型互換性
</span><!--end_jpstr-->
</h3>
  <p class="para">
  When you create a Swift class that descends from an Objective-C class, the class and its members—properties, methods, subscripts, and initializers—that are compatible with Objective-C are automatically available from Objective-C. This excludes Swift-only features, such as those listed here:
<br><span class="jpstr">
あなたがObjective-Cクラス由来のスウィフトクラスを作成するとき、そのクラスおよびObjective-C互換のそれのメンバー ― プロパティ、メソッド、添え字、そしてイニシャライザ ― は、自動的にObjective-Cから利用可能です。これは、ここに一覧にされるようなスウィフトのみの機能を除外します：
</span><!--end_jpstr-->
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  Generics
<br><span class="jpstr">
総称体
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Tuples
<br><span class="jpstr">
タプル
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Enumerations defined in Swift without <code class="code-voice">Int</code> raw value type
<br><span class="jpstr">
<code class="code-voice">Int</code>の生の値型なしでスウィフトにおいて定義される列挙
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Structures defined in Swift
<br><span class="jpstr">
スウィフトにおいて定義される構造体
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Top-level functions defined in Swift
<br><span class="jpstr">
スウィフトにおいて定義されるトップレベル関数
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Global variables defined in Swift
<br><span class="jpstr">
スウィフトにおいて定義されるグローバル変数
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Typealiases defined in Swift
<br><span class="jpstr">
スウィフトにおいて定義される型エイリアス
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Swift-style variadics
<br><span class="jpstr">
スウィフト形式の可変長引数
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Nested types
<br><span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Curried functions
<br><span class="jpstr">
カリー化関数
</span><!--end_jpstr-->
</p>
</li>
</ul><p class="para">
  Swift APIs are translated into Objective-C similar to how Objective-C APIs are translated into Swift, but in reverse:
<br><span class="jpstr">
スウィフトのAPIは、Objective-C APIがスウィフトへと翻訳される方法と同じように、しかし逆に、Objective-Cへと翻訳されます：
</span><!--end_jpstr-->
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  Swift optional types are annotated as <code class="code-voice">__nullable</code>.
<br><span class="jpstr">
スウィフトのオプショナル型は、<code class="code-voice">__nullable</code>として注釈を付けられます。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Swift nonoptional types are annotated as <code class="code-voice">__nonnull</code>.
<br><span class="jpstr">
スウィフトの非オプショナル型は、<code class="code-voice">__nonnull</code>として注釈を付けられます。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Swift constant stored properties and computed properties become read-only Objective-C properties.
<br><span class="jpstr">
スウィフトの定数保存プロパティと計算プロパティは、読出し専用Objecive-Cプロパティになります。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Swift variable stored properties become read-write Objective-C properties.
<br><span class="jpstr">
スウィフトの変数保存プロパティは、読み書き両用のObjective-Cプロパティになります。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Swift type properties become Objective-C properties with the <code class="code-voice">class</code> property attribute.
<br><span class="jpstr">
スウィフト型プロパティは、<code class="code-voice">class</code>プロパティ属性を持つObjective-Cプロパティになります。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Swift type methods become Objective-C class methods.
<br><span class="jpstr">
スウィフトの型メソッドは、Objective-Cクラスメソッドになります。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Swift initializers and instance methods become Objective-C instance methods.
<br><span class="jpstr">
スウィフトのイニシャライザとインスタンスメソッドは、Objective-Cインスタンスメソッドになります。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Swift methods that throw errors become Objective-C methods with an <code class="code-voice">NSError **</code> parameter. If the Swift method has no parameters, <code class="code-voice">AndReturnError:</code> is appended to the Objective-C method name, otherwise <code class="code-voice">error:</code> is appended. If a Swift method does not specify a return type, the corresponding Objective-C method has a <code class="code-voice">BOOL</code> return type. If the Swift method returns a nonoptional type, the corresponding Objective-C method has an optional return type.
<br><span class="jpstr">
エラーをスローするスウィフトメソッドは、<code class="code-voice">NSError **</code>パラメータを持つObjective-Cメソッドになります。そのスウィフトメソッドがパラメータを持たないならば、<code class="code-voice">AndReturnError:</code>がObjective-Cメソッド名に加えられ、そうでないならば<code class="code-voice">error:</code>が加えられます。そのスウィフトメソッドが戻り型を指定しないならば、対応するObjective-Cメソッドは<code class="code-voice">BOOL</code>の戻り型を持ちます。そのスウィフトメソッドが非オプショナル型を返すならば、対応するObjective-Cメソッドはオプショナルの戻り型を持ちます。
</span><!--end_jpstr-->
</p>
</li>
</ul><p class="para">
  For example, consider the following Swift declaration:
<br><span class="jpstr">
例として、以下のスウィフト宣言を考えてください：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">Jukebox</span>: <span class="n"><!-- a href="" -->NSObject<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">library</span>: <span class="n"><!-- a href="" -->Set<!-- /a --></span>&lt;<span class="n"><!-- a href="" -->String<!-- /a --></span>&gt;</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">nowPlaying</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span>?</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">isCurrentlyPlaying</span>: <span class="n"><!-- a href="" -->Bool<!-- /a --></span> {</code></li>
            <li><code class="code-voice">        <span class="kt">return</span> <span class="vc">nowPlaying</span> != <span class="kt">nil</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">class</span> <span class="kt">var</span> <span class="vc">favoritesPlaylist</span>: [<span class="n"><!-- a href="" -->String<!-- /a --></span>] {</code></li>
            <li><code class="code-voice">        <span class="c">// return an array of song names</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">songs</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span>...) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">library</span> = <span class="vc">Set</span>&lt;<span class="n"><!-- a href="" -->String<!-- /a --></span>&gt;(<span class="vc">songs</span>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">func</span> <span class="vc">playSong</span>(<span class="vc">named</span> <span class="vc">name</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span>) <span class="kt">throws</span> {</code></li>
            <li><code class="code-voice">        <span class="c">// play song or throw an error if unavailable&nbsp;<span class="jpstr">（曲を再生するか利用可能でないならばエラーをスローする）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how it’s imported by Objective-C:
<br><span class="jpstr">
ここにそれがObjective-Cによってインポートされる方法があります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="k">@interface</span> <span class="nc">Jukebox</span> : <span class="nc">NSObject</span>
</code></li>
            <li><code class="code-voice"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">)</span> <span class="n">NSSet</span><span class="o">&lt;</span><span class="n">NSString</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">library</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">nowPlaying</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">getter</span><span class="o">=</span><span class="n">isCurrentlyPlaying</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">currentlyPlaying</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">class</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">)</span> <span class="n">NSArray</span><span class="o">&lt;</span><span class="n">NSString</span> <span class="o">*&gt;</span> <span class="o">*</span> <span class="n">favoritesPlaylist</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="n">nonnull</span> <span class="n">instancetype</span><span class="p">)</span><span class="nl">initWithSongs:</span><span class="p">(</span><span class="n">NSArray</span><span class="o">&lt;</span><span class="n">NSString</span> <span class="o">*&gt;</span> <span class="o">*</span> <span class="n">__nonnull</span><span class="p">)</span><span class="n">songs</span> <span class="n">OBJC_DESIGNATED_INITIALIZER</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nl">playSong:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span> <span class="n">__nonnull</span><span class="p">)</span><span class="n">name</span> <span class="nl">error:</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span> <span class="n">__nullable</span> <span class="o">*</span> <span class="n">__null_unspecified</span><span class="p">)</span><span class="n">error</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@end</span>
</code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-NoLink_8"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">You cannot subclass a Swift class in Objective-C.
    	<br><span class="jpstr">
あなたは、スウィフトクラスのサブクラスをObjective-Cにおいて作成できません。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID55"></a>
  <h3 class="section-name" tabindex="0">Configuring Swift Interfaces in Objective-C<br><span class="jpstr">
スウィフトインターフェイスをObjective-Cにおいて構成する
</span><!--end_jpstr-->
</h3>
  <p class="para">
  In some cases, you need finer grained control over how your Swift API is exposed to Objective-C. You can use the <code class="code-voice">@objc(</code><em>name</em><code class="code-voice">)</code> attribute to change the name of a class, property, method, enumeration type, or enumeration case declaration in your interface as it’s exposed to Objective-C code.
<br><span class="jpstr">
いくつかの場合に、あなたはよりきめ細かな管理をあなたのスウィフト APIがObjective-Cに露出される方法に対して必要とします。あなたは、<code class="code-voice">@objc(</code><em>name</em><code class="code-voice">)</code>属性を使うことで、あなたのインターフェイスにおいてクラス、プロパティ、メソッド、列挙型、または列挙ケース宣言の名前を変更することがそれがObjective-Cコードに露出されるときに可能です。
</span><!--end_jpstr-->
</p><p class="para">
  For example, if the name of your Swift class contains a character that isn’t supported by Objective-C, you can provide an alternative name to use in Objective-C. If you provide an Objective-C name for a Swift function, use Objective-C selector syntax. Remember to add a colon (<code class="code-voice">:</code>) wherever a parameter follows a selector piece.
<br><span class="jpstr">
例えば、あなたのスウィフトクラスの名前がObjective-Cで支持されない文字を含むならば、あなたはObjective-Cで使うために代わりの名前を提供することができます。あなたがあるObjective-C名をスウィフト関数のために用意する場合は、Objective-Cセレクタ構文を使ってください。あるセレクタ片にパラメータが続くところはどこにでも、コロン（<code class="code-voice">:</code>）を加えるのを忘れないでください。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">@objc</span>(<span class="vc">Color</span>)</code></li>
            <li><code class="code-voice"><span class="kt">enum</span> <span class="vc">Цвет</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    @objc(<span class="vc">Red</span>)</code></li>
            <li><code class="code-voice">    <span class="kt">case</span> <span class="vc">Красный</span></code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    @objc(<span class="vc">Black</span>)</code></li>
            <li><code class="code-voice">    <span class="kt">case</span> <span class="vc">Черный</span></code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">@objc</span>(<span class="vc">Squirrel</span>)</code></li>
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">Белка</span>: <span class="n"><!-- a href="" -->NSObject<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">@objc</span>(<span class="vc">color</span>)</code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">цвет</span>: <span class="n"><!-- a href="" -->Цвет<!-- /a --></span> = .<span class="vc">Красный</span></code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">@objc</span>(<span class="vc">initWithName</span>:)</code></li>
            <li><code class="code-voice">    <span class="kt">init</span> (<span class="vc">имя</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="c">// ...</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    <span class="kt">@objc</span>(<span class="vc">hideNuts</span>:<span class="vc">inTree</span>:)</code></li>
            <li><code class="code-voice">    <span class="kt">func</span> <span class="vc">прячьОрехи</span>(<span class="vc">количество</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>, <span class="vc">вДереве</span> <span class="vc">дерево</span>: <span class="n"><!-- a href="" -->Дерево<!-- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="c">// ...</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  When you use the <code class="code-voice">@objc(</code><em>name</em><code class="code-voice">)</code> attribute on a Swift class, the class is made available in Objective-C without any namespacing. As a result, this attribute can also be useful when migrating an archivable Objective-C class to Swift. Because archived objects store the name of their class in the archive, you should use the <code class="code-voice">@objc(</code><em>name</em><code class="code-voice">)</code> attribute to specify the same name as your Objective-C class so that older archives can be unarchived by your new Swift class.
<br><span class="jpstr">
あなたがスウィフトクラス上で<code class="code-voice">@objc(</code><em>name</em><code class="code-voice">)</code>属性を使うとき、そのクラスは何ら名前空間操作なしにObjective-Cで利用できるようにされます。その結果、この属性はまた、アーカイブできるObjective-Cクラスをスウィフトに移行するとき便利でありえます。アーカイブされたオブジェクトがそれらのクラスの名前をアーカイブに格納するので、あなたは<code class="code-voice">@objc(</code><em>name</em><code class="code-voice">)</code>属性を使ってあなたのObjective-Cクラスと同じ名前を指定しなければなりません、それでちょっと古くなったアーカイブがあなたの新しいスウィフトクラスによってアンアーカイブされることができます。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-NoLink_9"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Conversely, Swift also provides the <code class="code-voice">@nonobjc</code> attribute, which makes a Swift declaration unavailable in Objective-C. You can use it to resolve circularity for bridging methods and to allow overloading of methods for classes imported by Objective-C. If an Objective-C method is overridden by a Swift method that cannot be represented in Objective-C, such as by specifying a parameter to be a variable, that method must be marked <code class="code-voice">@nonobjc</code>.
    	<br><span class="jpstr">
逆に、スウィフトはまた<code class="code-voice">@nonobjc</code>属性も提供します、それはあるスウィフト宣言をObjective-Cにおいて利用不可能にします。あなたはそれを使って、メソッドをブリッジすることの循環性を解決して、Objective-Cでインポートされるクラスに対してメソッドのオーバーロードを可能にします。あるObjective-Cメソッドが、Objective-Cでは表現できないスウィフトメソッドによって、たとえばあるパラメータを変数であるとして指定することなどによって、オーバーライドされるならば、そのメソッドは<code class="code-voice">@nonobjc</code>と印されなければなりません。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID57"></a>
  <h3 class="section-name" tabindex="0">Requiring Dynamic Dispatch<br><span class="jpstr">
動的なディスパッチを要求する
</span><!--end_jpstr-->
</h3>
  <p class="para">
  When Swift APIs are imported by the Objective-C runtime, there are no guarantees of dynamic dispatch for properties, methods, subscripts, or initializers. The Swift compiler may still devirtualize or inline member access to optimize the performance of your code, bypassing the Objective-C runtime.
<br><span class="jpstr">
スウィフト APIがObjective-Cランタイムによってインポートされる時、プロパティ、メソッド、添え字、またはイニシャライザに対する動的ディスパッチの保証はありません。スウィフトのコンパイラは、Objective-Cランタイムを迂回して、あなたのコードの性能を最適化するために、依然としてデバーチャライズまたはインラインでメンバーにアクセスをします。
</span><!--end_jpstr-->
</p><p class="para">
  You can use the <code class="code-voice">dynamic</code> modifier to require that access to members be dynamically dispatched through the Objective-C runtime. Requiring dynamic dispatch is rarely necessary. However, it is necessary when using APIs like key–value observing or the <code class="code-voice">method_exchangeImplementations</code> function in the Objective-C runtime, which dynamically replace the implementation of a method at runtime. If the Swift compiler inlined the implementation of the method or devirtualized access to it, the new implementation would not be used.
<br><span class="jpstr">
あなたは、<code class="code-voice">dynamic</code>修飾子を使うことで、メンバに対するアクセスがObjective-Cランタイムを通して動的にディスパッチされることを要求できます。動的なディスパッチを要求することは、めったに必要ではありません。しかしながら、それが必要であるのは、キー値監視または<code class="code-voice">method_exchangeImplementations</code>関数のようなAPIをObjective-Cランタイムにおいて使う時です、それはあるメソッドの実装を実行時に動的に置き換えます。スウィフトコンパイラがメソッドの実装をインラインにした、またはそれへのアクセスをまたはデバーチャライズしたならば、新しい実装は使用されないでしょう。
</span><!--end_jpstr-->
</p><p class="para">
  Declarations marked with the <code class="code-voice">dynamic</code> modifier must also be explicitly marked with the <code class="code-voice">@objc</code> attribute unless the <code class="code-voice">@objc</code> attribute is implicitly added by the declaration’s context. For information about when the <code class="code-voice">@objc</code> attribute is implicitly added, see <a href="../Swift_Programming_Language/Attributes.html#//apple_ref/doc/uid/TP40014097-CH35-ID348" data-renderer-version="2" target="_self">Declaration Attributes</a> in <em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">The Swift Programming Language (Swift 4)</a></em>.
<br><span class="jpstr">
<code class="code-voice">dynamic</code>修飾子で印される宣言はまた、明示的に<code class="code-voice">@objc</code>属性で印されなければなりません、<code class="code-voice">@objc</code>属性が暗黙的にその宣言の持つ文脈によって加えられるのでない限り。<code class="code-voice">@objc</code>属性が暗黙的に加えられる場合についての情報として、<a href="../Swift_Programming_Language/Attributes.html#//apple_ref/doc/uid/TP40014097-CH35-ID348" data-renderer-version="2" target="_self">宣言属性</a>を<em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">スウィフトプログラミング言語（Swift 4）</a></em>で見てください。
</span><!--end_jpstr-->
</p>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID59"></a>
  <h3 class="section-name" tabindex="0">Selectors<br><span class="jpstr">
セレクタ
</span><!--end_jpstr-->
</h3>
  <p class="para">
  In Objective-C, a selector is a type that refers to the name of an Objective-C method. In Swift, Objective-C selectors are represented by the <code class="code-voice">Selector</code> structure, and can be constructed using the <code class="code-voice">#selector</code> expression. To create a selector for a method that can be called from Objective-C, pass the name of the method, such as <code class="code-voice">#selector(MyViewController.tappedButton(sender:))</code>. To construct a selector for a property’s Objective-C getter or setter method, pass the property name prefixed by the <code class="code-voice">getter:</code> or <code class="code-voice">setter:</code> label, such as <code class="code-voice">#selector(getter: MyViewController.myButton)</code>.
<br><span class="jpstr">
Ojbective-Cでは、セレクタはObjective-Cメソッドの名前を参照するある型です。スウィフトでは、Objective-Cセレクタは<code class="code-voice">Selector</code>構造体によって表されます、そして<code class="code-voice">#selector</code>式を使って組み立てられることができます。Objective-Cから呼び出されることができるメソッドに対してセレクタを作成するには、そのメソッドの名前を渡してください、例えば<code class="code-voice">#selector(MyViewController.tappedButton(sender:))</code>のように。あるプロパティの持つObjective-Cゲッターまたはセッターメソッドに対してセレクタを組み立てるには、<code class="code-voice">getter:</code>または<code class="code-voice">setter:</code>接頭辞を付けられたプロパティ名を渡してください、例えば<code class="code-voice">#selector(getter: MyViewController.myButton)</code>のように。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">import</span> <span class="vc">UIKit</span></code></li>
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">MyViewController</span>: <span class="n"><!-- a href="" -->UIViewController<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">myButton</span> = <span class="vc">UIButton</span>(<span class="vc">frame</span>: <span class="vc">CGRect</span>(<span class="vc">x</span>: <span class="m">0</span>, <span class="vc">y</span>: <span class="m">0</span>, <span class="vc">width</span>: <span class="m">100</span>, <span class="vc">height</span>: <span class="m">50</span>))</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">override</span> <span class="kt">init</span>(<span class="vc">nibName</span> <span class="vc">nibNameOrNil</span>: <span class="n"><!-- a href="" -->NSNib<!-- /a --></span>.<span class="n"><!-- a href="" -->Name<!-- /a --></span>?, <span class="vc">bundle</span> <span class="vc">nibBundleOrNil</span>: <span class="n"><!-- a href="" -->Bundle<!-- /a --></span>?) {</code></li>
            <li><code class="code-voice">        <span class="kt">super</span>.<span class="kt">init</span>(<span class="vc">nibName</span>: <span class="vc">nibNameOrNil</span>, <span class="vc">bundle</span>: <span class="vc">nibBundleOrNil</span>)</code></li>
            <li><code class="code-voice">        <span class="kt">let</span> <span class="vc">action</span> = <span class="kt">#selector</span>(<span class="vc">MyViewController</span>.<span class="vc">tappedButton</span>)</code></li>
            <li><code class="code-voice">        <span class="vc">myButton</span>.<span class="vc">addTarget</span>(<span class="kt">self</span>, <span class="vc">action</span>: <span class="vc">action</span>, <span class="vc">forControlEvents</span>: .<span class="vc">touchUpInside</span>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">@objc</span> <span class="kt">func</span> <span class="vc">tappedButton</span>(<span class="vc">sender</span>: <span class="n"><!-- a href="" -->UIButton<!-- /a --></span>?) {</code></li>
            <li><code class="code-voice">        <span class="vc">print</span>(<span class="s">&quot;tapped button&quot;</span>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">required</span> <span class="kt">init</span>?(<span class="vc">coder</span>: <span class="n"><!-- a href="" -->NSCoder<!-- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">super</span>.<span class="kt">init</span>(<span class="vc">coder</span>: <span class="vc">coder</span>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-NoLink_10"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">An Objective-C method reference can be parenthesized, and it can use the <code class="code-voice">as</code> operator to disambiguate between overloaded functions, such as <code class="code-voice">#selector(((UIView.insert(subview:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void))</code>.
    	<br><span class="jpstr">
Objective-Cメソッド参照は、丸括弧で括られることができます、そしてそれはオーバーロードされた関数間を明確にするために<code class="code-voice">as</code>演算子を使うことができます、例えば<code class="code-voice">#selector(((UIView.insert(subview:at:)) as (UIView) -&gt; (UIView, Int) -&gt; Void))</code>のように。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID187"></a>
  <h3 class="section-name" tabindex="0">Unsafe Invocation of Objective-C Methods<br><span class="jpstr">
Objective-Cメソッドの安全でない発動
</span><!--end_jpstr-->
</h3>
  <p class="para">
  You can invoke an Objective-C method on an Objective-C compatible object using a selector with the <code class="code-voice">perform(_:)</code> method or one of its variants. Invoking a method using a selector is inherently unsafe, because the compiler cannot make any guarantees about the result, or even guarantee whether the object responds to the selector. Therefore, using these APIs is strongly discouraged unless your code specifically relies on the dynamic method resolution provided by the Objective-C runtime. For example, using these APIs would be appropriate if you need to implement a class that uses the target-action design pattern in its interface, like <code class="code-voice">NSResponder</code> does. In most cases, it’s safer and more convenient to cast the object to <code class="code-voice">AnyObject</code> and use optional chaining with a method call as described in <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014216-CH4-ID42" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID42">id Compatibility</a></span>.
<br><span class="jpstr">
あなたはObjective-CメソッドをObjective-C互換オブジェクト上で発動することが<code class="code-voice">perform(_:)</code>メソッドやそれの変種の１つを持つセレクタを使うことで可能です。メソッドをセレクタを使って発動することは、本質的に安全ではありません、なぜならコンパイラはその結果についてどんな保証も、またはオブジェクトがセレクタに応答するかどうかの保証さえもすることが不可能だからです。それゆえに、これらのAPIを使うことは強く反対されます、あなたのコードがObjective-Cランタイムによって提供される動的メソッド解決を特別に当てにするのでない限りは。例えば、これらのAPIの使用は、もしあなたがそれのインターフェイスにおいてターゲット-アクション・デザインパターンを使うクラスを実装する必要があるならば適切でしょう、<code class="code-voice">NSResponder</code>がするように。ほとんどの場合には、より安全でいっそう便利なのはそのオブジェクトを<code class="code-voice">AnyObject</code>にキャストして、メソッド呼び出しとともにオプショナル連鎖を使うことです、<span class="x-name"><a href="#//apple_ref/doc/uid/TP40014216-CH4-ID42" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID42">id互換性</a></span>で記述されるように。
</span><!--end_jpstr-->
</p><p class="para">
  The methods that perform a selector synchronously, such as <code class="code-voice">perform(_:)</code>, return an implicitly unwrapped optional unmanaged pointer to an <code class="code-voice">AnyObject</code> instance (<code class="code-voice">Unmanaged&lt;AnyObject&gt;!</code>), because the type and ownership of the value returned by performing the selector can’t be determined at compile time. In contrast, the methods that perform a selector on a specific thread or after a delay, such as <code class="code-voice">perform(_:on:with:waitUntilDone:modes:)</code> and <code class="code-voice">perform(_:with:afterDelay:)</code>, don’t return a value. See <span class="x-name"><a href="WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID85" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH6-ID85">Unmanaged Objects</a></span> for more information.
<br><span class="jpstr">
セレクタを同期的に実行するメソッド、例えば<code class="code-voice">perform(_:)</code>は、<code class="code-voice">AnyObject</code>インスタンス（<code class="code-voice">Unmanaged&lt;AnyObject&gt;!</code>）に対する暗黙的にアンラップされたオプショナルの非管理ボインタを返します、なぜならセレクタ実行によって返される値の型と所有権はコンパイル時に確定されることができないからです。対照的に、セレクタを特定のスレッド上やある猶予の後で実行するメソッド、例えば<code class="code-voice">perform(_:on:with:waitUntilDone:modes:)</code>そして<code class="code-voice">perform(_:with:afterDelay:)</code>は、値を返しません。更なる情報として<span class="x-name"><a href="WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID85" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH6-ID85">管理されないオブジェクト</a></span>を見てください。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">string</span>: <span class="n"><!-- a href="" -->NSString<!-- /a --></span> = <span class="s">&quot;Hello, Cocoa!&quot;</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">selector</span> = <span class="kt">#selector</span>(<span class="vc">NSString</span>.<span class="vc">lowercased</span>(<span class="vc">with</span>:))</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">locale</span> = <span class="vc">Locale</span>.<span class="vc">current</span></code></li>
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">result</span> = <span class="vc">string</span>.<span class="vc">perform</span>(<span class="vc">selector</span>, <span class="vc">with</span>: <span class="vc">locale</span>) {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="vc">result</span>.<span class="vc">takeUnretainedValue</span>())</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;hello, cocoa!&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Attempting to invoke a method on an object with an unrecognized selector causes the receiver to call <code class="code-voice">doesNotRecognizeSelector(_:)</code>, which by default raises an <code class="code-voice">NSInvalidArgumentException</code> exception.
<br><span class="jpstr">
メソッドをオブジェクト上で十分に評価されていないセレクタで発動することは、そのレシーバが<code class="code-voice">doesNotRecognizeSelector(_:)</code>を呼び出す原因になります、それは初期設定では<code class="code-voice">NSInvalidArgumentException</code>例外を引き起こします。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">array</span>: <span class="n"><!-- a href="" -->NSArray<!-- /a --></span> = [<span class="s">&quot;delta&quot;</span>, <span class="s">&quot;alpha&quot;</span>, <span class="s">&quot;zulu&quot;</span>]</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="c">// Not a compile-time error because NSDictionary has this selector.&nbsp;<span class="jpstr">（コンパイル時エラーでは無い、なぜならNSDictionaryはこのセレクタを持つからです。）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">selector</span> = <span class="kt">#selector</span>(<span class="vc">NSDictionary</span>.<span class="vc">allKeysForObject</span>)</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="c">// Raises an exception because NSArray does not respond to this selector.&nbsp;<span class="jpstr">（例外を引き起こします、なぜならNSArrayはこのセレクタに応答しないからです。）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="vc">array</span>.<span class="vc">perform</span>(<span class="vc">selector</span>)</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-ID205"></a>
  <h3 class="section-name" tabindex="0">Keys and Key Paths<br><span class="jpstr">
キーとキーパス
</span><!--end_jpstr-->
</h3>
  <p class="para">
  In Objective-C, a key is a string that identifies a specific property of an object; a key path is a string of dot-separated keys that specifies a sequence of object properties to traverse. Keys and key paths are frequently used for key-value coding (KVC), a mechanism for indirectly accessing an object’s attributes and relationships using string identifiers. Keys and key paths are also used for key-value observing (KVO), a mechanism that enables an object to be notified directly when a property of another object changes.
<br><span class="jpstr">
Objective-Cでは、キーはオプジェクトの特定のプロパティを識別するある文字列です；キーパスはドットで区切られたいくらかのキーからなる文字列で、それは巡回していく一連のオブジェクトプロパティを指定します。キーとキーパスは、文字列識別子を使ってオブジェクトの属性および関連付け（リレーションシップ）に間接的にアクセスするための仕組み、キー値コーディング（KVC）のためにしばしば使われます。キーとキーパスはまた、他のオブジェクトのプロパティが変化した時にあるオブジェクトが直接に通知されることを可能にする仕組み、キー値監視（KVO）のためにも使われます。
</span><!--end_jpstr-->
</p><p class="para">
  In Swift, you can use a key-path expression to create key paths that can be used to access properties. For example, you can use the <code class="code-voice">\Animal.name</code> key-path expression to access the <code class="code-voice">name</code> property of the <code class="code-voice">Animal</code> class shown below. Key paths created using key-path expressions include type information about the properties they reference; the result of applying a key path has the same type as if you had accessed the property directly. A key-path expression accepts property references and chained property references, such as <code class="code-voice">\Animal.name.count</code>.
<br><span class="jpstr">
スウィフトでは、あなたはキー値式を使ってキーパスを作成できます、それはプロパティにアクセスするために使われます。例えば、あなたは<code class="code-voice">\Animal.name</code>キーパス式を使って、下で示す<code class="code-voice">Animal</code>クラスの<code class="code-voice">name</code>プロパティにアクセスできます。キー値式を使って作成されるキーパスは、それらが参照するプロパティについての型情報を含みます；キーパスを適用する結果は、まるであなたがそのプロパティに直接にアクセスしたかのように同じ型です。キーパス式は、プロパティ参照そして数珠つなぎにされたプロパティ参照を受け入れます、例えば<code class="code-voice">\Animal.name.count</code>のように。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">Animal</span>: <span class="n"><!-- a href="" -->NSObject<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">@objc</span> <span class="kt">var</span> <span class="vc">name</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span></code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">name</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">name</span> = <span class="vc">name</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">llama</span> = <span class="vc">Animal</span>(<span class="vc">name</span>: <span class="s">&quot;Llama&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">nameAccessor</span> = \<span class="vc">Animal</span>.<span class="vc">name</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">nameCountAccessor</span> = \<span class="vc">Animal</span>.<span class="vc">name</span>.<span class="vc">count</span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">llama</span>[<span class="vc">keyPath</span>: <span class="vc">nameAccessor</span>]</code></li>
            <li><code class="code-voice"><span class="c">// &quot;Llama&quot;</span></code></li>
            <li><code class="code-voice"><span class="vc">llama</span>[<span class="vc">keyPath</span>: <span class="vc">nameCountAccessor</span>]</code></li>
            <li><code class="code-voice"><span class="c">// &quot;5&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  In Swift, you can also use the <code class="code-voice">#keyPath</code> string expression to create compiler-checked keys and key paths that can be used by KVC methods like <code class="code-voice">value(forKey:)</code> and <code class="code-voice">value(forKeyPath:)</code> and KVO methods like <code class="code-voice">addObserver(_:forKeyPath:options:context:)</code>. The <code class="code-voice">#keyPath</code> string expression accepts chained method or property references. It also supports chaining through optional values within a chain, such as <code class="code-voice">#keyPath(Person.bestFriend.name)</code>. Unlike key paths creating used key-path expressions, key paths created using the <code class="code-voice">#keyPath</code> string expression don’t pass along type information about the properties or methods they reference to the APIs that accept key paths.
<br><span class="jpstr">
スウィフトでは、あなたは<code class="code-voice">#keyPath</code>文字列式を使うことでコンパイラチェック済みのキーやキーパスを作成できます、それらは<code class="code-voice">value(forKey:)</code>と<code class="code-voice">value(forKeyPath:)</code>のようなKVCメソッドおよび<code class="code-voice">addObserver(_:forKeyPath:options:context:)</code>のようなKVOメソッドによって使われることができます。<code class="code-voice">#keyPath</code>文字列式は、数珠つなぎにされたメソッドまたはプロパティ参照を受け入れます。それはまた、ある数珠つなぎ内でオプショナル値を通した連鎖をサポートします、例えば<code class="code-voice">#keyPath(Person.bestFriend.name)</code>など。キーパス式を使って作成されるキーパスと違い、<code class="code-voice">#keyPath</code>文字列式を使って作成されるキーパスは、それらが参照するプロパティやメソッドについての型情報をキーパスを受け入れるAPIへ伝えません。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014216-CH4-NoLink_11"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">The syntax of a <code class="code-voice">#keyPath</code> string expression is similar to the syntax of a <code class="code-voice">#selector</code> expression, as described in <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014216-CH4-ID59" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID59">Selectors</a></span>.
    	<br><span class="jpstr">
<code class="code-voice">#keyPath</code>文字列式の構文は、<code class="code-voice">#selector</code>式の構文に似ています、<span class="x-name"><a href="#//apple_ref/doc/uid/TP40014216-CH4-ID59" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID59">セレクタ</a></span>で記述されるように。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">Person</span>: <span class="n"><!-- a href="" -->NSObject<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">@objc</span> <span class="kt">var</span> <span class="vc">name</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">@objc</span> <span class="kt">var</span> <span class="vc">friends</span>: [<span class="n"><!-- a href="" -->Person<!-- /a --></span>] = []</code></li>
            <li><code class="code-voice">    <span class="kt">@objc</span> <span class="kt">var</span> <span class="vc">bestFriend</span>: <span class="n"><!-- a href="" -->Person<!-- /a --></span>? = <span class="kt">nil</span></code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">name</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">name</span> = <span class="vc">name</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">gabrielle</span> = <span class="vc">Person</span>(<span class="vc">name</span>: <span class="s">&quot;Gabrielle&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">jim</span> = <span class="vc">Person</span>(<span class="vc">name</span>: <span class="s">&quot;Jim&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">yuanyuan</span> = <span class="vc">Person</span>(<span class="vc">name</span>: <span class="s">&quot;Yuanyuan&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="vc">gabrielle</span>.<span class="vc">friends</span> = [<span class="vc">jim</span>, <span class="vc">yuanyuan</span>]</code></li>
            <li><code class="code-voice"><span class="vc">gabrielle</span>.<span class="vc">bestFriend</span> = <span class="vc">yuanyuan</span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">#keyPath</span>(<span class="vc">Person</span>.<span class="vc">name</span>)</code></li>
            <li><code class="code-voice"><span class="c">// &quot;name&quot;</span></code></li>
            <li><code class="code-voice"><span class="vc">gabrielle</span>.<span class="vc">value</span>(<span class="vc">forKey</span>: <span class="kt">#keyPath</span>(<span class="vc">Person</span>.<span class="vc">name</span>))</code></li>
            <li><code class="code-voice"><span class="c">// &quot;Gabrielle&quot;</span></code></li>
            <li><code class="code-voice"><span class="kt">#keyPath</span>(<span class="vc">Person</span>.<span class="vc">bestFriend</span>.<span class="vc">name</span>)</code></li>
            <li><code class="code-voice"><span class="c">// &quot;bestFriend.name&quot;</span></code></li>
            <li><code class="code-voice"><span class="vc">gabrielle</span>.<span class="vc">value</span>(<span class="vc">forKeyPath</span>: <span class="kt">#keyPath</span>(<span class="vc">Person</span>.<span class="vc">bestFriend</span>.<span class="vc">name</span>))</code></li>
            <li><code class="code-voice"><span class="c">// &quot;Yuanyuan&quot;</span></code></li>
            <li><code class="code-voice"><span class="kt">#keyPath</span>(<span class="vc">Person</span>.<span class="vc">friends</span>.<span class="vc">name</span>)</code></li>
            <li><code class="code-voice"><span class="c">// &quot;friends.name&quot;</span></code></li>
            <li><code class="code-voice"><span class="vc">gabrielle</span>.<span class="vc">value</span>(<span class="vc">forKeyPath</span>: <span class="kt">#keyPath</span>(<span class="vc">Person</span>.<span class="vc">friends</span>.<span class="vc">name</span>))</code></li>
            <li><code class="code-voice"><span class="c">// [&quot;Yuanyuan&quot;, &quot;Jim&quot;]</span></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>

  	
 	<section id="next_previous" class="">
    		<p class="previous-link"><a href="index.html#//apple_ref/doc/uid/TP40014216-CH2-ID0" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH2-ID0">Basic Setup<br><span class="jpstr">
基本の準備
</span><!--end_jpstr-->
</a></p>
  			<p class="next-link"><a href="WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID86" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH5-ID86">Writing Swift Classes and Protocols with Objective-C Behavior<br><span class="jpstr">
スウィフトのクラスとプロトコルをObjective-C挙動で書く
</span><!--end_jpstr-->
</a></p>

    <p class="copyright">Copyright &#x00a9; 2017 Apple Inc. All rights reserved. 
  <a class="link" href="http://www.apple.com/legal/terms/site.html" target="_blank" rel="external">Terms of Use</a> | 
  <a class="link" href="http://www.apple.com/privacy/" target="_blank" rel="external">Privacy Policy</a> | 
  Updated: 2017-06-05
</p>
  </section>
</article>

    </div>
    <div id='big_button'></div>
    <footer id="footer">
  <div class="content-wrapper">
  	<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
  </div>
  <script src="../../../../Resources/1264/JavaScript/devpubs-1.6.3.js" type="text/javascript" charset="utf-8"></script>
  <script src="../../../../Resources/1264/JavaScript/feedback-1.6.3.js" type="text/javascript" charset="utf-8"></script>
  <div id="_omniture_top">
<!-- SiteCatalyst code version: H.8. Copyright 1997-2006 Omniture, Inc. -->
<script type="text/javascript">
/* RSID: */
var s_account="appleglobal,appleusdeveloper,dappdeveloperlib"
</script>

<!-- <script type="text/javascript" src="https://www.apple.com/metrics/scripts/s_code_h.js"></script> -->
<script type="text/javascript">
s.pageName=AC.Tracking.pageName();
s.channel="www.us.developer"

/************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
var s_code=s.t();if(s_code)document.write(s_code)</script>
<!-- End SiteCatalyst code version: H.8. -->
</div>

</footer>

    
  </body>
    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="https://developer.apple.com/bugreporter/" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

</div>
</html>
