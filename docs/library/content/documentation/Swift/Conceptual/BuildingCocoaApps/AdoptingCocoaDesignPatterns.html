<!DOCTYPE html>
<html lang="en">
  <head>  
  <title>Using Swift with Cocoa and Objective-C (Swift 4.1): Adopting Cocoa Design Patterns</title>
  <link rel="stylesheet" type="text/css" href="../../../../Resources/1277/CSS/style-1.6.3.css" />
  <link rel="stylesheet" type="text/css" href="../../../../Resources/1277/CSS/feedback-1.6.3.css" />
  <meta charset='utf-8'> 
<meta id="j-version" name="j-version" content="" />
<meta id="build" name="build" content="f99ee3d3b1b0baba635224fe02964519" />
<meta id="document-version" name="document-version" content="9.2.4" />
<meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Topic/Swift}" />
<meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/TP40014216" />
<meta id="chapterId" name="chapterId" content="TP40014216-CH7">
<meta id="book-title" name="book-title" content="Using Swift with Cocoa and Objective-C (Swift 4.1)" />
<meta id="book-resource-type" name="book-resource-type" content="Guide" />
<meta id="book-root" name="book-root" content="./" />
<meta id="book-json" name="book-json" content="book.json">
<meta id="date" name="date" content="2018-02-06" />
<meta id="description" name="description" content="Describes various aspects of Swift&#39;s compatibility with the Objective-C language and Cocoa/Cocoa Touch frameworks." />
<meta id="IndexTitle" name="IndexTitle" content="" />
<meta id="resources-uri" name="resources-uri" content="../../../../Resources/1277">
<link id="book-index-page" rel="Start" title="" type="text/html" href="./index.html">
<!-- , next_chapter: next_chapter, previous_chapter: previous_chapter -->
<link id="next-page" rel="Next" type="text/html" href="">
<link id="previous-page" rel="Prev" type="text/html" href="">
<meta id="devcenter" name="devcenter" content="<!-- DEVCENTER_NAME -->" />
<meta id="devcenter-url" name="devcenter-url" content="<!-- DEVCENTER_URL -->" />
<meta id="reflib" name="reflib" content="<!-- REFLIB_NAME -->" />

<meta id="xcode-display" name="xcode-display" content="render" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<meta id="platforms" name="platforms" content="Xcode Developer Tools">
</head>

  <body id="conceptual_flow_with_tasks" class="jazz">
    
    <header id="ios_header" class="hideOnPrint hideInXcode">
  <div class="content-wrapper">
    <p class="header-text">
    	<a href="../../../../navigation/index.html">Guides and Sample Code
 		</a>
 </p>
    <p id="wwdr"><img id="apple_logo" src="../../../../Resources/1277/Images/apple2.png" height="14px" width="12px" aria-hidden="true" /><a href="https://developer.apple.com">Developer</a></p>
  </div>
</header>

    <section id="valence">
  <div class="content-wrapper">
    <p id="hierarchial_navigation">
      <span id="book_title">Using Swift with Cocoa and Objective-C (Swift 4.1)</span>
    </p>
    <form id="search" class="hideInXcode" method="get" action="/search/index.php" accept-charset="utf-8" autocomplete="off">
  <input type="search" id="ssi_SearchField" placeholder="Search Guides and Sample Code" name="q" autocomplete="off" tabindex="2" />
</form>

      
   
   




    <span class="download-text hideInXcode">
      <a href="https://itunes.apple.com/us/book/using-swift-cocoa-objective/id1002624212?mt=11">iBooks</a>
    </span>

    

    <img id="shortstack" src="../../../../Resources/1277/Images/shortstack_2x.png"/>
  </div>
</section>
    <div class="content-wrapper">
      <nav id="navigator" class="book-parts hideInXcode" role="navigation">
    <ul class="nav-parts">
        <li data-id="//apple_ref/doc/uid/TP40014216-CH1-ID5"
            class="part-name">
            <a href="index.html#//apple_ref/doc/uid/TP40014216-CH2-ID0" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH2-ID0">Getting Started<br><span class="jpstr">
初めに
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="index.html#//apple_ref/doc/uid/TP40014216-CH2-ID0" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH2-ID0">Basic Setup<br><span class="jpstr">
基本の準備
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014216-CH3-ID60"
            class="part-name nav-part-active open-part">
            <a href="InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID35">Interoperability<br><span class="jpstr">
相互運用性
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID35">Interacting with Objective-C APIs<br><span class="jpstr">
Objective-C APIとの相互作用
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID86" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH5-ID86">Writing Swift Classes and Protocols with Objective-C Behavior<br><span class="jpstr">
スウィフトのクラスとプロトコルをObjective-C挙動で書く
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH6-ID61">Working with Cocoa Frameworks<br><span class="jpstr">
Cocoaフレームワークを扱う
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter nav-current-chapter">
              	<a href="#//apple_ref/doc/uid/TP40014216-CH7-ID6" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH7-ID6">Adopting Cocoa Design Patterns<br><span class="jpstr">
ココア・デザインパターンの採用
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID17" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH8-ID17">Interacting with C APIs<br><span class="jpstr">
C APIとの相互作用
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014216-CH9-ID141"
            class="part-name">
            <a href="MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH10-ID122">Mix and Match<br><span class="jpstr">
混合と適合
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH10-ID122">Swift and Objective-C in the Same Project<br><span class="jpstr">
同じプロジェクト中のスウィフトとObjective-C
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014216-CH11-ID121"
            class="part-name">
            <a href="Migration.html#//apple_ref/doc/uid/TP40014216-CH12-ID108" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH12-ID108">Migration<br><span class="jpstr">
移行
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="Migration.html#//apple_ref/doc/uid/TP40014216-CH12-ID108" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH12-ID108">Migrating Your Objective-C Code to Swift<br><span class="jpstr">
あなたのObjective-Cコードのスウィフトへの移行
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014216-CH13-ID143"
            class="part-name">
            <a href="RevisionHistory.html#//apple_ref/doc/uid/TP40014216-CH14-ID142" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH14-ID142">Revision History<br><span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="RevisionHistory.html#//apple_ref/doc/uid/TP40014216-CH14-ID142" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH14-ID142">Document Revision History<br><span class="jpstr">
文書改訂履歴
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
    </ul>
</nav>

      <menu id="bashful" type="toolbar">
  <div class="shield"></div>
  <menuitem id="jump_to" class="menu-bar-item closed">
  <span>On This Page</span>
  <div class="chevron">
    <div class="chevy chevron-left"></div>
    <div class="chevy chevron-right"></div>
  </div>
  <menu type="list" class="details">
      <ul class="list-bullet">
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH7-ID8">Delegation</a>
<br><span class="jpstr">
委任
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH7-ID179">Lazy Initialization</a>
<br><span class="jpstr">
遅延初期化
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH7-ID10">Error Handling</a>
<br><span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH7-ID12">Key-Value Observing</a>
<br><span class="jpstr">
キー値監視
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH7-ID14">Target-Action</a>
<br><span class="jpstr">
ターゲット-アクション
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH7-ID177">Singleton</a>
<br><span class="jpstr">
シングルトン
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH7-ID16">Introspection</a>
<br><span class="jpstr">
自己観察
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH7-ID182">Serialization</a>
<br><span class="jpstr">
シリアライズ
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH7-ID65">Localization</a>
<br><span class="jpstr">
現地語化
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH7-ID216">Autorelease Pools</a>
<br><span class="jpstr">
オートリリースプール
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH7-ID160">API Availability</a>
<br><span class="jpstr">
API有効性
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH7-ID184">Processing Command-Line Arguments</a>
<br><span class="jpstr">
コマンドライン引数の処理
</span><!--end_jpstr-->
          </li>
      </ul>
  </menu>
</menuitem>

</menu>
<div class="pixel-line"></div>
<div class="rubber-band-gap"></div>
<article class="chapter">
  <a name="//apple_ref/doc/uid/TP40014216-CH7"></a><a name="//apple_ref/doc/uid/TP40014216-CH7-ID6"></a>

  <h2 class='chapter-name'>Adopting Cocoa Design Patterns<br><span class="jpstr">
ココア・デザインパターンの採用
</span><!--end_jpstr-->
</h2>


  
  	<section class="section">
  		<p class="para">
  One aid in writing well-designed, resilient apps is to use Cocoa’s established design patterns. Many of these patterns rely on classes defined in Objective-C. Because of Swift’s interoperability with Objective-C, you can take advantage of these common patterns in your Swift code. In many cases, you can use Swift language features to extend or simplify existing Cocoa patterns, making them more powerful and easier to use.
<br><span class="jpstr">
よく設計された、溌剌としたアプリを記述することでの１つの援助は、ココアのいくつかの確立したデザインパターンを使うことです。これらのパターンの多くは、Objective-Cで定義されるクラスに頼ります。スウィフトのObjective-Cとの相互運用性のため、あなたはこれらの共通のパターンをあなたのスウィフトコードにおいて活用することができます。多くの場合に、あなたは既存のココア・パターンを拡張したり、単純化するためにスウィフト言語の特徴を働かせることができます。そして、それらをより強力でより使いやすくします。
</span><!--end_jpstr-->
</p>

		</section> 


  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID8"></a>
  <h3 class="section-name" tabindex="0">Delegation<br><span class="jpstr">
委任
</span><!--end_jpstr-->
</h3>
  <p class="para">
  In both Swift and Objective-C, delegation is often expressed with a protocol that defines the interaction and a conforming delegate property. Just as in Objective-C, before you send a message that a delegate may not respond to, you ask the delegate whether it responds to the selector. In Swift, you can use optional chaining to invoke an optional protocol method on a possibly <code class="code-voice">nil</code> object and unwrap the possible result using <code class="code-voice">if–let</code> syntax. The code listing below illustrates the following process:
<br><span class="jpstr">
スウィフトとObjective-Cの両方で、委任は、相互作用を定義するプロトコルと準拠している委任プロパティでたいてい表されます。ちょうどObjective-Cでのように、あなたが委任先が応答しないかもしれないメッセージを送る前に、あなたはその委任先にそれがセレクタに応答するかどうか尋ねます。スウィフトでは、あなたはオプショナル連鎖を使用することで、オプショナルのプロトコルメソッドをもしかすると<code class="code-voice">nil</code>であるオブジェクト上で呼び出して<code class="code-voice">if–let</code>構文を使って可能な結果をアンラップすることができます。下記のコード出力は、次の過程を例示します：
</span><!--end_jpstr-->
</p><ol class="list-number">
  <li class="item"><p class="para">
  Check that <code class="code-voice">myDelegate</code> is not <code class="code-voice">nil</code>.
<br><span class="jpstr">
<code class="code-voice">myDelegate</code>が<code class="code-voice">nil</code>でないことを確かめる。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Check that <code class="code-voice">myDelegate</code> implements the method <code class="code-voice">window:willUseFullScreenContentSize:</code>.
<br><span class="jpstr">
<code class="code-voice">myDelegate</code>がメソッド<code class="code-voice">window:willUseFullScreenContentSize:</code>を実装することを確かめる。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  If 1 and 2 hold true, invoke the method and assign the result of the method to the value named <code class="code-voice">fullScreenSize</code>.
<br><span class="jpstr">
１と２が当てはまるならば、そのメソッドを呼び出して、メソッドの結果を<code class="code-voice">fullScreenSize</code>と名前をつけられる値に代入する。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Print the return value of the method.
<br><span class="jpstr">
メソッドの戻り値を出力する。
</span><!--end_jpstr-->
</p>
</li>
</ol><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">MyDelegate</span>: <span class="n"><! -- a href="" -->NSObject<! -- /a --></span>, <span class="n"><! -- a href="" -->NSWindowDelegate<! -- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">func</span> <span class="vc">window</span>(<span class="kt">_</span> <span class="vc">window</span>: <span class="n"><! -- a href="" -->NSWindow<! -- /a --></span>, <span class="vc">willUseFullScreenContentSize</span> <span class="vc">proposedSize</span>: <span class="n"><! -- a href="" -->NSSize<! -- /a --></span>) -&gt; <span class="n"><! -- a href="" -->NSSize<! -- /a --></span> {</code></li>
            <li><code class="code-voice">        <span class="kt">return</span> <span class="vc">proposedSize</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="vc">myWindow</span>.<span class="vc">delegate</span> = <span class="vc">MyDelegate</span>()</code></li>
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">fullScreenSize</span> = <span class="vc">myWindow</span>.<span class="vc">delegate</span>?.<span class="vc">window</span>(<span class="vc">myWindow</span>, <span class="vc">willUseFullScreenContentSize</span>: <span class="vc">mySize</span>) {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="vc">NSStringFromSize</span>(<span class="vc">fullScreenSize</span>))</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID179"></a>
  <h3 class="section-name" tabindex="0">Lazy Initialization<br><span class="jpstr">
遅延初期化
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A <em>lazy property</em> is a property whose underlying value is only initialized when the property is first accessed. Lazy properties are useful when the initial value for a property either requires complex or computationally expensive setup, or cannot be determined until after an instance’s initialization is complete.
<br><span class="jpstr">
<em>遅延プロパティ</em>は、それの裏に潜んだ値が初期化されるのがそのプロパティが最初にアクセスされる時にして初めてというプロパティです。遅延プロパティが便利なのは、あるプロパティに対する初期値が、複雑なもしくは計算的に高くつく準備を必要とする、またはあるインスタンスの初期化が完了する後まで決定されることが出来ない、このどちらかである場合です。
</span><!--end_jpstr-->
</p><p class="para">
  In Objective-C, a property may override its synthesized getter method such that the underlying instance variable is conditionally initialized if its value is <code class="code-voice">nil</code>:
<br><span class="jpstr">
Objective-Cでは、プロパティは、それの合成されたゲッターメソッドをオーバーライドできます、例えば、裏に潜んだインスタンス変数が、それの値が<code class="code-voice">nil</code>かどうかで、条件付きで初期化されるように：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="k">@property</span> <span class="n">NSXMLDocument</span> <span class="o">*</span><span class="n">XML</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"> 
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="n">NSXMLDocument</span> <span class="o">*</span><span class="p">)</span><span class="n">XML</span> <span class="p">{</span>
</code></li>
            <li><code class="code-voice">    <span class="k">if</span> <span class="p">(</span><span class="n">_XML</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</code></li>
            <li><code class="code-voice">        <span class="n">_XML</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSXMLDocument</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithContentsOfURL:</span><span class="p">[[</span><span class="n">Bundle</span> <span class="n">mainBundle</span><span class="p">]</span> <span class="nl">URLForResource:</span><span class="s">@&quot;/path/to/resource&quot;</span> <span class="nl">withExtension:</span><span class="s">@&quot;xml&quot;</span><span class="p">]</span> <span class="nl">options:</span><span class="mi">0</span> <span class="nl">error:</span><span class="nb">nil</span><span class="p">];</span>
</code></li>
            <li><code class="code-voice">    <span class="p">}</span>
</code></li>
            <li><code class="code-voice"> 
</code></li>
            <li><code class="code-voice">    <span class="k">return</span> <span class="n">_XML</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="p">}</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  In Swift, a stored property with an initial value can be declared with the <code class="code-voice">lazy</code> modifier to have the expression calculating the initial value only evaluated when the property is first accessed:
<br><span class="jpstr">
スウィフトでは、初期値を持つ格納プロパティが<code class="code-voice">lazy</code>修飾子を使って宣言されると、初期値を計算する式は、そのプロパティが最初にアクセスされる時に初めて数値を求められるようになります。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">lazy</span> <span class="kt">var</span> <span class="vc">XML</span>: <span class="n"><! -- a href="" -->XMLDocument<! -- /a --></span> = <span class="kt">try</span>! <span class="vc">XMLDocument</span>(<span class="vc">contentsOf</span>: <span class="vc">Bundle</span>.<span class="vc">main</span>.<span class="vc">url</span>(<span class="vc">forResource</span>: <span class="s">&quot;document&quot;</span>, <span class="vc">withExtension</span>: <span class="s">&quot;xml&quot;</span>)!)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Because a lazy property is only computed when accessed for a fully-initialized instance it may access constant or variable properties in its default value initialization expression:
<br><span class="jpstr">
遅延プロパティは、完全に初期化されたインスタンスに対してアクセスされる時に初めて計算されるので、それは、定数または変数プロパティにアクセスすることがそれの省略時の値の初期化式において可能です：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">pattern</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span></code></li>
            <li><code class="code-voice"><span class="kt">lazy</span> <span class="kt">var</span> <span class="vc">regex</span>: <span class="n"><! -- a href="" -->NSRegularExpression<! -- /a --></span> = <span class="kt">try</span>! <span class="vc">NSRegularExpression</span>(<span class="vc">pattern</span>: <span class="kt">self</span>.<span class="vc">pattern</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  For values that require additional setup beyond initialization, you can assign the default value of the property to a self-evaluating closure that returns a fully-initialized value:
<br><span class="jpstr">
初期化を越えて更なる準備が必要な値に対して、あなたはプロパティの省略時の値を得る仕事を、完全初期化された値を返すある自己評価するクロージャに任せることができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">lazy</span> <span class="kt">var</span> <span class="vc">currencyFormatter</span>: <span class="n"><! -- a href="" -->NumberFormatter<! -- /a --></span> = {</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">formatter</span> = <span class="vc">NumberFormatter</span>()</code></li>
            <li><code class="code-voice">    <span class="vc">formatter</span>.<span class="vc">numberStyle</span> = .<span class="vc">currency</span></code></li>
            <li><code class="code-voice">    <span class="vc">formatter</span>.<span class="vc">currencySymbol</span> = <span class="s">&quot;¤&quot;</span></code></li>
            <li><code class="code-voice">    <span class="kt">return</span> <span class="vc">formatter</span></code></li>
            <li><code class="code-voice">}()</code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-NoLink_17"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">If a lazy property has not yet been initialized and is accessed by more than one thread at the same time, there is no guarantee that the property will be initialized only once.
    	<br><span class="jpstr">
遅延プロパティがまだ初期化されてしまわないのに１つ以上のスレッドによって同時にアクセスされるならば、そのプロパティがただ一度だけ初期化されるとは保証されません。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><p class="para">
  For more information, see <a href="../Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14" data-renderer-version="2" target="_self">Lazy Stored Properties</a> in <em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">The Swift Programming Language (Swift 4.1)</a></em>.
<br><span class="jpstr">
更なる情報として、<a href="../Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14" data-renderer-version="2" target="_self">遅延格納プロパティ</a>を<em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">スウィフトプログラミング言語（Swift 4.1）</a></em>で見てください。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID10"></a>
  <h3 class="section-name" tabindex="0">Error Handling<br><span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</h3>
  <p class="para">
  In Cocoa, methods that produce errors take an <code class="code-voice">NSError</code> pointer parameter as their last parameter, which populates its argument with an <code class="code-voice">NSError</code> object if an error occurs. Swift automatically translates Objective-C methods that produce errors into methods that throw an error according to Swift’s native error handling functionality.
<br><span class="jpstr">
Cocoaでは、エラーを生成するメソッドは、それの最後のパラメーターとして<code class="code-voice">NSError</code>ポインターパラメーターを取ります、エラーが起こるならばその引数に<code class="code-voice">NSError</code>オブジェクトが入ります。スウィフトは、自動的にエラーを生成するObjective-Cメソッドを、スウィフト固有のエラー処理機能に従ってエラーをスローするメソッドに翻訳します。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-NoLink_18"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Methods that <em>consume</em> errors, such as delegate methods or methods that take a completion handler with an <code class="code-voice">NSError</code> object argument, do not become methods that throw when imported by Swift.
    	<br><span class="jpstr">
エラーを<em>食べ尽くす</em>メソッド、例えば委任先メソッドたちや完了ハンドラを<code class="code-voice">NSError</code>オブジェクト引数で取るメソッドたちは、スウィフトによってインポートされる時にスローするメソッドになりません。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><p class="para">
  For example, consider the following Objective-C method from <code class="code-voice">NSFileManager</code>:
<br><span class="jpstr">
例として、以下の<code class="code-voice">NSFileManager</code>からのObjective-Cメソッドを考えてください：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nl">removeItemAtURL:</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="n">URL</span>
</code></li>
            <li><code class="code-voice">                  <span class="nl">error:</span><span class="p">(</span><span class="n">NSError</span> <span class="o">**</span><span class="p">)</span><span class="n">error</span><span class="p">;</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  In Swift, it’s imported like this:
<br><span class="jpstr">
スウィフトでは、それはこのようにインポートされます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">removeItem</span>(<span class="vc">at</span>: <span class="n"><! -- a href="" -->URL<! -- /a --></span>) <span class="kt">throws</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Notice that the <code class="code-voice">removeItem(at:)</code> method is imported by Swift with a <code class="code-voice">Void</code> return type, no <code class="code-voice">error</code> parameter, and a <code class="code-voice">throws</code> declaration.
<br><span class="jpstr">
<code class="code-voice">removeItem(at:)</code>メソッドがスウィフトによって<code class="code-voice">Void</code>の戻り型で、<code class="code-voice">error</code>パラメーターなしで、そして<code class="code-voice">throws</code>宣言でインポートされることに注意してください。
</span><!--end_jpstr-->
</p><p class="para">
  If the last non-block parameter of an Objective-C method is of type <code class="code-voice">NSError **</code>, Swift replaces it with the <code class="code-voice">throws</code> keyword, to indicate that the method can throw an error. If the Objective-C method’s error parameter is also its first parameter, Swift attempts to simplify the method name further, by removing the “WithError” or “AndReturnError” suffix, if present, from the first part of the selector. If another method is declared with the resulting selector, the method name is not changed.
<br><span class="jpstr">
Objective-Cメソッドの最後の非ブロックパラメーターが型<code class="code-voice">NSError **</code>ならば、スウィフトはそれを<code class="code-voice">throws</code>キーワードで置き換えて、そのメソッドがエラーをスローできることを示します。Objective-Cメソッドのエラーパラメーターがまたそれの最初のパラメーターでもあるならば、スウィフトは「WithError」または「AndReturnError」接尾辞を、もしあるならば、セレクタの最初の部分から取り除くことで、メソッド名をいっそう単純化することを試みます。結果として生じるセレクタで別のメソッドが宣言されるならば、メソッド名は変更されません。
</span><!--end_jpstr-->
</p><p class="para">
  If an error producing Objective-C method returns a <code class="code-voice">BOOL</code> value to indicate the success or failure of a method call, Swift changes the return type of the function to <code class="code-voice">Void</code>. Similarly, if an error producing Objective-C method returns a <code class="code-voice">nil</code> value to indicate the failure of a method call, Swift changes the return type of the function to a nonoptional type.
<br><span class="jpstr">
エラーを生成しているObjective-Cメソッドが<code class="code-voice">BOOL</code>値を返してメソッド呼び出しが成功か失敗かを指し示すならば、スウィフトは関数の戻り型を<code class="code-voice">Void</code>に変えます。同様に、エラーを生成しているObjective-Cメソッドが<code class="code-voice">nil</code>値を返してメソッド呼び出しの失敗を指し示すならば、スウィフトは関数の戻り型を非オプショナル型に変えます。
</span><!--end_jpstr-->
</p><p class="para">
  Otherwise, if no convention can be inferred, the method is left intact.
<br><span class="jpstr">
それ以外では、推論されることができる慣行がないならば、メソッドは元のままにしておかれます。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-NoLink_19"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Use the <code class="code-voice">NS_SWIFT_NOTHROW</code> macro on an Objective-C method declaration that produces an <code class="code-voice">NSError</code> to prevent it from being imported by Swift as a method that throws.
    	<br><span class="jpstr">
<code class="code-voice">NS_SWIFT_NOTHROW</code>マクロを<code class="code-voice">NSError</code>を生み出すObjective-Cメソッド宣言上で使って、それがスウィフトによってスローするメソッドとしてインポートされるのを防止してください。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID174"></a>
  <h3 class="section-name" tabindex="0">Catching and Handling an Error<br><span class="jpstr">
エラーを捕えて処理する
</span><!--end_jpstr-->
</h3>
  <p class="para">
  In Objective-C, error handling is opt-in, meaning that errors produced by calling a method are ignored unless an error pointer is provided. In Swift, calling a method that throws requires explicit error handling.
<br><span class="jpstr">
Objective-Cでは、エラー処理はオプトインです、それはメソッドを呼び出すことで生成されたエラーはエラーポインターが提供されない限りは無視されるということを意味しています。スウィフトでは、スローするメソッドを呼び出すことは明確にエラー処理することを必要とします。
</span><!--end_jpstr-->
</p><p class="para">
  Here’s an example of how to handle an error when calling a method in Objective-C:
<br><span class="jpstr">
ここにObejctive-Cにおいてメソッドを呼び出す時どのようにエラーを取り扱うかの例があります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="n">NSFileManager</span> <span class="o">*</span><span class="n">fileManager</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSFileManager</span> <span class="n">defaultManager</span><span class="p">];</span>
</code></li>
            <li><code class="code-voice"><span class="n">NSURL</span> <span class="o">*</span><span class="n">fromURL</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nl">fileURLWithPath:</span><span class="s">@&quot;/path/to/old&quot;</span><span class="p">];</span>
</code></li>
            <li><code class="code-voice"><span class="n">NSURL</span> <span class="o">*</span><span class="n">toURL</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nl">fileURLWithPath:</span><span class="s">@&quot;/path/to/new&quot;</span><span class="p">];</span>
</code></li>
            <li><code class="code-voice"><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="kt">BOOL</span> <span class="n">success</span> <span class="o">=</span> <span class="p">[</span><span class="n">fileManager</span> <span class="nl">moveItemAtURL:</span><span class="n">fromURL</span> <span class="nl">toURL:</span><span class="n">toURL</span> <span class="nl">error:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</code></li>
            <li><code class="code-voice"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
</code></li>
            <li><code class="code-voice">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Error: %@&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">.</span><span class="n">domain</span><span class="p">);</span>
</code></li>
            <li><code class="code-voice"><span class="p">}</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  And here’s the equivalent code in Swift:
<br><span class="jpstr">
そしてここにスウィフトにおける同等のコードがあります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">fileManager</span> = <span class="vc">FileManager</span>.<span class="kt">default</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">fromURL</span> = <span class="vc">URL</span>(<span class="vc">fileURLWithPath</span>: <span class="s">&quot;/path/to/old&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">toURL</span> = <span class="vc">URL</span>(<span class="vc">fileURLWithPath</span>: <span class="s">&quot;/path/to/new&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="kt">do</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">try</span> <span class="vc">fileManager</span>.<span class="vc">moveItem</span>(<span class="vc">at</span>: <span class="vc">fromURL</span>, <span class="vc">to</span>: <span class="vc">toURL</span>)</code></li>
            <li><code class="code-voice">} <span class="kt">catch</span> <span class="kt">let</span> <span class="vc">error</span> <span class="kt">as</span> <span class="n"><! -- a href="" -->NSError<! -- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;Error: </span>\(<span class="vc">error</span>.<span class="vc">domain</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Additionally, you can use <code class="code-voice">catch</code> clauses to match on particular error codes as a convenient way to differentiate possible failure conditions:
<br><span class="jpstr">
加えて、あなたは、起こりうる失敗条件を見分ける便利な方法として、<code class="code-voice">catch</code>節を特定のエラーコードで一致するように使うことができます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">do</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">try</span> <span class="vc">fileManager</span>.<span class="vc">moveItem</span>(<span class="vc">at</span>: <span class="vc">fromURL</span>, <span class="vc">to</span>: <span class="vc">toURL</span>)</code></li>
            <li><code class="code-voice">} <span class="kt">catch</span> <span class="vc">CocoaError</span>.<span class="vc">fileNoSuchFile</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;Error: no such file exists&quot;</span>)</code></li>
            <li><code class="code-voice">} <span class="kt">catch</span> <span class="vc">CocoaError</span>.<span class="vc">fileReadUnsupportedScheme</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;Error: unsupported scheme (should be &#39;file://&#39;)&quot;</span>)</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID180"></a>
  <h3 class="section-name" tabindex="0">Converting Errors to Optional Values<br><span class="jpstr">
エラーをオプショナルの値に変換する
</span><!--end_jpstr-->
</h3>
  <p class="para">
  In Objective-C, you pass <code class="code-voice">NULL</code> for the error parameter when you only care whether there was an error, not what specific error occurred. In Swift, you write <code class="code-voice">try?</code> to change a throwing expression into one that returns an optional value, and then check whether the value is <code class="code-voice">nil</code>.
<br><span class="jpstr">
Objective-Cでは、あなたは<code class="code-voice">NULL</code>をエラーパラメータのために渡すことが、あなたが心配するのがただエラーがあったかどうかだけであり、特定のエラーに出くわしたことではない時に行えます。スウィフトでは、あなたは<code class="code-voice">try?</code>を書くことで、スローする式をオプショナルの値を返すものへと変えて、それからその値が<code class="code-voice">nil</code>かどうかを調べます。
</span><!--end_jpstr-->
</p><p class="para">
  For example, the <code class="code-voice">NSFileManager</code> instance method <code class="code-voice">URL(for:in:appropriateForURL:create:)</code> returns a URL in the specified search path and domain, or produces an error if an appropriate URL does not exist and cannot be created. In Objective-C, the success or failure of the method can be determined by whether an <code class="code-voice">NSURL</code> object is returned.
<br><span class="jpstr">
例えば、<code class="code-voice">NSFileManager</code>のインスタンスメソッド<code class="code-voice">URL(for:in:appropriateForURL:create:)</code>は指定された検索パスとドメインにおけるURLを返すか、または適切なURLが存在せず作成もできないならばエラーを生成します。Objective-Cでは、メソッドの成功や失敗は、<code class="code-voice">NSURL</code>オブジェクトが返されるかどうかによって判断されることができます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="n">NSFileManager</span> <span class="o">*</span><span class="n">fileManager</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSFileManager</span> <span class="n">defaultManager</span><span class="p">];</span>
</code></li>
            <li><code class="code-voice"> 
</code></li>
            <li><code class="code-voice"><span class="n">NSURL</span> <span class="o">*</span><span class="n">tmpURL</span> <span class="o">=</span> <span class="p">[</span><span class="n">fileManager</span> <span class="nl">URLForDirectory:</span><span class="n">NSCachesDirectory</span>
</code></li>
            <li><code class="code-voice">                                    <span class="nl">inDomain:</span><span class="n">NSUserDomainMask</span>
</code></li>
            <li><code class="code-voice">                           <span class="nl">appropriateForURL:</span><span class="nb">nil</span>
</code></li>
            <li><code class="code-voice">                                      <span class="nl">create:</span><span class="n">YES</span>
</code></li>
            <li><code class="code-voice">                                       <span class="nl">error:</span><span class="nb">nil</span><span class="p">];</span>
</code></li>
            <li><code class="code-voice"> 
</code></li>
            <li><code class="code-voice"><span class="k">if</span> <span class="p">(</span><span class="n">tmpURL</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</code></li>
            <li><code class="code-voice">   <span class="c1">// ...</span>
</code></li>
            <li><code class="code-voice"><span class="p">}</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can do the same in Swift as follows:
<br><span class="jpstr">
あなたは、同じことをスウィフトにおいて以下のように行えます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">fileManager</span> = <span class="vc">FileManager</span>.<span class="kt">default</span></code></li>
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">tmpURL</span> = <span class="kt">try</span>? <span class="vc">fileManager</span>.<span class="vc">url</span>(<span class="vc">for</span>: .<span class="vc">cachesDirectory</span>, <span class="vc">in</span>: .<span class="vc">userDomainMask</span>, <span class="vc">appropriateFor</span>: <span class="kt">nil</span>, <span class="vc">create</span>: <span class="kt">true</span>) {</code></li>
            <li><code class="code-voice">    <span class="c">// ...</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID175"></a>
  <h3 class="section-name" tabindex="0">Throwing an Error<br><span class="jpstr">
エラーをスローする
</span><!--end_jpstr-->
</h3>
  <p class="para">
  If an error occurs in an Objective-C method, that error is used to populate the error pointer argument of that method:
<br><span class="jpstr">
エラーがObjective-Cメソッドにおいて起こるならば、そのエラーはそのメソッドのエラーポインター引数に入れられるために使われます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="c1">// an error occurred</span>
</code></li>
            <li><code class="code-voice"><span class="k">if</span> <span class="p">(</span><span class="n">errorPtr</span><span class="p">)</span> <span class="p">{</span>
</code></li>
            <li><code class="code-voice">   <span class="o">*</span><span class="n">errorPtr</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSError</span> <span class="nl">errorWithDomain:</span><span class="n">NSURLErrorDomain</span>
</code></li>
            <li><code class="code-voice">                                   <span class="nl">code:</span><span class="n">NSURLErrorCannotOpenFile</span>
</code></li>
            <li><code class="code-voice">                               <span class="nl">userInfo:</span><span class="nb">nil</span><span class="p">];</span>
</code></li>
            <li><code class="code-voice"><span class="p">}</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If an error occurs in a Swift method, the error is thrown, and automatically propagated to the caller:
<br><span class="jpstr">
エラーがスウィフトメソッドにおいて起こるならば、そのエラーはスローされます、そして自動的に呼び出し側に伝達されます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="c">// an error occurred</span></code></li>
            <li><code class="code-voice"><span class="kt">throw</span> <span class="vc">NSError</span>(<span class="vc">domain</span>: <span class="vc">NSURLErrorDomain</span>, <span class="vc">code</span>: <span class="vc">NSURLErrorCannotOpenFile</span>, <span class="vc">userInfo</span>: <span class="kt">nil</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If Objective-C code calls a Swift method that throws an error, the error is automatically propagated to the error pointer argument of the bridged Objective-C method.
<br><span class="jpstr">
Objective-Cコードがエラーをスローするスウィフトメソッドを呼ぶならば、そのエラーは橋渡しされたObjective-Cメソッドのエラーポインタ引数に自動的に伝達されます。
</span><!--end_jpstr-->
</p><p class="para">
  For example, consider the <code class="code-voice">read(from:ofType:)</code> method in <code class="code-voice">NSDocument</code>. In Objective-C, this method’s last parameter is of type <code class="code-voice">NSError **</code>. When overriding this method in a Swift subclass of <code class="code-voice">NSDocument</code>, the method replaces its error parameter and throws instead.
<br><span class="jpstr">
例として、<code class="code-voice">NSDocument</code>の<code class="code-voice">read(from:ofType:)</code>メソッドを考えてください。Objective-Cでは、このメソッドの最後のパラメーターは型<code class="code-voice">NSError **</code>です。このメソッドを<code class="code-voice">NSDocument</code>のスウィフトのサブクラスにおいてオーバーライドする時、メソッドはそれのエラーパラメーターを置き替えて、代わりにスローをします。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">SerializedDocument</span>: <span class="n"><! -- a href="" -->NSDocument<! -- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">static</span> <span class="kt">let</span> <span class="vc">ErrorDomain</span> = <span class="s">&quot;com.example.error.serialized-document&quot;</span></code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">representedObject</span>: [<span class="n"><! -- a href="" -->String<! -- /a --></span>: <span class="kt">Any</span>] = [:]</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">override</span> <span class="kt">func</span> <span class="vc">read</span>(<span class="vc">from</span> <span class="vc">fileWrapper</span>: <span class="n"><! -- a href="" -->FileWrapper<! -- /a --></span>, <span class="vc">ofType</span> <span class="vc">typeName</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>) <span class="kt">throws</span> {</code></li>
            <li><code class="code-voice">        <span class="kt">guard</span> <span class="kt">let</span> <span class="vc">data</span> = <span class="vc">fileWrapper</span>.<span class="vc">regularFileContents</span> <span class="kt">else</span> {</code></li>
            <li><code class="code-voice">            <span class="kt">throw</span> <span class="vc">NSError</span>(<span class="vc">domain</span>: <span class="vc">NSURLErrorDomain</span>, <span class="vc">code</span>: <span class="vc">NSURLErrorCannotOpenFile</span>, <span class="vc">userInfo</span>: <span class="kt">nil</span>)</code></li>
            <li><code class="code-voice">        }</code></li>
            <li><code class="code-voice">        </code></li>
            <li><code class="code-voice">        <span class="kt">if</span> <span class="kt">case</span> <span class="kt">let</span> <span class="vc">JSON</span> <span class="kt">as</span> [<span class="n"><! -- a href="" -->String<! -- /a --></span>: <span class="kt">Any</span>] = <span class="kt">try</span> <span class="vc">JSONSerialization</span>.<span class="vc">jsonObject</span>(<span class="vc">with</span>: <span class="vc">data</span>) {</code></li>
            <li><code class="code-voice">            <span class="kt">self</span>.<span class="vc">representedObject</span> = <span class="vc">JSON</span></code></li>
            <li><code class="code-voice">        } <span class="kt">else</span> {</code></li>
            <li><code class="code-voice">            <span class="kt">throw</span> <span class="vc">NSError</span>(<span class="vc">domain</span>: <span class="vc">SerializedDocument</span>.<span class="vc">ErrorDomain</span>, <span class="vc">code</span>: <span class="m">-1</span>, <span class="vc">userInfo</span>: <span class="kt">nil</span>)</code></li>
            <li><code class="code-voice">        }</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If the method is unable to create an object with the regular file contents of the document, it throws an <code class="code-voice">NSError</code> object. If the method is called from Swift code, the error is propagated to its calling scope. If the method is called from Objective-C code, the error instead populates the error pointer argument.
<br><span class="jpstr">
メソッドがオブジェクトを書類の標準ファイル内容で作成することができないならば、それは<code class="code-voice">NSError</code>オブジェクトをスローします。メソッドがスウィフトコードから呼ばれるならば、エラーはそれを呼び出しているスコープに伝えられます。メソッドがObjective-Cコードから呼ばれるならば、代わりにエラーはエラーポインタ引数に入れられます。
</span><!--end_jpstr-->
</p><p class="para">
  In Objective-C, error handling is opt-in, meaning that errors produced by calling a method are ignored unless you provide an error pointer. In Swift, calling a method that throws requires explicit error handling.
<br><span class="jpstr">
Objective-Cでは、エラー処理はオプトインです、それはメソッドを呼び出すことで生成されたエラーはあなたがエラーポインターを提供しない限りは無視されるということを意味しています。スウィフトでは、スローするメソッドを呼び出すことは明確にエラー処理することを必要とします。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-NoLink_20"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Although Swift error handling resembles exception handling in Objective-C, it is entirely separate functionality. If an Objective-C method throws an exception during runtime, Swift triggers a runtime error. There is no way to recover from Objective-C exceptions directly in Swift. Any exception handling behavior must be implemented in Objective-C code used by Swift.
    	<br><span class="jpstr">
スウィフトエラー処理はObjective-Cでの例外処理に似ていますが、それは完全に関係のない機能です。Objective-Cメソッドが実行時に例外をスローするならば、スウィフトは実行時エラーの引き金を引きます。スウィフトには直接にObjective-C例外から回復する方法はありません。どのような例外処理挙動もスウィフトによって使用されるObjective-Cコードの中で実装されなければなりません。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID223"></a>
  <h3 class="section-name" tabindex="0">Catching and Handling Custom Errors<br><span class="jpstr">
カスタムエラーを捕まえて処理する
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Objective-C frameworks can use custom error domains and enumerations to group related categories of errors.
<br><span class="jpstr">
Objective-Cフレームワークは、カスタムエラードメインと列挙を使って、エラーの関連カテゴリをグループ化します。
</span><!--end_jpstr-->
</p><p class="para">
  The example below shows a customized error type defined using the <code class="code-voice">NS_ERROR_ENUM</code> macro in Objective-C:
<br><span class="jpstr">
下の例は、Objective-Cにおいて<code class="code-voice">NS_ERROR_ENUM</code>を使ってカスタマイズされたエラー型を示します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="k">extern</span> <span class="n">NSErrorDomain</span> <span class="k">const</span> <span class="n">MyErrorDomain</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">typedef</span> <span class="nf">NS_ERROR_ENUM</span><span class="p">(</span><span class="n">MyErrorDomain</span><span class="p">,</span> <span class="n">MyError</span><span class="p">)</span> <span class="p">{</span>
</code></li>
            <li><code class="code-voice">    <span class="n">specificError1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</code></li>
            <li><code class="code-voice">    <span class="n">specificError2</span> <span class="o">=</span> <span class="mi">1</span>
</code></li>
            <li><code class="code-voice"><span class="p">};</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  This example shows how to generate errors using that custom error type in Swift:
<br><span class="jpstr">
この例は、そのあつらえのエラー型をスウィフトにおいて使うことでエラーを生成する方法を示します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">customThrow</span>() <span class="kt">throws</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">throw</span> <span class="vc">NSError</span>(</code></li>
            <li><code class="code-voice">        <span class="vc">domain</span>: <span class="vc">MyErrorDomain</span>,</code></li>
            <li><code class="code-voice">        <span class="vc">code</span>: <span class="vc">MyError</span>.<span class="vc">specificError2</span>.<span class="vc">rawValue</span>,</code></li>
            <li><code class="code-voice">        <span class="vc">userInfo</span>: [</code></li>
            <li><code class="code-voice">            <span class="vc">NSLocalizedDescriptionKey</span>: <span class="s">&quot;A customized error from MyErrorDomain.&quot;</span></code></li>
            <li><code class="code-voice">        ]</code></li>
            <li><code class="code-voice">    )</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">do</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">try</span> <span class="vc">customThrow</span>()</code></li>
            <li><code class="code-voice">} <span class="kt">catch</span> <span class="vc">MyError</span>.<span class="vc">specificError1</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;Caught specific error #1&quot;</span>)</code></li>
            <li><code class="code-voice">} <span class="kt">catch</span> <span class="kt">let</span> <span class="vc">error</span> <span class="kt">as</span> <span class="n"><! -- a href="" -->MyError<! -- /a --></span> <span class="kt">where</span> <span class="vc">error</span>.<span class="vc">code</span> == .<span class="vc">specificError2</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;Caught specific error #2, &quot;</span>, <span class="vc">error</span>.<span class="vc">localizedDescription</span>)</code></li>
            <li><code class="code-voice">    <span class="c">// Prints &quot;Caught specific error #2. A customized error from MyErrorDomain.&quot;</span></code></li>
            <li><code class="code-voice">} <span class="kt">let</span> <span class="vc">error</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">fatalError</span>(<span class="s">&quot;Some other error: </span>\(<span class="vc">error</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID12"></a>
  <h3 class="section-name" tabindex="0">Key-Value Observing<br><span class="jpstr">
キー値監視
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Key-value observing is a mechanism that allows objects to be notified of changes to specified properties of other objects. You can use key-value observing with a Swift class, as long as the class inherits from the <code class="code-voice">NSObject</code> class. You can use these two steps to implement key-value observing in Swift.
<br><span class="jpstr">
キー値監視は、オブジェクトが他のオブジェクトの指定されたプロパティに対する変更を通知されるようにする仕組みです。あなたは、そのクラスが<code class="code-voice">NSObject</code>クラスから継承する限り、スウィフトクラスでキー値監視を使うことができます。あなたは、これら２つの手順を使ってキー値監視をスウィフトにおいて実装できます。
</span><!--end_jpstr-->
</p><ol class="list-number">
  <li class="item"><p class="para">
  Add the <code class="code-voice">dynamic</code> modifier and <code class="code-voice">@objc</code> attribute to any property you want to observe. For more information on <code class="code-voice">dynamic</code>, see <span class="x-name"><a href="InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID57" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID57">Requiring Dynamic Dispatch</a></span>.
<br><span class="jpstr">
<code class="code-voice">dynamic</code>修飾子と<code class="code-voice">@objc</code>属性をあなたが監視したい何らかのプロパティに加えてください。<code class="code-voice">dynamic</code>に関数さらなる情報として、<span class="x-name"><a href="InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID57" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID57">動的なディスパッチを要求する</a></span>を見てください。
</span><!--end_jpstr-->
</p>
<section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">MyObjectToObserve</span>: <span class="n"><! -- a href="" -->NSObject<! -- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">@objc</span> <span class="kt">dynamic</span> <span class="kt">var</span> <span class="vc">myDate</span> = <span class="vc">NSDate</span>()</code></li>
            <li><code class="code-voice">    <span class="kt">func</span> <span class="vc">updateDate</span>() {</code></li>
            <li><code class="code-voice">        <span class="vc">myDate</span> = <span class="vc">NSDate</span>()</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section>
</li><li class="item"><p class="para">
  Create an observer for the key path and call the <code class="code-voice">observe(_:options:changeHandler)</code> method. For more information on key paths, see <span class="x-name"><a href="InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID205" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID205">Keys and Key Paths</a></span>.
<br><span class="jpstr">
キーパスに対する監視を作成して<code class="code-voice">observe(_:options:changeHandler)</code>メソッドを呼び出してください。新しいキーパスについてのさらなる情報として、<span class="x-name"><a href="InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID205" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID205">キーとキーパス</a></span>を見てください。
</span><!--end_jpstr-->
</p>
<section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">MyObserver</span>: <span class="n"><! -- a href="" -->NSObject<! -- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">@objc</span> <span class="kt">var</span> <span class="vc">objectToObserve</span>: <span class="n"><! -- a href="" -->MyObjectToObserve<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">observation</span>: <span class="n"><! -- a href="" -->NSKeyValueObservation<! -- /a --></span>?</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">object</span>: <span class="n"><! -- a href="" -->MyObjectToObserve<! -- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="vc">objectToObserve</span> = <span class="vc">object</span></code></li>
            <li><code class="code-voice">        <span class="kt">super</span>.<span class="kt">init</span>()</code></li>
            <li><code class="code-voice">        </code></li>
            <li><code class="code-voice">        <span class="vc">observation</span> = <span class="vc">observe</span>(\.<span class="vc">objectToObserve</span>.<span class="vc">myDate</span>) { <span class="vc">object</span>, <span class="vc">change</span> <span class="kt">in</span></code></li>
            <li><code class="code-voice">            <span class="vc">print</span>(<span class="s">&quot;Observed a change to </span>\(<span class="vc">object</span>.<span class="vc">objectToObserve</span>)<span class="s">.myDate, updated to: </span>\(<span class="vc">object</span>.<span class="vc">objectToObserve</span>.<span class="vc">myDate</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice">        }</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">observed</span> = <span class="vc">MyObjectToObserve</span>()</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">observer</span> = <span class="vc">MyObserver</span>(<span class="vc">object</span>: <span class="vc">observed</span>)</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">observed</span>.<span class="vc">updateDate</span>()</code></li>
        </ol>
      </div>
  </div>
</section>
</li>
</ol>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID14"></a>
  <h3 class="section-name" tabindex="0">Target-Action<br><span class="jpstr">
ターゲット-アクション
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Target-action is a common Cocoa design pattern in which one object sends a message to another object when a specific event occurs. The target-action model is fundamentally similar in Swift and Objective-C. In Swift, you use the <code class="code-voice">Selector</code> type to refer to Objective-C selectors. For an example of using target-action in Swift code, see <span class="x-name"><a href="InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID59" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID59">Selectors</a></span>.
<br><span class="jpstr">
ターゲット-アクションは、特定のイベントが起こる時にあるオブジェクトが別のオブジェクトにメッセージを送る場合の、一般的なココア・デザインパターンです。ターゲット-アクションの雛形は、スウィフトとObjective-Cで基本的に類似しています。スウィフトにおいて、あなたはObjective-Cセレクタに言及するために<code class="code-voice">Selector</code>型を使います。スウィフトコードにおいてターゲット-アクションを使う例のために、<span class="x-name"><a href="InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID59" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID59">セレクタ</a></span>を見てください。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID177"></a>
  <h3 class="section-name" tabindex="0">Singleton<br><span class="jpstr">
シングルトン
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Singletons provide a globally accessible, shared instance of an object. You can create your own singletons as a way to provide a unified access point to a resource or service that’s shared across an app, such as an audio channel to play sound effects or a network manager to make HTTP requests.
<br><span class="jpstr">
シングルトンは、全体で利用できる、共有されるひとつのインスタンスを、あるオブジェクトに提供します。あなたは、あるアプリ全体で共有されるリソースやサービス、例えばサウンドエフェクトを再生するオーディオチャンネルやHTTPリクエストを行うネットワークマネージャなどへの一本化されたアクセスポイントを提供する方法として、あなた自身のシングルトンを作成します。
</span><!--end_jpstr-->
</p><p class="para">
  In Objective-C, you can ensure that only one instance of a singleton object is created by wrapping its initialization in a call the <code class="code-voice">dispatch_once</code> function, which executes a block once and only once for the lifetime of an app:
<br><span class="jpstr">
Objective-Cでは、あなたはあるシングルトンオブジェクトにただ１つのインスタンスが作成されることを、それの初期化を、あるプロックをあるアプリのライフタイムに対していっぺんこっきり実行する<code class="code-voice">dispatch_once</code>関数呼び出しの中にラップする（包む）ことによって確実にできます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="o">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">sharedInstance</span> <span class="p">{</span>
</code></li>
            <li><code class="code-voice">    <span class="k">static</span> <span class="kt">id</span> <span class="n">_sharedInstance</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice">    <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice">    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</code></li>
            <li><code class="code-voice">        <span class="n">_sharedInstance</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</code></li>
            <li><code class="code-voice">    <span class="p">});</span>
</code></li>
            <li><code class="code-voice"> 
</code></li>
            <li><code class="code-voice">    <span class="k">return</span> <span class="n">_sharedInstance</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="p">}</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  In Swift, you can simply use a static type property, which is guaranteed to be lazily initialized only once, even when accessed across multiple threads simultaneously:
<br><span class="jpstr">
スウィフトでは、あなたは単にstatic型プロパティを使うことができます、それは、複数のスレッドから同時にアクセスされる時でさえも、ただ一度だけ遅延初期化されることを保証します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">Singleton</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">static</span> <span class="kt">let</span> <span class="vc">sharedInstance</span> = <span class="vc">Singleton</span>()</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If you need to perform additional setup beyond initialization, you can assign the result of the invocation of a closure to the global constant:
<br><span class="jpstr">
あなたが追加的な準備を初期化が済んだら実行する必要があるならば、あなたはあるクロージャの発動の結果をグローバル定数に割り当てることができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">Singleton</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">static</span> <span class="kt">let</span> <span class="vc">sharedInstance</span>: <span class="n"><! -- a href="" -->Singleton<! -- /a --></span> = {</code></li>
            <li><code class="code-voice">        <span class="kt">let</span> <span class="vc">instance</span> = <span class="vc">Singleton</span>()</code></li>
            <li><code class="code-voice">        <span class="c">// setup code</span></code></li>
            <li><code class="code-voice">        <span class="kt">return</span> <span class="vc">instance</span></code></li>
            <li><code class="code-voice">    }()</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  For more information, see <a href="../Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID264" data-renderer-version="2" target="_self">Type Properties</a> in <em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">The Swift Programming Language (Swift 4.1)</a></em>.
<br><span class="jpstr">
更なる情報として、<a href="../Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID264" data-renderer-version="2" target="_self">型プロパティ</a>を<em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">スウィフトプログラミング言語（Swift 4.1）</a></em>で見てください。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID16"></a>
  <h3 class="section-name" tabindex="0">Introspection<br><span class="jpstr">
自己観察
</span><!--end_jpstr-->
</h3>
  <p class="para">
  In Objective-C, you use the <code class="code-voice">isKindOfClass:</code> method to check whether an object is of a certain class type, and the <code class="code-voice">conformsToProtocol:</code> method to check whether an object conforms to a specified protocol. In Swift, you accomplish this task by using the <code class="code-voice">is</code> operator to check for a type, or the <code class="code-voice">as?</code> operator to downcast to that type.
<br><span class="jpstr">
Objective-Cでは、あるオブジェクトが特定のクラス型かどうか調べるために<code class="code-voice">isKindOfClass:</code>を、そしてオブジェクトが指定されたプロトコルに準拠するかどうか調べるために<code class="code-voice">conformsToProtocol:を</code>使います。スウィフトでは、あなたは、ある型か調べる<code class="code-voice">is</code>演算子、またはその型にダウンキャストする<code class="code-voice">as?</code>演算子を使うことによってこの作業を達成します。
</span><!--end_jpstr-->
</p><p class="para">
  You can check whether an instance is of a certain subclass type by using the <code class="code-voice">is</code> operator. The <code class="code-voice">is</code> operator returns <code class="code-voice">true</code> if the instance is of that subclass type, and <code class="code-voice">false</code> if it is not.
<br><span class="jpstr">
あなたは、あるインスタンスが特定のサブクラス型であるかどうか、<code class="code-voice">is</code>演算子を使うことによって調べることができます。<code class="code-voice">is</code>演算子は、そのインスタンスがそのサブクラス型であるならば<code class="code-voice">true</code>を、それがそうでないならば<code class="code-voice">false</code>返します。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">if</span> <span class="vc">object</span> <span class="kt">is</span> <span class="n"><! -- a href="" -->UIButton<! -- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="c">// object is of type UIButton&nbsp;<span class="jpstr">（オブジェクトは、型UIButtonです）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">} <span class="kt">else</span> {</code></li>
            <li><code class="code-voice">    <span class="c">// object is not of type UIButton&nbsp;<span class="jpstr">（オブジェクトは、型UIButtonではありません）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can also try and downcast to the subclass type by using the <code class="code-voice">as?</code> operator. The <code class="code-voice">as?</code> operator returns an optional value that can be bound to a constant using an <code class="code-voice">if</code>-<code class="code-voice">let</code> statement.
<br><span class="jpstr">
あなたはまた、<code class="code-voice">as?</code>演算子を使うことによって、そのサブクラス型へのダウンキャストを試みることができます。<code class="code-voice">as?</code>演算子は、<code class="code-voice">if</code>-<code class="code-voice">let</code>文を使って定数に束縛されることができるオプショナルの値を返します。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">button</span> = <span class="vc">object</span> <span class="kt">as</span>? <span class="n"><! -- a href="" -->UIButton<! -- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="c">// object is successfully cast to type UIButton and bound to button&nbsp;<span class="jpstr">（オブジェクトは、型UIButtonにうまくキャストされて、buttonに束縛されます）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">} <span class="kt">else</span> {</code></li>
            <li><code class="code-voice">    <span class="c">// object could not be cast to type UIButton&nbsp;<span class="jpstr">（オブジェクトは、型UIButtonにキャストされることができませんでした）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  For more information, see <a href="../Swift_Programming_Language/TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22" data-renderer-version="2" target="_self">Type Casting</a> in <em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">The Swift Programming Language (Swift 4.1)</a></em>.
<br><span class="jpstr">
さらなる情報として、<a href="../Swift_Programming_Language/TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22" data-renderer-version="2" target="_self">型キャスト</a>を<em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">スウィフトプログラミング言語（Swift 4.1）</a></em>で見てください。
</span><!--end_jpstr-->
</p><p class="para">
  Checking for and casting to a protocol follows exactly the same syntax as checking for and casting to a class. Here is an example of using the <code class="code-voice">as?</code> operator to check for protocol conformance:
<br><span class="jpstr">
あるプロトコルに対する調査とキャストは、あるクラスに対する調査とキャストと正確に同じ構文に従います。<code class="code-voice">as?</code>演算子を使ってプロトコル準拠について調べる例がここにあります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">dataSource</span> = <span class="vc">object</span> <span class="kt">as</span>? <span class="n"><! -- a href="" -->UITableViewDataSource<! -- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="c">// object conforms to UITableViewDataSource and is bound to dataSource&nbsp;<span class="jpstr">（オブジェクトは、UITableViewDataSourceに準拠して、dataSourceに結束されます）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">} <span class="kt">else</span> {</code></li>
            <li><code class="code-voice">    <span class="c">// object not conform to UITableViewDataSource&nbsp;<span class="jpstr">（オブジェクトは、UITableViewDataSourceに準拠しません）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Note that after this cast, the <code class="code-voice">dataSource</code> constant is of type <code class="code-voice">UITableViewDataSource</code>, so you can only call methods and access properties defined on the <code class="code-voice">UITableViewDataSource</code> protocol. You must cast it back to another type to perform other operations.
<br><span class="jpstr">
このキャストの後で、<code class="code-voice">dataSource</code>定数は型<code class="code-voice">UITableViewDataSource</code>である点に注意してください、なのであなたは<code class="code-voice">UITableViewDataSource</code>プロトコル上で定義されるメソッド呼び出しとプロパティアクセスができるだけです。あなたは、他の操作を実行するために再び別の型へそれをキャストしなければなりません。
</span><!--end_jpstr-->
</p><p class="para">
  For more information, see <a href="../Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25" data-renderer-version="2" target="_self">Protocols</a> in <em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">The Swift Programming Language (Swift 4.1)</a></em>.
<br><span class="jpstr">
さらなる情報として、<a href="../Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25" data-renderer-version="2" target="_self">プロトコル</a>を<em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">スウィフトプログラミング言語（Swift 4.1）</a></em>で見てください。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID182"></a>
  <h3 class="section-name" tabindex="0">Serialization<br><span class="jpstr">
シリアライズ
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Serialization allows you to encode and decode objects in your app to and from architecture-independent representations, such as JSON or property lists. These representations can then be written to a file, or transmitted to another process locally or over a network.
<br><span class="jpstr">
シリアライズは、オブジェクトをあなたのアプリにおいてアーキテクチャ非依存の表現、例えばJSONやプロパティリストなどに符号化および復号化できるようにします。これらの表現は、それからファイルに書き出されたり、別のプロセスにローカルにまたはそのネットワークを超えて送られたりができます。
</span><!--end_jpstr-->
</p><p class="para">
  In Objective-C, you can use the Foundation framework classes <code class="code-voice">NSJSONSerialization</code> and <code class="code-voice">NSPropertyListSerialization</code> to initialize objects from a decoded JSON or property list serialization value—usually an object of type <code class="code-voice">NSDictionary&lt;NSString *, id&gt;</code>.
<br><span class="jpstr">
Objective-Cでは、あなたはFoundationフレームワーククラスの<code class="code-voice">NSJSONSerialization</code>と<code class="code-voice">NSPropertyListSerialization</code>を使って、復号化されたJSONまたはプロパティリストのシリアライズ値 ― 通常は型<code class="code-voice">NSDictionary&lt;NSString *, id&gt;</code>のオブジェクトから各オブジェクトを初期化します。
</span><!--end_jpstr-->
</p><p class="para">
  In Swift, the standard library defines a standardized approach to data encoding and decoding. You adopt this approach by making your types conform to the <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/encodable" class="urlLink">Encodable</a></code> or <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/decodable" class="urlLink">Decodable</a></code> protocols, or by conforming to <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/codable" class="urlLink">Codable</a></code> as shorthand for conforming to both protocols. You can use the Foundation framework classes <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/foundation/jsonencoder" class="urlLink">JSONEncoder</a></code> and <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/foundation/propertylistencoder" class="urlLink">PropertyListEncoder</a></code> to convert instances to JSON or property list data. Similarly, you can use the <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/foundation/jsondecoder" class="urlLink">JSONDecoder</a></code> and <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/foundation/propertylistdecoder" class="urlLink">PropertyListDecoder</a></code> classes to decode and initialize instances from JSON or property list data.
<br><span class="jpstr">
スウィフトでは、標準ライブラリが標準化された取り組みをデータのエンコーディングとデコーディングに対して定義します。あなたはこの取り組み方を、あなたの型を<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/encodable" class="urlLink">Encodable</a></code>または<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/decodable" class="urlLink">Decodable</a></code>プロトコルに準拠するようにして、または両方のプロトコルへの準拠の簡略法として<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/codable" class="urlLink">Codable</a></code>に準拠することによって採用します。あなたは、Foundationフレームワーククラス<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/foundation/jsonencoder" class="urlLink">JSONEncoder</a></code>と<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/foundation/propertylistencoder" class="urlLink">PropertyListEncoder</a></code>を使って、インスタンスをJSONまたはプロパティリストデータへ変換します。同様に、あなたは<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/foundation/jsondecoder" class="urlLink">JSONDecoder</a></code>と<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/foundation/propertylistdecoder" class="urlLink">PropertyListDecoder</a></code>クラスを使って、インスタンスをJSONまたはプロパティリストデータからデコードして初期化します。
</span><!--end_jpstr-->
</p><p class="para">
  For example, an app that communicates with a web server would receive JSON representations of grocery products, such as:
<br><span class="jpstr">
例えば、あるアプリでウェブサーバと通信するものは、日用製品のJSON表現を受け取るでしょう、このように：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="">
        <ol class="code-lines">
            <li><code class="code-voice">{</code></li>
            <li><code class="code-voice">     &quot;name&quot;: &quot;Banana&quot;,</code></li>
            <li><code class="code-voice">     &quot;points&quot;: 200,</code></li>
            <li><code class="code-voice">     &quot;description&quot;: &quot;A banana grown in Ecuador.&quot;,</code></li>
            <li><code class="code-voice">     &quot;varieties&quot;: [</code></li>
            <li><code class="code-voice">         &quot;yellow&quot;,</code></li>
            <li><code class="code-voice">         &quot;green&quot;,</code></li>
            <li><code class="code-voice">         &quot;brown&quot;</code></li>
            <li><code class="code-voice">      ]</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how to write a Swift type that represents a grocery product and can be used with any serialization format that provides encoders and decoders:
<br><span class="jpstr">
ここにあるのは、日用製品を表して、エンコーダおよびデコーダで提供される何らかのシリアライズ形式で使用できるスウィフト型を書く方法です：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">struct</span> <span class="vc">GroceryProduct</span>: <span class="n"><! -- a href="" -->Codable<! -- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">points</span>: <span class="n"><! -- a href="" -->Int<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">description</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">varieties</span>: [<span class="n"><! -- a href="" -->String<! -- /a --></span>]</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can create a <code class="code-voice">GroceryProduct</code> from a JSON representation by creating a <code class="code-voice">JSONDecoder</code> instance and passing it the <code class="code-voice">GroceryProduct.self</code> type along with the JSON data:
<br><span class="jpstr">
あなたは<code class="code-voice">GroceryProduct</code>をJSON表現から作成することが<code class="code-voice">JSONDecoder</code>インスタンスを作成してそれを<code class="code-voice">GroceryProduct.self</code>型にそのJSONデータとともに渡すことによって可能です。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">json</span> = <span class="s">&quot;&quot;&quot;</span></code></li>
            <li><code class="code-voice"><span class="s">    {</span></code></li>
            <li><code class="code-voice"><span class="s">         &quot;name&quot;: &quot;Banana&quot;,</span></code></li>
            <li><code class="code-voice"><span class="s">         &quot;points&quot;: 200,</span></code></li>
            <li><code class="code-voice"><span class="s">         &quot;description&quot;: &quot;A banana grown in Ecuador.&quot;,</span></code></li>
            <li><code class="code-voice"><span class="s">         &quot;varieties&quot;: [</span></code></li>
            <li><code class="code-voice"><span class="s">             &quot;yellow&quot;,</span></code></li>
            <li><code class="code-voice"><span class="s">             &quot;green&quot;,</span></code></li>
            <li><code class="code-voice"><span class="s">             &quot;brown&quot;</span></code></li>
            <li><code class="code-voice"><span class="s">          ]</span></code></li>
            <li><code class="code-voice"><span class="s">    }</span></code></li>
            <li><code class="code-voice"><span class="s">&quot;&quot;&quot;</span>.<span class="vc">data</span>(<span class="vc">using</span>: .<span class="vc">utf8</span>)!</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">decoder</span> = <span class="vc">JSONDecoder</span>()</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">banana</span> = <span class="kt">try</span> <span class="vc">decoder</span>.<span class="vc">decode</span>(<span class="vc">GroceryProduct</span>.<span class="kt">self</span>, <span class="vc">from</span>: <span class="vc">json</span>)</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">print</span>(<span class="s">&quot;</span>\(<span class="vc">banana</span>.<span class="vc">name</span>)<span class="s"> (</span>\(<span class="vc">banana</span>.<span class="vc">points</span>)<span class="s"> points): </span>\(<span class="vc">banana</span>.<span class="vc">description</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;Banana (200 points): A banana grown in Ecuador.&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  For information about encoding and decoding more complex custom types, see <a href="https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types">Encoding and Decoding Custom Types</a>. For more information about encoding and decoding JSON, see <a href="https://developer.apple.com/documentation/foundation/archives_and_serialization/using_json_with_custom_types">Using JSON with Custom Types</a>.
<br><span class="jpstr">
より複雑なカスタム型のエンコードおよびデコードについての情報として、<a href="https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types">Encoding and Decoding Custom Types</a>を見てください。JSONのエンコードおよびデコードについてのさらなる情報として、<a href="https://developer.apple.com/documentation/foundation/archives_and_serialization/using_json_with_custom_types">Using JSON with Custom Types</a>を見てください。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID65"></a>
  <h3 class="section-name" tabindex="0">Localization<br><span class="jpstr">
現地語化
</span><!--end_jpstr-->
</h3>
  <p class="para">
  In Objective-C, you typically use the <code class="code-voice">NSLocalizedString</code> family of macros to localize strings. These include <code class="code-voice">NSLocalizedString</code>, <code class="code-voice">NSLocalizedStringFromTable</code>, <code class="code-voice">NSLocalizedStringFromTableInBundle</code>, and <code class="code-voice">NSLocalizedStringWithDefaultValue</code>. In Swift, the functionality of these macros is made available through a single function: <code class="code-voice">NSLocalizedString(_:tableName:bundle:value:comment:)</code>.
<br><span class="jpstr">
Objective-Cでは、あなたは一般的に文字列を現地語化するためにマクロの<code class="code-voice">NSLocalizedString</code>ファミリーを使います。これらは、<code class="code-voice">NSLocalizedString</code>, <code class="code-voice">NSLocalizedStringFromTable</code>, <code class="code-voice">NSLocalizedStringFromTableInBundle</code>, そして<code class="code-voice">NSLocalizedStringWithDefaultValue</code>を含みます。スウィフトでは、これらのマクロの機能性は、ただ１つの関数：<code class="code-voice">NSLocalizedString(_:tableName:bundle:value:comment:)</code>を通して利用可能にされます。
</span><!--end_jpstr-->
</p><p class="para">
  Rather than defining separate functions that correspond to each Objective-C macro, the Swift <code class="code-voice">NSLocalizedString(_:tableName:bundle:value:)</code> function specifies default values for the <code class="code-voice">tableName</code>, <code class="code-voice">bundle</code>, and <code class="code-voice">value</code> arguments, so that they may be overridden as necessary.
<br><span class="jpstr">
それぞれのObjective-Cマクロに対応した独立した関数を定義するのではなく、スウィフトの<code class="code-voice">NSLocalizedString(_:tableName:bundle:value:)</code>関数は<code class="code-voice">tableName</code>、<code class="code-voice">bundle</code>、そして<code class="code-voice">value</code>引数に省略時の値を指定します、それでそれらは必要に応じてオーバーライドされることができます。
</span><!--end_jpstr-->
</p><p class="para">
  For example, the most common form of a localized string in an app may only need a localization key and a comment:
<br><span class="jpstr">
例えば、アプリにおける最も一般的な形式の現地語化文字列は、現地語キーとコメントを必要とするだけでしょう：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">format</span> = <span class="vc">NSLocalizedString</span>(<span class="s">&quot;Hello, %@!&quot;</span>, <span class="vc">comment</span>: <span class="s">&quot;Hello, {given name}!&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">name</span> = <span class="s">&quot;Mei&quot;</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">greeting</span> = <span class="vc">String</span>(<span class="vc">format</span>: <span class="vc">format</span>, <span class="vc">arguments</span>: [<span class="vc">name</span> <span class="kt">as</span> <span class="n"><! -- a href="" -->CVarArg<! -- /a --></span>])</code></li>
            <li><code class="code-voice"><span class="vc">print</span>(<span class="vc">greeting</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;Hello, Mei!&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Or, an app may require more complex usage in order to use localization resources from a separate bundle:
<br><span class="jpstr">
または、独立したバンドルから現地語化リソースを使うために、アプリはより複雑な語法を必要とするかもしれません：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">path</span> = <span class="vc">Bundle</span>.<span class="vc">main</span>.<span class="vc">path</span>(<span class="vc">forResource</span>: <span class="s">&quot;Localization&quot;</span>, <span class="vc">ofType</span>: <span class="s">&quot;strings&quot;</span>, <span class="vc">inDirectory</span>: <span class="kt">nil</span>, <span class="vc">forLocalization</span>: <span class="s">&quot;ja&quot;</span>),</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">bundle</span> = <span class="vc">Bundle</span>(<span class="vc">path</span>: <span class="vc">path</span>) {</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">translation</span> = <span class="vc">NSLocalizedString</span>(<span class="s">&quot;Hello&quot;</span>, <span class="vc">bundle</span>: <span class="vc">bundle</span>, <span class="vc">comment</span>: <span class="s">&quot;&quot;</span>)</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="vc">translation</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;こんにちは&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  For more information, see <em class="u-book"><a href="../../../MacOSX/Conceptual/BPInternational/Introduction/Introduction.html#//apple_ref/doc/uid/10000171i" data-renderer-version="1" target="_self">Internationalization and Localization Guide</a></em>.
<br><span class="jpstr">
さらなる情報として、<em class="u-book"><a href="../../../MacOSX/Conceptual/BPInternational/Introduction/Introduction.html#//apple_ref/doc/uid/10000171i" data-renderer-version="1" target="_self">インターナショナライゼーションとローカリゼーションのガイド</a></em>（Apple訳有り）を見てください。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID216"></a>
  <h3 class="section-name" tabindex="0">Autorelease Pools<br><span class="jpstr">
オートリリースプール
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Autorelease pool blocks allow objects to relinquish ownership without being deallocated immediately. Typically, you don’t need to create your own autorelease pool blocks, but there are some situations in which either you must—such as when spawning a secondary thread—or it is beneficial to do so—such as when writing a loop that creates many temporary objects.
<br><span class="jpstr">
オートリリースプール・ブロックは、オブジェクトに直ちにデアロケートされることなしに所有権を放棄させます。概して、あなたはあなた独自のオートリリース・ブロックを作成する必要はありません、しかしいくつかの状況があり、そこにおいては、あなたが必要とする—例えば副次的スレッドを生み出す時など—もしくはそうすることが利益をもたらす—例えば多くの一時的オブジェクトを作成するあるループを書く時など—のいずれかです。
</span><!--end_jpstr-->
</p><p class="para">
  In Objective-C, autorelease pool blocks are marked using <code class="code-voice">@autoreleasepool</code>. In Swift, you can use the <code class="code-voice">autoreleasepool(_:)</code> function to execute a closure within an autorelease pool block.
<br><span class="jpstr">
Objective-Cでは、オートリリース・ブロックは<code class="code-voice">@autoreleasepool</code>を使って印されます。スウィフトでは、あなたは<code class="code-voice">autoreleasepool(_:)</code>関数を使って、あるクロージャをオートリリース・ブロックの内部で実行できます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">import</span> <span class="vc">Foundation</span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">autoreleasepool</span> {</code></li>
            <li><code class="code-voice">    <span class="c">// code that creates autoreleased objects.&nbsp;<span class="jpstr">（オートリリースされるオブジェクトを作成するコード）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  For more information, see <em class="u-book"><a href="../../../Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i" data-renderer-version="1" target="_self">Advanced Memory Management Programming Guide</a></em>.
<br><span class="jpstr">
さらなる情報は、<em class="u-book"><a href="../../../Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i" data-renderer-version="1" target="_self">Advanced Memory Management Programming Guide</a></em>を見てください。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID160"></a>
  <h3 class="section-name" tabindex="0">API Availability<br><span class="jpstr">
API有効性
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Some classes and methods are not available to all versions of all platforms that your app targets. To ensure that your app can accommodate any differences in functionality, you check the availability those APIs.
<br><span class="jpstr">
いくつかのクラスやメソッドは、あなたのアプリターゲットであるすべてのプラットホームのすべてのバージョンで利用可能ではありません。あなたのアプリが機能性でのどんな違いでも調整できることを確実にするために、あなたはそれらのAPIの有効性を確認します。
</span><!--end_jpstr-->
</p><p class="para">
  In Objective-C, you use the <code class="code-voice">respondsToSelector:</code> and <code class="code-voice">instancesRespondToSelector:</code> methods to check for the availability of a class or instance method. Without a check, the method call throws an <code class="code-voice">NSInvalidArgumentException</code> “unrecognized selector sent to instance” exception. For example, the <code class="code-voice">requestWhenInUseAuthorization</code> method is only available to instances of <code class="code-voice">CLLocationManager</code> starting in iOS 8.0 and macOS 10.10:
<br><span class="jpstr">
Objective-Cでは、あなたは<code class="code-voice">respondsToSelector:</code>と<code class="code-voice">instancesRespondToSelector:</code>メソッドを使ってクラスおよびインスタンス・メソッドの有効性を確認します。確認なしでは、メソッド呼び出しは<code class="code-voice">NSInvalidArgumentException</code>「認識不能セレクタがインスタンスに送られます」例外をスローします。例えば、<code class="code-voice">requestWhenInUseAuthorization</code>メソッドは、<code class="code-voice">CLLocationManager</code>のインスタンスに対してiOS 8.0およびmacOS 10.10からのみ利用可能です：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="k">if</span> <span class="p">([</span><span class="n">CLLocationManager</span> <span class="nl">instancesRespondToSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="n">requestWhenInUseAuthorization</span><span class="p">)])</span> <span class="p">{</span>
</code></li>
            <li><code class="code-voice">  <span class="c1">// Method is available for use.&nbsp;<span class="jpstr">（メソッドは利用に応じられます。）</span><!--end_jpstr-->
</span>
</code></li>
            <li><code class="code-voice"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</code></li>
            <li><code class="code-voice">  <span class="c1">// Method is not available.&nbsp;<span class="jpstr">（メソッドは利用できません。）</span><!--end_jpstr-->
</span>
</code></li>
            <li><code class="code-voice"><span class="p">}</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  In Swift, attempting to call a method that is not supported on all targeted platform versions causes a compile-time error.
<br><span class="jpstr">
スウィフトでは、ターゲットにされるすべてのプラットホーム上でサポートされないメソッドを呼び出す試みは、コンパイル時エラーを生じさせます。
</span><!--end_jpstr-->
</p><p class="para">
  Here’s the previous example, in Swift:
<br><span class="jpstr">
ここにスウィフトでの以前の例があります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">locationManager</span> = <span class="vc">CLLocationManager</span>()</code></li>
            <li><code class="code-voice"><span class="vc">locationManager</span>.<span class="vc">requestWhenInUseAuthorization</span>()</code></li>
            <li><code class="code-voice"><span class="c">// error: only available on iOS 8.0 or newer&nbsp;<span class="jpstr">（エラー：iOS 8.0以降でのみ利用可能）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If the app targets a version of iOS prior to 8.0 or macOS prior to 10.10, <code class="code-voice">requestWhenInUseAuthorization()</code> is unavailable, so the compiler reports an error.
<br><span class="jpstr">
アプリがiOSの8.0より前のまたはmacOSの10.10より前のあるバージョンをターゲットにするならば、<code class="code-voice">requestWhenInUseAuthorization()</code>は利用可能でありません、それでコンパイラはエラーを報告します。
</span><!--end_jpstr-->
</p><p class="para">
  Swift code can use the availability of APIs as a condition <strong>at run-time</strong>. Availability checks can be used in place of a condition in a control flow statement, such as an <code class="code-voice">if</code>, <code class="code-voice">guard</code>, or <code class="code-voice">while</code> statement.
<br><span class="jpstr">
スウィフトコードは、APIの有効性をひとつの条件として使うことが<strong>実行時に</strong>可能です。有効性確認は、制御の流れ文、例えば<code class="code-voice">if</code>、<code class="code-voice">guard</code>、または<code class="code-voice">while</code>の中のひとつの条件の代わりに使われることができます。
</span><!--end_jpstr-->
</p><p class="para">
  Taking the previous example, you can check availability in an <code class="code-voice">if</code> statement to call <code class="code-voice">requestWhenInUseAuthorization()</code> only if the method is available at runtime:
<br><span class="jpstr">
以前の例をとって、あなたは有効性を<code class="code-voice">if</code>文の中で確認して、<code class="code-voice">requestWhenInUseAuthorization()</code>をそのメソッドが実行時に有効である場合にのみ呼び出すことができます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">locationManager</span> = <span class="vc">CLLocationManager</span>()</code></li>
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">#available</span>(<span class="kt">iOS</span> <span class="m">8.0</span>, <span class="kt">macOS</span> <span class="m">10.10</span>, *) {</code></li>
            <li><code class="code-voice">    <span class="vc">locationManager</span>.<span class="vc">requestWhenInUseAuthorization</span>()</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Alternatively, you can check availability in a <code class="code-voice">guard</code> statement, which exits out of scope unless the current target satisfies the specified requirements. This approach simplifies the logic of handling different platform capabilities.
<br><span class="jpstr">
あるいはまた、あなたは有効性を<code class="code-voice">guard</code>文の中で使うことができます、それは現在のターゲットが指定された要件を満たさない限りスコープの外に退出します。この取り組みは、異なるプラットホーム適応性の取り扱い論理を単純にします。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">locationManager</span> = <span class="vc">CLLocationManager</span>()</code></li>
            <li><code class="code-voice"><span class="kt">guard</span> <span class="kt">#available</span>(<span class="kt">iOS</span> <span class="m">8.0</span>, <span class="kt">macOS</span> <span class="m">10.10</span>, *) <span class="kt">else</span> { <span class="kt">return</span> }</code></li>
            <li><code class="code-voice"><span class="vc">locationManager</span>.<span class="vc">requestWhenInUseAuthorization</span>()</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Each platform argument consists of one of platform names listed below, followed by corresponding version number. The last argument is an asterisk (<code class="code-voice">*</code>), which is used to handle potential future platforms.
<br><span class="jpstr">
各プラットホーム引数は、以下で箇条書きにされるプラットホーム名の１つ、それに続く該当するバージョン番号から成ります。最後の引数は、ひとつのアスタリスクです（<code class="code-voice">*</code>）、それは潜在的な将来のプラットホームを取り扱うために使われます。
</span><!--end_jpstr-->
</p><p class="para">
  <em>Platform Names</em>:
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  <code class="code-voice">iOS</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">iOSApplicationExtension</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">macOS</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">macOSApplicationExtension</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">watchOS</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">watchOSApplicationExtension</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">tvOS</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">tvOSApplicationExtension</code>
</p>
</li>
</ul><p class="para">
  All of the Cocoa APIs provide availability information, so you can be confident the code you write works as expected on any of the platforms your app targets.
<br><span class="jpstr">
Cocoa APIの全ては、有効性情報を提供します、それであなたは、あなたの書くコードが予想されるようにあなたのアプリがターゲットにするどのプラットホーム上でも機能すると確信することができます。
</span><!--end_jpstr-->
</p><p class="para">
  You can denote the availability of your own APIs by annotating declarations with the <code class="code-voice">@available</code> attribute. The <code class="code-voice">@available</code> attribute uses the same syntax as the <code class="code-voice">#available</code> runtime check, with the platform version requirements provided as comma-delimited arguments.
<br><span class="jpstr">
あなたは、宣言に<code class="code-voice">@available</code>属性で注釈を付けることによって、あなたの独自APIの有効性を示すことができます。<code class="code-voice">@available</code>属性は、コンマ区切り引数として提供されるプラットホームバージョン要件を使う、<code class="code-voice">#available</code>実行時確認と同じ構文を使います。
</span><!--end_jpstr-->
</p><p class="para">
  For example:
<br><span class="jpstr">
例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">@available</span>(<span class="kt">iOS</span> <span class="m">8.0</span>, <span class="vc">macOS</span> <span class="m">10.10</span>, *)</code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">useShinyNewFeature</span>() {</code></li>
            <li><code class="code-voice">    <span class="c">// ...</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-NoLink_21"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">A method annotated with the <code class="code-voice">@available</code> attribute can safely use APIs available to the specified platform requirements without the use of an explicit availability check.
    	<br><span class="jpstr">
<code class="code-voice">@available</code>属性で注釈を付けられるメソッドは、指定されたプラッホーム要件で利用可能なAPIを明確に有効性確認を使うことなく安全に使用できます。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-ID184"></a>
  <h3 class="section-name" tabindex="0">Processing Command-Line Arguments<br><span class="jpstr">
コマンドライン引数の処理
</span><!--end_jpstr-->
</h3>
  <p class="para">
  On macOS, you typically open an app by clicking its icon in the Dock or Launchpad, or by double-clicking its icon from the Finder. However, you can also open an app programmatically and pass command-line arguments from Terminal.
<br><span class="jpstr">
macOSでは、あなたは通常はアプリをそれのアイコンをDockまたはLaunchpadでクリックすることで、またはそれのアイコンをFinderからダブルクリックすることで開きます。しかしながら、あなたはまたアプリをプログラムに基づきそしてコマンドライン引数を渡してTerminalから開くことができます。
</span><!--end_jpstr-->
</p><p class="para">
  You can get a list of any command-line arguments that are specified at launch by accessing the <code class="code-voice">CommandLine.arguments</code> type property.
<br><span class="jpstr">
あなたは、起動時に<code class="code-voice">CommandLine.arguments</code>型プロパティにアクセスすることによって指定される、あらゆるコマンドライン引数のリストを得ることができます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="">
        <ol class="code-lines">
            <li><code class="code-voice">$ /path/to/app --argumentName value</code></li>
        </ol>
      </div>
  </div>
</section><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">for</span> <span class="vc">argument</span> <span class="kt">in</span> <span class="vc">CommandLine</span>.<span class="vc">arguments</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="vc">argument</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="c">// prints &quot;/path/to/app&quot;</span></code></li>
            <li><code class="code-voice"><span class="c">// prints &quot;--argumentName&quot;</span></code></li>
            <li><code class="code-voice"><span class="c">// prints &quot;value&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The first element in <code class="code-voice">CommandLine.arguments</code> is a path to the executable. Any command-line arguments that are specified at launch begin at <code class="code-voice">CommandLine.arguments[1]</code>.
<br><span class="jpstr">
<code class="code-voice">CommandLine.arguments</code>の中の最初の項目は、常に実行ファイルへのパスです。起動時に指定される何らかのコマンドライン引数は、<code class="code-voice">CommandLine.arguments[1]</code>で始まります。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014216-CH7-NoLink_22"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Accessing arguments using <code class="code-voice">CommandLine.arguments</code> is equivalent to accessing the <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/foundation/processinfo/1415596-arguments" class="urlLink">arguments</a></code> property on <code class="code-voice">ProcessInfo.processInfo</code>.
    	<br><span class="jpstr">
<code class="code-voice">CommandLine.arguments</code>を使って引数にアクセスすることは、<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/foundation/processinfo/1415596-arguments" class="urlLink">arguments</a></code>プロパティに<code class="code-voice">ProcessInfo.processInfo</code>上でアクセスすることと等価です。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>

  	
 	<section id="next_previous" class="">
    		<p class="previous-link"><a href="WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH6-ID61">Working with Cocoa Frameworks<br><span class="jpstr">
Cocoaフレームワークを扱う
</span><!--end_jpstr-->
</a></p>
  			<p class="next-link"><a href="InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID17" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH8-ID17">Interacting with C APIs<br><span class="jpstr">
C APIとの相互作用
</span><!--end_jpstr-->
</a></p>

    <p class="copyright">Copyright &#x00a9; 2018 Apple Inc. All rights reserved. 
  <a class="link" href="http://www.apple.com/legal/terms/site.html" target="_blank" rel="external">Terms of Use</a> | 
  <a class="link" href="http://www.apple.com/privacy/" target="_blank" rel="external">Privacy Policy</a> | 
  Updated: 2018-02-06
</p>
  </section>
</article>

    </div>
    <div id='big_button'></div>
    <footer id="footer">
  <div class="content-wrapper">
  	<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
  </div>
  <script src="../../../../Resources/1277/JavaScript/devpubs-1.6.3.js" type="text/javascript" charset="utf-8"></script>
  <script src="../../../../Resources/1277/JavaScript/feedback-1.6.3.js" type="text/javascript" charset="utf-8"></script>
  <div id="_omniture_top">
<!-- SiteCatalyst code version: H.8. Copyright 1997-2006 Omniture, Inc. -->
<script type="text/javascript">
/* RSID: */
var s_account="appleglobal,appleusdeveloper,dappdeveloperlib"
</script>

<!-- <script type="text/javascript" src="https://www.apple.com/metrics/scripts/s_code_h.js"></script> -->
<script type="text/javascript">
s.pageName=AC.Tracking.pageName();
s.channel="www.us.developer"

/************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
var s_code=s.t();if(s_code)document.write(s_code)</script>
<!-- End SiteCatalyst code version: H.8. -->
</div>

</footer>

    
  </body>
    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="https://developer.apple.com/bugreporter/" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

</div>
</html>
