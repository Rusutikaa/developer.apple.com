<!DOCTYPE html>
<html lang="en">
  <head>  
  <title>Using Swift with Cocoa and Objective-C (Swift 4.0.3): Working with Cocoa Frameworks</title>
  <link rel="stylesheet" type="text/css" href="../../../../Resources/1274/CSS/style-1.6.3.css" />
  <link rel="stylesheet" type="text/css" href="../../../../Resources/1274/CSS/feedback-1.6.3.css" />
  <meta charset='utf-8'> 
<meta id="j-version" name="j-version" content="" />
<meta id="build" name="build" content="3b40de4ca2af51e302b3b9b9306b0a3e" />
<meta id="document-version" name="document-version" content="9.1.5" />
<meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Topic/Swift}" />
<meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/TP40014216" />
<meta id="chapterId" name="chapterId" content="TP40014216-CH6">
<meta id="book-title" name="book-title" content="Using Swift with Cocoa and Objective-C (Swift 4.0.3)" />
<meta id="book-resource-type" name="book-resource-type" content="Guide" />
<meta id="book-root" name="book-root" content="./" />
<meta id="book-json" name="book-json" content="book.json">
<meta id="date" name="date" content="2017-12-04" />
<meta id="description" name="description" content="Describes various aspects of Swift&#39;s compatibility with the Objective-C language and Cocoa/Cocoa Touch frameworks." />
<meta id="IndexTitle" name="IndexTitle" content="" />
<meta id="resources-uri" name="resources-uri" content="../../../../Resources/1274">
<link id="book-index-page" rel="Start" title="" type="text/html" href="./index.html">
<!-- , next_chapter: next_chapter, previous_chapter: previous_chapter -->
<link id="next-page" rel="Next" type="text/html" href="">
<link id="previous-page" rel="Prev" type="text/html" href="">
<meta id="devcenter" name="devcenter" content="<!-- DEVCENTER_NAME -->" />
<meta id="devcenter-url" name="devcenter-url" content="<!-- DEVCENTER_URL -->" />
<meta id="reflib" name="reflib" content="<!-- REFLIB_NAME -->" />

<meta id="xcode-display" name="xcode-display" content="render" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<meta id="platforms" name="platforms" content="Xcode Developer Tools">
</head>

  <body id="conceptual_flow_with_tasks" class="jazz">
    
    <header id="ios_header" class="hideOnPrint hideInXcode">
  <div class="content-wrapper">
    <p class="header-text">
    	<a href="../../../../navigation/index.html">Guides and Sample Code
 		</a>
 </p>
    <p id="wwdr"><img id="apple_logo" src="../../../../Resources/1274/Images/apple2.png" height="14px" width="12px" aria-hidden="true" /><a href="https://developer.apple.com">Developer</a></p>
  </div>
</header>

    <section id="valence">
  <div class="content-wrapper">
    <p id="hierarchial_navigation">
      <span id="book_title">Using Swift with Cocoa and Objective-C (Swift 4.0.3)</span>
    </p>
    <form id="search" class="hideInXcode" method="get" action="/search/index.php" accept-charset="utf-8" autocomplete="off">
  <input type="search" id="ssi_SearchField" placeholder="Search Guides and Sample Code" name="q" autocomplete="off" tabindex="2" />
</form>

      
   
   




    <span class="download-text hideInXcode">
      <a href="https://itunes.apple.com/us/book/using-swift-cocoa-objective/id888894773?mt=11">iBooks</a>
    </span>

    

    <img id="shortstack" src="../../../../Resources/1274/Images/shortstack_2x.png"/>
  </div>
</section>
    <div class="content-wrapper">
      <nav id="navigator" class="book-parts hideInXcode" role="navigation">
    <ul class="nav-parts">
        <li data-id="//apple_ref/doc/uid/TP40014216-CH1-ID5"
            class="part-name">
            <a href="index.html#//apple_ref/doc/uid/TP40014216-CH2-ID0" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH2-ID0">Getting Started<br><span class="jpstr">
初めに
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="index.html#//apple_ref/doc/uid/TP40014216-CH2-ID0" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH2-ID0">Basic Setup<br><span class="jpstr">
基本の準備
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014216-CH3-ID60"
            class="part-name nav-part-active open-part">
            <a href="InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID35">Interoperability<br><span class="jpstr">
相互運用性
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH4-ID35">Interacting with Objective-C APIs<br><span class="jpstr">
Objective-C APIとの相互作用
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID86" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH5-ID86">Writing Swift Classes and Protocols with Objective-C Behavior<br><span class="jpstr">
スウィフトのクラスとプロトコルをObjective-C挙動で書く
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter nav-current-chapter">
              	<a href="#//apple_ref/doc/uid/TP40014216-CH6-ID61" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH6-ID61">Working with Cocoa Frameworks<br><span class="jpstr">
Cocoaフレームワークを扱う
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID6" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH7-ID6">Adopting Cocoa Design Patterns<br><span class="jpstr">
ココア・デザインパターンの採用
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID17" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH8-ID17">Interacting with C APIs<br><span class="jpstr">
C APIとの相互作用
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014216-CH9-ID141"
            class="part-name">
            <a href="MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH10-ID122">Mix and Match<br><span class="jpstr">
混合と適合
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH10-ID122">Swift and Objective-C in the Same Project<br><span class="jpstr">
同じプロジェクト中のスウィフトとObjective-C
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014216-CH11-ID121"
            class="part-name">
            <a href="Migration.html#//apple_ref/doc/uid/TP40014216-CH12-ID108" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH12-ID108">Migration<br><span class="jpstr">
移行
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="Migration.html#//apple_ref/doc/uid/TP40014216-CH12-ID108" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH12-ID108">Migrating Your Objective-C Code to Swift<br><span class="jpstr">
あなたのObjective-Cコードのスウィフトへの移行
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014216-CH13-ID143"
            class="part-name">
            <a href="RevisionHistory.html#//apple_ref/doc/uid/TP40014216-CH14-ID142" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH14-ID142">Revision History<br><span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="RevisionHistory.html#//apple_ref/doc/uid/TP40014216-CH14-ID142" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH14-ID142">Document Revision History<br><span class="jpstr">
文書改訂履歴
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
    </ul>
</nav>

      <menu id="bashful" type="toolbar">
  <div class="shield"></div>
  <menuitem id="jump_to" class="menu-bar-item closed">
  <span>On This Page</span>
  <div class="chevron">
    <div class="chevy chevron-left"></div>
    <div class="chevy chevron-right"></div>
  </div>
  <menu type="list" class="details">
      <ul class="list-bullet">
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH6-ID211">Foundation</a>
<br><span class="jpstr">
ファウンデーション
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH6-ID79">Core Foundation</a>
<br><span class="jpstr">
コアファウンデーション
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH6-ID219">Unified Logging</a>
<br><span class="jpstr">
統合ログ
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014216-CH6-ID221">Cocoa Structures</a>
<br><span class="jpstr">
Cocoa構造体
</span><!--end_jpstr-->
          </li>
      </ul>
  </menu>
</menuitem>

</menu>
<div class="pixel-line"></div>
<div class="rubber-band-gap"></div>
<article class="chapter">
  <a name="//apple_ref/doc/uid/TP40014216-CH6"></a><a name="//apple_ref/doc/uid/TP40014216-CH6-ID61"></a>

  <h2 class='chapter-name'>Working with Cocoa Frameworks<br><span class="jpstr">
Cocoaフレームワークを扱う
</span><!--end_jpstr-->
</h2>


  
  	<section class="section">
  		<p class="para">
  As part of its interoperability with Objective-C, Swift offers convenient and efficient ways of working with Cocoa frameworks.
<br><span class="jpstr">
それのObjective-Cとの相互運用性の一部として、スウィフトはCocoaフレームワークを扱う便利で効率的な方法を提供します。
</span><!--end_jpstr-->
</p>
<p class="para">
  Swift automatically converts some Objective-C types to Swift types, and some Swift types to Objective-C types. Types that can be converted between Objective-C and Swift are referred to as <em>bridged</em> types. For example, in Swift code, you can pass a <code class="code-voice">String</code> value to an Objective-C method declared to take an <code class="code-voice">NSString</code> parameter. In addition, many of the Cocoa frameworks, including Foundation, AppKit, and UIKit refine their APIs to be more natural in Swift. For example, the <code class="code-voice">NSCoder</code> method <code class="code-voice">decodeObjectOfClass(_:forKey:)</code> uses Swift generics to provide a stronger type signature.
<br><span class="jpstr">
スウィフトは、いくつかのObjective-C型をスウィフト型に、そしていくつかのスウィフト型をObjective-C型に自動的に変換します。Objective-Cとスウィフトの間で変換されることが可能な型は、<em>ブリッジ（橋渡しされる）</em>型と呼ばれます。例えば、スウィフトコードにおいて、あなたはある<code class="code-voice">String</code>値を、<code class="code-voice">NSString</code>パラメータをとるように宣言されたObjective-Cメソッドに渡すことができます。加えて、Foundation、AppKit、そしてUIKitを含む、多くのCocoaフレームワークは、それらのAPIをSwiftにおいてより自然なものに改良されます。例えば、<code class="code-voice">NSCoder</code>のメソッド<code class="code-voice">decodeObjectOfClass(_:forKey:)</code>は、スウィフト総称体を使うことでより強力な型シグネチャを提供します。
</span><!--end_jpstr-->
</p>

		</section> 


  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-ID211"></a>
  <h3 class="section-name" tabindex="0">Foundation<br><span class="jpstr">
ファウンデーション
</span><!--end_jpstr-->
</h3>
  <p class="para">
  The Foundation framework provides a base layer of functionality for apps and frameworks, including data storage, text processing, dates and times, sorting and filtering, persistence, and networking.
<br><span class="jpstr">
Foundationフレームワークは、ある基盤階層をアプリとフレームワークのための機能性に関して提供していて、データストレージ、テキスト処理、日付と時刻、ソートとフィルタ、永続、そしてネートワーク処理を含みます。
</span><!--end_jpstr-->
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-ID212"></a>
  <h3 class="section-name" tabindex="0">Bridged Types<br><span class="jpstr">
ブリッジ型
</span><!--end_jpstr-->
</h3>
  <p class="para">
  The Swift Foundation overlay provides the following bridged value types for the following Objective-C reference types:
<br><span class="jpstr">
スウィフト Foundationオーバーレイは、以下のブリッジ値型を以下のObjective-C参照型に対して提供します：
</span><!--end_jpstr-->
</p><div class="tableholder">
  
  <table class="graybox" border="0" cellspacing="0" cellpadding="5">
    <caption class="tablecaption"></caption>
    <thead>
        <tr>
            <th scope="col" class="TableHeading_TableRow_TableCell"><p class="para">
  Objective-C Reference Type
<br><span class="jpstr">
Objective-C参照型
</span><!--end_jpstr-->
</p></th>
            <th scope="col" class="TableHeading_TableRow_TableCell"><p class="para">
  Swift Value Type
<br><span class="jpstr">
スウィフト値型
</span><!--end_jpstr-->
</p></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSAffineTransform</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">AffineTransform</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSArray</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">Array</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSCalendar</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">Calendar</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSCharacterSet</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">CharacterSet</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSData</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">Data</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSDateComponents</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">DateComponents</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSDateInterval</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">DateInterval</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSDate</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">Date</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSDecimalNumber</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">Decimal</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSDictionary</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">Dictionary</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSIndexPath</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">IndexPath</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSIndexSet</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">IndexSet</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSLocale</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">Locale</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSMeasurement</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">Measurement</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSNotification</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">Notification</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSNumber</code>
</p></td>
            <td><p class="para">
  Swift numeric types (<code class="code-voice">Int</code>, <code class="code-voice">Float</code>, and so on.)
<br><span class="jpstr">
スウィフト数値型（<code class="code-voice">Int</code>、<code class="code-voice">Float</code>、など）。
</span><!--end_jpstr-->
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSPersonNameComponents</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">PersonNameComponents</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSSet</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">Set</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSString</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">String</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSTimeZone</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">TimeZone</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSURL</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">URL</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSURLComponents</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">URLComponents</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSURLQueryItem</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">URLQueryItem</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSURLRequest</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">URLRequest</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">NSUUID</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">UUID</code>
</p></td>
        </tr>
    </tbody>
  </table>
</div><p class="para">
  These value types have the same functionality as their corresponding reference types. Class clusters that include immutable and mutable subclasses are bridged to a single value type. Swift code uses <code class="code-voice">var</code> and <code class="code-voice">let</code> to control mutability, so it doesn’t need both classes. The corresponding reference types can be accessed with their original <code class="code-voice">NS</code> class name prefix.
<br><span class="jpstr">
これらの値型は、それらの対応する参照型と同じ機能性を持ちます。不変および可変サブクラスを含むクラス群は、単一値型へブリッジされます。スウィフトコードは、<code class="code-voice">var</code>と<code class="code-voice">let</code>を使って可変性を制御します、それでそれは両方のクラスを必要としません。対応する参照型は、それら本来の<code class="code-voice">NS</code>クラス名接頭辞でアクセスされることができます。
</span><!--end_jpstr-->
</p><p class="para">
  Anywhere you can use a bridged Objective-C reference type, you can use the Swift value type instead. This lets you take advantage of the functionality available on the reference type’s implementation in a way that is natural in Swift code. For this reason, you should almost never need to use a bridged reference type directly in your own code. In fact, when Swift code imports Objective-C APIs, the importer replaces Objective-C reference types with their corresponding value types. Likewise, when Objective-C code imports Swift APIs, the importer also replaces Swift value types with their corresponding Objective-C reference types.
<br><span class="jpstr">
あなたがブリッジObjective-C参照型を使うことができるどこにでも、あなたはスウィフト値型をその代わりに使うことができます。これは、あなたに参照型の実装上で利用可能な機能性を、スウィフトコードにおける自然な方法で利用させます。この理由のために、あなたはブリッジ参照型を直接にあなた自身のコードにおいて使う必要はほとんどないはずです。実際、スウィフトコードがObjective-C APIをインポートするとき、インポーターはObjective-C参照型をそれらの対応する値型と置き換えます。同様に、Objective-Cコードがスウィフト APIをインポートするとき、インポーターはまたスウィフト値型をそれらの対応するObjective-C参照型と置き換えます。
</span><!--end_jpstr-->
</p><p class="para">
  One of the primary advantages of value types over reference types is that they make it easier to reason about your code. For more information about value types, see <a href="../Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13" data-renderer-version="2" target="_self">Classes and Structures</a> in <em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">The Swift Programming Language (Swift 4.0.3)</a></em>, and WWDC 2015 session 414 <a href="https://developer.apple.com/videos/play/wwdc2015/414">Building Better Apps with Value Types in Swift</a>.
<br><span class="jpstr">
参照型を超える値型の主要な利点の１つは、それらがあなたのコードについて考えるのをより簡単にすることです。値型についてのさらなる情報として、<a href="../Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13" data-renderer-version="2" target="_self">クラスと構造体</a>を<em class="u-book"><a href="../Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" data-renderer-version="2" target="_self">スウィフトプログラミング言語 (Swift 4.0.3)</a></em>で、そしてWWDC 2015 セッション 414 <a href="https://developer.apple.com/videos/play/wwdc2015/414">より良いアプリをスウィフトの値型で作り上げる</a>を見てください。
</span><!--end_jpstr-->
</p><p class="para">
  If you do need to use a bridged Foundation object, you can cast between bridged types using the <code class="code-voice">as</code> type casting operator.
<br><span class="jpstr">
あなたがブリッジFoundationオブジェクトを使うことをどうしても必要とするならば、あなたはブリッジ型の間でキャストすることが<code class="code-voice">as</code>型キャスト演算子を使って可能です。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-ID213"></a>
  <h3 class="section-name" tabindex="0">Renamed Types<br><span class="jpstr">
改名された型
</span><!--end_jpstr-->
</h3>
  <p class="para">
  The Swift Foundation overlay renames classes and protocols, as well as related enumerations and constants.
<br><span class="jpstr">
スウィフト Foundationオーバーレイは、クラスおよびプロトコルを改名します、それだけでなく関連した列挙と定数も。
</span><!--end_jpstr-->
</p><p class="para">
  Imported Foundation classes and protocols drop their <code class="code-voice">NS</code> prefix, with the following exceptions:
<br><span class="jpstr">
インポートされたFoundationのクラスおよびプロトコルは、それらの<code class="code-voice">NS</code>接頭辞を外します、以下の例外を除いては：
</span><!--end_jpstr-->
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  Classes specific to Objective-C or inherently tied to the Objective-C runtime, such as <code class="code-voice">NSObject</code>, <code class="code-voice">NSAutoreleasePool</code>, <code class="code-voice">NSException</code>, and <code class="code-voice">NSProxy</code>
<br><span class="jpstr">
Objective-C特有の、またはObjective-Cランタイムに本質的に結びつけられ切り離せないクラス、例えば<code class="code-voice">NSObject</code>、<code class="code-voice">NSAutoreleasePool</code>、<code class="code-voice">NSException</code>、そして<code class="code-voice">NSProxy</code>など。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Platform-specific classes, such as <code class="code-voice">NSBackgroundActivity</code>, <code class="code-voice">NSUserNotification</code>, and <code class="code-voice">NSXPCConnection</code>
<br><span class="jpstr">
プラットホーム特有のクラス、例えば<code class="code-voice">NSBackgroundActivity</code>、<code class="code-voice">NSUserNotification</code>、そして<code class="code-voice">NSXPCConnection</code>など。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Classes that have a value type equivalent, as described in <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014216-CH6-ID212" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH6-ID212">Bridged Types</a></span>, such as <code class="code-voice">NSString</code>, <code class="code-voice">NSDictionary</code>, and <code class="code-voice">NSURL</code>
<br><span class="jpstr">
<span class="x-name"><a href="#//apple_ref/doc/uid/TP40014216-CH6-ID212" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH6-ID212">ブリッジ型</a></span>で記述される、値型の相当物を持つクラス、例えば<code class="code-voice">NSString</code>、<code class="code-voice">NSDictionary</code>、そして<code class="code-voice">NSURL</code>など。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  Classes that do not have a value type equivalent but are planned to have one in the near future, such as <code class="code-voice">NSAttributedString</code>, <code class="code-voice">NSRegularExpression</code>, and <code class="code-voice">NSPredicate</code>
<br><span class="jpstr">
値型の相当物を持たないが近い将来それを持つ計画をされるクラス、例えば<code class="code-voice">NSAttributedString</code>、<code class="code-voice">NSRegularExpression</code>、そして<code class="code-voice">NSPredicate</code>
</span><!--end_jpstr-->
</p>
</li>
</ul><p class="para">
  Foundation classes often declare enumeration or constant types. When importing these types, Swift moves them to be nested types of their related types. For example, the <code class="code-voice">NSJSONReadingOptions</code> option set is imported as <code class="code-voice">JSONSerialization.ReadingOptions</code>.
<br><span class="jpstr">
Foundationクラスは、しばしば列挙や定数型を宣言します。それらの型をインポートするとき、スウィフトはそれらを移動して、それらの関連型の入れ子にされた型にします。例えば、<code class="code-voice">NSJSONReadingOptions</code>オプションセットは<code class="code-voice">JSONSerialization.ReadingOptions</code>としてインポートされます。
</span><!--end_jpstr-->
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-ID63"></a>
  <h3 class="section-name" tabindex="0">Strings<br><span class="jpstr">
文字列
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Swift bridges between the <code class="code-voice">String</code> type and the <code class="code-voice">NSString</code> class. You can create an <code class="code-voice">NSString</code> object by casting a <code class="code-voice">String</code> value using the <code class="code-voice">as</code> operator. You can also create an <code class="code-voice">NSString</code> object using a string literal by explicitly providing a type annotation.
<br><span class="jpstr">
スフィフトは、<code class="code-voice">String</code>型と<code class="code-voice">NSString</code>クラスの間をブリッジします。あなたは、<code class="code-voice">NSString</code>オブジェクトの作成が、<code class="code-voice">String</code>値を<code class="code-voice">as</code>演算子を使ってキャストすることで可能です。あなたはまた、明示的に型注釈を提供することによって文字列リテラルを使って<code class="code-voice">NSString</code>オブジェクトを作成できます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">import</span> <span class="vc">Foundation</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">string</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span> = <span class="s">&quot;abc&quot;</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">bridgedString</span>: <span class="n"><! -- a href="" -->NSString<! -- /a --></span> = <span class="vc">string</span> <span class="kt">as</span> <span class="n"><! -- a href="" -->NSString<! -- /a --></span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">stringLiteral</span>: <span class="n"><! -- a href="" -->NSString<! -- /a --></span> = <span class="s">&quot;123&quot;</span></code></li>
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">integerValue</span> = <span class="vc">Int</span>(<span class="vc">stringLiteral</span> <span class="kt">as</span> <span class="n"><! -- a href="" -->String<! -- /a --></span>) {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;</span>\(<span class="vc">stringLiteral</span>)<span class="s"> is the integer </span>\(<span class="vc">integerValue</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;123 is the integer 123&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-NoLink_14"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">The Swift <code class="code-voice">String</code> type is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations. The <code class="code-voice">NSString</code> class encodes a Unicode-compliant text string, represented as a sequence of UTF–16 code units. <code class="code-voice">NSString</code> methods that express length, character indexes, or ranges in terms of 16-bit platform-endian values have corresponding Swift <code class="code-voice">String</code> methods that use <code class="code-voice">String.Index</code> and <code class="code-voice">Range&lt;String.Index&gt;</code> values rather than <code class="code-voice">Int</code> and <code class="code-voice">NSRange</code> values.
    	<br><span class="jpstr">
スウィフトの<code class="code-voice">String</code>型は、符号化非依存のユニコード文字から構成されます、そしてそれらの文字に様々なユニコード表現においてアクセスするための支援を提供します。<code class="code-voice">NSString</code>クラスは、一連のUTF–16コード単位として表される、あるユニコード遵守テキスト文字列を符号化します。16ビットのプラットホームエンディアンの値の観点から長さ、文字インデックス、または範囲を表す<code class="code-voice">NSString</code>メソッドは、対応するスウィフトの<code class="code-voice">String</code>メソッドを持ちます、それは<code class="code-voice">String.Index</code>と<code class="code-voice">Range&lt;String.Index&gt;</code>値を使います、<code class="code-voice">Int</code>と<code class="code-voice">NSRange</code>値ではなくて。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-ID67"></a>
  <h3 class="section-name" tabindex="0">Numbers<br><span class="jpstr">
数
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Swift bridges between the <code class="code-voice">NSNumber</code> class and Swift numeric types, including <code class="code-voice">Int</code>, <code class="code-voice">Double</code>, and <code class="code-voice">Bool</code>.
<br><span class="jpstr">
スウィフトは<code class="code-voice">NSNumber</code>クラスと、<code class="code-voice">Int</code>、<code class="code-voice">Double</code>、および<code class="code-voice">Bool</code>を含むスウィフト数値型の間をブリッジします。
</span><!--end_jpstr-->
</p><p class="para">
  You can create an <code class="code-voice">NSNumber</code> object by casting a Swift number value using the <code class="code-voice">as</code> operator. Because <code class="code-voice">NSNumber</code> can contain a variety of different types, you must use the <code class="code-voice">as?</code> operator when casting to a Swift number type. For example, casting an <code class="code-voice">NSNumber</code> value representing the number 500 to the <code class="code-voice">Int8</code> Swift type will fail and return <code class="code-voice">nil</code>, because the largest value that an <code class="code-voice">Int8</code> value can represent is 127.
<br><span class="jpstr">
あなたは、<code class="code-voice">NSNumber</code>オブジェクトを作成することが、スウィフト数値を<code class="code-voice">as</code>演算子を使ってキャストすることによって可能です。<code class="code-voice">NSNumber</code>が様々な異なる型を含むことができることから、あなたはスウィフト数値型をキャストする時に<code class="code-voice">as?</code>演算子を使わなければなりません。例えば、数500を表している<code class="code-voice">NSNumber</code>値を<code class="code-voice">Int8</code>のSwift型へキャストすることは失敗して<code class="code-voice">nil</code>を返します、なぜなら<code class="code-voice">Int8</code>値が表すことができる最大値は127だからです。
</span><!--end_jpstr-->
</p><p class="para">
  You can also create an <code class="code-voice">NSNumber</code> object using a floating-point, integer, or Boolean literal by explicitly providing a type annotation.
<br><span class="jpstr">
あなたはまた、<code class="code-voice">NSNumber</code>オブジェクトを作成することが、浮動小数点、整数、またはブールのリテラルを使って明示的に型注釈を提供することによって可能です。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">import</span> <span class="vc">Foundation</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">number</span> = <span class="m">42</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">bridgedNumber</span>: <span class="n"><! -- a href="" -->NSNumber<! -- /a --></span> = <span class="vc">number</span> <span class="kt">as</span> <span class="n"><! -- a href="" -->NSNumber<! -- /a --></span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">integerLiteral</span>: <span class="n"><! -- a href="" -->NSNumber<! -- /a --></span> = <span class="m">5</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">floatLiteral</span>: <span class="n"><! -- a href="" -->NSNumber<! -- /a --></span> = <span class="m">3.14159</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">booleanLiteral</span>: <span class="n"><! -- a href="" -->NSNumber<! -- /a --></span> = <span class="kt">true</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-NoLink_15"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Objective-C platform-adaptive integer types, such as <code class="code-voice">NSUInteger</code> and <code class="code-voice">NSInteger</code>, are bridged to <code class="code-voice">Int</code>.
    	<br><span class="jpstr">
Objective-Cのプラットホーム順応性の整数型、例えば<code class="code-voice">NSUInteger</code>と<code class="code-voice">NSInteger</code>などは、<code class="code-voice">Int</code>にブリッジされます。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-ID71"></a>
  <h3 class="section-name" tabindex="0">Arrays<br><span class="jpstr">
配列
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Swift bridges between the <code class="code-voice">Array</code> type and the <code class="code-voice">NSArray</code> class. When you bridge from an <code class="code-voice">NSArray</code> object with a parameterized type to a Swift array, the element type of the resulting array is bridged as well. If an <code class="code-voice">NSArray</code> object does not specify a parameterized type, it is bridged to a Swift array of type <code class="code-voice">[Any]</code>.
<br><span class="jpstr">
スウィフトは、<code class="code-voice">Array</code>型と<code class="code-voice">NSArray</code>クラスの間での橋渡しをします。あなたがあるパラメーター化された型を使う<code class="code-voice">NSArray</code>オブジェクトからスウィフト配列へとブリッジするとき、結果として生じる配列の要素型も同様にブリッジされます。<code class="code-voice">NSArray</code>オブジェクトがパラメータ化された型を指定しないならば、それは型<code class="code-voice">[Any]</code>のスウィフト配列に橋渡しされます。
</span><!--end_jpstr-->
</p><p class="para">
  For example, consider the following Objective-C declarations:
<br><span class="jpstr">
例として、以下のObjective-C宣言を考えてください：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="k">@property</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">objects</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@property</span> <span class="n">NSArray</span><span class="o">&lt;</span><span class="n">NSDate</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">dates</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="n">NSArray</span><span class="o">&lt;</span><span class="n">NSDate</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nl">datesBeforeDate:</span><span class="p">(</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="n">date</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">addDatesParsedFromTimestamps:</span><span class="p">(</span><span class="n">NSArray</span><span class="o">&lt;</span><span class="n">NSString</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">timestamps</span><span class="p">;</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how Swift imports them:
<br><span class="jpstr">
ここにどのようにスウィフトがそれらをインポートするかがあります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">objects</span>: [<span class="kt">Any</span>]</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">dates</span>: [<span class="n"><! -- a href="" -->Date<! -- /a --></span>]</code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">datesBeforeDate</span>(<span class="vc">date</span>: <span class="n"><! -- a href="" -->Date<! -- /a --></span>) -&gt; [<span class="n"><! -- a href="" -->Date<! -- /a --></span>]</code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">addDatesParsedFromTimestamps</span>(<span class="vc">timestamps</span>: [<span class="n"><! -- a href="" -->String<! -- /a --></span>])</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can also create an <code class="code-voice">NSArray</code> object directly from a Swift array literal, following the same bridging rules outlined above. When you explicitly type a constant or variable as an <code class="code-voice">NSArray</code> object and assign it an array literal, Swift creates an <code class="code-voice">NSArray</code> object instead of a Swift array.
<br><span class="jpstr">
あなたはまた、スウィフト配列リテラルから直接<code class="code-voice">NSArray</code>オブジェクトをつくることが、上で概説されるのと同じ橋渡し規則にしたがって可能です。あなたが明示的に定数または変数を<code class="code-voice">NSArray</code>オブジェクトとして型指定して、それに配列リテラルを代入するとき、スウィフトはスウィフト配列でなくて<code class="code-voice">NSArray</code>オブジェクトをつくります。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">schoolSupplies</span>: <span class="n"><! -- a href="" -->NSArray<! -- /a --></span> = [<span class="s">&quot;Pencil&quot;</span>, <span class="s">&quot;Eraser&quot;</span>, <span class="s">&quot;Notebook&quot;</span>]</code></li>
            <li><code class="code-voice"><span class="c">// schoolSupplies is an NSArray object containing three values&nbsp;<span class="jpstr">（schoolSuppliesは３つの値を含んでいるNSArrayオブジェクトです）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-ID151"></a>
  <h3 class="section-name" tabindex="0">Sets<br><span class="jpstr">
集合
</span><!--end_jpstr-->
</h3>
  <p class="para">
  In addition to arrays, Swift bridges between the <code class="code-voice">Set</code> type and the <code class="code-voice">NSSet</code> class. When you bridge from an <code class="code-voice">NSSet</code> object with a parameterized type to a Swift set, the resulting set is of type <code class="code-voice">Set&lt;ObjectType&gt;</code>. If an <code class="code-voice">NSSet</code> object does not specify a parameterized type, it is bridged to a Swift set of type <code class="code-voice">Set&lt;AnyHashable&gt;</code>.
<br><span class="jpstr">
配列に加えて、スウィフトは<code class="code-voice">Set</code>型と<code class="code-voice">NSSet</code>クラスの間を橋渡しします。あなたがあるパラメーター化された型を使う<code class="code-voice">NSSet</code>オブジェクトからスウィフト集合へ橋渡しするとき、結果として生じる集合は型<code class="code-voice">Set&lt;ObjectType&gt;</code>です。<code class="code-voice">NSSet</code>オブジェクトがパラメーター化された型を指定しないならば、それは型<code class="code-voice">Set&lt;AnyHashable&gt;</code>のスウィフト集合に橋渡しされます。
</span><!--end_jpstr-->
</p><p class="para">
  For example, consider the following Objective-C declarations:
<br><span class="jpstr">
例として、以下のObjective-C宣言を考えてください：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="k">@property</span> <span class="n">NSSet</span> <span class="o">*</span><span class="n">objects</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@property</span> <span class="n">NSSet</span><span class="o">&lt;</span><span class="n">NSString</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">words</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">NSString</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nl">wordsMatchingPredicate:</span><span class="p">(</span><span class="n">NSPredicate</span> <span class="o">*</span><span class="p">)</span><span class="n">predicate</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">removeWords:</span><span class="p">(</span><span class="n">NSSet</span><span class="o">&lt;</span><span class="n">NSString</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">words</span><span class="p">;</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how Swift imports them:
<br><span class="jpstr">
ここにどのようにスウィフトがそれらをインポートするかがあります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">objects</span>: <span class="n"><! -- a href="" -->Set<! -- /a --></span>&lt;<span class="n"><! -- a href="" -->AnyHashable<! -- /a --></span>&gt;</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">words</span>: <span class="n"><! -- a href="" -->Set<! -- /a --></span>&lt;<span class="n"><! -- a href="" -->String<! -- /a --></span>&gt;</code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">wordsMatchingPredicate</span>(<span class="vc">predicate</span>: <span class="n"><! -- a href="" -->NSPredicate<! -- /a --></span>) -&gt; <span class="n"><! -- a href="" -->Set<! -- /a --></span>&lt;<span class="n"><! -- a href="" -->String<! -- /a --></span>&gt;</code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">removeWords</span>(<span class="vc">words</span>: <span class="n"><! -- a href="" -->Set<! -- /a --></span>&lt;<span class="n"><! -- a href="" -->String<! -- /a --></span>&gt;)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can also create an <code class="code-voice">NSSet</code> object directly from a Swift array literal, following the same bridging rules outlined above. When you explicitly type a constant or variable as an <code class="code-voice">NSSet</code> object and assign it an array literal, Swift creates an <code class="code-voice">NSSet</code> object instead of a Swift set.
<br><span class="jpstr">
あなたはまた、<code class="code-voice">NSSet</code>オブジェクトを直接にスウィフト配列リテラルから作成することが、上で概説されるのと同じ橋渡し規則にしたがって可能です。あなたが明示的に定数または変数を<code class="code-voice">NSSet</code>オブジェクトとして型指定して、それに配列リテラルを代入するとき、スウィフトはスウィフト集合でなくて<code class="code-voice">NSSet</code>オブジェクトをつくります。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">amenities</span>: <span class="n"><! -- a href="" -->NSSet<! -- /a --></span> = [<span class="s">&quot;Sauna&quot;</span>, <span class="s">&quot;Steam Room&quot;</span>, <span class="s">&quot;Jacuzzi&quot;</span>]</code></li>
            <li><code class="code-voice"><span class="c">// amenities is an NSSet object containing three values&nbsp;<span class="jpstr">（amenitiesは３つの値を含んでいるNSSetオブジェクトです）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-ID73"></a>
  <h3 class="section-name" tabindex="0">Dictionaries<br><span class="jpstr">
辞書
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Swift also bridges between the <code class="code-voice">Dictionary</code> type and the <code class="code-voice">NSDictionary</code> class. When you bridge from an <code class="code-voice">NSDictionary</code> object with parameterized types to a Swift dictionary, the resulting dictionary is of type <code class="code-voice">[Key: Value]</code>. If an <code class="code-voice">NSDictionary</code> object does not specify parameterized types, it is bridged to a Swift dictionary of type <code class="code-voice">[AnyHashable: Any]</code>.
<br><span class="jpstr">
スウィフトはまた、<code class="code-voice">Dictionary</code>型から<code class="code-voice">NSDictionary</code>クラスへ橋渡しします。あなたがパラメーター化された型たちを使うある<code class="code-voice">NSDictionary</code>オブジェクトからスウィフト辞書へ橋渡しするとき、結果として得られる辞書は型<code class="code-voice">[Key: Value]</code>です。<code class="code-voice">NSDictionary</code>オブジェクトがパラメーター化された型を指定しないならば、それは型<code class="code-voice">[AnyHashable: Any]</code>のスウィフト辞書に橋渡しされます。
</span><!--end_jpstr-->
</p><p class="para">
  For example, consider the following Objective-C declarations:
<br><span class="jpstr">
例として、以下のObjective-C宣言を考えてください：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="k">@property</span> <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">keyedObjects</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="k">@property</span> <span class="n">NSDictionary</span><span class="o">&lt;</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">,</span> <span class="n">NSData</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">cachedData</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="n">NSDictionary</span><span class="o">&lt;</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">,</span> <span class="n">NSNumber</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nl">fileSizesForURLsWithSuffix:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">suffix</span><span class="p">;</span>
</code></li>
            <li><code class="code-voice"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setCacheExpirations:</span><span class="p">(</span><span class="n">NSDictionary</span><span class="o">&lt;</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">,</span> <span class="n">NSDate</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">expirations</span><span class="p">;</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how Swift imports them:
<br><span class="jpstr">
ここにどのようにスウィフトがそれらをインポートするかがあります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">keyedObjects</span>: [<span class="n"><! -- a href="" -->AnyHashable<! -- /a --></span>: <span class="kt">Any</span>]</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">cachedData</span>: [<span class="n"><! -- a href="" -->URL<! -- /a --></span>: <span class="n"><! -- a href="" -->Data<! -- /a --></span>]</code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">fileSizesForURLsWithSuffix</span>(<span class="vc">suffix</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>) -&gt; [<span class="n"><! -- a href="" -->URL<! -- /a --></span>: <span class="n"><! -- a href="" -->NSNumber<! -- /a --></span>]</code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">setCacheExpirations</span>(<span class="vc">expirations</span>: [<span class="n"><! -- a href="" -->URL<! -- /a --></span>: <span class="n"><! -- a href="" -->NSDate<! -- /a --></span>])</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can also create an <code class="code-voice">NSDictionary</code> object directly from a Swift dictionary literal, following the same bridging rules outlined above. When you explicitly type a constant or variable as an <code class="code-voice">NSDictionary</code> object and assign it a dictionary literal, Swift creates an <code class="code-voice">NSDictionary</code> object instead of a Swift dictionary.
<br><span class="jpstr">
あなたはまた、<code class="code-voice">NSDictionary</code>オブジェクトを直接にスウィフト辞書リテラルから作成することが、上で概説されるのと同じ橋渡し規則にしたがって可能です。あなたが明示的に定数または変数を<code class="code-voice">NSDictionary</code>オブジェクトとして型指定して、それに辞書リテラルを代入するとき、スウィフトはスウィフト辞書でなくて<code class="code-voice">NSDictionary</code>オブジェクトをつくります。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">medalRankings</span>: <span class="n"><! -- a href="" -->NSDictionary<! -- /a --></span> = [<span class="s">&quot;Gold&quot;</span>: <span class="s">&quot;1st Place&quot;</span>, <span class="s">&quot;Silver&quot;</span>: <span class="s">&quot;2nd Place&quot;</span>, <span class="s">&quot;Bronze&quot;</span>: <span class="s">&quot;3rd Place&quot;</span>]</code></li>
            <li><code class="code-voice"><span class="c">// medalRankings is an NSDictionary object containing three key-value pairs&nbsp;<span class="jpstr">（medalRankingsは、NSDictionaryオブジェクトでキー値ペアを含んでいます）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>

</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-ID79"></a>
  <h3 class="section-name" tabindex="0">Core Foundation<br><span class="jpstr">
コアファウンデーション
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Core Foundation types are imported as Swift classes. Wherever memory management annotations have been provided, Swift automatically manages the memory of Core Foundation objects, including Core Foundation objects that you instantiate yourself. In Swift, you can use each pair of toll-free bridged Foundation and Core Foundation types interchangeably. You can also bridge some toll-free bridged Core Foundation types to Swift standard library types if you cast to a bridging Foundation type first.
<br><span class="jpstr">
コアファウンデーション型は、スウィフトクラスとしてインポートされます。メモリ管理注釈が提供されているどこででも、あなた自身でインスタンス化するコアファウンデーション・オブジェクトを含めて、スウィフトは自動的にコアファウンデーション・オブジェクトのメモリを管理します。スウィフトにおいて、あなたは、無料の橋渡しされたファウンデーションとコアファウンデーション型のそれぞれの対を入れ替えて使うことができます。あなたはまた、いくつかの無料の橋渡しされたコアファウンデーション型をスウィフト標準のライブラリ型に橋渡しをすることが、橋渡ししているファウンデーション型にあなたが最初にキャストするならば、可能です。
</span><!--end_jpstr-->
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-ID81"></a>
  <h3 class="section-name" tabindex="0">Remapped Types<br><span class="jpstr">
リマップされた型
</span><!--end_jpstr-->
</h3>
  <p class="para">
  When Swift imports Core Foundation types, the compiler remaps the names of these types. The compiler removes <em class="book-name">Ref</em> from the end of each type name because all Swift classes are reference types, therefore the suffix is redundant.
<br><span class="jpstr">
スウィフトがコアファウンデーション型をインポートするとき、コンパイラはこれらの型の名前をリマップします。コンパイラは各型名の終わりから<em class="book-name">Ref</em>を削除します、なぜなら全てのスウィフトクラスが参照型であり、したがってこの接尾辞は冗長です。
</span><!--end_jpstr-->
</p><p class="para">
  The Core Foundation <code class="code-voice">CFTypeRef</code> type completely remaps to the <code class="code-voice">AnyObject</code> type. Wherever you would use <code class="code-voice">CFTypeRef</code>, you should now use <code class="code-voice">AnyObject</code> in your code.
<br><span class="jpstr">
コアファウンデーションの<code class="code-voice">CFTypeRef</code>型は、<code class="code-voice">AnyObject</code>型に完全にリマップされます。あなたが<code class="code-voice">CFTypeRef</code>を使うどこであろうとも、あなたは現在あなたのコードにおいて<code class="code-voice">AnyObject</code>を使わなければなりません。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-ID83"></a>
  <h3 class="section-name" tabindex="0">Memory Managed Objects<br><span class="jpstr">
メモリ管理オブジェクト
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Core Foundation objects returned from annotated APIs are automatically memory managed in Swift—you do not need to invoke the <code class="code-voice">CFRetain</code>, <code class="code-voice">CFRelease</code>, or <code class="code-voice">CFAutorelease</code> functions yourself.
<br><span class="jpstr">
注釈をつけられたAPIから返されるコアファウンデーション・オブジェクトは、自動的にスウィフトにおいてメモリ管理されます ― あなたは、あなた自身で<code class="code-voice">CFRetain</code>、<code class="code-voice">CFRelease</code>、または<code class="code-voice">CFAutorelease</code>関数を呼び出す必要はありません。
</span><!--end_jpstr-->
</p><p class="para">
  If you return Core Foundation objects from your own C functions and Objective-C methods, you can annotate them with either the <code class="code-voice">CF_RETURNS_RETAINED</code> or <code class="code-voice">CF_RETURNS_NOT_RETAINED</code> macro to automatically insert memory management calls. You can also use the <code class="code-voice">CF_IMPLICIT_BRIDGING_ENABLED</code> and <code class="code-voice">CF_IMPLICIT_BRIDGING_DISABLED</code> macros to enclose C function declarations that follow Core Foundation ownership policy naming policy in order to infer memory management from naming.
<br><span class="jpstr">
あなたがコアファウンデーション・オブジェクトをあなた独自のC関数およびObjective-Cメソッドから返すならば、あなたはそれらに<code class="code-voice">CF_RETURNS_RETAINED</code>または<code class="code-voice">CF_RETURNS_NOT_RETAINED</code>マクロのどちらかで注釈をつけて、自動的にメモリ管理呼び出しを差し込むことができます。あなたはまた、<code class="code-voice">CF_IMPLICIT_BRIDGING_ENABLED</code>と<code class="code-voice">CF_IMPLICIT_BRIDGING_DISABLED</code>マクロを使って、C関数宣言たち、それらは名前の付け方からメモリ管理を推測するためのコアファウンデーション所有者方針の命名方針に従うもの、を取り囲むことができます。
</span><!--end_jpstr-->
</p><p class="para">
  If you use only annotated APIs that do not indirectly return Core Foundation objects, you can skip the rest of this section. Otherwise, continue on to learn about working with unmanaged Core Foundation objects.
<br><span class="jpstr">
あなたがコアファウンデーション・オブジェクトを間接的に返さない注釈をつけられたAPIだけを使うならば、あなたはこの節の残りをスキップすることができます。一方で、管理されないコアファウンデーション・オブジェクトを扱うことについて学ぶためには続けてください。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-ID85"></a>
  <h3 class="section-name" tabindex="0">Unmanaged Objects<br><span class="jpstr">
管理されないオブジェクト
</span><!--end_jpstr-->
</h3>
  <p class="para">
  When Swift imports APIs that have not been annotated, the compiler cannot automatically memory manage the returned Core Foundation objects. Swift wraps these returned Core Foundation objects in an <code class="code-voice">Unmanaged&lt;Instance&gt;</code> structure. All indirectly returned Core Foundation objects are unmanaged as well. For example, here’s an unannotated C function:
<br><span class="jpstr">
注釈をつけられなかったAPIをスウィフトがインポートするとき、コンパイラは返されたコアファウンデーション・オブジェクトを自動的にメモリ管理できません。スウィフトは、これらの返されたコアファウンデーション・オブジェクトを<code class="code-voice">Unmanaged&lt;T&gt;</code>構造体に包みます。全ての間接的に返されたコアファウンデーション・オブジェクトは、同様に管理されません。例えば、ここに注釈をつけられなかったC関数があります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Objective-C">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="n">CFStringRef</span> <span class="n">StringByAddingTwoStrings</span><span class="p">(</span><span class="n">CFStringRef</span> <span class="n">s1</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">s2</span><span class="p">)</span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  And here’s how Swift imports it:
<br><span class="jpstr">
そしてここにスウィフトがそれをインポートする方法があります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">StringByAddingTwoStrings</span>(<span class="kt">_</span>: <span class="n"><! -- a href="" -->CFString<! -- /a --></span>!, <span class="kt">_</span>: <span class="n"><! -- a href="" -->CFString<! -- /a --></span>!) -&gt; <span class="n"><! -- a href="" -->Unmanaged<! -- /a --></span>&lt;<span class="n"><! -- a href="" -->CFString<! -- /a --></span>&gt;! {</code></li>
            <li><code class="code-voice">    <span class="c">// ...</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  When you receive an unmanaged object from an unannotated API, you should immediately convert it to a memory managed object before you work with it. That way, Swift can handle memory management for you. The <code class="code-voice">Unmanaged&lt;Instance&gt;</code> structure provides two methods to convert an unmanaged object to a memory managed object—<code class="code-voice">takeUnretainedValue()</code> and <code class="code-voice">takeRetainedValue()</code>. Both of these methods return the original, unwrapped type of the object. You choose which method to use based on whether the API you are invoking returns an unretained or retained object.
<br><span class="jpstr">
あなたが注釈をつけられなかったAPIから管理されないオブジェクトを受け取るとき、あなたがそれを扱う前に、あなたは直ちにそれをメモリ管理されたオブジェクトに変換しなければなりません。そのように、スウィフトはあなたの代わりにメモリ管理をうまく取り扱うことができます。<code class="code-voice">Unmanaged&lt;T&gt;</code>構造体は、管理されないオブジェクトをメモリ管理されたオブジェクトに変換するために、２つのメソッドを提供します ― <code class="code-voice">takeUnretainedValue()</code>と<code class="code-voice">takeRetainedValue()</code>。これらのメソッドの両方とも、最初の、包装を取られた型のオブジェクトを返します。あなたは、あなたが呼んでいるAPIが保有されない、または保有されるオブジェクトを返すかに基づいて、どちらかのメソッドを選びます。
</span><!--end_jpstr-->
</p><p class="para">
  For example, suppose the C function above does not retain the <code class="code-voice">CFString</code> object before returning it. To start using the object, you use the <code class="code-voice">takeUnretainedValue()</code> function.
<br><span class="jpstr">
例えば、上のC関数が<code class="code-voice">CFString</code>オブジェクトを、それを返す前に保持しないと思ってください。そのオブジェクトを使い始めるために、あなたは<code class="code-voice">takeUnretainedValue()</code>関数を使用します。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">memoryManagedResult</span> = <span class="vc">StringByAddingTwoStrings</span>(<span class="vc">str1</span>, <span class="vc">str2</span>).<span class="vc">takeUnretainedValue</span>()</code></li>
            <li><code class="code-voice"><span class="c">// memoryManagedResult is a memory managed CFString&nbsp;<span class="jpstr">（memoryManagedResultは、メモリ管理されるCFStringです）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can also invoke the <code class="code-voice">retain()</code>, <code class="code-voice">release()</code>, and <code class="code-voice">autorelease()</code> methods on unmanaged objects, but this approach is not recommended.
<br><span class="jpstr">
あなたはまた、管理されないオブジェクトの上で<code class="code-voice">retain()</code>、<code class="code-voice">release()</code>、そして<code class="code-voice">autorelease()</code>メソッドを呼び出すことができます、しかしこの取り組みは推薦されません。
</span><!--end_jpstr-->
</p><p class="para">
  For more information, see <a href="../../../CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148" data-renderer-version="1" target="_self">Ownership Policy</a> in <em class="u-book"><a href="../../../CoreFoundation/Conceptual/CFMemoryMgmt/CFMemoryMgmt.html#//apple_ref/doc/uid/10000127i" data-renderer-version="1" target="_self">Memory Management Programming Guide for Core Foundation</a></em>.
<br><span class="jpstr">
更なる情報のために、<a href="../../../CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148" data-renderer-version="1" target="_self">所有者方針</a>を<em class="u-book"><a href="../../../CoreFoundation/Conceptual/CFMemoryMgmt/CFMemoryMgmt.html#//apple_ref/doc/uid/10000127i" data-renderer-version="1" target="_self">コアファウンデーションのためのメモリ管理プログラミングガイド</a></em>で見てください。
</span><!--end_jpstr-->
</p>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-ID219"></a>
  <h3 class="section-name" tabindex="0">Unified Logging<br><span class="jpstr">
統合ログ
</span><!--end_jpstr-->
</h3>
  <p class="para">
  The unified logging system provides an API for capturing messaging across all levels of the system, and is a replacement for the <code class="code-voice">NSLog</code> function in the Foundation framework. Unified logging is available in iOS 10.0 and later, macOS 10.12 and later, tvOS 10.0 and later, and watchOS 3.0 and later.
<br><span class="jpstr">
統合ログシステムは、システムのすべての水準にまたがってメッセージを捕らえるためにAPIを提供します、そしてFoundationフレームワークにおける<code class="code-voice">NSLog</code>関数に対する置き換えです。統合ログは、iOS 10.0以降、macOS 10.12以降、tvOS 10.0以降、そしてwatchOS 3.0以降で利用可能です。
</span><!--end_jpstr-->
</p><p class="para">
  In Swift, you can interact with the unified logging system using the top level <code class="code-voice">os_log(_:dso:log:type:_:)</code> function, found in the <code class="code-voice">log</code> submodule of the <code class="code-voice">os</code> module.
<br><span class="jpstr">
スウィフトでは、あなたは統合ログシステムとトップレベルの<code class="code-voice">os_log(_:dso:log:type:_:)</code>関数、<code class="code-voice">os</code>モジュールの<code class="code-voice">log</code>サブモジュールで見つかります、を使ってやり取りできます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">import</span> <span class="vc">os</span>.<span class="vc">log</span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">os_log</span>(<span class="s">&quot;This is a log message.&quot;</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can format a log message using an <code class="code-voice">NSString</code> or <code class="code-voice">printf</code> format string along with one or more trailing arguments.
<br><span class="jpstr">
あなたはログメッセージをフォーマットすることが、<code class="code-voice">NSString</code>または<code class="code-voice">printf</code>フォーマット文字列を１つ以上の後に続く引数とともに使うことで行えます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">fileSize</span> = <span class="m">1234567890</span></code></li>
            <li><code class="code-voice"><span class="vc">os_log</span>(<span class="s">&quot;Finished downloading file. Size: %{iec-bytes}d&quot;</span>, <span class="vc">fileSize</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can also specify a log level defined by the logging system, such as Info, Debug, or Error, in order to control how log messages are handled according to the importance of the logging event. For example, information that may be helpful, but isn’t essential for troubleshooting errors should be logged at the Info level.
<br><span class="jpstr">
あなたはまた、ログイベントの重要性にそってどのようにログメッセージが取り扱われるか制御するために、ログシステムによって定義されるログ水準、例えばInfo、Debug、またはErrorを指定することが可能です。例えば、助けとなるかもしれない、しかしエラーを解決するのに必須ではない情報は、Info水準でログされるべきです。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">os_log</span>(<span class="s">&quot;This is additional info that may be helpful for troubleshooting.&quot;</span>, <span class="vc">type</span>: .<span class="vc">info</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  To log a message to a specific subsystem, you can create a new <code class="code-voice">OSLog</code> object, specifying the subsystem and category, and pass it as a parameter to the <code class="code-voice">os_log</code> function.
<br><span class="jpstr">
ある特定のサブシステムに対するメッセージをログするには、あなたは新しい<code class="code-voice">OSLog</code>オブジェクトを作成して、そのサブシステムとカテゴリを指定します、そしてそれをパラメータとして<code class="code-voice">os_log</code>関数に渡します。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">customLog</span> = <span class="vc">OSLog</span>(<span class="s">&quot;com.your_company.your_subsystem_name.plist&quot;</span>, <span class="s">&quot;your_category_name&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="vc">os_log</span>(<span class="s">&quot;This is info that may be helpful during development or debugging.&quot;</span>, <span class="vc">log</span>: <span class="vc">customLog</span>, <span class="vc">type</span>: .<span class="vc">debug</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  For more information about the unified logging system, see <a href="https://developer.apple.com/reference/os/logging">Logging</a>.
<br><span class="jpstr">
統合ログシステムについてのさらなる情報として、<a href="https://developer.apple.com/reference/os/logging">Logging</a>を見てください。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014216-CH6-ID221"></a>
  <h3 class="section-name" tabindex="0">Cocoa Structures<br><span class="jpstr">
Cocoa構造体
</span><!--end_jpstr-->
</h3>
  <p class="para">
  When bridging from Swift code back into Objective-C code, built-in structures from Cocoa and Foundation are bridged as <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/foundation/nsvalue" class="urlLink">NSValue</a></code> instances. As a result, you can use an Objective-C structure from Swift in Cocoa APIs that accept only instances of reference types. This is true even though the instance’s defining type is bridged to Swift as a structure type.
<br><span class="jpstr">
スウィフトコードから逆にObjective-Cコードへとブリッジする場合、CocoaおよびFoundation由来の組み込みの構造体は<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/foundation/nsvalue" class="urlLink">NSValue</a></code>インスタンスとしてブリッジされます。結果として、あなたは参照型のインスタンスのみを受け取るCocoa APIにおいてスウィフト由来のObjective-C構造体を使うことができます。これは、たとえそのインスタンスのもつ定義型がスウィフトへ構造体型としてブリッジされるとしても当てはまります。
</span><!--end_jpstr-->
</p><p class="para">
  The following structures are bridged to <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/foundation/nsvalue" class="urlLink">NSValue</a></code>:
<br><span class="jpstr">
以下の構造体は<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/foundation/nsvalue" class="urlLink">NSValue</a></code>へブリッジされます：
</span><!--end_jpstr-->
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  <code class="code-voice">CATransform3D</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">CLLocationCoordinate2D</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">CGAffineTransform</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">CGPoint</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">CGRect</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">CGSize</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">CGVector</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">CMTimeMapping</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">CMTimeRange</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">CMTime</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">MKCoordinateSpan</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">NSRange</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">SCNMatrix4</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">SCNVector3</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">SCNVector4</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">UIEdgeInsets</code>
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">UIOffset</code>
</p>
</li>
</ul>
  
</section>

  	
 	<section id="next_previous" class="">
    		<p class="previous-link"><a href="WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID86" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH5-ID86">Writing Swift Classes and Protocols with Objective-C Behavior<br><span class="jpstr">
スウィフトのクラスとプロトコルをObjective-C挙動で書く
</span><!--end_jpstr-->
</a></p>
  			<p class="next-link"><a href="AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID6" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014216-CH7-ID6">Adopting Cocoa Design Patterns<br><span class="jpstr">
ココア・デザインパターンの採用
</span><!--end_jpstr-->
</a></p>

    <p class="copyright">Copyright &#x00a9; 2017 Apple Inc. All rights reserved. 
  <a class="link" href="http://www.apple.com/legal/terms/site.html" target="_blank" rel="external">Terms of Use</a> | 
  <a class="link" href="http://www.apple.com/privacy/" target="_blank" rel="external">Privacy Policy</a> | 
  Updated: 2017-12-04
</p>
  </section>
</article>

    </div>
    <div id='big_button'></div>
    <footer id="footer">
  <div class="content-wrapper">
  	<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
  </div>
  <script src="../../../../Resources/1274/JavaScript/devpubs-1.6.3.js" type="text/javascript" charset="utf-8"></script>
  <script src="../../../../Resources/1274/JavaScript/feedback-1.6.3.js" type="text/javascript" charset="utf-8"></script>
  <div id="_omniture_top">
<!-- SiteCatalyst code version: H.8. Copyright 1997-2006 Omniture, Inc. -->
<script type="text/javascript">
/* RSID: */
var s_account="appleglobal,appleusdeveloper,dappdeveloperlib"
</script>

<!-- <script type="text/javascript" src="https://www.apple.com/metrics/scripts/s_code_h.js"></script> -->
<script type="text/javascript">
s.pageName=AC.Tracking.pageName();
s.channel="www.us.developer"

/************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
var s_code=s.t();if(s_code)document.write(s_code)</script>
<!-- End SiteCatalyst code version: H.8. -->
</div>

</footer>

    
  </body>
    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="https://developer.apple.com/bugreporter/" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

</div>
</html>
