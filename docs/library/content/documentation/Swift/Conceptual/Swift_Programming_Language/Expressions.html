<!DOCTYPE html>
<html lang="en">
  <head>  
  <title>The Swift Programming Language (Swift 3.0.1): Expressions</title>
  <link rel="stylesheet" type="text/css" href="../../../../Resources/1254/CSS/style-1.6.3.css" />
  <link rel="stylesheet" type="text/css" href="../../../../Resources/1254/CSS/feedback-1.6.3.css" />
  <meta charset='utf-8'> 
<meta id="j-version" name="j-version" content="" />
<meta id="build" name="build" content="0cd917ac01ec7578a7bd8964f41dd08b" />
<meta id="document-version" name="document-version" content="8.0.3" />
<meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Topic/Swift}" />
<meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/TP40014097" />
<meta id="chapterId" name="chapterId" content="TP40014097-CH32">
<meta id="book-title" name="book-title" content="The Swift Programming Language (Swift 3.0.1)" />
<meta id="book-resource-type" name="book-resource-type" content="Guide" />
<meta id="book-root" name="book-root" content="./" />
<meta id="book-json" name="book-json" content="book.json">
<meta id="date" name="date" content="2016-10-27" />
<meta id="description" name="description" content="The definitive guide to Swift, Apple’s new programming language for building iOS, OS X, watchOS, and tvOS apps." />
<meta id="IndexTitle" name="IndexTitle" content="" />
<meta id="resources-uri" name="resources-uri" content="../../../../Resources/1254">
<link id="book-index-page" rel="Start" title="" type="text/html" href="./index.html">
<!-- , next_chapter: next_chapter, previous_chapter: previous_chapter -->
<link id="next-page" rel="Next" type="text/html" href="">
<link id="previous-page" rel="Prev" type="text/html" href="">
<meta id="devcenter" name="devcenter" content="<!-- DEVCENTER_NAME -->" />
<meta id="devcenter-url" name="devcenter-url" content="<!-- DEVCENTER_URL -->" />
<meta id="reflib" name="reflib" content="<!-- REFLIB_NAME -->" />

<meta id="xcode-display" name="xcode-display" content="render" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<meta id="platforms" name="platforms" content="Xcode Developer Tools">
</head>

  <body id="conceptual_flow_with_tasks" class="jazz">
    
    <header id="ios_header" class="hideOnPrint hideInXcode">
  <div class="content-wrapper">
    <p class="header-text">
    	<a href="../../../../navigation/index.html">Guides and Sample Code
 		</a>
 </p>
    <p id="wwdr"><img id="apple_logo" src="../../../../Resources/1254/Images/apple2.png" height="14px" width="12px" aria-hidden="true" /><a href="https://developer.apple.com">Developer</a></p>
  </div>
</header>

    <section id="valence">
  <div class="content-wrapper">
    <p id="hierarchial_navigation">
      <span id="book_title">The Swift Programming Language (Swift 3.0.1)</span>
    </p>
    <form id="search" class="hideInXcode" method="get" action="/search/index.php" accept-charset="utf-8" autocomplete="off">
  <input type="search" id="ssi_SearchField" placeholder="Search Guides and Sample Code" name="q" autocomplete="off" tabindex="2" />
</form>

      
   
   




    <span class="download-text hideInXcode">
      <a href="https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11">iBooks</a>
    </span>

    

    <img id="shortstack" src="../../../../Resources/1254/Images/shortstack_2x.png"/>
  </div>
</section>
    <div class="content-wrapper">
      <nav id="navigator" class="book-parts hideInXcode" role="navigation">
    <ul class="nav-parts">
        <li data-id="//apple_ref/doc/uid/TP40014097-CH1-ID2"
            class="part-name">
            <a href="index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH3-ID0">Welcome to Swift<br><span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH3-ID0">About Swift<br><span class="jpstr">
スウィフトについて
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-ID1" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH2-ID1">A Swift Tour<br><span class="jpstr">
スウィフトツアー
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014097-CH4-ID233"
            class="part-name">
            <a href="TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID309">Language Guide<br><span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID309">The Basics<br><span class="jpstr">
基本
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID60">Basic Operators<br><span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID285" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH7-ID285">Strings and Characters<br><span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-ID105" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH8-ID105">Collection Types<br><span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH9-ID120">Control Flow<br><span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH10-ID158">Functions<br><span class="jpstr">
関数
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH11-ID94">Closures<br><span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH12-ID145">Enumerations<br><span class="jpstr">
列挙
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID82" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH13-ID82">Classes and Structures<br><span class="jpstr">
クラスと構造体
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH14-ID254">Properties<br><span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID234" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH15-ID234">Methods<br><span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Subscripts.html#//apple_ref/doc/uid/TP40014097-CH16-ID305" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH16-ID305">Subscripts<br><span class="jpstr">
添え字
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-ID193" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH17-ID193">Inheritance<br><span class="jpstr">
継承
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH18-ID203">Initialization<br><span class="jpstr">
初期化
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Deinitialization.html#//apple_ref/doc/uid/TP40014097-CH19-ID142" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH19-ID142">Deinitialization<br><span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID48" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH20-ID48">Automatic Reference Counting<br><span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH21-ID245">Optional Chaining<br><span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH42-ID508">Error Handling<br><span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22-ID338" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH22-ID338">Type Casting<br><span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="NestedTypes.html#//apple_ref/doc/uid/TP40014097-CH23-ID242" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH23-ID242">Nested Types<br><span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH24-ID151">Extensions<br><span class="jpstr">
拡張
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH25-ID267">Protocols<br><span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH26-ID179">Generics<br><span class="jpstr">
総称体
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-ID3" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH41-ID3">Access Control<br><span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID28" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH27-ID28">Advanced Operators<br><span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014097-CH28-ID427"
            class="part-name nav-part-active open-part">
            <a href="AboutTheLanguageReference.html#//apple_ref/doc/uid/TP40014097-CH29-ID345" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH29-ID345">Language Reference<br><span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="AboutTheLanguageReference.html#//apple_ref/doc/uid/TP40014097-CH29-ID345" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH29-ID345">About the Language Reference<br><span class="jpstr">
言語リファレンスについて
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="LexicalStructure.html#//apple_ref/doc/uid/TP40014097-CH30-ID410" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH30-ID410">Lexical Structure<br><span class="jpstr">
語彙の構造
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Types.html#//apple_ref/doc/uid/TP40014097-CH31-ID445" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH31-ID445">Types<br><span class="jpstr">
型
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter nav-current-chapter">
              	<a href="#//apple_ref/doc/uid/TP40014097-CH32-ID383" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH32-ID383">Expressions<br><span class="jpstr">
式
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Statements.html#//apple_ref/doc/uid/TP40014097-CH33-ID428" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH33-ID428">Statements<br><span class="jpstr">
文
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID351" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH34-ID351">Declarations<br><span class="jpstr">
宣言
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Attributes.html#//apple_ref/doc/uid/TP40014097-CH35-ID347" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH35-ID347">Attributes<br><span class="jpstr">
属性
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Patterns.html#//apple_ref/doc/uid/TP40014097-CH36-ID419" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH36-ID419">Patterns<br><span class="jpstr">
パターン
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="GenericParametersAndArguments.html#//apple_ref/doc/uid/TP40014097-CH37-ID406" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH37-ID406">Generic Parameters and Arguments<br><span class="jpstr">
総称体パラメータと引数
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="zzSummaryOfTheGrammar.html#//apple_ref/doc/uid/TP40014097-CH38-ID458" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH38-ID458">Summary of the Grammar<br><span class="jpstr">
文法の概要
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014097-CH39-ID460"
            class="part-name">
            <a href="RevisionHistory.html#//apple_ref/doc/uid/TP40014097-CH40-ID459" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH40-ID459">Revision History<br><span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="RevisionHistory.html#//apple_ref/doc/uid/TP40014097-CH40-ID459" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH40-ID459">Document Revision History<br><span class="jpstr">
文書改訂履歴
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
    </ul>
</nav>

      <menu id="bashful" type="toolbar">
  <div class="shield"></div>
  <menuitem id="jump_to" class="menu-bar-item closed">
  <span>On This Page</span>
  <div class="chevron">
    <div class="chevy chevron-left"></div>
    <div class="chevy chevron-right"></div>
  </div>
  <menu type="list" class="details">
      <ul class="list-bullet">
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH32-ID384">Prefix Expressions</a>
<br><span class="jpstr">
接頭辞式
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH32-ID385">Binary Expressions</a>
<br><span class="jpstr">
二項式
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH32-ID389">Primary Expressions</a>
<br><span class="jpstr">
基本式
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH32-ID397">Postfix Expressions</a>
<br><span class="jpstr">
接尾辞表現
</span><!--end_jpstr-->
          </li>
      </ul>
  </menu>
</menuitem>

</menu>
<div class="pixel-line"></div>
<div class="rubber-band-gap"></div>
<article class="chapter">
  <a name="//apple_ref/doc/uid/TP40014097-CH32"></a><a name="//apple_ref/doc/uid/TP40014097-CH32-ID383"></a>

  <h2 class='chapter-name'>Expressions<br><span class="jpstr">
式
</span><!--end_jpstr-->
</h2>


  
  	<section class="section">
  		<p class="para">
  In Swift, there are four kinds of expressions: prefix expressions, binary expressions, primary expressions, and postfix expressions. Evaluating an expression returns a value, causes a side effect, or both.
<br><span class="jpstr">
スウィフトには、４種類の式があります：接頭辞式、二項式、基本式、そして接尾辞式。ある式を評価することは、ひとつの値を返す、ある副作用を引き起こす、あるいはその両方です。
</span><!--end_jpstr-->
</p>
<p class="para">
  Prefix and binary expressions let you apply operators to smaller expressions. Primary expressions are conceptually the simplest kind of expression, and they provide a way to access values. Postfix expressions, like prefix and binary expressions, let you build up more complex expressions using postfixes such as function calls and member access. Each kind of expression is described in detail in the sections below.
<br><span class="jpstr">
接頭辞と二項式は、あなたに演算子をより小さい式に適用させます。基本式は、概念的に最も単純な種類の式で、それらはアクセス手段をさまざまな値に提供します。接尾辞式は、接頭辞や二項の式に似て、関数呼び出しやメンバー・アクセスのような接尾辞を使うことで、あなたにより複雑な式を組み立てさせます。各種類の式は、以下の節において詳細に記述されます。
</span><!--end_jpstr-->
</p>
<div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of an expression
<br><span class="jpstr">
式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/expression"></a>
  <span class="syntax-def-name">
  expression
</span>
<span class="arrow">
  →
</span><span class="optional"><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/try-operator" data-renderer-version="2" data-id="//apple_ref/swift/grammar/try-operator">try-operator</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/prefix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/prefix-expression">prefix-expression</a>&shy;</span><span class="optional"><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/binary-expressions" data-renderer-version="2" data-id="//apple_ref/swift/grammar/binary-expressions">binary-expressions</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/expression-list"></a>
  <span class="syntax-def-name">
  expression-list
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">,&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression-list" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression-list">expression-list</a>&shy;</span>
</span>
</p>
</div>
 </div>
		</section> 


  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID384"></a>
  <h3 class="section-name" tabindex="0">Prefix Expressions<br><span class="jpstr">
接頭辞式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  <em>Prefix expressions</em> combine an optional prefix operator with an expression. Prefix operators take one argument, the expression that follows them.
<br><span class="jpstr">
<em>接頭辞式</em>では、ある任意の接頭辞演算子をひとつの式と組み合わせます。接頭辞演算子は、１つの引数（それらの後に続く式）をとります。
</span><!--end_jpstr-->
</p><p class="para">
  For information about the behavior of these operators, see <span class="x-name"><a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID60">Basic Operators</a></span> and <span class="x-name"><a href="AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID28" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH27-ID28">Advanced Operators</a></span>.
<br><span class="jpstr">
これらの演算子の挙動に関して詳しくは、<span class="x-name"><a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID60">基本の演算子</a></span>と<span class="x-name"><a href="AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID28" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH27-ID28">先進の演算子</a></span>を見てください。
</span><!--end_jpstr-->
</p><p class="para">
  For information about the operators provided by the Swift standard library, see <em class="u-book"><a href="https://developer.apple.com/reference/swift/1851035-swift_standard_library_operators" class="urlLink" target="_self">Swift Standard Library Operators Reference</a></em>.
</p><p class="para">
  In addition to the standard library operators, you use <code class="code-voice">&amp;</code> immediately before the name of a variable that’s being passed as an in-out argument to a function call expression. For more information and to see an example, see <span class="x-name"><a href="Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID173" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH10-ID173">In-Out Parameters</a></span>.
<br><span class="jpstr">
標準ライブラリ演算子に加えて、あなたは<code class="code-voice">&amp;</code>を変数の名前の直前で使います、それはin-out引数として関数呼び出し式に渡されています。より多くの情報のために、そして、例を見るために、<span class="x-name"><a href="Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID173" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH10-ID173">In-Outパラメータ</a></span>を見てください。
</span><!--end_jpstr-->
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a prefix expression
<br><span class="jpstr">
接頭辞式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/prefix-expression"></a>
  <span class="syntax-def-name">
  prefix-expression
</span>
<span class="arrow">
  →
</span><span class="optional"><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/prefix-operator" data-renderer-version="2" data-id="//apple_ref/swift/grammar/prefix-operator">prefix-operator</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/postfix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_373"></a>
  <span class="syntax-def-name">
  prefix-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/in-out-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/in-out-expression">in-out-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/in-out-expression"></a>
  <span class="syntax-def-name">
  in-out-expression
</span>
<span class="arrow">
  →
</span><code class="literal">&amp;&shy;</code><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/identifier" data-renderer-version="2" data-id="//apple_ref/swift/grammar/identifier">identifier</a>&shy;</span>
</p>
</div>
 </div>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID516"></a>
  <h3 class="section-name" tabindex="0">Try Operator<br><span class="jpstr">
try演算子
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A <em>try expression</em> consists of the <code class="code-voice">try</code> operator followed by an expression that can throw an error. It has the following form:
<br><span class="jpstr">
<em>try式</em>は、<code class="code-voice">try</code>演算子と後につづくエラーをスローできる１つの式から成ります。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><span class="kt">try</span> <em class="variable-text">expression</em></pre></li>
  </ul>
</div><p class="para">
  An <em>optional-try expression</em> consists of the <code class="code-voice">try?</code> operator followed by an expression that can throw an error. It has the following form:
<br><span class="jpstr">
<em>オプショナルtry式</em>は、<code class="code-voice">try?</code>演算子と後につづくエラーをスローできる１つの式から成ります。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><span class="kt">try</span>? <em class="variable-text">expression</em></pre></li>
  </ul>
</div><p class="para">
  If the <em>expression</em> does not throw an error, the value of the optional-try expression is an optional containing the value of the <em>expression</em>. Otherwise, the value of the optional-try expression is <code class="code-voice">nil</code>.
<br><span class="jpstr">
この<em>expression（式）</em>がエラーをスローしないならば、オプショナルtry式の値はひとつのオプショナルになり、その<em>expression（式）</em>の値を含んでいます。そうでなければ、オプショナルtry式の値は<code class="code-voice">nil</code>です。
</span><!--end_jpstr-->
</p><p class="para">
  A <em>forced-try expression</em> consists of the <code class="code-voice">try!</code> operator followed by an expression that can throw an error. It has the following form:
<br><span class="jpstr">
<em>強制try式</em>は、<code class="code-voice">try!</code>演算子と後につづくエラーをスローできる１つの式から成ります。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><span class="kt">try</span>! <em class="variable-text">expression</em></pre></li>
  </ul>
</div><p class="para">
  If the <em>expression</em> throws an error, a runtime error is produced.
<br><span class="jpstr">
この<em>expression（式）</em>がエラーをスローするならば、実行時エラーが生み出されます。
</span><!--end_jpstr-->
</p><p class="para">
  When the expression on the left hand side of a binary operator is marked with <code class="code-voice">try</code>, <code class="code-voice">try?</code>, or <code class="code-voice">try!</code>, that operator applies to the whole binary expression. That said, you can use parentheses to be explicit about the scope of the operator’s application.
<br><span class="jpstr">
ある二項演算子の左手側での式が<code class="code-voice">try</code>、<code class="code-voice">try?</code>、または<code class="code-voice">try!</code>で印されるならば、その演算子は二項式全体に適用されます。とは言うものの、あなたは丸括弧を使って演算子の適用範囲について明確にすることができます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">sum</span> = <span class="kt">try</span> <span class="vc">someThrowingFunction</span>() + <span class="vc">anotherThrowingFunction</span>()   <span class="c">// try applies to both function calls&nbsp;<span class="jpstr"><span class="c">（tryは、両方の関数呼び出しに適用されます）</span></span><!--end_jpstr--></span>
</code></li>
            <li><code class="code-voice"><span class="vc">sum</span> = <span class="kt">try</span> (<span class="vc">someThrowingFunction</span>() + <span class="vc">anotherThrowingFunction</span>()) <span class="c">// try applies to both function calls&nbsp;<span class="jpstr"><span class="c">（tryは、両方の関数呼び出しに適用されます）</span></span><!--end_jpstr--></span>
</code></li>
            <li><code class="code-voice"><span class="vc">sum</span> = (<span class="vc">try</span> <span class="vc">someThrowingFunction</span>()) + <span class="vc">anotherThrowingFunction</span>() <span class="c">// Error: try applies only to the first function call&nbsp;<span class="jpstr"><span class="c">（エラー：tryは、最初の関数呼び出しだけに適用されます）</span></span><!--end_jpstr--></span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  A <code class="code-voice">try</code> expression can’t appear on the right hand side of a binary operator, unless the binary operator is the assignment operator or the <code class="code-voice">try</code> expression is enclosed in parentheses.
<br><span class="jpstr">
<code class="code-voice">try</code>式が二項演算子の右手側に現れることは、その二項演算子が代入演算子であるか<code class="code-voice">try</code>式が丸括弧の中に入れられるかしない限りできません。
</span><!--end_jpstr-->
</p><p class="para">
  For more information and to see examples of how to use <code class="code-voice">try</code>, <code class="code-voice">try?</code>, and <code class="code-voice">try!</code>, see <span class="x-name"><a href="ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH42-ID508">Error Handling</a></span>.
<br><span class="jpstr">
より多くの情報のために、そして<code class="code-voice">try</code>、<code class="code-voice">try?</code>、そして<code class="code-voice">try!</code>文を使う方法の例を見るために、<span class="x-name"><a href="ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH42-ID508">エラーを処理する</a></span>を見てください。
</span><!--end_jpstr-->
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a try expression
<br><span class="jpstr">
try式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/try-operator"></a>
  <span class="syntax-def-name">
  try-operator
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <code class="literal">try&shy;</code>
</span><span class="alternative">
  <code class="literal">try&shy;</code><code class="literal">?&shy;</code>
</span><span class="alternative">
  <code class="literal">try&shy;</code><code class="literal">!&shy;</code>
</span>
</p>
</div>
 </div>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID385"></a>
  <h3 class="section-name" tabindex="0">Binary Expressions<br><span class="jpstr">
二項式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  <em>Binary expressions</em> combine an infix binary operator with the expression that it takes as its left-hand and right-hand arguments. It has the following form:
<br><span class="jpstr">
<em>二項式</em>は、接中辞二進数演算子を、それがその左手側と右手側の引数としてとる式と組み合わせます。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><em class="variable-text">left-hand argument</em> <em class="variable-text">operator</em> <em class="variable-text">right-hand argument</em></pre></li>
  </ul>
</div><p class="para">
  For information about the behavior of these operators, see <span class="x-name"><a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID60">Basic Operators</a></span> and <span class="x-name"><a href="AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID28" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH27-ID28">Advanced Operators</a></span>.
<br><span class="jpstr">
これらの演算子の挙動に関して詳しくは、<span class="x-name"><a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID60">基本の演算子</a></span>と<span class="x-name"><a href="AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID28" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH27-ID28">先進の演算子</a></span>を見てください。
</span><!--end_jpstr-->
</p><p class="para">
  For information about the operators provided by the Swift standard library, see <em class="u-book"><a href="https://developer.apple.com/reference/swift/1851035-swift_standard_library_operators" class="urlLink" target="_self">Swift Standard Library Operators Reference</a></em>.
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_377"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">At parse time, an expression made up of binary operators is represented as a flat list. This list is transformed into a tree by applying operator precedence. For example, the expression <code class="code-voice">2 + 3 * 5</code> is initially understood as a flat list of five items, <code class="code-voice">2</code>, <code class="code-voice">+</code>, <code class="code-voice">3</code>, <code class="code-voice">*</code>, and <code class="code-voice">5</code>. This process transforms it into the tree (2 + (3 * 5)).
    	<br><span class="jpstr">
構文解析の時、二項演算子から成り立つ式は、平坦なリストとして表わされます。このリストは、演算子優先順位を適用することによって、ツリー（木構造）に変えられます。例えば、式<code class="code-voice">2 + 3 * 5</code>は、最初に５つの項目、<code class="code-voice">2</code>、<code class="code-voice">+</code>、<code class="code-voice">3</code>、<code class="code-voice">*</code>、そして<code class="code-voice">5</code>の平坦なリストとして理解されます。この処理は、それをツリー(2 + (3 * 5))に変えます。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a binary expression
<br><span class="jpstr">
二項式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/binary-expression"></a>
  <span class="syntax-def-name">
  binary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/binary-operator" data-renderer-version="2" data-id="//apple_ref/swift/grammar/binary-operator">binary-operator</a>&shy;</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/prefix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/prefix-expression">prefix-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_380"></a>
  <span class="syntax-def-name">
  binary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/assignment-operator" data-renderer-version="2" data-id="//apple_ref/swift/grammar/assignment-operator">assignment-operator</a>&shy;</span><span class="optional"><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/try-operator" data-renderer-version="2" data-id="//apple_ref/swift/grammar/try-operator">try-operator</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/prefix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/prefix-expression">prefix-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_381"></a>
  <span class="syntax-def-name">
  binary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/conditional-operator" data-renderer-version="2" data-id="//apple_ref/swift/grammar/conditional-operator">conditional-operator</a>&shy;</span><span class="optional"><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/try-operator" data-renderer-version="2" data-id="//apple_ref/swift/grammar/try-operator">try-operator</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/prefix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/prefix-expression">prefix-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_382"></a>
  <span class="syntax-def-name">
  binary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/type-casting-operator" data-renderer-version="2" data-id="//apple_ref/swift/grammar/type-casting-operator">type-casting-operator</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/binary-expressions"></a>
  <span class="syntax-def-name">
  binary-expressions
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/binary-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/binary-expression">binary-expression</a>&shy;</span><span class="optional"><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/binary-expressions" data-renderer-version="2" data-id="//apple_ref/swift/grammar/binary-expressions">binary-expressions</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span>
</p>
</div>
 </div>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID386"></a>
  <h3 class="section-name" tabindex="0">Assignment Operator<br><span class="jpstr">
代入演算子
</span><!--end_jpstr-->
</h3>
  <p class="para">
  The <em>assignment operator</em> sets a new value for a given expression. It has the following form:
<br><span class="jpstr">
<em>代入演算子</em>は、指定された式に対してある新しい値を設定します。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><em class="variable-text">expression</em> = <em class="variable-text">value</em></pre></li>
  </ul>
</div><p class="para">
  The value of the <em>expression</em> is set to the value obtained by evaluating the <em>value</em>. If the <em>expression</em> is a tuple, the <em>value</em> must be a tuple with the same number of elements. (Nested tuples are allowed.) Assignment is performed from each part of the <em>value</em> to the corresponding part of the <em>expression</em>. For example:
<br><span class="jpstr">
<em>式</em>の値は、<em>値</em>を評価することによって得られる値に設定されます。<em>式</em>がタプルであるならば、<em>値</em>は同じ数の要素をもつタプルでなければなりません。（入れ子にされたタプルは、認められます）。代入は、<em>値</em>の各部分から<em>式</em>の対応する部分へと実行されます。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice">(<span class="vc">a</span>, <span class="kt">_</span>, (<span class="vc">b</span>, <span class="vc">c</span>)) = (<span class="s">&quot;test&quot;</span>, <span class="m">9.45</span>, (<span class="m">12</span>, <span class="m">3</span>))</code></li>
            <li><code class="code-voice"><span class="c">// a is &quot;test&quot;, b is 12, c is 3, and 9.45 is ignored&nbsp;<span class="jpstr">（aは「test」です、bは12です、cは３です、そして9.45は無視されます）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The assignment operator does not return any value.
<br><span class="jpstr">
代入演算子は、少しの値も返しません。
</span><!--end_jpstr-->
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of an assignment operator
<br><span class="jpstr">
代入演算子の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/assignment-operator"></a>
  <span class="syntax-def-name">
  assignment-operator
</span>
<span class="arrow">
  →
</span><code class="literal">=&shy;</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID387"></a>
  <h3 class="section-name" tabindex="0">Ternary Conditional Operator<br><span class="jpstr">
三項条件演算子
</span><!--end_jpstr-->
</h3>
  <p class="para">
  The <em>ternary conditional operator</em> evaluates to one of two given values based on the value of a condition. It has the following form:
<br><span class="jpstr">
<em>三項条件演算子</em>は、ある条件の値に基づいて、２つの与えられた値のうちの１つへと評価されます。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><em class="variable-text">condition</em> ? <em class="variable-text">expression used if true</em> : <em class="variable-text">expression used if false</em></pre></li>
  </ul>
</div><p class="para">
  If the <em>condition</em> evaluates to <code class="code-voice">true</code>, the conditional operator evaluates the first expression and returns its value. Otherwise, it evaluates the second expression and returns its value. The unused expression is not evaluated.
<br><span class="jpstr">
<em>条件</em>が<code class="code-voice">true</code>に評価されるならば、条件演算子は最初の式を評価して、その値を返します。そうでなければ、それは第二の式を評価して、その値を返します。使っていない式は、評価されません。
</span><!--end_jpstr-->
</p><p class="para">
  For an example that uses the ternary conditional operator, see <span class="x-name"><a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID71">Ternary Conditional Operator</a></span>.
<br><span class="jpstr">
三項条件演算子を使用する例のために、<span class="x-name"><a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID71">三項条件演算子</a></span>を見てください。
</span><!--end_jpstr-->
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a conditional operator
<br><span class="jpstr">
条件演算子の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/conditional-operator"></a>
  <span class="syntax-def-name">
  conditional-operator
</span>
<span class="arrow">
  →
</span><code class="literal">?&shy;</code><span class="optional"><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/try-operator" data-renderer-version="2" data-id="//apple_ref/swift/grammar/try-operator">try-operator</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">:&shy;</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID388"></a>
  <h3 class="section-name" tabindex="0">Type-Casting Operators<br><span class="jpstr">
型キャスト演算子
</span><!--end_jpstr-->
</h3>
  <p class="para">
  There are four type-casting operators: the <code class="code-voice">is</code> operator, the <code class="code-voice">as</code> operator, the <code class="code-voice">as?</code> operator, and the <code class="code-voice">as!</code> operator.
<br><span class="jpstr">
４つの型キャスト演算子、<code class="code-voice">is</code>演算子、<code class="code-voice">as</code>演算子、<code class="code-voice">as?</code>演算子、そして<code class="code-voice">as!</code>演算子があります。
</span><!--end_jpstr-->
</p><p class="para">
  They have the following form:
<br><span class="jpstr">
これらは以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><em class="variable-text">expression</em> <span class="kt">is</span> <em class="variable-text">type</em></pre></li><li><pre class="code-voice"><em class="variable-text">expression</em> <span class="kt">as</span> <em class="variable-text">type</em></pre></li><li><pre class="code-voice"><em class="variable-text">expression</em> <span class="kt">as</span>? <em class="variable-text">type</em></pre></li><li><pre class="code-voice"><em class="variable-text">expression</em> <span class="kt">as</span>! <em class="variable-text">type</em></pre></li>
  </ul>
</div><p class="para">
  The <code class="code-voice">is</code> operator checks at runtime whether the <em>expression</em> can be cast to the specified <em>type</em>. It returns <code class="code-voice">true</code> if the <em>expression</em> can be cast to the specified <em>type</em>; otherwise, it returns <code class="code-voice">false</code>.
<br><span class="jpstr">
<code class="code-voice">is</code>演算子は実行時に<em>式</em>が指定された<em>型</em>へとキャスト可能かどうかを調べます。それは、<em>式</em>が指定された<em>型</em>へキャストできるならば<code class="code-voice">true</code>を返します；そうでなければ<code class="code-voice">false</code>を返します。
</span><!--end_jpstr-->
</p><p class="para">
  The <code class="code-voice">as</code> operator performs a cast when it is known at compile time that the cast always succeeds, such as upcasting or bridging. Upcasting lets you use an expression as an instance of its type’s supertype, without using an intermediate variable. The following approaches are equivalent:
<br><span class="jpstr">
<code class="code-voice">as</code>演算子は、コンパイル時にそのキャストが常に成功することを知られているキャストを実行します、例えばアップキャストやブリッジなど。アップキャストは、あなたにある式をそれのスーパータイプのインスタンスとして使用させます、中間生成物の変数の使用なしに。以下の各取り組みは同等です：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">f</span>(<span class="kt">_</span> <span class="vc">any</span>: <span class="kt">Any</span>) { <span class="vc">print</span>(<span class="s">&quot;Function for Any&quot;</span>) }</code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">f</span>(<span class="kt">_</span> <span class="vc">int</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>) { <span class="vc">print</span>(<span class="s">&quot;Function for Int&quot;</span>) }</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">x</span> = <span class="m">10</span></code></li>
            <li><code class="code-voice"><span class="vc">f</span>(<span class="vc">x</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;Function for Int&quot;</span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">y</span>: <span class="kt">Any</span> = <span class="vc">x</span></code></li>
            <li><code class="code-voice"><span class="vc">f</span>(<span class="vc">y</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;Function for Any&quot;</span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">f</span>(<span class="vc">x</span> <span class="kt">as</span> <span class="kt">Any</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;Function for Any&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Bridging lets you use an expression of a Swift standard library type such as <code class="code-voice">String</code> as its corresponding Foundation type such as <code class="code-voice">NSString</code> without needing to create a new instance. For more information on bridging, see <a href="../BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6" data-renderer-version="2" target="_self">Working with Cocoa Data Types</a> in <em class="u-book"><a href="../BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" data-renderer-version="2" target="_self">Using Swift with Cocoa and Objective-C (Swift 3.0.1)</a></em>.
<br><span class="jpstr">
ブリッジは、あなたに<code class="code-voice">String</code>のようなスウィフト標準ライブラリ型の式を、<code class="code-voice">NSString</code>のようなそれの対応しているFoundation型として使用させます、新しいインスタンスを作成する必要なしに。ブリッジに関する更なる情報として、<a href="../BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6" data-renderer-version="2" target="_self">ココアデータ型を扱う</a>を<em class="u-book"><a href="../BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" data-renderer-version="2" target="_self">SwiftをCocoaとObjective-Cと共に使う（Swift 3.0.1）</a></em>で見てください。
</span><!--end_jpstr-->
</p><p class="para">
  The <code class="code-voice">as?</code> operator performs a conditional cast of the <em>expression</em> to the specified <em>type</em>. The <code class="code-voice">as?</code> operator returns an optional of the specified <em>type</em>. At runtime, if the cast succeeds, the value of <em>expression</em> is wrapped in an optional and returned; otherwise, the value returned is <code class="code-voice">nil</code>. If casting to the specified <em>type</em> is guaranteed to fail or is guaranteed to succeed, a compile-time error is raised.
<br><span class="jpstr">
<code class="code-voice">as?</code>演算子は<em>式</em>の指定された<em>型</em>への条件付きキャストを実行します。<code class="code-voice">as?</code>演算子は、指定された<em>型</em>のオプショナルを返します。実行時に、キャストが成功したならば、<em>式</em>の値がひとつのオプショナルの中にラップされて返されます；そうでなければ返される値は<code class="code-voice">nil</code>です。指定された<em>型</em>へのキャストが失敗すると保証されるまたは成功すると保証される場合には、コンパイル時エラーが引き起こされます。
</span><!--end_jpstr-->
</p><p class="para">
  The <code class="code-voice">as!</code> operator performs a forced cast of the <em>expression</em> to the specified <em>type</em>. The <code class="code-voice">as!</code> operator returns a value of the specified <em>type</em>, not an optional type. If the cast fails, a runtime error is raised. The behavior of <code class="code-voice">x as! T</code> is the same as the behavior of <code class="code-voice">(x as? T)!</code>.
<br><span class="jpstr">
<code class="code-voice">as!</code>演算子は<em>式</em>の指定された<em>型</em>への強制的なキャストを実行します。<code class="code-voice">as!</code>演算子は指定された<em>型</em>の値を返します、オプショナル型ではなく。キャストが失敗したならば、実行時エラーが引き起こされます。<code class="code-voice">x as! T</code>の挙動は、<code class="code-voice">(x as? T)!</code>の挙動と同じです。
</span><!--end_jpstr-->
</p><p class="para">
  For more information about type casting and to see examples that use the type-casting operators, see <span class="x-name"><a href="TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22-ID338" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH22-ID338">Type Casting</a></span>.
<br><span class="jpstr">
型キャストに関するより多くの情報のために、そして、型キャスト演算子を使用する例をより多く見るために、<span class="x-name"><a href="TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22-ID338" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH22-ID338">型キャスト</a></span>を見てください。
</span><!--end_jpstr-->
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a type-casting operator
<br><span class="jpstr">
型キャスト演算子の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/type-casting-operator"></a>
  <span class="syntax-def-name">
  type-casting-operator
</span>
<span class="arrow">
  →
</span><code class="literal">is&shy;</code><span class="syntactic-cat"><a href="Types.html#//apple_ref/swift/grammar/type" data-renderer-version="2" data-id="//apple_ref/swift/grammar/type">type</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_390"></a>
  <span class="syntax-def-name">
  type-casting-operator
</span>
<span class="arrow">
  →
</span><code class="literal">as&shy;</code><span class="syntactic-cat"><a href="Types.html#//apple_ref/swift/grammar/type" data-renderer-version="2" data-id="//apple_ref/swift/grammar/type">type</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_391"></a>
  <span class="syntax-def-name">
  type-casting-operator
</span>
<span class="arrow">
  →
</span><code class="literal">as&shy;</code><code class="literal">?&shy;</code><span class="syntactic-cat"><a href="Types.html#//apple_ref/swift/grammar/type" data-renderer-version="2" data-id="//apple_ref/swift/grammar/type">type</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_392"></a>
  <span class="syntax-def-name">
  type-casting-operator
</span>
<span class="arrow">
  →
</span><code class="literal">as&shy;</code><code class="literal">!&shy;</code><span class="syntactic-cat"><a href="Types.html#//apple_ref/swift/grammar/type" data-renderer-version="2" data-id="//apple_ref/swift/grammar/type">type</a>&shy;</span>
</p>
</div>
 </div>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID389"></a>
  <h3 class="section-name" tabindex="0">Primary Expressions<br><span class="jpstr">
基本式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  <em>Primary expressions</em> are the most basic kind of expression. They can be used as expressions on their own, and they can be combined with other tokens to make prefix expressions, binary expressions, and postfix expressions.
<br><span class="jpstr">
<em>基本式</em>は、最も基本的な種類の式です。それらはそれら自身で式として使われることができます、そしてそれらは接頭辞式、二項式、そして接尾辞式を作るために別のトークンと組み合わされることができます。
</span><!--end_jpstr-->
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a primary expression
<br><span class="jpstr">
基本式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/primary-expression"></a>
  <span class="syntax-def-name">
  primary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/identifier" data-renderer-version="2" data-id="//apple_ref/swift/grammar/identifier">identifier</a>&shy;</span><span class="optional"><span class="syntactic-cat"><a href="GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-argument-clause" data-renderer-version="2" data-id="//apple_ref/swift/grammar/generic-argument-clause">generic-argument-clause</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_395"></a>
  <span class="syntax-def-name">
  primary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/literal-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/literal-expression">literal-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_396"></a>
  <span class="syntax-def-name">
  primary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/self-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/self-expression">self-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_397"></a>
  <span class="syntax-def-name">
  primary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/superclass-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/superclass-expression">superclass-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_398"></a>
  <span class="syntax-def-name">
  primary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/closure-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/closure-expression">closure-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_399"></a>
  <span class="syntax-def-name">
  primary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/parenthesized-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/parenthesized-expression">parenthesized-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_400"></a>
  <span class="syntax-def-name">
  primary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/tuple-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/tuple-expression">tuple-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_401"></a>
  <span class="syntax-def-name">
  primary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/implicit-member-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/implicit-member-expression">implicit-member-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_402"></a>
  <span class="syntax-def-name">
  primary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/wildcard-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/wildcard-expression">wildcard-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_403"></a>
  <span class="syntax-def-name">
  primary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/selector-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/selector-expression">selector-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_404"></a>
  <span class="syntax-def-name">
  primary-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/key-path-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/key-path-expression">key-path-expression</a>&shy;</span>
</p>
</div>
 </div>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID390"></a>
  <h3 class="section-name" tabindex="0">Literal Expression<br><span class="jpstr">
リテラル式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A <em>literal expression</em> consists of either an ordinary literal (such as a string or a number), an array or dictionary literal, a playground literal, or one of the following special literals:
<br><span class="jpstr">
<em>リテラル式</em>は、普通のリテラル（例えば、ある文字列または数）、配列または辞書リテラル、プレイグラウンドリテラル、または以下の特別なリテラルのうちの１つから成ります：
</span><!--end_jpstr-->
</p><div class="tableholder">
  
  <table class="graybox" border="0" cellspacing="0" cellpadding="5">
    <caption class="tablecaption"></caption>
    <thead>
        <tr>
            <th scope="col" class="TableHeading_TableRow_TableCell"><p class="para">
  Literal
<br><span class="jpstr">
リテラル
</span><!--end_jpstr-->
</p></th>
            <th scope="col" class="TableHeading_TableRow_TableCell"><p class="para">
  Type
<br><span class="jpstr">
型
</span><!--end_jpstr-->
</p></th>
            <th scope="col" class="TableHeading_TableRow_TableCell"><p class="para">
  Value
</p></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">#file</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">String</code>
</p></td>
            <td><p class="para">
  The name of the file in which it appears.
<br><span class="jpstr">
それが現れるファイルの名前。
</span><!--end_jpstr-->
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">#line</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">Int</code>
</p></td>
            <td><p class="para">
  The line number on which it appears.
<br><span class="jpstr">
それが現れる行番号。
</span><!--end_jpstr-->
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">#column</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">Int</code>
</p></td>
            <td><p class="para">
  The column number in which it begins.
<br><span class="jpstr">
それが開始するコラム番号。
</span><!--end_jpstr-->
</p></td>
        </tr>
        <tr>
            <td scope="row"><p class="para">
  <code class="code-voice">#function</code>
</p></td>
            <td><p class="para">
  <code class="code-voice">String</code>
</p></td>
            <td><p class="para">
  The name of the declaration in which it appears.
<br><span class="jpstr">
それが現れる宣言の名前。
</span><!--end_jpstr-->
</p></td>
        </tr>
    </tbody>
  </table>
</div><p class="para">
  Inside a function, the value of <code class="code-voice">#function</code> is the name of that function, inside a method it is the name of that method, inside a property getter or setter it is the name of that property, inside special members like <code class="code-voice">init</code> or <code class="code-voice">subscript</code> it is the name of that keyword, and at the top level of a file it is the name of the current module.
<br><span class="jpstr">
関数の内側では、<code class="code-voice">#function</code>の値は、その関数の名前であり、メソッドの内側ではそれはそのメソッドの名前であり、プロパティゲッターやセッターの内側ではそれはそのプロパティの名前であり、<code class="code-voice">init</code>または<code class="code-voice">subscript</code>のような特別なメンバーの内側ではそれはそのキーワードの名前であり、そしてあるファイルのトップレベルではそれは現在のモジュールの名前です。
</span><!--end_jpstr-->
</p><p class="para">
  When used as the default value of a function or method, the special literal’s value is determined when the default value expression is evaluated at the call site.
<br><span class="jpstr">
関数やメソッドの省略時の値として使われる場合は、この特別なリテラルの値はその省略時の値の式が呼び出し現場で評価される時に確定されます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">logFunctionName</span>(<span class="vc">string</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span> = <span class="kt">#function</span>) {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="vc">string</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">myFunction</span>() {</code></li>
            <li><code class="code-voice">    <span class="vc">logFunctionName</span>() <span class="c">// Prints &quot;myFunction()&quot;.</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  An <em>array literal</em> is an ordered collection of values. It has the following form:
<br><span class="jpstr">
<em>配列リテラル</em>は、順序付けられた値のコレクションです。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice">[<em class="variable-text">value 1</em>, <em class="variable-text">value 2</em>, <em class="variable-text">...</em>]</pre></li>
  </ul>
</div><p class="para">
  The last expression in the array can be followed by an optional comma. The value of an array literal has type <code class="code-voice">[T]</code>, where <code class="code-voice">T</code> is the type of the expressions inside it. If there are expressions of multiple types, <code class="code-voice">T</code> is their closest common supertype. Empty array literals are written using an empty pair of square brackets and can be used to create an empty array of a specified type.
<br><span class="jpstr">
配列の最後の式の後に、１つの任意のコンマが続くことができます。配列リテラルの値は型<code class="code-voice">[T]</code>を持ちます、そこで、<code class="code-voice">T</code>はそれの内部の式の型です。複数の型の式があるならば、<code class="code-voice">T</code>はそれらの最も近い共通のスーパー型です。空の配列リテラルは、空の角括弧の対を使って書かれて、指定された型の空の配列をつくるために使われることができます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">emptyArray</span>: [<span class="n"><!-- a href="" -->Double<!-- /a --></span>] = []</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  A <em>dictionary literal</em> is an unordered collection of key-value pairs. It has the following form:
<br><span class="jpstr">
<em>辞書リテラル</em>は、「キーと値」の対の順序付けされないコレクションです。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice">[<em class="variable-text">key 1</em>: <em class="variable-text">value 1</em>, <em class="variable-text">key 2</em>: <em class="variable-text">value 2</em>, <em class="variable-text">...</em>]</pre></li>
  </ul>
</div><p class="para">
  The last expression in the dictionary can be followed by an optional comma. The value of a dictionary literal has type <code class="code-voice">[Key: Value]</code>, where <code class="code-voice">Key</code> is the type of its key expressions and <code class="code-voice">Value</code> is the type of its value expressions. If there are expressions of multiple types, <code class="code-voice">Key</code> and <code class="code-voice">Value</code> are the closest common supertype for their respective values. An empty dictionary literal is written as a colon inside a pair of brackets (<code class="code-voice">[:]</code>) to distinguish it from an empty array literal. You can use an empty dictionary literal to create an empty dictionary literal of specified key and value types.
<br><span class="jpstr">
辞書の最後の式の後に、１つの任意のコンマが続くことができます。辞書リテラルの値は、型<code class="code-voice">[Key: Value]</code>を持ちます、そこで、<code class="code-voice">Key</code>はそのキーの式の型です、そして、<code class="code-voice">Value</code>はその値の式の型です。複数の型の式があるならば、<code class="code-voice">Key</code>と<code class="code-voice">Value</code>はそれらめいめいの値に対して最も近い共通のスーパー型です。空の辞書リテラルは、一対の角括弧の中のコロン（<code class="code-voice">[:]</code>）として書かれることで、空の配列リテラルからそれを区別します。あなたは、空の辞書リテラルを使って、指定されたキーと値型の空の辞書リテラルを作成できます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">emptyDictionary</span>: [<span class="n"><!-- a href="" -->String<!-- /a --></span>: <span class="n"><!-- a href="" -->Double<!-- /a --></span>] = [:]</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  A <em>playground literal</em> is used by Xcode to create an interactive representation of a color, file, or image within the program editor. Playground literals in plain text outside of Xcode are represented using a special literal syntax.
<br><span class="jpstr">
<em>プレイグラウンドリテラル</em>は、Xcodeによって使われて、プログラムエディタ内でいろ、ファイル、または画像の双方向の表現を作成します。Xcodeの外部のプレーンテキストの中のプレイグラウンドリテラルは、特別なリテラル構文を使って表されます。
</span><!--end_jpstr-->
</p><p class="para">
  For information on using playground literals in Xcode, see <a href="https://help.apple.com/xcode/">Xcode Help</a> &gt; Use playgrounds &gt; Add a literal.
<br><span class="jpstr">
Xcodeにおけるプレイグラウンドリテラルの使用に関するさらなる情報として、<a href="https://help.apple.com/xcode/">Xcode Help</a> &gt; Use playgrounds &gt; Add a literal を見てください。
</span><!--end_jpstr-->
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a literal expression
<br><span class="jpstr">
リテラル式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/literal-expression"></a>
  <span class="syntax-def-name">
  literal-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/literal" data-renderer-version="2" data-id="//apple_ref/swift/grammar/literal">literal</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_407"></a>
  <span class="syntax-def-name">
  literal-expression
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/array-literal" data-renderer-version="2" data-id="//apple_ref/swift/grammar/array-literal">array-literal</a>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/dictionary-literal" data-renderer-version="2" data-id="//apple_ref/swift/grammar/dictionary-literal">dictionary-literal</a>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/playground-literal" data-renderer-version="2" data-id="//apple_ref/swift/grammar/playground-literal">playground-literal</a>&shy;</span>
</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_408"></a>
  <span class="syntax-def-name">
  literal-expression
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <code class="literal">#file&shy;</code>
</span><span class="alternative">
  <code class="literal">#line&shy;</code>
</span><span class="alternative">
  <code class="literal">#column&shy;</code>
</span><span class="alternative">
  <code class="literal">#function&shy;</code>
</span>
</p>
</div><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/array-literal"></a>
  <span class="syntax-def-name">
  array-literal
</span>
<span class="arrow">
  →
</span><code class="literal">[&shy;</code><span class="optional"><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/array-literal-items" data-renderer-version="2" data-id="//apple_ref/swift/grammar/array-literal-items">array-literal-items</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span><code class="literal">]&shy;</code>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/array-literal-items"></a>
  <span class="syntax-def-name">
  array-literal-items
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/array-literal-item" data-renderer-version="2" data-id="//apple_ref/swift/grammar/array-literal-item">array-literal-item</a>&shy;</span><span class="optional"><code class="literal">,&shy;</code><sub class="subscript">opt</sub>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/array-literal-item" data-renderer-version="2" data-id="//apple_ref/swift/grammar/array-literal-item">array-literal-item</a>&shy;</span><code class="literal">,&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/array-literal-items" data-renderer-version="2" data-id="//apple_ref/swift/grammar/array-literal-items">array-literal-items</a>&shy;</span>
</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/array-literal-item"></a>
  <span class="syntax-def-name">
  array-literal-item
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span>
</p>
</div><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/dictionary-literal"></a>
  <span class="syntax-def-name">
  dictionary-literal
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <code class="literal">[&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/dictionary-literal-items" data-renderer-version="2" data-id="//apple_ref/swift/grammar/dictionary-literal-items">dictionary-literal-items</a>&shy;</span><code class="literal">]&shy;</code>
</span><span class="alternative">
  <code class="literal">[&shy;</code><code class="literal">:&shy;</code><code class="literal">]&shy;</code>
</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/dictionary-literal-items"></a>
  <span class="syntax-def-name">
  dictionary-literal-items
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/dictionary-literal-item" data-renderer-version="2" data-id="//apple_ref/swift/grammar/dictionary-literal-item">dictionary-literal-item</a>&shy;</span><span class="optional"><code class="literal">,&shy;</code><sub class="subscript">opt</sub>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/dictionary-literal-item" data-renderer-version="2" data-id="//apple_ref/swift/grammar/dictionary-literal-item">dictionary-literal-item</a>&shy;</span><code class="literal">,&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/dictionary-literal-items" data-renderer-version="2" data-id="//apple_ref/swift/grammar/dictionary-literal-items">dictionary-literal-items</a>&shy;</span>
</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/dictionary-literal-item"></a>
  <span class="syntax-def-name">
  dictionary-literal-item
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">:&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span>
</p>
</div><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/playground-literal"></a>
  <span class="syntax-def-name">
  playground-literal
</span>
<span class="arrow">
  →
</span><code class="literal">#colorLiteral&shy;</code><code class="literal">(&shy;</code><code class="literal">red&shy;</code><code class="literal">:&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">,&shy;</code><code class="literal">green&shy;</code><code class="literal">:&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">,&shy;</code><code class="literal">blue&shy;</code><code class="literal">:&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">,&shy;</code><code class="literal">alpha&shy;</code><code class="literal">:&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">)&shy;</code>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_416"></a>
  <span class="syntax-def-name">
  playground-literal
</span>
<span class="arrow">
  →
</span><code class="literal">#fileLiteral&shy;</code><code class="literal">(&shy;</code><code class="literal">resourceName&shy;</code><code class="literal">:&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">)&shy;</code>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_417"></a>
  <span class="syntax-def-name">
  playground-literal
</span>
<span class="arrow">
  →
</span><code class="literal">#imageLiteral&shy;</code><code class="literal">(&shy;</code><code class="literal">resourceName&shy;</code><code class="literal">:&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">)&shy;</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID391"></a>
  <h3 class="section-name" tabindex="0">Self Expression<br><span class="jpstr">
self式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  The <code class="code-voice">self</code> expression is an explicit reference to the current type or instance of the type in which it occurs. It has the following forms:
<br><span class="jpstr">
<code class="code-voice">self</code>式は、それがその中に現れているところの現在の型や型のインスタンスへの明確な参照です。それは、以下の各形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><span class="kt">self</span></pre></li><li><pre class="code-voice"><span class="kt">self</span>.<em class="variable-text">member name</em></pre></li><li><pre class="code-voice"><span class="kt">self</span>[<em class="variable-text">subscript index</em>]</pre></li><li><pre class="code-voice"><span class="kt">self</span>(<em class="variable-text">initializer arguments</em>)</pre></li><li><pre class="code-voice"><span class="kt">self</span>.<span class="kt">init</span>(<em class="variable-text">initializer arguments</em>)</pre></li>
  </ul>
</div><p class="para">
  In an initializer, subscript, or instance method, <code class="code-voice">self</code> refers to the current instance of the type in which it occurs. In a type method, <code class="code-voice">self</code> refers to the current type in which it occurs.
<br><span class="jpstr">
イニシャライザ、添え字、またはインスタンスメソッドでは、<code class="code-voice">self</code>はそれが現れているところの型の現在のインスタンスに言及します。型メソッドでは、<code class="code-voice">self</code>はそれが現れているところの現在の型に言及します。
</span><!--end_jpstr-->
</p><p class="para">
  The <code class="code-voice">self</code> expression is used to specify scope when accessing members, providing disambiguation when there is another variable of the same name in scope, such as a function parameter. For example:
<br><span class="jpstr">
<code class="code-voice">self</code>式は、メンバーにアクセスする時にスコープを指定するために使われて、関数パラメータなど、同じ名前の別の変数がスコープ内にある場合に一義化を提供します。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">SomeClass</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">greeting</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">greeting</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">greeting</span> = <span class="vc">greeting</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  In a mutating method of a value type, you can assign a new instance of that value type to <code class="code-voice">self</code>. For example:
<br><span class="jpstr">
値型の可変メソッドでは、あなたは<code class="code-voice">self</code>にその値型の新しいインスタンスを代入することができます。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">struct</span> <span class="vc">Point</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">x</span> = <span class="m">0.0</span>, <span class="vc">y</span> = <span class="m">0.0</span></code></li>
            <li><code class="code-voice">    <span class="kt">mutating</span> <span class="kt">func</span> <span class="vc">moveBy</span>(<span class="vc">x</span> <span class="vc">deltaX</span>: <span class="n"><!-- a href="" -->Double<!-- /a --></span>, <span class="vc">y</span> <span class="vc">deltaY</span>: <span class="n"><!-- a href="" -->Double<!-- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span> = <span class="vc">Point</span>(<span class="vc">x</span>: <span class="vc">x</span> + <span class="vc">deltaX</span>, <span class="vc">y</span>: <span class="vc">y</span> + <span class="vc">deltaY</span>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a self expression
<br><span class="jpstr">
self式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/self-expression"></a>
  <span class="syntax-def-name">
  self-expression
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <code class="literal">self&shy;</code>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/self-method-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/self-method-expression">self-method-expression</a>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/self-subscript-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/self-subscript-expression">self-subscript-expression</a>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/self-initializer-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/self-initializer-expression">self-initializer-expression</a>&shy;</span>
</span>
</p>
</div><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/self-method-expression"></a>
  <span class="syntax-def-name">
  self-method-expression
</span>
<span class="arrow">
  →
</span><code class="literal">self&shy;</code><code class="literal">.&shy;</code><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/identifier" data-renderer-version="2" data-id="//apple_ref/swift/grammar/identifier">identifier</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/self-subscript-expression"></a>
  <span class="syntax-def-name">
  self-subscript-expression
</span>
<span class="arrow">
  →
</span><code class="literal">self&shy;</code><code class="literal">[&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression-list" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression-list">expression-list</a>&shy;</span><code class="literal">]&shy;</code>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/self-initializer-expression"></a>
  <span class="syntax-def-name">
  self-initializer-expression
</span>
<span class="arrow">
  →
</span><code class="literal">self&shy;</code><code class="literal">.&shy;</code><code class="literal">init&shy;</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID392"></a>
  <h3 class="section-name" tabindex="0">Superclass Expression<br><span class="jpstr">
スーパークラス式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A <em>superclass expression</em> lets a class interact with its superclass. It has one of the following forms:
<br><span class="jpstr">
<em>スーパークラス式</em>は、あるクラスをそのスーパークラスと相互に作用させます。それは、以下の書式のうちの１つを持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><span class="kt">super</span>.<em class="variable-text">member name</em></pre></li><li><pre class="code-voice"><span class="kt">super</span>[<em class="variable-text">subscript index</em>]</pre></li><li><pre class="code-voice"><span class="kt">super</span>.<span class="kt">init</span>(<em class="variable-text">initializer arguments</em>)</pre></li>
  </ul>
</div><p class="para">
  The first form is used to access a member of the superclass. The second form is used to access the superclass’s subscript implementation. The third form is used to access an initializer of the superclass.
<br><span class="jpstr">
最初の形式は、スーパークラスのメンバーにアクセスするために使われます。第２の形式は、スーパークラスの添え字実装にアクセスするために使われます。第３の形式は、スーパークラスのイニシャライザにアクセスするために使われます。
</span><!--end_jpstr-->
</p><p class="para">
  Subclasses can use a superclass expression in their implementation of members, subscripting, and initializers to make use of the implementation in their superclass.
<br><span class="jpstr">
サブクラスは、そのメンバー、添え字、そしてイニシャライザの実装においてスーパークラス式を使うことで、それらのスーバークラス内の実装を活用することができます。
</span><!--end_jpstr-->
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a superclass expression
<br><span class="jpstr">
スーパークラス式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/superclass-expression"></a>
  <span class="syntax-def-name">
  superclass-expression
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/superclass-method-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/superclass-method-expression">superclass-method-expression</a>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/superclass-subscript-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/superclass-subscript-expression">superclass-subscript-expression</a>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/superclass-initializer-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/superclass-initializer-expression">superclass-initializer-expression</a>&shy;</span>
</span>
</p>
</div><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/superclass-method-expression"></a>
  <span class="syntax-def-name">
  superclass-method-expression
</span>
<span class="arrow">
  →
</span><code class="literal">super&shy;</code><code class="literal">.&shy;</code><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/identifier" data-renderer-version="2" data-id="//apple_ref/swift/grammar/identifier">identifier</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/superclass-subscript-expression"></a>
  <span class="syntax-def-name">
  superclass-subscript-expression
</span>
<span class="arrow">
  →
</span><code class="literal">super&shy;</code><code class="literal">[&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression-list" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression-list">expression-list</a>&shy;</span><code class="literal">]&shy;</code>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/superclass-initializer-expression"></a>
  <span class="syntax-def-name">
  superclass-initializer-expression
</span>
<span class="arrow">
  →
</span><code class="literal">super&shy;</code><code class="literal">.&shy;</code><code class="literal">init&shy;</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID393"></a>
  <h3 class="section-name" tabindex="0">Closure Expression<br><span class="jpstr">
クロージャ式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A <em>closure expression</em> creates a closure, also known as a <em>lambda</em> or an <em>anonymous function</em> in other programming languages. Like a function declaration, a closure contains statements which it executes, and it captures constants and variables from its enclosing scope. It has the following form:
<br><span class="jpstr">
<em>クロージャ式</em>はクロージャ、他のプログラミング言語ではまた<em>lambda</em>または<em>匿名関数</em>として知られるものをつくります。関数宣言の様に、クロージャはそれらが実行する文を含みます、そして、それはそれの取り囲むスコープから定数と変数をキャプチャします。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice">{ (<em class="variable-text">parameters</em>) -&gt; <em class="variable-text">return type</em> <span class="kt">in</span></pre></li><li><pre class="code-voice">    <em class="variable-text">statements</em></pre></li><li><pre class="code-voice">}</pre></li>
  </ul>
</div><p class="para">
  The <em>parameters</em> have the same form as the parameters in a function declaration, as described in <span class="x-name"><a href="Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH34-ID362">Function Declaration</a></span>.
<br><span class="jpstr">
<em>パラメータ</em>は、関数宣言で記述されるように、<span class="x-name"><a href="Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID362" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH34-ID362">関数宣言でのパラメータ</a></span>と同じ形式を持ちます。
</span><!--end_jpstr-->
</p><p class="para">
  There are several special forms that allow closures to be written more concisely:
<br><span class="jpstr">
クロージャをより簡潔に書かれるようにする特別ないくつかの形式があります：
</span><!--end_jpstr-->
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  A closure can omit the types of its parameters, its return type, or both. If you omit the parameter names and both types, omit the <code class="code-voice">in</code> keyword before the statements. If the omitted types can’t be inferred, a compile-time error is raised.
<br><span class="jpstr">
クロージャは、そのパラメータの型、その戻り型、または両方を省略することができます。あなたがパラメータ名と両方の型を省略するならば、文の前の<code class="code-voice">in</code>キーワードを省略します。省略された型が推論されることができないならば、コンパイル時エラーが引き起こされます。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  A closure may omit names for its parameters. Its parameters are then implicitly named <code class="code-voice">$</code> followed by their position: <code class="code-voice">$0</code>, <code class="code-voice">$1</code>, <code class="code-voice">$2</code>, and so on.
<br><span class="jpstr">
クロージャは、そのパラメータの名前を省略することができます。そのパラメータは、それから暗黙のうちに<code class="code-voice">$</code>の後にそれらの位置が続く名前：<code class="code-voice">$0</code>、<code class="code-voice">$1</code>、<code class="code-voice">$2</code>、などをつけられます。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  A closure that consists of only a single expression is understood to return the value of that expression. The contents of this expression are also considered when performing type inference on the surrounding expression.
<br><span class="jpstr">
一つの式だけから成るクロージャは、その式の値を返すと理解されます。この式の内容はまた、型推論を実行する時に周囲の式上にあると見なされます。
</span><!--end_jpstr-->
</p>
</li>
</ul><p class="para">
  The following closure expressions are equivalent:
<br><span class="jpstr">
以下のクロージャ式は、等しいです：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">myFunction</span> {</code></li>
            <li><code class="code-voice">    (<span class="vc">x</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>, <span class="vc">y</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>) -&gt; <span class="n"><!-- a href="" -->Int<!-- /a --></span> <span class="kt">in</span></code></li>
            <li><code class="code-voice">    <span class="kt">return</span> <span class="vc">x</span> + <span class="vc">y</span></code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">myFunction</span> {</code></li>
            <li><code class="code-voice">    (<span class="vc">x</span>, <span class="vc">y</span>) <span class="kt">in</span></code></li>
            <li><code class="code-voice">    <span class="kt">return</span> <span class="vc">x</span> + <span class="vc">y</span></code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">myFunction</span> { <span class="kt">return</span> <span class="vc">$0</span> + <span class="vc">$1</span> }</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">myFunction</span> { <span class="vc">$0</span> + <span class="vc">$1</span> }</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  For information about passing a closure as an argument to a function, see <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH32-ID398" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH32-ID398">Function Call Expression</a></span>.
<br><span class="jpstr">
クロージャを引数として関数に渡すことに関する情報については、<span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH32-ID398" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH32-ID398">関数呼び出し式</a></span>を見てください。
</span><!--end_jpstr-->
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID544"></a>
  <h3 class="section-name" tabindex="0">Capture Lists<br><span class="jpstr">
キャプチャリスト
</span><!--end_jpstr-->
</h3>
  <p class="para">
  By default, a closure expression captures constants and variables from its surrounding scope with strong references to those values. You can use a <em>capture list</em> to explicitly control how values are captured in a closure.
<br><span class="jpstr">
初期状態では、クロージャ式は、それの囲んでいるスコープから定数や変数をそれらの値への強い参照を使ってキャプチャします。あなたは<em>キャプチャリスト</em>を使って、どのようにあるクロージャにおいて値がキャプチャされるかを明示的に制御します。
</span><!--end_jpstr-->
</p><p class="para">
  A capture list is written as a comma separated list of expressions surrounded by square brackets, before the list of parameters. If you use a capture list, you must also use the <code class="code-voice">in</code> keyword, even if you omit the parameter names, parameter types, and return type.
<br><span class="jpstr">
キャプチャリストは、角括弧に囲まれているコンマ区切りの式のリストとして、パラメータのリストの前に書かれます。あなたがキャプチャリストを使うならば、あなたはまた<code class="code-voice">in</code>キーワードも使わなければなりません、たとえあなたがパラメータ名、パラメータ型、そして戻り型を省略するとしてもです。
</span><!--end_jpstr-->
</p><p class="para">
  The entries in the capture list are initialized when the closure is created. For each entry in the capture list, a constant is initialized to the value of the constant or variable that has the same name in the surrounding scope. For example in the code below, <code class="code-voice">a</code> is included in the capture list but <code class="code-voice">b</code> is not, which gives them different behavior.
<br><span class="jpstr">
キャプチャリストの中の登録項目は、クロージャが作成されるときに初期化されます。キャプチャリストのそれぞれの登録項目に対して、その定数や変数の値へとひとつの定数が初期化されます、それは囲んでいるスコープの中で同じ名前を待ちます。例えば以下のコードにおいて、<code class="code-voice">a</code>はキャプチャリストに含まれますが<code class="code-voice">b</code>はそうではありません、そのことはそれらに異なる挙動を与えます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">a</span> = <span class="m">0</span></code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">b</span> = <span class="m">0</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">closure</span> = { [<span class="vc">a</span>] <span class="kt">in</span></code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="vc">a</span>, <span class="vc">b</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">a</span> = <span class="m">10</span></code></li>
            <li><code class="code-voice"><span class="vc">b</span> = <span class="m">10</span></code></li>
            <li><code class="code-voice"><span class="vc">closure</span>()</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;0 10&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  There are two different things named <code class="code-voice">a</code>, the variable in the surrounding scope and the constant in the closure’s scope, but only one variable named <code class="code-voice">b</code>. The <code class="code-voice">a</code> in the inner scope is initialized with the value of the <code class="code-voice">a</code> in the outer scope when the closure is created, but their values are not connected in any special way. This means that a change to the value of <code class="code-voice">a</code> in the outer scope does not affect the value of <code class="code-voice">a</code> in the inner scope, nor does a change to <code class="code-voice">a</code> inside the closure affect the value of <code class="code-voice">a</code> outside the closure. In contrast, there is only one variable named <code class="code-voice">b</code>—the <code class="code-voice">b</code> in the outer scope—so changes from inside or outside the closure are visible in both places.
<br><span class="jpstr">
<code class="code-voice">a</code>と名前をつけられる２つの異なるものがあります、囲んでいるスコープにおける変数とクロージャのスコープにおける定数、しかし<code class="code-voice">b</code>と名前をつけられる変数はただひとつのものです。内側のスコープの中の<code class="code-voice">a</code>は、クロージャが作成される時に外側のスコープの中の<code class="code-voice">a</code>の値で初期化されます、しかしそれらの値は何ら特別な方法で結びつけられません。これが意味するのは、外側のスコープの<code class="code-voice">a</code>の値に対する変更は内側のスコープの<code class="code-voice">a</code>の値に影響を及ぼさない、そしてまたクロージャ内部の<code class="code-voice">a</code>に対する変更はクロージャ外部の<code class="code-voice">a</code>に影響を及ぼさないということです。対照的に、<code class="code-voice">b</code>と名前を付けられるただ１つだけの変数があります ― 外側のスコープの中の<code class="code-voice">b</code> ― それでクロージャ内部および外部からの変更は、両方の場所で見ることができます。
</span><!--end_jpstr-->
</p><p class="para">
  This distinction is not visible when the captured variable’s type has reference semantics. For example, there are two things named <code class="code-voice">x</code> in the code below, a variable in the outer scope and a constant in the inner scope, but they both refer to the same object because of reference semantics.
<br><span class="jpstr">
この相違は、キャプチャされた変数の型が参照意味論を持つ場合には見られません。例えば、<code class="code-voice">x</code>と名前をつけられる２つのものが以下のコードにはあります、外側のスコープの中の変数と内側のスコープの中の定数、しかしそれらは両方とも同じオブジェクトを参照します、なぜなら参照意味論だからです。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">SimpleClass</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">value</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span> = <span class="m">0</span></code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">x</span> = <span class="vc">SimpleClass</span>()</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">y</span> = <span class="vc">SimpleClass</span>()</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">closure</span> = { [<span class="vc">x</span>] <span class="kt">in</span></code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="vc">x</span>.<span class="vc">value</span>, <span class="vc">y</span>.<span class="vc">value</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">x</span>.<span class="vc">value</span> = <span class="m">10</span></code></li>
            <li><code class="code-voice"><span class="vc">y</span>.<span class="vc">value</span> = <span class="m">10</span></code></li>
            <li><code class="code-voice"><span class="vc">closure</span>()</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;10 10&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If the type of the expression’s value is a class, you can mark the expression in a capture list with <code class="code-voice">weak</code> or <code class="code-voice">unowned</code> to capture a weak or unowned reference to the expression’s value.
<br><span class="jpstr">
この式の値の型がクラスならば、あなたはその式をキャプチャリストの中で<code class="code-voice">weak</code>または<code class="code-voice">unowned</code>を使って印を付けて、式の値に対する弱いまたは非所有の参照をキャプチャすることができます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">myFunction</span> { <span class="vc">print</span>(<span class="kt">self</span>.<span class="vc">title</span>) }                    <span class="c">// strong capture&nbsp;<span class="jpstr"><span class="c">（強いキャプチャ）</span></span><!--end_jpstr--></span>
</code></li>
            <li><code class="code-voice"><span class="vc">myFunction</span> { [<span class="vc">weak</span> <span class="kt">self</span>] <span class="kt">in</span> <span class="vc">print</span>(<span class="kt">self</span>!.<span class="vc">title</span>) }    <span class="c">// weak capture&nbsp;<span class="jpstr"><span class="c">（弱いキャプチャ）</span></span><!--end_jpstr--></span>
</code></li>
            <li><code class="code-voice"><span class="vc">myFunction</span> { [<span class="vc">unowned</span> <span class="kt">self</span>] <span class="kt">in</span> <span class="vc">print</span>(<span class="kt">self</span>.<span class="vc">title</span>) }  <span class="c">// unowned capture&nbsp;<span class="jpstr"><span class="c">（非所有者キャプチャ）</span></span><!--end_jpstr--></span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can also bind an arbitrary expression to a named value in a capture list. The expression is evaluated when the closure is created, and the value is captured with the specified strength. For example:
<br><span class="jpstr">
あなたはまた、ある任意の式を、キャプチャリストの中の名前をつけられた値と結び付けることができます。その式は、クロージャが作成される時に評価されます、そしてその値は、指定された強さでキャプチャされます。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="c">// Weak capture of &quot;self.parent&quot; as &quot;parent&quot;&nbsp;<span class="jpstr">（「parent」としての弱いキャプチャ「self.parent」）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="vc">myFunction</span> { [<span class="vc">weak</span> <span class="vc">parent</span> = <span class="kt">self</span>.<span class="vc">parent</span>] <span class="kt">in</span> <span class="vc">print</span>(<span class="vc">parent</span>!.<span class="vc">title</span>) }</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  For more information and examples of closure expressions, see <span class="x-name"><a href="Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID95" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH11-ID95">Closure Expressions</a></span>. For more information and examples of capture lists, see <span class="x-name"><a href="AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID57" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH20-ID57">Resolving Strong Reference Cycles for Closures</a></span>.
<br><span class="jpstr">
クロージャ式のより多くの情報と例のために、<span class="x-name"><a href="Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID95" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH11-ID95">クロージャ式</a></span>を見てください。キャプチャリストのより多くの情報と例のために、<span class="x-name"><a href="AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID57" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH20-ID57">クロージャのための強い参照循環の解消</a></span>を見てください。
</span><!--end_jpstr-->
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a closure expression
<br><span class="jpstr">
クロージャ式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/closure-expression"></a>
  <span class="syntax-def-name">
  closure-expression
</span>
<span class="arrow">
  →
</span><code class="literal">{&shy;</code><span class="optional"><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/closure-signature" data-renderer-version="2" data-id="//apple_ref/swift/grammar/closure-signature">closure-signature</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span><span class="optional"><span class="syntactic-cat"><a href="Statements.html#//apple_ref/swift/grammar/statements" data-renderer-version="2" data-id="//apple_ref/swift/grammar/statements">statements</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span><code class="literal">}&shy;</code>
</p>
</div><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/closure-signature"></a>
  <span class="syntax-def-name">
  closure-signature
</span>
<span class="arrow">
  →
</span><span class="optional"><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/capture-list" data-renderer-version="2" data-id="//apple_ref/swift/grammar/capture-list">capture-list</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/closure-parameter-clause" data-renderer-version="2" data-id="//apple_ref/swift/grammar/closure-parameter-clause">closure-parameter-clause</a>&shy;</span><span class="optional"><code class="literal">throws&shy;</code><sub class="subscript">opt</sub>&shy;</span><span class="optional"><span class="syntactic-cat"><a href="Declarations.html#//apple_ref/swift/grammar/function-result" data-renderer-version="2" data-id="//apple_ref/swift/grammar/function-result">function-result</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span><code class="literal">in&shy;</code>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_431"></a>
  <span class="syntax-def-name">
  closure-signature
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/capture-list" data-renderer-version="2" data-id="//apple_ref/swift/grammar/capture-list">capture-list</a>&shy;</span><code class="literal">in&shy;</code>
</p>
</div><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/closure-parameter-clause"></a>
  <span class="syntax-def-name">
  closure-parameter-clause
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <code class="literal">(&shy;</code><code class="literal">)&shy;</code>
</span><span class="alternative">
  <code class="literal">(&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/closure-parameter-list" data-renderer-version="2" data-id="//apple_ref/swift/grammar/closure-parameter-list">closure-parameter-list</a>&shy;</span><code class="literal">)&shy;</code>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/identifier-list" data-renderer-version="2" data-id="//apple_ref/swift/grammar/identifier-list">identifier-list</a>&shy;</span>
</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/closure-parameter-list"></a>
  <span class="syntax-def-name">
  closure-parameter-list
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/closure-parameter" data-renderer-version="2" data-id="//apple_ref/swift/grammar/closure-parameter">closure-parameter</a>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/closure-parameter" data-renderer-version="2" data-id="//apple_ref/swift/grammar/closure-parameter">closure-parameter</a>&shy;</span><code class="literal">,&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/closure-parameter-list" data-renderer-version="2" data-id="//apple_ref/swift/grammar/closure-parameter-list">closure-parameter-list</a>&shy;</span>
</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/closure-parameter"></a>
  <span class="syntax-def-name">
  closure-parameter
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/closure-parameter-name" data-renderer-version="2" data-id="//apple_ref/swift/grammar/closure-parameter-name">closure-parameter-name</a>&shy;</span><span class="optional"><span class="syntactic-cat"><a href="Types.html#//apple_ref/swift/grammar/type-annotation" data-renderer-version="2" data-id="//apple_ref/swift/grammar/type-annotation">type-annotation</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_435"></a>
  <span class="syntax-def-name">
  closure-parameter
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/closure-parameter-name" data-renderer-version="2" data-id="//apple_ref/swift/grammar/closure-parameter-name">closure-parameter-name</a>&shy;</span><span class="syntactic-cat"><a href="Types.html#//apple_ref/swift/grammar/type-annotation" data-renderer-version="2" data-id="//apple_ref/swift/grammar/type-annotation">type-annotation</a>&shy;</span><code class="literal">...&shy;</code>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/closure-parameter-name"></a>
  <span class="syntax-def-name">
  closure-parameter-name
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/identifier" data-renderer-version="2" data-id="//apple_ref/swift/grammar/identifier">identifier</a>&shy;</span>
</p>
</div><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/capture-list"></a>
  <span class="syntax-def-name">
  capture-list
</span>
<span class="arrow">
  →
</span><code class="literal">[&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/capture-list-items" data-renderer-version="2" data-id="//apple_ref/swift/grammar/capture-list-items">capture-list-items</a>&shy;</span><code class="literal">]&shy;</code>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/capture-list-items"></a>
  <span class="syntax-def-name">
  capture-list-items
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/capture-list-item" data-renderer-version="2" data-id="//apple_ref/swift/grammar/capture-list-item">capture-list-item</a>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/capture-list-item" data-renderer-version="2" data-id="//apple_ref/swift/grammar/capture-list-item">capture-list-item</a>&shy;</span><code class="literal">,&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/capture-list-items" data-renderer-version="2" data-id="//apple_ref/swift/grammar/capture-list-items">capture-list-items</a>&shy;</span>
</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/capture-list-item"></a>
  <span class="syntax-def-name">
  capture-list-item
</span>
<span class="arrow">
  →
</span><span class="optional"><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/capture-specifier" data-renderer-version="2" data-id="//apple_ref/swift/grammar/capture-specifier">capture-specifier</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/capture-specifier"></a>
  <span class="syntax-def-name">
  capture-specifier
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <code class="literal">weak&shy;</code>
</span><span class="alternative">
  <code class="literal">unowned&shy;</code>
</span><span class="alternative">
  <code class="literal">unowned(safe)&shy;</code>
</span><span class="alternative">
  <code class="literal">unowned(unsafe)&shy;</code>
</span>
</p>
</div>
 </div>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID394"></a>
  <h3 class="section-name" tabindex="0">Implicit Member Expression<br><span class="jpstr">
暗黙のメンバー式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  An <em>implicit member expression</em> is an abbreviated way to access a member of a type, such as an enumeration case or a type method, in a context where type inference can determine the implied type. It has the following form:
<br><span class="jpstr">
<em>暗黙のメンバー式</em>は、型推論が暗黙の型を決定することができる前後関係において、例えば列挙のケース節や型メソッドなど、ある型のメンバーにアクセスするための簡略された方法です。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice">.<em class="variable-text">member name</em></pre></li>
  </ul>
</div><p class="para">
  For example:
<br><span class="jpstr">
例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">x</span> = <span class="vc">MyEnumeration</span>.<span class="vc">someValue</span></code></li>
            <li><code class="code-voice"><span class="vc">x</span> = .<span class="vc">anotherValue</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a implicit member expression
<br><span class="jpstr">
暗黙的メンバー式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/implicit-member-expression"></a>
  <span class="syntax-def-name">
  implicit-member-expression
</span>
<span class="arrow">
  →
</span><code class="literal">.&shy;</code><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/identifier" data-renderer-version="2" data-id="//apple_ref/swift/grammar/identifier">identifier</a>&shy;</span>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID395"></a>
  <h3 class="section-name" tabindex="0">Parenthesized Expression<br><span class="jpstr">
括弧に入れられた式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A <em>parenthesized expression</em> consists of an expression surrounded by parentheses. You can use parentheses to specify the precedence of operations by explicitly grouping expressions. Grouping parentheses don’t change an expression’s type—for example, the type of <code class="code-voice">(1)</code> is simply <code class="code-voice">Int</code>.
<br><span class="jpstr">
<em>括弧に入れられた式</em>は、丸括弧で囲まれたある式から成ります。あなたは丸括弧を使って、明示的にいくらかの式をグループにまとめることによって演算の優先順位を指定することができます。グループ化括弧はある式のもつ型を変えません — 例えば、<code class="code-voice">(1)</code>の型は単に<code class="code-voice">Int</code>です。
</span><!--end_jpstr-->
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a parenthesized expression
<br><span class="jpstr">
丸括弧に入れられた式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/parenthesized-expression"></a>
  <span class="syntax-def-name">
  parenthesized-expression
</span>
<span class="arrow">
  →
</span><code class="literal">(&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">)&shy;</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID552"></a>
  <h3 class="section-name" tabindex="0">Tuple Expression</h3>
  <p class="para">
  A <em>tuple expression</em> consists of a comma-separated list of expressions surrounded by parentheses. Each expression can have an optional identifier before it, separated by a colon (<code class="code-voice">:</code>). It has the following form:
<br><span class="jpstr">
<em>タプル式</em>は、丸括弧に囲まれているコンマ区切りの式のリストから成ります。各式はそれの前に、コロン（<code class="code-voice">:</code>）で区切られる任意の識別子を持つことができます。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice">(<em class="variable-text">identifier 1</em>: <em class="variable-text">expression 1</em>, <em class="variable-text">identifier 2</em>: <em class="variable-text">expression 2</em>, <em class="variable-text">...</em>)</pre></li>
  </ul>
</div><p class="para">
  A tuple expression can contain zero expressions, or it can contain two or more expressions. A single expression inside parentheses is a parenthesized expression.
<br><span class="jpstr">
タプル式はゼロ個の式を含むことができます、またはそれは２つまたはそれ以上の式を含むことができます。丸括弧で囲まれたただ１つだけの式は、括弧で囲まれた式です。
</span><!--end_jpstr-->
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a tuple expression
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/tuple-expression"></a>
  <span class="syntax-def-name">
  tuple-expression
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <code class="literal">(&shy;</code><code class="literal">)&shy;</code>
</span><span class="alternative">
  <code class="literal">(&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/tuple-element" data-renderer-version="2" data-id="//apple_ref/swift/grammar/tuple-element">tuple-element</a>&shy;</span><code class="literal">,&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/tuple-element-list" data-renderer-version="2" data-id="//apple_ref/swift/grammar/tuple-element-list">tuple-element-list</a>&shy;</span><code class="literal">)&shy;</code>
</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/tuple-element-list"></a>
  <span class="syntax-def-name">
  tuple-element-list
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/tuple-element" data-renderer-version="2" data-id="//apple_ref/swift/grammar/tuple-element">tuple-element</a>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/tuple-element" data-renderer-version="2" data-id="//apple_ref/swift/grammar/tuple-element">tuple-element</a>&shy;</span><code class="literal">,&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/tuple-element-list" data-renderer-version="2" data-id="//apple_ref/swift/grammar/tuple-element-list">tuple-element-list</a>&shy;</span>
</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/tuple-element"></a>
  <span class="syntax-def-name">
  tuple-element
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/identifier" data-renderer-version="2" data-id="//apple_ref/swift/grammar/identifier">identifier</a>&shy;</span><code class="literal">:&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span>
</span>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID396"></a>
  <h3 class="section-name" tabindex="0">Wildcard Expression<br><span class="jpstr">
ワイルドカード式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A <em>wildcard expression</em> is used to explicitly ignore a value during an assignment. For example, in the following assignment 10 is assigned to <code class="code-voice">x</code> and 20 is ignored:
<br><span class="jpstr">
<em>ワイルドカード式</em>は、代入の間に明示的に値を無視するために使われます。例えば、以下の代入において、10は<code class="code-voice">x</code>に代入されて20は無視されます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice">(<span class="vc">x</span>, <span class="kt">_</span>) = (<span class="m">10</span>, <span class="m">20</span>)</code></li>
            <li><code class="code-voice"><span class="c">// x is 10, and 20 is ignored&nbsp;<span class="jpstr">（xは10です、そして20は無視されます）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a wildcard expression
<br><span class="jpstr">
ワイルドカード式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/wildcard-expression"></a>
  <span class="syntax-def-name">
  wildcard-expression
</span>
<span class="arrow">
  →
</span><code class="literal">_&shy;</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID547"></a>
  <h3 class="section-name" tabindex="0">Selector Expression<br><span class="jpstr">
セレクタ式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A selector expression lets you access the selector used to refer to a method or to a property’s getter or setter in Objective-C.
<br><span class="jpstr">
セレクタ式は、あなたに、Objective-Cにおけるあるメソッドをまたはあるプロパティの持つゲッターやセッターを参照するために使われるセレクタにアクセスをさせます。
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><span class="kt">#selector</span>(<em class="variable-text">method name</em>)</pre></li><li><pre class="code-voice"><span class="kt">#selector</span>(<span class="vc">getter</span>: <em class="variable-text">property name</em>)</pre></li><li><pre class="code-voice"><span class="kt">#selector</span>(<span class="vc">setter</span>: <em class="variable-text">property name</em>)</pre></li>
  </ul>
</div><p class="para">
  The <em>method name</em> and <em>property name</em> must be a reference to a method or a property that is available in the Objective-C runtime. The value of a selector expression is an instance of the <code class="code-voice">Selector</code> type. For example:
<br><span class="jpstr">
<em>method name</em>と<em>property name</em>は、あるメソッドおよびプロパティへの参照で、それはObjective-Cランタイムにおいて利用可能なものでなければなりません。セレクタ式の値は、<code class="code-voice">Selector</code>型のインスタンスです。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">SomeClass</span>: <span class="n"><!-- a href="" -->NSObject<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">property</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">@objc</span>(<span class="vc">doSomethingWithInt</span>:)</code></li>
            <li><code class="code-voice">    <span class="kt">func</span> <span class="vc">doSomething</span>(<span class="kt">_</span> <span class="vc">x</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>) {}</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">property</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">property</span> = <span class="vc">property</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">selectorForMethod</span> = <span class="kt">#selector</span>(<span class="vc">SomeClass</span>.<span class="vc">doSomething</span>(<span class="kt">_</span>:))</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">selectorForPropertyGetter</span> = <span class="kt">#selector</span>(<span class="vc">getter</span>: <span class="vc">SomeClass</span>.<span class="vc">property</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  When creating a selector for a property’s getter, the <em>property name</em> can be a reference to a variable or constant property. In contrast, when creating a selector for a property’s setter, the <em>property name</em> must be a reference to a variable property only.
<br><span class="jpstr">
プロパティのゲッターのためのセレクタを作成するとき、<em>property name</em>は変数または定数プロパティへの参照であることができます。対照的に、プロパティのセッターのためのセレクタを作成するとき、<em>property name</em>は必ず変数プロパティへの参照でなければなりません。
</span><!--end_jpstr-->
</p><p class="para">
  The <em>method name</em> can contain parentheses for grouping, as well the <code class="code-voice">as</code> operator to disambiguate between methods that share a name but have different type signatures. For example:
<br><span class="jpstr">
<em>method name</em>は、グループにまとめるための丸括弧、その上に、名前を共有するが異なる型シグネチャを持つメソッド間の違いを明確にするために<code class="code-voice">as</code>演算子を含むことができます。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">extension</span> <span class="n"><!-- a href="" -->SomeClass<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">@objc</span>(<span class="vc">doSomethingWithString</span>:)</code></li>
            <li><code class="code-voice">    <span class="kt">func</span> <span class="vc">doSomething</span>(<span class="kt">_</span> <span class="vc">x</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span>) { }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">anotherSelector</span> = <span class="kt">#selector</span>(<span class="vc">SomeClass</span>.<span class="vc">doSomething</span>(<span class="kt">_</span>:) <span class="kt">as</span> (<span class="n"><!-- a href="" -->SomeClass<!-- /a --></span>) -&gt; (<span class="n"><!-- a href="" -->String<!-- /a --></span>) -&gt; <span class="n"><!-- a href="" -->Void<!-- /a --></span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Because a selector is created at compile time, not at runtime, the compiler can check that a method or property exists and that they’re exposed to the Objective-C runtime.
<br><span class="jpstr">
あるセレクタが作成されるのはコンパイル時であり、実行時でないので、コンパイラはそのメソッドまたはプロパティが存在すること、そしてそれらがObjective-Cランタイムに露出されていることを確かめることができます。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_451"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Although the <em>method name</em> and the <em>property name</em> are expressions, they’re never evaluated.
    	<br><span class="jpstr">
<em>method name（メソッド名）</em>と<em>property name（プロパティ名）</em>は式であるけれども、それらは決して評価されません。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><p class="para">
  For more information about using selectors in Swift code that interacts with Objective-C APIs, see <a href="../BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID59" data-renderer-version="2" target="_self">Objective-C Selectors</a> in <em class="u-book"><a href="../BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" data-renderer-version="2" target="_self">Using Swift with Cocoa and Objective-C (Swift 3.0.1)</a></em>.
<br><span class="jpstr">
Objective-C APIと相互作用するスウィフトコードにおいてセレクタを使うことについての更なる情報として、<a href="../BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID59" data-renderer-version="2" target="_self">Objective-Cセレクタ</a>を<em class="u-book"><a href="../BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" data-renderer-version="2" target="_self">SwiftをCocoaとObjective-Cと共に使う (Swift 3.0.1)</a></em>において見てください。
</span><!--end_jpstr-->
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a selector expression
<br><span class="jpstr">
セレクタ式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/selector-expression"></a>
  <span class="syntax-def-name">
  selector-expression
</span>
<span class="arrow">
  →
</span><code class="literal">#selector&shy;</code><code class="literal">(&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">)&shy;</code>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_454"></a>
  <span class="syntax-def-name">
  selector-expression
</span>
<span class="arrow">
  →
</span><code class="literal">#selector&shy;</code><code class="literal">(&shy;</code><code class="literal">getter:&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">)&shy;</code>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_455"></a>
  <span class="syntax-def-name">
  selector-expression
</span>
<span class="arrow">
  →
</span><code class="literal">#selector&shy;</code><code class="literal">(&shy;</code><code class="literal">setter:&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">)&shy;</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID549"></a>
  <h3 class="section-name" tabindex="0">Key-Path Expression<br><span class="jpstr">
キーパス式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A key-path expression lets you access the string used to refer to a property in Objective-C for use in key-value coding and key-value observing APIs.
<br><span class="jpstr">
キーパス式は、あなたにキー値コーディングとキー値監視APIにおいて使うためにObjective-Cでのプロパティを参照するのに使われる文字列にアクセスをさせます。
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><span class="kt">#keyPath</span>(<em class="variable-text">property name</em>)</pre></li>
  </ul>
</div><p class="para">
  The <em>property name</em> must be a reference to a property that is available in the Objective-C runtime. At compile time, the key-path expression is replaced by a string literal. For example:
<br><span class="jpstr">
<em>property name</em>は、Objective-Cランタイムにおいて利用可能であるプロパティへの参照でなければなりません。コンパイル時において、キーパス式は文字列リテラルで置き換えられます。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">@objc</span> <span class="kt">class</span> <span class="vc">SomeClass</span>: <span class="n"><!-- a href="" -->NSObject<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">someProperty</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">someProperty</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">someProperty</span> = <span class="vc">someProperty</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    <span class="kt">func</span> <span class="vc">keyPathTest</span>() -&gt; <span class="n"><!-- a href="" -->String<!-- /a --></span> {</code></li>
            <li><code class="code-voice">        <span class="kt">return</span> <span class="kt">#keyPath</span>(<span class="vc">someProperty</span>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">c</span> = <span class="vc">SomeClass</span>(<span class="vc">someProperty</span>: <span class="m">12</span>)</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">keyPath</span> = <span class="kt">#keyPath</span>(<span class="vc">SomeClass</span>.<span class="vc">someProperty</span>)</code></li>
            <li><code class="code-voice"><span class="vc">print</span>(<span class="vc">keyPath</span> == <span class="vc">c</span>.<span class="vc">keyPathTest</span>())</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;true&quot;&nbsp;<span class="jpstr">（「true」を出力します）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">value</span> = <span class="vc">c</span>.<span class="vc">value</span>(<span class="vc">forKey</span>: <span class="vc">keyPath</span>) {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="vc">value</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;12&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Because the key path is created at compile time, not at runtime, the compiler can check that the property exists and that the property is exposed to the Objective-C runtime.
<br><span class="jpstr">
キーパスは実行時ではなく、コンパイル時に作成されるため、コンパイラはプロパティが存在することおよびプロパティがObjective-Cランタイムへと露出されることを確認できます。
</span><!--end_jpstr-->
</p><p class="para">
  For more information about using selectors in Swift code that interacts with Objective-C APIs, see <a href="../BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID205" data-renderer-version="2" target="_self">Keys and Key Paths</a> in <em class="u-book"><a href="../BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" data-renderer-version="2" target="_self">Using Swift with Cocoa and Objective-C (Swift 3.0.1)</a></em>. For information about key-value coding and key-value observing, see <em class="u-book"><a href="../../../Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i" data-renderer-version="2" target="_self">Key-Value Coding Programming Guide</a></em> and <em class="u-book"><a href="../../../Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" data-renderer-version="1" target="_self">Key-Value Observing Programming Guide</a></em>.
<br><span class="jpstr">
Objective-C APIと相互作用するスウィフトコードにおけるセレクタの使用についてのさらなる情報として、<a href="../BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID205" data-renderer-version="2" target="_self">キーとキーパス</a>を<em class="u-book"><a href="../BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" data-renderer-version="2" target="_self">SwiftをCocoaとObjective-Cと共に使う（Swift 3.0.1）</a></em>で見てください。キー値コーディングとキー値監視についての情報として、<em class="u-book"><a href="../../../Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i" data-renderer-version="2" target="_self">キー値コーディングプログラミングガイド</a></em>（日本語文書）と<em class="u-book"><a href="../../../Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" data-renderer-version="1" target="_self">キー値監視プログラミングガイド</a></em>（日本語文書）を見てください。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_456"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Although the <em>property name</em> is an expression, it is never evaluated.
    	<br><span class="jpstr">
<em>property name（プロパティ名）</em>は式であるけれども、それは決して評価されません。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a key-path expression
<br><span class="jpstr">
キーパス式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/key-path-expression"></a>
  <span class="syntax-def-name">
  key-path-expression
</span>
<span class="arrow">
  →
</span><code class="literal">#keyPath&shy;</code><code class="literal">(&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">)&shy;</code>
</p>
</div>
 </div>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID397"></a>
  <h3 class="section-name" tabindex="0">Postfix Expressions<br><span class="jpstr">
接尾辞表現
</span><!--end_jpstr-->
</h3>
  <p class="para">
  <em>Postfix expressions</em> are formed by applying a postfix operator or other postfix syntax to an expression. Syntactically, every primary expression is also a postfix expression.
<br><span class="jpstr">
<em>接尾辞式</em>は、接尾辞演算子または他の接尾辞構文を式に適用することによって作り上げられます。統語論的に、あらゆる基本式は、また、接尾辞式です。
</span><!--end_jpstr-->
</p><p class="para">
  For information about the behavior of these operators, see <span class="x-name"><a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID60">Basic Operators</a></span> and <span class="x-name"><a href="AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID28" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH27-ID28">Advanced Operators</a></span>.
<br><span class="jpstr">
これらの演算子の挙動に関して詳しくは、<span class="x-name"><a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID60">基本の演算子</a></span>と<span class="x-name"><a href="AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID28" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH27-ID28">先進の演算子</a></span>を見てください。
</span><!--end_jpstr-->
</p><p class="para">
  For information about the operators provided by the Swift standard library, see <em class="u-book"><a href="https://developer.apple.com/reference/swift/1851035-swift_standard_library_operators" class="urlLink" target="_self">Swift Standard Library Operators Reference</a></em>.
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a postfix expression
<br><span class="jpstr">
接尾辞式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/postfix-expression"></a>
  <span class="syntax-def-name">
  postfix-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/primary-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/primary-expression">primary-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_461"></a>
  <span class="syntax-def-name">
  postfix-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/postfix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>&shy;</span><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/postfix-operator" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-operator">postfix-operator</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_462"></a>
  <span class="syntax-def-name">
  postfix-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/function-call-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/function-call-expression">function-call-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_463"></a>
  <span class="syntax-def-name">
  postfix-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/initializer-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/initializer-expression">initializer-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_464"></a>
  <span class="syntax-def-name">
  postfix-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/explicit-member-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/explicit-member-expression">explicit-member-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_465"></a>
  <span class="syntax-def-name">
  postfix-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/postfix-self-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-self-expression">postfix-self-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_466"></a>
  <span class="syntax-def-name">
  postfix-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/dynamic-type-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/dynamic-type-expression">dynamic-type-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_467"></a>
  <span class="syntax-def-name">
  postfix-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/subscript-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/subscript-expression">subscript-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_468"></a>
  <span class="syntax-def-name">
  postfix-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/forced-value-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/forced-value-expression">forced-value-expression</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_469"></a>
  <span class="syntax-def-name">
  postfix-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/optional-chaining-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/optional-chaining-expression">optional-chaining-expression</a>&shy;</span>
</p>
</div>
 </div>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID398"></a>
  <h3 class="section-name" tabindex="0">Function Call Expression<br><span class="jpstr">
関数呼び出し式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A <em>function call expression</em> consists of a function name followed by a comma-separated list of the function’s arguments in parentheses. Function call expressions have the following form:
<br><span class="jpstr">
<em>関数呼び出し式</em>は、関数名の後にその関数の引数のコンマ区切りのリストを丸括弧の中に続けることから成ります。関数呼び出し式は、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><em class="variable-text">function name</em>(<em class="variable-text">argument value 1</em>, <em class="variable-text">argument value 2</em>)</pre></li>
  </ul>
</div><p class="para">
  The <em>function name</em> can be any expression whose value is of a function type.
<br><span class="jpstr">
<em>関数名</em>は、値がその関数型であるどんな式でもかまいません
</span><!--end_jpstr-->
</p><p class="para">
  If the function definition includes names for its parameters, the function call must include names before its argument values separated by a colon (<code class="code-voice">:</code>). This kind of function call expression has the following form:
<br><span class="jpstr">
関数定義がそれのパラメータたちの名前を含むならば、関数呼び出しはそれらの引数値の前にその名前をコロン（<code class="code-voice">:</code>）で区切って含まなければなりません。この種類の関数呼び出し式は、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><em class="variable-text">function name</em>(<em class="variable-text">argument name 1</em>: <em class="variable-text">argument value 1</em>, <em class="variable-text">argument name 2</em>: <em class="variable-text">argument value 2</em>)</pre></li>
  </ul>
</div><p class="para">
  A function call expression can include a trailing closure in the form of a closure expression immediately after the closing parenthesis. The trailing closure is understood as an argument to the function, added after the last parenthesized argument. The following function calls are equivalent:
<br><span class="jpstr">
関数呼び出し式は、終わりの括弧の直後にクロージャ式の形で後付クロージャを含むことができます。後付クロージャは関数に対する引数として理解されます、そして、最後に括弧に入れた引数の後に加えられます。以下の関数呼び出しは、等しいです：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="c">// someFunction takes an integer and a closure as its arguments&nbsp;<span class="jpstr">（someFunctionは、その引数として整数とクロージャをとります）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="vc">someFunction</span>(<span class="vc">x</span>: <span class="vc">x</span>, <span class="vc">f</span>: {<span class="vc">$0</span> == <span class="m">13</span>})</code></li>
            <li><code class="code-voice"><span class="vc">someFunction</span>(<span class="vc">x</span>: <span class="vc">x</span>) {<span class="vc">$0</span> == <span class="m">13</span>}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If the trailing closure is the function’s only argument, the parentheses can be omitted.
<br><span class="jpstr">
後付クロージャが関数のただ一つの引数であるならば、括弧は省略されることができます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="c">// someFunction takes a closure as its only argument&nbsp;<span class="jpstr">（someFunctionは、そのただ一つの引数としてクロージャをとります）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="vc">myData</span>.<span class="vc">someMethod</span>() {<span class="vc">$0</span> == <span class="m">13</span>}</code></li>
            <li><code class="code-voice"><span class="vc">myData</span>.<span class="vc">someMethod</span> {<span class="vc">$0</span> == <span class="m">13</span>}</code></li>
        </ol>
      </div>
  </div>
</section><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a function call expression
<br><span class="jpstr">
関数呼び出し式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/function-call-expression"></a>
  <span class="syntax-def-name">
  function-call-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/postfix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>&shy;</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/function-call-argument-clause" data-renderer-version="2" data-id="//apple_ref/swift/grammar/function-call-argument-clause">function-call-argument-clause</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_472"></a>
  <span class="syntax-def-name">
  function-call-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/postfix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>&shy;</span><span class="optional"><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/function-call-argument-clause" data-renderer-version="2" data-id="//apple_ref/swift/grammar/function-call-argument-clause">function-call-argument-clause</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/trailing-closure" data-renderer-version="2" data-id="//apple_ref/swift/grammar/trailing-closure">trailing-closure</a>&shy;</span>
</p>
</div><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/function-call-argument-clause"></a>
  <span class="syntax-def-name">
  function-call-argument-clause
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <code class="literal">(&shy;</code><code class="literal">)&shy;</code>
</span><span class="alternative">
  <code class="literal">(&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/function-call-argument-list" data-renderer-version="2" data-id="//apple_ref/swift/grammar/function-call-argument-list">function-call-argument-list</a>&shy;</span><code class="literal">)&shy;</code>
</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/function-call-argument-list"></a>
  <span class="syntax-def-name">
  function-call-argument-list
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/function-call-argument" data-renderer-version="2" data-id="//apple_ref/swift/grammar/function-call-argument">function-call-argument</a>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/function-call-argument" data-renderer-version="2" data-id="//apple_ref/swift/grammar/function-call-argument">function-call-argument</a>&shy;</span><code class="literal">,&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/function-call-argument-list" data-renderer-version="2" data-id="//apple_ref/swift/grammar/function-call-argument-list">function-call-argument-list</a>&shy;</span>
</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/function-call-argument"></a>
  <span class="syntax-def-name">
  function-call-argument
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/identifier" data-renderer-version="2" data-id="//apple_ref/swift/grammar/identifier">identifier</a>&shy;</span><code class="literal">:&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span>
</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_476"></a>
  <span class="syntax-def-name">
  function-call-argument
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/operator" data-renderer-version="2" data-id="//apple_ref/swift/grammar/operator">operator</a>&shy;</span>
</span><span class="alternative">
  <span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/identifier" data-renderer-version="2" data-id="//apple_ref/swift/grammar/identifier">identifier</a>&shy;</span><code class="literal">:&shy;</code><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/operator" data-renderer-version="2" data-id="//apple_ref/swift/grammar/operator">operator</a>&shy;</span>
</span>
</p>
</div><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/trailing-closure"></a>
  <span class="syntax-def-name">
  trailing-closure
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/closure-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/closure-expression">closure-expression</a>&shy;</span>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID399"></a>
  <h3 class="section-name" tabindex="0">Initializer Expression<br><span class="jpstr">
イニシャライザ式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  An <em>initializer expression</em> provides access to a type’s initializer. It has the following form:
<br><span class="jpstr">
あなたはまた、スーパークラスのイニシャライザに委任するために、<em>イニシャライザ式</em>を使います。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><em class="variable-text">expression</em>.<span class="kt">init</span>(<em class="variable-text">initializer arguments</em>)</pre></li>
  </ul>
</div><p class="para">
  You use the initializer expression in a function call expression to initialize a new instance of a type. You also use an initializer expression to delegate to the initializer of a superclass.
<br><span class="jpstr">
あなたは、イニシャライザ式を関数呼び出し式において使うことで、ある型の新しいインスタンスを初期化します。あなたはまた、スーパークラスのイニシャライザに委任するために、イニシャライザ式を使います。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">SomeSubClass</span>: <span class="n"><!-- a href="" -->SomeSuperClass<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">override</span> <span class="kt">init</span>() {</code></li>
            <li><code class="code-voice">        <span class="c">// subclass initialization goes here&nbsp;<span class="jpstr">（サブクラスの初期化が、ここにきます）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">        <span class="kt">super</span>.<span class="kt">init</span>()</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Like a function, an initializer can be used as a value. For example:
<br><span class="jpstr">
関数のように、イニシャライザは値として使われることができます。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="c">// Type annotation is required because String has multiple initializers.&nbsp;<span class="jpstr">（型注釈は必須です、なぜならStringは複数のイニシャライザを持つからです）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">initializer</span>: (<span class="n"><!-- a href="" -->Int<!-- /a --></span>) -&gt; <span class="n"><!-- a href="" -->String<!-- /a --></span> = <span class="vc">String</span>.<span class="kt">init</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">oneTwoThree</span> = [<span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>].<span class="vc">map</span>(<span class="vc">initializer</span>).<span class="vc">reduce</span>(<span class="s">&quot;&quot;</span>, +)</code></li>
            <li><code class="code-voice"><span class="vc">print</span>(<span class="vc">oneTwoThree</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;123&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If you specify a type by name, you can access the type’s initializer without using an initializer expression. In all other cases, you must use an initializer expression.
<br><span class="jpstr">
あなたがある型を名前で指定するならば、あなたはその型のイニシャライザにイニシャライザ式を使うことなくアクセスすることができます。すべての他の場合では、あなたはイニシャライザ式を使う必要があります。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">s1</span> = <span class="vc">SomeType</span>.<span class="kt">init</span>(<span class="vc">data</span>: <span class="m">3</span>)  <span class="c">// Valid</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">s2</span> = <span class="vc">SomeType</span>(<span class="vc">data</span>: <span class="m">1</span>)       <span class="c">// Also valid</span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">s3</span> = <span class="vc">type</span>(<span class="vc">of</span>: <span class="vc">someValue</span>).<span class="kt">init</span>(<span class="vc">data</span>: <span class="m">7</span>)  <span class="c">// Valid</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">s4</span> = <span class="vc">type</span>(<span class="vc">of</span>: <span class="vc">someValue</span>)(<span class="vc">data</span>: <span class="m">5</span>)       <span class="c">// Error</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of an initializer expression
<br><span class="jpstr">
イニシャライザ式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/initializer-expression"></a>
  <span class="syntax-def-name">
  initializer-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/postfix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>&shy;</span><code class="literal">.&shy;</code><code class="literal">init&shy;</code>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_480"></a>
  <span class="syntax-def-name">
  initializer-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/postfix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>&shy;</span><code class="literal">.&shy;</code><code class="literal">init&shy;</code><code class="literal">(&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/argument-names" data-renderer-version="2" data-id="//apple_ref/swift/grammar/argument-names">argument-names</a>&shy;</span><code class="literal">)&shy;</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID400"></a>
  <h3 class="section-name" tabindex="0">Explicit Member Expression<br><span class="jpstr">
明示的メンバー式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  An <em>explicit member expression</em> allows access to the members of a named type, a tuple, or a module. It consists of a period (<code class="code-voice">.</code>) between the item and the identifier of its member.
<br><span class="jpstr">
<em>明示的メンバー式</em>は、名前付きの型、タプル、またはモジュールのメンバーに対するアクセスを可能にします。それは、その項目とそれのメンバーの識別子の間のピリオド（<code class="code-voice">.</code>）から成ります。
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><em class="variable-text">expression</em>.<em class="variable-text">member name</em></pre></li>
  </ul>
</div><p class="para">
  The members of a named type are named as part of the type’s declaration or extension. For example:
<br><span class="jpstr">
名前付きの型に属するメンバーは、型の宣言または拡張の一部として命名されます。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">SomeClass</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">someProperty</span> = <span class="m">42</span></code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">c</span> = <span class="vc">SomeClass</span>()</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">y</span> = <span class="vc">c</span>.<span class="vc">someProperty</span>  <span class="c">// Member access</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The members of a tuple are implicitly named using integers in the order they appear, starting from zero. For example:
<br><span class="jpstr">
タプルのメンバーは、整数を使って、それらが現れる順序で、ゼロから始めて、暗黙のうちに名前をつけられます。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">t</span> = (<span class="m">10</span>, <span class="m">20</span>, <span class="m">30</span>)</code></li>
            <li><code class="code-voice"><span class="vc">t</span>.<span class="m">0</span> = <span class="vc">t</span>.<span class="m">1</span></code></li>
            <li><code class="code-voice"><span class="c">// Now t is (20, 20, 30)&nbsp;<span class="jpstr">（tは、現在 (20, 20, 30)です）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The members of a module access the top-level declarations of that module.
<br><span class="jpstr">
モジュールのメンバーは、そのモジュールのトップレベルの宣言にアクセスします。
</span><!--end_jpstr-->
</p><p class="para">
  To distinguish between methods or initializers whose names differ only by the names of their arguments, include the argument names in parentheses, with each argument name followed by a colon (<code class="code-voice">:</code>). Write an underscore (<code class="code-voice">_</code>) for an argument with no name. To distinguish between overloaded methods, use a type annotation. For example:
<br><span class="jpstr">
名前がそれらの引数の名前でだけ異なるものであるメソッド間またはイニシャライザ間で識別を行うために、丸括弧の中に引数名を、各引数名にコロン（<code class="code-voice">:</code>）を続けることで含めて下さい。名前のない引数に対しては１つのアンダースコア（<code class="code-voice">_</code>）を書いてください。オーバーロードされたメソッド間で識別を行うには、型注釈を使ってください。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">SomeClass</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">func</span> <span class="vc">someMethod</span>(<span class="vc">x</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>, <span class="vc">y</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>) {}</code></li>
            <li><code class="code-voice">    <span class="kt">func</span> <span class="vc">someMethod</span>(<span class="vc">x</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>, <span class="vc">z</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>) {}</code></li>
            <li><code class="code-voice">    <span class="kt">func</span> <span class="vc">overloadedMethod</span>(<span class="vc">x</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>, <span class="vc">y</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>) {}</code></li>
            <li><code class="code-voice">    <span class="kt">func</span> <span class="vc">overloadedMethod</span>(<span class="vc">x</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>, <span class="vc">y</span>: <span class="n"><!-- a href="" -->Bool<!-- /a --></span>) {}</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">instance</span> = <span class="vc">SomeClass</span>()</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">a</span> = <span class="vc">instance</span>.<span class="vc">someMethod</span>              <span class="c">// Ambiguous&nbsp;<span class="jpstr"><span class="c">（あいまい）</span></span><!--end_jpstr--></span>
</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">b</span> = <span class="vc">instance</span>.<span class="vc">someMethod</span>(<span class="vc">x</span>:<span class="vc">y</span>:)        <span class="c">// Unambiguous&nbsp;<span class="jpstr"><span class="c">（あいまいさ無し）</span></span><!--end_jpstr--></span>
</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">d</span> = <span class="vc">instance</span>.<span class="vc">overloadedMethod</span>        <span class="c">// Ambiguous&nbsp;<span class="jpstr"><span class="c">（あいまい）</span></span><!--end_jpstr--></span>
</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">d</span> = <span class="vc">instance</span>.<span class="vc">overloadedMethod</span>(<span class="vc">x</span>:<span class="vc">y</span>:)  <span class="c">// Still ambiguous&nbsp;<span class="jpstr"><span class="c">（依然あいまい）</span></span><!--end_jpstr--></span>
</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">d</span>: (<span class="n"><!-- a href="" -->Int<!-- /a --></span>, <span class="n"><!-- a href="" -->Bool<!-- /a --></span>) -&gt; <span class="n"><!-- a href="" -->Void<!-- /a --></span>  = <span class="vc">instance</span>.<span class="vc">overloadedMethod</span>(<span class="vc">x</span>:<span class="vc">y</span>:)  <span class="c">// Unambiguous</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If a period appears at the beginning of a line, it is understood as part of an explicit member expression, not as an implicit member expression. For example, the following listing shows chained method calls split over several lines:
<br><span class="jpstr">
ピリオドがある行の初めに現れたならば、それはある明示的なメンバー式の一部として理解されます、ひとつの明示的なメンバー式としてではなく。例えば、以下のコード出力は、連結されたメソッド呼び出しがいくつかの行に分けられるのを示します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">x</span> = [<span class="m">10</span>, <span class="m">3</span>, <span class="m">20</span>, <span class="m">15</span>, <span class="m">4</span>]</code></li>
            <li><code class="code-voice">    .<span class="vc">sorted</span>()</code></li>
            <li><code class="code-voice">    .<span class="vc">filter</span> { <span class="vc">$0</span> &gt; <span class="m">5</span> }</code></li>
            <li><code class="code-voice">    .<span class="vc">map</span> { <span class="vc">$0</span> * <span class="m">100</span> }</code></li>
        </ol>
      </div>
  </div>
</section><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of an explicit member expression
<br><span class="jpstr">
明示的メンバー式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/explicit-member-expression"></a>
  <span class="syntax-def-name">
  explicit-member-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/postfix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>&shy;</span><code class="literal">.&shy;</code><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/decimal-digits" data-renderer-version="2" data-id="//apple_ref/swift/grammar/decimal-digits">decimal-digits</a>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_483"></a>
  <span class="syntax-def-name">
  explicit-member-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/postfix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>&shy;</span><code class="literal">.&shy;</code><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/identifier" data-renderer-version="2" data-id="//apple_ref/swift/grammar/identifier">identifier</a>&shy;</span><span class="optional"><span class="syntactic-cat"><a href="GenericParametersAndArguments.html#//apple_ref/swift/grammar/generic-argument-clause" data-renderer-version="2" data-id="//apple_ref/swift/grammar/generic-argument-clause">generic-argument-clause</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-NoLink_484"></a>
  <span class="syntax-def-name">
  explicit-member-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/postfix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>&shy;</span><code class="literal">.&shy;</code><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/identifier" data-renderer-version="2" data-id="//apple_ref/swift/grammar/identifier">identifier</a>&shy;</span><code class="literal">(&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/argument-names" data-renderer-version="2" data-id="//apple_ref/swift/grammar/argument-names">argument-names</a>&shy;</span><code class="literal">)&shy;</code>
</p>
</div><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/argument-names"></a>
  <span class="syntax-def-name">
  argument-names
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/argument-name" data-renderer-version="2" data-id="//apple_ref/swift/grammar/argument-name">argument-name</a>&shy;</span><span class="optional"><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/argument-names" data-renderer-version="2" data-id="//apple_ref/swift/grammar/argument-names">argument-names</a>&shy;</span><sub class="subscript">opt</sub>&shy;</span>
</p><p class="syntax-def">
  <a name="//apple_ref/swift/grammar/argument-name"></a>
  <span class="syntax-def-name">
  argument-name
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="LexicalStructure.html#//apple_ref/swift/grammar/identifier" data-renderer-version="2" data-id="//apple_ref/swift/grammar/identifier">identifier</a>&shy;</span><code class="literal">:&shy;</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID401"></a>
  <h3 class="section-name" tabindex="0">Postfix Self Expression<br><span class="jpstr">
接尾辞self式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A postfix <code class="code-voice">self</code> expression consists of an expression or the name of a type, immediately followed by <code class="code-voice">.self</code>. It has the following forms:
<br><span class="jpstr">
接尾辞<code class="code-voice">self</code>式は、ある式または型の名前と、それに直ちに続く<code class="code-voice">.self</code>から成ります。それは、以下の各形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><em class="variable-text">expression</em>.<span class="kt">self</span></pre></li><li><pre class="code-voice"><em class="variable-text">type</em>.<span class="kt">self</span></pre></li>
  </ul>
</div><p class="para">
  The first form evaluates to the value of the <em>expression</em>. For example, <code class="code-voice">x.self</code> evaluates to <code class="code-voice">x</code>.
<br><span class="jpstr">
最初の形式は、<em>式</em>の値に評価されます。例えば、<code class="code-voice">x.self</code>は<code class="code-voice">x</code>に評価されます。
</span><!--end_jpstr-->
</p><p class="para">
  The second form evaluates to the value of the <em>type</em>. Use this form to access a type as a value. For example, because <code class="code-voice">SomeClass.self</code> evaluates to the <code class="code-voice">SomeClass</code> type itself, you can pass it to a function or method that accepts a type-level argument.
<br><span class="jpstr">
第二の形式は、<em>型</em>の値に評価されます。値として型にアクセスするために、この形式を使ってください。例えば、<code class="code-voice">SomeClass.self</code>は<code class="code-voice">SomeClass</code>型それ自体に評価されるので、あなたはそれを型レベルの引数を受け入れる関数またはメソッドへ渡すことができます。
</span><!--end_jpstr-->
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a self expression
<br><span class="jpstr">
self式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/postfix-self-expression"></a>
  <span class="syntax-def-name">
  postfix-self-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/postfix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>&shy;</span><code class="literal">.&shy;</code><code class="literal">self&shy;</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID402"></a>
  <h3 class="section-name" tabindex="0">Dynamic Type Expression<br><span class="jpstr">
動的型式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A <em>dynamic type expression</em> consists of an expression within special syntax that resembles a <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH32-ID398" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH32-ID398">Function Call Expression</a></span>. It has the following form:
<br><span class="jpstr">
<em>動的型式</em>は、<span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH32-ID398" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH32-ID398">関数呼び出し式</a></span>に類似した特別な構文内のある式から成ります。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><span class="vc">type</span>(<span class="vc">of</span>: <em class="variable-text">expression</em>)</pre></li>
  </ul>
</div><p class="para">
  The <em>expression</em> can’t be the name of a type. The entire <code class="code-voice">type(of:)</code> expression evaluates to the value of the runtime type of the <em>expression</em>, as the following example shows:
<br><span class="jpstr">
<em>式</em>は、型の名前であることはできません。以下の例が示すように、<code class="code-voice">type(of:)</code>式の全体は、<em>expression（式）</em>の実行時型の値に評価されます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">SomeBaseClass</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">class</span> <span class="kt">func</span> <span class="vc">printClassName</span>() {</code></li>
            <li><code class="code-voice">        <span class="vc">print</span>(<span class="s">&quot;SomeBaseClass&quot;</span>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">SomeSubClass</span>: <span class="n"><!-- a href="" -->SomeBaseClass<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">override</span> <span class="kt">class</span> <span class="kt">func</span> <span class="vc">printClassName</span>() {</code></li>
            <li><code class="code-voice">        <span class="vc">print</span>(<span class="s">&quot;SomeSubClass&quot;</span>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">someInstance</span>: <span class="n"><!-- a href="" -->SomeBaseClass<!-- /a --></span> = <span class="vc">SomeSubClass</span>()</code></li>
            <li><code class="code-voice"><span class="c">// someInstance has a static type of SomeBaseClass at compile time, and&nbsp;<span class="jpstr">（someInstanceは、コンパイル時ではSomeBaseClassの静的型を持ちます、そして）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="c">// it has a dynamic type of SomeSubClass at runtime&nbsp;<span class="jpstr">（実行時ではそれは動的型のSomeSubClassを持ちます）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="vc">type</span>(<span class="vc">of</span>: <span class="vc">someInstance</span>).<span class="vc">printClassName</span>()</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;SomeSubClass&quot;&nbsp;<span class="jpstr">（「 SomeSubClass 」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a dynamic type expression
<br><span class="jpstr">
動的型式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/dynamic-type-expression"></a>
  <span class="syntax-def-name">
  dynamic-type-expression
</span>
<span class="arrow">
  →
</span><code class="literal">type&shy;</code><code class="literal">(&shy;</code><code class="literal">of&shy;</code><code class="literal">:&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression">expression</a>&shy;</span><code class="literal">)&shy;</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID403"></a>
  <h3 class="section-name" tabindex="0">Subscript Expression<br><span class="jpstr">
添え字式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A <em>subscript expression</em> provides subscript access using the getter and setter of the corresponding subscript declaration. It has the following form:
<br><span class="jpstr">
<em>添え字式</em>は、対応する添え字宣言のゲッターとセッターを使用して、添え字アクセスを提供します。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><em class="variable-text">expression</em>[<em class="variable-text">index expressions</em>]</pre></li>
  </ul>
</div><p class="para">
  To evaluate the value of a subscript expression, the subscript getter for the <em>expression</em>’s type is called with the <em>index expressions</em> passed as the subscript parameters. To set its value, the subscript setter is called in the same way.
<br><span class="jpstr">
添え字式の値を評価するために、この<em>式</em>のもつ型のための添え字ゲッターが、添え字パラメータとして渡される<em>インデックス式</em>を使って呼び出されます。その値を設定するために、添え字セッターが同様に呼ばれます。
</span><!--end_jpstr-->
</p><p class="para">
  For information about subscript declarations, see <span class="x-name"><a href="Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID373" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH34-ID373">Protocol Subscript Declaration</a></span>.
<br><span class="jpstr">
添え字宣言に関して詳しくは、<span class="x-name"><a href="Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID373" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH34-ID373">プロトコル添え字宣言</a></span>を見てください。
</span><!--end_jpstr-->
</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a subscript expression
<br><span class="jpstr">
添え字式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/subscript-expression"></a>
  <span class="syntax-def-name">
  subscript-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/postfix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>&shy;</span><code class="literal">[&shy;</code><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/expression-list" data-renderer-version="2" data-id="//apple_ref/swift/grammar/expression-list">expression-list</a>&shy;</span><code class="literal">]&shy;</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID404"></a>
  <h3 class="section-name" tabindex="0">Forced-Value Expression<br><span class="jpstr">
強制された値式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A <em>forced-value expression</em> unwraps an optional value that you are certain is not <code class="code-voice">nil</code>. It has the following form:
<br><span class="jpstr">
<em>強制された値式</em>は、あなたが<code class="code-voice">nilで</code>ないことを確信しているオプショナルの値をアンラップします。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><em class="variable-text">expression</em>!</pre></li>
  </ul>
</div><p class="para">
  If the value of the <em>expression</em> is not <code class="code-voice">nil</code>, the optional value is unwrapped and returned with the corresponding nonoptional type. Otherwise, a runtime error is raised.
<br><span class="jpstr">
<em>式</em>の値が<code class="code-voice">nil</code>でないならば、オプショナルの値は包装を取られて、対応する非オプショナル型で返されます。そうでなければ、実行時エラーが引き起こされます。
</span><!--end_jpstr-->
</p><p class="para">
  The unwrapped value of a forced-value expression can be modified, either by mutating the value itself, or by assigning to one of the value’s members. For example:
<br><span class="jpstr">
強制された値式のアンラップされた値は、値それ自体を変化させることによって、またはその値のメンバーの１つに代入することによってのどちらでも、修正されることができます。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">x</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>? = <span class="m">0</span></code></li>
            <li><code class="code-voice"><span class="vc">x</span>! += <span class="m">1</span></code></li>
            <li><code class="code-voice"><span class="c">// x is now 1</span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">someDictionary</span> = [<span class="s">&quot;a&quot;</span>: [<span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>], <span class="s">&quot;b&quot;</span>: [<span class="m">10</span>, <span class="m">20</span>]]</code></li>
            <li><code class="code-voice"><span class="vc">someDictionary</span>[<span class="s">&quot;a&quot;</span>]![<span class="m">0</span>] = <span class="m">100</span></code></li>
            <li><code class="code-voice"><span class="c">// someDictionary is now [&quot;b&quot;: [10, 20], &quot;a&quot;: [100, 2, 3]]&nbsp;<span class="jpstr">（someDictionaryは、現在["b": [10, 20], "a": [100, 2, 3]]です）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a forced-value expression
<br><span class="jpstr">
強制された値の式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/forced-value-expression"></a>
  <span class="syntax-def-name">
  forced-value-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/postfix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>&shy;</span><code class="literal">!&shy;</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH32-ID405"></a>
  <h3 class="section-name" tabindex="0">Optional-Chaining Expression<br><span class="jpstr">
オプショナル連鎖式
</span><!--end_jpstr-->
</h3>
  <p class="para">
  An <em>optional-chaining expression</em> provides a simplified syntax for using optional values in postfix expressions. It has the following form:
<br><span class="jpstr">
<em>オプショナル連鎖式</em>は、オプショナルの値を使うために単純化された構文を接尾辞式において提供します。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><em class="variable-text">expression</em>?</pre></li>
  </ul>
</div><p class="para">
  The postfix <code class="code-voice">?</code> operator makes an optional-chaining expression from an expression without changing the expression’s value.
<br><span class="jpstr">
接尾辞<code class="code-voice">?</code>演算子は、オプショナル連鎖式をある式から、その式の値を変更することなく作ります。
</span><!--end_jpstr-->
</p><p class="para">
  Optional-chaining expressions must appear within a postfix expression, and they cause the postfix expression to be evaluated in a special way. If the value of the optional-chaining expression is <code class="code-voice">nil</code>, all of the other operations in the postfix expression are ignored and the entire postfix expression evaluates to <code class="code-voice">nil</code>. If the value of the optional-chaining expression is not <code class="code-voice">nil</code>, the value of the optional-chaining expression is unwrapped and used to evaluate the rest of the postfix expression. In either case, the value of the postfix expression is still of an optional type.
<br><span class="jpstr">
オプショナル連鎖式は、接尾辞式の中に現れなければなりません、そしてそれはその接尾辞式を特別なやり方で評価されるようにします。オプショナル連鎖式の値が<code class="code-voice">nil</code>ならば、接尾辞式での他の演算の全ては無視されます、そして接尾辞式の全体は<code class="code-voice">nil</code>に評価されます。オプショナル連鎖式の値が<code class="code-voice">nil</code>でないならば、オプショナル連鎖式の値はアンラップされて、接尾辞式の残りを評価するために使われます。いずれにせよ、接尾辞式の値は、依然としてオプショナル型です。
</span><!--end_jpstr-->
</p><p class="para">
  If a postfix expression that contains an optional-chaining expression is nested inside other postfix expressions, only the outermost expression returns an optional type. In the example below, when <code class="code-voice">c</code> is not <code class="code-voice">nil</code>, its value is unwrapped and used to evaluate <code class="code-voice">.property</code>, the value of which is used to evaluate <code class="code-voice">.performAction()</code>. The entire expression <code class="code-voice">c?.property.performAction()</code> has a value of an optional type.
<br><span class="jpstr">
オプショナル連鎖式を含む接尾辞式が、他の接尾辞式の内部に入れ子にされるならば、最も外部の式だけがオプショナル型を返します。下記の例で、<code class="code-voice">c</code>が<code class="code-voice">nil</code>でないとき、その値はアンラップされて<code class="code-voice">.property</code>を評価するために使われ、その値が<code class="code-voice">.performAction()</code>を評価するために使われます。式<code class="code-voice">c?.property.performAction()</code>の全体がオプショナル型の値を持ちます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">c</span>: <span class="n"><!-- a href="" -->SomeClass<!-- /a --></span>?</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">result</span>: <span class="n"><!-- a href="" -->Bool<!-- /a --></span>? = <span class="vc">c</span>?.<span class="vc">property</span>.<span class="vc">performAction</span>()</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The following example shows the behavior of the example above without using optional chaining.
<br><span class="jpstr">
以下の例は、オプショナル連鎖を使うことなく上の例の挙動を示します。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">result</span>: <span class="n"><!-- a href="" -->Bool<!-- /a --></span>? = <span class="kt">nil</span></code></li>
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">unwrappedC</span> = <span class="vc">c</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">result</span> = <span class="vc">unwrappedC</span>.<span class="vc">property</span>.<span class="vc">performAction</span>()</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The unwrapped value of an optional-chaining expression can be modified, either by mutating the value itself, or by assigning to one of the value’s members. If the value of the optional-chaining expression is <code class="code-voice">nil</code>, the expression on the right hand side of the assignment operator is not evaluated. For example:
<br><span class="jpstr">
オプショナル連鎖のアンラップされた値は、その値自体を変化させることによって、またはその値のメンバーの１つに値に代入することによってのどちらでも修正されることができます。オプショナル連鎖式の値が<code class="code-voice">nil</code>ならば、代入演算子の右手側の式は評価されません。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">someFunctionWithSideEffects</span>() -&gt; <span class="n"><!-- a href="" -->Int<!-- /a --></span> {</code></li>
            <li><code class="code-voice">    <span class="kt">return</span> <span class="m">42</span>  <span class="c">// No actual side effects.&nbsp;<span class="jpstr"><span class="c">（実際の副作用なし）</span></span><!--end_jpstr--></span>
</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">someDictionary</span> = [<span class="s">&quot;a&quot;</span>: [<span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>], <span class="s">&quot;b&quot;</span>: [<span class="m">10</span>, <span class="m">20</span>]]</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">someDictionary</span>[<span class="s">&quot;not here&quot;</span>]?[<span class="m">0</span>] = <span class="vc">someFunctionWithSideEffects</span>()</code></li>
            <li><code class="code-voice"><span class="c">// someFunctionWithSideEffects is not evaluated&nbsp;<span class="jpstr">（someFunctionWithSideEffectsは、評価されません。）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="c">// someDictionary is still [&quot;b&quot;: [10, 20], &quot;a&quot;: [1, 2, 3]]&nbsp;<span class="jpstr">（someDictionaryは、依然として["b": [10, 20], "a": [1, 2, 3]]です）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">someDictionary</span>[<span class="s">&quot;a&quot;</span>]?[<span class="m">0</span>] = <span class="vc">someFunctionWithSideEffects</span>()</code></li>
            <li><code class="code-voice"><span class="c">// someFunctionWithSideEffects is evaluated and returns 42&nbsp;<span class="jpstr">（someFunctionWithSideEffectsは、評価されて42を返します）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="c">// someDictionary is now [&quot;b&quot;: [10, 20], &quot;a&quot;: [42, 2, 3]]&nbsp;<span class="jpstr">（someDictionaryは、現在["b": [10, 20], "a": [42, 2, 3]]です）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of an optional-chaining expression
<br><span class="jpstr">
オプショナル連鎖式の文法
</span><!--end_jpstr-->
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a name="//apple_ref/swift/grammar/optional-chaining-expression"></a>
  <span class="syntax-def-name">
  optional-chaining-expression
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a href="#//apple_ref/swift/grammar/postfix-expression" data-renderer-version="2" data-id="//apple_ref/swift/grammar/postfix-expression">postfix-expression</a>&shy;</span><code class="literal">?&shy;</code>
</p>
</div>
 </div>
  
</section>

</section>

  	
 	<section id="next_previous" class="">
    		<p class="previous-link"><a href="Types.html#//apple_ref/doc/uid/TP40014097-CH31-ID445" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH31-ID445">Types<br><span class="jpstr">
型
</span><!--end_jpstr-->
</a></p>
  			<p class="next-link"><a href="Statements.html#//apple_ref/doc/uid/TP40014097-CH33-ID428" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH33-ID428">Statements<br><span class="jpstr">
文
</span><!--end_jpstr-->
</a></p>

    <p class="copyright">Copyright &#x00a9; 2016 Apple Inc. All rights reserved. 
  <a class="link" href="http://www.apple.com/legal/terms/site.html" target="_blank" rel="external">Terms of Use</a> | 
  <a class="link" href="http://www.apple.com/privacy/" target="_blank" rel="external">Privacy Policy</a> | 
  Updated: 2016-10-27
</p>
  </section>
</article>

    </div>
    <div id='big_button'></div>
    <footer id="footer">
  <div class="content-wrapper">
  	<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
  </div>
  <script src="../../../../Resources/1254/JavaScript/devpubs-1.6.3.js" type="text/javascript" charset="utf-8"></script>
  <script src="../../../../Resources/1254/JavaScript/feedback-1.6.3.js" type="text/javascript" charset="utf-8"></script>
  <div id="_omniture_top">
<!-- SiteCatalyst code version: H.8. Copyright 1997-2006 Omniture, Inc. -->
<script type="text/javascript">
/* RSID: */
var s_account="appleglobal,appleusdeveloper,dappdeveloperlib"
</script>

<!-- <script type="text/javascript" src="https://www.apple.com/metrics/scripts/s_code_h.js"></script> -->
<script type="text/javascript">
s.pageName=AC.Tracking.pageName();
s.channel="www.us.developer"

/************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
var s_code=s.t();if(s_code)document.write(s_code)</script>
<!-- End SiteCatalyst code version: H.8. -->
</div>

</footer>

    
  </body>
    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="https://developer.apple.com/bugreporter/" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

</div>
</html>
