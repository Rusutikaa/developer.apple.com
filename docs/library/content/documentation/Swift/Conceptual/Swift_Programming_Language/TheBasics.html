<!DOCTYPE html>
<html lang="en">
  <head>  
  <title>The Swift Programming Language (Swift 4): The Basics</title>
  <link rel="stylesheet" type="text/css" href="../../../../Resources/1264/CSS/style-1.6.3.css" />
  <link rel="stylesheet" type="text/css" href="../../../../Resources/1264/CSS/feedback-1.6.3.css" />
  <meta charset='utf-8'> 
<meta id="j-version" name="j-version" content="" />
<meta id="build" name="build" content="0c869c990fa765914a9edf9866da5f1b" />
<meta id="document-version" name="document-version" content="10.0.10" />
<meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Topic/Swift}" />
<meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/TP40014097" />
<meta id="chapterId" name="chapterId" content="TP40014097-CH5">
<meta id="book-title" name="book-title" content="The Swift Programming Language (Swift 4)" />
<meta id="book-resource-type" name="book-resource-type" content="Guide" />
<meta id="book-root" name="book-root" content="./" />
<meta id="book-json" name="book-json" content="book.json">
<meta id="date" name="date" content="2017-08-21" />
<meta id="description" name="description" content="The definitive guide to Swift, Apple’s programming language for building iOS, macOS, watchOS, and tvOS apps." />
<meta id="IndexTitle" name="IndexTitle" content="" />
<meta id="resources-uri" name="resources-uri" content="../../../../Resources/1264">
<link id="book-index-page" rel="Start" title="" type="text/html" href="./index.html">
<!-- , next_chapter: next_chapter, previous_chapter: previous_chapter -->
<link id="next-page" rel="Next" type="text/html" href="">
<link id="previous-page" rel="Prev" type="text/html" href="">
<meta id="devcenter" name="devcenter" content="<!-- DEVCENTER_NAME -->" />
<meta id="devcenter-url" name="devcenter-url" content="<!-- DEVCENTER_URL -->" />
<meta id="reflib" name="reflib" content="<!-- REFLIB_NAME -->" />

<meta id="xcode-display" name="xcode-display" content="render" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<meta id="platforms" name="platforms" content="Xcode Developer Tools">
</head>

  <body id="conceptual_flow_with_tasks" class="jazz">
    
    <header id="ios_header" class="hideOnPrint hideInXcode">
  <div class="content-wrapper">
    <p class="header-text">
    	<a href="../../../../navigation/index.html">Guides and Sample Code
 		</a>
 </p>
    <p id="wwdr"><img id="apple_logo" src="../../../../Resources/1264/Images/apple2.png" height="14px" width="12px" aria-hidden="true" /><a href="https://developer.apple.com">Developer</a></p>
  </div>
</header>

    <section id="valence">
  <div class="content-wrapper">
    <p id="hierarchial_navigation">
      <span id="book_title">The Swift Programming Language (Swift 4)</span>
    </p>
    <form id="search" class="hideInXcode" method="get" action="/search/index.php" accept-charset="utf-8" autocomplete="off">
  <input type="search" id="ssi_SearchField" placeholder="Search Guides and Sample Code" name="q" autocomplete="off" tabindex="2" />
</form>

      
   
   




    <span class="download-text hideInXcode">
      <a href="https://itunes.apple.com/us/book/the-swift-programming-language/id1002622538?mt=11">iBooks</a>
    </span>

    

    <img id="shortstack" src="../../../../Resources/1264/Images/shortstack_2x.png"/>
  </div>
</section>
    <div class="content-wrapper">
      <nav id="navigator" class="book-parts hideInXcode" role="navigation">
    <ul class="nav-parts">
        <li data-id="//apple_ref/doc/uid/TP40014097-CH1-ID2"
            class="part-name">
            <a href="index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH3-ID0">Welcome to Swift<br><span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH3-ID0">About Swift<br><span class="jpstr">
スウィフトについて
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Compatibility.html#//apple_ref/doc/uid/TP40014097-CH45-ID561" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH45-ID561">Version Compatibility<br><span class="jpstr">
バージョン互換性
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-ID1" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH2-ID1">A Swift Tour<br><span class="jpstr">
スウィフトツアー
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014097-CH4-ID233"
            class="part-name nav-part-active open-part">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID309" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID309">Language Guide<br><span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter nav-current-chapter">
              	<a href="#//apple_ref/doc/uid/TP40014097-CH5-ID309" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID309">The Basics<br><span class="jpstr">
基本
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID60">Basic Operators<br><span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID285" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH7-ID285">Strings and Characters<br><span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-ID105" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH8-ID105">Collection Types<br><span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH9-ID120">Control Flow<br><span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH10-ID158">Functions<br><span class="jpstr">
関数
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH11-ID94">Closures<br><span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH12-ID145">Enumerations<br><span class="jpstr">
列挙
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID82" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH13-ID82">Classes and Structures<br><span class="jpstr">
クラスと構造体
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH14-ID254">Properties<br><span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID234" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH15-ID234">Methods<br><span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Subscripts.html#//apple_ref/doc/uid/TP40014097-CH16-ID305" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH16-ID305">Subscripts<br><span class="jpstr">
添え字
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-ID193" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH17-ID193">Inheritance<br><span class="jpstr">
継承
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH18-ID203">Initialization<br><span class="jpstr">
初期化
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Deinitialization.html#//apple_ref/doc/uid/TP40014097-CH19-ID142" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH19-ID142">Deinitialization<br><span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID48" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH20-ID48">Automatic Reference Counting<br><span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH21-ID245">Optional Chaining<br><span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH42-ID508">Error Handling<br><span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22-ID338" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH22-ID338">Type Casting<br><span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="NestedTypes.html#//apple_ref/doc/uid/TP40014097-CH23-ID242" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH23-ID242">Nested Types<br><span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH24-ID151">Extensions<br><span class="jpstr">
拡張
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH25-ID267">Protocols<br><span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH26-ID179">Generics<br><span class="jpstr">
総称体
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-ID3" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH41-ID3">Access Control<br><span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID28" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH27-ID28">Advanced Operators<br><span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014097-CH28-ID427"
            class="part-name">
            <a href="AboutTheLanguageReference.html#//apple_ref/doc/uid/TP40014097-CH29-ID345" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH29-ID345">Language Reference<br><span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="AboutTheLanguageReference.html#//apple_ref/doc/uid/TP40014097-CH29-ID345" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH29-ID345">About the Language Reference<br><span class="jpstr">
言語リファレンスについて
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="LexicalStructure.html#//apple_ref/doc/uid/TP40014097-CH30-ID410" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH30-ID410">Lexical Structure<br><span class="jpstr">
語彙の構造
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Types.html#//apple_ref/doc/uid/TP40014097-CH31-ID445" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH31-ID445">Types<br><span class="jpstr">
型
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID383" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH32-ID383">Expressions<br><span class="jpstr">
式
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Statements.html#//apple_ref/doc/uid/TP40014097-CH33-ID428" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH33-ID428">Statements<br><span class="jpstr">
文
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID351" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH34-ID351">Declarations<br><span class="jpstr">
宣言
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Attributes.html#//apple_ref/doc/uid/TP40014097-CH35-ID347" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH35-ID347">Attributes<br><span class="jpstr">
属性
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Patterns.html#//apple_ref/doc/uid/TP40014097-CH36-ID419" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH36-ID419">Patterns<br><span class="jpstr">
パターン
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="GenericParametersAndArguments.html#//apple_ref/doc/uid/TP40014097-CH37-ID406" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH37-ID406">Generic Parameters and Arguments<br><span class="jpstr">
総称体パラメータと引数
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="zzSummaryOfTheGrammar.html#//apple_ref/doc/uid/TP40014097-CH38-ID458" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH38-ID458">Summary of the Grammar<br><span class="jpstr">
文法の概要
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014097-CH39-ID460"
            class="part-name">
            <a href="RevisionHistory.html#//apple_ref/doc/uid/TP40014097-CH40-ID459" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH40-ID459">Revision History<br><span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="RevisionHistory.html#//apple_ref/doc/uid/TP40014097-CH40-ID459" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH40-ID459">Document Revision History<br><span class="jpstr">
文書改訂履歴
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
    </ul>
</nav>

      <menu id="bashful" type="toolbar">
  <div class="shield"></div>
  <menuitem id="jump_to" class="menu-bar-item closed">
  <span>On This Page</span>
  <div class="chevron">
    <div class="chevy chevron-left"></div>
    <div class="chevy chevron-right"></div>
  </div>
  <menu type="list" class="details">
      <ul class="list-bullet">
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID310">Constants and Variables</a>
<br><span class="jpstr">
定数と変数
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID315">Comments</a>
<br><span class="jpstr">
コメント
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID316">Semicolons</a>
<br><span class="jpstr">
セミコロン
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID317">Integers</a>
<br><span class="jpstr">
整数
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID321">Floating-Point Numbers</a>
<br><span class="jpstr">
浮動小数点数
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID322">Type Safety and Type Inference</a>
<br><span class="jpstr">
型安全と型推論
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID323">Numeric Literals</a>
<br><span class="jpstr">
数のリテラル
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID324">Numeric Type Conversion</a>
<br><span class="jpstr">
数の型変換
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID327">Type Aliases</a>
<br><span class="jpstr">
型エイリアス
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID328">Booleans</a>
<br><span class="jpstr">
ブール
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID329">Tuples</a>
<br><span class="jpstr">
タプル
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID330">Optionals</a>
<br><span class="jpstr">
オプショナル
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID515">Error Handling</a>
<br><span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH5-ID335">Assertions and Preconditions</a>
<br><span class="jpstr">
表明と前提条件
</span><!--end_jpstr-->
          </li>
      </ul>
  </menu>
</menuitem>

</menu>
<div class="pixel-line"></div>
<div class="rubber-band-gap"></div>
<article class="chapter">
  <a name="//apple_ref/doc/uid/TP40014097-CH5"></a><a name="//apple_ref/doc/uid/TP40014097-CH5-ID309"></a>
      <a name="//apple_ref/doc/uid/TP40014097-CH4"></a><a name="//apple_ref/doc/uid/TP40014097-CH4-ID233"></a>

  <h2 class='chapter-name'>The Basics<br><span class="jpstr">
基本
</span><!--end_jpstr-->
</h2>


  
  	<section class="section">
  		<p class="para">
  Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C.
<br><span class="jpstr">
スウィフトは、iOS、macOS、watchOS、そしてtvOSアプリ開発のための新しいプログラミング言語です。にもかかわらず、スウィフトの多くの部分は、あなたのCとObjective-Cでの開発経験からきっとお馴染みのものでしょう。
</span><!--end_jpstr-->
</p>
<p class="para">
  Swift provides its own versions of all fundamental C and Objective-C types, including <code class="code-voice">Int</code> for integers, <code class="code-voice">Double</code> and <code class="code-voice">Float</code> for floating-point values, <code class="code-voice">Bool</code> for Boolean values, and <code class="code-voice">String</code> for textual data. Swift also provides powerful versions of the three primary collection types, <code class="code-voice">Array</code>, <code class="code-voice">Set</code>, and <code class="code-voice">Dictionary</code>, as described in <span class="x-name"><a href="CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-ID105" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH8-ID105">Collection Types</a></span>.
<br><span class="jpstr">
スウィフトは、全ての基本的なCおよびObjective-C型に関してそれ自身のバージョンを提供します、それには、整数のための<code class="code-voice">Int</code>、浮動小数点値のための<code class="code-voice">Double</code>と<code class="code-voice">Float</code>、ブール値のための<code class="code-voice">Bool</code>、そして、文字情報データのための<code class="code-voice">String</code>を含みます。スウィフトはまた、３つの主要なコレクション型、<code class="code-voice">Array</code>、<code class="code-voice">Set</code>、そして<code class="code-voice">Dictionary</code>の強力なバージョンを提供します、それは<span class="x-name"><a href="CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-ID105" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH8-ID105">「コレクション型」</a></span>で記述されます。
</span><!--end_jpstr-->
</p>
<p class="para">
  Like C, Swift uses variables to store and refer to values by an identifying name. Swift also makes extensive use of variables whose values can’t changed. These are known as constants, and are much more powerful than constants in C. Constants are used throughout Swift to make code safer and clearer in intent when you work with values that don’t need to change.
<br><span class="jpstr">
Cのように、スウィフトはひとつの識別名によっていろいろな値を保管したり引用したりするために、変数を使います。スウィフトはまた、値が変更されることができない変数を広範囲に利用します。これらは定数として知られています、そしてCにおける定数よりずっと強力です。定数は、変わる必要がない値をあなたが扱う時、コードをより安全により明白にする意図でスウィフトを通して使われます。
</span><!--end_jpstr-->
</p>
<p class="para">
  In addition to familiar types, Swift introduces advanced types not found in Objective-C, such as tuples. Tuples enable you to create and pass around groupings of values. You can use a tuple to return multiple values from a function as a single compound value.
<br><span class="jpstr">
よく知られている型に加えて、スウィフトはObjective-Cで見られない先進の型を導入します、例えばタプルのような。タプルは、あなたに値のグループをつくってあちこち渡すことを可能にします。あなたはタプルを使って、関数から複数の値を一つの混成値として返すことができます。
</span><!--end_jpstr-->
</p>
<p class="para">
  Swift also introduces optional types, which handle the absence of a value. Optionals say either “there <em>is</em> a value, and it equals <em>x</em>” or “there <em>isn’t</em> a value at all”. Using optionals is similar to using <code class="code-voice">nil</code> with pointers in Objective-C, but they work for any type, not just classes. Not only are optionals safer and more expressive than <code class="code-voice">nil</code> pointers in Objective-C, they’re at the heart of many of Swift’s most powerful features.
<br><span class="jpstr">
スウィフトはまたオプショナルの型を導入します、それは値の欠如を取り扱います。オプショナルであるものは、「ひとつの値が<em>ある</em>、そしてそれは<em>x</em>に等しい」または「まったく値が<em>ない</em>」のどちらかを伝えます。オプショナルの使用は、Objective-Cのポインターで<code class="code-voice">nil</code>を使うことに似ています、しかしそれは、ただクラスだけでなく、どんな型のためにでも働きます。オプショナルはObjective-Cでの<code class="code-voice">nil</code>ポインターより安全でさらに表現豊かであるだけでなく、それはスウィフトのたくさんある非常に強力な特徴のうち核心的なものです。
</span><!--end_jpstr-->
</p>
<p class="para">
  Swift is a <em>type-safe</em> language, which means the language helps you to be clear about the types of values your code can work with. If part of your code requires a <code class="code-voice">String</code>, type safety prevents you from passing it an <code class="code-voice">Int</code> by mistake. Likewise, type safety prevents you from accidentally passing an optional <code class="code-voice">String</code> to a piece of code that requires a nonoptional <code class="code-voice">String</code>. Type safety helps you catch and fix errors as early as possible in the development process.
<br><span class="jpstr">
スウィフトは<em>型安全</em>な言語です、それが意味するのは、この言語があなたを助けて、あなたのコードが扱うことができる値の型について明確であるようにすることです。あなたのコードの一部が<code class="code-voice">String</code>を要求するならば、型安全はあなたが間違ってそれに<code class="code-voice">Int</code>を渡すことを防ぎます。さらに、型安全はあなたがうっかりしてオプショナル<code class="code-voice">String</code>を、非オプショナル<code class="code-voice">String</code>を要求するコード部分に渡すことを防ぎます。型安全は、あなたが開発プロセスにおいて可能な限り早期にエラーを捕まえて修復するのを助けます。
</span><!--end_jpstr-->
</p>

		</section> 


  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID310"></a>
  <h3 class="section-name" tabindex="0">Constants and Variables<br><span class="jpstr">
定数と変数
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Constants and variables associate a name (such as <code class="code-voice">maximumNumberOfLoginAttempts</code> or <code class="code-voice">welcomeMessage</code>) with a value of a particular type (such as the number <code class="code-voice">10</code> or the string <code class="code-voice">&quot;Hello&quot;</code>). The value of a <em>constant</em> can’t be changed once it’s set, whereas a <em>variable</em> can be set to a different value in the future.
<br><span class="jpstr">
定数と変数は、ひとつの名前（例えば<code class="code-voice">maximumNumberOfLoginAttempts</code>または<code class="code-voice">welcomeMessage</code>など）を特定の型のひとつの値（例えば数<code class="code-voice">10</code>または文字列<code class="code-voice">"Hello"</code>など）と結びつけます。<em>定数</em>の値は、一旦それが設定されるならば変わることができません、一方で<em>変数</em>は将来異なる値に設定されることができます。
</span><!--end_jpstr-->
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID311"></a>
  <h3 class="section-name" tabindex="0">Declaring Constants and Variables<br><span class="jpstr">
定数と変数の宣言
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Constants and variables must be declared before they’re used. You declare constants with the <code class="code-voice">let</code> keyword and variables with the <code class="code-voice">var</code> keyword. Here’s an example of how constants and variables can be used to track the number of login attempts a user has made:
<br><span class="jpstr">
定数と変数は、それらが使われる前に宣言されなければなりません。あなたは、<code class="code-voice">let</code>キーワードを使って定数を、<code class="code-voice">var</code>キーワードを使って変数を宣言します。ここに定数と変数が、どのようにあるユーザーが行ったログインの試みの数を追跡するために使われることができるかの例があります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">maximumNumberOfLoginAttempts</span> = <span class="m">10</span></code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">currentLoginAttempt</span> = <span class="m">0</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  This code can be read as:
<br><span class="jpstr">
このコードは、次のように解釈されることができます：
</span><!--end_jpstr-->
</p><p class="para">
  “Declare a new constant called <code class="code-voice">maximumNumberOfLoginAttempts</code>, and give it a value of <code class="code-voice">10</code>. Then, declare a new variable called <code class="code-voice">currentLoginAttempt</code>, and give it an initial value of <code class="code-voice">0</code>.”
<br><span class="jpstr">
「<code class="code-voice">maximumNumberOfLoginAttempts</code>と呼ばれるある新しい定数を宣言して、それに<code class="code-voice">10</code>というひとつの値を与える。 その後で、<code class="code-voice">currentLoginAttempt</code>と呼ばれる新しい変数を宣言して、それに<code class="code-voice">0</code>の初期値を与える。」
</span><!--end_jpstr-->
</p><p class="para">
  In this example, the maximum number of allowed login attempts is declared as a constant, because the maximum value never changes. The current login attempt counter is declared as a variable, because this value must be incremented after each failed login attempt.
<br><span class="jpstr">
この例において、許可されるログインの試みの最大数は、最大の値が決して変わらないので、定数として宣言されます。現在のログイン試行の計数は、この値が失敗したログインの試みそれぞれの後で増加する必要があるので、変数として宣言されます。
</span><!--end_jpstr-->
</p><p class="para">
  You can declare multiple constants or multiple variables on a single line, separated by commas:
<br><span class="jpstr">
あなたは複数の定数または複数の変数を、コンマで区切ることで一つの行に宣言することができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">x</span> = <span class="m">0.0</span>, <span class="vc">y</span> = <span class="m">0.0</span>, <span class="vc">z</span> = <span class="m">0.0</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_28"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">If a stored value in your code won’t change, always declare it as a constant with the <code class="code-voice">let</code> keyword. Use variables only for storing values that need to be able to change.
    	<br><span class="jpstr">
ある保存された値をあなたのコードにおいて変化させる予定がないならば、常に<code class="code-voice">let</code>キーワードを使ってそれを定数として宣言してください。変更できる必要がある値を保存するためにだけ、変数を使ってください。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID312"></a>
  <h3 class="section-name" tabindex="0">Type Annotations<br><span class="jpstr">
さまざまな型注釈
</span><!--end_jpstr-->
</h3>
  <p class="para">
  You can provide a <em>type annotation</em> when you declare a constant or variable, to be clear about the kind of values the constant or variable can store. Write a type annotation by placing a colon after the constant or variable name, followed by a space, followed by the name of the type to use.
<br><span class="jpstr">
あなたは、あなたが定数または変数を宣言するとき、その定数または変数が保存することができる値の種類について明確にするために、<em>型注釈</em>を提供することができます。定数か変数の名前のあとにコロンを置いて、１つの空白に続き、使用する型の名前を続けることによって型注釈を書いてください。
</span><!--end_jpstr-->
</p><p class="para">
  This example provides a type annotation for a variable called <code class="code-voice">welcomeMessage</code>, to indicate that the variable can store <code class="code-voice">String</code> values:
<br><span class="jpstr">
この例は、<code class="code-voice">welcomeMessage</code>と呼ばれる変数に対して、その変数は<code class="code-voice">String</code>値を保存できることを示すために型注釈を提供します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">welcomeMessage</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The colon in the declaration means “…of type…,” so the code above can be read as:
<br><span class="jpstr">
宣言でのコロンは「…の型の…」を意味します、それで上のコードは次のように読まれることができます：
</span><!--end_jpstr-->
</p><p class="para">
  “Declare a variable called <code class="code-voice">welcomeMessage</code> that is of type <code class="code-voice">String</code>.”
<br><span class="jpstr">
「<code class="code-voice">welcomeMessage</code>と呼ばれる型<code class="code-voice">String</code>の変数を宣言する。」
</span><!--end_jpstr-->
</p><p class="para">
  The phrase “of type <code class="code-voice">String</code>” means “can store any <code class="code-voice">String</code> value.” Think of it as meaning “the type of thing” (or “the kind of thing”) that can be stored.
<br><span class="jpstr">
フレーズ「型<code class="code-voice">String</code>の」は、「どんな<code class="code-voice">String</code>値でも保存することができる」ことを意味します。それを、保存されることができる「物の型」（または「物の種類」）の意味と思ってください。
</span><!--end_jpstr-->
</p><p class="para">
  The <code class="code-voice">welcomeMessage</code> variable can now be set to any string value without error:
<br><span class="jpstr">
<code class="code-voice">welcomeMessage</code>変数は、現在エラーなしでどんな文字列値にでも設定されることができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">welcomeMessage</span> = <span class="s">&quot;Hello&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can define multiple related variables of the same type on a single line, separated by commas, with a single type annotation after the final variable name:
<br><span class="jpstr">
あなたは同じ型の複数の関連した変数を、１行上に、コンマで区切って、型注釈を１つだけ最後の変数名の後につけて、定義することができます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">red</span>, <span class="vc">green</span>, <span class="vc">blue</span>: <span class="n"><!-- a href="" -->Double<!-- /a --></span></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_29"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">It’s rare that you need to write type annotations in practice. If you provide an initial value for a constant or variable at the point that it’s defined, Swift can almost always infer the type to be used for that constant or variable, as described in <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH5-ID322" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID322">Type Safety and Type Inference</a></span>. In the <code class="code-voice">welcomeMessage</code> example above, no initial value is provided, and so the type of the <code class="code-voice">welcomeMessage</code> variable is specified with a type annotation rather than being inferred from an initial value.
    	<br><span class="jpstr">
あなたが型注釈を書く必要があることは実際問題として、まれです。あなたが最初の値を定数または変数に、それが定義される時点で提供するならば、スウィフトはたいていその定数または変数のために使われる型を推測することが、<span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH5-ID322" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID322">「型安全と型推論」</a></span>で記述されるように可能です。上の<code class="code-voice">welcomeMessage</code>の例では、初期値が提供されません、それで<code class="code-voice">welcomeMessage</code>変数の型は、最初の値から推論されるのではなく、型注釈で指定されます。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID313"></a>
  <h3 class="section-name" tabindex="0">Naming Constants and Variables<br><span class="jpstr">
定数と変数に名をつける
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Constant and variable names can contain almost any character, including Unicode characters:
<br><span class="jpstr">
定数と変数の名前は、ユニコード文字を含めて、ほとんどどんな文字でも含むことができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">π</span> = <span class="m">3.14159</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">你好</span> = <span class="s">&quot;你好世界&quot;</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">🐶🐮</span> = <span class="s">&quot;dogcow&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Constant and variable names can’t contain whitespace characters, mathematical symbols, arrows, private-use (or invalid) Unicode code points, or line- and box-drawing characters. Nor can they begin with a number, although numbers may be included elsewhere within the name.
<br><span class="jpstr">
定数と変数の名前は、空白文字、数学記号、矢印、私的使用（または無効な）Unicodeコード点、または書式印刷文字および罫線素片を含むことができません。そしてそれらは数字から始まることもできません、けれども数字が名前内のどこか他で含まれることはできます。
</span><!--end_jpstr-->
</p><p class="para">
  Once you’ve declared a constant or variable of a certain type, you can’t declare it again with the same name, or change it to store values of a different type. Nor can you change a constant into a variable or a variable into a constant.
<br><span class="jpstr">
一旦あなたが特定の型のある定数または変数を宣言してしまったならば、あなたは同じ名前でもう一度それを宣言し直すこと、またはそれを異なる型の値を保存するように変更することは出来ません。そして、あなたはある定数を変数に、またはある変数を定数に変更することもできません。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_30"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">If you need to give a constant or variable the same name as a reserved Swift keyword, surround the keyword with backticks (<code class="code-voice">`</code>) when using it as a name. However, avoid using keywords as names unless you have absolutely no choice.
    	<br><span class="jpstr">
あなたが予約済みのスウィフトのキーワードと同じ名前を定数または変数に与える必要があるならば、名前としてそれを使うときバッククォート（<code class="code-voice">`</code>）でそのキーワードを囲んでください。しかし、あなたに選択が全くない場合を除き、キーワードをなんらかの名前として使用することを避けてください。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><p class="para">
  You can change the value of an existing variable to another value of a compatible type. In this example, the value of <code class="code-voice">friendlyWelcome</code> is changed from <code class="code-voice">&quot;Hello!&quot;</code> to <code class="code-voice">&quot;Bonjour!&quot;</code>:
<br><span class="jpstr">
あなたは、既存の変数の値を、別の互換性を持つ型の値に変えることができます。この例では、<code class="code-voice">friendlyWelcome</code>の値は、<code class="code-voice">"Hello!"</code>から<code class="code-voice">"Bonjour!"</code>に変えられます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">friendlyWelcome</span> = <span class="s">&quot;Hello!&quot;</span></code></li>
            <li><code class="code-voice"><span class="vc">friendlyWelcome</span> = <span class="s">&quot;Bonjour!&quot;</span></code></li>
            <li><code class="code-voice"><span class="c">// friendlyWelcome is now &quot;Bonjour!&quot;&nbsp;<span class="jpstr">（friendlyWelcomeは、現在「Bonjour!」です）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Unlike a variable, the value of a constant can’t be changed once it’s set. Attempting to do so is reported as an error when your code is compiled:
<br><span class="jpstr">
変数とは異なり、一旦それが設定されるならば、定数の値は変わることができません。そうしようとすることは、あなたのコードがコンパイルされる時にエラーとして報告されます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">languageName</span> = <span class="s">&quot;Swift&quot;</span></code></li>
            <li><code class="code-voice"><span class="vc">languageName</span> = <span class="s">&quot;Swift++&quot;</span></code></li>
            <li><code class="code-voice"><span class="c">// This is a compile-time error: languageName cannot be changed.&nbsp;<span class="jpstr">（これはコンパイル時エラーです：anguageNameは変わることができません。）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID314"></a>
  <h3 class="section-name" tabindex="0">Printing Constants and Variables<br><span class="jpstr">
定数と変数を出力する
</span><!--end_jpstr-->
</h3>
  <p class="para">
  You can print the current value of a constant or variable with the <code class="code-voice">print(_:separator:terminator:)</code> function:
<br><span class="jpstr">
あなたは、<code class="code-voice">print(_:separator:terminator:)</code>関数で定数または変数の現在の値を出力することができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">print</span>(<span class="vc">friendlyWelcome</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;Bonjour!&quot;&nbsp;<span class="jpstr">（「Bonjour!」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The <code class="code-voice">print(_:separator:terminator:)</code> function is a global function that prints one or more values to an appropriate output. In Xcode, for example, the <code class="code-voice">print(_:separator:terminator:)</code> function prints its output in Xcode’s “console” pane. The <code class="code-voice">separator</code> and <code class="code-voice">terminator</code> parameter have default values, so you can omit them when you call this function. By default, the function terminates the line it prints by adding a line break. To print a value without a line break after it, pass an empty string as the terminator—for example, <code class="code-voice">print(someValue, terminator: &quot;&quot;)</code>. For information about parameters with default values, see <span class="x-name"><a href="Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID169" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH10-ID169">Default Parameter Values</a></span>.
<br><span class="jpstr">
<code class="code-voice">print(_:separator:terminator:)</code>関数は、ひとつ以上の値を適切な出力先に出力するグローバルな関数です。例えば、Xcodeでは、<code class="code-voice">print(_:separator:terminator:)</code>関数はその出力をXcodeの「コンソール」枠に表示します。<code class="code-voice">separator</code>と<code class="code-voice">terminator</code>パラメータは省略時の値を持ちます、それであなたはそれらを省略することが、この関数をあなたが呼び出す時に可能です。初期状態では、この関数はそれが出力する行を改行を加えて終わります。ある値をそれの後に改行なしで出力するには、空の文字列を終端子（ターミネータ）として渡してください ― 例えば、<code class="code-voice">print(someValue, terminator:"")</code>。省略時の値を持つパラメータについての情報として、<span class="x-name"><a href="Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID169" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH10-ID169">省略時のパラメータ値</a></span>を見てください。
</span><!--end_jpstr-->
</p><p class="para">
  Swift uses <em>string interpolation</em> to include the name of a constant or variable as a placeholder in a longer string, and to prompt Swift to replace it with the current value of that constant or variable. Wrap the name in parentheses and escape it with a backslash before the opening parenthesis:
<br><span class="jpstr">
スウィフトは、定数または変数の名前をより長い文字列の中にプレースホルダーとして含めるために、そしてそれをその定数または変数の現在の値と取り替えることをスウィフトに促すために、<em>文字列補間</em>を使います。丸括弧にその名前を包んで、始めの括弧の前のバックスラッシュでそれをエスケープします：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">print</span>(<span class="s">&quot;The current value of friendlyWelcome is </span>\(<span class="vc">friendlyWelcome</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;The current value of friendlyWelcome is Bonjour!&quot;&nbsp;<span class="jpstr">（「The current value of friendlyWelcome is Bonjour!」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_31"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">All options you can use with string interpolation are described in <span class="x-name"><a href="StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID292" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH7-ID292">String Interpolation</a></span>.
    	<br><span class="jpstr">
あなたが文字列補間で使うことができるオプション全ては、<span class="x-name"><a href="StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID292" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH7-ID292">「文字列補間」</a></span>で記述されます。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID315"></a>
  <h3 class="section-name" tabindex="0">Comments<br><span class="jpstr">
コメント
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Use comments to include nonexecutable text in your code, as a note or reminder to yourself. Comments are ignored by the Swift compiler when your code is compiled.
<br><span class="jpstr">
あなた自身への注意事項または覚え書きとして、実行可能でないテキストをあなたのコードに含めるために、コメントを使ってください。あなたのコードがコンパイルされるとき、コメントはスウィフトのコンパイラによって無視されます。
</span><!--end_jpstr-->
</p><p class="para">
  Comments in Swift are very similar to comments in C. Single-line comments begin with two forward-slashes (<code class="code-voice">//</code>):
<br><span class="jpstr">
スウィフトのコメントは、Cのコメントに非常に似ています。一行コメントは２つのスラッシュで始まります（<code class="code-voice">//</code>）：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="c">// This is a comment.&nbsp;<span class="jpstr">//（これはコメントです。）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Multiline comments start with a forward-slash followed by an asterisk (<code class="code-voice">/*</code>) and end with an asterisk followed by a forward-slash (<code class="code-voice">*/</code>):
<br><span class="jpstr">
複数行コメントは、スラッシュに続く星印（<code class="code-voice">/*</code>）で始まり、星印に続くスラッシュ（<code class="code-voice">*/</code>）で終わります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="c">/* This is also a comment&nbsp;<span class="jpstr">（これもコメントです）</span><!--end_jpstr--></span></code></li>
            <li><code class="code-voice"><span class="c"> but is written over multiple lines. &nbsp;<span class="jpstr">（しかし複数行にわたって書かれます。）</span><!--end_jpstr-->*/</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Unlike multiline comments in C, multiline comments in Swift can be nested inside other multiline comments. You write nested comments by starting a multiline comment block and then starting a second multiline comment within the first block. The second block is then closed, followed by the first block:
<br><span class="jpstr">
Cでの複数行コメントと違って、スウィフトの複数行コメントは他の複数行コメント内部に入れ子にされることができます。あなたはひとつの複数行コメント・ブロックを始めて、それから第二の複数行を最初のブロック以内に始めることによって入れ子にされたコメントを書きます。第二のブロックはそれから閉じられます、そして最初のブロックが続きます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="c">/* This is the start of the first multiline comment.&nbsp;<span class="jpstr">（最初の複数行コメントの始まり。）</span><!--end_jpstr--></span></code></li>
            <li><code class="code-voice"><span class="c"> /* This is the second, nested multiline comment. &nbsp;<span class="jpstr">（第二の入れ子の複数行コメント。）</span><!--end_jpstr-->*/</span></code></li>
            <li><code class="code-voice"><span class="c"> This is the end of the first multiline comment. &nbsp;<span class="jpstr">（最初の複数行コメントの終わり。）</span><!--end_jpstr-->*/</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Nested multiline comments enable you to comment out large blocks of code quickly and easily, even if the code already contains multiline comments.
<br><span class="jpstr">
入れ子にされた複数行コメントによって、たとえコードがすでに複数行コメントを含むとしても、あなたは速く簡単にコードの大きなブロックをコメントアウトすることが可能になります。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID316"></a>
  <h3 class="section-name" tabindex="0">Semicolons<br><span class="jpstr">
セミコロン
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Unlike many other languages, Swift doesn’t require you to write a semicolon (<code class="code-voice">;</code>) after each statement in your code, although you can do so if you wish. However, semicolons <em>are</em> required if you want to write multiple separate statements on a single line:
<br><span class="jpstr">
多くの他の言語とは異なり、スウィフトはあなたにあなたのコードにおいて各文の後にセミコロン（<code class="code-voice">;</code>）を書くことを要求しません、けれどもあなたが望むならば、あなたはそうできます。それにもかかわらず、セミコロンは必要と<em>されます</em>、もしあなたが一つの行に複数の別々の文を書きたい場合には：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">cat</span> = <span class="s">&quot;🐱&quot;</span>; <span class="vc">print</span>(<span class="vc">cat</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;🐱&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID317"></a>
  <h3 class="section-name" tabindex="0">Integers<br><span class="jpstr">
整数
</span><!--end_jpstr-->
</h3>
  <p class="para">
  <em>Integers</em> are whole numbers with no fractional component, such as <code class="code-voice">42</code> and <code class="code-voice">-23</code>. Integers are either <em>signed</em> (positive, zero, or negative) or <em>unsigned</em> (positive or zero).
<br><span class="jpstr">
<em>整数</em>は、小数部分のない数すべてです、例えば<code class="code-voice">42</code>や<code class="code-voice">-23</code>など。整数は、<em>符号つき</em>（正、ゼロ、または負）または<em>符号なし</em>（正またはゼロ）のどちらかです。
</span><!--end_jpstr-->
</p><p class="para">
  Swift provides signed and unsigned integers in 8, 16, 32, and 64 bit forms. These integers follow a naming convention similar to C, in that an 8-bit unsigned integer is of type <code class="code-voice">UInt8</code>, and a 32-bit signed integer is of type <code class="code-voice">Int32</code>. Like all types in Swift, these integer types have capitalized names.
<br><span class="jpstr">
スウィフトは、８、16、32、そして64ビット形式で、符号つきおよび符号なし整数を提供します。これらの整数は、８ビットの符号なし整数が型<code class="code-voice">UInt8</code>である、そして32ビットの符号つき整数が型<code class="code-voice">Int32</code>であるという点で、Cに似ている命名規則に従います。スウィフトにおける全ての型のように、これらの整数型は頭文字を使った名前を持ちます。
</span><!--end_jpstr-->
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID318"></a>
  <h3 class="section-name" tabindex="0">Integer Bounds<br><span class="jpstr">
整数の限界
</span><!--end_jpstr-->
</h3>
  <p class="para">
  You can access the minimum and maximum values of each integer type with its <code class="code-voice">min</code> and <code class="code-voice">max</code> properties:
<br><span class="jpstr">
あなたは、その<code class="code-voice">min</code>と<code class="code-voice">max</code>プロパティで各整数型の最小と最大の値を得ることができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">minValue</span> = <span class="vc">UInt8</span>.<span class="vc">min</span>  <span class="c">// minValue is equal to 0, and is of type UInt8&nbsp;<span class="jpstr"><span class="c">（minValuesは0に等しく、そしてUInt8型です）</span></span><!--end_jpstr--></span>
</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">maxValue</span> = <span class="vc">UInt8</span>.<span class="vc">max</span>  <span class="c">// maxValue is equal to 255, and is of type UInt8&nbsp;<span class="jpstr"><span class="c">（maxValuesは255に等しく、そしてUInt8型です）</span></span><!--end_jpstr--></span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The values of these properties are of the appropriate-sized number type (such as <code class="code-voice">UInt8</code> in the example above) and can therefore be used in expressions alongside other values of the same type.
<br><span class="jpstr">
これらのプロパティの値は、適切なサイズの数の型（例えば上の例での<code class="code-voice">UInt8</code>）であり、したがって、式の中で同じ型の他の値と並べて使われることができます。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID319"></a>
  <h3 class="section-name" tabindex="0">Int</h3>
  <p class="para">
  In most cases, you don’t need to pick a specific size of integer to use in your code. Swift provides an additional integer type, <code class="code-voice">Int</code>, which has the same size as the current platform’s native word size:
<br><span class="jpstr">
ほとんどの場合、あなたはあなたのコードにおいて使用するのに整数の特定のサイズを選択する必要はありません。スウィフトは追加の整数型、<code class="code-voice">Int</code>を提供します、そしてそれは、現在のプラットホーム固有のワードサイズと同じ大きさを持ちます：
</span><!--end_jpstr-->
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  On a 32-bit platform, <code class="code-voice">Int</code> is the same size as <code class="code-voice">Int32</code>.
<br><span class="jpstr">
32ビットのプラットホーム上で、<code class="code-voice">Int</code>は<code class="code-voice">Int32</code>と同じサイズです。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  On a 64-bit platform, <code class="code-voice">Int</code> is the same size as <code class="code-voice">Int64</code>.
<br><span class="jpstr">
64ビットのプラットホーム上で、<code class="code-voice">Int</code>は<code class="code-voice">Int64</code>と同じサイズです。
</span><!--end_jpstr-->
</p>
</li>
</ul><p class="para">
  Unless you need to work with a specific size of integer, always use <code class="code-voice">Int</code> for integer values in your code. This aids code consistency and interoperability. Even on 32-bit platforms, <code class="code-voice">Int</code> can store any value between <code class="code-voice">-2,147,483,648</code> and <code class="code-voice">2,147,483,647</code>, and is large enough for many integer ranges.
<br><span class="jpstr">
あなたが整数の特定のサイズを扱う必要がない限り、常に、あなたのコードの整数値のために<code class="code-voice">Int</code>を使ってください。これは、コードの整合性と相互運用性を支援します。32ビットのプラットホーム上でさえ、<code class="code-voice">Int</code>は<code class="code-voice">-2,147,483,648</code>と<code class="code-voice">2,147,483,647</code>の間のどんな値でも保存することができ、多くの整数範囲のために十分に大きいです。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID320"></a>
  <h3 class="section-name" tabindex="0">UInt<br><span class="jpstr">
符号なし整数（Unsigned Integer）
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Swift also provides an unsigned integer type, <code class="code-voice">UInt</code>, which has the same size as the current platform’s native word size:
<br><span class="jpstr">
スウィフトはまた、符号なし整数型、<code class="code-voice">UInt</code>を提供します、そしてそれは、現在のプラットホーム固有のワードサイズと同じ大きさを持ちます：
</span><!--end_jpstr-->
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  On a 32-bit platform, <code class="code-voice">UInt</code> is the same size as <code class="code-voice">UInt32</code>.
<br><span class="jpstr">
32ビットのプラットホーム上で、<code class="code-voice">UInt</code>は<code class="code-voice">UInt32</code>と同じサイズです。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  On a 64-bit platform, <code class="code-voice">UInt</code> is the same size as <code class="code-voice">UInt64</code>.
<br><span class="jpstr">
64ビットのプラットホーム上で、<code class="code-voice">UInt</code>は<code class="code-voice">UInt64</code>と同じサイズです。
</span><!--end_jpstr-->
</p>
</li>
</ul><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_32"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Use <code class="code-voice">UInt</code> only when you specifically need an unsigned integer type with the same size as the platform’s native word size. If this isn’t the case, <code class="code-voice">Int</code> is preferred, even when the values to be stored are known to be nonnegative. A consistent use of <code class="code-voice">Int</code> for integer values aids code interoperability, avoids the need to convert between different number types, and matches integer type inference, as described in <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH5-ID322" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID322">Type Safety and Type Inference</a></span>.
    	<br><span class="jpstr">
あなたが特にプラットホーム固有のワードサイズと同じ大きさで符号なし整数型を必要とする時にだけ<code class="code-voice">UInt</code>を使ってください。この場合でないならば、保存される値が負数でないことがわかっている時でさえ、<code class="code-voice">Int</code>がむしろ好まれます。整数値のための<code class="code-voice">Int</code>の一貫した使用は、コードの相互運用性を支援して、異なる数の型の間で変換する必要を避けて、<span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH5-ID322" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID322">「型安全と型推論」</a></span>で記述されるように、整数型推論に合致します。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID321"></a>
  <h3 class="section-name" tabindex="0">Floating-Point Numbers<br><span class="jpstr">
浮動小数点数
</span><!--end_jpstr-->
</h3>
  <p class="para">
  <em>Floating-point numbers</em> are numbers with a fractional component, such as <code class="code-voice">3.14159</code>, <code class="code-voice">0.1</code>, and <code class="code-voice">-273.15</code>.
<br><span class="jpstr">
<em>浮動小数点数</em>は小数部を持つ数です、例えば<code class="code-voice">3.14159</code>、<code class="code-voice">0.1</code>、そして<code class="code-voice">-273.15</code>など。
</span><!--end_jpstr-->
</p><p class="para">
  Floating-point types can represent a much wider range of values than integer types, and can store numbers that are much larger or smaller than can be stored in an <code class="code-voice">Int</code>. Swift provides two signed floating-point number types:
<br><span class="jpstr">
浮動小数点型は、整数型よりずっと広い値の幅を表すことができ、そして<code class="code-voice">Intに</code>保存できるよりずっと大きいまたは小さい数を保存することができます。スウィフトは、２つの符号つき浮動小数点数型を提供します：
</span><!--end_jpstr-->
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  <code class="code-voice">Double</code> represents a 64-bit floating-point number.
<br><span class="jpstr">
<code class="code-voice">Double</code>は、64ビットの浮動小数点数を表します。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">Float</code> represents a 32-bit floating-point number.
<br><span class="jpstr">
<code class="code-voice">Float</code>は、32ビットの浮動小数点数を表します。
</span><!--end_jpstr-->
</p>
</li>
</ul><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_33"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para"><code class="code-voice">Double</code> has a precision of at least 15 decimal digits, whereas the precision of <code class="code-voice">Float</code> can be as little as 6 decimal digits. The appropriate floating-point type to use depends on the nature and range of values you need to work with in your code. In situations where either type would be appropriate, <code class="code-voice">Double</code> is preferred.
    	<br><span class="jpstr">
<code class="code-voice">Double</code>は少なくとも10進数で15桁の精度を持ちます、一方で<code class="code-voice">Float</code>の精度は10進数で６桁ほどです。使うのに適切な浮動小数点型は、あなたのコードにおいて扱わなければならない値の種別と幅に依ります。どちらの型でも適切である状況では、<code class="code-voice">Double</code>が望ましいです。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID322"></a>
  <h3 class="section-name" tabindex="0">Type Safety and Type Inference<br><span class="jpstr">
型安全と型推論
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Swift is a <em>type-safe</em> language. A type safe language encourages you to be clear about the types of values your code can work with. If part of your code requires a <code class="code-voice">String</code>, you can’t pass it an <code class="code-voice">Int</code> by mistake.
<br><span class="jpstr">
スウィフトは、<em>型安全</em>な言語です。型安全な言語は、あなたのコードが扱うことができる値の型について、あなたが確信を持つように促します。あなたのコードの一部が<code class="code-voice">String</code>を要求するならば、あなたは誤ってそれに<code class="code-voice">Int</code>を渡すことはできません。
</span><!--end_jpstr-->
</p><p class="para">
  Because Swift is type safe, it performs <em>type checks</em> when compiling your code and flags any mismatched types as errors. This enables you to catch and fix errors as early as possible in the development process.
<br><span class="jpstr">
スウィフトが型安全であるので、それは、あなたのコードをコンパイルするとき<em>型チェック</em>を実行して、あらゆる組合せを誤った型をエラーとして合図します。これは、あなたに開発過程においてエラーをできるだけ早く捕えて修復するのを可能にします。
</span><!--end_jpstr-->
</p><p class="para">
  Type-checking helps you avoid errors when you’re working with different types of values. However, this doesn’t mean that you have to specify the type of every constant and variable that you declare. If you don’t specify the type of value you need, Swift uses <em>type inference</em> to work out the appropriate type. Type inference enables a compiler to deduce the type of a particular expression automatically when it compiles your code, simply by examining the values you provide.
<br><span class="jpstr">
型をチェックすることは、あなたが異なる種類の値を扱っているとき、あなたがエラーを避ける手助けをします。しかし、これはあなたがすべてのあなたが宣言する定数と変数の型を指定しなければならないことを意味しません。あなたが必要とする値の型をあなたが指定しないならば、スウィフトは適切な型を導きだすために<em>型推論</em>を使います。型推論は、コンパイラに自動的に特定の式の型を演繹することを、それがあなたのコードをコンパイルする時に、単純にあなたが提供する値を調べることによって、可能にします。
</span><!--end_jpstr-->
</p><p class="para">
  Because of type inference, Swift requires far fewer type declarations than languages such as C or Objective-C. Constants and variables are still explicitly typed, but much of the work of specifying their type is done for you.
<br><span class="jpstr">
型推論のため、スウィフトはCまたはObjective-Cのような言語よりはるかに少ない型宣言しか必要としません。定数と変数は依然として明確に型を決められます、しかしそれらの型を指定する行為のほとんどは、あなたのために行われます。
</span><!--end_jpstr-->
</p><p class="para">
  Type inference is particularly useful when you declare a constant or variable with an initial value. This is often done by assigning a <em>literal value</em> (or <em>literal</em>) to the constant or variable at the point that you declare it. (A literal value is a value that appears directly in your source code, such as <code class="code-voice">42</code> and <code class="code-voice">3.14159</code> in the examples below.)
<br><span class="jpstr">
あなたが最初の値で定数または変数を宣言するとき、型推論は特に役に立ちます。これは、<em>リテラル値</em>（または<em>リテラル</em>）を定数または変数に、あなたがそれを宣言する時点で代入することによって、しばしば行われます。（リテラル値「文字通りの値」は、直接あなたのソース・コードで見かける値です、例えば下の例での<code class="code-voice">42</code>と<code class="code-voice">3.14159</code>）。
</span><!--end_jpstr-->
</p><p class="para">
  For example, if you assign a literal value of <code class="code-voice">42</code> to a new constant without saying what type it is, Swift infers that you want the constant to be an <code class="code-voice">Int</code>, because you have initialized it with a number that looks like an integer:
<br><span class="jpstr">
例えば、あなたがそれがどんな型であるかについて言うことなく、新しい定数にリテラル値<code class="code-voice">42</code>を代入するならば、スウィフトは、あなたがその定数に<code class="code-voice">Int</code>であって欲しいのだと推測します、なぜならあなたがそれを整数のように見える数で初期化したからです：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">meaningOfLife</span> = <span class="m">42</span></code></li>
            <li><code class="code-voice"><span class="c">// meaningOfLife is inferred to be of type Int&nbsp;<span class="jpstr">（meaningOfLifeはInt型であると推測されます）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Likewise, if you don’t specify a type for a floating-point literal, Swift infers that you want to create a <code class="code-voice">Double</code>:
<br><span class="jpstr">
同様に、あなたがある浮動小数点リテラルのために型を指定しないならば、スウィフトはあなたが<code class="code-voice">Double</code>をつくりたいと推測します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">pi</span> = <span class="m">3.14159</span></code></li>
            <li><code class="code-voice"><span class="c">// pi is inferred to be of type Double&nbsp;<span class="jpstr">（パイはDouble型であると推測されます）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Swift always chooses <code class="code-voice">Double</code> (rather than <code class="code-voice">Float</code>) when inferring the type of floating-point numbers.
<br><span class="jpstr">
浮動小数点数の型を推論するとき、スウィフトは常に<code class="code-voice">Double</code>を選びます（<code class="code-voice">Float</code>ではなく）。
</span><!--end_jpstr-->
</p><p class="para">
  If you combine integer and floating-point literals in an expression, a type of <code class="code-voice">Double</code> will be inferred from the context:
<br><span class="jpstr">
あなたがある式の中で整数と浮動小数点リテラルを結合するならば、その前後関係から<code class="code-voice">Double</code>の型が推論されます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">anotherPi</span> = <span class="m">3</span> + <span class="m">0.14159</span></code></li>
            <li><code class="code-voice"><span class="c">// anotherPi is also inferred to be of type Double&nbsp;<span class="jpstr">（anotherPiもまたDouble型であると推論されます）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The literal value of <code class="code-voice">3</code> has no explicit type in and of itself, and so an appropriate output type of <code class="code-voice">Double</code> is inferred from the presence of a floating-point literal as part of the addition.
<br><span class="jpstr">
リテラル値<code class="code-voice">3</code>は明確な型をそれ自体は持ちません、それで適切な出力の<code class="code-voice">Double</code>型は、加算部分の浮動小数点リテラルの存在から推論されます。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID323"></a>
  <h3 class="section-name" tabindex="0">Numeric Literals<br><span class="jpstr">
数のリテラル
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Integer literals can be written as:
<br><span class="jpstr">
整数リテラルは、次のように書かれることができます：
</span><!--end_jpstr-->
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  A <em>decimal</em> number, with no prefix
<br><span class="jpstr">
<em>10進</em>数は、接頭辞なしで
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  A <em>binary</em> number, with a <code class="code-voice">0b</code> prefix
<br><span class="jpstr">
<em>２進</em>数は、接頭辞<code class="code-voice">0b</code>つきで
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  An <em>octal</em> number, with a <code class="code-voice">0o</code> prefix
<br><span class="jpstr">
<em>８進</em>数は、接頭辞<code class="code-voice">0o</code>つきで
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  A <em>hexadecimal</em> number, with a <code class="code-voice">0x</code> prefix
<br><span class="jpstr">
<em>16進</em>数は、接頭辞<code class="code-voice">0x</code>つきで
</span><!--end_jpstr-->
</p>
</li>
</ul><p class="para">
  All of these integer literals have a decimal value of <code class="code-voice">17</code>:
<br><span class="jpstr">
次の整数リテラルの全ては、10進の値で<code class="code-voice">17</code>を持ちます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">decimalInteger</span> = <span class="m">17</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">binaryInteger</span> = <span class="m">0b10001</span>       <span class="c">// 17 in binary notation&nbsp;<span class="jpstr"><span class="c">（２進法での17）</span></span><!--end_jpstr--></span>
</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">octalInteger</span> = <span class="m">0o21</span>           <span class="c">// 17 in octal notation&nbsp;<span class="jpstr"><span class="c">（８進法での17）</span></span><!--end_jpstr--></span>
</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">hexadecimalInteger</span> = <span class="m">0x11</span>     <span class="c">// 17 in hexadecimal notation&nbsp;<span class="jpstr"><span class="c">（16進法での17）</span></span><!--end_jpstr--></span>
</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Floating-point literals can be decimal (with no prefix), or hexadecimal (with a <code class="code-voice">0x</code> prefix). They must always have a number (or hexadecimal number) on both sides of the decimal point. Decimal floats can also have an optional <em>exponent</em>, indicated by an uppercase or lowercase <code class="code-voice">e</code>; hexadecimal floats must have an exponent, indicated by an uppercase or lowercase <code class="code-voice">p</code>.
<br><span class="jpstr">
浮動小数点リテラルは、10進（接頭辞なし）、または16進（接頭辞<code class="code-voice">0x</code>つき）であることができます。それらは、常に小数点の両側で数（または16進の数）を持たなければなりません。10進浮動小数点はまた、任意に<em>指数</em>を持つことができ、大文字か小文字の<code class="code-voice">e</code>で示されます；16進浮動小数点は、指数を持つ必要があり、大文字か小文字の<code class="code-voice">p</code>で示されます。
</span><!--end_jpstr-->
</p><p class="para">
  For decimal numbers with an exponent of <code class="code-voice">exp</code>, the base number is multiplied by 10<sup>exp</sup>:
<br><span class="jpstr">
<code class="code-voice">exp</code>の指数を持つある10進数に対して、その基数は10<sup>exp</sup>を掛けられます：
</span><!--end_jpstr-->
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  <code class="code-voice">1.25e2</code> means 1.25 x 10<sup>2</sup>, or <code class="code-voice">125.0</code>.
<br><span class="jpstr">
<code class="code-voice">1.25e2</code>は、1.25 × 10<sup>2</sup>、または<code class="code-voice">125.0</code>を意味します。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">1.25e-2</code> means 1.25 x 10<sup>-2</sup>, or <code class="code-voice">0.0125</code>.
<br><span class="jpstr">
<code class="code-voice">1.25e-2</code>は、1.25 × 10<sup>-2</sup>、または<code class="code-voice">0.0125</code>を意味します。
</span><!--end_jpstr-->
</p>
</li>
</ul><p class="para">
  For hexadecimal numbers with an exponent of <code class="code-voice">exp</code>, the base number is multiplied by 2<sup>exp</sup>:
<br><span class="jpstr">
<code class="code-voice">exp</code>の指数を持つある16進数に対して、その基数は２<sup>exp</sup>を掛けられます：
</span><!--end_jpstr-->
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  <code class="code-voice">0xFp2</code> means 15 x 2<sup>2</sup>, or <code class="code-voice">60.0</code>.
<br><span class="jpstr">
<code class="code-voice">0xFp2</code>は、15 × 2<sup>2</sup>、または<code class="code-voice">60.0</code>を意味します。
</span><!--end_jpstr-->
</p>
</li><li class="item"><p class="para">
  <code class="code-voice">0xFp-2</code> means 15 x 2<sup>-2</sup>, or <code class="code-voice">3.75</code>.
<br><span class="jpstr">
<code class="code-voice">0xFp-2</code>は、15 × 2<sup>-2</sup>、または<code class="code-voice">3.75</code>を意味します。
</span><!--end_jpstr-->
</p>
</li>
</ul><p class="para">
  All of these floating-point literals have a decimal value of <code class="code-voice">12.1875</code>:
<br><span class="jpstr">
以下の浮動小数点リテラルの全ては、10進の値で<code class="code-voice">12.1875</code>を持ちます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">decimalDouble</span> = <span class="m">12.1875</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">exponentDouble</span> = <span class="m">1.21875e1</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">hexadecimalDouble</span> = <span class="m">0xC.3p0</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Numeric literals can contain extra formatting to make them easier to read. Both integers and floats can be padded with extra zeros and can contain underscores to help with readability. Neither type of formatting affects the underlying value of the literal:
<br><span class="jpstr">
数のリテラルは、それらをより簡単に読めるように書式を整える追加のものを含むことができます。整数と浮動小数点は、余分のゼロを詰められることができ、読みやすくするためにアンダースコアを含むことができます。書式整形のどちらの種類も、もととなるリテラルの値に影響を及ぼしません：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">paddedDouble</span> = <span class="m">000123.456</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">oneMillion</span> = <span class="m">1_000_000</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">justOverOneMillion</span> = <span class="m">1_000_000.000_000_1</span></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID324"></a>
  <h3 class="section-name" tabindex="0">Numeric Type Conversion<br><span class="jpstr">
数の型変換
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Use the <code class="code-voice">Int</code> type for all general-purpose integer constants and variables in your code, even if they’re known to be nonnegative. Using the default integer type in everyday situations means that integer constants and variables are immediately interoperable in your code and will match the inferred type for integer literal values.
<br><span class="jpstr">
<code class="code-voice">Int</code>型を全ての一般的な目的のための整数の定数と変数に対してあなたのコードにおいて使ってください、たとえそれらが負数でないことが知られているとしてもです。日々の状況において初期状態として整数型を使うことは、整数の定数と変数があなたのコードにおいて直接に情報交換が可能で、いろいろな整数のリテラル値に対して推論される型と調和することを意味します。
</span><!--end_jpstr-->
</p><p class="para">
  Use other integer types only when they’re specifically needed for the task at hand, because of explicitly sized data from an external source, or for performance, memory usage, or other necessary optimization. Using explicitly sized types in these situations helps to catch any accidental value overflows and implicitly documents the nature of the data being used.
<br><span class="jpstr">
外部ソース由来の明確に大きさを設定されたデータのために、またはパフォーマンス、メモリ使用、または他の必要な最適化のためになど、目下の作業に特に必要とされる時にだけ、他の整数を使ってください。これらの状況において明示的に大きさを設定された型を使うことは、偶発的な何らかの値のオーバフローを捕えることや、使われているデータの性質を暗黙的に記録することの手助けになります。
</span><!--end_jpstr-->
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID325"></a>
  <h3 class="section-name" tabindex="0">Integer Conversion<br><span class="jpstr">
整数変換
</span><!--end_jpstr-->
</h3>
  <p class="para">
  The range of numbers that can be stored in an integer constant or variable is different for each numeric type. An <code class="code-voice">Int8</code> constant or variable can store numbers between <code class="code-voice">-128</code> and <code class="code-voice">127</code>, whereas a <code class="code-voice">UInt8</code> constant or variable can store numbers between <code class="code-voice">0</code> and <code class="code-voice">255</code>. A number that won’t fit into a constant or variable of a sized integer type is reported as an error when your code is compiled:
<br><span class="jpstr">
整数の定数または変数に保存されることができる数の範囲は、それぞれの数の型で異なります。<code class="code-voice">Int8</code>定数または変数は、<code class="code-voice">-128</code>と<code class="code-voice">127</code>の間の数を保存することができる一方、<code class="code-voice">UInt8</code>定数または変数は、<code class="code-voice">0</code>と<code class="code-voice">255</code>の間の数を保存することができます。あなたのコードがコンパイルされるとき、ある大きさを設定された整数型の定数または変数に収まらない数はエラーとして報告されます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">cannotBeNegative</span>: <span class="n"><!-- a href="" -->UInt8<!-- /a --></span> = <span class="m">-1</span></code></li>
            <li><code class="code-voice"><span class="c">// UInt8 cannot store negative numbers, and so this will report an error&nbsp;<span class="jpstr">（UInt8は負の数を保存することができません、それでこれはエラーを報告します）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">tooBig</span>: <span class="n"><!-- a href="" -->Int8<!-- /a --></span> = <span class="vc">Int8</span>.<span class="vc">max</span> + <span class="m">1</span></code></li>
            <li><code class="code-voice"><span class="c">// Int8 cannot store a number larger than its maximum value,&nbsp;<span class="jpstr">（Int8はその最大の値より大きい数を保存することができません）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="c">// and so this will also report an error&nbsp;<span class="jpstr">（それでこれも同様にエラーを報告します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Because each numeric type can store a different range of values, you must opt in to numeric type conversion on a case-by-case basis. This opt-in approach prevents hidden conversion errors and helps make type conversion intentions explicit in your code.
<br><span class="jpstr">
それぞれの数の型は、値の異なる幅を保存できるので、あなたは数の型変換を一件一件を原則に決めていかなければなりません。このオプトインの（個々に決めていく）取り組み方は、隠された変換エラーを防いで、あなたのコードにおいて型変換の意図を明確にするのを助けます。
</span><!--end_jpstr-->
</p><p class="para">
  To convert one specific number type to another, you initialize a new number of the desired type with the existing value. In the example below, the constant <code class="code-voice">twoThousand</code> is of type <code class="code-voice">UInt16</code>, whereas the constant <code class="code-voice">one</code> is of type <code class="code-voice">UInt8</code>. They can’t be added together directly, because they’re not of the same type. Instead, this example calls <code class="code-voice">UInt16(one)</code> to create a new <code class="code-voice">UInt16</code> initialized with the value of <code class="code-voice">one</code>, and uses this value in place of the original:
<br><span class="jpstr">
１つの特定の数の型を他のものに変換するために、あなたは望む型の新しい数を既存の値で初期化します。下記の例で、定数<code class="code-voice">twoThousand</code>は<code class="code-voice">型UInt16</code>ですが、定数<code class="code-voice">one</code>は型<code class="code-voice">UInt8</code>です。それらは直接にひとつに加算されることができません、それらが同じ型でないためです。その代わりに、この例は<code class="code-voice">one</code>の値で初期化される新しい<code class="code-voice">UInt16</code>を作るために<code class="code-voice">UInt16(one)</code>を呼んで、オリジナルの代わりにこの値を使います：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">twoThousand</span>: <span class="n"><!-- a href="" -->UInt16<!-- /a --></span> = <span class="m">2_000</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">one</span>: <span class="n"><!-- a href="" -->UInt8<!-- /a --></span> = <span class="m">1</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">twoThousandAndOne</span> = <span class="vc">twoThousand</span> + <span class="vc">UInt16</span>(<span class="vc">one</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Because both sides of the addition are now of type <code class="code-voice">UInt16</code>, the addition is allowed. The output constant (<code class="code-voice">twoThousandAndOne</code>) is inferred to be of type <code class="code-voice">UInt16</code>, because it’s the sum of two <code class="code-voice">UInt16</code> values.
<br><span class="jpstr">
加算の両側が今では型<code class="code-voice">UInt16</code>であるので、加算は許されます。出力された定数（<code class="code-voice">twoThousandAndOne</code>）は、型<code class="code-voice">UInt16</code>であると推測されます、それが２つの<code class="code-voice">UInt16値</code>の合計であるので。
</span><!--end_jpstr-->
</p><p class="para">
  <code class="code-voice">SomeType(ofInitialValue)</code> is the default way to call the initializer of a Swift type and pass in an initial value. Behind the scenes, <code class="code-voice">UInt16</code> has an initializer that accepts a <code class="code-voice">UInt8</code> value, and so this initializer is used to make a new <code class="code-voice">UInt16</code> from an existing <code class="code-voice">UInt8</code>. You can’t pass in <em>any</em> type here, however—it has to be a type for which <code class="code-voice">UInt16</code> provides an initializer. Extending existing types to provide initializers that accept new types (including your own type definitions) is covered in <span class="x-name"><a href="Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH24-ID151">Extensions</a></span>.
<br><span class="jpstr">
<code class="code-voice">SomeType(ofInitialValue)</code>は、あるスウィフト型のイニシャライザを呼んで、初期値を渡すために通常使う方法です。舞台裏で、<code class="code-voice">UInt16</code>は<code class="code-voice">UInt8</code>値を受け入れるイニシャライザを持ちます、それでこのイニシャライザが新しい<code class="code-voice">UInt16</code>を既存の<code class="code-voice">UInt8</code>から作るために使われます。しかしながら、あなたは<em>あらゆる</em>型をここに渡すことはできません ― それは<code class="code-voice">UInt16</code>がイニシャライザを提供する型でなければなりません。新しい型（あなた独自の型定義を含む）を受け入れるイニシャライザを提供するように既存の型を拡張することは、<span class="x-name"><a href="Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH24-ID151">「拡張」</a></span>で扱われます。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID326"></a>
  <h3 class="section-name" tabindex="0">Integer and Floating-Point Conversion<br><span class="jpstr">
整数と浮動小数点の変換
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Conversions between integer and floating-point numeric types must be made explicit:
<br><span class="jpstr">
整数と浮動小数点数型の間の変換は、明示的に行われる必要があります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">three</span> = <span class="m">3</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">pointOneFourOneFiveNine</span> = <span class="m">0.14159</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">pi</span> = <span class="vc">Double</span>(<span class="vc">three</span>) + <span class="vc">pointOneFourOneFiveNine</span></code></li>
            <li><code class="code-voice"><span class="c">// pi equals 3.14159, and is inferred to be of type Double&nbsp;<span class="jpstr">（piは、3.14159に等しく、型Doubleであると推論されます）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here, the value of the constant <code class="code-voice">three</code> is used to create a new value of type <code class="code-voice">Double</code>, so that both sides of the addition are of the same type. Without this conversion in place, the addition would not be allowed.
<br><span class="jpstr">
ここでは、定数<code class="code-voice">three</code>の値が、<code class="code-voice">Double</code>型の新しい値をつくるために使われます、それでこの加算の両側は同じ型です。適切なこの変換なしでは、この加算は許されません。
</span><!--end_jpstr-->
</p><p class="para">
  Floating-point to integer conversion must also be made explicit. An integer type can be initialized with a <code class="code-voice">Double</code> or <code class="code-voice">Float</code> value:
<br><span class="jpstr">
浮動小数点を整数に変換することは、また、明示的に行われる必要があります。整数型は、<code class="code-voice">Double</code>または<code class="code-voice">Float</code>値で初期化されることができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">integerPi</span> = <span class="vc">Int</span>(<span class="vc">pi</span>)</code></li>
            <li><code class="code-voice"><span class="c">// integerPi equals 3, and is inferred to be of type Int&nbsp;<span class="jpstr">（integerPiは、３に等しく、型Intであると推測されます）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Floating-point values are always truncated when used to initialize a new integer value in this way. This means that <code class="code-voice">4.75</code> becomes <code class="code-voice">4</code>, and <code class="code-voice">-3.9</code> becomes <code class="code-voice">-3</code>.
<br><span class="jpstr">
この方法で新しい整数値を初期化するとき、浮動小数点値は常に切り詰められます。これは、<code class="code-voice">4.75</code>が<code class="code-voice">4</code>に、そして<code class="code-voice">-3.9</code>が<code class="code-voice">-3</code>になることを意味します。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_34"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">The rules for combining numeric constants and variables are different from the rules for numeric literals. The literal value <code class="code-voice">3</code> can be added directly to the literal value <code class="code-voice">0.14159</code>, because number literals don’t have an explicit type in and of themselves. Their type is inferred only at the point that they’re evaluated by the compiler.
    	<br><span class="jpstr">
数の定数や変数を結合することに対する規則は、数のリテラルに対する規則と異なります。リテラル値<code class="code-voice">3</code>は、直接にリテラル値<code class="code-voice">0.14159</code>に加えられることができます、なぜなら数リテラルがそれら自身において明確な型を持たないためです。それらの型は、それらがコンパイラによって評価される時点においてのみ、推論されます。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID327"></a>
  <h3 class="section-name" tabindex="0">Type Aliases<br><span class="jpstr">
型エイリアス
</span><!--end_jpstr-->
</h3>
  <p class="para">
  <em>Type aliases</em> define an alternative name for an existing type. You define type aliases with the <code class="code-voice">typealias</code> keyword.
<br><span class="jpstr">
<em>型エイリアス</em>は、既存の型の代替の名前を定義します。あなたは、<code class="code-voice">typealias</code>キーワードで型エイリアスを定義します。
</span><!--end_jpstr-->
</p><p class="para">
  Type aliases are useful when you want to refer to an existing type by a name that is contextually more appropriate, such as when working with data of a specific size from an external source:
<br><span class="jpstr">
型エイリアスは、あなたがより文脈上適切な名前で既存の型に言及したいとき役に立ちます、たとえば外部ソースからの特定の大きさのデータを扱う時など：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">typealias</span> <span class="vc">AudioSample</span> = <span class="n"><!-- a href="" -->UInt16<!-- /a --></span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Once you define a type alias, you can use the alias anywhere you might use the original name:
<br><span class="jpstr">
一旦あなたがある型エイリアスを定義するならば、あなたが本来の名前を使うであろうどこにでも、あなたはそのエイリアスを使用することができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">maxAmplitudeFound</span> = <span class="vc">AudioSample</span>.<span class="vc">min</span></code></li>
            <li><code class="code-voice"><span class="c">// maxAmplitudeFound is now 0&nbsp;<span class="jpstr">（maxAmplitudeFoundは、現在0です）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here, <code class="code-voice">AudioSample</code> is defined as an alias for <code class="code-voice">UInt16</code>. Because it’s an alias, the call to <code class="code-voice">AudioSample.min</code> actually calls <code class="code-voice">UInt16.min</code>, which provides an initial value of <code class="code-voice">0</code> for the <code class="code-voice">maxAmplitudeFound</code> variable.
<br><span class="jpstr">
ここでは、<code class="code-voice">AudioSample</code>は<code class="code-voice">UInt16</code>に対するエイリアス（別名）として定義されます。それがエイリアスであるので、<code class="code-voice">AudioSample.min</code>への呼び出しは実際には<code class="code-voice">UInt16.min</code>を呼び、それは<code class="code-voice">0</code>の初期値を<code class="code-voice">maxAmplitudeFound</code>変数のために提供します。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID328"></a>
  <h3 class="section-name" tabindex="0">Booleans<br><span class="jpstr">
ブール
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Swift has a basic <em>Boolean</em> type, called <code class="code-voice">Bool</code>. Boolean values are referred to as <em>logical</em>, because they can only ever be true or false. Swift provides two Boolean constant values, <code class="code-voice">true</code> and <code class="code-voice">false</code>:
<br><span class="jpstr">
スウィフトは、ひとつの基本的な<em>ブール</em>型を持ちます、それは<code class="code-voice">Bool</code>と呼ばれるものです。ブールの値は、<em>論理</em>として参照されます、なぜならそれらは真か偽であることだけができるからです。スウィフトは２つのブールの定数値、<code class="code-voice">true</code>と<code class="code-voice">false</code>を提供します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">orangesAreOrange</span> = <span class="kt">true</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">turnipsAreDelicious</span> = <span class="kt">false</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The types of <code class="code-voice">orangesAreOrange</code> and <code class="code-voice">turnipsAreDelicious</code> have been inferred as <code class="code-voice">Bool</code> from the fact that they were initialized with Boolean literal values. As with <code class="code-voice">Int</code> and <code class="code-voice">Double</code> above, you don’t need to declare constants or variables as <code class="code-voice">Bool</code> if you set them to <code class="code-voice">true</code> or <code class="code-voice">false</code> as soon as you create them. Type inference helps make Swift code more concise and readable when it initializes constants or variables with other values whose type is already known.
<br><span class="jpstr">
<code class="code-voice">orangesAreOrange</code>と<code class="code-voice">turnipsAreDelicious</code>の型は、それらがブールのリテラル値で初期化されたという事実から、<code class="code-voice">Bool</code>として推論されます。上の<code class="code-voice">Int</code>と<code class="code-voice">Double</code>と同様に、あなたがそれらを作成するやいなや<code class="code-voice">true</code>または<code class="code-voice">false</code>に設定するならば、あなたは定数または変数を<code class="code-voice">Bool</code>として宣言する必要はありません。型推論は、スウィフトのコードを、それが定数または変数を型がすでに知られている他の値で初期化するとき、より簡潔で読みやすくするのを助けます。
</span><!--end_jpstr-->
</p><p class="para">
  Boolean values are particularly useful when you work with conditional statements such as the <code class="code-voice">if</code> statement:
<br><span class="jpstr">
あなたが<code class="code-voice">if</code>文のような条件つきの文で作業するとき、ブールの値は特に役に立ちます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">if</span> <span class="vc">turnipsAreDelicious</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;Mmm, tasty turnips!&quot;</span>)</code></li>
            <li><code class="code-voice">} <span class="kt">else</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;Eww, turnips are horrible.&quot;</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;Eww, turnips are horrible.&quot;&nbsp;<span class="jpstr">（「うー、カブ怖い。」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Conditional statements such as the <code class="code-voice">if</code> statement are covered in more detail in <span class="x-name"><a href="ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH9-ID120">Control Flow</a></span>.
<br><span class="jpstr">
<code class="code-voice">if</code>文のような条件つきの文は、更に詳細に<span class="x-name"><a href="ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH9-ID120">「制御の流れ」</a></span>で扱われます。
</span><!--end_jpstr-->
</p><p class="para">
  Swift’s type safety prevents non-Boolean values from being substituted for <code class="code-voice">Bool</code>. The following example reports a compile-time error:
<br><span class="jpstr">
スウィフトの型安全は、非ブール値が<code class="code-voice">Bool</code>の代用にされるのを妨げます。以下の例は、コンパイル時エラーを報告します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">i</span> = <span class="m">1</span></code></li>
            <li><code class="code-voice"><span class="kt">if</span> <span class="vc">i</span> {</code></li>
            <li><code class="code-voice">    <span class="c">// this example will not compile, and will report an error&nbsp;<span class="jpstr">（この例はコンパイルせず、エラーを報告します）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  However, the alternative example below is valid:
<br><span class="jpstr">
しかし、これに代わる以下の例は有効です：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">i</span> = <span class="m">1</span></code></li>
            <li><code class="code-voice"><span class="kt">if</span> <span class="vc">i</span> == <span class="m">1</span> {</code></li>
            <li><code class="code-voice">    <span class="c">// this example will compile successfully&nbsp;<span class="jpstr">（この例は、うまくコンパイルします）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The result of the <code class="code-voice">i == 1</code> comparison is of type <code class="code-voice">Bool</code>, and so this second example passes the type-check. Comparisons like <code class="code-voice">i == 1</code> are discussed in <span class="x-name"><a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID60">Basic Operators</a></span>.
<br><span class="jpstr">
<code class="code-voice">i == 1</code>の比較の結果は型<code class="code-voice">Bool</code>です、それでこの第二の例は型チェックを通ります。<code class="code-voice">i == 1</code>のような比較は<span class="x-name"><a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID60">「基本の演算子」</a></span>で議論されます。
</span><!--end_jpstr-->
</p><p class="para">
  As with other examples of type safety in Swift, this approach avoids accidental errors and ensures that the intention of a particular section of code is always clear.
<br><span class="jpstr">
スウィフトにおける型安全に関する他の例と同様に、このやり方は、偶然のエラーを避けること、そしてコードの特定の節の意図を常にはっきりさせることを確実にします。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID329"></a>
  <h3 class="section-name" tabindex="0">Tuples<br><span class="jpstr">
タプル
</span><!--end_jpstr-->
</h3>
  <p class="para">
  <em>Tuples</em> group multiple values into a single compound value. The values within a tuple can be of any type and don’t have to be of the same type as each other.
<br><span class="jpstr">
<em>タプル</em>は、複数の値を一つの複合値にまとめます。タプルの内部の値は、どんな型でもかまいません、そして互いに同じ型である必要はありません。
</span><!--end_jpstr-->
</p><p class="para">
  In this example, <code class="code-voice">(404, &quot;Not Found&quot;)</code> is a tuple that describes an <em>HTTP status code</em>. An HTTP status code is a special value returned by a web server whenever you request a web page. A status code of <code class="code-voice">404 Not Found</code> is returned if you request a webpage that doesn’t exist.
<br><span class="jpstr">
この例では、<code class="code-voice">(404, "Not Found")</code>がひとつのタプルです、それは<em>HTTP状態コード</em>を記述します。HTTP状態コードは、あなたがウェブ・ページを要請するときはいつでもウェブ・サーバーによって返されるある特別な値です。状態コード<code class="code-voice">404 Not Found</code>は、あなたが存在しないウェブ・ページを要請するならば返されます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">http404Error</span> = (<span class="m">404</span>, <span class="s">&quot;Not Found&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="c">// http404Error is of type (Int, String), and equals (404, &quot;Not Found&quot;)&nbsp;<span class="jpstr">（http404Errorは、型が(Int, String)です、そして(404, "Not Found")と等しいです）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The <code class="code-voice">(404, &quot;Not Found&quot;)</code> tuple groups together an <code class="code-voice">Int</code> and a <code class="code-voice">String</code> to give the HTTP status code two separate values: a number and a human-readable description. It can be described as “a tuple of type <code class="code-voice">(Int, String)</code>”.
<br><span class="jpstr">
この<code class="code-voice">(404, "Not Found")</code>タプルは<code class="code-voice">Int</code>と<code class="code-voice">String</code>をひとつにまとめて、HTTP状態コードに２つの別々の値：数と人間の読める説明を与えます。それは型<code class="code-voice">(Int, String)</code>のタプルとして記述されることができます。
</span><!--end_jpstr-->
</p><p class="para">
  You can create tuples from any permutation of types, and they can contain as many different types as you like. There’s nothing stopping you from having a tuple of type <code class="code-voice">(Int, Int, Int)</code>, or <code class="code-voice">(String, Bool)</code>, or indeed any other permutation you require.
<br><span class="jpstr">
あなたは、いろいろな型をどんな順列にしてタプルを作っても構いません、そして、それらはあなたが望むだけ多くの異なる型を含むことができます。あなたが<code class="code-voice">(Int, Int, Int)</code>の型のタプル、または<code class="code-voice">(String, Bool)</code>、またはあなたが実際に必要とするあらゆる他の順列を持つのを止めるものは何もありません。
</span><!--end_jpstr-->
</p><p class="para">
  You can <em>decompose</em> a tuple’s contents into separate constants or variables, which you then access as usual:
<br><span class="jpstr">
あなたはタプルの内容を個々の定数または変数に<em>分解</em>することができます。そして、あなたはそれから通常通りそれにアクセスします：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> (<span class="vc">statusCode</span>, <span class="vc">statusMessage</span>) = <span class="vc">http404Error</span></code></li>
            <li><code class="code-voice"><span class="vc">print</span>(<span class="s">&quot;The status code is </span>\(<span class="vc">statusCode</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;The status code is 404&quot;&nbsp;<span class="jpstr">（「状態コードは404です」を出力します）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="vc">print</span>(<span class="s">&quot;The status message is </span>\(<span class="vc">statusMessage</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;The status message is Not Found&quot;&nbsp;<span class="jpstr">（「状態メッセージが見つかりません」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If you only need some of the tuple’s values, ignore parts of the tuple with an underscore (<code class="code-voice">_</code>) when you decompose the tuple:
<br><span class="jpstr">
あなたがタプルの値の一部を必要とするだけならば、あなたがタプルを分解するとき、アンダースコア（<code class="code-voice">_</code>）で、タプルの一部を無視してください：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> (<span class="vc">justTheStatusCode</span>, <span class="kt">_</span>) = <span class="vc">http404Error</span></code></li>
            <li><code class="code-voice"><span class="vc">print</span>(<span class="s">&quot;The status code is </span>\(<span class="vc">justTheStatusCode</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;The status code is 404&quot;&nbsp;<span class="jpstr">（「状態コードは404です」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Alternatively, access the individual element values in a tuple using index numbers starting at zero:
<br><span class="jpstr">
あるいは、ゼロから始まっているインデックス番号を使ってタプルの個々の要素の値にアクセスしてください：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">print</span>(<span class="s">&quot;The status code is </span>\(<span class="vc">http404Error</span>.<span class="m">0</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;The status code is 404&quot;&nbsp;<span class="jpstr">（「状態コードは404です」を出力します）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="vc">print</span>(<span class="s">&quot;The status message is </span>\(<span class="vc">http404Error</span>.<span class="m">1</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;The status message is Not Found&quot;&nbsp;<span class="jpstr">（「状態メッセージが見つかりません」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can name the individual elements in a tuple when the tuple is defined:
<br><span class="jpstr">
あなたは、タプルの個々の要素に名前をつけることが、そのタプルが定義される時に可能です：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">http200Status</span> = (<span class="vc">statusCode</span>: <span class="m">200</span>, <span class="vc">description</span>: <span class="s">&quot;OK&quot;</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If you name the elements in a tuple, you can use the element names to access the values of those elements:
<br><span class="jpstr">
あなたがタプルの要素に名をつけるならば、あなたはそれらの要素の値にアクセスするために要素名を使用することができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">print</span>(<span class="s">&quot;The status code is </span>\(<span class="vc">http200Status</span>.<span class="vc">statusCode</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;The status code is 200&quot;&nbsp;<span class="jpstr">（「状態コードは200です」を出力します）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="vc">print</span>(<span class="s">&quot;The status message is </span>\(<span class="vc">http200Status</span>.<span class="vc">description</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;The status message is OK&quot;&nbsp;<span class="jpstr">（「状態メッセージはOKです」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Tuples are particularly useful as the return values of functions. A function that tries to retrieve a web page might return the <code class="code-voice">(Int, String)</code> tuple type to describe the success or failure of the page retrieval. By returning a tuple with two distinct values, each of a different type, the function provides more useful information about its outcome than if it could only return a single value of a single type. For more information, see <span class="x-name"><a href="Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID164" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH10-ID164">Functions with Multiple Return Values</a></span>.
<br><span class="jpstr">
タプルは、特に関数の戻り値として便利です。ウェブ・ページを探してくるある関数は、ページ検索の成功または失敗を記述するために<code class="code-voice">(Int, String)</code>のタプル型を返すかもしれません。２つの別の値をそれぞれ異なる型で持つひとつのタプルを返すことによって、その関数は、それが一つの型の一つの値を返すことができるだけよりも、その結果に関するより役に立つ情報を提供します。詳細は、<span class="x-name"><a href="Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID164" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH10-ID164">「複数の戻り値をもつ関数」</a></span>を見てください。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_35"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Tuples are useful for temporary groups of related values. They’re not suited to the creation of complex data structures. If your data structure is likely to persist beyond a temporary scope, model it as a class or structure, rather than as a tuple. For more information, see <span class="x-name"><a href="ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID82" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH13-ID82">Classes and Structures</a></span>.
    	<br><span class="jpstr">
タプルは、関連した値の一時的なグループに役立ちます。それらは、複雑なデータ構造物の作成には適していません。あなたのデータ構造が、一時的な範囲を越えて存続しそうならば、タプルとしてよりも、クラスまたは構造体としてそれをモデル化してください。詳細は、<span class="x-name"><a href="ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID82" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH13-ID82">クラスと構造体</a></span>を見てください。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID330"></a>
  <h3 class="section-name" tabindex="0">Optionals<br><span class="jpstr">
オプショナル
</span><!--end_jpstr-->
</h3>
  <p class="para">
  You use <em>optionals</em> in situations where a value may be absent. An optional represents two possibilities: Either there <em>is</em> a value, and you can unwrap the optional to access that value, or there <em>isn’t</em> a value at all.
<br><span class="jpstr">
あなたは<em>オプショナル</em>を、ある値が不在かもしれない状況において使います。あるオプショナルは２つの可能性を表します：ある値が存在<em>する</em>、するとあなたはそのオプショナルをアンラップすることでその値を利用できます、または値がそもそも存在<em>しない</em>かのいずれか。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_36"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">The concept of optionals doesn’t exist in C or Objective-C. The nearest thing in Objective-C is the ability to return <code class="code-voice">nil</code> from a method that would otherwise return an object, with <code class="code-voice">nil</code> meaning “the absence of a valid object.” However, this only works for objects—it doesn’t work for structures, basic C types, or enumeration values. For these types, Objective-C methods typically return a special value (such as <code class="code-voice">NSNotFound</code>) to indicate the absence of a value. This approach assumes that the method’s caller knows there’s a special value to test against and remembers to check for it. Swift’s optionals let you indicate the absence of a value for <em>any type at all</em>, without the need for special constants.
    	<br><span class="jpstr">
オプショナルの概念は、CまたはObjective-Cの中に存在しません。Objective-Cにおいて最も近いものは、オブジェクトを返すメソッドからそうできない場合に<code class="code-voice">nil</code>を返す能力です、そのとき<code class="code-voice">nil</code>は「有効なオブジェクトの欠如」を意味しています。しかし、それは単にオブジェクトのためだけに働きます ― それは構造体、基本的なC型、または列挙値のために働きません。これらの型のために、Objective-Cメソッドは、値の欠如を示すために概して特別な値（例えば<code class="code-voice">NSNotFound</code>）を返します。このアプローチは、メソッドの呼び出し側が試験するべき特別な値があるのを知っていて、それについて調べるのを忘れないでいると仮定します。スウィフトのオプショナルは、あなたに特別な定数の必要なしに<em>あらゆる全ての型</em>の値の欠如を示させます。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><p class="para">
  Here’s an example of how optionals can be used to cope with the absence of a value. Swift’s <code class="code-voice">Int</code> type has an initializer which tries to convert a <code class="code-voice">String</code> value into an <code class="code-voice">Int</code> value. However, not every string can be converted into an integer. The string <code class="code-voice">&quot;123&quot;</code> can be converted into the numeric value <code class="code-voice">123</code>, but the string <code class="code-voice">&quot;hello, world&quot;</code> doesn’t have an obvious numeric value to convert to.
<br><span class="jpstr">
ここに、値の欠如に対処するためにどのようにオプショナルが使われることができるかの１つの例があります。スウィフトの<code class="code-voice">Int</code>型はあるイニシャライザを持ちます、それは<code class="code-voice">String</code>値を<code class="code-voice">Int値</code>に変換することを試みます。しかし、すべての文字列が、整数に変えられることができるというわけでありません。文字列<code class="code-voice">"123"</code>は数の値<code class="code-voice">123</code>に変えられることができます、しかし文字列<code class="code-voice">"hello, world"</code>には変えるための明らかな数の値がありません。
</span><!--end_jpstr-->
</p><p class="para">
  The example below uses the initializer to try to convert a <code class="code-voice">String</code> into an <code class="code-voice">Int</code>:
<br><span class="jpstr">
下の例は、このイニシャライザを使用して<code class="code-voice">String</code>を<code class="code-voice">Int</code>に変えることを試みます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">possibleNumber</span> = <span class="s">&quot;123&quot;</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">convertedNumber</span> = <span class="vc">Int</span>(<span class="vc">possibleNumber</span>)</code></li>
            <li><code class="code-voice"><span class="c">// convertedNumber is inferred to be of type &quot;Int?&quot;, or &quot;optional Int&quot;&nbsp;<span class="jpstr">（convertedNumberは、型「Int?」または「オプショナルのInt」であると推論されます）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Because the initializer might fail, it returns an <em>optional</em> <code class="code-voice">Int</code>, rather than an <code class="code-voice">Int</code>. An optional <code class="code-voice">Int</code> is written as <code class="code-voice">Int?</code>, not <code class="code-voice">Int</code>. The question mark indicates that the value it contains is optional, meaning that it might contain <em>some</em> <code class="code-voice">Int</code> value, or it might contain <em>no value at all</em>. (It can’t contain anything else, such as a <code class="code-voice">Bool</code> value or a <code class="code-voice">String</code> value. It’s either an <code class="code-voice">Int</code>, or it’s nothing at all.)
<br><span class="jpstr">
このイニシャライザが失敗するかもしれないので、それは<code class="code-voice">Int</code>ではなくて、<em>オプショナル</em>の<code class="code-voice">Int</code>を返します。オプショナルの<code class="code-voice">Int</code>は、<code class="code-voice">Int?</code>のように書かれます、<code class="code-voice">Int</code>ではなく。疑問符はそれが含む値がオプショナルであることを示します、そしてそれが<em>何かの</em><code class="code-voice">Int</code>値を含むかもしれない、あるいはそれが<em>まったく値を含まない</em>かもしれないことを意味しています。 （それは、他の何か、例えば<code class="code-voice">Bool</code>値または<code class="code-voice">String</code>値などを含むことはできません。それはひとつの<code class="code-voice">Int</code>、またはそれは全く何も無いかのどちらかです。）
</span><!--end_jpstr-->
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID331"></a>
  <h3 class="section-name" tabindex="0">nil</h3>
  <p class="para">
  You set an optional variable to a valueless state by assigning it the special value <code class="code-voice">nil</code>:
<br><span class="jpstr">
あなたが、あるオプショナルの変数を値が無い状態へと設定するには、それに特別な値<code class="code-voice">nil</code>を代入します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">serverResponseCode</span>: <span class="n"><!-- a href="" -->Int<!-- /a --></span>? = <span class="m">404</span></code></li>
            <li><code class="code-voice"><span class="c">// serverResponseCode contains an actual Int value of 404&nbsp;<span class="jpstr">（serverResponseCodeは、実際にあるInt値404を含みます）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="vc">serverResponseCode</span> = <span class="kt">nil</span></code></li>
            <li><code class="code-voice"><span class="c">// serverResponseCode now contains no value&nbsp;<span class="jpstr">（serverResponseCodeは、現在は値を含みません）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_37"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">You can’t use <code class="code-voice">nil</code> with nonoptional constants and variables. If a constant or variable in your code needs to work with the absence of a value under certain conditions, always declare it as an optional value of the appropriate type.
    	<br><span class="jpstr">
あなたは、<code class="code-voice">nil</code>を非オプショナルの定数および変数で使うことができます。あなたのコードの中の定数または変数が特定の条件下で値の欠如を取り扱う必要があるならば、常に、それを適切な型のオプショナルの値として宣言してください。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><p class="para">
  If you define an optional variable without providing a default value, the variable is automatically set to <code class="code-voice">nil</code> for you:
<br><span class="jpstr">
あなたが既定値を提供することなくオプショナルの変数を定義するならば、その変数はあなたのために自動的に<code class="code-voice">nilに</code>設定されます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">surveyAnswer</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span>?</code></li>
            <li><code class="code-voice"><span class="c">// surveyAnswer is automatically set to nil&nbsp;<span class="jpstr">（surveyAnswerは、自動的にnilに設定されます）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_38"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Swift’s <code class="code-voice">nil</code> is’nt the same as <code class="code-voice">nil</code> in Objective-C. In Objective-C, <code class="code-voice">nil</code> is a pointer to a nonexistent object. In Swift, <code class="code-voice">nil</code> isn’t a pointer—it’s the absence of a value of a certain type. Optionals of <em>any</em> type can be set to <code class="code-voice">nil</code>, not just object types.
    	<br><span class="jpstr">
スウィフトの<code class="code-voice">nil</code>は、Objective-Cでの<code class="code-voice">nil</code>と同じものではありません。Objective-Cでは、<code class="code-voice">nil</code>は、ある存在しないオブジェクトへのポインターです。スウィフトでは、<code class="code-voice">nil</code>はポインターではありません ― それは、ある特定の型のある値の不在です。<em>すべての</em>型のオプショナルが、<code class="code-voice">nil</code>に設定されることができます、単にオブジェクト型だけでなく。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID332"></a>
  <h3 class="section-name" tabindex="0">If Statements and Forced Unwrapping<br><span class="jpstr">
if文と強制アンラップ
</span><!--end_jpstr-->
</h3>
  <p class="para">
  You can use an <code class="code-voice">if</code> statement to find out whether an optional contains a value by comparing the optional against <code class="code-voice">nil</code>. You perform this comparison with the “equal to” operator (<code class="code-voice">==</code>) or the “not equal to” operator (<code class="code-voice">!=</code>).
<br><span class="jpstr">
あなたは、<code class="code-voice">if</code>文を、あるオプショナルが値を含むかどうか知るために使うことができます、それは、そのオプショナルを<code class="code-voice">nil</code>と比べることによって行います。あなたは、この比較を「同等」演算子（<code class="code-voice">==</code>）または「不等」演算子（<code class="code-voice">!=</code>）を使って実行します。
</span><!--end_jpstr-->
</p><p class="para">
  If an optional has a value, it’s considered to be “not equal to” <code class="code-voice">nil</code>:
<br><span class="jpstr">
あるオプショナルが値を持つならば、それは<code class="code-voice">nil</code>と「同等でない」と判断されます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">if</span> <span class="vc">convertedNumber</span> != <span class="kt">nil</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;convertedNumber contains some integer value.&quot;</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;convertedNumber contains some integer value.&quot;&nbsp;<span class="jpstr">（「convertedNumberは、何らかの整数値を持ちます」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Once you’re sure that the optional <em>does</em> contain a value, you can access its underlying value by adding an exclamation mark (<code class="code-voice">!</code>) to the end of the optional’s name. The exclamation mark effectively says, “I know that this optional definitely has a value; please use it.” This is known as <em>forced unwrapping</em> of the optional’s value:
<br><span class="jpstr">
一旦あなたがそのオプショナルが値を含んで<em>いる</em>ことを確かめたなら、あなたは感嘆符（<code class="code-voice">!</code>）をオプショナルの名前の終わりに加えることによって、それに内在する値にアクセスすることが可能です。感嘆符は、実際上こう言っています、「私はこのオプショナルが間違いなくひとつの値を持つことを知っています；どうぞそれを使ってください」。これは、そのオプショナルの所有する値の<em>強制アンラップ</em>として知られます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">if</span> <span class="vc">convertedNumber</span> != <span class="kt">nil</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;convertedNumber has an integer value of </span>\(<span class="vc">convertedNumber</span>!)<span class="s">.&quot;</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;convertedNumber has an integer value of 123.&quot;&nbsp;<span class="jpstr">（「convertedNumberは、整数値123を持ちます」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  For more on the <code class="code-voice">if</code> statement, see <span class="x-name"><a href="ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH9-ID120">Control Flow</a></span>.
<br><span class="jpstr">
<code class="code-voice">if</code>文の詳細については、<span class="x-name"><a href="ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH9-ID120">制御の流れ</a></span>を見てください。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_39"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Trying to use <code class="code-voice">!</code> to access a nonexistent optional value triggers a runtime error. Always make sure that an optional contains a non-<code class="code-voice">nil</code> value before using <code class="code-voice">!</code> to force-unwrap its value.
    	<br><span class="jpstr">
存在しないオプショナルの値にアクセスするために<code class="code-voice">!</code>を使うことを試みることは、実行時エラーの引き金となります。必ずあるオプショナルが<code class="code-voice">nil</code>ではない値を含むことを、それの値を強制アンラップする<code class="code-voice">!</code>を使う前に確かめてください。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID333"></a>
  <h3 class="section-name" tabindex="0">Optional Binding<br><span class="jpstr">
オプショナルを束縛する（定数・変数と結び付ける）
</span><!--end_jpstr-->
</h3>
  <p class="para">
  You use <em>optional binding</em> to find out whether an optional contains a value, and if so, to make that value available as a temporary constant or variable. Optional binding can be used with <code class="code-voice">if</code> and <code class="code-voice">while</code> statements to check for a value inside an optional, and to extract that value into a constant or variable, as part of a single action. <code class="code-voice">if</code> and <code class="code-voice">while</code> statements are described in more detail in <span class="x-name"><a href="ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH9-ID120">Control Flow</a></span>.
<br><span class="jpstr">
あなたは、あるオプショナルが値を含むかどうか知るために、そしてもしそうならば、その値を一時的な定数または変数として利用可能にするために、<em>オプショナル束縛</em>を使うことができます。オプショナル束縛は、<code class="code-voice">if</code>や<code class="code-voice">while</code>文と一緒に使用して、オプショナルの内部の値を確認すること、そしてその値を定数または変数に抽出することを、一回の動作で可能にします。<code class="code-voice">if</code>および<code class="code-voice">while</code>文は更に詳細に<span class="x-name"><a href="ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH9-ID120">「制御の流れ」</a></span>で記述されます。
</span><!--end_jpstr-->
</p><p class="para">
  Write an optional binding for an <code class="code-voice">if</code> statement as follows:
<br><span class="jpstr">
オプショナルの束縛を<code class="code-voice">if</code>文のために次のように書いてください：
</span><!--end_jpstr-->
</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines">
    <li><pre class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <em class="variable-text">constantName</em> = <em class="variable-text">someOptional</em> {</pre></li><li><pre class="code-voice">    <em class="variable-text">statements</em></pre></li><li><pre class="code-voice">}</pre></li>
  </ul>
</div><p class="para">
  You can rewrite the <code class="code-voice">possibleNumber</code> example from the <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH5-ID330" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID330">Optionals</a></span> section to use optional binding rather than forced unwrapping:
<br><span class="jpstr">
あなたは<span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH5-ID330" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID330">オプショナル</a></span>節の<code class="code-voice">possibleNumber</code>例を、強制アンラップではなくて、オプショナル束縛を使うように書き直すことができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">actualNumber</span> = <span class="vc">Int</span>(<span class="vc">possibleNumber</span>) {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;\&quot;</span>\(<span class="vc">possibleNumber</span>)<span class="s">\&quot; has an integer value of </span>\(<span class="vc">actualNumber</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice">} <span class="kt">else</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;\&quot;</span>\(<span class="vc">possibleNumber</span>)<span class="s">\&quot; could not be converted to an integer&quot;</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;&quot;123&quot; has an integer value of 123&quot;&nbsp;<span class="jpstr">（「"123" has an integer value of 123」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  This code can be read as:
<br><span class="jpstr">
このコードは、次のように解釈されることができます：
</span><!--end_jpstr-->
</p><p class="para">
  “If the optional <code class="code-voice">Int</code> returned by <code class="code-voice">Int(possibleNumber)</code> contains a value, set a new constant called <code class="code-voice">actualNumber</code> to the value contained in the optional.”
<br><span class="jpstr">
「<code class="code-voice">Int(possibleNumber)</code>によって返されるオプショナルの<code class="code-voice">Int</code>が値を含むならば、ある新しい定数<code class="code-voice">actualNumber</code>をそのオプショナルに含まれる値に設定してください。」
</span><!--end_jpstr-->
</p><p class="para">
  If the conversion is successful, the <code class="code-voice">actualNumber</code> constant becomes available for use within the first branch of the <code class="code-voice">if</code> statement. It has already been initialized with the value contained <em>within</em> the optional, and so there’s no need to use the <code class="code-voice">!</code> suffix to access its value. In this example, <code class="code-voice">actualNumber</code> is simply used to print the result of the conversion.
<br><span class="jpstr">
変換が成功しているならば、定数<code class="code-voice">actualNumber</code>は、<code class="code-voice">if</code>文の最初の分岐の内部での利用に役立てられます。それは、すでにオプショナルの<em>内部に</em>含まれる値で初期化されています、それでその値にアクセスするために<code class="code-voice">!</code>接尾辞を使う必要はありません。この例では、<code class="code-voice">actualNumber</code>は単にその変換の結果を出力するために使われます。
</span><!--end_jpstr-->
</p><p class="para">
  You can use both constants and variables with optional binding. If you wanted to manipulate the value of <code class="code-voice">actualNumber</code> within the first branch of the <code class="code-voice">if</code> statement, you could write <code class="code-voice">if var actualNumber</code> instead, and the value contained within the optional would be made available as a variable rather than a constant.
<br><span class="jpstr">
あなたは、定数と変数の両方をオプショナル束縛で使用できます。あなたが<code class="code-voice">actualNumber</code>の値を<code class="code-voice">if</code>文の最初の分岐内で取り扱うことを望むならば、あなたは<code class="code-voice">if var actualNumber</code>を代わりに書くことができたでしょう、そしてオプショナル内部に含まれる値は定数ではなく変数として利用可能にされたでしょう。
</span><!--end_jpstr-->
</p><p class="para">
  You can include as many optional bindings and Boolean conditions in a single <code class="code-voice">if</code> statement as you need to, separated by commas. If any of the values in the optional bindings are <code class="code-voice">nil</code> or any Boolean condition evaluates to <code class="code-voice">false</code>, the whole <code class="code-voice">if</code> statement’s condition is considered to be <code class="code-voice">false</code>. The following <code class="code-voice">if</code> statements are equivalent:
<br><span class="jpstr">
あなたは、単一の<code class="code-voice">if</code>文の中に、コンマで区切ったオプショナル束縛とブール条件をあなたが必要とするだけ多く含めることができます。何れかのオプショナル束縛の中の値が<code class="code-voice">nil</code>であるか何かのブール条件の評価が<code class="code-voice">false</code>になるならば、<code class="code-voice">if</code>文の条件の全体が<code class="code-voice">false</code>であるとみなされます。以下の<code class="code-voice">if</code>文は同等です：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">firstNumber</span> = <span class="vc">Int</span>(<span class="s">&quot;4&quot;</span>), <span class="kt">let</span> <span class="vc">secondNumber</span> = <span class="vc">Int</span>(<span class="s">&quot;42&quot;</span>), <span class="vc">firstNumber</span> &lt; <span class="vc">secondNumber</span> &amp;&amp; <span class="vc">secondNumber</span> &lt; <span class="m">100</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;</span>\(<span class="vc">firstNumber</span>)<span class="s"> &lt; </span>\(<span class="vc">secondNumber</span>)<span class="s"> &lt; 100&quot;</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;4 &lt; 42 &lt; 100&quot;</span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">firstNumber</span> = <span class="vc">Int</span>(<span class="s">&quot;4&quot;</span>) {</code></li>
            <li><code class="code-voice">    <span class="kt">if</span> <span class="kt">let</span> <span class="vc">secondNumber</span> = <span class="vc">Int</span>(<span class="s">&quot;42&quot;</span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">if</span> <span class="vc">firstNumber</span> &lt; <span class="vc">secondNumber</span> &amp;&amp; <span class="vc">secondNumber</span> &lt; <span class="m">100</span> {</code></li>
            <li><code class="code-voice">            <span class="vc">print</span>(<span class="s">&quot;</span>\(<span class="vc">firstNumber</span>)<span class="s"> &lt; </span>\(<span class="vc">secondNumber</span>)<span class="s"> &lt; 100&quot;</span>)</code></li>
            <li><code class="code-voice">        }</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;4 &lt; 42 &lt; 100&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_40"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Constants and variables created with optional binding in an <code class="code-voice">if</code> statement are available only within the body of the <code class="code-voice">if</code> statement. In contrast, the constants and variables created with a <code class="code-voice">guard</code> statement are available in the lines of code that follow the <code class="code-voice">guard</code> statement, as described in <span class="x-name"><a href="ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID525" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH9-ID525">Early Exit</a></span>.
    	<br><span class="jpstr">
<code class="code-voice">if</code>文の中でオプショナル束縛を使って作成された定数と変数は、その<code class="code-voice">if</code>文の本文の内部でのみ利用可能です。対照的に、<code class="code-voice">guard</code>文で作成された定数と変数は、その<code class="code-voice">guard</code>文以降のコード行において利用可能です、<span class="x-name"><a href="ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID525" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH9-ID525">早期退出</a></span>において議論されるように。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID334"></a>
  <h3 class="section-name" tabindex="0">Implicitly Unwrapped Optionals<br><span class="jpstr">
暗黙的にアンラップされるオプショナル
</span><!--end_jpstr-->
</h3>
  <p class="para">
  As described above, optionals indicate that a constant or variable is allowed to have “no value”. Optionals can be checked with an <code class="code-voice">if</code> statement to see if a value exists, and can be conditionally unwrapped with optional binding to access the optional’s value if it does exist.
<br><span class="jpstr">
先に述べたように、オプショナルは、ある定数や変数が「値がない」状態でも許されることを示します。オプショナルは、値が存在しているかどうか見るために、<code class="code-voice">if</code>文を使って調べられることが出来ます、そしてオプショナルの持つ値にそれが存在するならばアクセスするために、オプショナル束縛を使って条件に応じてアンラップされることができます。
</span><!--end_jpstr-->
</p><p class="para">
  Sometimes it’s clear from a program’s structure that an optional will <em>always</em> have a value, after that value is first set. In these cases, it’s useful to remove the need to check and unwrap the optional’s value every time it’s accessed, because it can be safely assumed to have a value all of the time.
<br><span class="jpstr">
時々、プログラムの構造から、あるオプショナルが<em>必ず</em>値を持つことが、その値が最初に設定される結果として、はっきりしていることがあります。これらの場合には、オプショナルの値をそれがアクセスされるたびに確認してアンラップする必要を無くすことは役に立ちます、なぜならそれがいつでも値を持つと安全に仮定されることが出来るためです。
</span><!--end_jpstr-->
</p><p class="para">
  These kinds of optionals are defined as <em>implicitly unwrapped optionals</em>. You write an implicitly unwrapped optional by placing an exclamation mark (<code class="code-voice">String!</code>) rather than a question mark (<code class="code-voice">String?</code>) after the type that you want to make optional.
<br><span class="jpstr">
これらの種類のオプショナルは、<em>暗黙的にアンラップされるオプショナル</em>として定義されます。あなたは暗黙的にアンラップされるオプショナルを、あなたがオプショナルを作りたい型の後に疑問符（<code class="code-voice">String?</code>）ではなく感嘆符（<code class="code-voice">String!</code>）を置くことによって記述します。
</span><!--end_jpstr-->
</p><p class="para">
  Implicitly unwrapped optionals are useful when an optional’s value is confirmed to exist immediately after the optional is first defined and can definitely be assumed to exist at every point thereafter. The primary use of implicitly unwrapped optionals in Swift is during class initialization, as described in <span class="x-name"><a href="AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID55" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH20-ID55">Unowned References and Implicitly Unwrapped Optional Properties</a></span>.
<br><span class="jpstr">
暗黙的にアンラップされるオプショナルは、あるオプショナルの値が存在するのをそのオプショナルが最初に定義された直後に確かめられて、それ以降あらゆる所で存在するのを自信を持って仮定出来るようにされる場合に役に立ちます。スウィフトでの暗黙的にアンラップされるオプショナルの主要な利用法は、<span class="x-name"><a href="AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID55" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH20-ID55">非所有参照と暗黙的にアンラップされるオプショナルのプロパティ</a></span>で記述されるように、クラス初期化の間にあります。
</span><!--end_jpstr-->
</p><p class="para">
  An implicitly unwrapped optional is a normal optional behind the scenes, but can also be used like a nonoptional value, without the need to unwrap the optional value each time it’s accessed. The following example shows the difference in behavior between an optional string and an implicitly unwrapped optional string when accessing their wrapped value as an explicit <code class="code-voice">String</code>:
<br><span class="jpstr">
暗黙的にアンラップされるオプショナルは、舞台裏では普通のオプショナルです、しかしまたオプショナルでない値のように扱うこともできます、それがアクセスされるたびにオプショナルの値をアンラップする必要はありません。以下の例は、オプショナルの文字列と、暗黙的にアンラップされるオプショナルの文字列の間での、明示的な<code class="code-voice">String</code>としてラップされるそれらにアクセスする場合での、挙動の違いを示します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">possibleString</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span>? = <span class="s">&quot;An optional string.&quot;</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">forcedString</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span> = <span class="vc">possibleString</span>! <span class="c">// requires an exclamation mark</span></code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">assumedString</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span>! = <span class="s">&quot;An implicitly unwrapped optional string.&quot;</span></code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">implicitString</span>: <span class="n"><!-- a href="" -->String<!-- /a --></span> = <span class="vc">assumedString</span> <span class="c">// no need for an exclamation mark</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can think of an implicitly unwrapped optional as giving permission for the optional to be unwrapped automatically whenever it’s used. Rather than placing an exclamation mark after the optional’s name each time you use it, you place an exclamation mark after the optional’s type when you declare it.
<br><span class="jpstr">
あなたは暗黙的にアンラップされるオプショナルを、それが使われるときはいつでも自動的にアンラップされる許可をそのオプショナルに与えていると考えることができます。あなたがそれを使うたびにオプショナルの名前の後に感嘆符を置くよりも、あなたがそれを宣言する時にオプショナルの型の後に感嘆符を書きたいとあなたは思うでしょう。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_41"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">If an implicitly unwrapped optional is <code class="code-voice">nil</code> and you try to access its wrapped value, you’ll trigger a runtime error. The result is exactly the same as if you place an exclamation mark after a normal optional that doesn’t contain a value.
    	<br><span class="jpstr">
暗黙的にアンラップされるオプショナルが<code class="code-voice">nil</code>であり、あなたがそれのラップされた値にアクセスしようとするならば、あなたは実行時エラーを引き起こします。その結果は、あなたが値を含まない通常のオプショナルの後に感嘆符を置いた場合と正確に同じものです。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><p class="para">
  You can still treat an implicitly unwrapped optional like a normal optional, to check if it contains a value:
<br><span class="jpstr">
あなたは依然として暗黙的にアンラップされるオプショナルを通常のオプショナルのように扱うことができます、それが値を含むかどうか確認するためには：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">if</span> <span class="vc">assumedString</span> != <span class="kt">nil</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="vc">assumedString</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;An implicitly unwrapped optional string.&quot;&nbsp;<span class="jpstr">（「暗黙的にアンラップされるオプショナルの文字列。」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can also use an implicitly unwrapped optional with optional binding, to check and unwrap its value in a single statement:
<br><span class="jpstr">
あなたは、また、暗黙的にアンラップされるオプショナルをオプショナル束縛とともに使うことができます、一つの文でその値を確認してアンラップするためには：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">if</span> <span class="kt">let</span> <span class="vc">definiteString</span> = <span class="vc">assumedString</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="vc">definiteString</span>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;An implicitly unwrapped optional string.&quot;&nbsp;<span class="jpstr">（「暗黙的にアンラップされるオプショナルの文字列。」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_42"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Don’t use an implicitly unwrapped optional when there’s a possibility of a variable becoming <code class="code-voice">nil</code> at a later point. Always use a normal optional type if you need to check for a <code class="code-voice">nil</code> value during the lifetime of a variable.
    	<br><span class="jpstr">
ある変数がその後のある時点で<code class="code-voice">nil</code>になる可能性がある時には、暗黙的にアンラップされるオプショナルを使用しないでください。あなたがある変数の生涯のある時期に<code class="code-voice">nil</code>値について確認する必要があるならば、必ず普通のオプショナル型を使ってください。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID515"></a>
  <h3 class="section-name" tabindex="0">Error Handling<br><span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</h3>
  <p class="para">
  You use <em>error handling</em> to respond to error conditions your program may encounter during execution.
<br><span class="jpstr">
あなたは、<em>エラー処理</em>を使ってあなたのプログラムが実行の間に遭遇するエラー状態に応答することができます。
</span><!--end_jpstr-->
</p><p class="para">
  In contrast to optionals, which can use the presence or absence of a value to communicate success or failure of a function, error handling allows you to determine the underlying cause of failure, and, if necessary, propagate the error to another part of your program.
<br><span class="jpstr">
オプショナルと対比して（それは値の有無を使って、ある関数の成否を伝えることができます）、エラー処理はあなたに根本的な失敗の原因を突き止めること、そして、必要ならば、そのエラーをあなたのプログラムの別の部分に伝えることを可能にします。
</span><!--end_jpstr-->
</p><p class="para">
  When a function encounters an error condition, it <em>throws</em> an error. That function’s caller can then <em>catch</em> the error and respond appropriately.
<br><span class="jpstr">
ある関数がエラー状態に遭遇するとき、それはあるエラーを<em>スローします</em>（投げます）。その関数の呼び出し側はそのときそのエラーを<em>キャッチして</em>（捕まえて）適切に応答することができます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">canThrowAnError</span>() <span class="kt">throws</span> {</code></li>
            <li><code class="code-voice">    <span class="c">// this function may or may not throw an error&nbsp;<span class="jpstr">（この関数はエラーをスローするかもしれないししないかもしれない）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  A function indicates that it can throw an error by including the <code class="code-voice">throws</code> keyword in its declaration. When you call a function that can throw an error, you prepend the <code class="code-voice">try</code> keyword to the expression.
<br><span class="jpstr">
ある関数は、それがエラーをスローできることを<code class="code-voice">throws</code>キーワードをそれの宣言に含めることによって示します。あなたがエラーをスローできる関数を呼ぶとき、あなたは<code class="code-voice">try</code>キーワードをその式の前に追加します。
</span><!--end_jpstr-->
</p><p class="para">
  Swift automatically propagates errors out of their current scope until they’re handled by a <code class="code-voice">catch</code> clause.
<br><span class="jpstr">
スウィフトは自動的に、エラーをそれの現在のスコープの外に、それが<code class="code-voice">catch</code>節によって取り扱われるまで伝えます。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">do</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">try</span> <span class="vc">canThrowAnError</span>()</code></li>
            <li><code class="code-voice">    <span class="c">// no error was thrown&nbsp;<span class="jpstr">（エラーはスローされなかった）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">} <span class="kt">catch</span> {</code></li>
            <li><code class="code-voice">    <span class="c">// an error was thrown&nbsp;<span class="jpstr">（エラーがスローされた）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  A <code class="code-voice">do</code> statement creates a new containing scope, which allows errors to be propagated to one or more <code class="code-voice">catch</code> clauses.
<br><span class="jpstr">
<code class="code-voice">do</code>文はひとつの新しく取り囲んでいるスコープを作成します、それはエラーに１つ以上の<code class="code-voice">catch</code>節に伝えられることを可能にします。
</span><!--end_jpstr-->
</p><p class="para">
  Here’s an example of how error handling can be used to respond to different error conditions:
<br><span class="jpstr">
ここにどのようにエラー処理が異なるエラー状態に応答するために使われることができるかの例があります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">func</span> <span class="vc">makeASandwich</span>() <span class="kt">throws</span> {</code></li>
            <li><code class="code-voice">    <span class="c">// ...</span></code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">do</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">try</span> <span class="vc">makeASandwich</span>()</code></li>
            <li><code class="code-voice">    <span class="vc">eatASandwich</span>()</code></li>
            <li><code class="code-voice">} <span class="kt">catch</span> <span class="vc">SandwichError</span>.<span class="vc">outOfCleanDishes</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">washDishes</span>()</code></li>
            <li><code class="code-voice">} <span class="kt">catch</span> <span class="vc">SandwichError</span>.<span class="vc">missingIngredients</span>(<span class="kt">let</span> <span class="vc">ingredients</span>) {</code></li>
            <li><code class="code-voice">    <span class="vc">buyGroceries</span>(<span class="vc">ingredients</span>)</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  In this example, the <code class="code-voice">makeASandwich()</code> function will throw an error if no clean dishes are available or if any ingredients are missing. Because <code class="code-voice">makeASandwich()</code> can throw an error, the function call is wrapped in a <code class="code-voice">try</code> expression. By wrapping the function call in a <code class="code-voice">do</code> statement, any errors that are thrown will be propagated to the provided <code class="code-voice">catch</code> clauses.
<br><span class="jpstr">
この例において、<code class="code-voice">makeASandwich()</code>関数は、綺麗な皿が利用可能でないならばまたは何の食材も見つからないならばエラーをスローします。<code class="code-voice">makeASandwich()</code>はエラーをスロー可能なので、この関数呼び出しは<code class="code-voice">try</code>式で包まれます。その関数呼び出しを<code class="code-voice">do</code>文の中に包み込むことによって、スローされるどんなエラーも添付の<code class="code-voice">catch</code>節に伝えられるようになります。
</span><!--end_jpstr-->
</p><p class="para">
  If no error is thrown, the <code class="code-voice">eatASandwich()</code> function is called. If an error is thrown and it matches the <code class="code-voice">SandwichError.outOfCleanDishes</code> case, then the <code class="code-voice">washDishes()</code> function will be called. If an error is thrown and it matches the <code class="code-voice">SandwichError.missingIngredients</code> case, then the <code class="code-voice">buyGroceries(_:)</code> function is called with the associated <code class="code-voice">[String]</code> value captured by the <code class="code-voice">catch</code> pattern.
<br><span class="jpstr">
エラーがスローされないならば、<code class="code-voice">eatASandwich()</code>関数が呼び出されます。エラーがスローされてそれが<code class="code-voice">SandwichError.outOfCleanDishes</code>ケース節にマッチするならば、そのとき<code class="code-voice">washDishes()</code>関数が呼ばれます。エラーがスローされてそれが<code class="code-voice">SandwichError.missingIngredients</code>ケース節にマッチするならば、そのとき<code class="code-voice">buyGroceries(_:)</code>関数がその<code class="code-voice">catch</code>パターンによってキャプチャされた<code class="code-voice">[String]</code>関連値とともに呼ばれます。
</span><!--end_jpstr-->
</p><p class="para">
  Throwing, catching, and propagating errors is covered in greater detail in <span class="x-name"><a href="ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH42-ID508">Error Handling</a></span>.
<br><span class="jpstr">
エラーのスロー、キャッチ、そして伝達は、詳細に<span class="x-name"><a href="ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH42-ID508">エラー処理</a></span>において扱われます。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID335"></a>
  <h3 class="section-name" tabindex="0">Assertions and Preconditions<br><span class="jpstr">
表明と前提条件
</span><!--end_jpstr-->
</h3>
  <p class="para">
  <em>Assertions</em> and <em>preconditions</em> are checks that happen at runtime. You use them to make sure an essential condition is satisfied before executing any further code. If the Boolean condition in the assertion or precondition evaluates to <code class="code-voice">true</code>, code execution continues as usual. If the condition evaluates to <code class="code-voice">false</code>, the current state of the program is invalid; code execution ends, and your app is terminated.
<br><span class="jpstr">
<em>表明</em>と<em>前提条件</em>は、起こることを実行時で調べられます。あなたはそれらを使って、必要不可欠な条件が満たされるのを何らかのその先のコードが実行される前に確実なものにします。表明または前提条件におけるブール条件が<code class="code-voice">true</code>に評価されるならば、コードは普段通り続けて実行されます。条件が<code class="code-voice">false</code>に評価されるならば、プログラムの現在の状態は無効です；コード実行は止まり、そしてあなたのアプリは終了させられます。
</span><!--end_jpstr-->
</p><p class="para">
  You use assertions and preconditions to express the assumptions you make and the expectations you have while coding, so you can include them as part of your code. Assertions help you find mistakes and incorrect assumptions during development, and preconditions help you detect issues in production.
<br><span class="jpstr">
あなたは表明と前提条件を使うことであなたのする想定とあなたが持つ期待をコーディングの間に表します、それであなたはそれらをあなたのコードの一部として含めることができます。表明は、あなたが失策や間違った想定を見つけるのを開発中に助けます、そして前提条件は、あなたが製品における問題点を見抜くのを助けます。
</span><!--end_jpstr-->
</p><p class="para">
  In addition to verifying your expectations at runtime, assertions and preconditions also become a useful form of documentation within the code. Unlike the error conditions discussed in <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH5-ID515" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID515">Error Handling</a></span> above, assertions and preconditions aren’t used for recoverable or expected errors. Because a failed assertion or precondition indicates an invalid program state, there’s no way to catch a failed assertion.
<br><span class="jpstr">
あなたの期待を実行時で実証するのに加えて、表明と前提条件はまたコード内部での有用な文書化形式となります。上の<span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH5-ID515" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID515">エラー処理</a></span>で議論されるエラー条件とは違い、表明と前提条件は回復できるまたは予想されたエラーに対して使われません。失敗した表明または前提条件は無効なプログラム状態を示すことから、失敗した表明を受け止めるための方法はありません。
</span><!--end_jpstr-->
</p><p class="para">
  Using assertions and preconditions isn’t a substitute for designing your code in such a way that invalid conditions are unlikely to arise. However, using them to enforce valid data and state causes your app to terminate more predictably if an invalid state occurs, and helps makes the problem easier to debug. Stopping execution as soon as an invalid state is detected also helps limit the damage caused by that invalid state.
<br><span class="jpstr">
表明と前提条件を使用することは、無効な条件が思いもよらず起こるようなあなたのコードの設計に対する代役ではありません。しかしながら、それらを使って有効なデータと状態を遵守させることは、あなたのアプリに不正な状態が生じる場合により予測のつく結びとなるようにします、そして問題をより簡単にデバッグする助けとなります。無効な状態が検知されるやいなや実行を停止することはまた、その無効な状態によって起こされる被害を抑えます。
</span><!--end_jpstr-->
</p><p class="para">
  The difference between assertions and preconditions is in when they’re checked: Assertions are checked only in debug builds, but preconditions are checked in both debug and production builds. In production builds, the condition inside an assertion isn’t evaluated. This means you can use as many assertions as you want during your development process, without impacting performance in production.
<br><span class="jpstr">
表明と前提条件の間の違いは、それらが調べられる時にあります：表明はデバッグビルドにおいてのみ調べられます、しかし前提条件はデバッグおよび製品（プロダクション）ビルドの両方において調べられます。プロダクションビルドでは、表明内の条件は評価されません。これが意味するのは、あなたは多くの表明をあなたが望むだけあなたの開発過程の間に使用できる、製品での性能に影響を与えることなしに、ということです。
</span><!--end_jpstr-->
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID336"></a>
  <h3 class="section-name" tabindex="0">Debugging with Assertions<br><span class="jpstr">
表明を使ってデバッグする
</span><!--end_jpstr-->
</h3>
  <p class="para">
  You write an assertion by calling the <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/1541112-assert" class="urlLink">assert(_:_:file:line:)</a></code> function from the Swift standard library. You pass this function an expression that evaluates to <code class="code-voice">true</code> or <code class="code-voice">false</code> and a message to display if the result of the condition is <code class="code-voice">false</code>. For example:
<br><span class="jpstr">
あなたは表明を<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/1541112-assert" class="urlLink">assert(_:_:file:line:)</a></code>関数をSwift標準ライブラリから呼び出すことによって記述します。あなたはこの関数に、<code class="code-voice">true</code>または<code class="code-voice">false</code>に評価する式と条件の結果が<code class="code-voice">false</code>であるならば表示するメッセージを渡します。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">age</span> = <span class="m">-3</span></code></li>
            <li><code class="code-voice"><span class="vc">assert</span>(<span class="vc">age</span> &gt;= <span class="m">0</span>, <span class="s">&quot;A person&#39;s age can&#39;t be less than zero.&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="c">// This assertion fails because -3 is not &gt;= 0.&nbsp;<span class="jpstr">（この表明は失敗する、なぜなら-3 は &gt;= 0 ではないから。）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  In this example, code execution continues if <code class="code-voice">age &gt;= 0</code> evaluates to <code class="code-voice">true</code>, that is, if the value of <code class="code-voice">age</code> is nonnegative. If the value of <code class="code-voice">age</code> is negative, as in the code above, then <code class="code-voice">age &gt;= 0</code> evaluates to <code class="code-voice">false</code>, and the assertion fails, terminating the application.
<br><span class="jpstr">
この例において、コード実行は<code class="code-voice">age &gt;= 0</code>が<code class="code-voice">true</code>に評価されるならば、すなわち<code class="code-voice">age</code>の値が負でないならば継続します。<code class="code-voice">age</code>の値が負であるならば、上のコードでのように、そのとき<code class="code-voice">age &gt;= 0</code>は<code class="code-voice">false</code>に評価され、そして表明は失敗して、アプリケーションを終了します。
</span><!--end_jpstr-->
</p><p class="para">
  You can omit the assertion message—for example, when it would just repeat the condition as prose.
<br><span class="jpstr">
あなたは表明メッセージを省略できます — 例えば、それが単に条件を単調に繰り返す場合。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">assert</span>(<span class="vc">age</span> &gt;= <span class="m">0</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If the code already checks the condition, you use the <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/1539616-assertionfailure" class="urlLink">assertionFailure(_:file:line:)</a></code> function to indicate that an assertion has failed. For example:
<br><span class="jpstr">
コードがすでに条件を調べるならば、あなたは<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/1539616-assertionfailure" class="urlLink">assertionFailure(_:file:line:)</a></code>関数を使って表明が失敗していることを示してください。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">if</span> <span class="vc">age</span> &gt; <span class="m">10</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;You can ride the roller-coaster or the ferris wheel.&quot;</span>)</code></li>
            <li><code class="code-voice">} <span class="kt">else</span> <span class="kt">if</span> <span class="vc">age</span> &gt; <span class="m">0</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">&quot;You can ride the ferris wheel.&quot;</span>)</code></li>
            <li><code class="code-voice">} <span class="kt">else</span> {</code></li>
            <li><code class="code-voice">    <span class="vc">assertionFailure</span>(<span class="s">&quot;A person&#39;s age can&#39;t be less than zero.&quot;</span>)</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-ID554"></a>
  <h3 class="section-name" tabindex="0">Enforcing Preconditions<br><span class="jpstr">
前提条件の遵守
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Use a precondition whenever a condition has the potential to be false, but must <em>definitely</em> be true for your code to continue execution. For example, use a precondition to check that a subscript is not out of bounds, or to check that a function has been passed a valid value.
<br><span class="jpstr">
ある条件が偽である可能性をもつ、しかし<em>definitely</em>があなたのコードの実行の継続のためにtrueでなければならない時はいつでも前提条件を使ってください。例えば、前提時要件を使って、ある添え字が範囲外でないことを調べてください、またはある関数が有効な値を渡されていることを確認してください。
</span><!--end_jpstr-->
</p><p class="para">
  You write a precondition by calling the <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/1540960-precondition" class="urlLink">precondition(_:_:file:line:)</a></code> function. You pass this function an expression that evaluates to <code class="code-voice">true</code> or <code class="code-voice">false</code> and a message to display if the result of the condition is <code class="code-voice">false</code>. For example:
<br><span class="jpstr">
あなたは、前提条件を<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/1540960-precondition" class="urlLink">precondition(_:_:file:line:)</a></code>関数を呼び出すことによって記述します。あなたはこの関数に、<code class="code-voice">true</code>または<code class="code-voice">false</code>に評価する式と条件の結果が<code class="code-voice">false</code>であるならば表示するメッセージを渡します。例えば：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="c">// In the implementation of a subscript...&nbsp;<span class="jpstr">（ある添え字の実装において...）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="vc">precondition</span>(<span class="vc">index</span> &gt; <span class="m">0</span>, <span class="s">&quot;Index must be greater than zero.&quot;</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can also call the <code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/1539374-preconditionfailure" class="urlLink">preconditionFailure(_:file:line:)</a></code> function to indicate that a failure has occurred—for example, if the default case of a switch was taken, but all valid input data should have been handled by one of the switch’s other cases.
<br><span class="jpstr">
あなたはまた、<code class="code-voice u-api"><a href="https://developer.apple.com/documentation/swift/1539374-preconditionfailure" class="urlLink">preconditionFailure(_:file:line:)</a></code>関数を呼び出して失敗がすでに起こっていることを示すことができます — 例えば、あるスイッチ文の省略時のケース節が取られた、しかし全ての有効な入力データがそのスイッチ文の他のケース節の１つによって取り扱われてしまっている場合。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH5-NoLink_43"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">If you compile in unchecked mode (<code class="code-voice">-Ounchecked</code>), preconditions aren’t checked. The compiler assumes that preconditions are always true, and it optimizes your code accordingly. However, the <code class="code-voice">fatalError(_:file:line:)</code> function always halts execution, regardless of optimization settings.
    	<br><span class="jpstr">
あなたが未検査モード（<code class="code-voice">-Ounchecked</code>）でコンパイルするならば、前提条件は調べられません。コンパイラは、その前提条件が常にtrueであるとみなします、そしてそれはあなたのコードをそれを受けて最適化します。しかしながら、<code class="code-voice">fatalError(_:file:line:)</code>関数は常に実行を停止します、最適化設定に関係なく。
</span><!--end_jpstr-->
</p>
    <p class="para">
  You can use the <code class="code-voice">fatalError(_:file:line:)</code> function during prototyping and early development to create stubs for functionality that hasn’t been implemented yet, by writing <code class="code-voice">fatalError(&quot;Unimplemented&quot;)</code> as the stub implementation. Because fatal errors are never optimized out, unlike assertions or preconditions, you can be sure that execution always halts if it encounters a stub implementation.
<br><span class="jpstr">
あなたは、<code class="code-voice">fatalError(_:file:line:)</code>関数を試作段階および開発初期の間に使って、まだ実装されていない機能性に対してスタブ（代用品）を作成することが、<code class="code-voice">fatalError("Unimplemented")</code>をスタブ実装として記述することによって行えます。致命的なエラーは決して間違って最適化されません、表明や前提条件と違います、あなたは実行が常に停止することをそれがスタブ実装に遭遇する場合には確信できます。
</span><!--end_jpstr-->
</p>

  </aside>
</div>
  
</section>

</section>

  	
 	<section id="next_previous" class="">
    		<p class="previous-link"><a href="GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-ID1" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH2-ID1">A Swift Tour<br><span class="jpstr">
スウィフトツアー
</span><!--end_jpstr-->
</a></p>
  			<p class="next-link"><a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID60">Basic Operators<br><span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></p>

    <p class="copyright">Copyright &#x00a9; 2017 Apple Inc. All rights reserved. 
  <a class="link" href="http://www.apple.com/legal/terms/site.html" target="_blank" rel="external">Terms of Use</a> | 
  <a class="link" href="http://www.apple.com/privacy/" target="_blank" rel="external">Privacy Policy</a> | 
  Updated: 2017-08-21
</p>
  </section>
</article>

    </div>
    <div id='big_button'></div>
    <footer id="footer">
  <div class="content-wrapper">
  	<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
  </div>
  <script src="../../../../Resources/1264/JavaScript/devpubs-1.6.3.js" type="text/javascript" charset="utf-8"></script>
  <script src="../../../../Resources/1264/JavaScript/feedback-1.6.3.js" type="text/javascript" charset="utf-8"></script>
  <div id="_omniture_top">
<!-- SiteCatalyst code version: H.8. Copyright 1997-2006 Omniture, Inc. -->
<script type="text/javascript">
/* RSID: */
var s_account="appleglobal,appleusdeveloper,dappdeveloperlib"
</script>

<!-- <script type="text/javascript" src="https://www.apple.com/metrics/scripts/s_code_h.js"></script> -->
<script type="text/javascript">
s.pageName=AC.Tracking.pageName();
s.channel="www.us.developer"

/************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
var s_code=s.t();if(s_code)document.write(s_code)</script>
<!-- End SiteCatalyst code version: H.8. -->
</div>

</footer>

    
  </body>
    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="https://developer.apple.com/bugreporter/" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

</div>
</html>
