<!DOCTYPE html>
<html lang="en">
  <head>  
  <title>The Swift Programming Language (Swift 4): Automatic Reference Counting</title>
  <link rel="stylesheet" type="text/css" href="../../../../Resources/1264/CSS/style-1.6.3.css" />
  <link rel="stylesheet" type="text/css" href="../../../../Resources/1264/CSS/feedback-1.6.3.css" />
  <meta charset='utf-8'> 
<meta id="j-version" name="j-version" content="" />
<meta id="build" name="build" content="73a86ab2241a413ce0c3e0e8d970ff25" />
<meta id="document-version" name="document-version" content="10.0.12" />
<meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Topic/Swift}" />
<meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/TP40014097" />
<meta id="chapterId" name="chapterId" content="TP40014097-CH20">
<meta id="book-title" name="book-title" content="The Swift Programming Language (Swift 4)" />
<meta id="book-resource-type" name="book-resource-type" content="Guide" />
<meta id="book-root" name="book-root" content="./" />
<meta id="book-json" name="book-json" content="book.json">
<meta id="date" name="date" content="2017-09-12" />
<meta id="description" name="description" content="The definitive guide to Swift, Apple’s programming language for building iOS, macOS, watchOS, and tvOS apps." />
<meta id="IndexTitle" name="IndexTitle" content="" />
<meta id="resources-uri" name="resources-uri" content="../../../../Resources/1264">
<link id="book-index-page" rel="Start" title="" type="text/html" href="./index.html">
<!-- , next_chapter: next_chapter, previous_chapter: previous_chapter -->
<link id="next-page" rel="Next" type="text/html" href="">
<link id="previous-page" rel="Prev" type="text/html" href="">
<meta id="devcenter" name="devcenter" content="<!-- DEVCENTER_NAME -->" />
<meta id="devcenter-url" name="devcenter-url" content="<!-- DEVCENTER_URL -->" />
<meta id="reflib" name="reflib" content="<!-- REFLIB_NAME -->" />

<meta id="xcode-display" name="xcode-display" content="render" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<meta id="platforms" name="platforms" content="Xcode Developer Tools">
</head>

  <body id="conceptual_flow_with_tasks" class="jazz">
    
    <header id="ios_header" class="hideOnPrint hideInXcode">
  <div class="content-wrapper">
    <p class="header-text">
    	<a href="../../../../navigation/index.html">Guides and Sample Code
 		</a>
 </p>
    <p id="wwdr"><img id="apple_logo" src="../../../../Resources/1264/Images/apple2.png" height="14px" width="12px" aria-hidden="true" /><a href="https://developer.apple.com">Developer</a></p>
  </div>
</header>

    <section id="valence">
  <div class="content-wrapper">
    <p id="hierarchial_navigation">
      <span id="book_title">The Swift Programming Language (Swift 4)</span>
    </p>
    <form id="search" class="hideInXcode" method="get" action="/search/index.php" accept-charset="utf-8" autocomplete="off">
  <input type="search" id="ssi_SearchField" placeholder="Search Guides and Sample Code" name="q" autocomplete="off" tabindex="2" />
</form>

      
   
   




    <span class="download-text hideInXcode">
      <a href="https://itunes.apple.com/us/book/the-swift-programming-language/id1002622538?mt=11">iBooks</a>
    </span>

    

    <img id="shortstack" src="../../../../Resources/1264/Images/shortstack_2x.png"/>
  </div>
</section>
    <div class="content-wrapper">
      <nav id="navigator" class="book-parts hideInXcode" role="navigation">
    <ul class="nav-parts">
        <li data-id="//apple_ref/doc/uid/TP40014097-CH1-ID2"
            class="part-name">
            <a href="index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH3-ID0">Welcome to Swift<br><span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH3-ID0">About Swift<br><span class="jpstr">
スウィフトについて
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Compatibility.html#//apple_ref/doc/uid/TP40014097-CH45-ID561" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH45-ID561">Version Compatibility<br><span class="jpstr">
バージョン互換性
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-ID1" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH2-ID1">A Swift Tour<br><span class="jpstr">
スウィフトツアー
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014097-CH4-ID233"
            class="part-name nav-part-active open-part">
            <a href="TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID309">Language Guide<br><span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID309">The Basics<br><span class="jpstr">
基本
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID60" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH6-ID60">Basic Operators<br><span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID285" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH7-ID285">Strings and Characters<br><span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-ID105" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH8-ID105">Collection Types<br><span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID120" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH9-ID120">Control Flow<br><span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH10-ID158">Functions<br><span class="jpstr">
関数
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH11-ID94">Closures<br><span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH12-ID145">Enumerations<br><span class="jpstr">
列挙
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID82" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH13-ID82">Classes and Structures<br><span class="jpstr">
クラスと構造体
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH14-ID254">Properties<br><span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID234" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH15-ID234">Methods<br><span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Subscripts.html#//apple_ref/doc/uid/TP40014097-CH16-ID305" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH16-ID305">Subscripts<br><span class="jpstr">
添え字
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-ID193" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH17-ID193">Inheritance<br><span class="jpstr">
継承
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH18-ID203">Initialization<br><span class="jpstr">
初期化
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Deinitialization.html#//apple_ref/doc/uid/TP40014097-CH19-ID142" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH19-ID142">Deinitialization<br><span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter nav-current-chapter">
              	<a href="#//apple_ref/doc/uid/TP40014097-CH20-ID48" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH20-ID48">Automatic Reference Counting<br><span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH21-ID245">Optional Chaining<br><span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH42-ID508">Error Handling<br><span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22-ID338" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH22-ID338">Type Casting<br><span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="NestedTypes.html#//apple_ref/doc/uid/TP40014097-CH23-ID242" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH23-ID242">Nested Types<br><span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH24-ID151">Extensions<br><span class="jpstr">
拡張
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH25-ID267">Protocols<br><span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH26-ID179">Generics<br><span class="jpstr">
総称体
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-ID3" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH41-ID3">Access Control<br><span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID28" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH27-ID28">Advanced Operators<br><span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014097-CH28-ID427"
            class="part-name">
            <a href="AboutTheLanguageReference.html#//apple_ref/doc/uid/TP40014097-CH29-ID345" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH29-ID345">Language Reference<br><span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="AboutTheLanguageReference.html#//apple_ref/doc/uid/TP40014097-CH29-ID345" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH29-ID345">About the Language Reference<br><span class="jpstr">
言語リファレンスについて
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="LexicalStructure.html#//apple_ref/doc/uid/TP40014097-CH30-ID410" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH30-ID410">Lexical Structure<br><span class="jpstr">
語彙の構造
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Types.html#//apple_ref/doc/uid/TP40014097-CH31-ID445" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH31-ID445">Types<br><span class="jpstr">
型
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID383" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH32-ID383">Expressions<br><span class="jpstr">
式
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Statements.html#//apple_ref/doc/uid/TP40014097-CH33-ID428" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH33-ID428">Statements<br><span class="jpstr">
文
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID351" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH34-ID351">Declarations<br><span class="jpstr">
宣言
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Attributes.html#//apple_ref/doc/uid/TP40014097-CH35-ID347" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH35-ID347">Attributes<br><span class="jpstr">
属性
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="Patterns.html#//apple_ref/doc/uid/TP40014097-CH36-ID419" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH36-ID419">Patterns<br><span class="jpstr">
パターン
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="GenericParametersAndArguments.html#//apple_ref/doc/uid/TP40014097-CH37-ID406" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH37-ID406">Generic Parameters and Arguments<br><span class="jpstr">
総称体パラメータと引数
</span><!--end_jpstr-->
</a>
              </li>
              <li class="nav-chapter">
              	<a href="zzSummaryOfTheGrammar.html#//apple_ref/doc/uid/TP40014097-CH38-ID458" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH38-ID458">Summary of the Grammar<br><span class="jpstr">
文法の概要
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
        <li data-id="//apple_ref/doc/uid/TP40014097-CH39-ID460"
            class="part-name">
            <a href="RevisionHistory.html#//apple_ref/doc/uid/TP40014097-CH40-ID459" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH40-ID459">Revision History<br><span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a>
          <ul class="nav-chapters">
              <li class="nav-chapter">
              	<a href="RevisionHistory.html#//apple_ref/doc/uid/TP40014097-CH40-ID459" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH40-ID459">Document Revision History<br><span class="jpstr">
文書改訂履歴
</span><!--end_jpstr-->
</a>
              </li>
          </ul>
        </li>
    </ul>
</nav>

      <menu id="bashful" type="toolbar">
  <div class="shield"></div>
  <menuitem id="jump_to" class="menu-bar-item closed">
  <span>On This Page</span>
  <div class="chevron">
    <div class="chevy chevron-left"></div>
    <div class="chevy chevron-right"></div>
  </div>
  <menu type="list" class="details">
      <ul class="list-bullet">
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH20-ID49">How ARC Works</a>
<br><span class="jpstr">
ARCは、どのように働きますか
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH20-ID50">ARC in Action</a>
<br><span class="jpstr">
ARCの動作
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH20-ID51">Strong Reference Cycles Between Class Instances</a>
<br><span class="jpstr">
クラスインスタンス間の強い参照循環
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH20-ID52">Resolving Strong Reference Cycles Between Class Instances</a>
<br><span class="jpstr">
クラスインスタンス間の強い参照循環の解消
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH20-ID56">Strong Reference Cycles for Closures</a>
<br><span class="jpstr">
クロージャのための強い参照循環
</span><!--end_jpstr-->
          </li>
          <li class="item">
            <a href="#//apple_ref/doc/uid/TP40014097-CH20-ID57">Resolving Strong Reference Cycles for Closures</a>
<br><span class="jpstr">
クロージャのための強い参照循環の解消
</span><!--end_jpstr-->
          </li>
      </ul>
  </menu>
</menuitem>

</menu>
<div class="pixel-line"></div>
<div class="rubber-band-gap"></div>
<article class="chapter">
  <a name="//apple_ref/doc/uid/TP40014097-CH20"></a><a name="//apple_ref/doc/uid/TP40014097-CH20-ID48"></a>

  <h2 class='chapter-name'>Automatic Reference Counting<br><span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</h2>


  
  	<section class="section">
  		<p class="para">
  Swift uses <em>Automatic Reference Counting</em> (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you do not need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed.
<br><span class="jpstr">
スウィフトは、あなたのアプリのメモリ使用を追跡して管理するために、<em>自動参照カウント（ARC）</em>を使います。ほとんどの場合、これは、スウィフトにおいてメモリ管理が「正確に機能する」こと、そしてあなたはあなた自身でメモリ管理について考える必要がないことを意味します。ARCはクラスインスタンスによって使われるメモリを、それらのインスタンスがもはや必要でないとき、自動的に自由にします。
</span><!--end_jpstr-->
</p>
<p class="para">
  However, in a few cases ARC requires more information about the relationships between parts of your code in order to manage memory for you. This chapter describes those situations and shows how you enable ARC to manage all of your app’s memory. Using ARC in Swift is very similar to the approach described in <em class="u-book"><a href="../../../../releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226" data-renderer-version="1" target="_self">Transitioning to ARC Release Notes</a></em> for using ARC with Objective-C.
<br><span class="jpstr">
しかし、２、３の場合には、ARCは、あなたのためにメモリを管理するために、あなたのコードの部分間の関係に関するより多くの情報を要求します。この章は、それらの状況を記載して、あなたがどのようにARCにあなたのアプリのメモリの全てを管理させるかについて示します。スウィフトでのARCの使用は、Objective-CでARCを使うための<em class="u-book"><a href="../../../../releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226" data-renderer-version="1" target="_self">Transitioning to ARC Release Notes</a></em>で記述される取り組みに非常に似ています。
</span><!--end_jpstr-->
</p>
<div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-NoLink_150"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Reference counting only applies to instances of classes. Structures and enumerations are value types, not reference types, and are not stored and passed by reference.
    	<br><span class="jpstr">
参照カウントは、クラスのインスタンスに適用されるだけです。構造と列挙は値型であって、参照型ではありません、そして参照によって格納されたり渡されたりしません。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>

		</section> 


  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-ID49"></a>
  <h3 class="section-name" tabindex="0">How ARC Works<br><span class="jpstr">
ARCは、どのように働きますか
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Every time you create a new instance of a class, ARC allocates a chunk of memory to store information about that instance. This memory holds information about the type of the instance, together with the values of any stored properties associated with that instance.
<br><span class="jpstr">
あなたがクラスの新しいインスタンスをつくるたびに、ARCはメモリのある量を割り当てて、そのインスタンスに関する情報を格納します。このメモリは、インスタンスの型に関する情報を、そのインスタンスと結びつけられるあらゆる格納プロパティの値と共に持ちます。
</span><!--end_jpstr-->
</p><p class="para">
  Additionally, when an instance is no longer needed, ARC frees up the memory used by that instance so that the memory can be used for other purposes instead. This ensures that class instances do not take up space in memory when they are no longer needed.
<br><span class="jpstr">
その上に、インスタンスがもはや必要でないとき、ARCはそのインスタンスによって使われるメモリを開放します、それでメモリが代わりに他の目的のために使われることができます。これは、クラスインスタンスが、それらがもはや必要でない時に、メモリ上で場所を取らないことを確実にします。
</span><!--end_jpstr-->
</p><p class="para">
  However, if ARC were to deallocate an instance that was still in use, it would no longer be possible to access that instance’s properties, or call that instance’s methods. Indeed, if you tried to access the instance, your app would most likely crash.
<br><span class="jpstr">
しかし、ARCがまだ使用中だったインスタンスの割り当て解除をすることになったならば、そのインスタンスのプロパティにアクセスすることや、そのインスタンスのメソッドを呼ぶことは、もはや可能でないでしょう。実はそれどころか、あなたがそのインスタンスにアクセスしようとするならば、あなたのアプリはたぶんクラッシュするでしょう。
</span><!--end_jpstr-->
</p><p class="para">
  To make sure that instances don’t disappear while they are still needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance. ARC will not deallocate an instance as long as at least one active reference to that instance still exists.
<br><span class="jpstr">
それがまだ必要な間にインスタンスが消えないことを確実にするために、ARCは、どれくらいのプロパティ、定数、および変数が目下のところ各クラスインスタンスに言及しているかを追跡します。ARCは、そのインスタンスへの少なくとも１つの活発な参照がまだ存在する限り、インスタンスの割り当て解除をしません。
</span><!--end_jpstr-->
</p><p class="para">
  To make this possible, whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a <em>strong reference</em> to the instance. The reference is called a “strong” reference because it keeps a firm hold on that instance, and does not allow it to be deallocated for as long as that strong reference remains.
<br><span class="jpstr">
これを可能にするために、あなたがクラスインスタンスをプロパティ、定数、または変数に代入するときはいつでも、そのプロパティ、定数、または変数はそのインスタンスへの<em>強い参照</em>を作ります。この参照が「強い」参照と呼ばれるのはそれがそのインスタンスに対する堅い支配力を保つからです、そしてその強い参照が残る限りは、そのインスタンスがメモリ割り当て解除されるのを許しません。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-ID50"></a>
  <h3 class="section-name" tabindex="0">ARC in Action<br><span class="jpstr">
ARCの動作
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Here’s an example of how Automatic Reference Counting works. This example starts with a simple class called <code class="code-voice">Person</code>, which defines a stored constant property called <code class="code-voice">name</code>:
<br><span class="jpstr">
自動参照カウントがどのように働くかの例は、ここにあります。この例は、<code class="code-voice">Person</code>と呼ばれる単純なクラスから始めます、それは、<code class="code-voice">name</code>と呼ばれる格納定数プロパティを定義します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">Person</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">name</span> = <span class="vc">name</span></code></li>
            <li><code class="code-voice">        <span class="vc">print</span>(<span class="s">&quot;</span>\(<span class="vc">name</span>)<span class="s"> is being initialized&quot;</span>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    <span class="kt">deinit</span> {</code></li>
            <li><code class="code-voice">        <span class="vc">print</span>(<span class="s">&quot;</span>\(<span class="vc">name</span>)<span class="s"> is being deinitialized&quot;</span>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The <code class="code-voice">Person</code> class has an initializer that sets the instance’s <code class="code-voice">name</code> property and prints a message to indicate that initialization is underway. The <code class="code-voice">Person</code> class also has a deinitializer that prints a message when an instance of the class is deallocated.
<br><span class="jpstr">
<code class="code-voice">Person</code>クラスは、インスタンスの<code class="code-voice">name</code>プロパティを設定して、初期化が進行中であることを示すためにメッセージを出力するイニシャライザを持ちます。<code class="code-voice">Person</code>クラスはまた、クラスのインスタンスが割り当て解除されるとき、メッセージを出力するデイニシャライザを持ちます。
</span><!--end_jpstr-->
</p><p class="para">
  The next code snippet defines three variables of type <code class="code-voice">Person?</code>, which are used to set up multiple references to a new <code class="code-voice">Person</code> instance in subsequent code snippets. Because these variables are of an optional type (<code class="code-voice">Person?</code>, not <code class="code-voice">Person</code>), they are automatically initialized with a value of <code class="code-voice">nil</code>, and do not currently reference a <code class="code-voice">Person</code> instance.
<br><span class="jpstr">
次のコード断片は、型<code class="code-voice">Person?</code>の３つの変数を定義します、それは、以降のコード断片の中のある１つの新しい<code class="code-voice">Person</code>インスタンスへの複数の参照を準備するために使われます。これらの変数がオプショナル型（<code class="code-voice">Person</code>ではなく、<code class="code-voice">Person?</code>）であることから、それらは自動的に<code class="code-voice">nil</code>の値で初期化されて、今は<code class="code-voice">Person</code>インスタンスに参照をつけません。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">reference1</span>: <span class="n"><! -- a href="" -->Person<! -- /a --></span>?</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">reference2</span>: <span class="n"><! -- a href="" -->Person<! -- /a --></span>?</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">reference3</span>: <span class="n"><! -- a href="" -->Person<! -- /a --></span>?</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can now create a new <code class="code-voice">Person</code> instance and assign it to one of these three variables:
<br><span class="jpstr">
あなたは、いま新しい<code class="code-voice">Person</code>インスタンスを作成して、それをこれらの３つの変数のうちの１つに代入することができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">reference1</span> = <span class="vc">Person</span>(<span class="vc">name</span>: <span class="s">&quot;John Appleseed&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;John Appleseed is being initialized&quot;&nbsp;<span class="jpstr">（「John Appleseedは、初期化された」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Note that the message <code class="code-voice">&quot;John Appleseed is being initialized&quot;</code> is printed at the point that you call the <code class="code-voice">Person</code> class’s initializer. This confirms that initialization has taken place.
<br><span class="jpstr">
あなたが<code class="code-voice">Person</code>クラスのイニシャライザを呼んだ時点で、メッセージ<code class="code-voice">"John Appleseed is being initialized"</code>が出力されるという点に注意してください。これは、初期化が起こったことを確認します。
</span><!--end_jpstr-->
</p><p class="para">
  Because the new <code class="code-voice">Person</code> instance has been assigned to the <code class="code-voice">reference1</code> variable, there is now a strong reference from <code class="code-voice">reference1</code> to the new <code class="code-voice">Person</code> instance. Because there is at least one strong reference, ARC makes sure that this <code class="code-voice">Person</code> is kept in memory and is not deallocated.
<br><span class="jpstr">
新しい<code class="code-voice">Person</code>インスタンスが<code class="code-voice">reference1</code>変数に代入されたので、強い参照が現在<code class="code-voice">reference1</code>から新しい<code class="code-voice">Person</code>インスタンスまで存在します。少なくとも１つの強い参照があるので、ARCはこの<code class="code-voice">Person</code>がメモリに保たれて割り当て解除されないことを確実にします。
</span><!--end_jpstr-->
</p><p class="para">
  If you assign the same <code class="code-voice">Person</code> instance to two more variables, two more strong references to that instance are established:
<br><span class="jpstr">
あなたが同じ<code class="code-voice">Person</code>インスタンスをさらに２つの変数に代入するならば、そのインスタンスへのさらに２つの強い参照が確立されます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">reference2</span> = <span class="vc">reference1</span></code></li>
            <li><code class="code-voice"><span class="vc">reference3</span> = <span class="vc">reference1</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  There are now <em>three</em> strong references to this single <code class="code-voice">Person</code> instance.
<br><span class="jpstr">
現在この一つの<code class="code-voice">Person</code>インスタンスへの<em>３つ</em>の強い参照があります。
</span><!--end_jpstr-->
</p><p class="para">
  If you break two of these strong references (including the original reference) by assigning <code class="code-voice">nil</code> to two of the variables, a single strong reference remains, and the <code class="code-voice">Person</code> instance is not deallocated:
<br><span class="jpstr">
あなたが変数のうちの２つに<code class="code-voice">nil</code>を代入することによってこれらの強い参照のうちの（最初の参照を含む）２つを壊すならば、１つの強い参照が残ります、そして<code class="code-voice">Person</code>インスタンスは割り当て解除されません：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">reference1</span> = <span class="kt">nil</span></code></li>
            <li><code class="code-voice"><span class="vc">reference2</span> = <span class="kt">nil</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  ARC does not deallocate the <code class="code-voice">Person</code> instance until the third and final strong reference is broken, at which point it’s clear that you are no longer using the <code class="code-voice">Person</code> instance:
<br><span class="jpstr">
ARCは、<code class="code-voice">Person</code>インスタンスの割り当て解除を３番目で最後に残ったの強い参照が壊れるまで行いません、その時点では、あなたがもはや<code class="code-voice">Person</code>インスタンスを使っていないことは明白です：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">reference3</span> = <span class="kt">nil</span></code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;John Appleseed is being deinitialized&quot;&nbsp;<span class="jpstr">（「John Appleseedは、デイニシャライズされた」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-ID51"></a>
  <h3 class="section-name" tabindex="0">Strong Reference Cycles Between Class Instances<br><span class="jpstr">
クラスインスタンス間の強い参照循環
</span><!--end_jpstr-->
</h3>
  <p class="para">
  In the examples above, ARC is able to track the number of references to the new <code class="code-voice">Person</code> instance you create and to deallocate that <code class="code-voice">Person</code> instance when it’s no longer needed.
<br><span class="jpstr">
上の例で、ARCはあなたがつくる新しい<code class="code-voice">Person</code>インスタンスへの参照の数を追跡して、その<code class="code-voice">Person</code>インスタンスをそれがもはや必要でないとき割り当て解除することができます。
</span><!--end_jpstr-->
</p><p class="para">
  However, it’s possible to write code in which an instance of a class <em>never</em> gets to a point where it has zero strong references. This can happen if two class instances hold a strong reference to each other, such that each instance keeps the other alive. This is known as a <em>strong reference cycle</em>.
<br><span class="jpstr">
しかしながら、あるクラスのあるインスタンスが、強い参照を１つも持たない状態になることが<em>決してない</em>コードを書くことは、可能です。２つのクラスインスタンスが強い参照にお互いを守らせるならば、これは起こることができます、各インスタンスが他を生かしておくようなものです。これは、<em>強い参照循環</em>として知られています。
</span><!--end_jpstr-->
</p><p class="para">
  You resolve strong reference cycles by defining some of the relationships between classes as weak or unowned references instead of as strong references. This process is described in <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH20-ID52" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH20-ID52">Resolving Strong Reference Cycles Between Class Instances</a></span>. However, before you learn how to resolve a strong reference cycle, it’s useful to understand how such a cycle is caused.
<br><span class="jpstr">
あなたは、クラス間の関係の一部を強い参照としてでなくて弱い、または非所有者参照として定義することによって強い参照循環を解消します。この過程は、<span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH20-ID52" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH20-ID52">クラスインスタンス間の強い参照循環の解消</a></span>で記述されます。しかし、あなたが強い参照循環を解消する方法を学ぶ前に、そのような循環がどのように引き起こされるか理解することは役に立ちます。
</span><!--end_jpstr-->
</p><p class="para">
  Here’s an example of how a strong reference cycle can be created by accident. This example defines two classes called <code class="code-voice">Person</code> and <code class="code-voice">Apartment</code>, which model a block of apartments and its residents:
<br><span class="jpstr">
強い参照循環がどのように偶然に作られることができるかの例は、ここにあります。この例は<code class="code-voice">Person</code>と<code class="code-voice">Apartment</code>と呼ばれる２つのクラスを定義します、それは、アパートの１区画とその居住者をモデル化します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">Person</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>) { <span class="kt">self</span>.<span class="vc">name</span> = <span class="vc">name</span> }</code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">apartment</span>: <span class="n"><! -- a href="" -->Apartment<! -- /a --></span>?</code></li>
            <li><code class="code-voice">    <span class="kt">deinit</span> { <span class="vc">print</span>(<span class="s">&quot;</span>\(<span class="vc">name</span>)<span class="s"> is being deinitialized&quot;</span>) }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">Apartment</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">unit</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">unit</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>) { <span class="kt">self</span>.<span class="vc">unit</span> = <span class="vc">unit</span> }</code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">tenant</span>: <span class="n"><! -- a href="" -->Person<! -- /a --></span>?</code></li>
            <li><code class="code-voice">    <span class="kt">deinit</span> { <span class="vc">print</span>(<span class="s">&quot;Apartment </span>\(<span class="vc">unit</span>)<span class="s"> is being deinitialized&quot;</span>) }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Every <code class="code-voice">Person</code> instance has a <code class="code-voice">name</code> property of type <code class="code-voice">String</code> and an optional <code class="code-voice">apartment</code> property that is initially <code class="code-voice">nil</code>. The <code class="code-voice">apartment</code> property is optional, because a person may not always have an apartment.
<br><span class="jpstr">
あらゆる<code class="code-voice">Person</code>インスタンスは、型<code class="code-voice">String</code>の<code class="code-voice">name</code>プロパティと初期時には<code class="code-voice">nil</code>であるオプショナルの<code class="code-voice">apartment</code>プロパティを持ちます。人は必ずしもアパートを持つわけではないので、<code class="code-voice">apartment</code>プロパティはオプショナルです。
</span><!--end_jpstr-->
</p><p class="para">
  Similarly, every <code class="code-voice">Apartment</code> instance has a <code class="code-voice">unit</code> property of type <code class="code-voice">String</code> and has an optional <code class="code-voice">tenant</code> property that is initially <code class="code-voice">nil</code>. The tenant property is optional because an apartment may not always have a tenant.
<br><span class="jpstr">
同じように、あらゆる<code class="code-voice">Apartment</code>インスタンスは、型<code class="code-voice">String</code>の<code class="code-voice">unit</code>プロパティを持って、初期時には<code class="code-voice">nil</code>であるオプショナルの<code class="code-voice">tenant</code>プロパティを持ちます。アパートには常に賃借人がいるわけではないので、tenant（テナント、賃借人）プロパティはオプショナルです。
</span><!--end_jpstr-->
</p><p class="para">
  Both of these classes also define a deinitializer, which prints the fact that an instance of that class is being deinitialized. This enables you to see whether instances of <code class="code-voice">Person</code> and <code class="code-voice">Apartment</code> are being deallocated as expected.
<br><span class="jpstr">
これらのクラスの両方ともデイニシャライザを定義します、それは、そのクラスのインスタンスがデイニシャライズされているという事実を出力します。これは、あなたに期待されるように<code class="code-voice">Person</code>と<code class="code-voice">Apartment</code>のインスタンスが割り当て解除されているかどうか知ることを可能にします。
</span><!--end_jpstr-->
</p><p class="para">
  This next code snippet defines two variables of optional type called <code class="code-voice">john</code> and <code class="code-voice">unit4A</code>, which will be set to a specific <code class="code-voice">Apartment</code> and <code class="code-voice">Person</code> instance below. Both of these variables have an initial value of <code class="code-voice">nil</code>, by virtue of being optional:
<br><span class="jpstr">
この次のコード断片は<code class="code-voice">john</code>と<code class="code-voice">unit4A</code>と呼ばれるオプショナルの型の２つの変数を定義します、それは、特定の<code class="code-voice">Apartment</code>と<code class="code-voice">Person</code>インスタンスに以降で設定されます。オプショナルである利点によって、これらの変数の両方とも、<code class="code-voice">nil</code>の初期値を持ちます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">john</span>: <span class="n"><! -- a href="" -->Person<! -- /a --></span>?</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">unit4A</span>: <span class="n"><! -- a href="" -->Apartment<! -- /a --></span>?</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can now create a specific <code class="code-voice">Person</code> instance and <code class="code-voice">Apartment</code> instance and assign these new instances to the <code class="code-voice">john</code> and <code class="code-voice">unit4A</code> variables:
<br><span class="jpstr">
あなたは、今や特定の<code class="code-voice">Person</code>インスタンスと<code class="code-voice">Apartment</code>インスタンスを作成して、それらの新しいインスタンスを<code class="code-voice">john</code>および<code class="code-voice">unit4A</code>変数に代入することができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">john</span> = <span class="vc">Person</span>(<span class="vc">name</span>: <span class="s">&quot;John Appleseed&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="vc">unit4A</span> = <span class="vc">Apartment</span>(<span class="vc">unit</span>: <span class="s">&quot;4A&quot;</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how the strong references look after creating and assigning these two instances. The <code class="code-voice">john</code> variable now has a strong reference to the new <code class="code-voice">Person</code> instance, and the <code class="code-voice">unit4A</code> variable has a strong reference to the new <code class="code-voice">Apartment</code> instance:
<br><span class="jpstr">
それらの２つのインスタンスの作成と代入の後に強い参照がどのように見えるかが、ここにあります。<code class="code-voice">john</code>変数は現在新しい<code class="code-voice">Person</code>インスタンスへの強い参照を持ちます、そして<code class="code-voice">unit4A</code>変数は新しい<code class="code-voice">Apartment</code>インスタンスへの強い参照を持ちます：
</span><!--end_jpstr-->
</p><figure class="figure">
  
  <span class="caption"></span>
  <img src="Art/referenceCycle01_2x.png" alt="image: ../Art/referenceCycle01_2x.png" width="626" height="188" />
</figure><p class="para">
  You can now link the two instances together so that the person has an apartment, and the apartment has a tenant. Note that an exclamation mark (<code class="code-voice">!</code>) is used to unwrap and access the instances stored inside the <code class="code-voice">john</code> and <code class="code-voice">unit4A</code> optional variables, so that the properties of those instances can be set:
<br><span class="jpstr">
あなたは次に人がアパートを持つように、２つのインスタンスを結びつけることができます、するとアパートには賃借人があります。感嘆符（<code class="code-voice">!</code>）が使われることに注意してください、そうすることでオプショナル変数の<code class="code-voice">john</code>と<code class="code-voice">unit4A</code>に格納されるインスタンスがアンラップされてアクセスされるようになります、それでそれらのインスタンスのプロパティが設定されることができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">john</span>!.<span class="vc">apartment</span> = <span class="vc">unit4A</span></code></li>
            <li><code class="code-voice"><span class="vc">unit4A</span>!.<span class="vc">tenant</span> = <span class="vc">john</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how the strong references look after you link the two instances together:
<br><span class="jpstr">
あなたが２つのインスタンスを結びつけた後に強い参照がどのように見えるかが、ここにあります。
</span><!--end_jpstr-->
</p><figure class="figure">
  
  <span class="caption"></span>
  <img src="Art/referenceCycle02_2x.png" alt="image: ../Art/referenceCycle02_2x.png" width="626" height="200" />
</figure><p class="para">
  Unfortunately, linking these two instances creates a strong reference cycle between them. The <code class="code-voice">Person</code> instance now has a strong reference to the <code class="code-voice">Apartment</code> instance, and the <code class="code-voice">Apartment</code> instance has a strong reference to the <code class="code-voice">Person</code> instance. Therefore, when you break the strong references held by the <code class="code-voice">john</code> and <code class="code-voice">unit4A</code> variables, the reference counts do not drop to zero, and the instances are not deallocated by ARC:
<br><span class="jpstr">
残念なことに、これらの２つのインスタンスを結ぶことは、それらの間で強い参照循環をつくります。<code class="code-voice">Person</code>インスタンスは現在<code class="code-voice">Apartment</code>インスタンスへの強い参照を持ちます、そして、<code class="code-voice">Apartment</code>インスタンスは<code class="code-voice">Person</code>インスタンスへの強い参照を持ちます。したがって、あなたが<code class="code-voice">john</code>と<code class="code-voice">unit4A</code>変数によって保持される強い参照を壊すとき、参照総数はゼロに落ちません、なのでインスタンスはARCによって割り当て解除されません：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">john</span> = <span class="kt">nil</span></code></li>
            <li><code class="code-voice"><span class="vc">unit4A</span> = <span class="kt">nil</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Note that neither deinitializer was called when you set these two variables to <code class="code-voice">nil</code>. The strong reference cycle prevents the <code class="code-voice">Person</code> and <code class="code-voice">Apartment</code> instances from ever being deallocated, causing a memory leak in your app.
<br><span class="jpstr">
あなたがこれらの２つの変数を<code class="code-voice">nil</code>に設定したとき、どちらのデイニシャライザも呼ばれなかった点に注意してください。強い参照循環は<code class="code-voice">Person</code>と<code class="code-voice">Apartment</code>インスタンスがともかく割り当て解除されるのを妨げます。そして、あなたのアプリのメモリリークを引き起こします。
</span><!--end_jpstr-->
</p><p class="para">
  Here’s how the strong references look after you set the <code class="code-voice">john</code> and <code class="code-voice">unit4A</code> variables to <code class="code-voice">nil</code>:
<br><span class="jpstr">
あなたが<code class="code-voice">john</code>と<code class="code-voice">unit4A</code>変数を<code class="code-voice">nil</code>に設定したあと、強い参照がどのように見えるかは、ここにあります：
</span><!--end_jpstr-->
</p><figure class="figure">
  
  <span class="caption"></span>
  <img src="Art/referenceCycle03_2x.png" alt="image: ../Art/referenceCycle03_2x.png" width="626" height="200" />
</figure><p class="para">
  The strong references between the <code class="code-voice">Person</code> instance and the <code class="code-voice">Apartment</code> instance remain and cannot be broken.
<br><span class="jpstr">
<code class="code-voice">Person</code>インスタンスと<code class="code-voice">Apartment</code>インスタンスの間の強い参照は、残っていて、壊されることができません。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-ID52"></a>
  <h3 class="section-name" tabindex="0">Resolving Strong Reference Cycles Between Class Instances<br><span class="jpstr">
クラスインスタンス間の強い参照循環の解消
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Swift provides two ways to resolve strong reference cycles when you work with properties of class type: weak references and unowned references.
<br><span class="jpstr">
あなたがクラス型のプロパティを扱うとき、スウィフトは強い参照循環を解消する２つの道を提供します：弱い参照と非所有者参照。
</span><!--end_jpstr-->
</p><p class="para">
  Weak and unowned references enable one instance in a reference cycle to refer to the other instance <em>without</em> keeping a strong hold on it. The instances can then refer to each other without creating a strong reference cycle.
<br><span class="jpstr">
弱いおよび非所有者参照は、ある参照循環の中の１つのインスタンスに、他のインスタンスに言及することをそれに対する強い支配力を持つこと<em>なく</em>可能にします。インスタンスは、そのあと強い参照循環をつくることなくお互いに言及することができます。
</span><!--end_jpstr-->
</p><p class="para">
  Use a weak reference when the other instance has a shorter lifetime—that is, when the other instance can be deallocated first. In the <code class="code-voice">Apartment</code> example above, it’s appropriate for an apartment to be able to have no tenant at some point in its lifetime, and so a weak reference is an appropriate way to break the reference cycle in this case. In contrast, use an unowned reference when the other instance has the same lifetime or a longer lifetime.
<br><span class="jpstr">
弱い参照を他のインスタンスがより短い生涯を持つ場合に使ってください — すなわち、他のインスタンスが最初にでアロケートされることが可能である時。上の<code class="code-voice">Apartment</code>例において、あるアパートがその生涯のどこかの時点で賃借人がいないことがあるというのは妥当です、なのでこの場合は弱い参照が参照循環を壊す適切な方法です。対照的に、非所有参照を他のインスタンスが同じ生涯またはより長い生涯を持つ場合に使ってください。
</span><!--end_jpstr-->
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-ID53"></a>
  <h3 class="section-name" tabindex="0">Weak References<br><span class="jpstr">
弱い参照
</span><!--end_jpstr-->
</h3>
  <p class="para">
  A <em>weak reference</em> is a reference that does not keep a strong hold on the instance it refers to, and so does not stop ARC from disposing of the referenced instance. This behavior prevents the reference from becoming part of a strong reference cycle. You indicate a weak reference by placing the <code class="code-voice">weak</code> keyword before a property or variable declaration.
<br><span class="jpstr">
<em>弱い参照</em>は、それが言及するインスタンスに対する強い支配力を保たない参照です、なのでARCは参照をつけられたインスタンスを処分するのを止めません。この挙動は、参照が強い参照循環の一部になるのを妨げます。あなたは、プロパティまたは変数の宣言の前に<code class="code-voice">weak</code>キーワードを置くことによって弱い参照を示します。
</span><!--end_jpstr-->
</p><p class="para">
  Because a weak reference does not keep a strong hold on the instance it refers to, it’s possible for that instance to be deallocated while the weak reference is still referring to it. Therefore, ARC automatically sets a weak reference to <code class="code-voice">nil</code> when the instance that it refers to is deallocated. And, because weak references need to allow their value to be changed to <code class="code-voice">nil</code> at runtime, they are always declared as variables, rather than constants, of an optional type.
<br><span class="jpstr">
弱い参照がそれが言及するインスタンスに対する強い支配力を保たないので、弱い参照がまだそれに言及している間にそのインスタンスが割り当て解除されることは可能です。したがって、ARCは自動的に、弱い参照をそれが言及するインスタンスが割り当て解除されるとき<code class="code-voice">nil</code>に設定します。そしてまた、弱い参照はそれらの値を実行時に<code class="code-voice">nil</code>に変更されるのを許される必要があることから、それらは常にオプショナル型の変数として宣言されます、定数ではなく。
</span><!--end_jpstr-->
</p><p class="para">
  You can check for the existence of a value in the weak reference, just like any other optional value, and you will never end up with a reference to an invalid instance that no longer exists.
<br><span class="jpstr">
他のあらゆるオプショナルの値と同じように、あなたは弱い参照の中の値の存在について調べることができます、そして、あなたは既に存在しない無効なインスタンスへの参照に至ることは決してありません。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-NoLink_151"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Property observers aren’t called when ARC sets a weak reference to <code class="code-voice">nil</code>.
    	<br><span class="jpstr">
プロパティオブザーバーは、ARCが弱い参照を<code class="code-voice">nil</code>に設定するとき呼び出されません。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><p class="para">
  The example below is identical to the <code class="code-voice">Person</code> and <code class="code-voice">Apartment</code> example from above, with one important difference. This time around, the <code class="code-voice">Apartment</code> type’s <code class="code-voice">tenant</code> property is declared as a weak reference:
<br><span class="jpstr">
下の例は、上記の<code class="code-voice">Person</code>と<code class="code-voice">Apartment</code>例に同一ですが、１つの重要な違いがあります。今度は、<code class="code-voice">Apartment</code>型の<code class="code-voice">tenant</code>プロパティは、弱い参照として宣言されます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">Person</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>) { <span class="kt">self</span>.<span class="vc">name</span> = <span class="vc">name</span> }</code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">apartment</span>: <span class="n"><! -- a href="" -->Apartment<! -- /a --></span>?</code></li>
            <li><code class="code-voice">    <span class="kt">deinit</span> { <span class="vc">print</span>(<span class="s">&quot;</span>\(<span class="vc">name</span>)<span class="s"> is being deinitialized&quot;</span>) }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">Apartment</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">unit</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">unit</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>) { <span class="kt">self</span>.<span class="vc">unit</span> = <span class="vc">unit</span> }</code></li>
            <li><code class="code-voice">    <span class="kt">weak</span> <span class="kt">var</span> <span class="vc">tenant</span>: <span class="n"><! -- a href="" -->Person<! -- /a --></span>?</code></li>
            <li><code class="code-voice">    <span class="kt">deinit</span> { <span class="vc">print</span>(<span class="s">&quot;Apartment </span>\(<span class="vc">unit</span>)<span class="s"> is being deinitialized&quot;</span>) }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The strong references from the two variables (<code class="code-voice">john</code> and <code class="code-voice">unit4A</code>) and the links between the two instances are created as before:
<br><span class="jpstr">
２つの変数（<code class="code-voice">john</code>と<code class="code-voice">unit4A</code>）からの強い参照と２つのインスタンスの繋がりは、前の通り作成されます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">john</span>: <span class="n"><! -- a href="" -->Person<! -- /a --></span>?</code></li>
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">unit4A</span>: <span class="n"><! -- a href="" -->Apartment<! -- /a --></span>?</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">john</span> = <span class="vc">Person</span>(<span class="vc">name</span>: <span class="s">&quot;John Appleseed&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="vc">unit4A</span> = <span class="vc">Apartment</span>(<span class="vc">unit</span>: <span class="s">&quot;4A&quot;</span>)</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="vc">john</span>!.<span class="vc">apartment</span> = <span class="vc">unit4A</span></code></li>
            <li><code class="code-voice"><span class="vc">unit4A</span>!.<span class="vc">tenant</span> = <span class="vc">john</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how the references look now that you’ve linked the two instances together:
<br><span class="jpstr">
あなたが２つのインスタンスを結びつけた今、参照がどのように見えるかは、ここにあります：
</span><!--end_jpstr-->
</p><figure class="figure">
  
  <span class="caption"></span>
  <img src="Art/weakReference01_2x.png" alt="image: ../Art/weakReference01_2x.png" width="626" height="197" />
</figure><p class="para">
  The <code class="code-voice">Person</code> instance still has a strong reference to the <code class="code-voice">Apartment</code> instance, but the <code class="code-voice">Apartment</code> instance now has a <em>weak</em> reference to the <code class="code-voice">Person</code> instance. This means that when you break the strong reference held by the <code class="code-voice">john</code> variable by setting it to <code class="code-voice">nil</code>, there are no more strong references to the <code class="code-voice">Person</code> instance:
<br><span class="jpstr">
<code class="code-voice">Person</code>インスタンスは依然として<code class="code-voice">Apartment</code>インスタンスへの強い参照を持ちます、しかし、<code class="code-voice">Apartment</code>インスタンスは現在は<code class="code-voice">Person</code>インスタンスへの<em>弱い</em>参照を持ちます。これは、あなたが<code class="code-voice">john</code>変数によって保持される強い参照を、それを<code class="code-voice">nil</code>に設定することによって壊すとき、<code class="code-voice">Person</code>インスタンスへの強い参照がもうそれ以上ないことを意味します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">john</span> = <span class="kt">nil</span></code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;John Appleseed is being deinitialized&quot;&nbsp;<span class="jpstr">（「John Appleseedは、デイニシャライズされた」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Because there are no more strong references to the <code class="code-voice">Person</code> instance, it’s deallocated and the <code class="code-voice">tenant</code> property is set to <code class="code-voice">nil</code>:
<br><span class="jpstr">
もうこれ以上<code class="code-voice">Person</code>インスタンスへの強い参照はないことから、それは割り当て解除されます、そして<code class="code-voice">tenant</code>特性は<code class="code-voice">nil</code>に設定されます：
</span><!--end_jpstr-->
</p><figure class="figure">
  
  <span class="caption"></span>
  <img src="Art/weakReference02_2x.png" alt="image: ../Art/weakReference02_2x.png" width="626" height="188" />
</figure><p class="para">
  The only remaining strong reference to the <code class="code-voice">Apartment</code> instance is from the <code class="code-voice">unit4A</code> variable. If you break <em>that</em> strong reference, there are no more strong references to the <code class="code-voice">Apartment</code> instance:
<br><span class="jpstr">
<code class="code-voice">Apartment</code>インスタンスへの唯一の残っている強い参照は、<code class="code-voice">unit4A</code>変数からです。あなたが<em>その</em>強い参照を壊すならば、<code class="code-voice">Apartment</code>インスタンスへの強い参照はもうこれ以上ありません：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">unit4A</span> = <span class="kt">nil</span></code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;Apartment 4A is being deinitialized&quot;&nbsp;<span class="jpstr">（「アパート4Aは、デイニシャライズされた」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Because there are no more strong references to the <code class="code-voice">Apartment</code> instance, it too is deallocated:
<br><span class="jpstr">
<code class="code-voice">Apartment</code>インスタンスへの強い参照はもうこれ以上ないので、それも割り当て解除されます：
</span><!--end_jpstr-->
</p><figure class="figure">
  
  <span class="caption"></span>
  <img src="Art/weakReference03_2x.png" alt="image: ../Art/weakReference03_2x.png" width="626" height="188" />
</figure><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-NoLink_152"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">In systems that use garbage collection, weak pointers are sometimes used to implement a simple caching mechanism because objects with no strong references are deallocated only when memory pressure triggers garbage collection. However, with ARC, values are deallocated as soon as their last strong reference is removed, making weak references unsuitable for such a purpose.
    	<br><span class="jpstr">
ガベージコレクションを使うシステムにおいて、時おり弱いポインタが簡単なキャッシュの仕組みを実装するために使われます、なぜなら強い参照を持たないオブジェクトは、メモリの逼迫がガベージコレクションを引き起こす時のみに割り当て解除されるためです。しかしながら、ARCでは、値はその最後の強い参照が削除されるやいなや割り当て解除されて、弱い参照をそのような目的のためにふさわしくないものにします。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-ID54"></a>
  <h3 class="section-name" tabindex="0">Unowned References<br><span class="jpstr">
非所有者参照
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Like a weak reference, an <em>unowned reference</em> does not keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime. You indicate an unowned reference by placing the <code class="code-voice">unowned</code> keyword before a property or variable declaration.
<br><span class="jpstr">
弱い参照のように、<em>非所有者参照</em>は、それが言及するインスタンスに対する強い支配力を保ちません。しかしながら、弱い参照とは違い、非所有参照は他のインスタンスが同じ生涯またはより長い生涯を持つ場合に使われます。あなたは、プロパティまたは変数の宣言の前に<code class="code-voice">unowned</code>キーワードを置くことによって非所有者参照を示します。
</span><!--end_jpstr-->
</p><p class="para">
  An unowned reference is expected to always have a value. As a result, ARC never sets an unowned reference’s value to <code class="code-voice">nil</code>, which means that unowned references are defined using nonoptional types.
<br><span class="jpstr">
非所有者参照は、常にある値を持っていることを期待されます。結果として、ARCは決して非所有参照の持つ値を<code class="code-voice">nil</code>に設定しません、それは非所有参照が非オプショナル型を使って定義されることを意味します。
</span><!--end_jpstr-->
</p><div class="important clear">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-DontLinkElementID_3"></a>
  <aside class="aside">
    <p class="aside-title">Important
    <br><span class="jpstr">
重要
</span><!--end_jpstr-->
</p>
    <p class="para">Use an unowned reference only when you are sure that the reference <em>always</em> refers to an instance that has not been deallocated.
    <br><span class="jpstr">
非所有者参照を、その参照が<em>常に</em>デアロケートされていないインスタンスに言及するとあなたが確信する時にだけ使用してください。
</span><!--end_jpstr-->
</p>
    <p class="para">
  If you try to access the value of an unowned reference after that instance has been deallocated, you’ll get a runtime error.
<br><span class="jpstr">
あなたがある非所有者参照の値に、そのインスタンスがデアロケートされてしまった後にアクセスしようとするならば、あなたは実行時エラーを得るでしょう。
</span><!--end_jpstr-->
</p>

  </aside>
</div><p class="para">
  The following example defines two classes, <code class="code-voice">Customer</code> and <code class="code-voice">CreditCard</code>, which model a bank customer and a possible credit card for that customer. These two classes each store an instance of the other class as a property. This relationship has the potential to create a strong reference cycle.
<br><span class="jpstr">
以下の例は２つのクラス、<code class="code-voice">Customer</code>と<code class="code-voice">CreditCard</code>を定義します、それは、銀行顧客とその顧客のために可能なクレジットカードをモデル化します。これらの２つのクラスは、それぞれ他のクラスのインスタンスをプロパティとして格納します。この関係は、強い参照循環をつくる可能性を持ちます。
</span><!--end_jpstr-->
</p><p class="para">
  The relationship between <code class="code-voice">Customer</code> and <code class="code-voice">CreditCard</code> is slightly different from the relationship between <code class="code-voice">Apartment</code> and <code class="code-voice">Person</code> seen in the weak reference example above. In this data model, a customer may or may not have a credit card, but a credit card will <em>always</em> be associated with a customer. A <code class="code-voice">CreditCard</code> instance never outlives the <code class="code-voice">Customer</code> that it refers to. To represent this, the <code class="code-voice">Customer</code> class has an optional <code class="code-voice">card</code> property, but the <code class="code-voice">CreditCard</code> class has an unowned (and nonoptional) <code class="code-voice">customer</code> property.
<br><span class="jpstr">
<code class="code-voice">Customer</code>と<code class="code-voice">CreditCard</code>の関係は、上の弱い参照の例で見られる<code class="code-voice">Apartment</code>と<code class="code-voice">Person</code>の関係と少しばかり異なります。このデータ・モデルにおいて、顧客はクレジットカードを持っているかもしれないし、持っていないかもしれません、しかし、クレジットカードは<em>常に</em>ひとりの顧客と結び付けられます。<code class="code-voice">CreditCard</code>インスタンスは、それが参照する<code class="code-voice">Customer</code>より決して長生きしません。これを表すために、<code class="code-voice">Customer</code>クラスはオプショナルの<code class="code-voice">カード</code>プロパティを持ちます、しかし、<code class="code-voice">CreditCard</code>クラスは非オプショナルの<code class="code-voice">customer</code>プロパティを持ちます。
</span><!--end_jpstr-->
</p><p class="para">
  Furthermore, a new <code class="code-voice">CreditCard</code> instance can <em>only</em> be created by passing a <code class="code-voice">number</code> value and a <code class="code-voice">customer</code> instance to a custom <code class="code-voice">CreditCard</code> initializer. This ensures that a <code class="code-voice">CreditCard</code> instance always has a <code class="code-voice">customer</code> instance associated with it when the <code class="code-voice">CreditCard</code> instance is created.
<br><span class="jpstr">
さらに、新しい<code class="code-voice">CreditCard</code>インスタンスは、<code class="code-voice">number</code>値と<code class="code-voice">customer</code>インスタンスをあつらえの<code class="code-voice">CreditCard</code>イニシャライザに渡すことによって<em>のみ</em>作成されることができます。これは、<code class="code-voice">CreditCard</code>インスタンスがつくられるとき、<code class="code-voice">CreditCard</code>インスタンスが常にそれと結びつけられる<code class="code-voice">Customer</code>インスタンスを持つことを確実にします。
</span><!--end_jpstr-->
</p><p class="para">
  Because a credit card will always have a customer, you define its <code class="code-voice">customer</code> property as an unowned reference, to avoid a strong reference cycle:
<br><span class="jpstr">
クレジットカードが常にひとりの顧客を持つので、強い参照循環を避けるために、あなたはその<code class="code-voice">customer</code>プロパティを非所有者参照として定義します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">Customer</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">card</span>: <span class="n"><! -- a href="" -->CreditCard<! -- /a --></span>?</code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">name</span> = <span class="vc">name</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    <span class="kt">deinit</span> { <span class="vc">print</span>(<span class="s">&quot;</span>\(<span class="vc">name</span>)<span class="s"> is being deinitialized&quot;</span>) }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">CreditCard</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">number</span>: <span class="n"><! -- a href="" -->UInt64<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">unowned</span> <span class="kt">let</span> <span class="vc">customer</span>: <span class="n"><! -- a href="" -->Customer<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">number</span>: <span class="n"><! -- a href="" -->UInt64<! -- /a --></span>, <span class="vc">customer</span>: <span class="n"><! -- a href="" -->Customer<! -- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">number</span> = <span class="vc">number</span></code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">customer</span> = <span class="vc">customer</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    <span class="kt">deinit</span> { <span class="vc">print</span>(<span class="s">&quot;Card #</span>\(<span class="vc">number</span>)<span class="s"> is being deinitialized&quot;</span>) }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-NoLink_153"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">The <code class="code-voice">number</code> property of the <code class="code-voice">CreditCard</code> class is defined with a type of <code class="code-voice">UInt64</code> rather than <code class="code-voice">Int</code>, to ensure that the <code class="code-voice">number</code> property’s capacity is large enough to store a 16-digit card number on both 32-bit and 64-bit systems.
    	<br><span class="jpstr">
<code class="code-voice">CreditCard</code>クラスの<code class="code-voice">number</code>プロパティは、<code class="code-voice">UInt64</code>の型で定義されます、<code class="code-voice">Int</code>ではなく、それによって<code class="code-voice">number</code>プロパティの容量が32bitと64bitシステムの両方で16桁のカード番号を格納するのに十分に大きいことを保証します。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><p class="para">
  This next code snippet defines an optional <code class="code-voice">Customer</code> variable called <code class="code-voice">john</code>, which will be used to store a reference to a specific customer. This variable has an initial value of nil, by virtue of being optional:
<br><span class="jpstr">
次のコード断片は、<code class="code-voice">john</code>と呼ばれる、オプショナルの<code class="code-voice">Customer</code>変数を定義します。それは、特定の顧客への参照を格納するために使われます。オプショナルであるおかげで、この変数はnilの初期値を持ちます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">john</span>: <span class="n"><! -- a href="" -->Customer<! -- /a --></span>?</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  You can now create a <code class="code-voice">Customer</code> instance, and use it to initialize and assign a new <code class="code-voice">CreditCard</code> instance as that customer’s <code class="code-voice">card</code> property:
<br><span class="jpstr">
あなたは、現在<code class="code-voice">Customer</code>インスタンスを作成して、それを使って、新しい<code class="code-voice">CreditCard</code>インスタンスを、その顧客の<code class="code-voice">card</code>プロパティとして初期化して代入することができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">john</span> = <span class="vc">Customer</span>(<span class="vc">name</span>: <span class="s">&quot;John Appleseed&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="vc">john</span>!.<span class="vc">card</span> = <span class="vc">CreditCard</span>(<span class="vc">number</span>: <span class="m">1234_5678_9012_3456</span>, <span class="vc">customer</span>: <span class="vc">john</span>!)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how the references look, now that you’ve linked the two instances:
<br><span class="jpstr">
あなたが２つのインスタンスを結んだ今、これらの参照がどのように見えるかは、ここにあります：
</span><!--end_jpstr-->
</p><figure class="figure">
  
  <span class="caption"></span>
  <img src="Art/unownedReference01_2x.png" alt="image: ../Art/unownedReference01_2x.png" width="626" height="197" />
</figure><p class="para">
  The <code class="code-voice">Customer</code> instance now has a strong reference to the <code class="code-voice">CreditCard</code> instance, and the <code class="code-voice">CreditCard</code> instance has an unowned reference to the <code class="code-voice">Customer</code> instance.
<br><span class="jpstr">
<code class="code-voice">Customer</code>インスタンスは現在<code class="code-voice">CreditCard</code>インスタンスへの強い参照を持ちます、そして、<code class="code-voice">CreditCard</code>インスタンスは<code class="code-voice">Customer</code>インスタンスへの非所有者参照を持ちます。
</span><!--end_jpstr-->
</p><p class="para">
  Because of the unowned <code class="code-voice">customer</code> reference, when you break the strong reference held by the <code class="code-voice">john</code> variable, there are no more strong references to the <code class="code-voice">Customer</code> instance:
<br><span class="jpstr">
非所有者<code class="code-voice">customer</code>参照であることから、あなたが<code class="code-voice">john</code>変数によって保持される強い参照を壊すとき、<code class="code-voice">Customer</code>インスタンスへの強い参照はもうそれ以上ありません：
</span><!--end_jpstr-->
</p><figure class="figure">
  
  <span class="caption"></span>
  <img src="Art/unownedReference02_2x.png" alt="image: ../Art/unownedReference02_2x.png" width="626" height="197" />
</figure><p class="para">
  Because there are no more strong references to the <code class="code-voice">Customer</code> instance, it’s deallocated. After this happens, there are no more strong references to the <code class="code-voice">CreditCard</code> instance, and it too is deallocated:
<br><span class="jpstr">
<code class="code-voice">Customer</code>インスタンスへの強い参照はもうないので、それは割り当て解除されます。これが起こったあと、<code class="code-voice">CreditCard</code>インスタンスへの強い参照はもうありません、そして、それも割り当て解除されます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">john</span> = <span class="kt">nil</span></code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;John Appleseed is being deinitialized&quot;&nbsp;<span class="jpstr">（「John Appleseedは、デイニシャライズされた」を出力します）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;Card #1234567890123456 is being deinitialized&quot;&nbsp;<span class="jpstr">（「カード#1234567890123456は、デイニシャライズされた」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The final code snippet above shows that the deinitializers for the <code class="code-voice">Customer</code> instance and <code class="code-voice">CreditCard</code> instance both print their “deinitialized” messages after the <code class="code-voice">john</code> variable is set to <code class="code-voice">nil</code>.
<br><span class="jpstr">
上の最後のコード断片は、<code class="code-voice">Customer</code>インスタンスと<code class="code-voice">CreditCard</code>インスタンスのためのデイニシャライザが両方ともそれらの「デイニシャライズされた」メッセージを、<code class="code-voice">john</code>変数が<code class="code-voice">nil</code>に設定された後に出力することを示します。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-NoLink_154"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">The examples above show how to use <em>safe</em> unowned references. Swift also provides <em>unsafe</em> unowned references for cases where you need to disable runtime safety checks—for example, for performance reasons. As with all unsafe operations, you take on the responsiblity for checking that code for safety.
    	<br><span class="jpstr">
上の例は、どのように<em>safe</em>非所有参照を使うかを示します。スウィフトはまた<em>unsafe</em>非所有参照を、あなたが実行時安全確認を無効にする必要がある場合のために提供します — 例えば、性能上の理由のために。すべての安全でない操作と同様に、あなたは安全性のためにそのコードを検査する責任があります。
</span><!--end_jpstr-->
</p>
    <p class="para">
  You indicate an unsafe unowned reference by writing <code class="code-voice">unowned(unsafe)</code>. If you try to access an unsafe unowned reference after the instance that it refers to is deallocated, your program will try to access the memory location where the instance used to be, which is an unsafe operation.
<br><span class="jpstr">
あなたは、安全でない非所有参照を<code class="code-voice">unowned(unsafe)</code>を書くことによって指し示します。あなたが安全でない非所有参照に、それが参照するインスタンスがデアロケートされてしまった後にアクセスすることを試みるならば、あなたのプログラムはそのインスタンスが存在するのに使われたところの位置でメモリにアクセスしようと試みるでしょう、それはメモリ安全ではない操作です。
</span><!--end_jpstr-->
</p>

  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-ID55"></a>
  <h3 class="section-name" tabindex="0">Unowned References and Implicitly Unwrapped Optional Properties<br><span class="jpstr">
非所有者参照と暗黙的にアンラップされるオプショナルのプロパティ
</span><!--end_jpstr-->
</h3>
  <p class="para">
  The examples for weak and unowned references above cover two of the more common scenarios in which it’s necessary to break a strong reference cycle.
<br><span class="jpstr">
上の弱いおよび非所有者参照のための例は、強い参照循環を壊すために不可欠なよくある筋書きのうちの２つを扱います。
</span><!--end_jpstr-->
</p><p class="para">
  The <code class="code-voice">Person</code> and <code class="code-voice">Apartment</code> example shows a situation where two properties, both of which are allowed to be <code class="code-voice">nil</code>, have the potential to cause a strong reference cycle. This scenario is best resolved with a weak reference.
<br><span class="jpstr">
<code class="code-voice">Person</code>と<code class="code-voice">Apartment</code>の例は、２つのプロパティ、両方とも<code class="code-voice">nil</code>であることを許されるものが強い参照循環を引き起こす可能性をもつ状況を示します。この筋書きは、弱い参照で最もよく解消されます。
</span><!--end_jpstr-->
</p><p class="para">
  The <code class="code-voice">Customer</code> and <code class="code-voice">CreditCard</code> example shows a situation where one property that is allowed to be <code class="code-voice">nil</code> and another property that cannot be <code class="code-voice">nil</code> have the potential to cause a strong reference cycle. This scenario is best resolved with an unowned reference.
<br><span class="jpstr">
<code class="code-voice">Customer</code>と<code class="code-voice">CreditCard</code>の例は、<code class="code-voice">nil</code>であることを許されるあるプロパティと<code class="code-voice">nil</code>であることができないもう１つのプロパティが強い参照循環を引き起こす可能性をもつ状況を示します。この筋書きは、非所有者参照で最もよく解消されます。
</span><!--end_jpstr-->
</p><p class="para">
  However, there is a third scenario, in which <em>both</em> properties should always have a value, and neither property should ever be <code class="code-voice">nil</code> once initialization is complete. In this scenario, it’s useful to combine an unowned property on one class with an implicitly unwrapped optional property on the other class.
<br><span class="jpstr">
しかし、第３の筋書きがあります、そこにおいて<em>両方の</em>プロパティは常に値を持たなければなりません、そして一旦初期化が終了しているならば、どちらのプロパティも決して<code class="code-voice">nil</code>であってはなりません。この筋書きにおいて、一方のクラス上の非所有者プロパティと他方のクラス上の暗黙的にアンラップされるオプショナルのプロパティを結合することは、役に立ちます。
</span><!--end_jpstr-->
</p><p class="para">
  This enables both properties to be accessed directly (without optional unwrapping) once initialization is complete, while still avoiding a reference cycle. This section shows you how to set up such a relationship.
<br><span class="jpstr">
これは、一旦初期化が終了しているならば、両方のプロパティが直接にアクセスされるのを（オプショナルをアンラップすることなく）可能にします、その一方で、依然として参照循環を避けます。この節は、あなたにそのような関係を設定する方法を教えます。
</span><!--end_jpstr-->
</p><p class="para">
  The example below defines two classes, <code class="code-voice">Country</code> and <code class="code-voice">City</code>, each of which stores an instance of the other class as a property. In this data model, every country must always have a capital city, and every city must always belong to a country. To represent this, the <code class="code-voice">Country</code> class has a <code class="code-voice">capitalCity</code> property, and the <code class="code-voice">City</code> class has a <code class="code-voice">country</code> property:
<br><span class="jpstr">
下の例は２つのクラス、<code class="code-voice">Country</code>と<code class="code-voice">City</code>を定義します、そして、そのそれぞれは他のクラスのインスタンスをプロパティとして格納します。このデータ・モデルにおいて、あらゆる国に常に主都がなければなりません、そして、あらゆる都市は常に国に属していなければなりません。これを表すために、<code class="code-voice">Country</code>クラスは<code class="code-voice">capitalCity</code>プロパティを持ちます、そして、<code class="code-voice">City</code>クラスは<code class="code-voice">country</code>プロパティを持ちます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">Country</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">var</span> <span class="vc">capitalCity</span>: <span class="n"><! -- a href="" -->City<! -- /a --></span>!</code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>, <span class="vc">capitalName</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">name</span> = <span class="vc">name</span></code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">capitalCity</span> = <span class="vc">City</span>(<span class="vc">name</span>: <span class="vc">capitalName</span>, <span class="vc">country</span>: <span class="kt">self</span>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"> </code></li>
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">City</span> {</code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">unowned</span> <span class="kt">let</span> <span class="vc">country</span>: <span class="n"><! -- a href="" -->Country<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>, <span class="vc">country</span>: <span class="n"><! -- a href="" -->Country<! -- /a --></span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">name</span> = <span class="vc">name</span></code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">country</span> = <span class="vc">country</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  To set up the interdependency between the two classes, the initializer for <code class="code-voice">City</code> takes a <code class="code-voice">Country</code> instance, and stores this instance in its <code class="code-voice">country</code> property.
<br><span class="jpstr">
２つのクラスの間で相互依存を設定するために、<code class="code-voice">City</code>のためのイニシャライザは、<code class="code-voice">Country</code>インスタンスをとって、このインスタンスをそれの<code class="code-voice">country</code>プロパティに保管します。
</span><!--end_jpstr-->
</p><p class="para">
  The initializer for <code class="code-voice">City</code> is called from within the initializer for <code class="code-voice">Country</code>. However, the initializer for <code class="code-voice">Country</code> cannot pass <code class="code-voice">self</code> to the <code class="code-voice">City</code> initializer until a new <code class="code-voice">Country</code> instance is fully initialized, as described in <span class="x-name"><a href="Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID220" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH18-ID220">Two-Phase Initialization</a></span>.
<br><span class="jpstr">
<code class="code-voice">City</code>のためのイニシャライザは、<code class="code-voice">Country</code>のためにイニシャライザの内部から呼ばれます。しかし、<span class="x-name"><a href="Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID220" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH18-ID220">２段階初期化</a></span>で記述されるように、<code class="code-voice">Country</code>のためのイニシャライザは、<code class="code-voice">self</code>を<code class="code-voice">City</code>イニシャライザに渡すことが、新しい<code class="code-voice">Country</code>インスタンスが完全に初期化されるまでできません。
</span><!--end_jpstr-->
</p><p class="para">
  To cope with this requirement, you declare the <code class="code-voice">capitalCity</code> property of <code class="code-voice">Country</code> as an implicitly unwrapped optional property, indicated by the exclamation mark at the end of its type annotation (<code class="code-voice">City!</code>). This means that the <code class="code-voice">capitalCity</code> property has a default value of <code class="code-voice">nil</code>, like any other optional, but can be accessed without the need to unwrap its value as described in <span class="x-name"><a href="TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID334" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID334">Implicitly Unwrapped Optionals</a></span>.
<br><span class="jpstr">
この必要条件に対処するために、あなたは<code class="code-voice">Country</code>の<code class="code-voice">capitalCity</code>プロパティを、暗黙的にアンラップされるオプショナルのプロパティとして、その型注釈の終わりに感嘆符で示して宣言します（<code class="code-voice">City!</code>）。これは、<span class="x-name"><a href="TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID334" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH5-ID334">暗黙的にアンラップされるオプショナル</a></span>で記述されるように、<code class="code-voice">capitalCity</code>プロパティが、オプショナルの他のものの様に、<code class="code-voice">nil</code>の省略時の値を持つが、アンラップする必要なしでその値にアクセスされることができることを意味します。
</span><!--end_jpstr-->
</p><p class="para">
  Because <code class="code-voice">capitalCity</code> has a default <code class="code-voice">nil</code> value, a new <code class="code-voice">Country</code> instance is considered fully initialized as soon as the <code class="code-voice">Country</code> instance sets its <code class="code-voice">name</code> property within its initializer. This means that the <code class="code-voice">Country</code> initializer can start to reference and pass around the implicit <code class="code-voice">self</code> property as soon as the <code class="code-voice">name</code> property is set. The <code class="code-voice">Country</code> initializer can therefore pass <code class="code-voice">self</code> as one of the parameters for the <code class="code-voice">City</code> initializer when the <code class="code-voice">Country</code> initializer is setting its own <code class="code-voice">capitalCity</code> property.
<br><span class="jpstr">
<code class="code-voice">capitalCity</code>が省略時の<code class="code-voice">nil</code>値を持つので、新しい<code class="code-voice">Country</code>インスタンスは、<code class="code-voice">Country</code>インスタンスがそのイニシャライザ内でその<code class="code-voice">name</code>プロパティを設定するとすぐに、完全に初期化されると見なされます。これは<code class="code-voice">Country</code>イニシャライザが、<code class="code-voice">name</code>プロパティが設定されるとすぐに、暗黙の<code class="code-voice">self</code>プロパティに基づいて参照したり渡したりを可能であるのを意味します。<code class="code-voice">Country</code>イニシャライザはしたがって、<code class="code-voice">self</code>を<code class="code-voice">City</code>イニシャライザのパラメータの１つとして渡すことが、<code class="code-voice">Country</code>イニシャライザが自身の<code class="code-voice">capitalCity</code>プロパティを設定しているときに可能です。
</span><!--end_jpstr-->
</p><p class="para">
  All of this means that you can create the <code class="code-voice">Country</code> and <code class="code-voice">City</code> instances in a single statement, without creating a strong reference cycle, and the <code class="code-voice">capitalCity</code> property can be accessed directly, without needing to use an exclamation mark to unwrap its optional value:
<br><span class="jpstr">
これの全ては、あなたが<code class="code-voice">Country</code>と<code class="code-voice">City</code>インスタンスを１つの文において、強い参照循環をつくることなく作成できることを意味します、そして、<code class="code-voice">capitalCity</code>プロパティはそのオプショナルの値をアンラップするために感嘆符を使う必要なしに直接にアクセスされることができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">country</span> = <span class="vc">Country</span>(<span class="vc">name</span>: <span class="s">&quot;Canada&quot;</span>, <span class="vc">capitalName</span>: <span class="s">&quot;Ottawa&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="vc">print</span>(<span class="s">&quot;</span>\(<span class="vc">country</span>.<span class="vc">name</span>)<span class="s">&#39;s capital city is called </span>\(<span class="vc">country</span>.<span class="vc">capitalCity</span>.<span class="vc">name</span>)<span class="s">&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;Canada&#39;s capital city is called Ottawa&quot;&nbsp;<span class="jpstr">（「カナダの首都はオタワです」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  In the example above, the use of an implicitly unwrapped optional means that all of the two-phase class initializer requirements are satisfied. The <code class="code-voice">capitalCity</code> property can be used and accessed like a nonoptional value once initialization is complete, while still avoiding a strong reference cycle.
<br><span class="jpstr">
上の例で、暗黙的にアンラップされるオプショナルの使用は、２段階のクラスイニシャライザの必要とする条件の全てが満たされることを意味します。<code class="code-voice">capitalCity</code>プロパティは、一旦初期化が終了しているならば、非オプショナルの値のように使われて、アクセスされることができます、その一方で、依然として強い参照循環を避けます。
</span><!--end_jpstr-->
</p>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-ID56"></a>
  <h3 class="section-name" tabindex="0">Strong Reference Cycles for Closures<br><span class="jpstr">
クロージャのための強い参照循環
</span><!--end_jpstr-->
</h3>
  <p class="para">
  You saw above how a strong reference cycle can be created when two class instance properties hold a strong reference to each other. You also saw how to use weak and unowned references to break these strong reference cycles.
<br><span class="jpstr">
あなたは上で、２つのクラスインスタンスプロパティが強い参照にお互いを守らせるとき、どのように強い参照循環がつくられることができるかを見ました。あなたはまた、これらの強い参照循環を壊すために弱いおよび非所有者参照を使う方法を見ました。
</span><!--end_jpstr-->
</p><p class="para">
  A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance. This capture might occur because the closure’s body accesses a property of the instance, such as <code class="code-voice">self.someProperty</code>, or because the closure calls a method on the instance, such as <code class="code-voice">self.someMethod()</code>. In either case, these accesses cause the closure to “capture” <code class="code-voice">self</code>, creating a strong reference cycle.
<br><span class="jpstr">
強い参照循環はまた、あなたがあるクロージャをクラスインスタンスのプロパティに代入して、そのクロージャの本文がそのインスタンスを捕獲するならば、起こることができます。この捕獲は、例えば<code class="code-voice">self.someProperty</code>のようにクロージャの本文がインスタンスのプロパティにアクセスするために、または例えば<code class="code-voice">self.someMethod()</code>のようにクロージャがインスタンスのメソッドを呼ぶために起こるかもしれません。いずれにせよ、これらのアクセスは、クロージャが強い参照循環をつくって<code class="code-voice">self</code>を「捕獲する」ことを引き起こします
</span><!--end_jpstr-->
</p><p class="para">
  This strong reference cycle occurs because closures, like classes, are <em>reference types</em>. When you assign a closure to a property, you are assigning a <em>reference</em> to that closure. In essence, it’s the same problem as above—two strong references are keeping each other alive. However, rather than two class instances, this time it’s a class instance and a closure that are keeping each other alive.
<br><span class="jpstr">
この強い参照循環は、クロージャが、クラスの様に<em>参照型</em>であるために起こります。あなたがクロージャをプロパティに代入するとき、あなたは<em>参照</em>をそのクロージャに代入しています。本質において、それは上記と同じ問題です ― ２つの強い参照が、お互いを生かし続けています。しかし２つのクラスインスタンスではなく、今度は、それはお互いを生かし続けているクラスインスタンスとクロージャです。
</span><!--end_jpstr-->
</p><p class="para">
  Swift provides an elegant solution to this problem, known as a <em>closure capture list</em>. However, before you learn how to break a strong reference cycle with a closure capture list, it’s useful to understand how such a cycle can be caused.
<br><span class="jpstr">
スウィフトはこの問題の洗練された解答、<em>クロージャ捕獲リスト</em>として知られるものを提供します。しかし、あなたがクロージャ捕獲リストで強い参照循環を壊す方法を学ぶ前に、そのような循環がどのように引き起こされることがありえるか理解することは役に立ちます。
</span><!--end_jpstr-->
</p><p class="para">
  The example below shows how you can create a strong reference cycle when using a closure that references <code class="code-voice">self</code>. This example defines a class called <code class="code-voice">HTMLElement</code>, which provides a simple model for an individual element within an HTML document:
<br><span class="jpstr">
下の例は、<code class="code-voice">self</code>に参照をつけるクロージャを使うとき、あなたがどのように強い参照循環をつくることができるかについて示します。この例は<code class="code-voice">HTMLElement</code>と呼ばれるクラスを定義します、それは、HTML文書内個々の要素に対する単純なモデルを用意します：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">HTMLElement</span> {</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">text</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>?</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">lazy</span> <span class="kt">var</span> <span class="vc">asHTML</span>: () -&gt; <span class="n"><! -- a href="" -->String<! -- /a --></span> = {</code></li>
            <li><code class="code-voice">        <span class="kt">if</span> <span class="kt">let</span> <span class="vc">text</span> = <span class="kt">self</span>.<span class="vc">text</span> {</code></li>
            <li><code class="code-voice">            <span class="kt">return</span> <span class="s">&quot;&lt;</span>\(<span class="kt">self</span>.<span class="vc">name</span>)<span class="s">&gt;</span>\(<span class="vc">text</span>)<span class="s">&lt;/</span>\(<span class="kt">self</span>.<span class="vc">name</span>)<span class="s">&gt;&quot;</span></code></li>
            <li><code class="code-voice">        } <span class="kt">else</span> {</code></li>
            <li><code class="code-voice">            <span class="kt">return</span> <span class="s">&quot;&lt;</span>\(<span class="kt">self</span>.<span class="vc">name</span>)<span class="s"> /&gt;&quot;</span></code></li>
            <li><code class="code-voice">        }</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>, <span class="vc">text</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>? = <span class="kt">nil</span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">name</span> = <span class="vc">name</span></code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">text</span> = <span class="vc">text</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">deinit</span> {</code></li>
            <li><code class="code-voice">        <span class="vc">print</span>(<span class="s">&quot;</span>\(<span class="vc">name</span>)<span class="s"> is being deinitialized&quot;</span>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  The <code class="code-voice">HTMLElement</code> class defines a <code class="code-voice">name</code> property, which indicates the name of the element, such as <code class="code-voice">&quot;h1&quot;</code> for a heading element, <code class="code-voice">&quot;p&quot;</code> for a paragraph element, or <code class="code-voice">&quot;br&quot;</code> for a line break element. <code class="code-voice">HTMLElement</code> also defines an optional <code class="code-voice">text</code> property, which you can set to a string that represents the text to be rendered within that HTML element.
<br><span class="jpstr">
<code class="code-voice">HTMLElement</code>クラスは<code class="code-voice">name</code>プロパティを定義します、それは、要素の名前を示します、例えばヘッダ要素の<code class="code-voice">"h1"</code>、段落要素のための<code class="code-voice">"p"</code>、またはあるいは、改行のための<code class="code-voice">"br"</code>要素など。<code class="code-voice">HTMLElement</code>はまた、オプショナルの<code class="code-voice">text</code>プロパティを定義します、それは、あなたはそれをテキストがそのHTML要素の範囲内で提出されると述べる文字列に設定することができます。
</span><!--end_jpstr-->
</p><p class="para">
  In addition to these two simple properties, the <code class="code-voice">HTMLElement</code> class defines a lazy property called <code class="code-voice">asHTML</code>. This property references a closure that combines <code class="code-voice">name</code> and <code class="code-voice">text</code> into an HTML string fragment. The <code class="code-voice">asHTML</code> property is of type <code class="code-voice">() -&gt; String</code>, or “a function that takes no parameters, and returns a <code class="code-voice">String</code> value”.
<br><span class="jpstr">
これらの２つの単純なプロパティに加えて、<code class="code-voice">HTMLElement</code>クラスは、<code class="code-voice">asHTML</code>と呼ばれる遅延プロパティを定義します。このプロパティは、<code class="code-voice">name</code>と<code class="code-voice">text</code>をHTML文字列断片に結合するクロージャに参照をつけます。<code class="code-voice">asHTML</code>プロパティは型<code class="code-voice">() -&gt; String</code>です、あるいは「パラメータをとらなくて、<code class="code-voice">String</code>値を返す関数」。
</span><!--end_jpstr-->
</p><p class="para">
  By default, the <code class="code-voice">asHTML</code> property is assigned a closure that returns a string representation of an HTML tag. This tag contains the optional <code class="code-voice">text</code> value if it exists, or no text content if <code class="code-voice">text</code> does not exist. For a paragraph element, the closure would return <code class="code-voice">&quot;&lt;p&gt;some text&lt;/p&gt;&quot;</code> or <code class="code-voice">&quot;&lt;p /&gt;&quot;</code>, depending on whether the <code class="code-voice">text</code> property equals <code class="code-voice">&quot;some text&quot;</code> or <code class="code-voice">nil</code>.
<br><span class="jpstr">
特に何もしなければ、<code class="code-voice">asHTML</code>プロパティは、あるHTMLタグの文字列表現を返すクロージャを代入されます。このタグは、それが存在するならばオプショナルの<code class="code-voice">text</code>値を、あるいは<code class="code-voice">text</code>が存在しないならば、無いテキスト内容を含みます。段落要素のために、このクロージャは、<code class="code-voice">text</code>プロパティが<code class="code-voice">"some text"</code>または<code class="code-voice">nil</code>に等しいかどうかに従って、<code class="code-voice">"&lt;p&gt;some text&lt;/p&gt;"</code>または<code class="code-voice">"&lt;p /&gt;"</code>を返します。
</span><!--end_jpstr-->
</p><p class="para">
  The <code class="code-voice">asHTML</code> property is named and used somewhat like an instance method. However, because <code class="code-voice">asHTML</code> is a closure property rather than an instance method, you can replace the default value of the <code class="code-voice">asHTML</code> property with a custom closure, if you want to change the HTML rendering for a particular HTML element.
<br><span class="jpstr">
<code class="code-voice">asHTML</code>プロパティは、いくぶんインスタンスメソッドのように名前をつけられて、使われます。しかし、<code class="code-voice">asHTML</code>はインスタンスメソッドではなくクロージャプロパティであるので、あなたが特定のHTML要素に対してHTML解釈を変更したいならば、あなたはあつらえのクロージャで<code class="code-voice">asHTML</code>プロパティの省略時の値を置き替えることができます。
</span><!--end_jpstr-->
</p><p class="para">
  For example, the <code class="code-voice">asHTML</code> property could be set to a closure that defaults to some text if the <code class="code-voice">text</code> property is <code class="code-voice">nil</code>, in order to prevent the representation from returning an empty HTML tag:
<br><span class="jpstr">
例えば、<code class="code-voice">asHTML</code>プロパティは、あるクロージャに設定されることができます、それは<code class="code-voice">text</code>プロパティが<code class="code-voice">nil</code>ならば特に何もしなくともいくらかのテキストになり、その表現が空のHTMLタグを返すことを予防する手段となります。
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">heading</span> = <span class="vc">HTMLElement</span>(<span class="vc">name</span>: <span class="s">&quot;h1&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="kt">let</span> <span class="vc">defaultText</span> = <span class="s">&quot;some default text&quot;</span></code></li>
            <li><code class="code-voice"><span class="vc">heading</span>.<span class="vc">asHTML</span> = {</code></li>
            <li><code class="code-voice">    <span class="kt">return</span> <span class="s">&quot;&lt;</span>\(<span class="vc">heading</span>.<span class="vc">name</span>)<span class="s">&gt;</span>\(<span class="vc">heading</span>.<span class="vc">text</span> ?? <span class="vc">defaultText</span>)<span class="s">&lt;/</span>\(<span class="vc">heading</span>.<span class="vc">name</span>)<span class="s">&gt;&quot;</span></code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><span class="vc">print</span>(<span class="vc">heading</span>.<span class="vc">asHTML</span>())</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;&lt;h1&gt;some default text&lt;/h1&gt;&quot;</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-NoLink_155"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">The <code class="code-voice">asHTML</code> property is declared as a lazy property, because it’s only needed if and when the element actually needs to be rendered as a string value for some HTML output target. The fact that <code class="code-voice">asHTML</code> is a lazy property means that you can refer to <code class="code-voice">self</code> within the default closure, because the lazy property will not be accessed until after initialization has been completed and <code class="code-voice">self</code> is known to exist.
    	<br><span class="jpstr">
<code class="code-voice">asHTML</code>プロパティは遅延プロパティとして宣言されます、なぜなら、要素が何らかのHTML出力対象のために実際に文字列値として解釈される必要がもしもあるときのみそれが必要なだけだからです。<code class="code-voice">asHTML</code>が遅延プロパティだという事実は、あなたが省略時のクロージャ内で<code class="code-voice">self</code>に言及することができることを意味します、なぜなら、遅延プロパティは、初期化が完了されてしまって<code class="code-voice">self</code>が存在することを知られる後までアクセスされることはないからです。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><p class="para">
  The <code class="code-voice">HTMLElement</code> class provides a single initializer, which takes a <code class="code-voice">name</code> argument and (if desired) a <code class="code-voice">text</code> argument to initialize a new element. The class also defines a deinitializer, which prints a message to show when an <code class="code-voice">HTMLElement</code> instance is deallocated.
<br><span class="jpstr">
<code class="code-voice">HTMLElement</code>クラスは一つのイニシャライザを提供します、それは、<code class="code-voice">name</code>引数と（希望する場合には）<code class="code-voice">text</code>引数をとって新しい要素を初期化します。クラスもデイニシャライザを定義します、それは、<code class="code-voice">HTMLElement</code>インスタンスが割り当て解除される場合に示すメッセージを出力します。
</span><!--end_jpstr-->
</p><p class="para">
  Here’s how you use the <code class="code-voice">HTMLElement</code> class to create and print a new instance:
<br><span class="jpstr">
あなたが新しいインスタンスを作成して出力するために<code class="code-voice">HTMLElement</code>クラスを使用する方法は、ここにあります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">paragraph</span>: <span class="n"><! -- a href="" -->HTMLElement<! -- /a --></span>? = <span class="vc">HTMLElement</span>(<span class="vc">name</span>: <span class="s">&quot;p&quot;</span>, <span class="vc">text</span>: <span class="s">&quot;hello, world&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="vc">print</span>(<span class="vc">paragraph</span>!.<span class="vc">asHTML</span>())</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;&lt;p&gt;hello, world&lt;/p&gt;&quot;&nbsp;<span class="jpstr">（「&lt;p&gt;よろしく、世界&lt;/p&gt;」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-NoLink_156"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">The <code class="code-voice">paragraph</code> variable above is defined as an <em>optional</em> <code class="code-voice">HTMLElement</code>, so that it can be set to <code class="code-voice">nil</code> below to demonstrate the presence of a strong reference cycle.
    	<br><span class="jpstr">
上記の<code class="code-voice">paragraph</code>変数は、<em>オプショナル</em>の<code class="code-voice">HTMLElement</code>として定義されます、それでそれは下で強い参照循環の存在を例示するために<code class="code-voice">nil</code>に設定されることができます。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><p class="para">
  Unfortunately, the <code class="code-voice">HTMLElement</code> class, as written above, creates a strong reference cycle between an <code class="code-voice">HTMLElement</code> instance and the closure used for its default <code class="code-voice">asHTML</code> value. Here’s how the cycle looks:
<br><span class="jpstr">
残念なことに、この<code class="code-voice">HTMLElement</code>クラスは、上で書かれるように、<code class="code-voice">HTMLElement</code>インスタンスとその省略時の<code class="code-voice">asHTML</code>値のために使われるクロージャとの間に強い参照循環をつくります。循環がどのように見えるかは、ここにあります：
</span><!--end_jpstr-->
</p><figure class="figure">
  
  <span class="caption"></span>
  <img src="Art/closureReferenceCycle01_2x.png" alt="image: ../Art/closureReferenceCycle01_2x.png" width="626" height="218" />
</figure><p class="para">
  The instance’s <code class="code-voice">asHTML</code> property holds a strong reference to its closure. However, because the closure refers to <code class="code-voice">self</code> within its body (as a way to reference <code class="code-voice">self.name</code> and <code class="code-voice">self.text</code>), the closure <em>captures</em> self, which means that it holds a strong reference back to the <code class="code-voice">HTMLElement</code> instance. A strong reference cycle is created between the two. (For more information about capturing values in a closure, see <span class="x-name"><a href="Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID103" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH11-ID103">Capturing Values</a></span>.)
<br><span class="jpstr">
このインスタンスの<code class="code-voice">asHTML</code>プロパティは、それのクロージャに対する強い参照を保持します。しかし、クロージャがその本文内で<code class="code-voice">self</code>に言及する（<code class="code-voice">self.name</code>と<code class="code-voice">self.text</code>を参照する方法として）ので、クロージャはselfを<em>捕獲</em>します、それは、今度は逆にそれが<code class="code-voice">HTMLElement</code>インスタンスへの強い参照を保持することを意味します。強い参照循環は、２つ作られます。（クロージャにおいて値を捕獲することに関する詳細は、<span class="x-name"><a href="Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID103" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH11-ID103">値を捕獲する</a></span>を見てください。）
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-NoLink_157"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Even though the closure refers to <code class="code-voice">self</code> multiple times, it only captures one strong reference to the <code class="code-voice">HTMLElement</code> instance.
    	<br><span class="jpstr">
たとえクロージャが複数回<code class="code-voice">self</code>に言及するとしても、それはその<code class="code-voice">HTMLElement</code>インスタンスへの１つの強い参照を捕獲するだけです。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><p class="para">
  If you set the <code class="code-voice">paragraph</code> variable to <code class="code-voice">nil</code> and break its strong reference to the <code class="code-voice">HTMLElement</code> instance, neither the <code class="code-voice">HTMLElement</code> instance nor its closure are deallocated, because of the strong reference cycle:
<br><span class="jpstr">
あなたが<code class="code-voice">paragraph</code>変数を<code class="code-voice">nil</code>に設定して、<code class="code-voice">HTMLElement</code>へのそれの強い参照を壊すならば、<code class="code-voice">HTMLElement</code>インスタンスもそれのクロージャも割り当て解除されません、強い参照循環のためです：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">paragraph</span> = <span class="kt">nil</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Note that the message in the <code class="code-voice">HTMLElement</code> deinitializer is not printed, which shows that the <code class="code-voice">HTMLElement</code> instance is not deallocated.
<br><span class="jpstr">
<code class="code-voice">HTMLElement</code>デイニシャライザにおけるメッセージが出力されないことに注意してください、それは、<code class="code-voice">HTMLElement</code>インスタンスが割り当て解除されないことを示します。
</span><!--end_jpstr-->
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-ID57"></a>
  <h3 class="section-name" tabindex="0">Resolving Strong Reference Cycles for Closures<br><span class="jpstr">
クロージャのための強い参照循環の解消
</span><!--end_jpstr-->
</h3>
  <p class="para">
  You resolve a strong reference cycle between a closure and a class instance by defining a <em>capture list</em> as part of the closure’s definition. A capture list defines the rules to use when capturing one or more reference types within the closure’s body. As with strong reference cycles between two class instances, you declare each captured reference to be a weak or unowned reference rather than a strong reference. The appropriate choice of weak or unowned depends on the relationships between the different parts of your code.
<br><span class="jpstr">
あなたは、クロージャの定義の一部として<em>捕獲リスト</em>を定義することによってクロージャとクラスインスタンスの間で強い参照循環を解消します。捕獲リストは、クロージャの本文内で一つ以上の参照型を捕獲するとき使用する規則を定義します。２つのクラスインスタンスの間の強い参照循環と同様に、あなたは各捕らえられた参照が強い参照というよりは弱いまたは非所有者参照であると宣言します。弱いまたは非所有者の適切な選択は、あなたのコードの異なる部分間の関係に依存します。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-NoLink_158"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">Swift requires you to write <code class="code-voice">self.someProperty</code> or <code class="code-voice">self.someMethod()</code> (rather than just <code class="code-voice">someProperty</code> or <code class="code-voice">someMethod()</code>) whenever you refer to a member of <code class="code-voice">self</code> within a closure. This helps you remember that it’s possible to capture <code class="code-voice">self</code> by accident.
    	<br><span class="jpstr">
スウィフトはあなたに<code class="code-voice">self.someProperty</code>または<code class="code-voice">self.someMethod()</code>（ただ単に<code class="code-voice">someProperty</code>または<code class="code-voice">someMethod()</code>ではなく）を書くことを、あなたがクロージャ内で<code class="code-voice">self</code>のメンバーに言及するときはいつでも、要求します。これは、偶然に<code class="code-voice">self</code>を捕らえることは可能であるのをあなたが忘れないことを手助けします。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-ID58"></a>
  <h3 class="section-name" tabindex="0">Defining a Capture List<br><span class="jpstr">
捕獲リストの定義
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Each item in a capture list is a pairing of the <code class="code-voice">weak</code> or <code class="code-voice">unowned</code> keyword with a reference to a class instance (such as <code class="code-voice">self</code>) or a variable initialized with some value (such as <code class="code-voice">delegate = self.delegate!</code>). These pairings are written within a pair of square braces, separated by commas.
<br><span class="jpstr">
捕獲リストの各項目は、<code class="code-voice">weak</code>または<code class="code-voice">unowned</code>キーワードと、クラスインスタンスへの参照（例えば<code class="code-voice">self</code>）またはなんらかの値で初期化された変数（例えば<code class="code-voice">delegate = self.delegate!</code>）を対にしたものです。これらの組合せは、一対の角括弧内に書かれて、コンマで区切られます。
</span><!--end_jpstr-->
</p><p class="para">
  Place the capture list before a closure’s parameter list and return type if they are provided:
<br><span class="jpstr">
それらが提供されるならばクロージャのパラメータ・リストと戻り型の前に、捕獲リストを置いてください：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">lazy</span> <span class="kt">var</span> <span class="vc">someClosure</span>: (<span class="n"><! -- a href="" -->Int<! -- /a --></span>, <span class="n"><! -- a href="" -->String<! -- /a --></span>) -&gt; <span class="n"><! -- a href="" -->String<! -- /a --></span> = {</code></li>
            <li><code class="code-voice">    [<span class="vc">unowned</span> <span class="kt">self</span>, <span class="vc">weak</span> <span class="vc">delegate</span> = <span class="kt">self</span>.<span class="vc">delegate</span>!] (<span class="vc">index</span>: <span class="n"><! -- a href="" -->Int<! -- /a --></span>, <span class="vc">stringToProcess</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>) -&gt; <span class="n"><! -- a href="" -->String<! -- /a --></span> <span class="kt">in</span></code></li>
            <li><code class="code-voice">    <span class="c">// closure body goes here&nbsp;<span class="jpstr">（クロージャ本文が、ここにきます）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  If a closure does not specify a parameter list or return type because they can be inferred from context, place the capture list at the very start of the closure, followed by the <code class="code-voice">in</code> keyword:
<br><span class="jpstr">
クロージャがパラメータ・リストまたは戻り型を、それらが前後関係から推論されることができるために指定しないならば、捕獲リストをクロージャのまさしくその始まりに、<code class="code-voice">in</code>キーワードに続けて置いてください：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">lazy</span> <span class="kt">var</span> <span class="vc">someClosure</span>: () -&gt; <span class="n"><! -- a href="" -->String<! -- /a --></span> = {</code></li>
            <li><code class="code-voice">    [<span class="vc">unowned</span> <span class="kt">self</span>, <span class="vc">weak</span> <span class="vc">delegate</span> = <span class="kt">self</span>.<span class="vc">delegate</span>!] <span class="kt">in</span></code></li>
            <li><code class="code-voice">    <span class="c">// closure body goes here&nbsp;<span class="jpstr">（クロージャ本文が、ここにきます）</span><!--end_jpstr-->
</span></code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-ID59"></a>
  <h3 class="section-name" tabindex="0">Weak and Unowned References<br><span class="jpstr">
弱いおよび非所有者参照
</span><!--end_jpstr-->
</h3>
  <p class="para">
  Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.
<br><span class="jpstr">
それが捕らえるクロージャとインスタンスが常にお互いに言及して、常に同時に割り当て解除されるときは、クロージャにおいて捕獲を非所有者参照として定義してください。
</span><!--end_jpstr-->
</p><p class="para">
  Conversely, define a capture as a weak reference when the captured reference may become <code class="code-voice">nil</code> at some point in the future. Weak references are always of an optional type, and automatically become <code class="code-voice">nil</code> when the instance they reference is deallocated. This enables you to check for their existence within the closure’s body.
<br><span class="jpstr">
逆に、捕らえられた参照が将来どこかの時点で<code class="code-voice">nil</code>になるかもしれないときは、捕獲を弱い参照として定義してください。弱い参照は常にオプショナルの型です、そしてそれが参照をつけるインスタンスが割り当て解除されるとき、自動的に<code class="code-voice">nil</code>になります。これはあなたに、クロージャの本文内でそれらの存在について調べることを可能にします。
</span><!--end_jpstr-->
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH20-NoLink_159"></a>
  <aside class="aside">
    <p class="aside-title">Note
    <br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
    	<p class="para">If the captured reference will never become <code class="code-voice">nil</code>, it should always be captured as an unowned reference, rather than a weak reference.
    	<br><span class="jpstr">
捕獲された参照が決して<code class="code-voice">nil</code>にならないならば、それは常に、非所有者参照として捕らえられなければなりません、弱い参照ではなくて。
</span><!--end_jpstr-->
</p>
    
  </aside>
</div><p class="para">
  An unowned reference is the appropriate capture method to use to resolve the strong reference cycle in the <code class="code-voice">HTMLElement</code> example from earlier. Here’s how you write the <code class="code-voice">HTMLElement</code> class to avoid the cycle:
<br><span class="jpstr">
非所有者参照は、以前の<code class="code-voice">HTMLElement</code>例での強い参照循環を解消するのために使うのに適切な捕獲の手法です。あなたが<code class="code-voice">HTMLElement</code>クラスを循環を避けるように書く方法は、ここにあります：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">class</span> <span class="vc">HTMLElement</span> {</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span></code></li>
            <li><code class="code-voice">    <span class="kt">let</span> <span class="vc">text</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>?</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">lazy</span> <span class="kt">var</span> <span class="vc">asHTML</span>: () -&gt; <span class="n"><! -- a href="" -->String<! -- /a --></span> = {</code></li>
            <li><code class="code-voice">        [<span class="vc">unowned</span> <span class="kt">self</span>] <span class="kt">in</span></code></li>
            <li><code class="code-voice">        <span class="kt">if</span> <span class="kt">let</span> <span class="vc">text</span> = <span class="kt">self</span>.<span class="vc">text</span> {</code></li>
            <li><code class="code-voice">            <span class="kt">return</span> <span class="s">&quot;&lt;</span>\(<span class="kt">self</span>.<span class="vc">name</span>)<span class="s">&gt;</span>\(<span class="vc">text</span>)<span class="s">&lt;/</span>\(<span class="kt">self</span>.<span class="vc">name</span>)<span class="s">&gt;&quot;</span></code></li>
            <li><code class="code-voice">        } <span class="kt">else</span> {</code></li>
            <li><code class="code-voice">            <span class="kt">return</span> <span class="s">&quot;&lt;</span>\(<span class="kt">self</span>.<span class="vc">name</span>)<span class="s"> /&gt;&quot;</span></code></li>
            <li><code class="code-voice">        }</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">init</span>(<span class="vc">name</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>, <span class="vc">text</span>: <span class="n"><! -- a href="" -->String<! -- /a --></span>? = <span class="kt">nil</span>) {</code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">name</span> = <span class="vc">name</span></code></li>
            <li><code class="code-voice">        <span class="kt">self</span>.<span class="vc">text</span> = <span class="vc">text</span></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <span class="kt">deinit</span> {</code></li>
            <li><code class="code-voice">        <span class="vc">print</span>(<span class="s">&quot;</span>\(<span class="vc">name</span>)<span class="s"> is being deinitialized&quot;</span>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  This implementation of <code class="code-voice">HTMLElement</code> is identical to the previous implementation, apart from the addition of a capture list within the <code class="code-voice">asHTML</code> closure. In this case, the capture list is <code class="code-voice">[unowned self]</code>, which means “capture self as an unowned reference rather than a strong reference”.
<br><span class="jpstr">
<code class="code-voice">HTMLElement</code>のこの実装は、<code class="code-voice">asHTML</code>クロージャ内の捕獲リストの追加は別として、前の実装と同一です。この場合、捕獲リストは<code class="code-voice">[unowned self]</code>です、それは、「selfを強い参照ではなく非所有者参照として捕獲する」ことを意味します。
</span><!--end_jpstr-->
</p><p class="para">
  You can create and print an <code class="code-voice">HTMLElement</code> instance as before:
<br><span class="jpstr">
あなたは、<code class="code-voice">HTMLElement</code>インスタンスを前の通り作成して出力することができます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="kt">var</span> <span class="vc">paragraph</span>: <span class="n"><! -- a href="" -->HTMLElement<! -- /a --></span>? = <span class="vc">HTMLElement</span>(<span class="vc">name</span>: <span class="s">&quot;p&quot;</span>, <span class="vc">text</span>: <span class="s">&quot;hello, world&quot;</span>)</code></li>
            <li><code class="code-voice"><span class="vc">print</span>(<span class="vc">paragraph</span>!.<span class="vc">asHTML</span>())</code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;&lt;p&gt;hello, world&lt;/p&gt;&quot;&nbsp;<span class="jpstr">（「&lt;p&gt;よろしく、世界&lt;/p&gt;」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  Here’s how the references look with the capture list in place:
<br><span class="jpstr">
捕獲リストで適切にされた参照がどのように見えるかは、ここにあります：
</span><!--end_jpstr-->
</p><figure class="figure">
  
  <span class="caption"></span>
  <img src="Art/closureReferenceCycle02_2x.png" alt="image: ../Art/closureReferenceCycle02_2x.png" width="626" height="218" />
</figure><p class="para">
  This time, the capture of <code class="code-voice">self</code> by the closure is an unowned reference, and does not keep a strong hold on the <code class="code-voice">HTMLElement</code> instance it has captured. If you set the strong reference from the <code class="code-voice">paragraph</code> variable to <code class="code-voice">nil</code>, the <code class="code-voice">HTMLElement</code> instance is deallocated, as can be seen from the printing of its deinitializer message in the example below:
<br><span class="jpstr">
今度は、クロージャによる<code class="code-voice">self</code>の捕獲は非所有者参照であって、それが捕獲している<code class="code-voice">HTMLElement</code>インスタンスに対する強い支配力を保ちません。あなたが強い参照である<code class="code-voice">paragraph</code>変数を<code class="code-voice">nil</code>に設定するならば、その<code class="code-voice">HTMLElement</code>インスタンスは、下の例におけるそれのデイニシャライザのメッセージの出力から分かるように、割り当て解除されます：
</span><!--end_jpstr-->
</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><span class="vc">paragraph</span> = <span class="kt">nil</span></code></li>
            <li><code class="code-voice"><span class="c">// Prints &quot;p is being deinitialized&quot;&nbsp;<span class="jpstr">（「pは、デイニシャライズされている」を出力します）</span><!--end_jpstr-->
</span></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">
  For more information about capture lists, see <span class="x-name"><a href="Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID544" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH32-ID544">Capture Lists</a></span>.
<br><span class="jpstr">
キャプチャリストについての更なる情報として、<span class="x-name"><a href="Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID544" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH32-ID544">キャプチャリスト</a></span>を見てください。
</span><!--end_jpstr-->
</p>
  
</section>

</section>

  	
 	<section id="next_previous" class="">
    		<p class="previous-link"><a href="Deinitialization.html#//apple_ref/doc/uid/TP40014097-CH19-ID142" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH19-ID142">Deinitialization<br><span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></p>
  			<p class="next-link"><a href="OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40014097-CH21-ID245">Optional Chaining<br><span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></p>

    <p class="copyright">Copyright &#x00a9; 2017 Apple Inc. All rights reserved. 
  <a class="link" href="http://www.apple.com/legal/terms/site.html" target="_blank" rel="external">Terms of Use</a> | 
  <a class="link" href="http://www.apple.com/privacy/" target="_blank" rel="external">Privacy Policy</a> | 
  Updated: 2017-09-12
</p>
  </section>
</article>

    </div>
    <div id='big_button'></div>
    <footer id="footer">
  <div class="content-wrapper">
  	<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
  </div>
  <script src="../../../../Resources/1264/JavaScript/devpubs-1.6.3.js" type="text/javascript" charset="utf-8"></script>
  <script src="../../../../Resources/1264/JavaScript/feedback-1.6.3.js" type="text/javascript" charset="utf-8"></script>
  <div id="_omniture_top">
<!-- SiteCatalyst code version: H.8. Copyright 1997-2006 Omniture, Inc. -->
<script type="text/javascript">
/* RSID: */
var s_account="appleglobal,appleusdeveloper,dappdeveloperlib"
</script>

<!-- <script type="text/javascript" src="https://www.apple.com/metrics/scripts/s_code_h.js"></script> -->
<script type="text/javascript">
s.pageName=AC.Tracking.pageName();
s.channel="www.us.developer"

/************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
var s_code=s.t();if(s_code)document.write(s_code)</script>
<!-- End SiteCatalyst code version: H.8. -->
</div>

</footer>

    
  </body>
    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="https://developer.apple.com/bugreporter/" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

</div>
</html>
